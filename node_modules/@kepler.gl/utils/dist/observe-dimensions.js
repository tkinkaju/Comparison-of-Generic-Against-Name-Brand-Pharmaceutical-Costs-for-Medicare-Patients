// Copyright (c) 2022 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.observeDimensions = observeDimensions;
exports.unobserveDimensions = unobserveDimensions;
exports["default"] = useDimensions;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _lodash = _interopRequireDefault(require("lodash.throttle"));

var _react = require("react");

var _resizeObserverPolyfill = _interopRequireDefault(require("resize-observer-polyfill"));

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var DEFAULT_THROTTLE_DELAY = 100; // Using a single ResizeObserver for all elements can be 10x
// more performant than using a separate ResizeObserver per element
// https://groups.google.com/a/chromium.org/forum/#!msg/blink-dev/z6ienONUb5A/F5-VcUZtBAAJ

var _observerRegistry;

function getObserverRegistry() {
  if (_observerRegistry === undefined) {
    var callbacks = new Map();
    var resizeObserver = new _resizeObserverPolyfill["default"](function (entries, observer) {
      var _iterator = _createForOfIteratorHelper(entries),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var _callbacks$get;

          var entry = _step.value;
          (_callbacks$get = callbacks.get(entry.target)) === null || _callbacks$get === void 0 ? void 0 : _callbacks$get(entry, observer);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    });
    _observerRegistry = {
      subscribe: function subscribe(target, callback) {
        resizeObserver.observe(target);
        callbacks.set(target, callback);
      },
      unsubscribe: function unsubscribe(target) {
        resizeObserver.unobserve(target);
        callbacks["delete"](target);
      }
    };
  }

  return _observerRegistry;
}

function observeDimensions(target, handleResize) {
  var throttleDelay = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_THROTTLE_DELAY;
  var registry = getObserverRegistry();
  var handler = throttleDelay > 0 ? (0, _lodash["default"])(handleResize, throttleDelay) : handleResize;
  registry.subscribe(target, function (entry) {
    return handler(getSize(target, entry));
  });
}

function unobserveDimensions(target) {
  var registry = getObserverRegistry();
  registry.unsubscribe(target);
}

function getSize(node, entry) {
  if (entry.contentRect) {
    var _entry$contentRect = entry.contentRect,
        width = _entry$contentRect.width,
        height = _entry$contentRect.height;
    return {
      width: width,
      height: height
    };
  }

  if (node.getBoundingClientRect) {
    var _node$getBoundingClie = node.getBoundingClientRect(),
        _width = _node$getBoundingClie.width,
        _height = _node$getBoundingClie.height;

    return {
      width: _width,
      height: _height
    };
  }

  return null;
}
/**
 * Usage example:
 * const [ref, dimensions] = useDimensions<HTMLDivElement>();
 *
 * @param throttleDelay
 * @returns
 */


function useDimensions() {
  var throttleDelay = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_THROTTLE_DELAY;
  var ref = (0, _react.useRef)(null);

  var _useState = (0, _react.useState)(null),
      _useState2 = (0, _slicedToArray2["default"])(_useState, 2),
      size = _useState2[0],
      setSize = _useState2[1];

  (0, _react.useEffect)(function () {
    var current = ref.current;

    if (!current) {
      return;
    }

    var didUnobserve = false;
    observeDimensions(current, function (entry) {
      if (didUnobserve) return;
      var newSize = getSize(current, entry);

      if (newSize) {
        // @ts-ignore
        setSize(newSize);
      }
    }, throttleDelay);
    return function () {
      didUnobserve = true;
      unobserveDimensions(current);
    }; // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [throttleDelay]);
  return [ref, size];
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9vYnNlcnZlLWRpbWVuc2lvbnMudHMiXSwibmFtZXMiOlsiREVGQVVMVF9USFJPVFRMRV9ERUxBWSIsIl9vYnNlcnZlclJlZ2lzdHJ5IiwiZ2V0T2JzZXJ2ZXJSZWdpc3RyeSIsInVuZGVmaW5lZCIsImNhbGxiYWNrcyIsIk1hcCIsInJlc2l6ZU9ic2VydmVyIiwiUmVzaXplT2JzZXJ2ZXIiLCJlbnRyaWVzIiwib2JzZXJ2ZXIiLCJlbnRyeSIsImdldCIsInRhcmdldCIsInN1YnNjcmliZSIsImNhbGxiYWNrIiwib2JzZXJ2ZSIsInNldCIsInVuc3Vic2NyaWJlIiwidW5vYnNlcnZlIiwib2JzZXJ2ZURpbWVuc2lvbnMiLCJoYW5kbGVSZXNpemUiLCJ0aHJvdHRsZURlbGF5IiwicmVnaXN0cnkiLCJoYW5kbGVyIiwiZ2V0U2l6ZSIsInVub2JzZXJ2ZURpbWVuc2lvbnMiLCJub2RlIiwiY29udGVudFJlY3QiLCJ3aWR0aCIsImhlaWdodCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsInVzZURpbWVuc2lvbnMiLCJyZWYiLCJzaXplIiwic2V0U2l6ZSIsImN1cnJlbnQiLCJkaWRVbm9ic2VydmUiLCJuZXdTaXplIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBb0JBOztBQUNBOztBQUNBOzs7Ozs7OztBQU9BLElBQU1BLHNCQUFzQixHQUFHLEdBQS9CLEMsQ0FFQTtBQUNBO0FBQ0E7O0FBQ0EsSUFBSUMsaUJBQUo7O0FBRUEsU0FBU0MsbUJBQVQsR0FBK0I7QUFDN0IsTUFBSUQsaUJBQWlCLEtBQUtFLFNBQTFCLEVBQXFDO0FBQ25DLFFBQU1DLFNBQVMsR0FBRyxJQUFJQyxHQUFKLEVBQWxCO0FBQ0EsUUFBTUMsY0FBYyxHQUFHLElBQUlDLGtDQUFKLENBQW1CLFVBQUNDLE9BQUQsRUFBVUMsUUFBVixFQUF1QjtBQUFBLGlEQUMzQ0QsT0FEMkM7QUFBQTs7QUFBQTtBQUMvRCw0REFBNkI7QUFBQTs7QUFBQSxjQUFsQkUsS0FBa0I7QUFDM0Is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VUFBTUMsT0FBTyxHQUFHYixPQUFPLENBQUNXLE9BQUQsRUFBVXpCLEtBQVYsQ0FBdkI7O0FBQ0EsVUFBSTJCLE9BQUosRUFBYTtBQUNYO0FBQ0FILFFBQUFBLE9BQU8sQ0FBQ0csT0FBRCxDQUFQO0FBQ0Q7QUFDRixLQVRjLEVBVWZoQixhQVZlLENBQWpCO0FBWUEsV0FBTyxZQUFNO0FBQ1hlLE1BQUFBLFlBQVksR0FBRyxJQUFmO0FBQ0FYLE1BQUFBLG1CQUFtQixDQUFDVSxPQUFELENBQW5CO0FBQ0QsS0FIRCxDQW5CYyxDQXVCZDtBQUNELEdBeEJELEVBd0JHLENBQUNkLGFBQUQsQ0F4Qkg7QUEwQkEsU0FBTyxDQUFDVyxHQUFELEVBQU1DLElBQU4sQ0FBUDtBQUNEIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDIyIFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuaW1wb3J0IHRocm90dGxlIGZyb20gJ2xvZGFzaC50aHJvdHRsZSc7XG5pbXBvcnQge3VzZUVmZmVjdCwgdXNlUmVmLCB1c2VTdGF0ZSwgUmVmT2JqZWN0fSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUmVzaXplT2JzZXJ2ZXIgZnJvbSAncmVzaXplLW9ic2VydmVyLXBvbHlmaWxsJztcblxuZXhwb3J0IGludGVyZmFjZSBEaW1lbnNpb25zIHtcbiAgcmVhZG9ubHkgaGVpZ2h0OiBudW1iZXI7XG4gIHJlYWRvbmx5IHdpZHRoOiBudW1iZXI7XG59XG5cbmNvbnN0IERFRkFVTFRfVEhST1RUTEVfREVMQVkgPSAxMDA7XG5cbi8vIFVzaW5nIGEgc2luZ2xlIFJlc2l6ZU9ic2VydmVyIGZvciBhbGwgZWxlbWVudHMgY2FuIGJlIDEweFxuLy8gbW9yZSBwZXJmb3JtYW50IHRoYW4gdXNpbmcgYSBzZXBhcmF0ZSBSZXNpemVPYnNlcnZlciBwZXIgZWxlbWVudFxuLy8gaHR0cHM6Ly9ncm91cHMuZ29vZ2xlLmNvbS9hL2Nocm9taXVtLm9yZy9mb3J1bS8jIW1zZy9ibGluay1kZXYvejZpZW5PTlViNUEvRjUtVmNVWnRCQUFKXG5sZXQgX29ic2VydmVyUmVnaXN0cnk7XG5cbmZ1bmN0aW9uIGdldE9ic2VydmVyUmVnaXN0cnkoKSB7XG4gIGlmIChfb2JzZXJ2ZXJSZWdpc3RyeSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc3QgY2FsbGJhY2tzID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IHJlc2l6ZU9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKChlbnRyaWVzLCBvYnNlcnZlcikgPT4ge1xuICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiBlbnRyaWVzKSB7XG4gICAgICAgIGNhbGxiYWNrcy5nZXQoZW50cnkudGFyZ2V0KT8uKGVudHJ5LCBvYnNlcnZlcik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgX29ic2VydmVyUmVnaXN0cnkgPSB7XG4gICAgICBzdWJzY3JpYmUodGFyZ2V0LCBjYWxsYmFjaykge1xuICAgICAgICByZXNpemVPYnNlcnZlci5vYnNlcnZlKHRhcmdldCk7XG4gICAgICAgIGNhbGxiYWNrcy5zZXQodGFyZ2V0LCBjYWxsYmFjayk7XG4gICAgICB9LFxuICAgICAgdW5zdWJzY3JpYmUodGFyZ2V0KSB7XG4gICAgICAgIHJlc2l6ZU9ic2VydmVyLnVub2JzZXJ2ZSh0YXJnZXQpO1xuICAgICAgICBjYWxsYmFja3MuZGVsZXRlKHRhcmdldCk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICByZXR1cm4gX29ic2VydmVyUmVnaXN0cnk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBvYnNlcnZlRGltZW5zaW9ucyhcbiAgdGFyZ2V0OiBFbGVtZW50LFxuICBoYW5kbGVSZXNpemU6IChzaXplOiBEaW1lbnNpb25zIHwgbnVsbCkgPT4gdm9pZCxcbiAgdGhyb3R0bGVEZWxheSA9IERFRkFVTFRfVEhST1RUTEVfREVMQVlcbikge1xuICBjb25zdCByZWdpc3RyeSA9IGdldE9ic2VydmVyUmVnaXN0cnkoKTtcbiAgY29uc3QgaGFuZGxlciA9IHRocm90dGxlRGVsYXkgPiAwID8gdGhyb3R0bGUoaGFuZGxlUmVzaXplLCB0aHJvdHRsZURlbGF5KSA6IGhhbmRsZVJlc2l6ZTtcbiAgcmVnaXN0cnkuc3Vic2NyaWJlKHRhcmdldCwgZW50cnkgPT4gaGFuZGxlcihnZXRTaXplKHRhcmdldCwgZW50cnkpKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1bm9ic2VydmVEaW1lbnNpb25zKHRhcmdldDogRWxlbWVudCkge1xuICBjb25zdCByZWdpc3RyeSA9IGdldE9ic2VydmVyUmVnaXN0cnkoKTtcbiAgcmVnaXN0cnkudW5zdWJzY3JpYmUodGFyZ2V0KTtcbn1cblxuZnVuY3Rpb24gZ2V0U2l6ZShub2RlLCBlbnRyeSk6IERpbWVuc2lvbnMgfCBudWxsIHtcbiAgaWYgKGVudHJ5LmNvbnRlbnRSZWN0KSB7XG4gICAgY29uc3Qge3dpZHRoLCBoZWlnaHR9ID0gZW50cnkuY29udGVudFJlY3Q7XG4gICAgcmV0dXJuIHt3aWR0aCwgaGVpZ2h0fTtcbiAgfVxuICBpZiAobm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QpIHtcbiAgICBjb25zdCB7d2lkdGgsIGhlaWdodH0gPSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHJldHVybiB7d2lkdGgsIGhlaWdodH07XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogVXNhZ2UgZXhhbXBsZTpcbiAqIGNvbnN0IFtyZWYsIGRpbWVuc2lvbnNdID0gdXNlRGltZW5zaW9uczxIVE1MRGl2RWxlbWVudD4oKTtcbiAqXG4gKiBAcGFyYW0gdGhyb3R0bGVEZWxheVxuICogQHJldHVybnNcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdXNlRGltZW5zaW9uczxUIGV4dGVuZHMgRWxlbWVudD4oXG4gIHRocm90dGxlRGVsYXkgPSBERUZBVUxUX1RIUk9UVExFX0RFTEFZXG4pOiBbUmVmT2JqZWN0PFQ+LCBEaW1lbnNpb25zIHwgbnVsbF0ge1xuICBjb25zdCByZWYgPSB1c2VSZWY8VD4obnVsbCk7XG4gIGNvbnN0IFtzaXplLCBzZXRTaXplXSA9IHVzZVN0YXRlKG51bGwpO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3Qge2N1cnJlbnR9ID0gcmVmO1xuICAgIGlmICghY3VycmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCBkaWRVbm9ic2VydmUgPSBmYWxzZTtcbiAgICBvYnNlcnZlRGltZW5zaW9ucyhcbiAgICAgIGN1cnJlbnQsXG4gICAgICBlbnRyeSA9PiB7XG4gICAgICAgIGlmIChkaWRVbm9ic2VydmUpIHJldHVybjtcbiAgICAgICAgY29uc3QgbmV3U2l6ZSA9IGdldFNpemUoY3VycmVudCwgZW50cnkpO1xuICAgICAgICBpZiAobmV3U2l6ZSkge1xuICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICBzZXRTaXplKG5ld1NpemUpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdGhyb3R0bGVEZWxheVxuICAgICk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGRpZFVub2JzZXJ2ZSA9IHRydWU7XG4gICAgICB1bm9ic2VydmVEaW1lbnNpb25zKGN1cnJlbnQpO1xuICAgIH07XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICB9LCBbdGhyb3R0bGVEZWxheV0pO1xuXG4gIHJldHVybiBbcmVmLCBzaXplXTtcbn1cbiJdfQ==