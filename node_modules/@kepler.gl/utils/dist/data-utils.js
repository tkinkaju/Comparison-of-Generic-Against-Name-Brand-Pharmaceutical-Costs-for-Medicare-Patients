// Copyright (c) 2022 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.unique = unique;
exports.getLatLngBounds = getLatLngBounds;
exports.clamp = clamp;
exports.getSampleData = getSampleData;
exports.timeToUnixMilli = timeToUnixMilli;
exports.notNullorUndefined = notNullorUndefined;
exports.isNumber = isNumber;
exports.isPlainObject = isPlainObject;
exports.hasOwnProperty = hasOwnProperty;
exports.numberSort = numberSort;
exports.getSortingFunction = getSortingFunction;
exports.preciseRound = preciseRound;
exports.getRoundingDecimalFromStep = getRoundingDecimalFromStep;
exports.snapToMarks = snapToMarks;
exports.normalizeSliderValue = normalizeSliderValue;
exports.roundValToStep = roundValToStep;
exports.getFormatter = getFormatter;
exports.applyDefaultFormat = applyDefaultFormat;
exports.getBooleanFormatter = getBooleanFormatter;
exports.applyCustomFormat = applyCustomFormat;
exports.datetimeFormatter = datetimeFormatter;
exports.arrayMove = exports.parseFieldValue = exports.FIELD_DISPLAY_FORMAT = exports.defaultFormatter = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _assert = _interopRequireDefault(require("assert"));

var _constants = require("@kepler.gl/constants");

var _d3Format = require("d3-format");

var _d3Array = require("d3-array");

var _momentTimezone = _interopRequireDefault(require("moment-timezone"));

var _FIELD_DISPLAY_FORMAT;

/**
 * simple getting unique values of an array
 *
 * @param values
 * @returns unique values
 */
function unique(values) {
  var results = [];
  var uniqueSet = new Set(values);
  uniqueSet.forEach(function (v) {
    if (notNullorUndefined(v)) {
      results.push(v);
    }
  });
  return results;
}

function getLatLngBounds(points, idx, limit) {
  var lats = points.map(function (d) {
    return Number(Array.isArray(d)) && d[idx];
  }).filter(Number.isFinite).sort(numberSort);

  if (!lats.length) {
    return null;
  } // clamp to limit


  return [Math.max(lats[0], limit[0]), Math.min(lats[lats.length - 1], limit[1])];
}

function clamp(_ref) {
  var _ref2 = (0, _slicedToArray2["default"])(_ref, 2),
      min = _ref2[0],
      max = _ref2[1];

  var val = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  return val <= min ? min : val >= max ? max : val;
}

function getSampleData(data) {
  var sampleSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 500;
  var getValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function (d) {
    return d;
  };
  var sampleStep = Math.max(Math.floor(data.length / sampleSize), 1);
  var output = [];

  for (var i = 0; i < data.length; i += sampleStep) {
    output.push(getValue(data[i]));
  }

  return output;
}
/**
 * Convert different time format to unix milliseconds
 */


function timeToUnixMilli(value, format) {
  if (notNullorUndefined(value)) {
    if (typeof value === 'string') {
      return _momentTimezone["default"].utc(value, format).valueOf();
    }

    if (typeof value === 'number') {
      return format === 'x' ? value * 1000 : value;
    }

    if (value instanceof Date) {
      return value.valueOf();
    }
  }

  return null;
}
/**
 * whether null or undefined
 */


function notNullorUndefined(d) {
  return d !== undefined && d !== null;
}
/**
 * Whether d is a number, this filtered out NaN as well
 */


function isNumber(d) {
  return Number.isFinite(d);
}
/**
 * whether is an object
 * @returns {boolean} - yes or no
 */


function isPlainObject(obj) {
  return obj === Object(obj) && typeof obj !== 'function' && !Array.isArray(obj);
}
/**
 * whether object has property
 * @param {string} prop
 * @returns {boolean} - yes or no
 */


function hasOwnProperty(obj, prop) {
  return obj.hasOwnProperty(prop);
}

function numberSort(a, b) {
  return a - b;
}

function getSortingFunction(fieldType) {
  switch (fieldType) {
    case _constants.ALL_FIELD_TYPES.real:
    case _constants.ALL_FIELD_TYPES.integer:
    case _constants.ALL_FIELD_TYPES.timestamp:
      return numberSort;

    default:
      return undefined;
  }
}
/**
 * round number with exact number of decimals
 * return as a string
 */


function preciseRound(num, decimals) {
  var t = Math.pow(10, decimals);
  return (Math.round(num * t + (decimals > 0 ? 1 : 0) * (Math.sign(num) * (10 / Math.pow(100, decimals)))) / t).toFixed(decimals);
}
/**
 * get number of decimals to round to for slider from step
 * @param step
 * @returns- number of decimal
 */


function getRoundingDecimalFromStep(step) {
  if (isNaN(step)) {
    (0, _assert["default"])('step is not a number');
    (0, _assert["default"])(step);
  }

  var splitZero = step.toString().split('.');

  if (splitZero.length === 1) {
    return 0;
  }

  return splitZero[1].length;
}
/**
 * Use in slider, given a number and an array of numbers, return the nears number from the array
 * @param value
 * @param marks
 */


function snapToMarks(value, marks) {
  // always use bin x0
  var i = (0, _d3Array.bisectLeft)(marks, value);

  if (i === 0) {
    return marks[i];
  } else if (i === marks.length) {
    return marks[i - 1];
  }

  var idx = marks[i] - value < value - marks[i - 1] ? i : i - 1;
  return marks[idx];
}
/**
 * If marks is provided, snap to marks, if not normalize to step
 * @param val
 * @param minValue
 * @param step
 * @param marks
 */


function normalizeSliderValue(val, minValue, step, marks) {
  if (marks && marks.length) {
    return snapToMarks(val, marks);
  }

  return roundValToStep(minValue, step, val);
}
/**
 * round the value to step for the slider
 * @param minValue
 * @param step
 * @param val
 * @returns - rounded number
 */


function roundValToStep(minValue, step, val) {
  if (!isNumber(step) || !isNumber(minValue)) {
    return val;
  }

  var decimal = getRoundingDecimalFromStep(step);
  var steps = Math.floor((val - minValue) / step);
  var remain = val - (steps * step + minValue); // has to round because javascript turns 0.1 into 0.9999999999999987

  remain = Number(preciseRound(remain, 8));
  var closest;

  if (remain === 0) {
    closest = val;
  } else if (remain < step / 2) {
    closest = steps * step + minValue;
  } else {
    closest = (steps + 1) * step + minValue;
  } // precise round return a string rounded to the defined decimal


  var rounded = preciseRound(closest, decimal);
  return Number(rounded);
}
/**
 * Get the value format based on field and format options
 * Used in render tooltip value
 */


var defaultFormatter = function defaultFormatter(v) {
  return notNullorUndefined(v) ? String(v) : '';
};

exports.defaultFormatter = defaultFormatter;
var FIELD_DISPLAY_FORMAT = (_FIELD_DISPLAY_FORMAT = {}, (0, _defineProperty2["default"])(_FIELD_DISPLAY_FORMAT, _constants.ALL_FIELD_TYPES.string, defaultFormatter), (0, _defineProperty2["default"])(_FIELD_DISPLAY_FORMAT, _constants.ALL_FIELD_TYPES.timestamp, defaultFormatter), (0, _defineProperty2["default"])(_FIELD_DISPLAY_FORMAT, _constants.ALL_FIELD_TYPES.integer, defaultFormatter), (0, _defineProperty2["default"])(_FIELD_DISPLAY_FORMAT, _constants.ALL_FIELD_TYPES.real, defaultFormatter), (0, _defineProperty2["default"])(_FIELD_DISPLAY_FORMAT, _constants.ALL_FIELD_TYPES["boolean"], defaultFormatter), (0, _defineProperty2["default"])(_FIELD_DISPLAY_FORMAT, _constants.ALL_FIELD_TYPES.date, defaultFormatter), (0, _defineProperty2["default"])(_FIELD_DISPLAY_FORMAT, _constants.ALL_FIELD_TYPES.geojson, function (d) {
  return typeof d === 'string' ? d : isPlainObject(d) ? JSON.stringify(d) : Array.isArray(d) ? "[".concat(String(d), "]") : '';
}), _FIELD_DISPLAY_FORMAT);
/**
 * Parse field value and type and return a string representation
 */

exports.FIELD_DISPLAY_FORMAT = FIELD_DISPLAY_FORMAT;

var parseFieldValue = function parseFieldValue(value, type) {
  if (!notNullorUndefined(value)) {
    return '';
  }

  return FIELD_DISPLAY_FORMAT[type] ? FIELD_DISPLAY_FORMAT[type](value) : String(value);
};

exports.parseFieldValue = parseFieldValue;

var arrayMoveMutate = function arrayMoveMutate(array, from, to) {
  array.splice(to < 0 ? array.length + to : to, 0, array.splice(from, 1)[0]);
};
/**
 *
 * @param array
 * @param from
 * @param to
 */


var arrayMove = function arrayMove(array, from, to) {
  array = array.slice();
  arrayMoveMutate(array, from, to);
  return array;
};
/**
 * Get the value format based on field and format options
 * Used in render tooltip value
 * @param format
 * @param field
 */


exports.arrayMove = arrayMove;

function getFormatter(format, field) {
  if (!format) {
    return defaultFormatter;
  }

  var tooltipFormat = Object.values(_constants.TOOLTIP_FORMATS).find(function (f) {
    return f[_constants.TOOLTIP_KEY] === format;
  });

  if (tooltipFormat) {
    return applyDefaultFormat(tooltipFormat);
  } else if (typeof format === 'string' && field) {
    return applyCustomFormat(format, field);
  }

  return defaultFormatter;
}

function applyDefaultFormat(tooltipFormat) {
  if (!tooltipFormat || !tooltipFormat.format) {
    return defaultFormatter;
  }

  switch (tooltipFormat.type) {
    case _constants.TOOLTIP_FORMAT_TYPES.DECIMAL:
      return (0, _d3Format.format)(tooltipFormat.format);

    case _constants.TOOLTIP_FORMAT_TYPES.DATE:
    case _constants.TOOLTIP_FORMAT_TYPES.DATE_TIME:
      return datetimeFormatter(null)(tooltipFormat.format);

    case _constants.TOOLTIP_FORMAT_TYPES.PERCENTAGE:
      return function (v) {
        return "".concat((0, _d3Format.format)(_constants.TOOLTIP_FORMATS.DECIMAL_DECIMAL_FIXED_2.format)(v), "%");
      };

    case _constants.TOOLTIP_FORMAT_TYPES.BOOLEAN:
      return getBooleanFormatter(tooltipFormat.format);

    default:
      return defaultFormatter;
  }
}

function getBooleanFormatter(format) {
  switch (format) {
    case '01':
      return function (v) {
        return v ? '1' : '0';
      };

    case 'yn':
      return function (v) {
        return v ? 'yes' : 'no';
      };

    default:
      return defaultFormatter;
  }
} // Allow user to specify custom tooltip format via config


function applyCustomFormat(format, field) {
  switch (field.type) {
    case _constants.ALL_FIELD_TYPES.real:
    case _constants.ALL_FIELD_TYPES.integer:
      return (0, _d3Format.format)(format);

    case _constants.ALL_FIELD_TYPES.date:
    case _constants.ALL_FIELD_TYPES.timestamp:
      return datetimeFormatter(null)(format);

    default:
      return function (v) {
        return v;
      };
  }
}
/**
 * Format epoch milliseconds with a format string
 * @type timezone
 */


function datetimeFormatter(timezone) {
  return timezone ? function (format) {
    return function (ts) {
      return _momentTimezone["default"].utc(ts).tz(timezone).format(format);
    };
  } : function (format) {
    return function (ts) {
      return _momentTimezone["default"].utc(ts).format(format);
    };
  };
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9kYXRhLXV0aWxzLnRzIl0sIm5hbWVzIjpbInVuaXF1ZSIsInZhbHVlcyIsInJlc3VsdHMiLCJ1bmlxdWVTZXQiLCJTZXQiLCJmb3JFYWNoIiwidiIsIm5vdE51bGxvclVuZGVmaW5lZCIsInB1c2giLCJnZXRMYXRMbmdCb3VuZHMiLCJwb2ludHMiLCJpZHgiLCJsaW1pdCIsImxhdHMiLCJtYXAiLCJkIiwiTnVtYmVyIiwiQXJyYXkiLCJpc0FycmF5IiwiZmlsdGVyIiwiaXNGaW5pdGUiLCJzb3J0IiwibnVtYmVyU29ydCIsImxlbmd0aCIsIk1hdGgiLCJtYXgiLCJtaW4iLCJjbGFtcCIsInZhbCIsImdldFNhbXBsZURhdGEiLCJkYXRhIiwic2FtcGxlU2l6ZSIsImdldFZhbHVlIiwic2FtcGxlU3RlcCIsImZsb29yIiwib3V0cHV0IiwiaSIsInRpbWVUb1VuaXhNaWxsaSIsInZhbHVlIiwiZm9ybWF0IiwibW9tZW50IiwidXRjIiwidmFsdWVPZiIsIkRhdGUiLCJ1bmRlZmluZWQiLCJpc051bWJlciIsImlzUGxhaW5PYmplY3QiLCJvYmoiLCJPYmplY3QiLCJoYXNPd25Qcm9wZXJ0eSIsInByb3AiLCJhIiwiYiIsImdldFNvcnRpbmdGdW5jdGlvbiIsImZpZWxkVHlwZSIsIkFMTF9GSUVMRF9UWVBFUyIsInJlYWwiLCJpbnRlZ2VyIiwidGltZXN0YW1wIiwicHJlY2lzZVJvdW5kIiwibnVtIiwiZGVjaW1hbHMiLCJ0IiwicG93Iiwicm91bmQiLCJzaWduIiwidG9GaXhlZCIsImdldFJvdW5kaW5nRGVjaW1hbEZyb21TdGVwIiwic3RlcCIsImlzTmFOIiwic3BsaXRaZXJvIiwidG9TdHJpbmciLCJzcGxpdCIsInNuYXBUb01hcmtzIiwibWFya3MiLCJub3JtYWxpemVTbGlkZXJWYWx1ZSIsIm1pblZhbHVlIiwicm91bmRWYWxUb1N0ZXAiLCJkZWNpbWFsIiwic3RlcHMiLCJyZW1haW4iLCJjbG9zZXN0Iiwicm91bmRlZCIsImRlZmF1bHRGb3JtYXR0ZXIiLCJTdHJpbmciLCJGSUVMRF9ESVNQTEFZX0ZPUk1BVCIsInN0cmluZyIsImRhdGUiLCJnZW9qc29uIiwiSlNPTiIsInN0cmluZ2lmeSIsInBhcnNlRmllbGRWYWx1ZSIsInR5cGUiLCJhcnJheU1vdmVNdXRhdGUiLCJhcnJheSIsImZyb20iLCJ0byIsInNwbGljZSIsImFycmF5TW92ZSIsInNsaWNlIiwiZ2V0Rm9ybWF0dGVyIiwiZmllbGQiLCJ0b29sdGlwRm9ybWF0IiwiVE9PTFRJUF9GT1JNQVRTIiwiZmluZCIsImYiLCJUT09MVElQX0tFWSIsImFwcGx5RGVmYXVsdEZvcm1hdCIsImFwcGx5Q3VzdG9tRm9ybWF0IiwiVE9PTFRJUF9GT1JNQVRfVFlQRVMiLCJERUNJTUFMIiwiREFURSIsIkRBVEVfVElNRSIsImRhdGV0aW1lRm9ybWF0dGVyIiwiUEVSQ0VOVEFHRSIsIkRFQ0lNQUxfREVDSU1BTF9GSVhFRF8yIiwiQk9PTEVBTiIsImdldEJvb2xlYW5Gb3JtYXR0ZXIiLCJ0aW1lem9uZSIsInRzIiwidHoiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFvQkE7O0FBQ0E7O0FBT0E7O0FBQ0E7O0FBQ0E7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxTQUFTQSxNQUFULENBQW1CQyxNQUFuQixFQUFnQztBQUNyQyxNQUFNQyxPQUFZLEdBQUcsRUFBckI7QUFDQSxNQUFNQyxTQUFTLEdBQUcsSUFBSUMsR0FBSixDQUFRSCxNQUFSLENBQWxCO0FBQ0FFLEVBQUFBLFNBQVMsQ0FBQ0UsT0FBVixDQUFrQixVQUFBQyxDQUFDLEVBQUk7QUFDckIsUUFBSUMsa0JBQWtCLENBQUNELENBQUQsQ0FBdEIsRUFBMkI7QUFDekJKLE1BQUFBLE9BQU8sQ0FBQ00sSUFBUixDQUFhRixDQUFiO0FBQ0Q7QUFDRixHQUpEO0FBS0EsU0FBT0osT0FBUDtBQUNEOztBQUVNLFNBQVNPLGVBQVQsQ0FDTEMsTUFESyxFQUVMQyxHQUZLLEVBR0xDLEtB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TUFBZixDQUFzQkEsTUFBdEIsQ0FBSjtBQUFBLEtBQU47QUFBQSxHQU5WO0FBT0QiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMjIgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5pbXBvcnQgYXNzZXJ0IGZyb20gJ2Fzc2VydCc7XG5pbXBvcnQge1xuICBBTExfRklFTERfVFlQRVMsXG4gIFRPT0xUSVBfRk9STUFUUyxcbiAgVE9PTFRJUF9GT1JNQVRfVFlQRVMsXG4gIFRPT0xUSVBfS0VZLFxuICBUb29sdGlwRm9ybWF0XG59IGZyb20gJ0BrZXBsZXIuZ2wvY29uc3RhbnRzJztcbmltcG9ydCB7Zm9ybWF0IGFzIGQzRm9ybWF0fSBmcm9tICdkMy1mb3JtYXQnO1xuaW1wb3J0IHtiaXNlY3RMZWZ0fSBmcm9tICdkMy1hcnJheSc7XG5pbXBvcnQgbW9tZW50IGZyb20gJ21vbWVudC10aW1lem9uZSc7XG5cbmltcG9ydCB7TWlsbGlzZWNvbmQsIEZpZWxkfSBmcm9tICdAa2VwbGVyLmdsL3R5cGVzJztcblxuZXhwb3J0IHR5cGUgRmllbGRGb3JtYXR0ZXIgPSAodmFsdWU6IGFueSkgPT4gc3RyaW5nO1xuXG4vKipcbiAqIHNpbXBsZSBnZXR0aW5nIHVuaXF1ZSB2YWx1ZXMgb2YgYW4gYXJyYXlcbiAqXG4gKiBAcGFyYW0gdmFsdWVzXG4gKiBAcmV0dXJucyB1bmlxdWUgdmFsdWVzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1bmlxdWU8VD4odmFsdWVzOiBUW10pIHtcbiAgY29uc3QgcmVzdWx0czogVFtdID0gW107XG4gIGNvbnN0IHVuaXF1ZVNldCA9IG5ldyBTZXQodmFsdWVzKTtcbiAgdW5pcXVlU2V0LmZvckVhY2godiA9PiB7XG4gICAgaWYgKG5vdE51bGxvclVuZGVmaW5lZCh2KSkge1xuICAgICAgcmVzdWx0cy5wdXNoKHYpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXN1bHRzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0TGF0TG5nQm91bmRzKFxuICBwb2ludHM6IG51bWJlcltdW10sXG4gIGlkeDogbnVtYmVyLFxuICBsaW1pdDogW251bWJlciwgbnVtYmVyXVxuKTogW251bWJlciwgbnVtYmVyXSB8IG51bGwge1xuICBjb25zdCBsYXRzID0gcG9pbnRzXG4gICAgLm1hcChkID0+IE51bWJlcihBcnJheS5pc0FycmF5KGQpKSAmJiBkW2lkeF0pXG4gICAgLmZpbHRlcihOdW1iZXIuaXNGaW5pdGUpXG4gICAgLnNvcnQobnVtYmVyU29ydCk7XG5cbiAgaWYgKCFsYXRzLmxlbmd0aCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gY2xhbXAgdG8gbGltaXRcbiAgcmV0dXJuIFtNYXRoLm1heChsYXRzWzBdLCBsaW1pdFswXSksIE1hdGgubWluKGxhdHNbbGF0cy5sZW5ndGggLSAxXSwgbGltaXRbMV0pXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNsYW1wKFttaW4sIG1heF06IFtudW1iZXIsIG51bWJlcl0sIHZhbDogbnVtYmVyID0gMCk6IG51bWJlciB7XG4gIHJldHVybiB2YWwgPD0gbWluID8gbWluIDogdmFsID49IG1heCA/IG1heCA6IHZhbDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFNhbXBsZURhdGEoZGF0YSwgc2FtcGxlU2l6ZSA9IDUwMCwgZ2V0VmFsdWUgPSBkID0+IGQpIHtcbiAgY29uc3Qgc2FtcGxlU3RlcCA9IE1hdGgubWF4KE1hdGguZmxvb3IoZGF0YS5sZW5ndGggLyBzYW1wbGVTaXplKSwgMSk7XG4gIGNvbnN0IG91dHB1dDogYW55W10gPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSArPSBzYW1wbGVTdGVwKSB7XG4gICAgb3V0cHV0LnB1c2goZ2V0VmFsdWUoZGF0YVtpXSkpO1xuICB9XG5cbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGRpZmZlcmVudCB0aW1lIGZvcm1hdCB0byB1bml4IG1pbGxpc2Vjb25kc1xuICovXG5leHBvcnQgZnVuY3Rpb24gdGltZVRvVW5peE1pbGxpKHZhbHVlOiBzdHJpbmcgfCBudW1iZXIgfCBEYXRlLCBmb3JtYXQ6IHN0cmluZyk6IE1pbGxpc2Vjb25kIHwgbnVsbCB7XG4gIGlmIChub3ROdWxsb3JVbmRlZmluZWQodmFsdWUpKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBtb21lbnQudXRjKHZhbHVlLCBmb3JtYXQpLnZhbHVlT2YoKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIHJldHVybiBmb3JtYXQgPT09ICd4JyA/IHZhbHVlICogMTAwMCA6IHZhbHVlO1xuICAgIH1cbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICByZXR1cm4gdmFsdWUudmFsdWVPZigpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiB3aGV0aGVyIG51bGwgb3IgdW5kZWZpbmVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBub3ROdWxsb3JVbmRlZmluZWQ8VCBleHRlbmRzIE5vbk51bGxhYmxlPGFueT4+KGQ6IFQgfCBudWxsIHwgdW5kZWZpbmVkKTogZCBpcyBUIHtcbiAgcmV0dXJuIGQgIT09IHVuZGVmaW5lZCAmJiBkICE9PSBudWxsO1xufVxuXG4vKipcbiAqIFdoZXRoZXIgZCBpcyBhIG51bWJlciwgdGhpcyBmaWx0ZXJlZCBvdXQgTmFOIGFzIHdlbGxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzTnVtYmVyKGQ6IGFueSk6IGJvb2xlYW4ge1xuICByZXR1cm4gTnVtYmVyLmlzRmluaXRlKGQpO1xufVxuXG4vKipcbiAqIHdoZXRoZXIgaXMgYW4gb2JqZWN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSB5ZXMgb3Igbm9cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzUGxhaW5PYmplY3Qob2JqOiB1bmtub3duKTogb2JqIGlzIFJlY29yZDxzdHJpbmcsIHVua25vd24+IHtcbiAgcmV0dXJuIG9iaiA9PT0gT2JqZWN0KG9iaikgJiYgdHlwZW9mIG9iaiAhPT0gJ2Z1bmN0aW9uJyAmJiAhQXJyYXkuaXNBcnJheShvYmopO1xufVxuXG4vKipcbiAqIHdoZXRoZXIgb2JqZWN0IGhhcyBwcm9wZXJ0eVxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BcbiAqIEByZXR1cm5zIHtib29sZWFufSAtIHllcyBvciBub1xuICovXG5leHBvcnQgZnVuY3Rpb24gaGFzT3duUHJvcGVydHk8WCBleHRlbmRzIHt9LCBZIGV4dGVuZHMgUHJvcGVydHlLZXk+KFxuICBvYmo6IFgsXG4gIHByb3A6IFlcbik6IG9iaiBpcyBYICYgUmVjb3JkPFksIHVua25vd24+IHtcbiAgcmV0dXJuIG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG51bWJlclNvcnQoYTogbnVtYmVyLCBiOiBudW1iZXIpOiBudW1iZXIge1xuICByZXR1cm4gYSAtIGI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRTb3J0aW5nRnVuY3Rpb24oZmllbGRUeXBlOiBzdHJpbmcpOiB0eXBlb2YgbnVtYmVyU29ydCB8IHVuZGVmaW5lZCB7XG4gIHN3aXRjaCAoZmllbGRUeXBlKSB7XG4gICAgY2FzZSBBTExfRklFTERfVFlQRVMucmVhbDpcbiAgICBjYXNlIEFMTF9GSUVMRF9UWVBFUy5pbnRlZ2VyOlxuICAgIGNhc2UgQUxMX0ZJRUxEX1RZUEVTLnRpbWVzdGFtcDpcbiAgICAgIHJldHVybiBudW1iZXJTb3J0O1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5cbi8qKlxuICogcm91bmQgbnVtYmVyIHdpdGggZXhhY3QgbnVtYmVyIG9mIGRlY2ltYWxzXG4gKiByZXR1cm4gYXMgYSBzdHJpbmdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByZWNpc2VSb3VuZChudW06IG51bWJlciwgZGVjaW1hbHM6IG51bWJlcik6IHN0cmluZyB7XG4gIGNvbnN0IHQgPSBNYXRoLnBvdygxMCwgZGVjaW1hbHMpO1xuICByZXR1cm4gKFxuICAgIE1hdGgucm91bmQoXG4gICAgICBudW0gKiB0ICsgKGRlY2ltYWxzID4gMCA/IDEgOiAwKSAqIChNYXRoLnNpZ24obnVtKSAqICgxMCAvIE1hdGgucG93KDEwMCwgZGVjaW1hbHMpKSlcbiAgICApIC8gdFxuICApLnRvRml4ZWQoZGVjaW1hbHMpO1xufVxuXG4vKipcbiAqIGdldCBudW1iZXIgb2YgZGVjaW1hbHMgdG8gcm91bmQgdG8gZm9yIHNsaWRlciBmcm9tIHN0ZXBcbiAqIEBwYXJhbSBzdGVwXG4gKiBAcmV0dXJucy0gbnVtYmVyIG9mIGRlY2ltYWxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFJvdW5kaW5nRGVjaW1hbEZyb21TdGVwKHN0ZXA6IG51bWJlcik6IG51bWJlciB7XG4gIGlmIChpc05hTihzdGVwKSkge1xuICAgIGFzc2VydCgnc3RlcCBpcyBub3QgYSBudW1iZXInKTtcbiAgICBhc3NlcnQoc3RlcCk7XG4gIH1cblxuICBjb25zdCBzcGxpdFplcm8gPSBzdGVwLnRvU3RyaW5nKCkuc3BsaXQoJy4nKTtcbiAgaWYgKHNwbGl0WmVyby5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICByZXR1cm4gc3BsaXRaZXJvWzFdLmxlbmd0aDtcbn1cblxuLyoqXG4gKiBVc2UgaW4gc2xpZGVyLCBnaXZlbiBhIG51bWJlciBhbmQgYW4gYXJyYXkgb2YgbnVtYmVycywgcmV0dXJuIHRoZSBuZWFycyBudW1iZXIgZnJvbSB0aGUgYXJyYXlcbiAqIEBwYXJhbSB2YWx1ZVxuICogQHBhcmFtIG1hcmtzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzbmFwVG9NYXJrcyh2YWx1ZTogbnVtYmVyLCBtYXJrczogbnVtYmVyW10pOiBudW1iZXIge1xuICAvLyBhbHdheXMgdXNlIGJpbiB4MFxuICBjb25zdCBpID0gYmlzZWN0TGVmdChtYXJrcywgdmFsdWUpO1xuICBpZiAoaSA9PT0gMCkge1xuICAgIHJldHVybiBtYXJrc1tpXTtcbiAgfSBlbHNlIGlmIChpID09PSBtYXJrcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gbWFya3NbaSAtIDFdO1xuICB9XG4gIGNvbnN0IGlkeCA9IG1hcmtzW2ldIC0gdmFsdWUgPCB2YWx1ZSAtIG1hcmtzW2kgLSAxXSA/IGkgOiBpIC0gMTtcbiAgcmV0dXJuIG1hcmtzW2lkeF07XG59XG5cbi8qKlxuICogSWYgbWFya3MgaXMgcHJvdmlkZWQsIHNuYXAgdG8gbWFya3MsIGlmIG5vdCBub3JtYWxpemUgdG8gc3RlcFxuICogQHBhcmFtIHZhbFxuICogQHBhcmFtIG1pblZhbHVlXG4gKiBAcGFyYW0gc3RlcFxuICogQHBhcmFtIG1hcmtzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemVTbGlkZXJWYWx1ZShcbiAgdmFsOiBudW1iZXIsXG4gIG1pblZhbHVlOiBudW1iZXIsXG4gIHN0ZXA6IG51bWJlcixcbiAgbWFya3M/OiBudW1iZXJbXVxuKTogbnVtYmVyIHtcbiAgaWYgKG1hcmtzICYmIG1hcmtzLmxlbmd0aCkge1xuICAgIHJldHVybiBzbmFwVG9NYXJrcyh2YWwsIG1hcmtzKTtcbiAgfVxuXG4gIHJldHVybiByb3VuZFZhbFRvU3RlcChtaW5WYWx1ZSwgc3RlcCwgdmFsKTtcbn1cblxuLyoqXG4gKiByb3VuZCB0aGUgdmFsdWUgdG8gc3RlcCBmb3IgdGhlIHNsaWRlclxuICogQHBhcmFtIG1pblZhbHVlXG4gKiBAcGFyYW0gc3RlcFxuICogQHBhcmFtIHZhbFxuICogQHJldHVybnMgLSByb3VuZGVkIG51bWJlclxuICovXG5leHBvcnQgZnVuY3Rpb24gcm91bmRWYWxUb1N0ZXAobWluVmFsdWU6IG51bWJlciwgc3RlcDogbnVtYmVyLCB2YWw6IG51bWJlcik6IG51bWJlciB7XG4gIGlmICghaXNOdW1iZXIoc3RlcCkgfHwgIWlzTnVtYmVyKG1pblZhbHVlKSkge1xuICAgIHJldHVybiB2YWw7XG4gIH1cblxuICBjb25zdCBkZWNpbWFsID0gZ2V0Um91bmRpbmdEZWNpbWFsRnJvbVN0ZXAoc3RlcCk7XG4gIGNvbnN0IHN0ZXBzID0gTWF0aC5mbG9vcigodmFsIC0gbWluVmFsdWUpIC8gc3RlcCk7XG4gIGxldCByZW1haW4gPSB2YWwgLSAoc3RlcHMgKiBzdGVwICsgbWluVmFsdWUpO1xuXG4gIC8vIGhhcyB0byByb3VuZCBiZWNhdXNlIGphdmFzY3JpcHQgdHVybnMgMC4xIGludG8gMC45OTk5OTk5OTk5OTk5OTg3XG4gIHJlbWFpbiA9IE51bWJlcihwcmVjaXNlUm91bmQocmVtYWluLCA4KSk7XG5cbiAgbGV0IGNsb3Nlc3Q6IG51bWJlcjtcbiAgaWYgKHJlbWFpbiA9PT0gMCkge1xuICAgIGNsb3Nlc3QgPSB2YWw7XG4gIH0gZWxzZSBpZiAocmVtYWluIDwgc3RlcCAvIDIpIHtcbiAgICBjbG9zZXN0ID0gc3RlcHMgKiBzdGVwICsgbWluVmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgY2xvc2VzdCA9IChzdGVwcyArIDEpICogc3RlcCArIG1pblZhbHVlO1xuICB9XG5cbiAgLy8gcHJlY2lzZSByb3VuZCByZXR1cm4gYSBzdHJpbmcgcm91bmRlZCB0byB0aGUgZGVmaW5lZCBkZWNpbWFsXG4gIGNvbnN0IHJvdW5kZWQgPSBwcmVjaXNlUm91bmQoY2xvc2VzdCwgZGVjaW1hbCk7XG5cbiAgcmV0dXJuIE51bWJlcihyb3VuZGVkKTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHZhbHVlIGZvcm1hdCBiYXNlZCBvbiBmaWVsZCBhbmQgZm9ybWF0IG9wdGlvbnNcbiAqIFVzZWQgaW4gcmVuZGVyIHRvb2x0aXAgdmFsdWVcbiAqL1xuZXhwb3J0IGNvbnN0IGRlZmF1bHRGb3JtYXR0ZXI6IEZpZWxkRm9ybWF0dGVyID0gdiA9PiAobm90TnVsbG9yVW5kZWZpbmVkKHYpID8gU3RyaW5nKHYpIDogJycpO1xuXG5leHBvcnQgY29uc3QgRklFTERfRElTUExBWV9GT1JNQVQ6IHtcbiAgW2tleTogc3RyaW5nXTogRmllbGRGb3JtYXR0ZXI7XG59ID0ge1xuICBbQUxMX0ZJRUxEX1RZUEVTLnN0cmluZ106IGRlZmF1bHRGb3JtYXR0ZXIsXG4gIFtBTExfRklFTERfVFlQRVMudGltZXN0YW1wXTogZGVmYXVsdEZvcm1hdHRlcixcbiAgW0FMTF9GSUVMRF9UWVBFUy5pbnRlZ2VyXTogZGVmYXVsdEZvcm1hdHRlcixcbiAgW0FMTF9GSUVMRF9UWVBFUy5yZWFsXTogZGVmYXVsdEZvcm1hdHRlcixcbiAgW0FMTF9GSUVMRF9UWVBFUy5ib29sZWFuXTogZGVmYXVsdEZvcm1hdHRlcixcbiAgW0FMTF9GSUVMRF9UWVBFUy5kYXRlXTogZGVmYXVsdEZvcm1hdHRlcixcbiAgW0FMTF9GSUVMRF9UWVBFUy5nZW9qc29uXTogZCA9PlxuICAgIHR5cGVvZiBkID09PSAnc3RyaW5nJ1xuICAgICAgPyBkXG4gICAgICA6IGlzUGxhaW5PYmplY3QoZClcbiAgICAgID8gSlNPTi5zdHJpbmdpZnkoZClcbiAgICAgIDogQXJyYXkuaXNBcnJheShkKVxuICAgICAgPyBgWyR7U3RyaW5nKGQpfV1gXG4gICAgICA6ICcnXG59O1xuXG4vKipcbiAqIFBhcnNlIGZpZWxkIHZhbHVlIGFuZCB0eXBlIGFuZCByZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50YXRpb25cbiAqL1xuZXhwb3J0IGNvbnN0IHBhcnNlRmllbGRWYWx1ZSA9ICh2YWx1ZTogYW55LCB0eXBlOiBzdHJpbmcpOiBzdHJpbmcgPT4ge1xuICBpZiAoIW5vdE51bGxvclVuZGVmaW5lZCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICByZXR1cm4gRklFTERfRElTUExBWV9GT1JNQVRbdHlwZV0gPyBGSUVMRF9ESVNQTEFZX0ZPUk1BVFt0eXBlXSh2YWx1ZSkgOiBTdHJpbmcodmFsdWUpO1xufTtcblxuY29uc3QgYXJyYXlNb3ZlTXV0YXRlID0gPFQ+KGFycmF5OiBUW10sIGZyb206IG51bWJlciwgdG86IG51bWJlcikgPT4ge1xuICBhcnJheS5zcGxpY2UodG8gPCAwID8gYXJyYXkubGVuZ3RoICsgdG8gOiB0bywgMCwgYXJyYXkuc3BsaWNlKGZyb20sIDEpWzBdKTtcbn07XG5cbi8qKlxuICpcbiAqIEBwYXJhbSBhcnJheVxuICogQHBhcmFtIGZyb21cbiAqIEBwYXJhbSB0b1xuICovXG5leHBvcnQgY29uc3QgYXJyYXlNb3ZlID0gPFQ+KGFycmF5OiBUW10sIGZyb206IG51bWJlciwgdG86IG51bWJlcikgPT4ge1xuICBhcnJheSA9IGFycmF5LnNsaWNlKCk7XG4gIGFycmF5TW92ZU11dGF0ZShhcnJheSwgZnJvbSwgdG8pO1xuICByZXR1cm4gYXJyYXk7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgdmFsdWUgZm9ybWF0IGJhc2VkIG9uIGZpZWxkIGFuZCBmb3JtYXQgb3B0aW9uc1xuICogVXNlZCBpbiByZW5kZXIgdG9vbHRpcCB2YWx1ZVxuICogQHBhcmFtIGZvcm1hdFxuICogQHBhcmFtIGZpZWxkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRGb3JtYXR0ZXIoXG4gIGZvcm1hdDogc3RyaW5nIHwgUmVjb3JkPHN0cmluZywgc3RyaW5nPixcbiAgZmllbGQ/OiBGaWVsZFxuKTogRmllbGRGb3JtYXR0ZXIge1xuICBpZiAoIWZvcm1hdCkge1xuICAgIHJldHVybiBkZWZhdWx0Rm9ybWF0dGVyO1xuICB9XG4gIGNvbnN0IHRvb2x0aXBGb3JtYXQgPSBPYmplY3QudmFsdWVzKFRPT0xUSVBfRk9STUFUUykuZmluZChmID0+IGZbVE9PTFRJUF9LRVldID09PSBmb3JtYXQpO1xuXG4gIGlmICh0b29sdGlwRm9ybWF0KSB7XG4gICAgcmV0dXJuIGFwcGx5RGVmYXVsdEZvcm1hdCh0b29sdGlwRm9ybWF0IGFzIFRvb2x0aXBGb3JtYXQpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBmb3JtYXQgPT09ICdzdHJpbmcnICYmIGZpZWxkKSB7XG4gICAgcmV0dXJuIGFwcGx5Q3VzdG9tRm9ybWF0KGZvcm1hdCwgZmllbGQpO1xuICB9XG5cbiAgcmV0dXJuIGRlZmF1bHRGb3JtYXR0ZXI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhcHBseURlZmF1bHRGb3JtYXQodG9vbHRpcEZvcm1hdDogVG9vbHRpcEZvcm1hdCk6ICh2OiBhbnkpID0+IHN0cmluZyB7XG4gIGlmICghdG9vbHRpcEZvcm1hdCB8fCAhdG9vbHRpcEZvcm1hdC5mb3JtYXQpIHtcbiAgICByZXR1cm4gZGVmYXVsdEZvcm1hdHRlcjtcbiAgfVxuXG4gIHN3aXRjaCAodG9vbHRpcEZvcm1hdC50eXBlKSB7XG4gICAgY2FzZSBUT09MVElQX0ZPUk1BVF9UWVBFUy5ERUNJTUFMOlxuICAgICAgcmV0dXJuIGQzRm9ybWF0KHRvb2x0aXBGb3JtYXQuZm9ybWF0KTtcbiAgICBjYXNlIFRPT0xUSVBfRk9STUFUX1RZUEVTLkRBVEU6XG4gICAgY2FzZSBUT09MVElQX0ZPUk1BVF9UWVBFUy5EQVRFX1RJTUU6XG4gICAgICByZXR1cm4gZGF0ZXRpbWVGb3JtYXR0ZXIobnVsbCkodG9vbHRpcEZvcm1hdC5mb3JtYXQpO1xuICAgIGNhc2UgVE9PTFRJUF9GT1JNQVRfVFlQRVMuUEVSQ0VOVEFHRTpcbiAgICAgIHJldHVybiB2ID0+IGAke2QzRm9ybWF0KFRPT0xUSVBfRk9STUFUUy5ERUNJTUFMX0RFQ0lNQUxfRklYRURfMi5mb3JtYXQpKHYpfSVgO1xuICAgIGNhc2UgVE9PTFRJUF9GT1JNQVRfVFlQRVMuQk9PTEVBTjpcbiAgICAgIHJldHVybiBnZXRCb29sZWFuRm9ybWF0dGVyKHRvb2x0aXBGb3JtYXQuZm9ybWF0KTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGRlZmF1bHRGb3JtYXR0ZXI7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEJvb2xlYW5Gb3JtYXR0ZXIoZm9ybWF0OiBzdHJpbmcpOiBGaWVsZEZvcm1hdHRlciB7XG4gIHN3aXRjaCAoZm9ybWF0KSB7XG4gICAgY2FzZSAnMDEnOlxuICAgICAgcmV0dXJuICh2OiBCb29sZWFuKSA9PiAodiA/ICcxJyA6ICcwJyk7XG4gICAgY2FzZSAneW4nOlxuICAgICAgcmV0dXJuICh2OiBCb29sZWFuKSA9PiAodiA/ICd5ZXMnIDogJ25vJyk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBkZWZhdWx0Rm9ybWF0dGVyO1xuICB9XG59XG4vLyBBbGxvdyB1c2VyIHRvIHNwZWNpZnkgY3VzdG9tIHRvb2x0aXAgZm9ybWF0IHZpYSBjb25maWdcbmV4cG9ydCBmdW5jdGlvbiBhcHBseUN1c3RvbUZvcm1hdChmb3JtYXQsIGZpZWxkKTogRmllbGRGb3JtYXR0ZXIge1xuICBzd2l0Y2ggKGZpZWxkLnR5cGUpIHtcbiAgICBjYXNlIEFMTF9GSUVMRF9UWVBFUy5yZWFsOlxuICAgIGNhc2UgQUxMX0ZJRUxEX1RZUEVTLmludGVnZXI6XG4gICAgICByZXR1cm4gZDNGb3JtYXQoZm9ybWF0KTtcbiAgICBjYXNlIEFMTF9GSUVMRF9UWVBFUy5kYXRlOlxuICAgIGNhc2UgQUxMX0ZJRUxEX1RZUEVTLnRpbWVzdGFtcDpcbiAgICAgIHJldHVybiBkYXRldGltZUZvcm1hdHRlcihudWxsKShmb3JtYXQpO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdiA9PiB2O1xuICB9XG59XG5cbi8qKlxuICogRm9ybWF0IGVwb2NoIG1pbGxpc2Vjb25kcyB3aXRoIGEgZm9ybWF0IHN0cmluZ1xuICogQHR5cGUgdGltZXpvbmVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRhdGV0aW1lRm9ybWF0dGVyKFxuICB0aW1lem9uZT86IHN0cmluZyB8IG51bGxcbik6IChmb3JtYXQ/OiBzdHJpbmcpID0+ICh0czogbnVtYmVyKSA9PiBzdHJpbmcge1xuICByZXR1cm4gdGltZXpvbmVcbiAgICA/IGZvcm1hdCA9PiB0cyA9PlxuICAgICAgICBtb21lbnRcbiAgICAgICAgICAudXRjKHRzKVxuICAgICAgICAgIC50eih0aW1lem9uZSlcbiAgICAgICAgICAuZm9ybWF0KGZvcm1hdClcbiAgICA6IGZvcm1hdCA9PiB0cyA9PiBtb21lbnQudXRjKHRzKS5mb3JtYXQoZm9ybWF0KTtcbn1cbiJdfQ==