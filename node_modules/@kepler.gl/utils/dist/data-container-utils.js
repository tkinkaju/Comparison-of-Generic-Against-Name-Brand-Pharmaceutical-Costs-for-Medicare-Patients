// Copyright (c) 2022 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createDataContainer = createDataContainer;
exports.createIndexedDataContainer = createIndexedDataContainer;
exports.getSampleData = getSampleData;
exports.DataForm = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _rowDataContainer = require("./row-data-container");

var _indexedDataContainer = require("./indexed-data-container");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var DataForm = {
  ROWS_ARRAY: 'ROWS_ARRAY'
};
exports.DataForm = DataForm;
var defaultOptions = {
  inputDataFormat: DataForm.ROWS_ARRAY
};
/**
 * Creates a data container wrapper for the data.
 * @param data Data.
 * @param options Options.
 * @returns A data container object which is based on data and options.
 */

function createDataContainer(data) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultOptions;
  options = _objectSpread(_objectSpread({}, defaultOptions), options);

  if (options.inputDataFormat === DataForm.ROWS_ARRAY) {
    return new _rowDataContainer.RowDataContainer({
      rows: data,
      fields: options.fields
    });
  }

  throw Error('Failed to create a data container: not implemented format');
}
/**
 * Creates a data container wrapper around another data container.
 * @param dataContainer Parent data container.
 * @param indices An array of row indices in the parent data container.
 */


function createIndexedDataContainer(dataContainer, indices) {
  return new _indexedDataContainer.IndexedDataContainer(dataContainer, indices);
}
/**
 * Get a sample of rows from a data container.
 * @param dataContainer Data container to get samples from.
 * @param sampleSize Max number of samples.
 * @returns A data container which contains samples from the original data container.
 */


function getSampleData(dataContainer) {
  var sampleSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 500;
  var numberOfRows = dataContainer.numRows();
  var sampleStep = Math.max(Math.floor(numberOfRows / sampleSize), 1);
  var indices = [];

  for (var i = 0; i < numberOfRows; i += sampleStep) {
    indices.push(i);
  }

  return createIndexedDataContainer(dataContainer, indices);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9kYXRhLWNvbnRhaW5lci11dGlscy50cyJdLCJuYW1lcyI6WyJEYXRhRm9ybSIsIlJPV1NfQVJSQVkiLCJkZWZhdWx0T3B0aW9ucyIsImlucHV0RGF0YUZvcm1hdCIsImNyZWF0ZURhdGFDb250YWluZXIiLCJkYXRhIiwib3B0aW9ucyIsIlJvd0RhdGFDb250YWluZXIiLCJyb3dzIiwiZmllbGRzIiwiRXJyb3IiLCJjcmVhdGVJbmRleGVkRGF0YUNvbnRhaW5lciIsImRhdGFDb250YWluZXIiLCJpbmRpY2VzIiwiSW5kZXhlZERhdGFDb250YWluZXIiLCJnZXRTYW1wbGVEYXRhIiwic2FtcGxlU2l6ZSIsIm51bWJlck9mUm93cyIsIm51bVJvd3MiLCJzYW1wbGVTdGVwIiwiTWF0aCIsIm1heCIsImZsb29yIiwiaSIsInB1c2giXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBb0JBOztBQUNBOzs7Ozs7QUFVTyxJQUFNQSxRQUFRLEdBQUc7QUFDdEJDLEVBQUFBLFVBQVUsRUFBRTtBQURVLENBQWpCOztBQUlQLElBQU1DLGNBQW9DLEdBQUc7QUFDM0NDLEVBQUFBLGVBQWUsRUFBRUgsUUFBUSxDQUFDQztBQURpQixDQUE3QztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDTyxTQUFTRyxtQkFBVCxDQUNMQyxJQURLLEVBR21CO0FBQUEsTUFEeEJDLE9BQ3dCLHVFQURRSixjQUNSO0FBQ3hCSSxFQUFBQSxPQUFPLG1DQUFPSixjQUFQLEdBQTBCSSxPQUExQixDQUFQOztBQUVBLE1BQUlBLE9BQU8sQ0FBQ0gsZUFBUixLQUE0QkgsUUFBUSxDQUFDQyxVQUF6QyxFQUFxRDtBQUNuRCxXQUFPLElBQUlNLGtDQUFKLENBQXFCO0FBQUNDLE1BQUFBLElBQUksRUFBRUgsSUFBUDtBQUFhSSxNQUFBQSxNQUFNLEVBQUVILE9BQU8sQ0FBQ0c7QUFBN0IsS0FBckIsQ0FBUDtBQUNEOztBQUVELFFBQU1DLEtBQUssQ0FBQywyREFBRCxDQUFYO0FBQ0Q7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDTyxTQUFTQywwQkFBVCxDQUNMQyxhQURLLEVBRUxDLE9BRkssRUFHbUI7QUFDeEIsU0FBTyxJQUFJQywwQ0FBSixDQUF5QkYsYUFBekIsRUFBd0NDLE9BQXhDLENBQVA7QUFDRDtBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ08sU0FBU0UsYUFBVCxDQUNMSCxhQURLLEVBR21CO0FBQUEsTUFEeEJJLFVBQ3dCLHVFQURYLEdBQ1c7QUFDeEIsTUFBTUMsWUFBWSxHQUFHTCxhQUFhLENBQUNNLE9BQWQsRUFBckI7QUFDQSxNQUFNQyxVQUFVLEdBQUdDLElBQUksQ0FBQ0MsR0FBTCxDQUFTRCxJQUFJLENBQUNFLEtBQUwsQ0FBV0wsWUFBWSxHQUFHRCxVQUExQixDQUFULEVBQWdELENBQWhELENBQW5CO0FBRUEsTUFBTUgsT0FBaUIsR0FBRyxFQUExQjs7QUFDQSxPQUFLLElBQUlVLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUdOLFlBQXBCLEVBQWtDTSxDQUFDLElBQUlKLFVBQXZDLEVBQW1EO0FBQ2pETixJQUFBQSxPQUFPLENBQUNXLElBQVIsQ0FBYUQsQ0FBYjtBQUNEOztBQUVELFNBQU9aLDBCQUEwQixDQUFDQyxhQUFELEVBQWdCQyxPQUFoQixDQUFqQztBQUNEIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDIyIFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuaW1wb3J0IHtSb3dEYXRhQ29udGFpbmVyfSBmcm9tICcuL3Jvdy1kYXRhLWNvbnRhaW5lcic7XG5pbXBvcnQge0luZGV4ZWREYXRhQ29udGFpbmVyfSBmcm9tICcuL2luZGV4ZWQtZGF0YS1jb250YWluZXInO1xuXG5pbXBvcnQge0RhdGFDb250YWluZXJJbnRlcmZhY2V9IGZyb20gJy4vZGF0YS1jb250YWluZXItaW50ZXJmYWNlJztcbmltcG9ydCB7RmllbGR9IGZyb20gJ0BrZXBsZXIuZ2wvdHlwZXMnO1xuXG5leHBvcnQgdHlwZSBEYXRhQ29udGFpbmVyT3B0aW9ucyA9IHtcbiAgaW5wdXREYXRhRm9ybWF0Pzogc3RyaW5nOyAvLyBvbmUgb2YgRGF0YUZvcm1cbiAgZmllbGRzPzogRmllbGRbXTtcbn07XG5cbmV4cG9ydCBjb25zdCBEYXRhRm9ybSA9IHtcbiAgUk9XU19BUlJBWTogJ1JPV1NfQVJSQVknXG59O1xuXG5jb25zdCBkZWZhdWx0T3B0aW9uczogRGF0YUNvbnRhaW5lck9wdGlvbnMgPSB7XG4gIGlucHV0RGF0YUZvcm1hdDogRGF0YUZvcm0uUk9XU19BUlJBWVxufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZGF0YSBjb250YWluZXIgd3JhcHBlciBmb3IgdGhlIGRhdGEuXG4gKiBAcGFyYW0gZGF0YSBEYXRhLlxuICogQHBhcmFtIG9wdGlvbnMgT3B0aW9ucy5cbiAqIEByZXR1cm5zIEEgZGF0YSBjb250YWluZXIgb2JqZWN0IHdoaWNoIGlzIGJhc2VkIG9uIGRhdGEgYW5kIG9wdGlvbnMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVEYXRhQ29udGFpbmVyKFxuICBkYXRhOiBhbnlbXSxcbiAgb3B0aW9uczogRGF0YUNvbnRhaW5lck9wdGlvbnMgPSBkZWZhdWx0T3B0aW9uc1xuKTogRGF0YUNvbnRhaW5lckludGVyZmFjZSB7XG4gIG9wdGlvbnMgPSB7Li4uZGVmYXVsdE9wdGlvbnMsIC4uLm9wdGlvbnN9O1xuXG4gIGlmIChvcHRpb25zLmlucHV0RGF0YUZvcm1hdCA9PT0gRGF0YUZvcm0uUk9XU19BUlJBWSkge1xuICAgIHJldHVybiBuZXcgUm93RGF0YUNvbnRhaW5lcih7cm93czogZGF0YSwgZmllbGRzOiBvcHRpb25zLmZpZWxkc30pO1xuICB9XG5cbiAgdGhyb3cgRXJyb3IoJ0ZhaWxlZCB0byBjcmVhdGUgYSBkYXRhIGNvbnRhaW5lcjogbm90IGltcGxlbWVudGVkIGZvcm1hdCcpO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBkYXRhIGNvbnRhaW5lciB3cmFwcGVyIGFyb3VuZCBhbm90aGVyIGRhdGEgY29udGFpbmVyLlxuICogQHBhcmFtIGRhdGFDb250YWluZXIgUGFyZW50IGRhdGEgY29udGFpbmVyLlxuICogQHBhcmFtIGluZGljZXMgQW4gYXJyYXkgb2Ygcm93IGluZGljZXMgaW4gdGhlIHBhcmVudCBkYXRhIGNvbnRhaW5lci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUluZGV4ZWREYXRhQ29udGFpbmVyKFxuICBkYXRhQ29udGFpbmVyOiBEYXRhQ29udGFpbmVySW50ZXJmYWNlLFxuICBpbmRpY2VzOiBudW1iZXJbXVxuKTogRGF0YUNvbnRhaW5lckludGVyZmFjZSB7XG4gIHJldHVybiBuZXcgSW5kZXhlZERhdGFDb250YWluZXIoZGF0YUNvbnRhaW5lciwgaW5kaWNlcyk7XG59XG5cbi8qKlxuICogR2V0IGEgc2FtcGxlIG9mIHJvd3MgZnJvbSBhIGRhdGEgY29udGFpbmVyLlxuICogQHBhcmFtIGRhdGFDb250YWluZXIgRGF0YSBjb250YWluZXIgdG8gZ2V0IHNhbXBsZXMgZnJvbS5cbiAqIEBwYXJhbSBzYW1wbGVTaXplIE1heCBudW1iZXIgb2Ygc2FtcGxlcy5cbiAqIEByZXR1cm5zIEEgZGF0YSBjb250YWluZXIgd2hpY2ggY29udGFpbnMgc2FtcGxlcyBmcm9tIHRoZSBvcmlnaW5hbCBkYXRhIGNvbnRhaW5lci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFNhbXBsZURhdGEoXG4gIGRhdGFDb250YWluZXI6IERhdGFDb250YWluZXJJbnRlcmZhY2UsXG4gIHNhbXBsZVNpemUgPSA1MDBcbik6IERhdGFDb250YWluZXJJbnRlcmZhY2Uge1xuICBjb25zdCBudW1iZXJPZlJvd3MgPSBkYXRhQ29udGFpbmVyLm51bVJvd3MoKTtcbiAgY29uc3Qgc2FtcGxlU3RlcCA9IE1hdGgubWF4KE1hdGguZmxvb3IobnVtYmVyT2ZSb3dzIC8gc2FtcGxlU2l6ZSksIDEpO1xuXG4gIGNvbnN0IGluZGljZXM6IG51bWJlcltdID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtYmVyT2ZSb3dzOyBpICs9IHNhbXBsZVN0ZXApIHtcbiAgICBpbmRpY2VzLnB1c2goaSk7XG4gIH1cblxuICByZXR1cm4gY3JlYXRlSW5kZXhlZERhdGFDb250YWluZXIoZGF0YUNvbnRhaW5lciwgaW5kaWNlcyk7XG59XG4iXX0=