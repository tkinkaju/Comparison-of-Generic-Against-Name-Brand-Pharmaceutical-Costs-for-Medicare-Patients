import { Millisecond, Field, ParsedFilter, Filter, FilterBase, PolygonFilter, FieldDomain, TimeRangeFieldDomain, HistogramBin, Feature, FeatureValue, LineChart, TimeRangeFilter, RangeFieldDomain, FilterDatasetOpt, FilterRecord } from '@kepler.gl/types';
import { DataContainerInterface } from './data-container-interface';
export declare const durationSecond = 1000;
export declare const durationMinute: number;
export declare const durationHour: number;
export declare const durationDay: number;
export declare const durationWeek: number;
export declare const durationYear: number;
export declare type FilterResult = {
    filteredIndexForDomain?: number[];
    filteredIndex?: number[];
};
export declare type FilterChanged = {
    [key in keyof FilterRecord]: {
        [key: string]: 'added' | 'deleted' | 'name_changed' | 'value_changed' | 'dataId_changed';
    } | null;
};
export declare type dataValueAccessor = (data: {
    index: number;
}) => number | null;
export declare const TimestampStepMap: {
    max: number;
    step: number;
}[];
export declare const histogramBins = 30;
export declare const enlargedHistogramBins = 100;
export declare const FILTER_UPDATER_PROPS: {
    dataId: "dataId";
    name: "name";
    layerId: "layerId";
};
export declare const LIMITED_FILTER_EFFECT_PROPS: {
    name: "name";
};
export declare const FILTER_COMPONENTS: {
    select: string;
    multiSelect: string;
    timeRange: string;
    range: string;
    polygon: string;
};
export declare const DEFAULT_FILTER_STRUCTURE: {
    dataId: never[];
    freeze: boolean;
    id: null;
    fixedDomain: boolean;
    enlarged: boolean;
    isAnimating: boolean;
    animationWindow: "free";
    speed: number;
    name: never[];
    type: null;
    fieldIdx: never[];
    domain: null;
    value: null;
    plotType: "histogram";
    yAxis: null;
    interval: null;
    gpu: boolean;
};
export declare const FILTER_ID_LENGTH = 4;
export declare const LAYER_FILTERS: "polygon"[];
/**
 * Generates a filter with a dataset id as dataId
 */
export declare function getDefaultFilter(dataId: string | null | string[]): FilterBase<LineChart>;
/**
 * Check if a filter is valid based on the given dataId
 * @param  filter to validate
 * @param  datasetId id to validate filter against
 * @return true if a filter is valid, false otherwise
 */
export declare function shouldApplyFilter(filter: Filter, datasetId: string): boolean;
interface KeplerTableModel<K, L> {
    id: string;
    getColumnFieldIdx(columnName: string): number;
    filterTable(filters: Filter[], layers: L[], opt?: FilterDatasetOpt): K;
    getColumnFilterProps(columnName: string): Field['filterProps'] | null | undefined;
    dataContainer: DataContainerInterface;
    filterTableCPU(filters: Filter[], layers: L[]): K;
}
/**
 * Validates and modifies polygon filter structure
 * @param dataset
 * @param filter
 * @param layers
 * @return - {filter, dataset}
 */
export declare function validatePolygonFilter<K extends KeplerTableModel<K, L>, L extends {
    id: string;
}>(dataset: K, filter: PolygonFilter, layers: L[]): {
    filter: PolygonFilter | null;
    dataset: K;
};
/**
 * Default validate filter function
 * @param dataset
 * @param filter
 * @return - {filter, dataset}
 */
export declare function validateFilter<K extends KeplerTableModel<K, L>, L>(dataset: K, filter: ParsedFilter): {
    filter: Filter | null;
    dataset: K;
};
/**
 * Validate saved filter config with new data,
 * calculate domain and fieldIdx based new fields and data
 *
 * @param dataset
 * @param filter - filter to be validate
 * @param layers - layers
 * @return validated filter
 */
export declare function validateFilterWithData<K extends KeplerTableModel<K, L>, L>(dataset: K, filter: ParsedFilter, layers: L[]): {
    filter: Filter;
    dataset: K;
};
/**
 * Get default filter prop based on field type
 *
 * @param field
 * @param fieldDomain
 * @returns default filter
 */
export declare function getFilterProps(field: Field, fieldDomain: FieldDomain): Partial<Filter> & {
    fieldType: string;
};
export declare const getPolygonFilterFunctor: (layer: any, filter: any, dataContainer: any) => (data: any) => any;
/**
 * @param param An object that represents a row record.
 * @param param.index Index of the row in data container.
 * @returns Returns true to keep the element, or false otherwise.
 */
declare type filterFunction = (data: {
    index: number;
}) => boolean;
/**
 * @param field dataset Field
 * @param dataId Dataset id
 * @param filter Filter object
 * @param layers list of layers to filter upon
 * @param dataContainer Data container
 * @return filterFunction
 */
export declare function getFilterFunction<L extends {
    config: {
        dataId: string | null;
    };
    id: string;
}>(field: Field | null, dataId: string, filter: Filter, layers: L[], dataContainer: DataContainerInterface): filterFunction;
export declare function updateFilterDataId(dataId: string): FilterBase<LineChart>;
export declare function filterDataByFilterTypes({ dynamicDomainFilters, cpuFilters, filterFuncs }: {
    dynamicDomainFilters: Filter[] | null;
    cpuFilters: Filter[] | null;
    filterFuncs: {
        [key: string]: filterFunction;
    };
}, dataContainer: DataContainerInterface): FilterResult;
/**
 * Get a record of filters based on domain type and gpu / cpu
 */
export declare function getFilterRecord(dataId: string, filters: Filter[], opt?: FilterDatasetOpt): FilterRecord;
/**
 * Compare filter records to get what has changed
 */
export declare function diffFilters(filterRecord: FilterRecord, oldFilterRecord?: FilterRecord | {}): FilterChanged;
/**
 * Call by parsing filters from URL
 * Check if value of filter within filter domain, if not adjust it to match
 * filter domain
 *
 * @returns value - adjusted value to match filter or null to remove filter
 */
export declare function adjustValueToFilterDomain(value: Filter['value'], { domain, type }: {
    domain: any;
    type: any;
}): any;
/**
 * Calculate numeric domain and suitable step
 */
export declare function getNumericFieldDomain(dataContainer: DataContainerInterface, valueAccessor: dataValueAccessor): RangeFieldDomain;
/**
 * Calculate step size for range and timerange filter
 */
export declare function getNumericStepSize(diff: number): number;
/**
 * Calculate timestamp domain and suitable step
 */
export declare function getTimestampFieldDomain(dataContainer: DataContainerInterface, valueAccessor: dataValueAccessor): TimeRangeFieldDomain;
export declare function histogramConstruct(domain: [number, number], mappedValue: (Millisecond | number)[], bins: number): HistogramBin[];
/**
 * Calculate histogram from domain and array of values
 */
export declare function getHistogram(domain: [number, number], mappedValue: (Millisecond | number)[]): {
    histogram: HistogramBin[];
    enlargedHistogram: HistogramBin[];
};
/**
 * round number based on step
 *
 * @param {Number} val
 * @param {Number} step
 * @param {string} bound
 * @returns {Number} rounded number
 */
export declare function formatNumberByStep(val: number, step: number, bound: 'floor' | 'ceil'): number;
export declare function isInRange(val: any, domain: number[]): boolean;
/**
 * Determines whether a point is within the provided polygon
 *
 * @param point as input search [lat, lng]
 * @param polygon Points must be within these (Multi)Polygon(s)
 * @return {boolean}
 */
export declare function isInPolygon(point: number[], polygon: any): boolean;
export declare function getTimeWidgetTitleFormatter(domain: [number, number]): string | null;
/**
 * Sanity check on filters to prepare for save
 * @type {typeof import('./filter-utils').isFilterValidToSave}
 */
export declare function isFilterValidToSave(filter: any): boolean;
/**
 * Sanity check on filters to prepare for save
 * @type {typeof import('./filter-utils').isValidFilterValue}
 */
export declare function isValidFilterValue(type: string | null, value: any): boolean;
export declare function getColumnFilterProps<K extends KeplerTableModel<K, L>, L>(filter: Filter, dataset: K): {
    lineChart: LineChart;
    yAxs: Field;
} | {};
export declare function getDefaultFilterPlotType(filter: Filter): string | null;
/**
 *
 * @param datasetIds list of dataset ids to be filtered
 * @param datasets all datasets
 * @param filters all filters to be applied to datasets
 * @return datasets - new updated datasets
 */
export declare function applyFiltersToDatasets<K extends KeplerTableModel<K, L>, L extends {
    config: {
        dataId: string | null;
    };
}>(datasetIds: string[], datasets: {
    [id: string]: K;
}, filters: Filter[], layers?: L[]): {
    [id: string]: K;
};
/**
 * Applies a new field name value to fielter and update both filter and dataset
 * @param filter - to be applied the new field name on
 * @param dataset - dataset the field belongs to
 * @param fieldName - field.name
 * @param filterDatasetIndex - field.name
 * @param option
 * @return - {filter, datasets}
 */
export declare function applyFilterFieldName<K extends KeplerTableModel<K, L>, L>(filter: Filter, dataset: K, fieldName: string, filterDatasetIndex?: number, option?: {
    mergeDomain: boolean;
}): {
    filter: Filter | null;
    dataset: K;
};
/**
 * Merge one filter with other filter prop domain
 */
export declare function mergeFilterDomainStep(filter: Filter, filterProps?: Partial<Filter>): (Filter & {
    step?: number;
}) | null;
/**
 * Generates polygon filter
 */
export declare const featureToFilterValue: (feature: Feature, filterId: string, properties?: {} | undefined) => FeatureValue;
export declare const getFilterIdInFeature: (f: FeatureValue) => string;
/**
 * Generates polygon filter
 */
export declare function generatePolygonFilter<L extends {
    config: {
        dataId: string | null;
        label: string;
    };
    id: string;
}>(layers: L[], feature: Feature): PolygonFilter;
/**
 * Run filter entirely on CPU
 */
interface StateType<K extends KeplerTableModel<K, L>, L> {
    layers: L[];
    filters: Filter[];
    datasets: {
        [id: string]: K;
    };
}
export declare function filterDatasetCPU<T extends StateType<K, L>, K extends KeplerTableModel<K, L>, L>(state: T, dataId: string): T;
/**
 * Validate parsed filters with datasets and add filterProps to field
 */
export declare function validateFiltersUpdateDatasets<S extends {
    datasets: {
        [id: string]: K;
    };
    layers: L[];
}, K extends KeplerTableModel<K, L>, L extends {
    config: {
        dataId: string | null;
        label: string;
    };
    id: string;
}>(state: S, filtersToValidate?: ParsedFilter[]): {
    validated: Filter[];
    failed: Filter[];
    updatedDatasets: S['datasets'];
};
export declare function getFilterPlot<K extends KeplerTableModel<K, L>, L>(filter: Filter, dataset: K): {
    lineChart: LineChart;
    yAxs: Field;
} | {};
/**
 * Retrieve interval bins for time filter
 */
export declare function getIntervalBins(filter: TimeRangeFilter): any;
export declare function isValidTimeDomain(domain: any): boolean;
export declare function getTimeWidgetHintFormatter(domain: [number, number]): string | undefined;
export {};
