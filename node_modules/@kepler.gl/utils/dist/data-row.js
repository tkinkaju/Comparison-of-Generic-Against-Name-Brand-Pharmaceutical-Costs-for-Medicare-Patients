// Copyright (c) 2022 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DataRow = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));/**
 * Setting for shared row optimization.
 * - False/undefined indicates that unique row objects should be used (default).
 * - True indicates that a single temporary row object should be created and used without extra allocations.
 * - A DataRow object indicates that the row should be used as a temporary shared row.
 * When used, the content of the shared row isn't preserved between calls.
 */

/**
 * Return type for createSharedRow:
 * - DataRow object that should be used as shared row.
 * - Falsy values indicate that shared row object shouldn't be used.
 */
var DataRow = /*#__PURE__*/function () {
  /**
   * Creates new DataRow.
   * @param dataContainer Data container where data is stored. Can be initialized with null for shared rows.
   * @param rowIndex Index of a row in the data container.
   */
  function DataRow(dataContainer, rowIndex) {
    (0, _classCallCheck2["default"])(this, DataRow);
    (0, _defineProperty2["default"])(this, "_dataContainer", void 0);
    (0, _defineProperty2["default"])(this, "_rowIndex", void 0);
    this._dataContainer = dataContainer;
    this._rowIndex = rowIndex;
  }
  /**
   * Conditionally creates a DataRow object.
   * @param sharedRowDesc Accepts forllowing options:
   * - true indicates that new DataRow should be created.
   * - falsy value or a DataRow object is passed through without any change.
   * @returns A new DataRow object or unchanged input argument.
   */


  (0, _createClass2["default"])(DataRow, [{
    key: "valueAt",
    value:
    /**
     * Returns the value stored at the specified index in the row.
     * @param columnIndex Index of the requested field in the row.
     * @returns Value at the index.
     */
    function valueAt(columnIndex) {
      var _this$_dataContainer;

      return (_this$_dataContainer = this._dataContainer) === null || _this$_dataContainer === void 0 ? void 0 : _this$_dataContainer.valueAt(this._rowIndex, columnIndex);
    }
    /**
     * Returns the row represented as an array.
     * @returns The row represented as an array.
     */

  }, {
    key: "values",
    value: function values() {
      return this._dataContainer ? this._dataContainer.rowAsArray(this._rowIndex) : [];
    }
    /**
     * Setup a row object. The method is used by shared rows to prevent excessive allocations.
     * @param dataContainer Data container.
     * @param rowIndex Index of a row in the data container.
     */

  }, {
    key: "setSource",
    value: function setSource(dataContainer, rowIndex) {
      this._dataContainer = dataContainer;
      this._rowIndex = rowIndex;
    }
    /**
     * Creates a new array populated with the results of calling the provided function
     * on every element of the row.
     * @param handler The callback is called with the following arguments:
     * - elem: The current element being processed in the row.
     * - index: The index of the current element being processed in the row.
     * @returns A new array with each element being the result of the func callback.
     */

  }, {
    key: "map",
    value: function map(handler) {
      var _this$_dataContainer2;

      var numColumns = ((_this$_dataContainer2 = this._dataContainer) === null || _this$_dataContainer2 === void 0 ? void 0 : _this$_dataContainer2.numColumns()) || 0;
      var out = [];

      for (var column = 0; column < numColumns; ++column) {
        out[column] = handler(this.valueAt(column), column);
      }

      return out;
    }
  }], [{
    key: "createSharedRow",
    value: function createSharedRow(sharedRowDesc) {
      if (sharedRowDesc === true) {
        return new DataRow(null, 0);
      }

      return sharedRowDesc;
    }
  }]);
  return DataRow;
}();

exports.DataRow = DataRow;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9kYXRhLXJvdy50cyJdLCJuYW1lcyI6WyJEYXRhUm93IiwiZGF0YUNvbnRhaW5lciIsInJvd0luZGV4IiwiX2RhdGFDb250YWluZXIiLCJfcm93SW5kZXgiLCJjb2x1bW5JbmRleCIsInZhbHVlQXQiLCJyb3dBc0FycmF5IiwiaGFuZGxlciIsIm51bUNvbHVtbnMiLCJvdXQiLCJjb2x1bW4iLCJzaGFyZWRSb3dEZXNjIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0lBR2FBLE87QUFLWDtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0UsbUJBQVlDLGFBQVosRUFBMERDLFFBQTFELEVBQTRFO0FBQUE7QUFBQTtBQUFBO0FBQzFFLFNBQUtDLGNBQUwsR0FBc0JGLGFBQXRCO0FBQ0EsU0FBS0csU0FBTCxHQUFpQkYsUUFBakI7QUFDRDtBQUVEO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFRRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0UscUJBQVFHLFdBQVIsRUFBa0M7QUFBQTs7QUFDaEMscUNBQU8sS0FBS0YsY0FBWix5REFBTyxxQkFBcUJHLE9BQXJCLENBQTZCLEtBQUtGLFNBQWxDLEVBQTZDQyxXQUE3QyxDQUFQO0FBQ0Q7QUFFRDtBQUNGO0FBQ0E7QUFDQTs7OztXQUNFLGtCQUFnQjtBQUNkLGFBQU8sS0FBS0YsY0FBTCxHQUFzQixLQUFLQSxjQUFMLENBQW9CSSxVQUFwQixDQUErQixLQUFLSCxTQUFwQyxDQUF0QixHQUF1RSxFQUE5RTtBQUNEO0FBRUQ7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7OztXQUNFLG1CQUFVSCxhQUFWLEVBQWlEQyxRQUFqRCxFQUF5RTtBQUN2RSxXQUFLQyxjQUFMLEdBQXNCRixhQUF0QjtBQUNBLFdBQUtHLFNBQUwsR0FBaUJGLFFBQWpCO0FBQ0Q7QUFFRDtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O1dBQ0UsYUFBSU0sT0FBSixFQUF1RDtBQUFBOztBQUNyRCxVQUFNQyxVQUFVLEdBQUcsK0JBQUtOLGNBQUwsZ0ZBQXFCTSxVQUFyQixPQUFxQyxDQUF4RDtBQUNBLFVBQU1DLEdBQVUsR0FBRyxFQUFuQjs7QUFDQSxXQUFLLElBQUlDLE1BQU0sR0FBRyxDQUFsQixFQUFxQkEsTUFBTSxHQUFHRixVQUE5QixFQUEwQyxFQUFFRSxNQUE1QyxFQUFvRDtBQUNsREQsUUFBQUEsR0FBRyxDQUFDQyxNQUFELENBQUgsR0FBY0gsT0FBTyxDQUFDLEtBQUtGLE9BQUwsQ0FBYUssTUFBYixDQUFELEVBQXVCQSxNQUF2QixDQUFyQjtBQUNEOztBQUNELGFBQU9ELEdBQVA7QUFDRDs7O1dBakRELHlCQUF1QkUsYUFBdkIsRUFBZ0Y7QUFDOUUsVUFBSUEsYUFBYSxLQUFLLElBQXRCLEVBQTRCO0FBQzFCLGVBQU8sSUFBSVosT0FBSixDQUFZLElBQVosRUFBa0IsQ0FBbEIsQ0FBUDtBQUNEOztBQUNELGFBQU9ZLGFBQVA7QUFDRCIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAyMiBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5cbmltcG9ydCB7RGF0YUNvbnRhaW5lckludGVyZmFjZX0gZnJvbSAnLi9kYXRhLWNvbnRhaW5lci1pbnRlcmZhY2UnO1xuXG4vKipcbiAqIFNldHRpbmcgZm9yIHNoYXJlZCByb3cgb3B0aW1pemF0aW9uLlxuICogLSBGYWxzZS91bmRlZmluZWQgaW5kaWNhdGVzIHRoYXQgdW5pcXVlIHJvdyBvYmplY3RzIHNob3VsZCBiZSB1c2VkIChkZWZhdWx0KS5cbiAqIC0gVHJ1ZSBpbmRpY2F0ZXMgdGhhdCBhIHNpbmdsZSB0ZW1wb3Jhcnkgcm93IG9iamVjdCBzaG91bGQgYmUgY3JlYXRlZCBhbmQgdXNlZCB3aXRob3V0IGV4dHJhIGFsbG9jYXRpb25zLlxuICogLSBBIERhdGFSb3cgb2JqZWN0IGluZGljYXRlcyB0aGF0IHRoZSByb3cgc2hvdWxkIGJlIHVzZWQgYXMgYSB0ZW1wb3Jhcnkgc2hhcmVkIHJvdy5cbiAqIFdoZW4gdXNlZCwgdGhlIGNvbnRlbnQgb2YgdGhlIHNoYXJlZCByb3cgaXNuJ3QgcHJlc2VydmVkIGJldHdlZW4gY2FsbHMuXG4gKi9cbmV4cG9ydCB0eXBlIFNoYXJlZFJvd09wdGlvbnMgPSBEYXRhUm93IHwgYm9vbGVhbiB8IHVuZGVmaW5lZDtcbi8qKlxuICogUmV0dXJuIHR5cGUgZm9yIGNyZWF0ZVNoYXJlZFJvdzpcbiAqIC0gRGF0YVJvdyBvYmplY3QgdGhhdCBzaG91bGQgYmUgdXNlZCBhcyBzaGFyZWQgcm93LlxuICogLSBGYWxzeSB2YWx1ZXMgaW5kaWNhdGUgdGhhdCBzaGFyZWQgcm93IG9iamVjdCBzaG91bGRuJ3QgYmUgdXNlZC5cbiAqL1xuZXhwb3J0IHR5cGUgU2hhcmVkUm93T3B0aW9uc1Jlc3VsdCA9IERhdGFSb3cgfCBmYWxzZSB8IHVuZGVmaW5lZDtcblxuZXhwb3J0IGNsYXNzIERhdGFSb3cge1xuICBfZGF0YUNvbnRhaW5lcjogRGF0YUNvbnRhaW5lckludGVyZmFjZSB8IG51bGw7XG5cbiAgX3Jvd0luZGV4OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgbmV3IERhdGFSb3cuXG4gICAqIEBwYXJhbSBkYXRhQ29udGFpbmVyIERhdGEgY29udGFpbmVyIHdoZXJlIGRhdGEgaXMgc3RvcmVkLiBDYW4gYmUgaW5pdGlhbGl6ZWQgd2l0aCBudWxsIGZvciBzaGFyZWQgcm93cy5cbiAgICogQHBhcmFtIHJvd0luZGV4IEluZGV4IG9mIGEgcm93IGluIHRoZSBkYXRhIGNvbnRhaW5lci5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGRhdGFDb250YWluZXI6IERhdGFDb250YWluZXJJbnRlcmZhY2UgfCBudWxsLCByb3dJbmRleDogbnVtYmVyKSB7XG4gICAgdGhpcy5fZGF0YUNvbnRhaW5lciA9IGRhdGFDb250YWluZXI7XG4gICAgdGhpcy5fcm93SW5kZXggPSByb3dJbmRleDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb25kaXRpb25hbGx5IGNyZWF0ZXMgYSBEYXRhUm93IG9iamVjdC5cbiAgICogQHBhcmFtIHNoYXJlZFJvd0Rlc2MgQWNjZXB0cyBmb3JsbG93aW5nIG9wdGlvbnM6XG4gICAqIC0gdHJ1ZSBpbmRpY2F0ZXMgdGhhdCBuZXcgRGF0YVJvdyBzaG91bGQgYmUgY3JlYXRlZC5cbiAgICogLSBmYWxzeSB2YWx1ZSBvciBhIERhdGFSb3cgb2JqZWN0IGlzIHBhc3NlZCB0aHJvdWdoIHdpdGhvdXQgYW55IGNoYW5nZS5cbiAgICogQHJldHVybnMgQSBuZXcgRGF0YVJvdyBvYmplY3Qgb3IgdW5jaGFuZ2VkIGlucHV0IGFyZ3VtZW50LlxuICAgKi9cbiAgc3RhdGljIGNyZWF0ZVNoYXJlZFJvdyhzaGFyZWRSb3dEZXNjOiBTaGFyZWRSb3dPcHRpb25zKTogU2hhcmVkUm93T3B0aW9uc1Jlc3VsdCB7XG4gICAgaWYgKHNoYXJlZFJvd0Rlc2MgPT09IHRydWUpIHtcbiAgICAgIHJldHVybiBuZXcgRGF0YVJvdyhudWxsLCAwKTtcbiAgICB9XG4gICAgcmV0dXJuIHNoYXJlZFJvd0Rlc2M7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdmFsdWUgc3RvcmVkIGF0IHRoZSBzcGVjaWZpZWQgaW5kZXggaW4gdGhlIHJvdy5cbiAgICogQHBhcmFtIGNvbHVtbkluZGV4IEluZGV4IG9mIHRoZSByZXF1ZXN0ZWQgZmllbGQgaW4gdGhlIHJvdy5cbiAgICogQHJldHVybnMgVmFsdWUgYXQgdGhlIGluZGV4LlxuICAgKi9cbiAgdmFsdWVBdChjb2x1bW5JbmRleDogbnVtYmVyKTogYW55IHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YUNvbnRhaW5lcj8udmFsdWVBdCh0aGlzLl9yb3dJbmRleCwgY29sdW1uSW5kZXgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHJvdyByZXByZXNlbnRlZCBhcyBhbiBhcnJheS5cbiAgICogQHJldHVybnMgVGhlIHJvdyByZXByZXNlbnRlZCBhcyBhbiBhcnJheS5cbiAgICovXG4gIHZhbHVlcygpOiBhbnlbXSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGFDb250YWluZXIgPyB0aGlzLl9kYXRhQ29udGFpbmVyLnJvd0FzQXJyYXkodGhpcy5fcm93SW5kZXgpIDogW107XG4gIH1cblxuICAvKipcbiAgICogU2V0dXAgYSByb3cgb2JqZWN0LiBUaGUgbWV0aG9kIGlzIHVzZWQgYnkgc2hhcmVkIHJvd3MgdG8gcHJldmVudCBleGNlc3NpdmUgYWxsb2NhdGlvbnMuXG4gICAqIEBwYXJhbSBkYXRhQ29udGFpbmVyIERhdGEgY29udGFpbmVyLlxuICAgKiBAcGFyYW0gcm93SW5kZXggSW5kZXggb2YgYSByb3cgaW4gdGhlIGRhdGEgY29udGFpbmVyLlxuICAgKi9cbiAgc2V0U291cmNlKGRhdGFDb250YWluZXI6IERhdGFDb250YWluZXJJbnRlcmZhY2UsIHJvd0luZGV4OiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aGlzLl9kYXRhQ29udGFpbmVyID0gZGF0YUNvbnRhaW5lcjtcbiAgICB0aGlzLl9yb3dJbmRleCA9IHJvd0luZGV4O1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgYXJyYXkgcG9wdWxhdGVkIHdpdGggdGhlIHJlc3VsdHMgb2YgY2FsbGluZyB0aGUgcHJvdmlkZWQgZnVuY3Rpb25cbiAgICogb24gZXZlcnkgZWxlbWVudCBvZiB0aGUgcm93LlxuICAgKiBAcGFyYW0gaGFuZGxlciBUaGUgY2FsbGJhY2sgaXMgY2FsbGVkIHdpdGggdGhlIGZvbGxvd2luZyBhcmd1bWVudHM6XG4gICAqIC0gZWxlbTogVGhlIGN1cnJlbnQgZWxlbWVudCBiZWluZyBwcm9jZXNzZWQgaW4gdGhlIHJvdy5cbiAgICogLSBpbmRleDogVGhlIGluZGV4IG9mIHRoZSBjdXJyZW50IGVsZW1lbnQgYmVpbmcgcHJvY2Vzc2VkIGluIHRoZSByb3cuXG4gICAqIEByZXR1cm5zIEEgbmV3IGFycmF5IHdpdGggZWFjaCBlbGVtZW50IGJlaW5nIHRoZSByZXN1bHQgb2YgdGhlIGZ1bmMgY2FsbGJhY2suXG4gICAqL1xuICBtYXAoaGFuZGxlcjogKGVsZW06IGFueSwgaW5kZXg6IG51bWJlcikgPT4gYW55KTogYW55W10ge1xuICAgIGNvbnN0IG51bUNvbHVtbnMgPSB0aGlzLl9kYXRhQ29udGFpbmVyPy5udW1Db2x1bW5zKCkgfHwgMDtcbiAgICBjb25zdCBvdXQ6IGFueVtdID0gW107XG4gICAgZm9yIChsZXQgY29sdW1uID0gMDsgY29sdW1uIDwgbnVtQ29sdW1uczsgKytjb2x1bW4pIHtcbiAgICAgIG91dFtjb2x1bW5dID0gaGFuZGxlcih0aGlzLnZhbHVlQXQoY29sdW1uKSwgY29sdW1uKTtcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbiAgfVxufVxuIl19