import { DataContainerInterface, RangeOptions } from './data-container-interface';
import { DataRow, SharedRowOptions } from './data-row';
/**
 * A data container wrapper around another data container.
 * You have to pass an array of indices to reference rows in the parent data container.
 * For example indices [3, 4, 6, 8] means that IndexedDataContainer is going to have
 * 4 rows and row(2) points to 6th row in the referenced data container.
 */
export declare class IndexedDataContainer implements DataContainerInterface {
    _parentDataContainer: DataContainerInterface;
    _indices: number[];
    constructor(parentDataContainer: DataContainerInterface, indices: number[]);
    numRows(): number;
    numColumns(): number;
    /**
     * Remaps a local index to an index in the parent dataset
     * @param rowIndex
     * @returns number
     */
    _mappedRowIndex(rowIndex: number): number;
    valueAt(rowIndex: number, columnIndex: number): any;
    row(rowIndex: number, sharedRow?: SharedRowOptions): DataRow;
    rowAsArray(rowIndex: number): any[];
    rows(sharedRow?: SharedRowOptions): Generator<DataRow, any, unknown>;
    column(columnIndex: number): Generator<any, any, unknown>;
    getPlainIndex(): number[];
    flattenData(): any[][];
    map<T>(func: (row: DataRow, index: number) => T, sharedRow?: SharedRowOptions, options?: RangeOptions): T[];
    mapIndex<T>(func: ({ index: number }: {
        index: any;
    }, dc: DataContainerInterface) => T, options?: RangeOptions): T[];
    find(func: (row: DataRow, index: number) => boolean, sharedRow?: SharedRowOptions): DataRow | undefined;
    reduce<T>(func: (acc: T, row: DataRow, index: number) => T, initialValue: T, sharedRow?: SharedRowOptions): T;
}
