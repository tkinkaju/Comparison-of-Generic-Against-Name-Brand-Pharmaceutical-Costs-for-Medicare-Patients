import { TooltipFormat } from '@kepler.gl/constants';
import { Millisecond, Field } from '@kepler.gl/types';
export declare type FieldFormatter = (value: any) => string;
/**
 * simple getting unique values of an array
 *
 * @param values
 * @returns unique values
 */
export declare function unique<T>(values: T[]): T[];
export declare function getLatLngBounds(points: number[][], idx: number, limit: [number, number]): [number, number] | null;
export declare function clamp([min, max]: [number, number], val?: number): number;
export declare function getSampleData(data: any, sampleSize?: number, getValue?: (d: any) => any): any[];
/**
 * Convert different time format to unix milliseconds
 */
export declare function timeToUnixMilli(value: string | number | Date, format: string): Millisecond | null;
/**
 * whether null or undefined
 */
export declare function notNullorUndefined<T extends NonNullable<any>>(d: T | null | undefined): d is T;
/**
 * Whether d is a number, this filtered out NaN as well
 */
export declare function isNumber(d: any): boolean;
/**
 * whether is an object
 * @returns {boolean} - yes or no
 */
export declare function isPlainObject(obj: unknown): obj is Record<string, unknown>;
/**
 * whether object has property
 * @param {string} prop
 * @returns {boolean} - yes or no
 */
export declare function hasOwnProperty<X extends {}, Y extends PropertyKey>(obj: X, prop: Y): obj is X & Record<Y, unknown>;
export declare function numberSort(a: number, b: number): number;
export declare function getSortingFunction(fieldType: string): typeof numberSort | undefined;
/**
 * round number with exact number of decimals
 * return as a string
 */
export declare function preciseRound(num: number, decimals: number): string;
/**
 * get number of decimals to round to for slider from step
 * @param step
 * @returns- number of decimal
 */
export declare function getRoundingDecimalFromStep(step: number): number;
/**
 * Use in slider, given a number and an array of numbers, return the nears number from the array
 * @param value
 * @param marks
 */
export declare function snapToMarks(value: number, marks: number[]): number;
/**
 * If marks is provided, snap to marks, if not normalize to step
 * @param val
 * @param minValue
 * @param step
 * @param marks
 */
export declare function normalizeSliderValue(val: number, minValue: number, step: number, marks?: number[]): number;
/**
 * round the value to step for the slider
 * @param minValue
 * @param step
 * @param val
 * @returns - rounded number
 */
export declare function roundValToStep(minValue: number, step: number, val: number): number;
/**
 * Get the value format based on field and format options
 * Used in render tooltip value
 */
export declare const defaultFormatter: FieldFormatter;
export declare const FIELD_DISPLAY_FORMAT: {
    [key: string]: FieldFormatter;
};
/**
 * Parse field value and type and return a string representation
 */
export declare const parseFieldValue: (value: any, type: string) => string;
/**
 *
 * @param array
 * @param from
 * @param to
 */
export declare const arrayMove: <T>(array: T[], from: number, to: number) => T[];
/**
 * Get the value format based on field and format options
 * Used in render tooltip value
 * @param format
 * @param field
 */
export declare function getFormatter(format: string | Record<string, string>, field?: Field): FieldFormatter;
export declare function applyDefaultFormat(tooltipFormat: TooltipFormat): (v: any) => string;
export declare function getBooleanFormatter(format: string): FieldFormatter;
export declare function applyCustomFormat(format: any, field: any): FieldFormatter;
/**
 * Format epoch milliseconds with a format string
 * @type timezone
 */
export declare function datetimeFormatter(timezone?: string | null): (format?: string) => (ts: number) => string;
