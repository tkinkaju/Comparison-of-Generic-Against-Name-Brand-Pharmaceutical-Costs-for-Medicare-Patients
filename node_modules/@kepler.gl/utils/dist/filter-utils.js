// Copyright (c) 2022 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getDefaultFilter = getDefaultFilter;
exports.shouldApplyFilter = shouldApplyFilter;
exports.validatePolygonFilter = validatePolygonFilter;
exports.validateFilter = validateFilter;
exports.validateFilterWithData = validateFilterWithData;
exports.getFilterProps = getFilterProps;
exports.getFilterFunction = getFilterFunction;
exports.updateFilterDataId = updateFilterDataId;
exports.filterDataByFilterTypes = filterDataByFilterTypes;
exports.getFilterRecord = getFilterRecord;
exports.diffFilters = diffFilters;
exports.adjustValueToFilterDomain = adjustValueToFilterDomain;
exports.getNumericFieldDomain = getNumericFieldDomain;
exports.getNumericStepSize = getNumericStepSize;
exports.getTimestampFieldDomain = getTimestampFieldDomain;
exports.histogramConstruct = histogramConstruct;
exports.getHistogram = getHistogram;
exports.formatNumberByStep = formatNumberByStep;
exports.isInRange = isInRange;
exports.isInPolygon = isInPolygon;
exports.getTimeWidgetTitleFormatter = getTimeWidgetTitleFormatter;
exports.isFilterValidToSave = isFilterValidToSave;
exports.isValidFilterValue = isValidFilterValue;
exports.getColumnFilterProps = getColumnFilterProps;
exports.getDefaultFilterPlotType = getDefaultFilterPlotType;
exports.applyFiltersToDatasets = applyFiltersToDatasets;
exports.applyFilterFieldName = applyFilterFieldName;
exports.mergeFilterDomainStep = mergeFilterDomainStep;
exports.generatePolygonFilter = generatePolygonFilter;
exports.filterDatasetCPU = filterDatasetCPU;
exports.validateFiltersUpdateDatasets = validateFiltersUpdateDatasets;
exports.getFilterPlot = getFilterPlot;
exports.getIntervalBins = getIntervalBins;
exports.isValidTimeDomain = isValidTimeDomain;
exports.getTimeWidgetHintFormatter = getTimeWidgetHintFormatter;
exports.getFilterIdInFeature = exports.featureToFilterValue = exports.getPolygonFilterFunctor = exports.LAYER_FILTERS = exports.FILTER_ID_LENGTH = exports.DEFAULT_FILTER_STRUCTURE = exports.FILTER_COMPONENTS = exports.LIMITED_FILTER_EFFECT_PROPS = exports.FILTER_UPDATER_PROPS = exports.enlargedHistogramBins = exports.histogramBins = exports.TimestampStepMap = exports.durationYear = exports.durationWeek = exports.durationDay = exports.durationHour = exports.durationMinute = exports.durationSecond = void 0;

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _d3Array = require("d3-array");

var _keymirror = _interopRequireDefault(require("keymirror"));

var _console = _interopRequireDefault(require("global/console"));

var _lodash = _interopRequireDefault(require("lodash.get"));

var _lodash2 = _interopRequireDefault(require("lodash.isequal"));

var _booleanWithin = _interopRequireDefault(require("@turf/boolean-within"));

var _helpers = require("@turf/helpers");

var _decimal = require("decimal.js");

var _constants = require("@kepler.gl/constants");

var ScaleUtils = _interopRequireWildcard(require("./data-scale-utils"));

var _h3Js = require("h3-js");

var _utils = require("./utils");

var _dataUtils = require("./data-utils");

var _h3Utils = require("./h3-utils");

var _FILTER_TYPES$timeRan, _FILTER_TYPES$range, _SupportedPlotType, _FILTER_COMPONENTS;

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var durationSecond = 1000;
exports.durationSecond = durationSecond;
var durationMinute = durationSecond * 60;
exports.durationMinute = durationMinute;
var durationHour = durationMinute * 60;
exports.durationHour = durationHour;
var durationDay = durationHour * 24;
exports.durationDay = durationDay;
var durationWeek = durationDay * 7;
exports.durationWeek = durationWeek;
var durationYear = durationDay * 365;
exports.durationYear = durationYear;
var TimestampStepMap = [{
  max: 1,
  step: 0.05
}, {
  max: 10,
  step: 0.1
}, {
  max: 100,
  step: 1
}, {
  max: 500,
  step: 5
}, {
  max: 1000,
  step: 10
}, {
  max: 5000,
  step: 50
}, {
  max: Number.POSITIVE_INFINITY,
  step: 1000
}];
exports.TimestampStepMap = TimestampStepMap;
var histogramBins = 30;
exports.histogramBins = histogramBins;
var enlargedHistogramBins = 100;
exports.enlargedHistogramBins = enlargedHistogramBins;
var FILTER_UPDATER_PROPS = (0, _keymirror["default"])({
  dataId: null,
  name: null,
  layerId: null
});
exports.FILTER_UPDATER_PROPS = FILTER_UPDATER_PROPS;
var LIMITED_FILTER_EFFECT_PROPS = (0, _keymirror["default"])((0, _defineProperty2["default"])({}, FILTER_UPDATER_PROPS.name, null));
/**
 * Max number of filter value buffers that deck.gl provides
 */

exports.LIMITED_FILTER_EFFECT_PROPS = LIMITED_FILTER_EFFECT_PROPS;
var SupportedPlotType = (_SupportedPlotType = {}, (0, _defineProperty2["default"])(_SupportedPlotType, _constants.FILTER_TYPES.timeRange, (_FILTER_TYPES$timeRan = {
  "default": 'histogram'
}, (0, _defineProperty2["default"])(_FILTER_TYPES$timeRan, _constants.ALL_FIELD_TYPES.integer, 'lineChart'), (0, _defineProperty2["default"])(_FILTER_TYPES$timeRan, _constants.ALL_FIELD_TYPES.real, 'lineChart'), _FILTER_TYPES$timeRan)), (0, _defineProperty2["default"])(_SupportedPlotType, _constants.FILTER_TYPES.range, (_FILTER_TYPES$range = {
  "default": 'histogram'
}, (0, _defineProperty2["default"])(_FILTER_TYPES$range, _constants.ALL_FIELD_TYPES.integer, 'lineChart'), (0, _defineProperty2["default"])(_FILTER_TYPES$range, _constants.ALL_FIELD_TYPES.real, 'lineChart'), _FILTER_TYPES$range)), _SupportedPlotType);
var FILTER_COMPONENTS = (_FILTER_COMPONENTS = {}, (0, _defineProperty2["default"])(_FILTER_COMPONENTS, _constants.FILTER_TYPES.select, 'SingleSelectFilter'), (0, _defineProperty2["default"])(_FILTER_COMPONENTS, _constants.FILTER_TYPES.multiSelect, 'MultiSelectFilter'), (0, _defineProperty2["default"])(_FILTER_COMPONENTS, _constants.FILTER_TYPES.timeRange, 'TimeRangeFilter'), (0, _defineProperty2["default"])(_FILTER_COMPONENTS, _constants.FILTER_TYPES.range, 'RangeFilter'), (0, _defineProperty2["default"])(_FILTER_COMPONENTS, _constants.FILTER_TYPES.polygon, 'PolygonFilter'), _FILTER_COMPONENTS);
exports.FILTER_COMPONENTS = FILTER_COMPONENTS;
var DEFAULT_FILTER_STRUCTURE = {
  dataId: [],
  // [string]
  freeze: false,
  id: null,
  // time range filter specific
  fixedDomain: false,
  enlarged: false,
  isAnimating: false,
  animationWindow: _constants.ANIMATION_WINDOW.free,
  speed: 1,
  // field specific
  name: [],
  // string
  type: null,
  fieldIdx: [],
  // [integer]
  domain: null,
  value: null,
  // plot
  plotType: _constants.PLOT_TYPES.histogram,
  yAxis: null,
  interval: null,
  // mode
  gpu: false
};
exports.DEFAULT_FILTER_STRUCTURE = DEFAULT_FILTER_STRUCTURE;
var FILTER_ID_LENGTH = 4;
exports.FILTER_ID_LENGTH = FILTER_ID_LENGTH;
var LAYER_FILTERS = [_constants.FILTER_TYPES.polygon];
/**
 * Generates a filter with a dataset id as dataId
 */

exports.LAYER_FILTERS = LAYER_FILTERS;

function getDefaultFilter(dataId) {
  return _objectSpread(_objectSpread({}, DEFAULT_FILTER_STRUCTURE), {}, {
    // store it as dataId and it could be one or many
    dataId: (0, _utils.toArray)(dataId),
    id: (0, _utils.generateHashId)(FILTER_ID_LENGTH)
  });
}
/**
 * Check if a filter is valid based on the given dataId
 * @param  filter to validate
 * @param  datasetId id to validate filter against
 * @return true if a filter is valid, false otherwise
 */


function shouldApplyFilter(filter, datasetId) {
  var dataIds = (0, _utils.toArray)(filter.dataId);
  return dataIds.includes(datasetId) && filter.value !== null;
}

/**
 * Validates and modifies polygon filter structure
 * @param dataset
 * @param filter
 * @param layers
 * @return - {filter, dataset}
 */
function validatePolygonFilter(dataset, filter, layers) {
  var failed = {
    dataset: dataset,
    filter: null
  };
  var value = filter.value,
      layerId = filter.layerId,
      type = filter.type,
      dataId = filter.dataId;

  if (!layerId || !isValidFilterValue(type, value)) {
    return failed;
  }

  var isValidDataset = dataId.includes(dataset.id);

  if (!isValidDataset) {
    return failed;
  }

  var layer = layers.find(function (l) {
    return layerId.includes(l.id);
  });

  if (!layer) {
    return failed;
  }

  return {
    filter: _objectSpread(_objectSpread({}, filter), {}, {
      freeze: true,
      fieldIdx: []
    }),
    dataset: dataset
  };
}
/**
 * Custom filter validators
 */


var filterValidators = (0, _defineProperty2["default"])({}, _constants.FILTER_TYPES.polygon, validatePolygonFilter);
/**
 * Default validate filter function
 * @param dataset
 * @param filter
 * @return - {filter, dataset}
 */

function validateFilter(dataset, filter) {
  // match filter.dataId
  var failed = {
    dataset: dataset,
    filter: null
  };
  var filterDataId = (0, _utils.toArray)(filter.dataId);
  var filterDatasetIndex = filterDataId.indexOf(dataset.id);

  if (filterDatasetIndex < 0 || !(0, _utils.toArray)(filter.name)[filterDatasetIndex]) {
    // the current filter is not mapped against the current dataset
    return failed;
  }

  var initializeFilter = _objectSpread(_objectSpread(_objectSpread({}, getDefaultFilter(filter.dataId)), filter), {}, {
    dataId: filterDataId,
    name: (0, _utils.toArray)(filter.name)
  });

  var fieldName = initializeFilter.name[filterDatasetIndex];

  var _applyFilterFieldName = applyFilterFieldName(initializeFilter, dataset, fieldName, filterDatasetIndex, {
    mergeDomain: true
  }),
      updatedFilter = _applyFilterFieldName.filter,
      updatedDataset = _applyFilterFieldName.dataset;

  if (!updatedFilter) {
    return failed;
  }

  updatedFilter.value = adjustValueToFilterDomain(filter.value, updatedFilter);
  updatedFilter.enlarged = typeof filter.enlarged === 'boolean' ? filter.enlarged : updatedFilter.enlarged;

  if (updatedFilter.value === null) {
    // cannot adjust saved value to filter
    return failed;
  }

  return {
    filter: validateFilterYAxis(updatedFilter, updatedDataset),
    dataset: updatedDataset
  };
}
/**
 * Validate saved filter config with new data,
 * calculate domain and fieldIdx based new fields and data
 *
 * @param dataset
 * @param filter - filter to be validate
 * @param layers - layers
 * @return validated filter
 */


function validateFilterWithData(dataset, filter, layers) {
  return filter.type && filterValidators.hasOwnProperty(filter.type) ? filterValidators[filter.type](dataset, filter, layers) : validateFilter(dataset, filter);
}
/**
 * Validate YAxis
 * @param filter
 * @param dataset
 * @return {*}
 */


function validateFilterYAxis(filter, dataset) {
  // TODO: validate yAxis against other datasets
  var fields = dataset.fields;
  var _filter = filter,
      yAxis = _filter.yAxis; // TODO: validate yAxis against other datasets

  if (yAxis) {
    var matchedAxis = fields.find(function (_ref) {
      var name = _ref.name,
          type = _ref.type;
      return name === yAxis.name && type === yAxis.type;
    });
    filter = matchedAxis ? _objectSpread(_objectSpread({}, filter), {}, {
      yAxis: matchedAxis
    }, getFilterPlot(_objectSpread(_objectSpread({}, filter), {}, {
      yAxis: matchedAxis
    }), dataset)) : filter;
  }

  return filter;
}
/**
 * Get default filter prop based on field type
 *
 * @param field
 * @param fieldDomain
 * @returns default filter
 */


function getFilterProps(field, fieldDomain) {
  var filterProps = _objectSpread(_objectSpread({}, fieldDomain), {}, {
    fieldType: field.type
  });

  switch (field.type) {
    case _constants.ALL_FIELD_TYPES.real:
    case _constants.ALL_FIELD_TYPES.integer:
      return _objectSpread(_objectSpread({}, filterProps), {}, {
        value: fieldDomain.domain,
        type: _constants.FILTER_TYPES.range,
        // @ts-expect-error
        typeOptions: [_constants.FILTER_TYPES.range],
        gpu: true
      });

    case _constants.ALL_FIELD_TYPES["boolean"]:
      // @ts-expect-error
      return _objectSpread(_objectSpread({}, filterProps), {}, {
        type: _constants.FILTER_TYPES.select,
        value: true,
        gpu: false
      });

    case _constants.ALL_FIELD_TYPES.string:
    case _constants.ALL_FIELD_TYPES.date:
      // @ts-expect-error
      return _objectSpread(_objectSpread({}, filterProps), {}, {
        type: _constants.FILTER_TYPES.multiSelect,
        value: [],
        gpu: false
      });

    case _constants.ALL_FIELD_TYPES.timestamp:
      // @ts-expect-error
      return _objectSpread(_objectSpread({}, filterProps), {}, {
        type: _constants.FILTER_TYPES.timeRange,
        enlarged: true,
        fixedDomain: true,
        value: filterProps.domain,
        gpu: true
      });

    default:
      // @ts-expect-error
      return {};
  }
}

var getPolygonFilterFunctor = function getPolygonFilterFunctor(layer, filter, dataContainer) {
  var getPosition = layer.getPositionAccessor(dataContainer);

  switch (layer.type) {
    case _constants.LAYER_TYPES.point:
    case _constants.LAYER_TYPES.icon:
      return function (data) {
        var pos = getPosition(data);
        return pos.every(Number.isFinite) && isInPolygon(pos, filter.value);
      };

    case _constants.LAYER_TYPES.arc:
    case _constants.LAYER_TYPES.line:
      return function (data) {
        var pos = getPosition(data);
        return pos.every(Number.isFinite) && [[pos[0], pos[1]], [pos[3], pos[4]]].every(function (point) {
          return isInPolygon(point, filter.value);
        });
      };

    case _constants.LAYER_TYPES.hexagonId:
      if (layer.dataToFeature && layer.dataToFeature.centroids) {
        return function (data) {
          // null or getCentroid({id})
          var centroid = layer.dataToFeature.centroids[data.index];
          return centroid && isInPolygon(centroid, filter.value);
        };
      }

      return function (data) {
        var id = getPosition(data);

        if (!(0, _h3Js.h3IsValid)(id)) {
          return false;
        }

        var pos = (0, _h3Utils.getCentroid)({
          id: id
        });
        return pos.every(Number.isFinite) && isInPolygon(pos, filter.value);
      };

    default:
      return function () {
        return true;
      };
  }
};
/**
 * @param param An object that represents a row record.
 * @param param.index Index of the row in data container.
 * @returns Returns true to keep the element, or false otherwise.
 */


exports.getPolygonFilterFunctor = getPolygonFilterFunctor;

/**
 * @param field dataset Field
 * @param dataId Dataset id
 * @param filter Filter object
 * @param layers list of layers to filter upon
 * @param dataContainer Data container
 * @return filterFunction
 */

/* eslint-disable complexity */
function getFilterFunction(field, dataId, filter, layers, dataContainer) {
  // field could be null in polygon filter
  var valueAccessor = field ? field.valueAccessor : function (data) {
    return null;
  };

  var defaultFunc = function defaultFunc(d) {
    return true;
  };

  switch (filter.type) {
    case _constants.FILTER_TYPES.range:
      return function (data) {
        return isInRange(valueAccessor(data), filter.value);
      };

    case _constants.FILTER_TYPES.multiSelect:
      return function (data) {
        return filter.value.includes(valueAccessor(data));
      };

    case _constants.FILTER_TYPES.select:
      return function (data) {
        return valueAccessor(data) === filter.value;
      };

    case _constants.FILTER_TYPES.timeRange:
      if (!field) {
        return defaultFunc;
      }

      var mappedValue = (0, _lodash["default"])(field, ['filterProps', 'mappedValue']);
      var accessor = Array.isArray(mappedValue) ? function (data) {
        return mappedValue[data.index];
      } : function (data) {
        return (0, _dataUtils.timeToUnixMilli)(valueAccessor(data), field.format);
      };
      return function (data) {
        return isInRange(accessor(data), filter.value);
      };

    case _constants.FILTER_TYPES.polygon:
      if (!layers || !layers.length || !filter.layerId) {
        return defaultFunc;
      }

      var layerFilterFunctions = filter.layerId.map(function (id) {
        return layers.find(function (l) {
          return l.id === id;
        });
      }).filter(function (l) {
        return l && l.config.dataId === dataId;
      }).map(function (layer) {
        return getPolygonFilterFunctor(layer, filter, dataContainer);
      });
      return function (data) {
        return layerFilterFunctions.every(function (filterFunc) {
          return filterFunc(data);
        });
      };

    default:
      return defaultFunc;
  }
}

function updateFilterDataId(dataId) {
  return getDefaultFilter(dataId);
}

function filterDataByFilterTypes(_ref2, dataContainer) {
  var dynamicDomainFilters = _ref2.dynamicDomainFilters,
      cpuFilters = _ref2.cpuFilters,
      filterFuncs = _ref2.filterFuncs;
  var filteredIndexForDomain = [];
  var filteredIndex = [];
  var filterContext = {
    index: -1,
    dataContainer: dataContainer
  };

  var filterFuncCaller = function filterFuncCaller(filter) {
    return filterFuncs[filter.id](filterContext);
  };

  var numRows = dataContainer.numRows();

  for (var i = 0; i < numRows; ++i) {
    filterContext.index = i;
    var matchForDomain = dynamicDomainFilters && dynamicDomainFilters.every(filterFuncCaller);

    if (matchForDomain) {
      filteredIndexForDomain.push(filterContext.index);
    }

    var matchForRender = cpuFilters && cpuFilters.every(filterFuncCaller);

    if (matchForRender) {
      filteredIndex.push(filterContext.index);
    }
  }

  return _objectSpread(_objectSpread({}, dynamicDomainFilters ? {
    filteredIndexForDomain: filteredIndexForDomain
  } : {}), cpuFilters ? {
    filteredIndex: filteredIndex
  } : {});
}
/**
 * Get a record of filters based on domain type and gpu / cpu
 */


function getFilterRecord(dataId, filters) {
  var opt = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var filterRecord = {
    dynamicDomain: [],
    fixedDomain: [],
    cpu: [],
    gpu: []
  };
  filters.forEach(function (f) {
    if (isValidFilterValue(f.type, f.value) && (0, _utils.toArray)(f.dataId).includes(dataId)) {
      (f.fixedDomain || opt.ignoreDomain ? filterRecord.fixedDomain : filterRecord.dynamicDomain).push(f);
      (f.gpu && !opt.cpuOnly ? filterRecord.gpu : filterRecord.cpu).push(f);
    }
  });
  return filterRecord;
}
/**
 * Compare filter records to get what has changed
 */


function diffFilters(filterRecord) {
  var oldFilterRecord = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var filterChanged = {};
  Object.entries(filterRecord).forEach(function (_ref3) {
    var _ref4 = (0, _slicedToArray2["default"])(_ref3, 2),
        record = _ref4[0],
        items = _ref4[1];

    items.forEach(function (filter) {
      var oldFilter = (oldFilterRecord[record] || []).find(function (f) {
        return f.id === filter.id;
      });

      if (!oldFilter) {
        // added
        filterChanged = (0, _utils.set)([record, filter.id], 'added', filterChanged);
      } else {
        // check  what has changed
        ['name', 'value', 'dataId'].forEach(function (prop) {
          if (filter[prop] !== oldFilter[prop]) {
            filterChanged = (0, _utils.set)([record, filter.id], "".concat(prop, "_changed"), filterChanged);
          }
        });
      }
    });
    (oldFilterRecord[record] || []).forEach(function (oldFilter) {
      // deleted
      if (!items.find(function (f) {
        return f.id === oldFilter.id;
      })) {
        filterChanged = (0, _utils.set)([record, oldFilter.id], 'deleted', filterChanged);
      }
    });
  });
  return _objectSpread(_objectSpread({}, {
    dynamicDomain: null,
    fixedDomain: null,
    cpu: null,
    gpu: null
  }), filterChanged);
}
/**
 * Call by parsing filters from URL
 * Check if value of filter within filter domain, if not adjust it to match
 * filter domain
 *
 * @returns value - adjusted value to match filter or null to remove filter
 */
// eslint-disable-next-line complexity


function adjustValueToFilterDomain(value, _ref5) {
  var domain = _ref5.domain,
      type = _ref5.type;

  if (!type) {
    return false;
  } // if the current filter is a polygon it will not have any domain
  // all other filter types require domain


  if (type !== _constants.FILTER_TYPES.polygon && !domain) {
    return false;
  }

  switch (type) {
    case _constants.FILTER_TYPES.range:
    case _constants.FILTER_TYPES.timeRange:
      if (!Array.isArray(value) || value.length !== 2) {
        return domain.map(function (d) {
          return d;
        });
      }

      return value.map(function (d, i) {
        return (0, _dataUtils.notNullorUndefined)(d) && isInRange(d, domain) ? d : domain[i];
      });

    case _constants.FILTER_TYPES.multiSelect:
      if (!Array.isArray(value)) {
        return [];
      }

      var filteredValue = value.filter(function (d) {
        return domain.includes(d);
      });
      return filteredValue.length ? filteredValue : [];

    case _constants.FILTER_TYPES.select:
      return domain.includes(value) ? value : true;

    case _constants.FILTER_TYPES.polygon:
      return value;

    default:
      return null;
  }
}
/* eslint-enable complexity */

/**
 * Calculate numeric domain and suitable step
 */


function getNumericFieldDomain(dataContainer, valueAccessor) {
  var domain = [0, 1];
  var step = 0.1;
  var mappedValue = dataContainer.mapIndex(valueAccessor);

  if (dataContainer.numRows() > 1) {
    domain = ScaleUtils.getLinearDomain(mappedValue);
    var diff = domain[1] - domain[0]; // in case equal domain, [96, 96], which will break quantize scale

    if (!diff) {
      domain[1] = domain[0] + 1;
    }

    step = getNumericStepSize(diff) || step;
    domain[0] = formatNumberByStep(domain[0], step, 'floor');
    domain[1] = formatNumberByStep(domain[1], step, 'ceil');
  }

  var _getHistogram = getHistogram(domain, mappedValue),
      histogram = _getHistogram.histogram,
      enlargedHistogram = _getHistogram.enlargedHistogram;

  return {
    domain: domain,
    step: step,
    histogram: histogram,
    enlargedHistogram: enlargedHistogram
  };
}
/**
 * Calculate step size for range and timerange filter
 */


function getNumericStepSize(diff) {
  diff = Math.abs(diff);

  if (diff > 100) {
    return 1;
  } else if (diff > 3) {
    return 0.01;
  } else if (diff > 1) {
    return 0.001;
  } // Try to get at least 1000 steps - and keep the step size below that of
  // the (diff > 1) case.


  var x = diff / 1000; // Find the exponent and truncate to 10 to the power of that exponent

  var exponentialForm = x.toExponential();
  var exponent = parseFloat(exponentialForm.split('e')[1]); // Getting ready for node 12
  // this is why we need decimal.js
  // Math.pow(10, -5) = 0.000009999999999999999
  // the above result shows in browser and node 10
  // node 12 behaves correctly

  return new _decimal.Decimal(10).pow(exponent).toNumber();
}
/**
 * Calculate timestamp domain and suitable step
 */


function getTimestampFieldDomain(dataContainer, valueAccessor) {
  // to avoid converting string format time to epoch
  // every time we compare we store a value mapped to int in filter domain
  var mappedValue = dataContainer.mapIndex(valueAccessor);
  var domain = ScaleUtils.getLinearDomain(mappedValue);
  var defaultTimeFormat = getTimeWidgetTitleFormatter(domain);
  var step = 0.01;
  var diff = domain[1] - domain[0];
  var entry = TimestampStepMap.find(function (f) {
    return f.max >= diff;
  });

  if (entry) {
    step = entry.step;
  }

  var _getHistogram2 = getHistogram(domain, mappedValue),
      histogram = _getHistogram2.histogram,
      enlargedHistogram = _getHistogram2.enlargedHistogram;

  return {
    domain: domain,
    step: step,
    mappedValue: mappedValue,
    histogram: histogram,
    enlargedHistogram: enlargedHistogram,
    defaultTimeFormat: defaultTimeFormat
  };
}

function histogramConstruct(domain, mappedValue, bins) {
  return (0, _d3Array.histogram)().thresholds((0, _d3Array.ticks)(domain[0], domain[1], bins)).domain(domain)(mappedValue).map(function (bin) {
    return {
      count: bin.length,
      bin: bin,
      x0: bin.x0,
      x1: bin.x1
    };
  });
}
/**
 * Calculate histogram from domain and array of values
 */


function getHistogram(domain, mappedValue) {
  var histogram = histogramConstruct(domain, mappedValue, histogramBins);
  var enlargedHistogram = histogramConstruct(domain, mappedValue, enlargedHistogramBins);
  return {
    histogram: histogram,
    enlargedHistogram: enlargedHistogram
  };
}
/**
 * round number based on step
 *
 * @param {Number} val
 * @param {Number} step
 * @param {string} bound
 * @returns {Number} rounded number
 */


function formatNumberByStep(val, step, bound) {
  if (bound === 'floor') {
    return Math.floor(val * (1 / step)) / (1 / step);
  }

  return Math.ceil(val * (1 / step)) / (1 / step);
}

function isInRange(val, domain) {
  if (!Array.isArray(domain)) {
    return false;
  }

  return val >= domain[0] && val <= domain[1];
}
/**
 * Determines whether a point is within the provided polygon
 *
 * @param point as input search [lat, lng]
 * @param polygon Points must be within these (Multi)Polygon(s)
 * @return {boolean}
 */


function isInPolygon(point, polygon) {
  return (0, _booleanWithin["default"])((0, _helpers.point)(point), polygon);
}

function getTimeWidgetTitleFormatter(domain) {
  if (!isValidTimeDomain(domain)) {
    return null;
  }

  var diff = domain[1] - domain[0]; // Local aware formats
  // https://momentjs.com/docs/#/parsing/string-format

  return diff > durationYear ? 'L' : diff > durationDay ? 'L LT' : 'L LTS';
}
/**
 * Sanity check on filters to prepare for save
 * @type {typeof import('./filter-utils').isFilterValidToSave}
 */


function isFilterValidToSave(filter) {
  return (filter === null || filter === void 0 ? void 0 : filter.type) && Array.isArray(filter === null || filter === void 0 ? void 0 : filter.name) && ((filter === null || filter === void 0 ? void 0 : filter.name.length) || (filter === null || filter === void 0 ? void 0 : filter.layerId.length)) && isValidFilterValue(filter === null || filter === void 0 ? void 0 : filter.type, filter === null || filter === void 0 ? void 0 : filter.value);
}
/**
 * Sanity check on filters to prepare for save
 * @type {typeof import('./filter-utils').isValidFilterValue}
 */

/* eslint-disable complexity */


function isValidFilterValue(type, value) {
  if (!type) {
    return false;
  }

  switch (type) {
    case _constants.FILTER_TYPES.select:
      return value === true || value === false;

    case _constants.FILTER_TYPES.range:
    case _constants.FILTER_TYPES.timeRange:
      return Array.isArray(value) && value.every(function (v) {
        return v !== null && !isNaN(v);
      });

    case _constants.FILTER_TYPES.multiSelect:
      return Array.isArray(value) && Boolean(value.length);

    case _constants.FILTER_TYPES.input:
      return Boolean(value.length);

    case _constants.FILTER_TYPES.polygon:
      var coordinates = (0, _lodash["default"])(value, ['geometry', 'coordinates']);
      return Boolean(value && value.id && coordinates);

    default:
      return true;
  }
}

function getColumnFilterProps(filter, dataset) {
  if (filter.plotType === _constants.PLOT_TYPES.histogram || !filter.yAxis) {
    // histogram should be calculated when create filter
    return {};
  }

  var _filter$mappedValue = filter.mappedValue,
      mappedValue = _filter$mappedValue === void 0 ? [] : _filter$mappedValue;
  var yAxis = filter.yAxis;
  var fieldIdx = dataset.getColumnFieldIdx(yAxis.name);

  if (fieldIdx < 0) {
    _console["default"].warn("yAxis ".concat(yAxis.name, " does not exist in dataset"));

    return {
      lineChart: {},
      yAxis: yAxis
    };
  } // return lineChart


  var series = dataset.dataContainer.map(function (row, rowIndex) {
    return {
      x: mappedValue[rowIndex],
      y: row.valueAt(fieldIdx)
    };
  }, true).filter(function (_ref6) {
    var x = _ref6.x,
        y = _ref6.y;
    return Number.isFinite(x) && Number.isFinite(y);
  }).sort(function (a, b) {
    return (0, _d3Array.ascending)(a.x, b.x);
  });
  var yDomain = (0, _d3Array.extent)(series, function (d) {
    return d.y;
  });
  var xDomain = [series[0].x, series[series.length - 1].x];
  return {
    lineChart: {
      series: series,
      yDomain: yDomain,
      xDomain: xDomain
    },
    yAxis: yAxis
  };
}

function getDefaultFilterPlotType(filter) {
  var filterPlotTypes = filter.type && SupportedPlotType[filter.type];

  if (!filterPlotTypes) {
    return null;
  }

  if (!filter.yAxis) {
    return filterPlotTypes["default"];
  }

  return filterPlotTypes[filter.yAxis.type] || null;
}
/**
 *
 * @param datasetIds list of dataset ids to be filtered
 * @param datasets all datasets
 * @param filters all filters to be applied to datasets
 * @return datasets - new updated datasets
 */


function applyFiltersToDatasets(datasetIds, datasets, filters, layers) {
  var dataIds = (0, _utils.toArray)(datasetIds);
  return dataIds.reduce(function (acc, dataId) {
    var layersToFilter = (layers || []).filter(function (l) {
      return l.config.dataId === dataId;
    });
    var appliedFilters = filters.filter(function (d) {
      return shouldApplyFilter(d, dataId);
    });
    var table = datasets[dataId];
    return _objectSpread(_objectSpread({}, acc), {}, (0, _defineProperty2["default"])({}, dataId, table.filterTable(appliedFilters, layersToFilter, {})));
  }, datasets);
}
/**
 * Applies a new field name value to fielter and update both filter and dataset
 * @param filter - to be applied the new field name on
 * @param dataset - dataset the field belongs to
 * @param fieldName - field.name
 * @param filterDatasetIndex - field.name
 * @param option
 * @return - {filter, datasets}
 */


function applyFilterFieldName(filter, dataset, fieldName) {
  var filterDatasetIndex = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
  var option = arguments.length > 4 ? arguments[4] : undefined;
  // using filterDatasetIndex we can filter only the specified dataset
  var mergeDomain = option && option.hasOwnProperty('mergeDomain') ? option.mergeDomain : false;
  var fieldIndex = dataset.getColumnFieldIdx(fieldName); // if no field with same name is found, move to the next datasets

  if (fieldIndex === -1) {
    // throw new Error(`fieldIndex not found. Dataset must contain a property with name: ${fieldName}`);
    return {
      filter: null,
      dataset: dataset
    };
  } // TODO: validate field type


  var filterProps = dataset.getColumnFilterProps(fieldName);

  var newFilter = _objectSpread(_objectSpread({}, mergeDomain ? mergeFilterDomainStep(filter, filterProps) : _objectSpread(_objectSpread({}, filter), filterProps)), {}, {
    name: Object.assign((0, _toConsumableArray2["default"])((0, _utils.toArray)(filter.name)), (0, _defineProperty2["default"])({}, filterDatasetIndex, fieldName)),
    fieldIdx: Object.assign((0, _toConsumableArray2["default"])((0, _utils.toArray)(filter.fieldIdx)), (0, _defineProperty2["default"])({}, filterDatasetIndex, fieldIndex)),
    // TODO, since we allow to add multiple fields to a filter we can no longer freeze the filter
    freeze: true
  });

  return {
    filter: newFilter,
    dataset: dataset
  };
}
/**
 * Merge one filter with other filter prop domain
 */

/* eslint-disable complexity */


function mergeFilterDomainStep(filter, filterProps) {
  if (!filter) {
    return null;
  }

  if (!filterProps) {
    return filter;
  }

  if (filter.fieldType && filter.fieldType !== filterProps.fieldType || !filterProps.domain) {
    return filter;
  }

  var combinedDomain = !filter.domain ? filterProps.domain : [].concat((0, _toConsumableArray2["default"])(filter.domain || []), (0, _toConsumableArray2["default"])(filterProps.domain || [])).sort(function (a, b) {
    return a - b;
  });

  var newFilter = _objectSpread(_objectSpread(_objectSpread({}, filter), filterProps), {}, {
    domain: [combinedDomain[0], combinedDomain[combinedDomain.length - 1]]
  });

  switch (filterProps.fieldType) {
    case _constants.ALL_FIELD_TYPES.string:
    case _constants.ALL_FIELD_TYPES.date:
      return _objectSpread(_objectSpread({}, newFilter), {}, {
        domain: (0, _dataUtils.unique)(combinedDomain).sort()
      });

    case _constants.ALL_FIELD_TYPES.timestamp:
      var step = filter.step < filterProps.step ? filter.step : filterProps.step;
      return _objectSpread(_objectSpread({}, newFilter), {}, {
        step: step
      });

    case _constants.ALL_FIELD_TYPES.real:
    case _constants.ALL_FIELD_TYPES.integer:
    default:
      return newFilter;
  }
}
/* eslint-enable complexity */

/**
 * Generates polygon filter
 */


var featureToFilterValue = function featureToFilterValue(feature, filterId, properties) {
  return _objectSpread(_objectSpread({}, feature), {}, {
    id: feature.id,
    properties: _objectSpread(_objectSpread(_objectSpread({}, feature.properties), properties), {}, {
      filterId: filterId
    })
  });
};

exports.featureToFilterValue = featureToFilterValue;

var getFilterIdInFeature = function getFilterIdInFeature(f) {
  return (0, _lodash["default"])(f, ['properties', 'filterId']);
};
/**
 * Generates polygon filter
 */


exports.getFilterIdInFeature = getFilterIdInFeature;

function generatePolygonFilter(layers, feature) {
  var dataId = layers.map(function (l) {
    return l.config.dataId;
  }).filter(_dataUtils.notNullorUndefined);
  var layerId = layers.map(function (l) {
    return l.id;
  });
  var name = layers.map(function (l) {
    return l.config.label;
  });
  var filter = getDefaultFilter(dataId);
  return _objectSpread(_objectSpread({}, filter), {}, {
    fixedDomain: true,
    type: _constants.FILTER_TYPES.polygon,
    name: name,
    layerId: layerId,
    value: featureToFilterValue(feature, filter.id, {
      isVisible: true
    })
  });
}
/**
 * Run filter entirely on CPU
 */


function filterDatasetCPU(state, dataId) {
  var datasetFilters = state.filters.filter(function (f) {
    return f.dataId.includes(dataId);
  });
  var dataset = state.datasets[dataId];

  if (!dataset) {
    return state;
  }

  var cpuFilteredDataset = dataset.filterTableCPU(datasetFilters, state.layers);
  return (0, _utils.set)(['datasets', dataId], cpuFilteredDataset, state);
}
/**
 * Validate parsed filters with datasets and add filterProps to field
 */


function validateFiltersUpdateDatasets(state) {
  var filtersToValidate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  // TODO Better Typings here
  var validated = [];
  var failed = [];
  var datasets = state.datasets;
  var updatedDatasets = datasets; // merge filters

  filtersToValidate.forEach(function (filter) {
    // we can only look for datasets define in the filter dataId
    var datasetIds = (0, _utils.toArray)(filter.dataId); // we can merge a filter only if all datasets in filter.dataId are loaded

    if (datasetIds.every(function (d) {
      return datasets[d];
    })) {
      // all datasetIds in filter must be present the state datasets
      var _datasetIds$reduce = datasetIds.reduce(function (acc, datasetId) {
        var dataset = updatedDatasets[datasetId];
        var layers = state.layers.filter(function (l) {
          return l.config.dataId === dataset.id;
        });

        var _validateFilterWithDa = validateFilterWithData(acc.augmentedDatasets[datasetId] || dataset, filter, layers),
            updatedFilter = _validateFilterWithDa.filter,
            updatedDataset = _validateFilterWithDa.dataset;

        if (updatedFilter) {
          return _objectSpread(_objectSpread({}, acc), {}, {
            // merge filter props
            filter: acc.filter ? _objectSpread(_objectSpread({}, acc.filter), mergeFilterDomainStep(acc, updatedFilter)) : updatedFilter,
            applyToDatasets: [].concat((0, _toConsumableArray2["default"])(acc.applyToDatasets), [datasetId]),
            augmentedDatasets: _objectSpread(_objectSpread({}, acc.augmentedDatasets), {}, (0, _defineProperty2["default"])({}, datasetId, updatedDataset))
          });
        }

        return acc;
      }, {
        filter: null,
        applyToDatasets: [],
        augmentedDatasets: {}
      }),
          validatedFilter = _datasetIds$reduce.filter,
          applyToDatasets = _datasetIds$reduce.applyToDatasets,
          augmentedDatasets = _datasetIds$reduce.augmentedDatasets;

      if (validatedFilter && (0, _lodash2["default"])(datasetIds, applyToDatasets)) {
        validated.push(validatedFilter);
        updatedDatasets = _objectSpread(_objectSpread({}, updatedDatasets), augmentedDatasets);
      }
    } else {
      failed.push(filter);
    }
  });
  return {
    validated: validated,
    failed: failed,
    updatedDatasets: updatedDatasets
  };
}

function getFilterPlot(filter, dataset) {
  if (filter.plotType === _constants.PLOT_TYPES.histogram || !filter.yAxis) {
    // histogram should be calculated when create filter
    return {};
  }

  var _filter$mappedValue2 = filter.mappedValue,
      mappedValue = _filter$mappedValue2 === void 0 ? [] : _filter$mappedValue2;
  var yAxis = filter.yAxis;
  var fieldIdx = dataset.getColumnFieldIdx(yAxis.name);

  if (fieldIdx < 0) {
    _console["default"].warn("yAxis ".concat(yAxis.name, " does not exist in dataset"));

    return {
      lineChart: {},
      yAxis: yAxis
    };
  } // return lineChart


  var series = dataset.dataContainer.map(function (row, rowIndex) {
    return {
      x: mappedValue[rowIndex],
      y: row.valueAt(fieldIdx)
    };
  }, true).filter(function (_ref7) {
    var x = _ref7.x,
        y = _ref7.y;
    return Number.isFinite(x) && Number.isFinite(y);
  }).sort(function (a, b) {
    return (0, _d3Array.ascending)(a.x, b.x);
  });
  var yDomain = (0, _d3Array.extent)(series, function (d) {
    return d.y;
  });
  var xDomain = [series[0].x, series[series.length - 1].x];
  return {
    lineChart: {
      series: series,
      yDomain: yDomain,
      xDomain: xDomain
    },
    yAxis: yAxis
  };
}
/**
 * Retrieve interval bins for time filter
 */


function getIntervalBins(filter) {
  var _filter$plotType;

  var bins = filter.bins;
  var interval = (_filter$plotType = filter.plotType) === null || _filter$plotType === void 0 ? void 0 : _filter$plotType.interval;

  if (!interval || !bins || Object.keys(bins).length === 0) {
    return null;
  }

  var values = Object.values(bins);
  return values[0] ? values[0][interval] : null;
}

function isValidTimeDomain(domain) {
  return Array.isArray(domain) && domain.every(Number.isFinite);
}

function getTimeWidgetHintFormatter(domain) {
  if (!isValidTimeDomain(domain)) {
    return undefined;
  }

  var diff = domain[1] - domain[0];
  return diff > durationWeek ? 'L' : diff > durationDay ? 'L LT' : diff > durationHour ? 'LT' : 'LTS';
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9maWx0ZXItdXRpbHMudHMiXSwibmFtZXMiOlsiZHVyYXRpb25TZWNvbmQiLCJkdXJhdGlvbk1pbnV0ZSIsImR1cmF0aW9uSG91ciIsImR1cmF0aW9uRGF5IiwiZHVyYXRpb25XZWVrIiwiZHVyYXRpb25ZZWFyIiwiVGltZXN0YW1wU3RlcE1hcCIsIm1heCIsInN0ZXAiLCJOdW1iZXIiLCJQT1NJVElWRV9JTkZJTklUWSIsImhpc3RvZ3JhbUJpbnMiLCJlbmxhcmdlZEhpc3RvZ3JhbUJpbnMiLCJGSUxURVJfVVBEQVRFUl9QUk9QUyIsImRhdGFJZCIsIm5hbWUiLCJsYXllcklkIiwiTElNSVRFRF9GSUxURVJfRUZGRUNUX1BST1BTIiwiU3VwcG9ydGVkUGxvdFR5cGUiLCJGSUxURVJfVFlQRVMiLCJ0aW1lUmFuZ2UiLCJBTExfRklFTERfVFlQRVMiLCJpbnRlZ2VyIiwicmVhbCIsInJhbmdlIiwiRklMVEVSX0NPTVBPTkVOVFMiLCJzZWxlY3QiLCJtdWx0aVNlbGVjdCIsInBvbHlnb24iLCJERUZBVUxUX0ZJTFRFUl9TVFJVQ1RVUkUiLCJmcmVlemUiLCJpZCIsImZpeGVkRG9tYWluIiwiZW5sYXJnZWQiLCJpc0FuaW1hdGluZyIsImFuaW1hdGlvbldpbmRvdyIsIkFOSU1BVElPTl9XSU5ET1ciLCJmcmVlIiwic3BlZWQiLCJ0eXBlIiwiZmllbGRJZHgiLCJkb21haW4iLCJ2YWx1ZSIsInBsb3RUeXBlIiwiUExPVF9UWVBFUyIsImhpc3RvZ3JhbSIsInlBeGlzIiwiaW50ZXJ2YWwiLCJncHUiLCJGSUxURVJfSURfTEVOR1RIIiwiTEFZRVJfRklMVEVSUyIsImdldERlZmF1bHRGaWx0ZXIiLCJzaG91bGRBcHBseUZpbHRlciIsImZpbHRlciIsImRhdGFzZXRJZCIsImRhdGFJZHMiLCJpbmNsdWRlcyIsInZhbGlkYXRlUG9seWdvbkZpbHRlciIsImRhdGFzZXQiLCJsYXllcnMiLCJmYWlsZWQiLCJpc1ZhbGlkRmlsdGVyVmFsdWUiLCJpc1ZhbGlkRGF0YXNldCIsImxheWVyIiwiZmluZCIsImwiLCJmaWx0ZXJWYWxpZGF0b3JzIiwidmFsaWRhdGVGaWx0ZXIiLCJmaWx0ZXJEYXRhSWQiLCJmaWx0ZXJEYXRhc2V0SW5kZXgiLCJpbmRleE9mIiwiaW5pdGlhbGl6ZUZpbHRlciIsImZpZWxkTmFtZSIsImFwcGx5RmlsdGVyRmllbGROYW1lIiwibWVyZ2VEb21haW4iLCJ1cGRhdGVkRmlsdGVyIiwidXBkYXRlZERhdGFzZXQiLCJhZGp1c3RWYWx1ZVRvRmlsdGVyRG9tYWluIiwidmFsaWRhdGVGaWx0ZXJZQXhpcyIsInZhbGlkYXRlRmlsdGVyV2l0aERhdGEiLCJoYXNPd25Qcm9wZXJ0eSIsImZpZWxkcyIsIm1hdGNoZWRBeGlzIiwiZ2V0RmlsdGVyUGxvdCIsImdldEZpbHRlclByb3BzIiwiZmllbGQiLCJmaWVsZERvbWFpbiIsImZpbHRlclByb3BzIiwiZmllbGRUeXBlIiwidHlwZU9wdGlvbnMiLCJzdHJpbmciLCJkYXRlIiwidGltZXN0YW1wIiwiZ2V0UG9seWdvbkZpbHRlckZ1bmN0b3IiLCJkYXRhQ29udGFpbmVyIiwiZ2V0UG9zaXRpb24iLCJnZXRQb3NpdGlvbkFjY2Vzc29yIiwiTEFZRVJfVFlQRVMiLCJwb2ludCIsImljb24iLCJkYXRhIiwicG9zIiwiZXZlcnkiLCJpc0Zpbml0ZSIsImlzSW5Qb2x5Z29uIiwiYXJjIiwibGluZSIsImhleGFnb25JZCIsImRhdGFUb0ZlYXR1cmUiLCJjZW50cm9pZHMiLCJjZW50cm9pZCIsImluZGV4IiwiZ2V0RmlsdGVyRnVuY3Rpb24iLCJ2YWx1ZUFjY2Vzc29yIiwiZGVmYXVsdEZ1bmMiLCJkIiwiaXNJblJhbmdlIiwibWFwcGVkVmFsdWUiLCJhY2Nlc3NvciIsIkFycmF5IiwiaXNBcnJheSIsImZvcm1hdCIsImxlbmd0aCIsImxheWVyRmlsdGVyRnVuY3Rpb25zIiwibWFwIiwiY29uZmlnIiwiZmlsdGVyRnVuYyIsInVwZGF0ZUZpbHRlckRhdGFJZCIsImZpbHRlckRhdGFCeUZpbHRlclR5cGVzIiwiZHluYW1pY0RvbWFpbkZpbHRlcnMiLCJjcHVGaWx0ZXJzIiwiZmlsdGVyRnVuY3MiLCJmaWx0ZXJlZEluZGV4Rm9yRG9tYWluIiwiZmlsdGVyZWRJbmRleCIsImZpbHRlckNvbnRleHQiLCJmaWx0ZXJGdW5jQ2FsbGVyIiwibnVtUm93cyIsImkiLCJtYXRjaEZvckRvbWFpbiIsInB1c2giLCJtYXRjaEZvclJlbmRlciIsImdldEZpbHRlclJlY29yZCIsImZpbHRlcnMiLCJvcHQiLCJmaWx0ZXJSZWNvcmQiLCJkeW5hbWljRG9tYWluIiwiY3B1IiwiZm9yRWFjaCIsImYiLCJpZ25vcmVEb21haW4iLCJjcHVPbmx5IiwiZGlmZkZpbHRlcnMiLCJvbGRGaWx0ZXJSZWNvcmQiLCJmaWx0ZXJDaGFuZ2VkIiwiT2JqZWN0IiwiZW50cmllcyIsInJlY29yZCIsIml0ZW1zIiwib2xkRmlsdGVyIiwicHJvcCIsImZpbHRlcmVkVmFsdWUiLCJnZXROdW1lcmljRmllbGREb21haW4iLCJtYXBJbmRleCIsIlNjYWxlVXRpbHMiLCJnZXRMaW5lYXJEb21haW4iLCJkaWZmIiwiZ2V0TnVtZXJpY1N0ZXBTaXplIiwiZm9ybWF0TnVtYmVyQnlTdGVwIiwiZ2V0SGlzdG9ncmFtIiwiZW5sYXJnZWRIaXN0b2dyYW0iLCJNYXRoIiwiYWJzIiwieCIsImV4cG9uZW50aWFsRm9ybSIsInRvRXhwb25lbnRpYWwiLCJleHBvbmVudCIsInBhcnNlRmxvYXQiLCJzcGxpdCIsIkRlY2ltYWwiLCJwb3ciLCJ0b051bWJlciIsImdldFRpbWVzdGFtcEZpZWxkRG9tYWluIiwiZGVmYXVsdFRpbWVGb3JtYXQiLCJnZXRUaW1lV2lkZ2V0VGl0bGVGb3JtYXR0ZXIiLCJlbnRyeSIsImhpc3RvZ3JhbUNvbnN0cnVjdCIsImJpbnMiLCJ0aHJlc2hvbGRzIiwiYmluIiwiY291bnQiLCJ4MCIsIngxIiwidmFsIiwiYm91bmQiLCJmbG9vciIsImNlaWwiLCJpc1ZhbGlkVGltZURvbWFpbiIsImlzRmlsdGVyVmFsaWRUb1NhdmUiLCJ2IiwiaXNOYU4iLCJCb29sZWFuIiwiaW5wdXQiLCJjb29yZGluYXRlcyIsImdldENvbHVtbkZpbHRlclByb3BzIiwiZ2V0Q29sdW1uRmllbGRJZHgiLCJDb25zb2xlIiwid2FybiIsImxpbmVDaGFydCIsInNlcmllcyIsInJvdyIsInJvd0luZGV4IiwieSIsInZhbHVlQXQiLCJzb3J0IiwiYSIsImIiLCJ5RG9tYWluIiwieERvbWFpbiIsImdldERlZmF1bHRGaWx0ZXJQbG90VHlwZSIsImZpbHRlclBsb3RUeXBlcyIsImFwcGx5RmlsdGVyc1RvRGF0YXNldHMiLCJkYXRhc2V0SWRzIiwiZGF0YXNldHMiLCJyZWR1Y2UiLCJhY2MiLCJsYXllcnNUb0ZpbHRlciIsImFwcGxpZWRGaWx0ZXJzIiwidGFibGUiLCJmaWx0ZXJUYWJsZSIsIm9wdGlvbiIsImZpZWxkSW5kZXgiLCJuZXdGaWx0ZXIiLCJtZXJnZUZpbHRlckRvbWFpblN0ZXAiLCJhc3NpZ24iLCJjb21iaW5lZERvbWFpbiIsImZlYXR1cmVUb0ZpbHRlclZhbHVlIiwiZmVhdHVyZSIsImZpbHRlcklkIiwicHJvcGVydGllcyIsImdldEZpbHRlcklkSW5GZWF0dXJlIiwiZ2VuZXJhdGVQb2x5Z29uRmlsdGVyIiwibm90TnVsbG9yVW5kZWZpbmVkIiwibGFiZWwiLCJpc1Zpc2libGUiLCJmaWx0ZXJEYXRhc2V0Q1BVIiwic3RhdGUiLCJkYXRhc2V0RmlsdGVycyIsImNwdUZpbHRlcmVkRGF0YXNldCIsImZpbHRlclRhYmxlQ1BVIiwidmFsaWRhdGVGaWx0ZXJzVXBkYXRlRGF0YXNldHMiLCJmaWx0ZXJzVG9WYWxpZGF0ZSIsInZhbGlkYXRlZCIsInVwZGF0ZWREYXRhc2V0cyIsImF1Z21lbnRlZERhdGFzZXRzIiwiYXBwbHlUb0RhdGFzZXRzIiwidmFsaWRhdGVkRmlsdGVyIiwiZ2V0SW50ZXJ2YWxCaW5zIiwia2V5cyIsInZhbHVlcyIsImdldFRpbWVXaWRnZXRIaW50Rm9ybWF0dGVyIiwidW5kZWZpbmVkIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7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Q0FBQ0MsT0FBTixDQUFjL0UsTUFBZCxLQUF5QkEsTUFBTSxDQUFDNkQsS0FBUCxDQUFhN0YsTUFBTSxDQUFDOEYsUUFBcEIsQ0FBaEM7QUFDRDs7QUFFTSxTQUFTNEosMEJBQVQsQ0FBb0MxTixNQUFwQyxFQUFrRjtBQUN2RixNQUFJLENBQUMySixpQkFBaUIsQ0FBQzNKLE1BQUQsQ0FBdEIsRUFBZ0M7QUFDOUIsV0FBTzJOLFNBQVA7QUFDRDs7QUFFRCxNQUFNL0YsSUFBSSxHQUFHNUgsTUFBTSxDQUFDLENBQUQsQ0FBTixHQUFZQSxNQUFNLENBQUMsQ0FBRCxDQUEvQjtBQUNBLFNBQU80SCxJQUFJLEdBQUdqSyxZQUFQLEdBQ0gsR0FERyxHQUVIaUssSUFBSSxHQUFHbEssV0FBUCxHQUNBLE1BREEsR0FFQWtLLElBQUksR0FBR25LLFlBQVAsR0FDQSxJQURBLEdBRUEsS0FOSjtBQU9EIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDIyIFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuaW1wb3J0IHthc2NlbmRpbmcsIGV4dGVudCwgaGlzdG9ncmFtIGFzIGQzSGlzdG9ncmFtLCB0aWNrc30gZnJvbSAnZDMtYXJyYXknO1xuaW1wb3J0IGtleU1pcnJvciBmcm9tICdrZXltaXJyb3InO1xuaW1wb3J0IENvbnNvbGUgZnJvbSAnZ2xvYmFsL2NvbnNvbGUnO1xuaW1wb3J0IGdldCBmcm9tICdsb2Rhc2guZ2V0JztcbmltcG9ydCBpc0VxdWFsIGZyb20gJ2xvZGFzaC5pc2VxdWFsJztcblxuaW1wb3J0IGJvb2xlYW5XaXRoaW4gZnJvbSAnQHR1cmYvYm9vbGVhbi13aXRoaW4nO1xuaW1wb3J0IHtwb2ludCBhcyB0dXJmUG9pbnR9IGZyb20gJ0B0dXJmL2hlbHBlcnMnO1xuaW1wb3J0IHtEZWNpbWFsfSBmcm9tICdkZWNpbWFsLmpzJztcbmltcG9ydCB7XG4gIEFMTF9GSUVMRF9UWVBFUyxcbiAgRklMVEVSX1RZUEVTLFxuICBBTklNQVRJT05fV0lORE9XLFxuICBQTE9UX1RZUEVTLFxuICBMQVlFUl9UWVBFU1xufSBmcm9tICdAa2VwbGVyLmdsL2NvbnN0YW50cyc7XG5pbXBvcnQgKiBhcyBTY2FsZVV0aWxzIGZyb20gJy4vZGF0YS1zY2FsZS11dGlscyc7XG5pbXBvcnQge2gzSXNWYWxpZH0gZnJvbSAnaDMtanMnO1xuXG5pbXBvcnQge1xuICBNaWxsaXNlY29uZCxcbiAgRW50cmllcyxcbiAgRmllbGQsXG4gIFBhcnNlZEZpbHRlcixcbiAgRmlsdGVyLFxuICBGaWx0ZXJCYXNlLFxuICBQb2x5Z29uRmlsdGVyLFxuICBGaWVsZERvbWFpbixcbiAgVGltZVJhbmdlRmllbGREb21haW4sXG4gIEhpc3RvZ3JhbUJpbixcbiAgRmVhdHVyZSxcbiAgRmVhdHVyZVZhbHVlLFxuICBMaW5lQ2hhcnQsXG4gIFRpbWVSYW5nZUZpbHRlcixcbiAgUmFuZ2VGaWVsZERvbWFpbixcbiAgRmlsdGVyRGF0YXNldE9wdCxcbiAgRmlsdGVyUmVjb3JkXG59IGZyb20gJ0BrZXBsZXIuZ2wvdHlwZXMnO1xuXG5pbXBvcnQge0RhdGFDb250YWluZXJJbnRlcmZhY2V9IGZyb20gJy4vZGF0YS1jb250YWluZXItaW50ZXJmYWNlJztcbmltcG9ydCB7Z2VuZXJhdGVIYXNoSWQsIHNldCwgdG9BcnJheX0gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQge25vdE51bGxvclVuZGVmaW5lZCwgdGltZVRvVW5peE1pbGxpLCB1bmlxdWV9IGZyb20gJy4vZGF0YS11dGlscyc7XG5pbXBvcnQge2dldENlbnRyb2lkfSBmcm9tICcuL2gzLXV0aWxzJztcblxuZXhwb3J0IGNvbnN0IGR1cmF0aW9uU2Vjb25kID0gMTAwMDtcbmV4cG9ydCBjb25zdCBkdXJhdGlvbk1pbnV0ZSA9IGR1cmF0aW9uU2Vjb25kICogNjA7XG5leHBvcnQgY29uc3QgZHVyYXRpb25Ib3VyID0gZHVyYXRpb25NaW51dGUgKiA2MDtcbmV4cG9ydCBjb25zdCBkdXJhdGlvbkRheSA9IGR1cmF0aW9uSG91ciAqIDI0O1xuZXhwb3J0IGNvbnN0IGR1cmF0aW9uV2VlayA9IGR1cmF0aW9uRGF5ICogNztcbmV4cG9ydCBjb25zdCBkdXJhdGlvblllYXIgPSBkdXJhdGlvbkRheSAqIDM2NTtcblxuZXhwb3J0IHR5cGUgRmlsdGVyUmVzdWx0ID0ge1xuICBmaWx0ZXJlZEluZGV4Rm9yRG9tYWluPzogbnVtYmVyW107XG4gIGZpbHRlcmVkSW5kZXg/OiBudW1iZXJbXTtcbn07XG5cbmV4cG9ydCB0eXBlIEZpbHRlckNoYW5nZWQgPSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuICBba2V5IGluIGtleW9mIEZpbHRlclJlY29yZF06IHtcbiAgICBba2V5OiBzdHJpbmddOiAnYWRkZWQnIHwgJ2RlbGV0ZWQnIHwgJ25hbWVfY2hhbmdlZCcgfCAndmFsdWVfY2hhbmdlZCcgfCAnZGF0YUlkX2NoYW5nZWQnO1xuICB9IHwgbnVsbDtcbn07XG5cbmV4cG9ydCB0eXBlIGRhdGFWYWx1ZUFjY2Vzc29yID0gKGRhdGE6IHtpbmRleDogbnVtYmVyfSkgPT4gbnVtYmVyIHwgbnVsbDtcblxuZXhwb3J0IGNvbnN0IFRpbWVzdGFtcFN0ZXBNYXAgPSBbXG4gIHttYXg6IDEsIHN0ZXA6IDAuMDV9LFxuICB7bWF4OiAxMCwgc3RlcDogMC4xfSxcbiAge21heDogMTAwLCBzdGVwOiAxfSxcbiAge21heDogNTAwLCBzdGVwOiA1fSxcbiAge21heDogMTAwMCwgc3RlcDogMTB9LFxuICB7bWF4OiA1MDAwLCBzdGVwOiA1MH0sXG4gIHttYXg6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSwgc3RlcDogMTAwMH1cbl07XG5cbmV4cG9ydCBjb25zdCBoaXN0b2dyYW1CaW5zID0gMzA7XG5leHBvcnQgY29uc3QgZW5sYXJnZWRIaXN0b2dyYW1CaW5zID0gMTAwO1xuXG5leHBvcnQgY29uc3QgRklMVEVSX1VQREFURVJfUFJPUFMgPSBrZXlNaXJyb3Ioe1xuICBkYXRhSWQ6IG51bGwsXG4gIG5hbWU6IG51bGwsXG4gIGxheWVySWQ6IG51bGxcbn0pO1xuXG5leHBvcnQgY29uc3QgTElNSVRFRF9GSUxURVJfRUZGRUNUX1BST1BTID0ga2V5TWlycm9yKHtcbiAgW0ZJTFRFUl9VUERBVEVSX1BST1BTLm5hbWVdOiBudWxsXG59KTtcbi8qKlxuICogTWF4IG51bWJlciBvZiBmaWx0ZXIgdmFsdWUgYnVmZmVycyB0aGF0IGRlY2suZ2wgcHJvdmlkZXNcbiAqL1xuXG5jb25zdCBTdXBwb3J0ZWRQbG90VHlwZSA9IHtcbiAgW0ZJTFRFUl9UWVBFUy50aW1lUmFuZ2VdOiB7XG4gICAgZGVmYXVsdDogJ2hpc3RvZ3JhbScsXG4gICAgW0FMTF9GSUVMRF9UWVBFUy5pbnRlZ2VyXTogJ2xpbmVDaGFydCcsXG4gICAgW0FMTF9GSUVMRF9UWVBFUy5yZWFsXTogJ2xpbmVDaGFydCdcbiAgfSxcbiAgW0ZJTFRFUl9UWVBFUy5yYW5nZV06IHtcbiAgICBkZWZhdWx0OiAnaGlzdG9ncmFtJyxcbiAgICBbQUxMX0ZJRUxEX1RZUEVTLmludGVnZXJdOiAnbGluZUNoYXJ0JyxcbiAgICBbQUxMX0ZJRUxEX1RZUEVTLnJlYWxdOiAnbGluZUNoYXJ0J1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgRklMVEVSX0NPTVBPTkVOVFMgPSB7XG4gIFtGSUxURVJfVFlQRVMuc2VsZWN0XTogJ1NpbmdsZVNlbGVjdEZpbHRlcicsXG4gIFtGSUxURVJfVFlQRVMubXVsdGlTZWxlY3RdOiAnTXVsdGlTZWxlY3RGaWx0ZXInLFxuICBbRklMVEVSX1RZUEVTLnRpbWVSYW5nZV06ICdUaW1lUmFuZ2VGaWx0ZXInLFxuICBbRklMVEVSX1RZUEVTLnJhbmdlXTogJ1JhbmdlRmlsdGVyJyxcbiAgW0ZJTFRFUl9UWVBFUy5wb2x5Z29uXTogJ1BvbHlnb25GaWx0ZXInXG59O1xuXG5leHBvcnQgY29uc3QgREVGQVVMVF9GSUxURVJfU1RSVUNUVVJFID0ge1xuICBkYXRhSWQ6IFtdLCAvLyBbc3RyaW5nXVxuICBmcmVlemU6IGZhbHNlLFxuICBpZDogbnVsbCxcblxuICAvLyB0aW1lIHJhbmdlIGZpbHRlciBzcGVjaWZpY1xuICBmaXhlZERvbWFpbjogZmFsc2UsXG4gIGVubGFyZ2VkOiBmYWxzZSxcbiAgaXNBbmltYXRpbmc6IGZhbHNlLFxuICBhbmltYXRpb25XaW5kb3c6IEFOSU1BVElPTl9XSU5ET1cuZnJlZSxcbiAgc3BlZWQ6IDEsXG5cbiAgLy8gZmllbGQgc3BlY2lmaWNcbiAgbmFtZTogW10sIC8vIHN0cmluZ1xuICB0eXBlOiBudWxsLFxuICBmaWVsZElkeDogW10sIC8vIFtpbnRlZ2VyXVxuICBkb21haW46IG51bGwsXG4gIHZhbHVlOiBudWxsLFxuXG4gIC8vIHBsb3RcbiAgcGxvdFR5cGU6IFBMT1RfVFlQRVMuaGlzdG9ncmFtLFxuICB5QXhpczogbnVsbCxcbiAgaW50ZXJ2YWw6IG51bGwsXG5cbiAgLy8gbW9kZVxuICBncHU6IGZhbHNlXG59O1xuXG5leHBvcnQgY29uc3QgRklMVEVSX0lEX0xFTkdUSCA9IDQ7XG5cbmV4cG9ydCBjb25zdCBMQVlFUl9GSUxURVJTID0gW0ZJTFRFUl9UWVBFUy5wb2x5Z29uXTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBmaWx0ZXIgd2l0aCBhIGRhdGFzZXQgaWQgYXMgZGF0YUlkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXREZWZhdWx0RmlsdGVyKGRhdGFJZDogc3RyaW5nIHwgbnVsbCB8IHN0cmluZ1tdKTogRmlsdGVyQmFzZTxMaW5lQ2hhcnQ+IHtcbiAgcmV0dXJuIHtcbiAgICAuLi5ERUZBVUxUX0ZJTFRFUl9TVFJVQ1RVUkUsXG4gICAgLy8gc3RvcmUgaXQgYXMgZGF0YUlkIGFuZCBpdCBjb3VsZCBiZSBvbmUgb3IgbWFueVxuICAgIGRhdGFJZDogdG9BcnJheShkYXRhSWQpLFxuICAgIGlkOiBnZW5lcmF0ZUhhc2hJZChGSUxURVJfSURfTEVOR1RIKVxuICB9O1xufVxuXG4vKipcbiAqIENoZWNrIGlmIGEgZmlsdGVyIGlzIHZhbGlkIGJhc2VkIG9uIHRoZSBnaXZlbiBkYXRhSWRcbiAqIEBwYXJhbSAgZmlsdGVyIHRvIHZhbGlkYXRlXG4gKiBAcGFyYW0gIGRhdGFzZXRJZCBpZCB0byB2YWxpZGF0ZSBmaWx0ZXIgYWdhaW5zdFxuICogQHJldHVybiB0cnVlIGlmIGEgZmlsdGVyIGlzIHZhbGlkLCBmYWxzZSBvdGhlcndpc2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNob3VsZEFwcGx5RmlsdGVyKGZpbHRlcjogRmlsdGVyLCBkYXRhc2V0SWQ6IHN0cmluZyk6IGJvb2xlYW4ge1xuICBjb25zdCBkYXRhSWRzID0gdG9BcnJheShmaWx0ZXIuZGF0YUlkKTtcbiAgcmV0dXJuIGRhdGFJZHMuaW5jbHVkZXMoZGF0YXNldElkKSAmJiBmaWx0ZXIudmFsdWUgIT09IG51bGw7XG59XG5cbmludGVyZmFjZSBLZXBsZXJUYWJsZU1vZGVsPEssIEw+IHtcbiAgaWQ6IHN0cmluZztcbiAgZ2V0Q29sdW1uRmllbGRJZHgoY29sdW1uTmFtZTogc3RyaW5nKTogbnVtYmVyO1xuICBmaWx0ZXJUYWJsZShmaWx0ZXJzOiBGaWx0ZXJbXSwgbGF5ZXJzOiBMW10sIG9wdD86IEZpbHRlckRhdGFzZXRPcHQpOiBLO1xuICBnZXRDb2x1bW5GaWx0ZXJQcm9wcyhjb2x1bW5OYW1lOiBzdHJpbmcpOiBGaWVsZFsnZmlsdGVyUHJvcHMnXSB8IG51bGwgfCB1bmRlZmluZWQ7XG4gIGRhdGFDb250YWluZXI6IERhdGFDb250YWluZXJJbnRlcmZhY2U7XG4gIGZpbHRlclRhYmxlQ1BVKGZpbHRlcnM6IEZpbHRlcltdLCBsYXllcnM6IExbXSk6IEs7XG59XG5cbi8qKlxuICogVmFsaWRhdGVzIGFuZCBtb2RpZmllcyBwb2x5Z29uIGZpbHRlciBzdHJ1Y3R1cmVcbiAqIEBwYXJhbSBkYXRhc2V0XG4gKiBAcGFyYW0gZmlsdGVyXG4gKiBAcGFyYW0gbGF5ZXJzXG4gKiBAcmV0dXJuIC0ge2ZpbHRlciwgZGF0YXNldH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlUG9seWdvbkZpbHRlcjxLIGV4dGVuZHMgS2VwbGVyVGFibGVNb2RlbDxLLCBMPiwgTCBleHRlbmRzIHtpZDogc3RyaW5nfT4oXG4gIGRhdGFzZXQ6IEssXG4gIGZpbHRlcjogUG9seWdvbkZpbHRlcixcbiAgbGF5ZXJzOiBMW11cbik6IHtmaWx0ZXI6IFBvbHlnb25GaWx0ZXIgfCBudWxsOyBkYXRhc2V0OiBLfSB7XG4gIGNvbnN0IGZhaWxlZCA9IHtkYXRhc2V0LCBmaWx0ZXI6IG51bGx9O1xuICBjb25zdCB7dmFsdWUsIGxheWVySWQsIHR5cGUsIGRhdGFJZH0gPSBmaWx0ZXI7XG5cbiAgaWYgKCFsYXllcklkIHx8ICFpc1ZhbGlkRmlsdGVyVmFsdWUodHlwZSwgdmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhaWxlZDtcbiAgfVxuXG4gIGNvbnN0IGlzVmFsaWREYXRhc2V0ID0gZGF0YUlkLmluY2x1ZGVzKGRhdGFzZXQuaWQpO1xuXG4gIGlmICghaXNWYWxpZERhdGFzZXQpIHtcbiAgICByZXR1cm4gZmFpbGVkO1xuICB9XG5cbiAgY29uc3QgbGF5ZXIgPSBsYXllcnMuZmluZChsID0+IGxheWVySWQuaW5jbHVkZXMobC5pZCkpO1xuXG4gIGlmICghbGF5ZXIpIHtcbiAgICByZXR1cm4gZmFpbGVkO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBmaWx0ZXI6IHtcbiAgICAgIC4uLmZpbHRlcixcbiAgICAgIGZyZWV6ZTogdHJ1ZSxcbiAgICAgIGZpZWxkSWR4OiBbXVxuICAgIH0sXG4gICAgZGF0YXNldFxuICB9O1xufVxuXG4vKipcbiAqIEN1c3RvbSBmaWx0ZXIgdmFsaWRhdG9yc1xuICovXG5jb25zdCBmaWx0ZXJWYWxpZGF0b3JzID0ge1xuICBbRklMVEVSX1RZUEVTLnBvbHlnb25dOiB2YWxpZGF0ZVBvbHlnb25GaWx0ZXJcbn07XG5cbi8qKlxuICogRGVmYXVsdCB2YWxpZGF0ZSBmaWx0ZXIgZnVuY3Rpb25cbiAqIEBwYXJhbSBkYXRhc2V0XG4gKiBAcGFyYW0gZmlsdGVyXG4gKiBAcmV0dXJuIC0ge2ZpbHRlciwgZGF0YXNldH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlRmlsdGVyPEsgZXh0ZW5kcyBLZXBsZXJUYWJsZU1vZGVsPEssIEw+LCBMPihcbiAgZGF0YXNldDogSyxcbiAgZmlsdGVyOiBQYXJzZWRGaWx0ZXJcbik6IHtmaWx0ZXI6IEZpbHRlciB8IG51bGw7IGRhdGFzZXQ6IEt9IHtcbiAgLy8gbWF0Y2ggZmlsdGVyLmRhdGFJZFxuICBjb25zdCBmYWlsZWQgPSB7ZGF0YXNldCwgZmlsdGVyOiBudWxsfTtcbiAgY29uc3QgZmlsdGVyRGF0YUlkID0gdG9BcnJheShmaWx0ZXIuZGF0YUlkKTtcblxuICBjb25zdCBmaWx0ZXJEYXRhc2V0SW5kZXggPSBmaWx0ZXJEYXRhSWQuaW5kZXhPZihkYXRhc2V0LmlkKTtcbiAgaWYgKGZpbHRlckRhdGFzZXRJbmRleCA8IDAgfHwgIXRvQXJyYXkoZmlsdGVyLm5hbWUpW2ZpbHRlckRhdGFzZXRJbmRleF0pIHtcbiAgICAvLyB0aGUgY3VycmVudCBmaWx0ZXIgaXMgbm90IG1hcHBlZCBhZ2FpbnN0IHRoZSBjdXJyZW50IGRhdGFzZXRcbiAgICByZXR1cm4gZmFpbGVkO1xuICB9XG5cbiAgY29uc3QgaW5pdGlhbGl6ZUZpbHRlcjogRmlsdGVyID0ge1xuICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAuLi5nZXREZWZhdWx0RmlsdGVyKGZpbHRlci5kYXRhSWQpLFxuICAgIC4uLmZpbHRlcixcbiAgICBkYXRhSWQ6IGZpbHRlckRhdGFJZCxcbiAgICBuYW1lOiB0b0FycmF5KGZpbHRlci5uYW1lKVxuICB9O1xuXG4gIGNvbnN0IGZpZWxkTmFtZSA9IGluaXRpYWxpemVGaWx0ZXIubmFtZVtmaWx0ZXJEYXRhc2V0SW5kZXhdO1xuICBjb25zdCB7ZmlsdGVyOiB1cGRhdGVkRmlsdGVyLCBkYXRhc2V0OiB1cGRhdGVkRGF0YXNldH0gPSBhcHBseUZpbHRlckZpZWxkTmFtZShcbiAgICBpbml0aWFsaXplRmlsdGVyLFxuICAgIGRhdGFzZXQsXG4gICAgZmllbGROYW1lLFxuICAgIGZpbHRlckRhdGFzZXRJbmRleCxcbiAgICB7bWVyZ2VEb21haW46IHRydWV9XG4gICk7XG5cbiAgaWYgKCF1cGRhdGVkRmlsdGVyKSB7XG4gICAgcmV0dXJuIGZhaWxlZDtcbiAgfVxuXG4gIHVwZGF0ZWRGaWx0ZXIudmFsdWUgPSBhZGp1c3RWYWx1ZVRvRmlsdGVyRG9tYWluKGZpbHRlci52YWx1ZSwgdXBkYXRlZEZpbHRlcik7XG4gIHVwZGF0ZWRGaWx0ZXIuZW5sYXJnZWQgPVxuICAgIHR5cGVvZiBmaWx0ZXIuZW5sYXJnZWQgPT09ICdib29sZWFuJyA/IGZpbHRlci5lbmxhcmdlZCA6IHVwZGF0ZWRGaWx0ZXIuZW5sYXJnZWQ7XG5cbiAgaWYgKHVwZGF0ZWRGaWx0ZXIudmFsdWUgPT09IG51bGwpIHtcbiAgICAvLyBjYW5ub3QgYWRqdXN0IHNhdmVkIHZhbHVlIHRvIGZpbHRlclxuICAgIHJldHVybiBmYWlsZWQ7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGZpbHRlcjogdmFsaWRhdGVGaWx0ZXJZQXhpcyh1cGRhdGVkRmlsdGVyLCB1cGRhdGVkRGF0YXNldCksXG4gICAgZGF0YXNldDogdXBkYXRlZERhdGFzZXRcbiAgfTtcbn1cblxuLyoqXG4gKiBWYWxpZGF0ZSBzYXZlZCBmaWx0ZXIgY29uZmlnIHdpdGggbmV3IGRhdGEsXG4gKiBjYWxjdWxhdGUgZG9tYWluIGFuZCBmaWVsZElkeCBiYXNlZCBuZXcgZmllbGRzIGFuZCBkYXRhXG4gKlxuICogQHBhcmFtIGRhdGFzZXRcbiAqIEBwYXJhbSBmaWx0ZXIgLSBmaWx0ZXIgdG8gYmUgdmFsaWRhdGVcbiAqIEBwYXJhbSBsYXllcnMgLSBsYXllcnNcbiAqIEByZXR1cm4gdmFsaWRhdGVkIGZpbHRlclxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVGaWx0ZXJXaXRoRGF0YTxLIGV4dGVuZHMgS2VwbGVyVGFibGVNb2RlbDxLLCBMPiwgTD4oXG4gIGRhdGFzZXQ6IEssXG4gIGZpbHRlcjogUGFyc2VkRmlsdGVyLFxuICBsYXllcnM6IExbXVxuKToge2ZpbHRlcjogRmlsdGVyOyBkYXRhc2V0OiBLfSB7XG4gIHJldHVybiBmaWx0ZXIudHlwZSAmJiBmaWx0ZXJWYWxpZGF0b3JzLmhhc093blByb3BlcnR5KGZpbHRlci50eXBlKVxuICAgID8gZmlsdGVyVmFsaWRhdG9yc1tmaWx0ZXIudHlwZV0oZGF0YXNldCwgZmlsdGVyLCBsYXllcnMpXG4gICAgOiB2YWxpZGF0ZUZpbHRlcihkYXRhc2V0LCBmaWx0ZXIpO1xufVxuXG4vKipcbiAqIFZhbGlkYXRlIFlBeGlzXG4gKiBAcGFyYW0gZmlsdGVyXG4gKiBAcGFyYW0gZGF0YXNldFxuICogQHJldHVybiB7Kn1cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVGaWx0ZXJZQXhpcyhmaWx0ZXIsIGRhdGFzZXQpIHtcbiAgLy8gVE9ETzogdmFsaWRhdGUgeUF4aXMgYWdhaW5zdCBvdGhlciBkYXRhc2V0c1xuXG4gIGNvbnN0IHtmaWVsZHN9ID0gZGF0YXNldDtcbiAgY29uc3Qge3lBeGlzfSA9IGZpbHRlcjtcbiAgLy8gVE9ETzogdmFsaWRhdGUgeUF4aXMgYWdhaW5zdCBvdGhlciBkYXRhc2V0c1xuICBpZiAoeUF4aXMpIHtcbiAgICBjb25zdCBtYXRjaGVkQXhpcyA9IGZpZWxkcy5maW5kKCh7bmFtZSwgdHlwZX0pID0+IG5hbWUgPT09IHlBeGlzLm5hbWUgJiYgdHlwZSA9PT0geUF4aXMudHlwZSk7XG5cbiAgICBmaWx0ZXIgPSBtYXRjaGVkQXhpc1xuICAgICAgPyB7XG4gICAgICAgICAgLi4uZmlsdGVyLFxuICAgICAgICAgIHlBeGlzOiBtYXRjaGVkQXhpcyxcbiAgICAgICAgICAuLi5nZXRGaWx0ZXJQbG90KHsuLi5maWx0ZXIsIHlBeGlzOiBtYXRjaGVkQXhpc30sIGRhdGFzZXQpXG4gICAgICAgIH1cbiAgICAgIDogZmlsdGVyO1xuICB9XG5cbiAgcmV0dXJuIGZpbHRlcjtcbn1cblxuLyoqXG4gKiBHZXQgZGVmYXVsdCBmaWx0ZXIgcHJvcCBiYXNlZCBvbiBmaWVsZCB0eXBlXG4gKlxuICogQHBhcmFtIGZpZWxkXG4gKiBAcGFyYW0gZmllbGREb21haW5cbiAqIEByZXR1cm5zIGRlZmF1bHQgZmlsdGVyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRGaWx0ZXJQcm9wcyhcbiAgZmllbGQ6IEZpZWxkLFxuICBmaWVsZERvbWFpbjogRmllbGREb21haW5cbik6IFBhcnRpYWw8RmlsdGVyPiAmIHtmaWVsZFR5cGU6IHN0cmluZ30ge1xuICBjb25zdCBmaWx0ZXJQcm9wcyA9IHtcbiAgICAuLi5maWVsZERvbWFpbixcbiAgICBmaWVsZFR5cGU6IGZpZWxkLnR5cGVcbiAgfTtcblxuICBzd2l0Y2ggKGZpZWxkLnR5cGUpIHtcbiAgICBjYXNlIEFMTF9GSUVMRF9UWVBFUy5yZWFsOlxuICAgIGNhc2UgQUxMX0ZJRUxEX1RZUEVTLmludGVnZXI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5maWx0ZXJQcm9wcyxcbiAgICAgICAgdmFsdWU6IGZpZWxkRG9tYWluLmRvbWFpbixcbiAgICAgICAgdHlwZTogRklMVEVSX1RZUEVTLnJhbmdlLFxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIHR5cGVPcHRpb25zOiBbRklMVEVSX1RZUEVTLnJhbmdlXSxcbiAgICAgICAgZ3B1OiB0cnVlXG4gICAgICB9O1xuXG4gICAgY2FzZSBBTExfRklFTERfVFlQRVMuYm9vbGVhbjpcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLmZpbHRlclByb3BzLFxuICAgICAgICB0eXBlOiBGSUxURVJfVFlQRVMuc2VsZWN0LFxuICAgICAgICB2YWx1ZTogdHJ1ZSxcbiAgICAgICAgZ3B1OiBmYWxzZVxuICAgICAgfTtcblxuICAgIGNhc2UgQUxMX0ZJRUxEX1RZUEVTLnN0cmluZzpcbiAgICBjYXNlIEFMTF9GSUVMRF9UWVBFUy5kYXRlOlxuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uZmlsdGVyUHJvcHMsXG4gICAgICAgIHR5cGU6IEZJTFRFUl9UWVBFUy5tdWx0aVNlbGVjdCxcbiAgICAgICAgdmFsdWU6IFtdLFxuICAgICAgICBncHU6IGZhbHNlXG4gICAgICB9O1xuXG4gICAgY2FzZSBBTExfRklFTERfVFlQRVMudGltZXN0YW1wOlxuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uZmlsdGVyUHJvcHMsXG4gICAgICAgIHR5cGU6IEZJTFRFUl9UWVBFUy50aW1lUmFuZ2UsXG4gICAgICAgIGVubGFyZ2VkOiB0cnVlLFxuICAgICAgICBmaXhlZERvbWFpbjogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGZpbHRlclByb3BzLmRvbWFpbixcbiAgICAgICAgZ3B1OiB0cnVlXG4gICAgICB9O1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgIHJldHVybiB7fTtcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgZ2V0UG9seWdvbkZpbHRlckZ1bmN0b3IgPSAobGF5ZXIsIGZpbHRlciwgZGF0YUNvbnRhaW5lcikgPT4ge1xuICBjb25zdCBnZXRQb3NpdGlvbiA9IGxheWVyLmdldFBvc2l0aW9uQWNjZXNzb3IoZGF0YUNvbnRhaW5lcik7XG5cbiAgc3dpdGNoIChsYXllci50eXBlKSB7XG4gICAgY2FzZSBMQVlFUl9UWVBFUy5wb2ludDpcbiAgICBjYXNlIExBWUVSX1RZUEVTLmljb246XG4gICAgICByZXR1cm4gZGF0YSA9PiB7XG4gICAgICAgIGNvbnN0IHBvcyA9IGdldFBvc2l0aW9uKGRhdGEpO1xuICAgICAgICByZXR1cm4gcG9zLmV2ZXJ5KE51bWJlci5pc0Zpbml0ZSkgJiYgaXNJblBvbHlnb24ocG9zLCBmaWx0ZXIudmFsdWUpO1xuICAgICAgfTtcbiAgICBjYXNlIExBWUVSX1RZUEVTLmFyYzpcbiAgICBjYXNlIExBWUVSX1RZUEVTLmxpbmU6XG4gICAgICByZXR1cm4gZGF0YSA9PiB7XG4gICAgICAgIGNvbnN0IHBvcyA9IGdldFBvc2l0aW9uKGRhdGEpO1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIHBvcy5ldmVyeShOdW1iZXIuaXNGaW5pdGUpICYmXG4gICAgICAgICAgW1xuICAgICAgICAgICAgW3Bvc1swXSwgcG9zWzFdXSxcbiAgICAgICAgICAgIFtwb3NbM10sIHBvc1s0XV1cbiAgICAgICAgICBdLmV2ZXJ5KHBvaW50ID0+IGlzSW5Qb2x5Z29uKHBvaW50LCBmaWx0ZXIudmFsdWUpKVxuICAgICAgICApO1xuICAgICAgfTtcbiAgICBjYXNlIExBWUVSX1RZUEVTLmhleGFnb25JZDpcbiAgICAgIGlmIChsYXllci5kYXRhVG9GZWF0dXJlICYmIGxheWVyLmRhdGFUb0ZlYXR1cmUuY2VudHJvaWRzKSB7XG4gICAgICAgIHJldHVybiBkYXRhID0+IHtcbiAgICAgICAgICAvLyBudWxsIG9yIGdldENlbnRyb2lkKHtpZH0pXG4gICAgICAgICAgY29uc3QgY2VudHJvaWQgPSBsYXllci5kYXRhVG9GZWF0dXJlLmNlbnRyb2lkc1tkYXRhLmluZGV4XTtcbiAgICAgICAgICByZXR1cm4gY2VudHJvaWQgJiYgaXNJblBvbHlnb24oY2VudHJvaWQsIGZpbHRlci52YWx1ZSk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YSA9PiB7XG4gICAgICAgIGNvbnN0IGlkID0gZ2V0UG9zaXRpb24oZGF0YSk7XG4gICAgICAgIGlmICghaDNJc1ZhbGlkKGlkKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwb3MgPSBnZXRDZW50cm9pZCh7aWR9KTtcbiAgICAgICAgcmV0dXJuIHBvcy5ldmVyeShOdW1iZXIuaXNGaW5pdGUpICYmIGlzSW5Qb2x5Z29uKHBvcywgZmlsdGVyLnZhbHVlKTtcbiAgICAgIH07XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAoKSA9PiB0cnVlO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSBwYXJhbSBBbiBvYmplY3QgdGhhdCByZXByZXNlbnRzIGEgcm93IHJlY29yZC5cbiAqIEBwYXJhbSBwYXJhbS5pbmRleCBJbmRleCBvZiB0aGUgcm93IGluIGRhdGEgY29udGFpbmVyLlxuICogQHJldHVybnMgUmV0dXJucyB0cnVlIHRvIGtlZXAgdGhlIGVsZW1lbnQsIG9yIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xudHlwZSBmaWx0ZXJGdW5jdGlvbiA9IChkYXRhOiB7aW5kZXg6IG51bWJlcn0pID0+IGJvb2xlYW47XG4vKipcbiAqIEBwYXJhbSBmaWVsZCBkYXRhc2V0IEZpZWxkXG4gKiBAcGFyYW0gZGF0YUlkIERhdGFzZXQgaWRcbiAqIEBwYXJhbSBmaWx0ZXIgRmlsdGVyIG9iamVjdFxuICogQHBhcmFtIGxheWVycyBsaXN0IG9mIGxheWVycyB0byBmaWx0ZXIgdXBvblxuICogQHBhcmFtIGRhdGFDb250YWluZXIgRGF0YSBjb250YWluZXJcbiAqIEByZXR1cm4gZmlsdGVyRnVuY3Rpb25cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgY29tcGxleGl0eSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEZpbHRlckZ1bmN0aW9uPEwgZXh0ZW5kcyB7Y29uZmlnOiB7ZGF0YUlkOiBzdHJpbmcgfCBudWxsfTsgaWQ6IHN0cmluZ30+KFxuICBmaWVsZDogRmllbGQgfCBudWxsLFxuICBkYXRhSWQ6IHN0cmluZyxcbiAgZmlsdGVyOiBGaWx0ZXIsXG4gIGxheWVyczogTFtdLFxuICBkYXRhQ29udGFpbmVyOiBEYXRhQ29udGFpbmVySW50ZXJmYWNlXG4pOiBmaWx0ZXJGdW5jdGlvbiB7XG4gIC8vIGZpZWxkIGNvdWxkIGJlIG51bGwgaW4gcG9seWdvbiBmaWx0ZXJcbiAgY29uc3QgdmFsdWVBY2Nlc3NvciA9IGZpZWxkID8gZmllbGQudmFsdWVBY2Nlc3NvciA6IGRhdGEgPT4gbnVsbDtcbiAgY29uc3QgZGVmYXVsdEZ1bmMgPSBkID0+IHRydWU7XG5cbiAgc3dpdGNoIChmaWx0ZXIudHlwZSkge1xuICAgIGNhc2UgRklMVEVSX1RZUEVTLnJhbmdlOlxuICAgICAgcmV0dXJuIGRhdGEgPT4gaXNJblJhbmdlKHZhbHVlQWNjZXNzb3IoZGF0YSksIGZpbHRlci52YWx1ZSk7XG4gICAgY2FzZSBGSUxURVJfVFlQRVMubXVsdGlTZWxlY3Q6XG4gICAgICByZXR1cm4gZGF0YSA9PiBmaWx0ZXIudmFsdWUuaW5jbHVkZXModmFsdWVBY2Nlc3NvcihkYXRhKSk7XG4gICAgY2FzZSBGSUxURVJfVFlQRVMuc2VsZWN0OlxuICAgICAgcmV0dXJuIGRhdGEgPT4gdmFsdWVBY2Nlc3NvcihkYXRhKSA9PT0gZmlsdGVyLnZhbHVlO1xuICAgIGNhc2UgRklMVEVSX1RZUEVTLnRpbWVSYW5nZTpcbiAgICAgIGlmICghZmllbGQpIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRGdW5jO1xuICAgICAgfVxuICAgICAgY29uc3QgbWFwcGVkVmFsdWUgPSBnZXQoZmllbGQsIFsnZmlsdGVyUHJvcHMnLCAnbWFwcGVkVmFsdWUnXSk7XG4gICAgICBjb25zdCBhY2Nlc3NvciA9IEFycmF5LmlzQXJyYXkobWFwcGVkVmFsdWUpXG4gICAgICAgID8gZGF0YSA9PiBtYXBwZWRWYWx1ZVtkYXRhLmluZGV4XVxuICAgICAgICA6IGRhdGEgPT4gdGltZVRvVW5peE1pbGxpKHZhbHVlQWNjZXNzb3IoZGF0YSksIGZpZWxkLmZvcm1hdCk7XG4gICAgICByZXR1cm4gZGF0YSA9PiBpc0luUmFuZ2UoYWNjZXNzb3IoZGF0YSksIGZpbHRlci52YWx1ZSk7XG4gICAgY2FzZSBGSUxURVJfVFlQRVMucG9seWdvbjpcbiAgICAgIGlmICghbGF5ZXJzIHx8ICFsYXllcnMubGVuZ3RoIHx8ICFmaWx0ZXIubGF5ZXJJZCkge1xuICAgICAgICByZXR1cm4gZGVmYXVsdEZ1bmM7XG4gICAgICB9XG4gICAgICBjb25zdCBsYXllckZpbHRlckZ1bmN0aW9ucyA9IGZpbHRlci5sYXllcklkXG4gICAgICAgIC5tYXAoaWQgPT4gbGF5ZXJzLmZpbmQobCA9PiBsLmlkID09PSBpZCkpXG4gICAgICAgIC5maWx0ZXIobCA9PiBsICYmIGwuY29uZmlnLmRhdGFJZCA9PT0gZGF0YUlkKVxuICAgICAgICAubWFwKGxheWVyID0+IGdldFBvbHlnb25GaWx0ZXJGdW5jdG9yKGxheWVyLCBmaWx0ZXIsIGRhdGFDb250YWluZXIpKTtcblxuICAgICAgcmV0dXJuIGRhdGEgPT4gbGF5ZXJGaWx0ZXJGdW5jdGlvbnMuZXZlcnkoZmlsdGVyRnVuYyA9PiBmaWx0ZXJGdW5jKGRhdGEpKTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGRlZmF1bHRGdW5jO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVGaWx0ZXJEYXRhSWQoZGF0YUlkOiBzdHJpbmcpOiBGaWx0ZXJCYXNlPExpbmVDaGFydD4ge1xuICByZXR1cm4gZ2V0RGVmYXVsdEZpbHRlcihkYXRhSWQpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZmlsdGVyRGF0YUJ5RmlsdGVyVHlwZXMoXG4gIHtcbiAgICBkeW5hbWljRG9tYWluRmlsdGVycyxcbiAgICBjcHVGaWx0ZXJzLFxuICAgIGZpbHRlckZ1bmNzXG4gIH06IHtcbiAgICBkeW5hbWljRG9tYWluRmlsdGVyczogRmlsdGVyW10gfCBudWxsO1xuICAgIGNwdUZpbHRlcnM6IEZpbHRlcltdIHwgbnVsbDtcbiAgICBmaWx0ZXJGdW5jczoge1xuICAgICAgW2tleTogc3RyaW5nXTogZmlsdGVyRnVuY3Rpb247XG4gICAgfTtcbiAgfSxcbiAgZGF0YUNvbnRhaW5lcjogRGF0YUNvbnRhaW5lckludGVyZmFjZVxuKTogRmlsdGVyUmVzdWx0IHtcbiAgY29uc3QgZmlsdGVyZWRJbmRleEZvckRvbWFpbjogbnVtYmVyW10gPSBbXTtcbiAgY29uc3QgZmlsdGVyZWRJbmRleDogbnVtYmVyW10gPSBbXTtcblxuICBjb25zdCBmaWx0ZXJDb250ZXh0ID0ge2luZGV4OiAtMSwgZGF0YUNvbnRhaW5lcn07XG4gIGNvbnN0IGZpbHRlckZ1bmNDYWxsZXIgPSAoZmlsdGVyOiBGaWx0ZXIpID0+IGZpbHRlckZ1bmNzW2ZpbHRlci5pZF0oZmlsdGVyQ29udGV4dCk7XG5cbiAgY29uc3QgbnVtUm93cyA9IGRhdGFDb250YWluZXIubnVtUm93cygpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVJvd3M7ICsraSkge1xuICAgIGZpbHRlckNvbnRleHQuaW5kZXggPSBpO1xuXG4gICAgY29uc3QgbWF0Y2hGb3JEb21haW4gPSBkeW5hbWljRG9tYWluRmlsdGVycyAmJiBkeW5hbWljRG9tYWluRmlsdGVycy5ldmVyeShmaWx0ZXJGdW5jQ2FsbGVyKTtcbiAgICBpZiAobWF0Y2hGb3JEb21haW4pIHtcbiAgICAgIGZpbHRlcmVkSW5kZXhGb3JEb21haW4ucHVzaChmaWx0ZXJDb250ZXh0LmluZGV4KTtcbiAgICB9XG5cbiAgICBjb25zdCBtYXRjaEZvclJlbmRlciA9IGNwdUZpbHRlcnMgJiYgY3B1RmlsdGVycy5ldmVyeShmaWx0ZXJGdW5jQ2FsbGVyKTtcbiAgICBpZiAobWF0Y2hGb3JSZW5kZXIpIHtcbiAgICAgIGZpbHRlcmVkSW5kZXgucHVzaChmaWx0ZXJDb250ZXh0LmluZGV4KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIC4uLihkeW5hbWljRG9tYWluRmlsdGVycyA/IHtmaWx0ZXJlZEluZGV4Rm9yRG9tYWlufSA6IHt9KSxcbiAgICAuLi4oY3B1RmlsdGVycyA/IHtmaWx0ZXJlZEluZGV4fSA6IHt9KVxuICB9O1xufVxuXG4vKipcbiAqIEdldCBhIHJlY29yZCBvZiBmaWx0ZXJzIGJhc2VkIG9uIGRvbWFpbiB0eXBlIGFuZCBncHUgLyBjcHVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEZpbHRlclJlY29yZChcbiAgZGF0YUlkOiBzdHJpbmcsXG4gIGZpbHRlcnM6IEZpbHRlcltdLFxuICBvcHQ6IEZpbHRlckRhdGFzZXRPcHQgPSB7fVxuKTogRmlsdGVyUmVjb3JkIHtcbiAgY29uc3QgZmlsdGVyUmVjb3JkOiBGaWx0ZXJSZWNvcmQgPSB7XG4gICAgZHluYW1pY0RvbWFpbjogW10sXG4gICAgZml4ZWREb21haW46IFtdLFxuICAgIGNwdTogW10sXG4gICAgZ3B1OiBbXVxuICB9O1xuXG4gIGZpbHRlcnMuZm9yRWFjaChmID0+IHtcbiAgICBpZiAoaXNWYWxpZEZpbHRlclZhbHVlKGYudHlwZSwgZi52YWx1ZSkgJiYgdG9BcnJheShmLmRhdGFJZCkuaW5jbHVkZXMoZGF0YUlkKSkge1xuICAgICAgKGYuZml4ZWREb21haW4gfHwgb3B0Lmlnbm9yZURvbWFpblxuICAgICAgICA/IGZpbHRlclJlY29yZC5maXhlZERvbWFpblxuICAgICAgICA6IGZpbHRlclJlY29yZC5keW5hbWljRG9tYWluXG4gICAgICApLnB1c2goZik7XG5cbiAgICAgIChmLmdwdSAmJiAhb3B0LmNwdU9ubHkgPyBmaWx0ZXJSZWNvcmQuZ3B1IDogZmlsdGVyUmVjb3JkLmNwdSkucHVzaChmKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBmaWx0ZXJSZWNvcmQ7XG59XG5cbi8qKlxuICogQ29tcGFyZSBmaWx0ZXIgcmVjb3JkcyB0byBnZXQgd2hhdCBoYXMgY2hhbmdlZFxuICovXG5leHBvcnQgZnVuY3Rpb24gZGlmZkZpbHRlcnMoXG4gIGZpbHRlclJlY29yZDogRmlsdGVyUmVjb3JkLFxuICBvbGRGaWx0ZXJSZWNvcmQ6IEZpbHRlclJlY29yZCB8IHt9ID0ge31cbik6IEZpbHRlckNoYW5nZWQge1xuICBsZXQgZmlsdGVyQ2hhbmdlZDogUGFydGlhbDxGaWx0ZXJDaGFuZ2VkPiA9IHt9O1xuXG4gIChPYmplY3QuZW50cmllcyhmaWx0ZXJSZWNvcmQpIGFzIEVudHJpZXM8RmlsdGVyUmVjb3JkPikuZm9yRWFjaCgoW3JlY29yZCwgaXRlbXNdKSA9PiB7XG4gICAgaXRlbXMuZm9yRWFjaChmaWx0ZXIgPT4ge1xuICAgICAgY29uc3Qgb2xkRmlsdGVyOiBGaWx0ZXIgPSAob2xkRmlsdGVyUmVjb3JkW3JlY29yZF0gfHwgW10pLmZpbmQoXG4gICAgICAgIChmOiBGaWx0ZXIpID0+IGYuaWQgPT09IGZpbHRlci5pZFxuICAgICAgKTtcblxuICAgICAgaWYgKCFvbGRGaWx0ZXIpIHtcbiAgICAgICAgLy8gYWRkZWRcbiAgICAgICAgZmlsdGVyQ2hhbmdlZCA9IHNldChbcmVjb3JkLCBmaWx0ZXIuaWRdLCAnYWRkZWQnLCBmaWx0ZXJDaGFuZ2VkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGNoZWNrICB3aGF0IGhhcyBjaGFuZ2VkXG4gICAgICAgIFsnbmFtZScsICd2YWx1ZScsICdkYXRhSWQnXS5mb3JFYWNoKHByb3AgPT4ge1xuICAgICAgICAgIGlmIChmaWx0ZXJbcHJvcF0gIT09IG9sZEZpbHRlcltwcm9wXSkge1xuICAgICAgICAgICAgZmlsdGVyQ2hhbmdlZCA9IHNldChbcmVjb3JkLCBmaWx0ZXIuaWRdLCBgJHtwcm9wfV9jaGFuZ2VkYCwgZmlsdGVyQ2hhbmdlZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIChvbGRGaWx0ZXJSZWNvcmRbcmVjb3JkXSB8fCBbXSkuZm9yRWFjaCgob2xkRmlsdGVyOiBGaWx0ZXIpID0+IHtcbiAgICAgIC8vIGRlbGV0ZWRcbiAgICAgIGlmICghaXRlbXMuZmluZChmID0+IGYuaWQgPT09IG9sZEZpbHRlci5pZCkpIHtcbiAgICAgICAgZmlsdGVyQ2hhbmdlZCA9IHNldChbcmVjb3JkLCBvbGRGaWx0ZXIuaWRdLCAnZGVsZXRlZCcsIGZpbHRlckNoYW5nZWQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcblxuICByZXR1cm4gey4uLntkeW5hbWljRG9tYWluOiBudWxsLCBmaXhlZERvbWFpbjogbnVsbCwgY3B1OiBudWxsLCBncHU6IG51bGx9LCAuLi5maWx0ZXJDaGFuZ2VkfTtcbn1cbi8qKlxuICogQ2FsbCBieSBwYXJzaW5nIGZpbHRlcnMgZnJvbSBVUkxcbiAqIENoZWNrIGlmIHZhbHVlIG9mIGZpbHRlciB3aXRoaW4gZmlsdGVyIGRvbWFpbiwgaWYgbm90IGFkanVzdCBpdCB0byBtYXRjaFxuICogZmlsdGVyIGRvbWFpblxuICpcbiAqIEByZXR1cm5zIHZhbHVlIC0gYWRqdXN0ZWQgdmFsdWUgdG8gbWF0Y2ggZmlsdGVyIG9yIG51bGwgdG8gcmVtb3ZlIGZpbHRlclxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuZXhwb3J0IGZ1bmN0aW9uIGFkanVzdFZhbHVlVG9GaWx0ZXJEb21haW4odmFsdWU6IEZpbHRlclsndmFsdWUnXSwge2RvbWFpbiwgdHlwZX0pIHtcbiAgaWYgKCF0eXBlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIGlmIHRoZSBjdXJyZW50IGZpbHRlciBpcyBhIHBvbHlnb24gaXQgd2lsbCBub3QgaGF2ZSBhbnkgZG9tYWluXG4gIC8vIGFsbCBvdGhlciBmaWx0ZXIgdHlwZXMgcmVxdWlyZSBkb21haW5cbiAgaWYgKHR5cGUgIT09IEZJTFRFUl9UWVBFUy5wb2x5Z29uICYmICFkb21haW4pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIEZJTFRFUl9UWVBFUy5yYW5nZTpcbiAgICBjYXNlIEZJTFRFUl9UWVBFUy50aW1lUmFuZ2U6XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpIHx8IHZhbHVlLmxlbmd0aCAhPT0gMikge1xuICAgICAgICByZXR1cm4gZG9tYWluLm1hcChkID0+IGQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdmFsdWUubWFwKChkLCBpKSA9PiAobm90TnVsbG9yVW5kZWZpbmVkKGQpICYmIGlzSW5SYW5nZShkLCBkb21haW4pID8gZCA6IGRvbWFpbltpXSkpO1xuXG4gICAgY2FzZSBGSUxURVJfVFlQRVMubXVsdGlTZWxlY3Q6XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGZpbHRlcmVkVmFsdWUgPSB2YWx1ZS5maWx0ZXIoZCA9PiBkb21haW4uaW5jbHVkZXMoZCkpO1xuICAgICAgcmV0dXJuIGZpbHRlcmVkVmFsdWUubGVuZ3RoID8gZmlsdGVyZWRWYWx1ZSA6IFtdO1xuXG4gICAgY2FzZSBGSUxURVJfVFlQRVMuc2VsZWN0OlxuICAgICAgcmV0dXJuIGRvbWFpbi5pbmNsdWRlcyh2YWx1ZSkgPyB2YWx1ZSA6IHRydWU7XG4gICAgY2FzZSBGSUxURVJfVFlQRVMucG9seWdvbjpcbiAgICAgIHJldHVybiB2YWx1ZTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuLyogZXNsaW50LWVuYWJsZSBjb21wbGV4aXR5ICovXG5cbi8qKlxuICogQ2FsY3VsYXRlIG51bWVyaWMgZG9tYWluIGFuZCBzdWl0YWJsZSBzdGVwXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXROdW1lcmljRmllbGREb21haW4oXG4gIGRhdGFDb250YWluZXI6IERhdGFDb250YWluZXJJbnRlcmZhY2UsXG4gIHZhbHVlQWNjZXNzb3I6IGRhdGFWYWx1ZUFjY2Vzc29yXG4pOiBSYW5nZUZpZWxkRG9tYWluIHtcbiAgbGV0IGRvbWFpbjogW251bWJlciwgbnVtYmVyXSA9IFswLCAxXTtcbiAgbGV0IHN0ZXAgPSAwLjE7XG5cbiAgY29uc3QgbWFwcGVkVmFsdWUgPSBkYXRhQ29udGFpbmVyLm1hcEluZGV4KHZhbHVlQWNjZXNzb3IpO1xuXG4gIGlmIChkYXRhQ29udGFpbmVyLm51bVJvd3MoKSA+IDEpIHtcbiAgICBkb21haW4gPSBTY2FsZVV0aWxzLmdldExpbmVhckRvbWFpbihtYXBwZWRWYWx1ZSk7XG4gICAgY29uc3QgZGlmZiA9IGRvbWFpblsxXSAtIGRvbWFpblswXTtcblxuICAgIC8vIGluIGNhc2UgZXF1YWwgZG9tYWluLCBbOTYsIDk2XSwgd2hpY2ggd2lsbCBicmVhayBxdWFudGl6ZSBzY2FsZVxuICAgIGlmICghZGlmZikge1xuICAgICAgZG9tYWluWzFdID0gZG9tYWluWzBdICsgMTtcbiAgICB9XG5cbiAgICBzdGVwID0gZ2V0TnVtZXJpY1N0ZXBTaXplKGRpZmYpIHx8IHN0ZXA7XG4gICAgZG9tYWluWzBdID0gZm9ybWF0TnVtYmVyQnlTdGVwKGRvbWFpblswXSwgc3RlcCwgJ2Zsb29yJyk7XG4gICAgZG9tYWluWzFdID0gZm9ybWF0TnVtYmVyQnlTdGVwKGRvbWFpblsxXSwgc3RlcCwgJ2NlaWwnKTtcbiAgfVxuXG4gIGNvbnN0IHtoaXN0b2dyYW0sIGVubGFyZ2VkSGlzdG9ncmFtfSA9IGdldEhpc3RvZ3JhbShkb21haW4sIG1hcHBlZFZhbHVlKTtcblxuICByZXR1cm4ge2RvbWFpbiwgc3RlcCwgaGlzdG9ncmFtLCBlbmxhcmdlZEhpc3RvZ3JhbX07XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlIHN0ZXAgc2l6ZSBmb3IgcmFuZ2UgYW5kIHRpbWVyYW5nZSBmaWx0ZXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldE51bWVyaWNTdGVwU2l6ZShkaWZmOiBudW1iZXIpOiBudW1iZXIge1xuICBkaWZmID0gTWF0aC5hYnMoZGlmZik7XG5cbiAgaWYgKGRpZmYgPiAxMDApIHtcbiAgICByZXR1cm4gMTtcbiAgfSBlbHNlIGlmIChkaWZmID4gMykge1xuICAgIHJldHVybiAwLjAxO1xuICB9IGVsc2UgaWYgKGRpZmYgPiAxKSB7XG4gICAgcmV0dXJuIDAuMDAxO1xuICB9XG4gIC8vIFRyeSB0byBnZXQgYXQgbGVhc3QgMTAwMCBzdGVwcyAtIGFuZCBrZWVwIHRoZSBzdGVwIHNpemUgYmVsb3cgdGhhdCBvZlxuICAvLyB0aGUgKGRpZmYgPiAxKSBjYXNlLlxuICBjb25zdCB4ID0gZGlmZiAvIDEwMDA7XG4gIC8vIEZpbmQgdGhlIGV4cG9uZW50IGFuZCB0cnVuY2F0ZSB0byAxMCB0byB0aGUgcG93ZXIgb2YgdGhhdCBleHBvbmVudFxuXG4gIGNvbnN0IGV4cG9uZW50aWFsRm9ybSA9IHgudG9FeHBvbmVudGlhbCgpO1xuICBjb25zdCBleHBvbmVudCA9IHBhcnNlRmxvYXQoZXhwb25lbnRpYWxGb3JtLnNwbGl0KCdlJylbMV0pO1xuXG4gIC8vIEdldHRpbmcgcmVhZHkgZm9yIG5vZGUgMTJcbiAgLy8gdGhpcyBpcyB3aHkgd2UgbmVlZCBkZWNpbWFsLmpzXG4gIC8vIE1hdGgucG93KDEwLCAtNSkgPSAwLjAwMDAwOTk5OTk5OTk5OTk5OTk5OVxuICAvLyB0aGUgYWJvdmUgcmVzdWx0IHNob3dzIGluIGJyb3dzZXIgYW5kIG5vZGUgMTBcbiAgLy8gbm9kZSAxMiBiZWhhdmVzIGNvcnJlY3RseVxuICByZXR1cm4gbmV3IERlY2ltYWwoMTApLnBvdyhleHBvbmVudCkudG9OdW1iZXIoKTtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGUgdGltZXN0YW1wIGRvbWFpbiBhbmQgc3VpdGFibGUgc3RlcFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VGltZXN0YW1wRmllbGREb21haW4oXG4gIGRhdGFDb250YWluZXI6IERhdGFDb250YWluZXJJbnRlcmZhY2UsXG4gIHZhbHVlQWNjZXNzb3I6IGRhdGFWYWx1ZUFjY2Vzc29yXG4pOiBUaW1lUmFuZ2VGaWVsZERvbWFpbiB7XG4gIC8vIHRvIGF2b2lkIGNvbnZlcnRpbmcgc3RyaW5nIGZvcm1hdCB0aW1lIHRvIGVwb2NoXG4gIC8vIGV2ZXJ5IHRpbWUgd2UgY29tcGFyZSB3ZSBzdG9yZSBhIHZhbHVlIG1hcHBlZCB0byBpbnQgaW4gZmlsdGVyIGRvbWFpblxuXG4gIGNvbnN0IG1hcHBlZFZhbHVlID0gZGF0YUNvbnRhaW5lci5tYXBJbmRleCh2YWx1ZUFjY2Vzc29yKTtcbiAgY29uc3QgZG9tYWluID0gU2NhbGVVdGlscy5nZXRMaW5lYXJEb21haW4obWFwcGVkVmFsdWUpO1xuICBjb25zdCBkZWZhdWx0VGltZUZvcm1hdCA9IGdldFRpbWVXaWRnZXRUaXRsZUZvcm1hdHRlcihkb21haW4pO1xuXG4gIGxldCBzdGVwID0gMC4wMTtcblxuICBjb25zdCBkaWZmID0gZG9tYWluWzFdIC0gZG9tYWluWzBdO1xuICBjb25zdCBlbnRyeSA9IFRpbWVzdGFtcFN0ZXBNYXAuZmluZChmID0+IGYubWF4ID49IGRpZmYpO1xuICBpZiAoZW50cnkpIHtcbiAgICBzdGVwID0gZW50cnkuc3RlcDtcbiAgfVxuXG4gIGNvbnN0IHtoaXN0b2dyYW0sIGVubGFyZ2VkSGlzdG9ncmFtfSA9IGdldEhpc3RvZ3JhbShkb21haW4sIG1hcHBlZFZhbHVlKTtcblxuICByZXR1cm4ge1xuICAgIGRvbWFpbixcbiAgICBzdGVwLFxuICAgIG1hcHBlZFZhbHVlLFxuICAgIGhpc3RvZ3JhbSxcbiAgICBlbmxhcmdlZEhpc3RvZ3JhbSxcbiAgICBkZWZhdWx0VGltZUZvcm1hdFxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaGlzdG9ncmFtQ29uc3RydWN0KFxuICBkb21haW46IFtudW1iZXIsIG51bWJlcl0sXG4gIG1hcHBlZFZhbHVlOiAoTWlsbGlzZWNvbmQgfCBudW1iZXIpW10sXG4gIGJpbnM6IG51bWJlclxuKTogSGlzdG9ncmFtQmluW10ge1xuICByZXR1cm4gZDNIaXN0b2dyYW0oKVxuICAgIC50aHJlc2hvbGRzKHRpY2tzKGRvbWFpblswXSwgZG9tYWluWzFdLCBiaW5zKSlcbiAgICAuZG9tYWluKGRvbWFpbikobWFwcGVkVmFsdWUpXG4gICAgLm1hcChiaW4gPT4gKHtcbiAgICAgIGNvdW50OiBiaW4ubGVuZ3RoLFxuICAgICAgYmluLFxuICAgICAgeDA6IGJpbi54MCxcbiAgICAgIHgxOiBiaW4ueDFcbiAgICB9KSk7XG59XG4vKipcbiAqIENhbGN1bGF0ZSBoaXN0b2dyYW0gZnJvbSBkb21haW4gYW5kIGFycmF5IG9mIHZhbHVlc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0SGlzdG9ncmFtKFxuICBkb21haW46IFtudW1iZXIsIG51bWJlcl0sXG4gIG1hcHBlZFZhbHVlOiAoTWlsbGlzZWNvbmQgfCBudW1iZXIpW11cbik6IHtoaXN0b2dyYW06IEhpc3RvZ3JhbUJpbltdOyBlbmxhcmdlZEhpc3RvZ3JhbTogSGlzdG9ncmFtQmluW119IHtcbiAgY29uc3QgaGlzdG9ncmFtID0gaGlzdG9ncmFtQ29uc3RydWN0KGRvbWFpbiwgbWFwcGVkVmFsdWUsIGhpc3RvZ3JhbUJpbnMpO1xuICBjb25zdCBlbmxhcmdlZEhpc3RvZ3JhbSA9IGhpc3RvZ3JhbUNvbnN0cnVjdChkb21haW4sIG1hcHBlZFZhbHVlLCBlbmxhcmdlZEhpc3RvZ3JhbUJpbnMpO1xuXG4gIHJldHVybiB7aGlzdG9ncmFtLCBlbmxhcmdlZEhpc3RvZ3JhbX07XG59XG5cbi8qKlxuICogcm91bmQgbnVtYmVyIGJhc2VkIG9uIHN0ZXBcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gdmFsXG4gKiBAcGFyYW0ge051bWJlcn0gc3RlcFxuICogQHBhcmFtIHtzdHJpbmd9IGJvdW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSByb3VuZGVkIG51bWJlclxuICovXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0TnVtYmVyQnlTdGVwKHZhbDogbnVtYmVyLCBzdGVwOiBudW1iZXIsIGJvdW5kOiAnZmxvb3InIHwgJ2NlaWwnKTogbnVtYmVyIHtcbiAgaWYgKGJvdW5kID09PSAnZmxvb3InKSB7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IodmFsICogKDEgLyBzdGVwKSkgLyAoMSAvIHN0ZXApO1xuICB9XG5cbiAgcmV0dXJuIE1hdGguY2VpbCh2YWwgKiAoMSAvIHN0ZXApKSAvICgxIC8gc3RlcCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0luUmFuZ2UodmFsOiBhbnksIGRvbWFpbjogbnVtYmVyW10pOiBib29sZWFuIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGRvbWFpbikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdmFsID49IGRvbWFpblswXSAmJiB2YWwgPD0gZG9tYWluWzFdO1xufVxuXG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciBhIHBvaW50IGlzIHdpdGhpbiB0aGUgcHJvdmlkZWQgcG9seWdvblxuICpcbiAqIEBwYXJhbSBwb2ludCBhcyBpbnB1dCBzZWFyY2ggW2xhdCwgbG5nXVxuICogQHBhcmFtIHBvbHlnb24gUG9pbnRzIG11c3QgYmUgd2l0aGluIHRoZXNlIChNdWx0aSlQb2x5Z29uKHMpXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNJblBvbHlnb24ocG9pbnQ6IG51bWJlcltdLCBwb2x5Z29uOiBhbnkpOiBib29sZWFuIHtcbiAgcmV0dXJuIGJvb2xlYW5XaXRoaW4odHVyZlBvaW50KHBvaW50KSwgcG9seWdvbik7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0VGltZVdpZGdldFRpdGxlRm9ybWF0dGVyKGRvbWFpbjogW251bWJlciwgbnVtYmVyXSk6IHN0cmluZyB8IG51bGwge1xuICBpZiAoIWlzVmFsaWRUaW1lRG9tYWluKGRvbWFpbikpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGNvbnN0IGRpZmYgPSBkb21haW5bMV0gLSBkb21haW5bMF07XG5cbiAgLy8gTG9jYWwgYXdhcmUgZm9ybWF0c1xuICAvLyBodHRwczovL21vbWVudGpzLmNvbS9kb2NzLyMvcGFyc2luZy9zdHJpbmctZm9ybWF0XG4gIHJldHVybiBkaWZmID4gZHVyYXRpb25ZZWFyID8gJ0wnIDogZGlmZiA+IGR1cmF0aW9uRGF5ID8gJ0wgTFQnIDogJ0wgTFRTJztcbn1cblxuLyoqXG4gKiBTYW5pdHkgY2hlY2sgb24gZmlsdGVycyB0byBwcmVwYXJlIGZvciBzYXZlXG4gKiBAdHlwZSB7dHlwZW9mIGltcG9ydCgnLi9maWx0ZXItdXRpbHMnKS5pc0ZpbHRlclZhbGlkVG9TYXZlfVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNGaWx0ZXJWYWxpZFRvU2F2ZShmaWx0ZXI6IGFueSk6IGJvb2xlYW4ge1xuICByZXR1cm4gKFxuICAgIGZpbHRlcj8udHlwZSAmJlxuICAgIEFycmF5LmlzQXJyYXkoZmlsdGVyPy5uYW1lKSAmJlxuICAgIChmaWx0ZXI/Lm5hbWUubGVuZ3RoIHx8IGZpbHRlcj8ubGF5ZXJJZC5sZW5ndGgpICYmXG4gICAgaXNWYWxpZEZpbHRlclZhbHVlKGZpbHRlcj8udHlwZSwgZmlsdGVyPy52YWx1ZSlcbiAgKTtcbn1cblxuLyoqXG4gKiBTYW5pdHkgY2hlY2sgb24gZmlsdGVycyB0byBwcmVwYXJlIGZvciBzYXZlXG4gKiBAdHlwZSB7dHlwZW9mIGltcG9ydCgnLi9maWx0ZXItdXRpbHMnKS5pc1ZhbGlkRmlsdGVyVmFsdWV9XG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIGNvbXBsZXhpdHkgKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1ZhbGlkRmlsdGVyVmFsdWUodHlwZTogc3RyaW5nIHwgbnVsbCwgdmFsdWU6IGFueSk6IGJvb2xlYW4ge1xuICBpZiAoIXR5cGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBGSUxURVJfVFlQRVMuc2VsZWN0OlxuICAgICAgcmV0dXJuIHZhbHVlID09PSB0cnVlIHx8IHZhbHVlID09PSBmYWxzZTtcblxuICAgIGNhc2UgRklMVEVSX1RZUEVTLnJhbmdlOlxuICAgIGNhc2UgRklMVEVSX1RZUEVTLnRpbWVSYW5nZTpcbiAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5ldmVyeSh2ID0+IHYgIT09IG51bGwgJiYgIWlzTmFOKHYpKTtcblxuICAgIGNhc2UgRklMVEVSX1RZUEVTLm11bHRpU2VsZWN0OlxuICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpICYmIEJvb2xlYW4odmFsdWUubGVuZ3RoKTtcblxuICAgIGNhc2UgRklMVEVSX1RZUEVTLmlucHV0OlxuICAgICAgcmV0dXJuIEJvb2xlYW4odmFsdWUubGVuZ3RoKTtcblxuICAgIGNhc2UgRklMVEVSX1RZUEVTLnBvbHlnb246XG4gICAgICBjb25zdCBjb29yZGluYXRlcyA9IGdldCh2YWx1ZSwgWydnZW9tZXRyeScsICdjb29yZGluYXRlcyddKTtcbiAgICAgIHJldHVybiBCb29sZWFuKHZhbHVlICYmIHZhbHVlLmlkICYmIGNvb3JkaW5hdGVzKTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q29sdW1uRmlsdGVyUHJvcHM8SyBleHRlbmRzIEtlcGxlclRhYmxlTW9kZWw8SywgTD4sIEw+KFxuICBmaWx0ZXI6IEZpbHRlcixcbiAgZGF0YXNldDogS1xuKToge2xpbmVDaGFydDogTGluZUNoYXJ0OyB5QXhzOiBGaWVsZH0gfCB7fSB7XG4gIGlmIChmaWx0ZXIucGxvdFR5cGUgPT09IFBMT1RfVFlQRVMuaGlzdG9ncmFtIHx8ICFmaWx0ZXIueUF4aXMpIHtcbiAgICAvLyBoaXN0b2dyYW0gc2hvdWxkIGJlIGNhbGN1bGF0ZWQgd2hlbiBjcmVhdGUgZmlsdGVyXG4gICAgcmV0dXJuIHt9O1xuICB9XG5cbiAgY29uc3Qge21hcHBlZFZhbHVlID0gW119ID0gZmlsdGVyO1xuICBjb25zdCB7eUF4aXN9ID0gZmlsdGVyO1xuICBjb25zdCBmaWVsZElkeCA9IGRhdGFzZXQuZ2V0Q29sdW1uRmllbGRJZHgoeUF4aXMubmFtZSk7XG4gIGlmIChmaWVsZElkeCA8IDApIHtcbiAgICBDb25zb2xlLndhcm4oYHlBeGlzICR7eUF4aXMubmFtZX0gZG9lcyBub3QgZXhpc3QgaW4gZGF0YXNldGApO1xuICAgIHJldHVybiB7bGluZUNoYXJ0OiB7fSwgeUF4aXN9O1xuICB9XG5cbiAgLy8gcmV0dXJuIGxpbmVDaGFydFxuICBjb25zdCBzZXJpZXMgPSBkYXRhc2V0LmRhdGFDb250YWluZXJcbiAgICAubWFwKFxuICAgICAgKHJvdywgcm93SW5kZXgpID0+ICh7XG4gICAgICAgIHg6IG1hcHBlZFZhbHVlW3Jvd0luZGV4XSxcbiAgICAgICAgeTogcm93LnZhbHVlQXQoZmllbGRJZHgpXG4gICAgICB9KSxcbiAgICAgIHRydWVcbiAgICApXG4gICAgLmZpbHRlcigoe3gsIHl9KSA9PiBOdW1iZXIuaXNGaW5pdGUoeCkgJiYgTnVtYmVyLmlzRmluaXRlKHkpKVxuICAgIC5zb3J0KChhLCBiKSA9PiBhc2NlbmRpbmcoYS54LCBiLngpKTtcblxuICBjb25zdCB5RG9tYWluID0gZXh0ZW50KHNlcmllcywgZCA9PiBkLnkpO1xuICBjb25zdCB4RG9tYWluID0gW3Nlcmllc1swXS54LCBzZXJpZXNbc2VyaWVzLmxlbmd0aCAtIDFdLnhdO1xuXG4gIHJldHVybiB7bGluZUNoYXJ0OiB7c2VyaWVzLCB5RG9tYWluLCB4RG9tYWlufSwgeUF4aXN9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGVmYXVsdEZpbHRlclBsb3RUeXBlKGZpbHRlcjogRmlsdGVyKTogc3RyaW5nIHwgbnVsbCB7XG4gIGNvbnN0IGZpbHRlclBsb3RUeXBlczogdHlwZW9mIFN1cHBvcnRlZFBsb3RUeXBlW2tleW9mIHR5cGVvZiBTdXBwb3J0ZWRQbG90VHlwZV0gfCBudWxsID1cbiAgICBmaWx0ZXIudHlwZSAmJiBTdXBwb3J0ZWRQbG90VHlwZVtmaWx0ZXIudHlwZV07XG4gIGlmICghZmlsdGVyUGxvdFR5cGVzKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAoIWZpbHRlci55QXhpcykge1xuICAgIHJldHVybiBmaWx0ZXJQbG90VHlwZXMuZGVmYXVsdDtcbiAgfVxuXG4gIHJldHVybiBmaWx0ZXJQbG90VHlwZXNbZmlsdGVyLnlBeGlzLnR5cGVdIHx8IG51bGw7XG59XG5cbi8qKlxuICpcbiAqIEBwYXJhbSBkYXRhc2V0SWRzIGxpc3Qgb2YgZGF0YXNldCBpZHMgdG8gYmUgZmlsdGVyZWRcbiAqIEBwYXJhbSBkYXRhc2V0cyBhbGwgZGF0YXNldHNcbiAqIEBwYXJhbSBmaWx0ZXJzIGFsbCBmaWx0ZXJzIHRvIGJlIGFwcGxpZWQgdG8gZGF0YXNldHNcbiAqIEByZXR1cm4gZGF0YXNldHMgLSBuZXcgdXBkYXRlZCBkYXRhc2V0c1xuICovXG5leHBvcnQgZnVuY3Rpb24gYXBwbHlGaWx0ZXJzVG9EYXRhc2V0czxcbiAgSyBleHRlbmRzIEtlcGxlclRhYmxlTW9kZWw8SywgTD4sXG4gIEwgZXh0ZW5kcyB7Y29uZmlnOiB7ZGF0YUlkOiBzdHJpbmcgfCBudWxsfX1cbj4oXG4gIGRhdGFzZXRJZHM6IHN0cmluZ1tdLFxuICBkYXRhc2V0czoge1tpZDogc3RyaW5nXTogS30sXG4gIGZpbHRlcnM6IEZpbHRlcltdLFxuICBsYXllcnM/OiBMW11cbik6IHtbaWQ6IHN0cmluZ106IEt9IHtcbiAgY29uc3QgZGF0YUlkcyA9IHRvQXJyYXkoZGF0YXNldElkcyk7XG4gIHJldHVybiBkYXRhSWRzLnJlZHVjZSgoYWNjLCBkYXRhSWQpID0+IHtcbiAgICBjb25zdCBsYXllcnNUb0ZpbHRlciA9IChsYXllcnMgfHwgW10pLmZpbHRlcihsID0+IGwuY29uZmlnLmRhdGFJZCA9PT0gZGF0YUlkKTtcbiAgICBjb25zdCBhcHBsaWVkRmlsdGVycyA9IGZpbHRlcnMuZmlsdGVyKGQgPT4gc2hvdWxkQXBwbHlGaWx0ZXIoZCwgZGF0YUlkKSk7XG4gICAgY29uc3QgdGFibGUgPSBkYXRhc2V0c1tkYXRhSWRdO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmFjYyxcbiAgICAgIFtkYXRhSWRdOiB0YWJsZS5maWx0ZXJUYWJsZShhcHBsaWVkRmlsdGVycywgbGF5ZXJzVG9GaWx0ZXIsIHt9KVxuICAgIH07XG4gIH0sIGRhdGFzZXRzKTtcbn1cblxuLyoqXG4gKiBBcHBsaWVzIGEgbmV3IGZpZWxkIG5hbWUgdmFsdWUgdG8gZmllbHRlciBhbmQgdXBkYXRlIGJvdGggZmlsdGVyIGFuZCBkYXRhc2V0XG4gKiBAcGFyYW0gZmlsdGVyIC0gdG8gYmUgYXBwbGllZCB0aGUgbmV3IGZpZWxkIG5hbWUgb25cbiAqIEBwYXJhbSBkYXRhc2V0IC0gZGF0YXNldCB0aGUgZmllbGQgYmVsb25ncyB0b1xuICogQHBhcmFtIGZpZWxkTmFtZSAtIGZpZWxkLm5hbWVcbiAqIEBwYXJhbSBmaWx0ZXJEYXRhc2V0SW5kZXggLSBmaWVsZC5uYW1lXG4gKiBAcGFyYW0gb3B0aW9uXG4gKiBAcmV0dXJuIC0ge2ZpbHRlciwgZGF0YXNldHN9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhcHBseUZpbHRlckZpZWxkTmFtZTxLIGV4dGVuZHMgS2VwbGVyVGFibGVNb2RlbDxLLCBMPiwgTD4oXG4gIGZpbHRlcjogRmlsdGVyLFxuICBkYXRhc2V0OiBLLFxuICBmaWVsZE5hbWU6IHN0cmluZyxcbiAgZmlsdGVyRGF0YXNldEluZGV4ID0gMCxcbiAgb3B0aW9uPzoge21lcmdlRG9tYWluOiBib29sZWFufVxuKToge1xuICBmaWx0ZXI6IEZpbHRlciB8IG51bGw7XG4gIGRhdGFzZXQ6IEs7XG59IHtcbiAgLy8gdXNpbmcgZmlsdGVyRGF0YXNldEluZGV4IHdlIGNhbiBmaWx0ZXIgb25seSB0aGUgc3BlY2lmaWVkIGRhdGFzZXRcbiAgY29uc3QgbWVyZ2VEb21haW4gPSBvcHRpb24gJiYgb3B0aW9uLmhhc093blByb3BlcnR5KCdtZXJnZURvbWFpbicpID8gb3B0aW9uLm1lcmdlRG9tYWluIDogZmFsc2U7XG5cbiAgY29uc3QgZmllbGRJbmRleCA9IGRhdGFzZXQuZ2V0Q29sdW1uRmllbGRJZHgoZmllbGROYW1lKTtcbiAgLy8gaWYgbm8gZmllbGQgd2l0aCBzYW1lIG5hbWUgaXMgZm91bmQsIG1vdmUgdG8gdGhlIG5leHQgZGF0YXNldHNcbiAgaWYgKGZpZWxkSW5kZXggPT09IC0xKSB7XG4gICAgLy8gdGhyb3cgbmV3IEVycm9yKGBmaWVsZEluZGV4IG5vdCBmb3VuZC4gRGF0YXNldCBtdXN0IGNvbnRhaW4gYSBwcm9wZXJ0eSB3aXRoIG5hbWU6ICR7ZmllbGROYW1lfWApO1xuICAgIHJldHVybiB7ZmlsdGVyOiBudWxsLCBkYXRhc2V0fTtcbiAgfVxuXG4gIC8vIFRPRE86IHZhbGlkYXRlIGZpZWxkIHR5cGVcbiAgY29uc3QgZmlsdGVyUHJvcHMgPSBkYXRhc2V0LmdldENvbHVtbkZpbHRlclByb3BzKGZpZWxkTmFtZSk7XG5cbiAgY29uc3QgbmV3RmlsdGVyID0ge1xuICAgIC4uLihtZXJnZURvbWFpbiA/IG1lcmdlRmlsdGVyRG9tYWluU3RlcChmaWx0ZXIsIGZpbHRlclByb3BzKSA6IHsuLi5maWx0ZXIsIC4uLmZpbHRlclByb3BzfSksXG4gICAgbmFtZTogT2JqZWN0LmFzc2lnbihbLi4udG9BcnJheShmaWx0ZXIubmFtZSldLCB7W2ZpbHRlckRhdGFzZXRJbmRleF06IGZpZWxkTmFtZX0pLFxuICAgIGZpZWxkSWR4OiBPYmplY3QuYXNzaWduKFsuLi50b0FycmF5KGZpbHRlci5maWVsZElkeCldLCB7XG4gICAgICBbZmlsdGVyRGF0YXNldEluZGV4XTogZmllbGRJbmRleFxuICAgIH0pLFxuICAgIC8vIFRPRE8sIHNpbmNlIHdlIGFsbG93IHRvIGFkZCBtdWx0aXBsZSBmaWVsZHMgdG8gYSBmaWx0ZXIgd2UgY2FuIG5vIGxvbmdlciBmcmVlemUgdGhlIGZpbHRlclxuICAgIGZyZWV6ZTogdHJ1ZVxuICB9O1xuXG4gIHJldHVybiB7XG4gICAgZmlsdGVyOiBuZXdGaWx0ZXIsXG4gICAgZGF0YXNldFxuICB9O1xufVxuXG4vKipcbiAqIE1lcmdlIG9uZSBmaWx0ZXIgd2l0aCBvdGhlciBmaWx0ZXIgcHJvcCBkb21haW5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgY29tcGxleGl0eSAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlRmlsdGVyRG9tYWluU3RlcChcbiAgZmlsdGVyOiBGaWx0ZXIsXG4gIGZpbHRlclByb3BzPzogUGFydGlhbDxGaWx0ZXI+XG4pOiAoRmlsdGVyICYge3N0ZXA/OiBudW1iZXJ9KSB8IG51bGwge1xuICBpZiAoIWZpbHRlcikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKCFmaWx0ZXJQcm9wcykge1xuICAgIHJldHVybiBmaWx0ZXI7XG4gIH1cblxuICBpZiAoKGZpbHRlci5maWVsZFR5cGUgJiYgZmlsdGVyLmZpZWxkVHlwZSAhPT0gZmlsdGVyUHJvcHMuZmllbGRUeXBlKSB8fCAhZmlsdGVyUHJvcHMuZG9tYWluKSB7XG4gICAgcmV0dXJuIGZpbHRlcjtcbiAgfVxuXG4gIGNvbnN0IGNvbWJpbmVkRG9tYWluID0gIWZpbHRlci5kb21haW5cbiAgICA/IGZpbHRlclByb3BzLmRvbWFpblxuICAgIDogWy4uLihmaWx0ZXIuZG9tYWluIHx8IFtdKSwgLi4uKGZpbHRlclByb3BzLmRvbWFpbiB8fCBbXSldLnNvcnQoKGEsIGIpID0+IGEgLSBiKTtcblxuICBjb25zdCBuZXdGaWx0ZXIgPSB7XG4gICAgLi4uZmlsdGVyLFxuICAgIC4uLmZpbHRlclByb3BzLFxuICAgIGRvbWFpbjogW2NvbWJpbmVkRG9tYWluWzBdLCBjb21iaW5lZERvbWFpbltjb21iaW5lZERvbWFpbi5sZW5ndGggLSAxXV1cbiAgfTtcblxuICBzd2l0Y2ggKGZpbHRlclByb3BzLmZpZWxkVHlwZSkge1xuICAgIGNhc2UgQUxMX0ZJRUxEX1RZUEVTLnN0cmluZzpcbiAgICBjYXNlIEFMTF9GSUVMRF9UWVBFUy5kYXRlOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4ubmV3RmlsdGVyLFxuICAgICAgICBkb21haW46IHVuaXF1ZShjb21iaW5lZERvbWFpbikuc29ydCgpXG4gICAgICB9O1xuXG4gICAgY2FzZSBBTExfRklFTERfVFlQRVMudGltZXN0YW1wOlxuICAgICAgY29uc3Qgc3RlcCA9XG4gICAgICAgIChmaWx0ZXIgYXMgVGltZVJhbmdlRmlsdGVyKS5zdGVwIDwgKGZpbHRlclByb3BzIGFzIFRpbWVSYW5nZUZpZWxkRG9tYWluKS5zdGVwXG4gICAgICAgICAgPyAoZmlsdGVyIGFzIFRpbWVSYW5nZUZpbHRlcikuc3RlcFxuICAgICAgICAgIDogKGZpbHRlclByb3BzIGFzIFRpbWVSYW5nZUZpZWxkRG9tYWluKS5zdGVwO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5uZXdGaWx0ZXIsXG4gICAgICAgIHN0ZXBcbiAgICAgIH07XG4gICAgY2FzZSBBTExfRklFTERfVFlQRVMucmVhbDpcbiAgICBjYXNlIEFMTF9GSUVMRF9UWVBFUy5pbnRlZ2VyOlxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gbmV3RmlsdGVyO1xuICB9XG59XG4vKiBlc2xpbnQtZW5hYmxlIGNvbXBsZXhpdHkgKi9cblxuLyoqXG4gKiBHZW5lcmF0ZXMgcG9seWdvbiBmaWx0ZXJcbiAqL1xuZXhwb3J0IGNvbnN0IGZlYXR1cmVUb0ZpbHRlclZhbHVlID0gKFxuICBmZWF0dXJlOiBGZWF0dXJlLFxuICBmaWx0ZXJJZDogc3RyaW5nLFxuICBwcm9wZXJ0aWVzPzoge31cbik6IEZlYXR1cmVWYWx1ZSA9PiAoe1xuICAuLi5mZWF0dXJlLFxuICBpZDogZmVhdHVyZS5pZCxcbiAgcHJvcGVydGllczoge1xuICAgIC4uLmZlYXR1cmUucHJvcGVydGllcyxcbiAgICAuLi5wcm9wZXJ0aWVzLFxuICAgIGZpbHRlcklkXG4gIH1cbn0pO1xuXG5leHBvcnQgY29uc3QgZ2V0RmlsdGVySWRJbkZlYXR1cmUgPSAoZjogRmVhdHVyZVZhbHVlKTogc3RyaW5nID0+IGdldChmLCBbJ3Byb3BlcnRpZXMnLCAnZmlsdGVySWQnXSk7XG5cbi8qKlxuICogR2VuZXJhdGVzIHBvbHlnb24gZmlsdGVyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZVBvbHlnb25GaWx0ZXI8XG4gIEwgZXh0ZW5kcyB7Y29uZmlnOiB7ZGF0YUlkOiBzdHJpbmcgfCBudWxsOyBsYWJlbDogc3RyaW5nfTsgaWQ6IHN0cmluZ31cbj4obGF5ZXJzOiBMW10sIGZlYXR1cmU6IEZlYXR1cmUpOiBQb2x5Z29uRmlsdGVyIHtcbiAgY29uc3QgZGF0YUlkID0gbGF5ZXJzLm1hcChsID0+IGwuY29uZmlnLmRhdGFJZCkuZmlsdGVyKG5vdE51bGxvclVuZGVmaW5lZCk7XG4gIGNvbnN0IGxheWVySWQgPSBsYXllcnMubWFwKGwgPT4gbC5pZCk7XG4gIGNvbnN0IG5hbWUgPSBsYXllcnMubWFwKGwgPT4gbC5jb25maWcubGFiZWwpO1xuICBjb25zdCBmaWx0ZXIgPSBnZXREZWZhdWx0RmlsdGVyKGRhdGFJZCk7XG4gIHJldHVybiB7XG4gICAgLi4uZmlsdGVyLFxuICAgIGZpeGVkRG9tYWluOiB0cnVlLFxuICAgIHR5cGU6IEZJTFRFUl9UWVBFUy5wb2x5Z29uLFxuICAgIG5hbWUsXG4gICAgbGF5ZXJJZCxcbiAgICB2YWx1ZTogZmVhdHVyZVRvRmlsdGVyVmFsdWUoZmVhdHVyZSwgZmlsdGVyLmlkLCB7aXNWaXNpYmxlOiB0cnVlfSlcbiAgfTtcbn1cblxuLyoqXG4gKiBSdW4gZmlsdGVyIGVudGlyZWx5IG9uIENQVVxuICovXG5pbnRlcmZhY2UgU3RhdGVUeXBlPEsgZXh0ZW5kcyBLZXBsZXJUYWJsZU1vZGVsPEssIEw+LCBMPiB7XG4gIGxheWVyczogTFtdO1xuICBmaWx0ZXJzOiBGaWx0ZXJbXTtcbiAgZGF0YXNldHM6IHtbaWQ6IHN0cmluZ106IEt9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZmlsdGVyRGF0YXNldENQVTxUIGV4dGVuZHMgU3RhdGVUeXBlPEssIEw+LCBLIGV4dGVuZHMgS2VwbGVyVGFibGVNb2RlbDxLLCBMPiwgTD4oXG4gIHN0YXRlOiBULFxuICBkYXRhSWQ6IHN0cmluZ1xuKTogVCB7XG4gIGNvbnN0IGRhdGFzZXRGaWx0ZXJzID0gc3RhdGUuZmlsdGVycy5maWx0ZXIoZiA9PiBmLmRhdGFJZC5pbmNsdWRlcyhkYXRhSWQpKTtcbiAgY29uc3QgZGF0YXNldCA9IHN0YXRlLmRhdGFzZXRzW2RhdGFJZF07XG5cbiAgaWYgKCFkYXRhc2V0KSB7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG5cbiAgY29uc3QgY3B1RmlsdGVyZWREYXRhc2V0ID0gZGF0YXNldC5maWx0ZXJUYWJsZUNQVShkYXRhc2V0RmlsdGVycywgc3RhdGUubGF5ZXJzKTtcblxuICByZXR1cm4gc2V0KFsnZGF0YXNldHMnLCBkYXRhSWRdLCBjcHVGaWx0ZXJlZERhdGFzZXQsIHN0YXRlKTtcbn1cblxuLyoqXG4gKiBWYWxpZGF0ZSBwYXJzZWQgZmlsdGVycyB3aXRoIGRhdGFzZXRzIGFuZCBhZGQgZmlsdGVyUHJvcHMgdG8gZmllbGRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlRmlsdGVyc1VwZGF0ZURhdGFzZXRzPFxuICBTIGV4dGVuZHMge2RhdGFzZXRzOiB7W2lkOiBzdHJpbmddOiBLfTsgbGF5ZXJzOiBMW119LFxuICBLIGV4dGVuZHMgS2VwbGVyVGFibGVNb2RlbDxLLCBMPixcbiAgTCBleHRlbmRzIHtjb25maWc6IHtkYXRhSWQ6IHN0cmluZyB8IG51bGw7IGxhYmVsOiBzdHJpbmd9OyBpZDogc3RyaW5nfVxuPihcbiAgc3RhdGU6IFMsXG4gIGZpbHRlcnNUb1ZhbGlkYXRlOiBQYXJzZWRGaWx0ZXJbXSA9IFtdXG4pOiB7XG4gIHZhbGlkYXRlZDogRmlsdGVyW107XG4gIGZhaWxlZDogRmlsdGVyW107XG4gIHVwZGF0ZWREYXRhc2V0czogU1snZGF0YXNldHMnXTtcbn0ge1xuICAvLyBUT0RPIEJldHRlciBUeXBpbmdzIGhlcmVcbiAgY29uc3QgdmFsaWRhdGVkOiBhbnlbXSA9IFtdO1xuICBjb25zdCBmYWlsZWQ6IGFueVtdID0gW107XG4gIGNvbnN0IHtkYXRhc2V0c30gPSBzdGF0ZTtcbiAgbGV0IHVwZGF0ZWREYXRhc2V0cyA9IGRhdGFzZXRzO1xuXG4gIC8vIG1lcmdlIGZpbHRlcnNcbiAgZmlsdGVyc1RvVmFsaWRhdGUuZm9yRWFjaChmaWx0ZXIgPT4ge1xuICAgIC8vIHdlIGNhbiBvbmx5IGxvb2sgZm9yIGRhdGFzZXRzIGRlZmluZSBpbiB0aGUgZmlsdGVyIGRhdGFJZFxuICAgIGNvbnN0IGRhdGFzZXRJZHMgPSB0b0FycmF5KGZpbHRlci5kYXRhSWQpO1xuXG4gICAgLy8gd2UgY2FuIG1lcmdlIGEgZmlsdGVyIG9ubHkgaWYgYWxsIGRhdGFzZXRzIGluIGZpbHRlci5kYXRhSWQgYXJlIGxvYWRlZFxuICAgIGlmIChkYXRhc2V0SWRzLmV2ZXJ5KGQgPT4gZGF0YXNldHNbZF0pKSB7XG4gICAgICAvLyBhbGwgZGF0YXNldElkcyBpbiBmaWx0ZXIgbXVzdCBiZSBwcmVzZW50IHRoZSBzdGF0ZSBkYXRhc2V0c1xuICAgICAgY29uc3Qge2ZpbHRlcjogdmFsaWRhdGVkRmlsdGVyLCBhcHBseVRvRGF0YXNldHMsIGF1Z21lbnRlZERhdGFzZXRzfSA9IGRhdGFzZXRJZHMucmVkdWNlKFxuICAgICAgICAoYWNjLCBkYXRhc2V0SWQpID0+IHtcbiAgICAgICAgICBjb25zdCBkYXRhc2V0ID0gdXBkYXRlZERhdGFzZXRzW2RhdGFzZXRJZF07XG4gICAgICAgICAgY29uc3QgbGF5ZXJzID0gc3RhdGUubGF5ZXJzLmZpbHRlcihsID0+IGwuY29uZmlnLmRhdGFJZCA9PT0gZGF0YXNldC5pZCk7XG4gICAgICAgICAgY29uc3Qge2ZpbHRlcjogdXBkYXRlZEZpbHRlciwgZGF0YXNldDogdXBkYXRlZERhdGFzZXR9ID0gdmFsaWRhdGVGaWx0ZXJXaXRoRGF0YShcbiAgICAgICAgICAgIGFjYy5hdWdtZW50ZWREYXRhc2V0c1tkYXRhc2V0SWRdIHx8IGRhdGFzZXQsXG4gICAgICAgICAgICBmaWx0ZXIsXG4gICAgICAgICAgICBsYXllcnNcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgaWYgKHVwZGF0ZWRGaWx0ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIC4uLmFjYyxcbiAgICAgICAgICAgICAgLy8gbWVyZ2UgZmlsdGVyIHByb3BzXG4gICAgICAgICAgICAgIGZpbHRlcjogYWNjLmZpbHRlclxuICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICAuLi5hY2MuZmlsdGVyLFxuICAgICAgICAgICAgICAgICAgICAuLi5tZXJnZUZpbHRlckRvbWFpblN0ZXAoYWNjLCB1cGRhdGVkRmlsdGVyKVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDogdXBkYXRlZEZpbHRlcixcblxuICAgICAgICAgICAgICBhcHBseVRvRGF0YXNldHM6IFsuLi5hY2MuYXBwbHlUb0RhdGFzZXRzLCBkYXRhc2V0SWRdLFxuXG4gICAgICAgICAgICAgIGF1Z21lbnRlZERhdGFzZXRzOiB7XG4gICAgICAgICAgICAgICAgLi4uYWNjLmF1Z21lbnRlZERhdGFzZXRzLFxuICAgICAgICAgICAgICAgIFtkYXRhc2V0SWRdOiB1cGRhdGVkRGF0YXNldFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBmaWx0ZXI6IG51bGwsXG4gICAgICAgICAgYXBwbHlUb0RhdGFzZXRzOiBbXSxcbiAgICAgICAgICBhdWdtZW50ZWREYXRhc2V0czoge31cbiAgICAgICAgfVxuICAgICAgKTtcblxuICAgICAgaWYgKHZhbGlkYXRlZEZpbHRlciAmJiBpc0VxdWFsKGRhdGFzZXRJZHMsIGFwcGx5VG9EYXRhc2V0cykpIHtcbiAgICAgICAgdmFsaWRhdGVkLnB1c2godmFsaWRhdGVkRmlsdGVyKTtcbiAgICAgICAgdXBkYXRlZERhdGFzZXRzID0ge1xuICAgICAgICAgIC4uLnVwZGF0ZWREYXRhc2V0cyxcbiAgICAgICAgICAuLi5hdWdtZW50ZWREYXRhc2V0c1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmYWlsZWQucHVzaChmaWx0ZXIpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHt2YWxpZGF0ZWQsIGZhaWxlZCwgdXBkYXRlZERhdGFzZXRzfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEZpbHRlclBsb3Q8SyBleHRlbmRzIEtlcGxlclRhYmxlTW9kZWw8SywgTD4sIEw+KFxuICBmaWx0ZXI6IEZpbHRlcixcbiAgZGF0YXNldDogS1xuKToge2xpbmVDaGFydDogTGluZUNoYXJ0OyB5QXhzOiBGaWVsZH0gfCB7fSB7XG4gIGlmIChmaWx0ZXIucGxvdFR5cGUgPT09IFBMT1RfVFlQRVMuaGlzdG9ncmFtIHx8ICFmaWx0ZXIueUF4aXMpIHtcbiAgICAvLyBoaXN0b2dyYW0gc2hvdWxkIGJlIGNhbGN1bGF0ZWQgd2hlbiBjcmVhdGUgZmlsdGVyXG4gICAgcmV0dXJuIHt9O1xuICB9XG5cbiAgY29uc3Qge21hcHBlZFZhbHVlID0gW119ID0gZmlsdGVyO1xuICBjb25zdCB7eUF4aXN9ID0gZmlsdGVyO1xuICBjb25zdCBmaWVsZElkeCA9IGRhdGFzZXQuZ2V0Q29sdW1uRmllbGRJZHgoeUF4aXMubmFtZSk7XG4gIGlmIChmaWVsZElkeCA8IDApIHtcbiAgICBDb25zb2xlLndhcm4oYHlBeGlzICR7eUF4aXMubmFtZX0gZG9lcyBub3QgZXhpc3QgaW4gZGF0YXNldGApO1xuICAgIHJldHVybiB7bGluZUNoYXJ0OiB7fSwgeUF4aXN9O1xuICB9XG5cbiAgLy8gcmV0dXJuIGxpbmVDaGFydFxuICBjb25zdCBzZXJpZXMgPSBkYXRhc2V0LmRhdGFDb250YWluZXJcbiAgICAubWFwKFxuICAgICAgKHJvdywgcm93SW5kZXgpID0+ICh7XG4gICAgICAgIHg6IG1hcHBlZFZhbHVlW3Jvd0luZGV4XSxcbiAgICAgICAgeTogcm93LnZhbHVlQXQoZmllbGRJZHgpXG4gICAgICB9KSxcbiAgICAgIHRydWVcbiAgICApXG4gICAgLmZpbHRlcigoe3gsIHl9KSA9PiBOdW1iZXIuaXNGaW5pdGUoeCkgJiYgTnVtYmVyLmlzRmluaXRlKHkpKVxuICAgIC5zb3J0KChhLCBiKSA9PiBhc2NlbmRpbmcoYS54LCBiLngpKTtcblxuICBjb25zdCB5RG9tYWluID0gZXh0ZW50KHNlcmllcywgZCA9PiBkLnkpO1xuICBjb25zdCB4RG9tYWluID0gW3Nlcmllc1swXS54LCBzZXJpZXNbc2VyaWVzLmxlbmd0aCAtIDFdLnhdO1xuXG4gIHJldHVybiB7bGluZUNoYXJ0OiB7c2VyaWVzLCB5RG9tYWluLCB4RG9tYWlufSwgeUF4aXN9O1xufVxuXG4vKipcbiAqIFJldHJpZXZlIGludGVydmFsIGJpbnMgZm9yIHRpbWUgZmlsdGVyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRJbnRlcnZhbEJpbnMoZmlsdGVyOiBUaW1lUmFuZ2VGaWx0ZXIpIHtcbiAgY29uc3Qge2JpbnN9ID0gZmlsdGVyO1xuICBjb25zdCBpbnRlcnZhbCA9IGZpbHRlci5wbG90VHlwZT8uaW50ZXJ2YWw7XG4gIGlmICghaW50ZXJ2YWwgfHwgIWJpbnMgfHwgT2JqZWN0LmtleXMoYmlucykubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgdmFsdWVzID0gT2JqZWN0LnZhbHVlcyhiaW5zKTtcbiAgcmV0dXJuIHZhbHVlc1swXSA/IHZhbHVlc1swXVtpbnRlcnZhbF0gOiBudWxsO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNWYWxpZFRpbWVEb21haW4oZG9tYWluKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGRvbWFpbikgJiYgZG9tYWluLmV2ZXJ5KE51bWJlci5pc0Zpbml0ZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRUaW1lV2lkZ2V0SGludEZvcm1hdHRlcihkb21haW46IFtudW1iZXIsIG51bWJlcl0pOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICBpZiAoIWlzVmFsaWRUaW1lRG9tYWluKGRvbWFpbikpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgY29uc3QgZGlmZiA9IGRvbWFpblsxXSAtIGRvbWFpblswXTtcbiAgcmV0dXJuIGRpZmYgPiBkdXJhdGlvbldlZWtcbiAgICA/ICdMJ1xuICAgIDogZGlmZiA+IGR1cmF0aW9uRGF5XG4gICAgPyAnTCBMVCdcbiAgICA6IGRpZmYgPiBkdXJhdGlvbkhvdXJcbiAgICA/ICdMVCdcbiAgICA6ICdMVFMnO1xufVxuIl19