// Copyright (c) 2022 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.IndexedDataContainer = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _dataRow = require("./data-row");

var _marked = /*#__PURE__*/_regenerator["default"].mark(rowsIterator),
    _marked2 = /*#__PURE__*/_regenerator["default"].mark(columnIterator);

/**
 * @param dataContainer
 * @param indices
 * @param sharedRow
 * @returns
 */
function rowsIterator(dataContainer, indices, sharedRow) {
  var numRows, rowIndex, mappedRowIndex;
  return _regenerator["default"].wrap(function rowsIterator$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          numRows = indices.length;
          rowIndex = 0;

        case 2:
          if (!(rowIndex < numRows)) {
            _context.next = 9;
            break;
          }

          mappedRowIndex = indices[rowIndex];
          _context.next = 6;
          return dataContainer.row(mappedRowIndex, sharedRow);

        case 6:
          ++rowIndex;
          _context.next = 2;
          break;

        case 9:
        case "end":
          return _context.stop();
      }
    }
  }, _marked);
}
/**
 * @param dataContainer
 * @param indices
 * @param columnIndex
 * @returns
 */


function columnIterator(dataContainer, indices, columnIndex) {
  var numRows, rowIndex, mappedRowIndex;
  return _regenerator["default"].wrap(function columnIterator$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          numRows = indices.length;
          rowIndex = 0;

        case 2:
          if (!(rowIndex < numRows)) {
            _context2.next = 9;
            break;
          }

          mappedRowIndex = indices[rowIndex];
          _context2.next = 6;
          return dataContainer.valueAt(mappedRowIndex, columnIndex);

        case 6:
          ++rowIndex;
          _context2.next = 2;
          break;

        case 9:
        case "end":
          return _context2.stop();
      }
    }
  }, _marked2);
}
/**
 * A data container wrapper around another data container.
 * You have to pass an array of indices to reference rows in the parent data container.
 * For example indices [3, 4, 6, 8] means that IndexedDataContainer is going to have
 * 4 rows and row(2) points to 6th row in the referenced data container.
 */


var IndexedDataContainer = /*#__PURE__*/function () {
  function IndexedDataContainer(parentDataContainer, indices) {
    (0, _classCallCheck2["default"])(this, IndexedDataContainer);
    (0, _defineProperty2["default"])(this, "_parentDataContainer", void 0);
    (0, _defineProperty2["default"])(this, "_indices", void 0);
    this._parentDataContainer = parentDataContainer;
    this._indices = indices;
  }

  (0, _createClass2["default"])(IndexedDataContainer, [{
    key: "numRows",
    value: function numRows() {
      return this._indices.length;
    }
  }, {
    key: "numColumns",
    value: function numColumns() {
      return this._parentDataContainer.numColumns();
    }
    /**
     * Remaps a local index to an index in the parent dataset
     * @param rowIndex
     * @returns number
     */

  }, {
    key: "_mappedRowIndex",
    value: function _mappedRowIndex(rowIndex) {
      return this._indices[rowIndex];
    }
  }, {
    key: "valueAt",
    value: function valueAt(rowIndex, columnIndex) {
      return this._parentDataContainer.valueAt(this._mappedRowIndex(rowIndex), columnIndex);
    }
  }, {
    key: "row",
    value: function row(rowIndex, sharedRow) {
      return this._parentDataContainer.row(this._mappedRowIndex(rowIndex), sharedRow);
    }
  }, {
    key: "rowAsArray",
    value: function rowAsArray(rowIndex) {
      return this._parentDataContainer.rowAsArray(this._mappedRowIndex(rowIndex));
    }
  }, {
    key: "rows",
    value: function rows(sharedRow) {
      return rowsIterator(this._parentDataContainer, this._indices, sharedRow);
    }
  }, {
    key: "column",
    value: function column(columnIndex) {
      return columnIterator(this._parentDataContainer, this._indices, columnIndex);
    }
  }, {
    key: "getPlainIndex",
    value: function getPlainIndex() {
      return this._indices.map(function (_, i) {
        return i;
      });
    }
  }, {
    key: "flattenData",
    value: function flattenData() {
      var _this = this;

      var tSharedRow = _dataRow.DataRow.createSharedRow(true);

      return this._indices.map(function (_, i) {
        return _this.row(i, tSharedRow).values();
      }, this);
    }
  }, {
    key: "map",
    value: function map(func, sharedRow) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var _options$start = options.start,
          start = _options$start === void 0 ? 0 : _options$start,
          _options$end = options.end,
          end = _options$end === void 0 ? this.numRows() : _options$end;
      var endRow = Math.min(this.numRows(), end);

      var tSharedRow = _dataRow.DataRow.createSharedRow(sharedRow);

      var out = [];

      for (var rowIndex = start; rowIndex < endRow; ++rowIndex) {
        var _row = this.row(rowIndex, tSharedRow);

        out.push(func(_row, rowIndex));
      }

      return out;
    }
  }, {
    key: "mapIndex",
    value: function mapIndex(func) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var _options$start2 = options.start,
          start = _options$start2 === void 0 ? 0 : _options$start2,
          _options$end2 = options.end,
          end = _options$end2 === void 0 ? this.numRows() : _options$end2;
      var endRow = Math.min(this.numRows(), end);
      var out = [];

      for (var rowIndex = start; rowIndex < endRow; ++rowIndex) {
        out.push(func({
          index: this._mappedRowIndex(rowIndex)
        }, this._parentDataContainer));
      }

      return out;
    }
  }, {
    key: "find",
    value: function find(func, sharedRow) {
      var tSharedRow = _dataRow.DataRow.createSharedRow(sharedRow);

      for (var rowIndex = 0; rowIndex < this.numRows(); ++rowIndex) {
        var _row2 = this.row(rowIndex, tSharedRow);

        if (func(_row2, rowIndex)) {
          return _row2;
        }
      }

      return undefined;
    }
  }, {
    key: "reduce",
    value: function reduce(func, initialValue, sharedRow) {
      var tSharedRow = _dataRow.DataRow.createSharedRow(sharedRow);

      for (var rowIndex = 0; rowIndex < this._indices.length; ++rowIndex) {
        var _row3 = this.row(rowIndex, tSharedRow);

        initialValue = func(initialValue, _row3, rowIndex);
      }

      return initialValue;
    }
  }]);
  return IndexedDataContainer;
}();

exports.IndexedDataContainer = IndexedDataContainer;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9pbmRleGVkLWRhdGEtY29udGFpbmVyLnRzIl0sIm5hbWVzIjpbInJvd3NJdGVyYXRvciIsImNvbHVtbkl0ZXJhdG9yIiwiZGF0YUNvbnRhaW5lciIsImluZGljZXMiLCJzaGFyZWRSb3ciLCJudW1Sb3dzIiwibGVuZ3RoIiwicm93SW5kZXgiLCJtYXBwZWRSb3dJbmRleCIsInJvdyIsImNvbHVtbkluZGV4IiwidmFsdWVBdCIsIkluZGV4ZWREYXRhQ29udGFpbmVyIiwicGFyZW50RGF0YUNvbnRhaW5lciIsIl9wYXJlbnREYXRhQ29udGFpbmVyIiwiX2luZGljZXMiLCJudW1Db2x1bW5zIiwiX21hcHBlZFJvd0luZGV4Iiwicm93QXNBcnJheSIsIm1hcCIsIl8iLCJpIiwidFNoYXJlZFJvdyIsIkRhdGFSb3ciLCJjcmVhdGVTaGFyZWRSb3ciLCJ2YWx1ZXMiLCJmdW5jIiwib3B0aW9ucyIsInN0YXJ0IiwiZW5kIiwiZW5kUm93IiwiTWF0aCIsIm1pbiIsIm91dCIsInB1c2giLCJpbmRleCIsInVuZGVmaW5lZCIsImluaXRpYWxWYWx1ZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFxQkE7O3dEQVFVQSxZO3lEQWtCQUMsYzs7QUF4QlY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBVUQsWUFBVixDQUNFRSxhQURGLEVBRUVDLE9BRkYsRUFHRUMsU0FIRjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFLUUMsVUFBQUEsT0FMUixHQUtrQkYsT0FBTyxDQUFDRyxNQUwxQjtBQU1XQyxVQUFBQSxRQU5YLEdBTXNCLENBTnRCOztBQUFBO0FBQUEsZ0JBTXlCQSxRQUFRLEdBQUdGLE9BTnBDO0FBQUE7QUFBQTtBQUFBOztBQU9VRyxVQUFBQSxjQVBWLEdBTzJCTCxPQUFPLENBQUNJLFFBQUQsQ0FQbEM7QUFBQTtBQVFJLGlCQUFNTCxhQUFhLENBQUNPLEdBQWQsQ0FBa0JELGNBQWxCLEVBQWtDSixTQUFsQyxDQUFOOztB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QUFDRCIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAyMiBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5cbmltcG9ydCB7RGF0YUNvbnRhaW5lckludGVyZmFjZSwgUmFuZ2VPcHRpb25zfSBmcm9tICcuL2RhdGEtY29udGFpbmVyLWludGVyZmFjZSc7XG5pbXBvcnQge0RhdGFSb3csIFNoYXJlZFJvd09wdGlvbnN9IGZyb20gJy4vZGF0YS1yb3cnO1xuXG4vKipcbiAqIEBwYXJhbSBkYXRhQ29udGFpbmVyXG4gKiBAcGFyYW0gaW5kaWNlc1xuICogQHBhcmFtIHNoYXJlZFJvd1xuICogQHJldHVybnNcbiAqL1xuZnVuY3Rpb24qIHJvd3NJdGVyYXRvcihcbiAgZGF0YUNvbnRhaW5lcjogRGF0YUNvbnRhaW5lckludGVyZmFjZSxcbiAgaW5kaWNlczogbnVtYmVyW10sXG4gIHNoYXJlZFJvdzogU2hhcmVkUm93T3B0aW9uc1xuKTogR2VuZXJhdG9yPERhdGFSb3c+IHtcbiAgY29uc3QgbnVtUm93cyA9IGluZGljZXMubGVuZ3RoO1xuICBmb3IgKGxldCByb3dJbmRleCA9IDA7IHJvd0luZGV4IDwgbnVtUm93czsgKytyb3dJbmRleCkge1xuICAgIGNvbnN0IG1hcHBlZFJvd0luZGV4ID0gaW5kaWNlc1tyb3dJbmRleF07XG4gICAgeWllbGQgZGF0YUNvbnRhaW5lci5yb3cobWFwcGVkUm93SW5kZXgsIHNoYXJlZFJvdyk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0gZGF0YUNvbnRhaW5lclxuICogQHBhcmFtIGluZGljZXNcbiAqIEBwYXJhbSBjb2x1bW5JbmRleFxuICogQHJldHVybnNcbiAqL1xuZnVuY3Rpb24qIGNvbHVtbkl0ZXJhdG9yKFxuICBkYXRhQ29udGFpbmVyOiBEYXRhQ29udGFpbmVySW50ZXJmYWNlLFxuICBpbmRpY2VzOiBudW1iZXJbXSxcbiAgY29sdW1uSW5kZXg6IG51bWJlclxuKTogR2VuZXJhdG9yPGFueT4ge1xuICBjb25zdCBudW1Sb3dzID0gaW5kaWNlcy5sZW5ndGg7XG4gIGZvciAobGV0IHJvd0luZGV4ID0gMDsgcm93SW5kZXggPCBudW1Sb3dzOyArK3Jvd0luZGV4KSB7XG4gICAgY29uc3QgbWFwcGVkUm93SW5kZXggPSBpbmRpY2VzW3Jvd0luZGV4XTtcbiAgICB5aWVsZCBkYXRhQ29udGFpbmVyLnZhbHVlQXQobWFwcGVkUm93SW5kZXgsIGNvbHVtbkluZGV4KTtcbiAgfVxufVxuXG4vKipcbiAqIEEgZGF0YSBjb250YWluZXIgd3JhcHBlciBhcm91bmQgYW5vdGhlciBkYXRhIGNvbnRhaW5lci5cbiAqIFlvdSBoYXZlIHRvIHBhc3MgYW4gYXJyYXkgb2YgaW5kaWNlcyB0byByZWZlcmVuY2Ugcm93cyBpbiB0aGUgcGFyZW50IGRhdGEgY29udGFpbmVyLlxuICogRm9yIGV4YW1wbGUgaW5kaWNlcyBbMywgNCwgNiwgOF0gbWVhbnMgdGhhdCBJbmRleGVkRGF0YUNvbnRhaW5lciBpcyBnb2luZyB0byBoYXZlXG4gKiA0IHJvd3MgYW5kIHJvdygyKSBwb2ludHMgdG8gNnRoIHJvdyBpbiB0aGUgcmVmZXJlbmNlZCBkYXRhIGNvbnRhaW5lci5cbiAqL1xuZXhwb3J0IGNsYXNzIEluZGV4ZWREYXRhQ29udGFpbmVyIGltcGxlbWVudHMgRGF0YUNvbnRhaW5lckludGVyZmFjZSB7XG4gIF9wYXJlbnREYXRhQ29udGFpbmVyOiBEYXRhQ29udGFpbmVySW50ZXJmYWNlO1xuICBfaW5kaWNlczogbnVtYmVyW107XG5cbiAgY29uc3RydWN0b3IocGFyZW50RGF0YUNvbnRhaW5lcjogRGF0YUNvbnRhaW5lckludGVyZmFjZSwgaW5kaWNlczogbnVtYmVyW10pIHtcbiAgICB0aGlzLl9wYXJlbnREYXRhQ29udGFpbmVyID0gcGFyZW50RGF0YUNvbnRhaW5lcjtcbiAgICB0aGlzLl9pbmRpY2VzID0gaW5kaWNlcztcbiAgfVxuXG4gIG51bVJvd3MoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5faW5kaWNlcy5sZW5ndGg7XG4gIH1cblxuICBudW1Db2x1bW5zKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuX3BhcmVudERhdGFDb250YWluZXIubnVtQ29sdW1ucygpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbWFwcyBhIGxvY2FsIGluZGV4IHRvIGFuIGluZGV4IGluIHRoZSBwYXJlbnQgZGF0YXNldFxuICAgKiBAcGFyYW0gcm93SW5kZXhcbiAgICogQHJldHVybnMgbnVtYmVyXG4gICAqL1xuICBfbWFwcGVkUm93SW5kZXgocm93SW5kZXg6IG51bWJlcik6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuX2luZGljZXNbcm93SW5kZXhdO1xuICB9XG5cbiAgdmFsdWVBdChyb3dJbmRleDogbnVtYmVyLCBjb2x1bW5JbmRleDogbnVtYmVyKTogYW55IHtcbiAgICByZXR1cm4gdGhpcy5fcGFyZW50RGF0YUNvbnRhaW5lci52YWx1ZUF0KHRoaXMuX21hcHBlZFJvd0luZGV4KHJvd0luZGV4KSwgY29sdW1uSW5kZXgpO1xuICB9XG5cbiAgcm93KHJvd0luZGV4OiBudW1iZXIsIHNoYXJlZFJvdz86IFNoYXJlZFJvd09wdGlvbnMpOiBEYXRhUm93IHtcbiAgICByZXR1cm4gdGhpcy5fcGFyZW50RGF0YUNvbnRhaW5lci5yb3codGhpcy5fbWFwcGVkUm93SW5kZXgocm93SW5kZXgpLCBzaGFyZWRSb3cpO1xuICB9XG5cbiAgcm93QXNBcnJheShyb3dJbmRleDogbnVtYmVyKTogYW55W10ge1xuICAgIHJldHVybiB0aGlzLl9wYXJlbnREYXRhQ29udGFpbmVyLnJvd0FzQXJyYXkodGhpcy5fbWFwcGVkUm93SW5kZXgocm93SW5kZXgpKTtcbiAgfVxuXG4gIHJvd3Moc2hhcmVkUm93PzogU2hhcmVkUm93T3B0aW9ucykge1xuICAgIHJldHVybiByb3dzSXRlcmF0b3IodGhpcy5fcGFyZW50RGF0YUNvbnRhaW5lciwgdGhpcy5faW5kaWNlcywgc2hhcmVkUm93KTtcbiAgfVxuXG4gIGNvbHVtbihjb2x1bW5JbmRleDogbnVtYmVyKSB7XG4gICAgcmV0dXJuIGNvbHVtbkl0ZXJhdG9yKHRoaXMuX3BhcmVudERhdGFDb250YWluZXIsIHRoaXMuX2luZGljZXMsIGNvbHVtbkluZGV4KTtcbiAgfVxuXG4gIGdldFBsYWluSW5kZXgoKTogbnVtYmVyW10ge1xuICAgIHJldHVybiB0aGlzLl9pbmRpY2VzLm1hcCgoXywgaSkgPT4gaSk7XG4gIH1cblxuICBmbGF0dGVuRGF0YSgpOiBhbnlbXVtdIHtcbiAgICBjb25zdCB0U2hhcmVkUm93ID0gRGF0YVJvdy5jcmVhdGVTaGFyZWRSb3codHJ1ZSk7XG5cbiAgICByZXR1cm4gdGhpcy5faW5kaWNlcy5tYXAoKF8sIGkpID0+IHtcbiAgICAgIHJldHVybiB0aGlzLnJvdyhpLCB0U2hhcmVkUm93KS52YWx1ZXMoKTtcbiAgICB9LCB0aGlzKTtcbiAgfVxuXG4gIG1hcDxUPihcbiAgICBmdW5jOiAocm93OiBEYXRhUm93LCBpbmRleDogbnVtYmVyKSA9PiBULFxuICAgIHNoYXJlZFJvdz86IFNoYXJlZFJvd09wdGlvbnMsXG4gICAgb3B0aW9uczogUmFuZ2VPcHRpb25zID0ge31cbiAgKTogVFtdIHtcbiAgICBjb25zdCB7c3RhcnQgPSAwLCBlbmQgPSB0aGlzLm51bVJvd3MoKX0gPSBvcHRpb25zO1xuICAgIGNvbnN0IGVuZFJvdyA9IE1hdGgubWluKHRoaXMubnVtUm93cygpLCBlbmQpO1xuXG4gICAgY29uc3QgdFNoYXJlZFJvdyA9IERhdGFSb3cuY3JlYXRlU2hhcmVkUm93KHNoYXJlZFJvdyk7XG5cbiAgICBjb25zdCBvdXQ6IFRbXSA9IFtdO1xuICAgIGZvciAobGV0IHJvd0luZGV4ID0gc3RhcnQ7IHJvd0luZGV4IDwgZW5kUm93OyArK3Jvd0luZGV4KSB7XG4gICAgICBjb25zdCByb3cgPSB0aGlzLnJvdyhyb3dJbmRleCwgdFNoYXJlZFJvdyk7XG4gICAgICBvdXQucHVzaChmdW5jKHJvdywgcm93SW5kZXgpKTtcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbiAgfVxuXG4gIG1hcEluZGV4PFQ+KFxuICAgIGZ1bmM6ICh7aW5kZXg6IG51bWJlcn0sIGRjOiBEYXRhQ29udGFpbmVySW50ZXJmYWNlKSA9PiBULFxuICAgIG9wdGlvbnM6IFJhbmdlT3B0aW9ucyA9IHt9XG4gICk6IFRbXSB7XG4gICAgY29uc3Qge3N0YXJ0ID0gMCwgZW5kID0gdGhpcy5udW1Sb3dzKCl9ID0gb3B0aW9ucztcbiAgICBjb25zdCBlbmRSb3cgPSBNYXRoLm1pbih0aGlzLm51bVJvd3MoKSwgZW5kKTtcblxuICAgIGNvbnN0IG91dDogVFtdID0gW107XG4gICAgZm9yIChsZXQgcm93SW5kZXggPSBzdGFydDsgcm93SW5kZXggPCBlbmRSb3c7ICsrcm93SW5kZXgpIHtcbiAgICAgIG91dC5wdXNoKGZ1bmMoe2luZGV4OiB0aGlzLl9tYXBwZWRSb3dJbmRleChyb3dJbmRleCl9LCB0aGlzLl9wYXJlbnREYXRhQ29udGFpbmVyKSk7XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG4gIH1cblxuICBmaW5kKFxuICAgIGZ1bmM6IChyb3c6IERhdGFSb3csIGluZGV4OiBudW1iZXIpID0+IGJvb2xlYW4sXG4gICAgc2hhcmVkUm93PzogU2hhcmVkUm93T3B0aW9uc1xuICApOiBEYXRhUm93IHwgdW5kZWZpbmVkIHtcbiAgICBjb25zdCB0U2hhcmVkUm93ID0gRGF0YVJvdy5jcmVhdGVTaGFyZWRSb3coc2hhcmVkUm93KTtcblxuICAgIGZvciAobGV0IHJvd0luZGV4ID0gMDsgcm93SW5kZXggPCB0aGlzLm51bVJvd3MoKTsgKytyb3dJbmRleCkge1xuICAgICAgY29uc3Qgcm93ID0gdGhpcy5yb3cocm93SW5kZXgsIHRTaGFyZWRSb3cpO1xuICAgICAgaWYgKGZ1bmMocm93LCByb3dJbmRleCkpIHtcbiAgICAgICAgcmV0dXJuIHJvdztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIHJlZHVjZTxUPihcbiAgICBmdW5jOiAoYWNjOiBULCByb3c6IERhdGFSb3csIGluZGV4OiBudW1iZXIpID0+IFQsXG4gICAgaW5pdGlhbFZhbHVlOiBULFxuICAgIHNoYXJlZFJvdz86IFNoYXJlZFJvd09wdGlvbnNcbiAgKTogVCB7XG4gICAgY29uc3QgdFNoYXJlZFJvdyA9IERhdGFSb3cuY3JlYXRlU2hhcmVkUm93KHNoYXJlZFJvdyk7XG5cbiAgICBmb3IgKGxldCByb3dJbmRleCA9IDA7IHJvd0luZGV4IDwgdGhpcy5faW5kaWNlcy5sZW5ndGg7ICsrcm93SW5kZXgpIHtcbiAgICAgIGNvbnN0IHJvdyA9IHRoaXMucm93KHJvd0luZGV4LCB0U2hhcmVkUm93KTtcbiAgICAgIGluaXRpYWxWYWx1ZSA9IGZ1bmMoaW5pdGlhbFZhbHVlLCByb3csIHJvd0luZGV4KTtcbiAgICB9XG4gICAgcmV0dXJuIGluaXRpYWxWYWx1ZTtcbiAgfVxufVxuIl19