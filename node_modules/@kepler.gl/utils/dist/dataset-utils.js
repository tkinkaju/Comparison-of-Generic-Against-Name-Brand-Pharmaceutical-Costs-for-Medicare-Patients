// Copyright (c) 2022 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.findDefaultColorField = findDefaultColorField;
exports.validateInputData = validateInputData;
exports.getSampleForTypeAnalyze = getSampleForTypeAnalyze;
exports.getFieldsFromData = getFieldsFromData;
exports.renameDuplicateFields = renameDuplicateFields;
exports.analyzerTypeToFieldType = analyzerTypeToFieldType;
exports.ACCEPTED_ANALYZER_TYPES = exports.datasetColorMaker = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _window = require("global/window");

var _constants = require("@kepler.gl/constants");

var _typeAnalyzer = require("type-analyzer");

var _assert = _interopRequireDefault(require("assert"));

var _dataUtils = require("./data-utils");

var _d3Array = require("d3-array");

var _colorUtils = require("./color-utils");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var _marked = /*#__PURE__*/_regenerator["default"].mark(generateColor);

// apply a color for each dataset
// to use as label colors
var datasetColors = ['#8F2FBF', '#005CFF', '#C06C84', '#F8B195', '#547A82', '#3EACA8', '#A2D4AB'].map(_colorUtils.hexToRgb);
/**
 * Random color generator
 */

function generateColor() {
  var index;
  return _regenerator["default"].wrap(function generateColor$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          index = 0;

        case 1:
          if (!(index < datasetColors.length + 1)) {
            _context.next = 7;
            break;
          }

          if (index === datasetColors.length) {
            index = 0;
          }

          _context.next = 5;
          return datasetColors[index++];

        case 5:
          _context.next = 1;
          break;

        case 7:
        case "end":
          return _context.stop();
      }
    }
  }, _marked);
}

var datasetColorMaker = generateColor();
/**
 * Field name prefixes and suffixes which should not be considered
 * as metrics. Fields will still be included if a 'metric word'
 * is found on the field name, however.
 */

exports.datasetColorMaker = datasetColorMaker;
var EXCLUDED_DEFAULT_FIELDS = [// Serial numbers and identification numbers
'_id', 'id', 'index', 'uuid', 'guid', 'uid', 'gid', 'serial', // Geographic IDs are unlikely to be interesting to color
'zip', 'code', 'post', 'region', 'fips', 'cbgs', 'h3', 's2', // Geographic coords (but not z/elevation/altitude
// since that might be a metric)
'lat', 'lon', 'lng', 'latitude', 'longitude', '_x', '_y'];
/**
 * Prefixes and suffixes that indicate a field is a metric.
 *
 * Note that these are in order of preference, first being
 * most preferred.
 */

var METRIC_DEFAULT_FIELDS = ['metric', 'value', 'sum', 'count', 'unique', 'mean', 'mode', 'median', 'max', 'min', 'deviation', 'variance', 'p99', 'p95', 'p75', 'p50', 'p25', 'p05', // Abbreviations are less preferred
'cnt', 'val'];
/**
 * Choose a field to use as the default color field of a layer.
 *
 * The heuristic is:
 *
 * First, exclude fields that are on the exclusion list and don't
 * have names that suggest they contain metrics. Also exclude
 * field names that are blank.
 *
 * Next, look for a field that is of real type and contains one
 * of the preferred names (in order of the preferred names).
 *
 * Next, look for a field that is of integer type and contains
 * one of the preferred names (in order of the preferred names).
 *
 * Next, look for the first field that is of real type (in order
 * of field index).
 *
 * Next, look for the first field that is of integer type (in
 * order of field index).
 *
 * It's possible no field will be chosen (i.e. because all fields
 * are strings.)
 *
 * @param dataset
 */

function findDefaultColorField(_ref) {
  var fields = _ref.fields,
      _ref$fieldPairs = _ref.fieldPairs,
      fieldPairs = _ref$fieldPairs === void 0 ? [] : _ref$fieldPairs;
  var fieldsWithoutExcluded = fields.filter(function (field) {
    if (field.type !== _constants.ALL_FIELD_TYPES.real && field.type !== _constants.ALL_FIELD_TYPES.integer) {
      // Only select numeric fields.
      return false;
    }

    if (fieldPairs.find(function (pair) {
      return pair.pair.lat.value === field.name || pair.pair.lng.value === field.name;
    })) {
      // Do not permit lat, lon fields
      return false;
    }

    var normalizedFieldName = field.name.toLowerCase();

    if (normalizedFieldName === '') {
      // Special case excluded name when the name is blank.
      return false;
    }

    var hasExcluded = EXCLUDED_DEFAULT_FIELDS.find(function (f) {
      return normalizedFieldName.startsWith(f) || normalizedFieldName.endsWith(f);
    });
    var hasInclusion = METRIC_DEFAULT_FIELDS.find(function (f) {
      return normalizedFieldName.startsWith(f) || normalizedFieldName.endsWith(f);
    });
    return !hasExcluded || hasInclusion;
  });
  var sortedFields = fieldsWithoutExcluded.sort(function (left, right) {
    var normalizedLeft = left.name.toLowerCase();
    var normalizedRight = right.name.toLowerCase();
    var leftHasInclusion = METRIC_DEFAULT_FIELDS.findIndex(function (f) {
      return normalizedLeft.startsWith(f) || normalizedLeft.endsWith(f);
    });
    var rightHasInclusion = METRIC_DEFAULT_FIELDS.findIndex(function (f) {
      return normalizedRight.startsWith(f) || normalizedRight.endsWith(f);
    });

    if (leftHasInclusion !== rightHasInclusion) {
      if (leftHasInclusion === -1) {
        // Elements that do not have the inclusion list should go after those that do.
        return 1;
      } else if (rightHasInclusion === -1) {
        // Elements that do have the inclusion list should go before those that don't.
        return -1;
      } // Compare based on order in the inclusion list


      return leftHasInclusion - rightHasInclusion;
    } // Compare based on type


    if (left.type !== right.type) {
      if (left.type === _constants.ALL_FIELD_TYPES.real) {
        return -1;
      } // left is an integer and right is not
      // and reals come before integers


      return 1;
    } // Finally, order based on the order in the datasets columns
    // @ts-expect-error


    return left.index - right.index;
  });

  if (sortedFields.length) {
    // There was a best match
    return sortedFields[0];
  } // No matches


  return null;
}

var ACCEPTED_ANALYZER_TYPES = [_typeAnalyzer.DATA_TYPES.DATE, _typeAnalyzer.DATA_TYPES.TIME, _typeAnalyzer.DATA_TYPES.DATETIME, _typeAnalyzer.DATA_TYPES.NUMBER, _typeAnalyzer.DATA_TYPES.INT, _typeAnalyzer.DATA_TYPES.FLOAT, _typeAnalyzer.DATA_TYPES.BOOLEAN, _typeAnalyzer.DATA_TYPES.STRING, _typeAnalyzer.DATA_TYPES.GEOMETRY, _typeAnalyzer.DATA_TYPES.GEOMETRY_FROM_STRING, _typeAnalyzer.DATA_TYPES.PAIR_GEOMETRY_FROM_STRING, _typeAnalyzer.DATA_TYPES.ZIPCODE, _typeAnalyzer.DATA_TYPES.ARRAY, _typeAnalyzer.DATA_TYPES.OBJECT];
exports.ACCEPTED_ANALYZER_TYPES = ACCEPTED_ANALYZER_TYPES;
var IGNORE_DATA_TYPES = Object.keys(_typeAnalyzer.DATA_TYPES).filter(function (type) {
  return !ACCEPTED_ANALYZER_TYPES.includes(type);
});
/**
 * Validate input data, adding missing field types, rename duplicate columns
 */

function validateInputData(data) {
  if (!(0, _dataUtils.isPlainObject)(data)) {
    (0, _assert["default"])('addDataToMap Error: dataset.data cannot be null');
    return null;
  } else if (!Array.isArray(data.fields)) {
    (0, _assert["default"])('addDataToMap Error: expect dataset.data.fields to be an array');
    return null;
  } else if (!Array.isArray(data.rows)) {
    (0, _assert["default"])('addDataToMap Error: expect dataset.data.rows to be an array');
    return null;
  }

  var fields = data.fields,
      rows = data.rows; // check if all fields has name, format and type

  var allValid = fields.every(function (f, i) {
    if (!(0, _dataUtils.isPlainObject)(f)) {
      (0, _assert["default"])("fields needs to be an array of object, but find ".concat((0, _typeof2["default"])(f)));
      fields[i] = {};
    }

    if (!f.name) {
      (0, _assert["default"])("field.name is required but missing in ".concat(JSON.stringify(f))); // assign a name

      fields[i].name = "column_".concat(i);
    }

    if (!_constants.ALL_FIELD_TYPES[f.type]) {
      (0, _assert["default"])("unknown field type ".concat(f.type));
      return false;
    }

    if (!fields.every(function (field) {
      return field.analyzerType;
    })) {
      (0, _assert["default"])('field missing analyzerType');
      return false;
    } // check time format is correct based on first 10 not empty element


    if (f.type === _constants.ALL_FIELD_TYPES.timestamp) {
      var sample = findNonEmptyRowsAtField(rows, i, 10).map(function (r) {
        return {
          ts: r[i]
        };
      });

      var analyzedType = _typeAnalyzer.Analyzer.computeColMeta(sample)[0];

      return analyzedType && analyzedType.category === 'TIME' && analyzedType.format === f.format;
    }

    return true;
  });

  if (allValid) {
    return {
      rows: rows,
      fields: fields
    };
  } // if any field has missing type, recalculate it for everyone
  // because we simply lost faith in humanity


  var sampleData = getSampleForTypeAnalyze({
    fields: fields.map(function (f) {
      return f.name;
    }),
    rows: rows
  });
  var fieldOrder = fields.map(function (f) {
    return f.name;
  });
  var meta = getFieldsFromData(sampleData, fieldOrder);
  var updatedFields = fields.map(function (f, i) {
    return _objectSpread(_objectSpread({}, f), {}, {
      type: meta[i].type,
      format: meta[i].format,
      analyzerType: meta[i].analyzerType
    });
  });
  return {
    fields: updatedFields,
    rows: rows
  };
}

function findNonEmptyRowsAtField(rows, fieldIdx, total) {
  var sample = [];
  var i = 0;

  while (sample.length < total && i < rows.length) {
    var _rows$i;

    if ((0, _dataUtils.notNullorUndefined)((_rows$i = rows[i]) === null || _rows$i === void 0 ? void 0 : _rows$i[fieldIdx])) {
      sample.push(rows[i]);
    }

    i++;
  }

  return sample;
}
/**
 * Getting sample data for analyzing field type.
 */


function getSampleForTypeAnalyze(_ref2) {
  var fields = _ref2.fields,
      rows = _ref2.rows,
      _ref2$sampleCount = _ref2.sampleCount,
      sampleCount = _ref2$sampleCount === void 0 ? 50 : _ref2$sampleCount;
  var total = Math.min(sampleCount, rows.length); // const fieldOrder = fields.map(f => f.name);

  var sample = (0, _d3Array.range)(0, total, 1).map(function (d) {
    return {};
  }); // collect sample data for each field

  fields.forEach(function (field, fieldIdx) {
    // data counter
    var i = 0; // sample counter

    var j = 0;

    while (j < total) {
      if (i >= rows.length) {
        // if depleted data pool
        sample[j][field] = null;
        j++;
      } else if ((0, _dataUtils.notNullorUndefined)(rows[i][fieldIdx])) {
        var value = rows[i][fieldIdx];
        sample[j][field] = typeof value === 'string' ? value.trim() : value;
        j++;
        i++;
      } else {
        i++;
      }
    }
  });
  return sample;
}
/**
 * Analyze field types from data in `string` format, e.g. uploaded csv.
 * Assign `type`, `fieldIdx` and `format` (timestamp only) to each field
 *
 * @param data array of row object
 * @param fieldOrder array of field names as string
 * @returns formatted fields
 * @public
 * @example
 *
 * import {getFieldsFromData} from 'kepler.gl/processors';
 * const data = [{
 *   time: '2016-09-17 00:09:55',
 *   value: '4',
 *   surge: '1.2',
 *   isTrip: 'true',
 *   zeroOnes: '0'
 * }, {
 *   time: '2016-09-17 00:30:08',
 *   value: '3',
 *   surge: null,
 *   isTrip: 'false',
 *   zeroOnes: '1'
 * }, {
 *   time: null,
 *   value: '2',
 *   surge: '1.3',
 *   isTrip: null,
 *   zeroOnes: '1'
 * }];
 *
 * const fieldOrder = ['time', 'value', 'surge', 'isTrip', 'zeroOnes'];
 * const fields = getFieldsFromData(data, fieldOrder);
 * // fields = [
 * // {name: 'time', format: 'YYYY-M-D H:m:s', fieldIdx: 1, type: 'timestamp'},
 * // {name: 'value', format: '', fieldIdx: 4, type: 'integer'},
 * // {name: 'surge', format: '', fieldIdx: 5, type: 'real'},
 * // {name: 'isTrip', format: '', fieldIdx: 6, type: 'boolean'},
 * // {name: 'zeroOnes', format: '', fieldIdx: 7, type: 'integer'}];
 *
 */


function getFieldsFromData(data, fieldOrder) {
  // add a check for epoch timestamp
  var metadata = _typeAnalyzer.Analyzer.computeColMeta(data, [{
    regex: /.*geojson|all_points/g,
    dataType: 'GEOMETRY'
  }, {
    regex: /.*census/g,
    dataType: 'STRING'
  }], {
    ignoredDataTypes: IGNORE_DATA_TYPES
  });

  var _renameDuplicateField = renameDuplicateFields(fieldOrder),
      fieldByIndex = _renameDuplicateField.fieldByIndex;

  var result = fieldOrder.map(function (field, index) {
    var name = fieldByIndex[index];
    var fieldMeta = metadata.find(function (m) {
      return m.key === field;
    });

    var _ref3 = fieldMeta || {},
        type = _ref3.type,
        format = _ref3.format;

    return {
      name: name,
      id: name,
      displayName: name,
      format: format,
      fieldIdx: index,
      type: analyzerTypeToFieldType(type),
      analyzerType: type,
      valueAccessor: function valueAccessor(dc) {
        return function (d) {
          return dc.valueAt(d.index, index);
        };
      }
    };
  });
  return result;
}
/**
 * pass in an array of field names, rename duplicated one
 * and return a map from old field index to new name
 *
 * @param fieldOrder
 * @returns new field name by index
 */


function renameDuplicateFields(fieldOrder) {
  return fieldOrder.reduce(function (accu, field, i) {
    var allNames = accu.allNames;
    var fieldName = field; // add a counter to duplicated names

    if (allNames.includes(field)) {
      var counter = 0;

      while (allNames.includes("".concat(field, "-").concat(counter))) {
        counter++;
      }

      fieldName = "".concat(field, "-").concat(counter);
    }

    accu.fieldByIndex[i] = fieldName;
    accu.allNames.push(fieldName);
    return accu;
  }, {
    allNames: [],
    fieldByIndex: []
  });
}
/**
 * Convert type-analyzer output to kepler.gl field types
 *
 * @param aType
 * @returns corresponding type in `ALL_FIELD_TYPES`
 */

/* eslint-disable complexity */


function analyzerTypeToFieldType(aType) {
  var DATE = _typeAnalyzer.DATA_TYPES.DATE,
      TIME = _typeAnalyzer.DATA_TYPES.TIME,
      DATETIME = _typeAnalyzer.DATA_TYPES.DATETIME,
      NUMBER = _typeAnalyzer.DATA_TYPES.NUMBER,
      INT = _typeAnalyzer.DATA_TYPES.INT,
      FLOAT = _typeAnalyzer.DATA_TYPES.FLOAT,
      BOOLEAN = _typeAnalyzer.DATA_TYPES.BOOLEAN,
      STRING = _typeAnalyzer.DATA_TYPES.STRING,
      GEOMETRY = _typeAnalyzer.DATA_TYPES.GEOMETRY,
      GEOMETRY_FROM_STRING = _typeAnalyzer.DATA_TYPES.GEOMETRY_FROM_STRING,
      PAIR_GEOMETRY_FROM_STRING = _typeAnalyzer.DATA_TYPES.PAIR_GEOMETRY_FROM_STRING,
      ZIPCODE = _typeAnalyzer.DATA_TYPES.ZIPCODE,
      ARRAY = _typeAnalyzer.DATA_TYPES.ARRAY,
      OBJECT = _typeAnalyzer.DATA_TYPES.OBJECT; // TODO: un recognized types
  // CURRENCY PERCENT NONE

  switch (aType) {
    case DATE:
      return _constants.ALL_FIELD_TYPES.date;

    case TIME:
    case DATETIME:
      return _constants.ALL_FIELD_TYPES.timestamp;

    case FLOAT:
      return _constants.ALL_FIELD_TYPES.real;

    case INT:
      return _constants.ALL_FIELD_TYPES.integer;

    case BOOLEAN:
      return _constants.ALL_FIELD_TYPES["boolean"];

    case GEOMETRY:
    case GEOMETRY_FROM_STRING:
    case PAIR_GEOMETRY_FROM_STRING:
    case ARRAY:
    case OBJECT:
      // TODO: create a new data type for objects and arrays
      return _constants.ALL_FIELD_TYPES.geojson;

    case NUMBER:
    case STRING:
    case ZIPCODE:
      return _constants.ALL_FIELD_TYPES.string;

    default:
      _window.console.warn("Unsupported analyzer type: ".concat(aType));

      return _constants.ALL_FIELD_TYPES.string;
  }
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9kYXRhc2V0LXV0aWxzLnRzIl0sIm5hbWVzIjpbImdlbmVyYXRlQ29sb3IiLCJkYXRhc2V0Q29sb3JzIiwibWFwIiwiaGV4VG9SZ2IiLCJpbmRleCIsImxlbmd0aCIsImRhdGFzZXRDb2xvck1ha2VyIiwiRVhDTFVERURfREVGQVVMVF9GSUVMRFMiLCJNRVRSSUNfREVGQVVMVF9GSUVMRFMiLCJmaW5kRGVmYXVsdENvbG9yRmllbGQiLCJmaWVsZHMiLCJmaWVsZFBhaXJzIiwiZmllbGRzV2l0aG91dEV4Y2x1ZGVkIiwiZmlsdGVyIiwiZmllbGQiLCJ0eXBlIiwiQUxMX0ZJRUxEX1RZUEVTIiwicmVhbCIsImludGVnZXIiLCJmaW5kIiwicGFpciIsImxhdCIsInZhbHVlIiwibmFtZSIsImxuZyIsIm5vcm1hbGl6ZWRGaWVsZE5hbWUiLCJ0b0xvd2VyQ2FzZSIsImhhc0V4Y2x1ZGVkIiwiZiIsInN0YXJ0c1dpdGgiLCJlbmRzV2l0aCIsImhhc0luY2x1c2lvbiIsInNvcnRlZEZpZWxkcyIsInNvcnQiLCJsZWZ0IiwicmlnaHQiLCJub3JtYWxpemVkTGVmdCIsIm5vcm1hbGl6ZWRSaWdodCIsImxlZnRIYXNJbmNsdXNpb24iLCJmaW5kSW5kZXgiLCJyaWdodEhhc0luY2x1c2lvbiIsIkFDQ0VQVEVEX0FOQUxZWkVSX1RZUEVTIiwiQW5hbHl6ZXJEQVRBX1RZUEVTIiwiREFURSIsIlRJTUUiLCJEQVRFVElNRSIsIk5VTUJFUiIsIklOVCIsIkZMT0FUIiwiQk9PTEVBTiIsIlNUUklORyIsIkdFT01FVFJZIiwiR0VPTUVUUllfRlJPTV9TVFJJTkciLCJQQUlSX0dFT01FVFJZX0ZST01fU1RSSU5HIiwiWklQQ09ERSIsIkFSUkFZIiwiT0JKRUNUIiwiSUdOT1JFX0RBVEFfVFlQRVMiLCJPYmplY3QiLCJrZXlzIiwiaW5jbHVkZXMiLCJ2YWxpZGF0ZUlucHV0RGF0YSIsImRhdGEiLCJBcnJheSIsImlzQXJyYXkiLCJyb3dzIiwiYWxsVmFsaWQiLCJldmVyeSIsImkiLCJKU09OIiwic3RyaW5naWZ5IiwiYW5hbHl6ZXJUeXBlIiwidGltZXN0YW1wIiwic2FtcGxlIiwiZmluZE5vbkVtcHR5Um93c0F0RmllbGQiLCJyIiwidHMiLCJhbmFseXplZFR5cGUiLCJBbmFseXplciIsImNvbXB1dGVDb2xNZXRhIiwiY2F0ZWdvcnkiLCJmb3JtYXQiLCJzYW1wbGVEYXRhIiwiZ2V0U2FtcGxlRm9yVHlwZUFuYWx5emUiLCJmaWVsZE9yZGVyIiwibWV0YSIsImdldEZpZWxkc0Zyb21EYXRhIiwidXBkYXRlZEZpZWxkcyIsImZpZWxkSWR4IiwidG90YWwiLCJwdXNoIiwic2FtcGxlQ291bnQiLCJNYXRoIiwibWluIiwiZCIsImZvckVhY2giLCJqIiwidHJpbSIsIm1ldGFkYXRhIiwicmVnZXgiLCJkYXRhVHlwZSIsImlnbm9yZWREYXRhVHlwZXMiLCJyZW5hbWVEdXBsaWNhdGVGaWVsZHMiLCJmaWVsZEJ5SW5kZXgiLCJyZXN1bHQiLCJmaWVsZE1ldGEiLCJtIiwia2V5IiwiaWQiLCJkaXNwbGF5TmFtZSIsImFuYWx5emVyVHlwZVRvRmllbGRUeXBlIiwidmFsdWVBY2Nlc3NvciIsImRjIiwidmFsdWVBdCIsInJlZHVjZSIsImFjY3UiLCJhbGxOYW1lcyIsImZpZWxkTmFtZSIsImNvdW50ZXIiLCJhVHlwZSIsImRhdGUiLCJnZW9qc29uIiwic3RyaW5nIiwiZ2xvYmFsQ29uc29sZSIsIndhcm4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW9CQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFJQTs7QUFDQTs7QUFDQTs7Ozs7O3dEQWlCVUEsYTs7QUFmVjtBQUNBO0FBQ0EsSUFBTUMsYUFBYSxHQUFHLENBQ3BCLFNBRG9CLEVBRXBCLFNBRm9CLEVBR3BCLFNBSG9CLEVBSXBCLFNBSm9CLEVBS3BCLFNBTG9CLEVBTXBCLFNBTm9CLEVBT3BCLFNBUG9CLEVBUXBCQyxHQVJvQixDQVFoQkMsb0JBUmdCLENBQXRCO0FBVUE7QUFDQTtBQUNBOztBQUNBLFNBQVVILGFBQVY7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ01JLFVBQUFBLEtBRE4sR0FDYyxDQURkOztBQUFBO0FBQUEsZ0JBRVNBLEtBQUssR0FBR0gsYUFBYSxDQUFDSSxNQUFkLEdBQXVCLENBRnhDO0FBQUE7QUFBQTtBQUFBOztBQUdJLGNBQUlELEtBQUssS0FBS0gsYUFBYSxDQUFDSSxNQUE1QixFQUFvQztBQUNsQ0QsWUFBQUEsS0FBSyxHQUFHLENBQVI7QUFDRDs7QUFMTDtBQU1JLGlCQUFNSCxhQUFhLENBQUNHLEtBQUssRUFBTixDQUFuQjs7QUFOSjtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBVU8sSUFBTUUsaUJBQWlCLEdBQUdOLGFBQWEsRUFBdkM7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxJQUFNTyx1QkFBdUIsR0FBRyxDQUM5QjtBQUNBLEtBRjhCLEVBRzlCLElBSDhCLEVBSTlCLE9BSjhCLEVBSzlCLE1BTDhCLEVBTTlCLE1BTjhCLEVBTzlCLEtBUDhCLEVBUTlCLEtBUjhCLEVBUzlCLFFBVDhCLEVBVTlCO0FBQ0EsS0FYOEIsRUFZOUIsTUFaOEIsRUFhOUIsTUFiOEIsRUFjOUIsUUFkOEIsRUFlOUIsTUFmOEIsRUFnQjlCLE1BaEI4QixFQWlCOUIsSUFqQjhCLEVBa0I5QixJQWxCOEIsRUFtQjlCO0FBQ0E7QUFDQSxLQXJCOEIsRUFzQjlCLEtBdEI4QixFQXVCOUIsS0F2QjhCLEVBd0I5QixVQXhCOEIsRUF5QjlCLFdBekI4QixFQTBCOUIsSUExQjhCLEVBMkI5QixJQTNCOEIsQ0FBaEM7QUE4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBLElBQU1DLHFCQUFxQixHQUFHLENBQzVCLFFBRDRCLEVBRTVCLE9BRjRCLEVBRzVCLEtBSDRCLEVBSTVCLE9BSjRCLEVBSzVCLFFBTDRCLEVBTTVCLE1BTjRCLEVBTzVCLE1BUDRCLEVBUTVCLFFBUjRCLEVBUzVCLEtBVDRCLEVBVTVCLEtBVjRCLEVBVzVCLFdBWDRCLEVBWTVCLFVBWjRCLEVBYTVCLEtBYjRCLEVBYzVCLEtBZDRCLEVBZTVCLEtBZjRCLEVBZ0I1QixLQWhCNEIsRUFpQjVCLEtBakI0QixFQWtCNUIsS0FsQjRCLEVBbUI1QjtBQUNBLEtBcEI0QixFQXFCNUIsS0FyQjRCLENBQTlCO0FBd0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ08sU0FBU0MscUJBQVQsT0FNVTtBQUFBLE1BTGZDLE1BS2UsUUFMZkEsTUFLZTtBQUFBLDZCQUpmQyxVQUllO0FBQUEsTUFKZkEsVUFJZSxnQ0FKRixFQUlFO0FBQ2YsTUFBTUMscUJBQXFCLEdBQUdGLE1BQU0sQ0FBQ0csTUFBUCxDQUFjLFVBQUFDLEtBQUssRUFBSTtBQUNuRCxRQUFJQSxLQUFLLENBQUNDLElBQU4sS0FBZUMsMkJBQWdCQyxJQUEvQixJQUF1Q0gsS0FBSyxDQUFDQyxJQUFOLEtBQWVDLDJCQUFnQkUsT0FBMUUsRUFBbUY7QUFDakY7QUFDQSxhQUFPLEtBQVA7QUFDRDs7QUFDRCxRQUNFUCxVQUFVLENBQUNRLElBQVgsQ0FDRSxVQUFBQyxJQUFJO0FBQUEsYUFBSUEsSUFBSSxDQUFDQSxJQUFMLENBQVVDLEdBQVYsQ0FBY0MsS0FBZCxLQUF3QlIsS0FBSyxDQUFDUyxJQUE5QixJQUFzQ0gsSUFBSSxDQUFDQSxJQUFMLENBQVVJLEdBQVYsQ0FBY0YsS0FBZCxLQUF3QlIsS0FBSyxDQUFDUyxJQUF4RTtBQUFBLEtBRE4sQ0FERixFQUlFO0FBQ0E7QUFDQSxhQUFPLEtBQVA7QUFDRDs7QUFFRCxRQUFNRSxtQkFBbUIsR0FBR1gsS0FBSyxDQUFDUyxJQUFOLENBQVdHLFdBQVgsRUFBNUI7O0FBQ0EsUUFBSUQsbUJBQW1CLEtBQUssRUFBNUIsRUFBZ0M7QUFDOUI7QUFDQSxhQUFPLEtBQVA7QUFDRDs7QUFDRCxRQUFNRSxXQUFXLEdBQUdwQix1QkFBdUIsQ0FBQ1ksSUFBeEIsQ0FDbEIsVUFBQVMsQ0FBQztBQUFBLGFBQUlILG1CQUFtQixDQUFDSSxVQUFwQixDQUErQkQsQ0FBL0IsS0FBcUNILG1CQUFtQixDQUFDSyxRQUFwQixDQUE2QkYsQ0FBN0IsQ0FBekM7QUFBQSxLQURpQixDQUFwQjtBQUdBLFFBQU1HLFlBQVksR0FBR3ZCLHFCQUFxQixDQUFDVyxJQUF0QixDQUNuQixVQUFBUyxDQUFDO0FBQUEsYUFBSUgsbUJBQW1CLENBQUNJLFVBQXBCLENBQStCRCxDQUEvQixLQUFxQ0gsbUJBQW1CLENBQUNLLFFBQXBCLENBQTZCRixDQUE3QixDQUF6QztBQUFBLEtBRGtCLENBQXJCO0FBR0EsV0FBTyxDQUFDRCxXQUFELElBQWdCSSxZQUF2QjtBQUNELEdBMUI2QixDQUE5QjtBQTRCQSxNQUFNQyxZQUFZLEdBQUdwQixxQkFBcUIsQ0FBQ3FCLElBQXRCLENBQTJCLFVBQUNDLElBQUQsRUFBT0MsS0FBUCxFQUFpQjtBQUMvRCxRQUFNQyxjQUFjLEdBQUdGLElBQUksQ0FBQ1gsSUFBTCxDQUFVRyxXQUFWLEVBQXZCO0FBQ0EsUUFBTVcsZUFBZSxHQUFHRixLQUFLLENBQUNaLElBQU4sQ0FBV0csV0FBWCxFQUF4QjtBQUNBLFFBQU1ZLGdCQUFnQixHQUFHOUIscUJBQXFCLENBQUMrQixTQUF0QixDQUN2QixVQUFBWCxDQUFDO0FBQUEsYUFBSVEsY0FBYyxDQUFDUCxVQUFmLENBQTBCRCxDQUExQixLQUFnQ1EsY0FBYyxDQUFDTixRQUFmLENBQXdCRixDQUF4QixDQUFwQztBQUFBLEtBRHNCLENBQXpCO0FBR0EsUUFBTVksaUJBQWlCLEdBQUdoQyxxQkFBcUIsQ0FBQytCLFNBQXRCLENBQ3hCLFVBQUFYLENBQUM7QUFBQSxhQUFJUyxlQUFlLENBQUNSLFVBQWhCLENBQTJCRCxDQUEzQixLQUFpQ1MsZUFBZSxDQUFDUCxRQUFoQixDQUF5QkYsQ0FBekIsQ0FBckM7QUFBQSxLQUR1QixDQUExQjs7QUFHQSxRQUFJVSxnQkFBZ0IsS0FBS0UsaUJBQXpCLEVBQTRDO0FBQzFDLFVBQUlGLGdCQUFnQixLQUFLLENBQUMsQ0FBMUIsRUFBNkI7QUFDM0I7QUFDQSxlQUFPLENBQVA7QUFDRCxPQUhELE1BR08sSUFBSUUsaUJBQWlCLEtBQUssQ0FBQyxDQUEzQixFQUE4QjtBQUNuQztBQUNBLGVBQU8sQ0FBQyxDQUFSO0FBQ0QsT0FQeUMsQ0FRMUM7OztBQUNBLGFBQU9GLGdCQUFnQixHQUFHRSxpQkFBMUI7QUFDRCxLQW5COEQsQ0FxQi9EOzs7QUFDQSxRQUFJTixJQUFJLENBQUNuQixJQUFMLEtBQWNvQixLQUFLLENBQUNwQixJQUF4QixFQUE4QjtBQUM1QixVQUFJbUIsSUFBSSxDQUFDbkIsSUFBTCxLQUFjQywyQkFBZ0JDLElBQWxDLEVBQXdDO0FBQ3RDLGVBQU8sQ0FBQyxDQUFSO0FBQ0QsT0FIMkIsQ0FJNUI7QUFDQTs7O0FBQ0EsYUFBTyxDQUFQO0FBQ0QsS0E3QjhELENBK0IvRDtBQUNBOzs7QUFDQSxXQUFPaUIsSUFBSSxDQUFDOUIsS0FBTCxHQUFhK0IsS0FBSyxDQUFDL0IsS0FBMUI7QUFDRCxHQWxDb0IsQ0FBckI7O0FBb0NBLE1BQUk0QixZQUFZLENBQUMzQixNQUFqQixFQUF5QjtBQUN2QjtBQUNBLFdBQU8yQixZQUFZLENBQUMsQ0FBRCxDQUFuQjtBQUNELEdBcEVjLENBcUVmOzs7QUFDQSxTQUFPLElBQVA7QUFDRDs7QUFFTSxJQUFNUyx1QkFBdUIsR0FBRyxDQUNyQ0MseUJBQW1CQyxJQURrQixFQUVyQ0QseUJBQW1CRSxJQUZrQixFQUdyQ0YseUJBQW1CRyxRQUhrQixFQUlyQ0gseUJBQW1CSSxNQUprQixFQUtyQ0oseUJBQW1CSyxHQUxrQixFQU1yQ0wseUJBQW1CTSxLQU5rQixFQU9yQ04seUJBQW1CTyxPQVBrQixFQVFyQ1AseUJBQW1CUSxNQVJrQixFQVNyQ1IseUJBQW1CUyxRQVRrQixFQVVyQ1QseUJBQW1CVSxvQkFWa0IsRUFXckNWLHlCQUFtQlcseUJBWGtCLEVBWXJDWCx5QkFBbUJZLE9BWmtCLEVBYXJDWix5QkFBbUJhLEtBYmtCLEVBY3JDYix5QkFBbUJjLE1BZGtCLENBQWhDOztBQWlCUCxJQUFNQyxpQkFBaUIsR0FBR0MsTUFBTSxDQUFDQyxJQUFQLENBQVlqQix3QkFBWixFQUFnQzdCLE1BQWhDLENBQ3hCLFVBQUFFLElBQUk7QUFBQSxTQUFJLENBQUMwQix1QkFBdUIsQ0FBQ21CLFFBQXhCLENBQWlDN0MsSUFBakMsQ0FBTDtBQUFBLENBRG9CLENBQTFCO0FBSUE7QUFDQTtBQUNBOztBQUNPLFNBQVM4QyxpQkFBVCxDQUEyQkMsSUFBM0IsRUFBMkU7QUFDaEYsTUFBSSxDQUFDLDhCQUFjQSxJQUFkLENBQUwsRUFBMEI7QUFDeEIsNEJBQU8saURBQVA7QUFDQSxXQUFPLElBQVA7QUFDRCxHQUhELE1BR08sSUFBSSxDQUFDQyxLQUFLLENBQUNDLE9BQU4sQ0FBY0YsSUFBSSxDQUFDcEQsTUFBbkIsQ0FBTCxFQUFpQztBQUN0Qyw0QkFBTywrREFBUDtBQUNBLFdBQU8sSUFBUDtBQUNELEdBSE0sTUFHQSxJQUFJLENBQUNxRCxLQUFLLENBQUNDLE9BQU4sQ0FBY0YsSUFBSSxDQUFDRyxJQUFuQixDQUFMLEVBQStCO0FBQ3BDLDRCQUFPLDZEQUFQO0FBQ0EsV0FBTyxJQUFQO0FBQ0Q7O0FBVitFLE1BWXpFdkQsTUFaeUUsR0FZekRvRCxJQVp5RCxDQVl6RXBELE1BWnlFO0FBQUEsTUFZakV1RCxJQVppRSxHQVl6REgsSUFaeUQsQ0FZakVHLElBWmlFLEVBY2hGOztBQUNBLE1BQU1DLFFBQVEsR0FBR3hELE1BQU0sQ0FBQ3lELEtBQVAsQ0FBYSxVQUFDdkMsQ0FBRCxFQUFJd0MsQ0FBSixFQUFVO0FBQ3RDLFFBQUksQ0FBQyw4QkFBY3hDLENBQWQsQ0FBTCxFQUF1QjtBQUNyQixpSEFBaUVBLENBQWpFO0FBQ0FsQixNQUFBQSxNQUFNLENBQUMwRCxDQUFELENBQU4sR0FBWSxFQUFaO0FBQ0Q7O0FBRUQsUUFBSSxDQUFDeEMsQ0FBQyxDQUFDTCxJQUFQLEVBQWE7QUFDWCw4RUFBZ0Q4QyxJQUFJLENBQUNDLFNBQUwsQ0FBZTFDLENBQWYsQ0FBaEQsR0FEVyxDQUVYOztBQUNBbEIsTUFBQUEsTUFBTSxDQUFDMEQsQ0FBRCxDQUFOLENBQVU3QyxJQUFWLG9CQUEyQjZDLENBQTNCO0FBQ0Q7O0FBRUQsUUFBSSxDQUFDcEQsMkJBQWdCWSxDQUFDLENBQUNiLElBQWxCLENBQUwsRUFBOEI7QUFDNUIsMkRBQTZCYSxDQUFDLENBQUNiLElBQS9CO0FBQ0EsYUFBTyxLQUFQO0FBQ0Q7O0FBRUQsUUFBSSxDQUFDTCxNQUFNLENBQUN5RCxLQUFQLENBQWEsVUFBQXJELEtBQUs7QUFBQSxhQUFJQSxLQUFLLENBQUN5RCxZQUFWO0FBQUEsS0FBbEIsQ0FBTCxFQUFnRDtBQUM5Qyw4QkFBTyw0QkFBUDtBQUNBLGFBQU8sS0FBUDtBQUNELEtBcEJxQyxDQXNCdEM7OztBQUNBLFFBQUkzQyxDQUFDLENBQUNiLElBQUYsS0FBV0MsMkJBQWdCd0QsU0FBL0IsRUFBMEM7QUFDeEMsVUFBTUMsTUFBTSxHQUFHQyx1QkFBdUIsQ0FBQ1QsSUFBRCxFQUFPRyxDQUFQLEVBQVUsRUFBVixDQUF2QixDQUFxQ2xFLEdBQXJDLENBQXlDLFVBQUF5RSxDQUFDO0FBQUEsZUFBSztBQUFDQyxVQUFBQSxFQUFFLEVBQUVELENBQUMsQ0FBQ1AsQ0FBRDtBQUFOLFNBQUw7QUFBQSxPQUExQyxDQUFmOztBQUNBLFVBQU1TLFlBQVksR0FBR0MsdUJBQVNDLGNBQVQsQ0FBd0JOLE1BQXhCLEVBQWdDLENBQWhDLENBQXJCOztBQUNBLGFBQU9JLFlBQVksSUFBSUEsWUFBWSxDQUFDRyxRQUFiLEtBQTBCLE1BQTFDLElBQW9ESCxZQUFZLENBQUNJLE1BQWIsS0FBd0JyRCxDQUFDLENBQUNxRCxNQUFyRjtBQUNEOztBQUVELFdBQU8sSUFBUDtBQUNELEdBOUJnQixDQUFqQjs7QUFnQ0EsTUFBSWYsUUFBSixFQUFjO0FBQ1osV0FBTztBQUFDRCxNQUFBQSxJQUFJLEVBQUpBLElBQUQ7QUFBT3ZELE1BQUFBLE1BQU0sRUFBTkE7QUFBUCxLQUFQO0FBQ0QsR0FqRCtFLENBbURoRjtBQUNBOzs7QUFDQSxNQUFNd0UsVUFBVSxHQUFHQyx1QkFBdUIsQ0FBQztBQUN6Q3pFLElBQUFBLE1BQU0sRUFBRUEsTUFBTSxDQUFDUixHQUFQLENBQVcsVUFBQTBCLENBQUM7QUFBQSxhQUFJQSxDQUFDLENBQUNMLElBQU47QUFBQSxLQUFaLENBRGlDO0FBRXpDMEMsSUFBQUEsSUFBSSxFQUFKQTtBQUZ5QyxHQUFELENBQTFDO0FBSUEsTUFBTW1CLFVBQVUsR0FBRzFFLE1BQU0sQ0FBQ1IsR0FBUCxDQUFXLFVBQUEwQixDQUFDO0FBQUEsV0FBSUEsQ0FBQyxDQUFDTCxJQUFOO0FBQUEsR0FBWixDQUFuQjtBQUNBLE1BQU04RCxJQUFJLEdBQUdDLGlCQUFpQixDQUFDSixVQUFELEVBQWFFLFVBQWIsQ0FBOUI7QUFDQSxNQUFNRyxhQUFhLEdBQUc3RSxNQUFNLENBQUNSLEdBQVAsQ0FBVyxVQUFDMEIsQ0FBRCxFQUFJd0MsQ0FBSjtBQUFBLDJDQUM1QnhDLENBRDRCO0FBRS9CYixNQUFBQSxJQUFJLEVBQUVzRSxJQUFJLENBQUNqQixDQUFELENBQUosQ0FBUXJELElBRmlCO0FBRy9Ca0UsTUFBQUEsTUFBTSxFQUFFSSxJQUFJLENBQUNqQixDQUFELENBQUosQ0FBUWEsTUFIZTtBQUkvQlYsTUFBQUEsWUFBWSxFQUFFYyxJQUFJLENBQUNqQixDQUFELENBQUosQ0FBUUc7QUFKUztBQUFBLEdBQVgsQ0FBdEI7QUFPQSxTQUFPO0FBQUM3RCxJQUFBQSxNQUFNLEVBQUU2RSxhQUFUO0FBQXdCdEIsSUFBQUEsSUFBSSxFQUFKQTtBQUF4QixHQUFQO0FBQ0Q7O0FBRUQsU0FBU1MsdUJBQVQsQ0FBaUNULElBQWpDLEVBQW9EdUIsUUFBcEQsRUFBc0VDLEtBQXRFLEVBQTRGO0FBQzFGLE1BQU1oQixNQUFhLEdBQUcsRUFBdEI7QUFDQSxNQUFJTCxDQUFDLEdBQUcsQ0FBUjs7QUFDQSxTQUFPSyxNQUFNLENBQUNwRSxNQUFQLEdBQWdCb0YsS0FBaEIsSUFBeUJyQixDQUFDLEdBQUdILElBQUksQ0FBQzVELE1BQXpDLEVBQWlEO0FBQUE7O0FBQy9DLFFBQUksOENBQW1CNEQsSUFBSSxDQUFDRyxDQUFELENBQXZCLDRDQUFtQixRQUFVb0IsUUFBVixDQUFuQixDQUFKLEVBQTZDO0FBQzNDZixNQUFBQSxNQUFNLENBQUNpQixJQUFQLENBQVl6QixJQUFJLENBQUNHLENBQUQsQ0FBaEI7QUFDRDs7QUFDREEsSUFBQUEsQ0FBQztBQUNGOztBQUNELFNBQU9LLE1BQVA7QUFDRDtBQUNEO0FBQ0E7QUFDQTs7O0FBQ08sU0FBU1UsdUJBQVQsUUFRSztBQUFBLE1BUFZ6RSxNQU9VLFNBUFZBLE1BT1U7QUFBQSxNQU5WdUQsSUFNVSxTQU5WQSxJQU1VO0FBQUEsZ0NBTFYwQixXQUtVO0FBQUEsTUFMVkEsV0FLVSxrQ0FMSSxFQUtKO0FBQ1YsTUFBTUYsS0FBSyxHQUFHRyxJQUFJLENBQUNDLEdBQUwsQ0FBU0YsV0FBVCxFQUFzQjFCLElBQUksQ0FBQzVELE1BQTNCLENBQWQsQ0FEVSxDQUVWOztBQUNBLE1BQU1vRSxNQUFNLEdBQUcsb0JBQU0sQ0FBTixFQUFTZ0IsS0FBVCxFQUFnQixDQUFoQixFQUFtQnZGLEdBQW5CLENBQXVCLFVBQUE0RixDQUFDO0FBQUEsV0FBSyxFQUFMO0FBQUEsR0FBeEIsQ0FBZixDQUhVLENBS1Y7O0FBQ0FwRixFQUFBQSxNQUFNLENBQUNxRixPQUFQLENBQWUsVUFBQ2pGLEtBQUQsRUFBUTBFLFFBQVIsRUFBcUI7QUFDbEM7QUFDQSxRQUFJcEIsQ0FBQyxHQUFHLENBQVIsQ0FGa0MsQ0FHbEM7O0FBQ0EsUUFBSTRCLENBQUMsR0FBRyxDQUFSOztBQUVBLFdBQU9BLENBQUMsR0FBR1AsS0FBWCxFQUFrQjtBQUNoQixVQUFJckIsQ0FBQyxJQUFJSCxJQUFJLENBQUM1RCxNQUFkLEVBQXNCO0FBQ3BCO0FBQ0FvRSxRQUFBQSxNQUFNLENBQUN1QixDQUFELENBQU4sQ0FBVWxGLEtBQVYsSUFBbUIsSUFBbkI7QUFDQWtGLFFBQUFBLENBQUM7QUFDRixPQUpELE1BSU8sSUFBSSxtQ0FBbUIvQixJQUFJLENBQUNHLENBQUQsQ0FBSixDQUFRb0IsUUFBUixDQUFuQixDQUFKLEVBQTJDO0FBQ2hELFlBQU1sRSxLQUFLLEdBQUcyQyxJQUFJLENBQUNHLENBQUQsQ0FBSixDQUFRb0IsUUFBUixDQUFkO0FBQ0FmLFFBQUFBLE1BQU0sQ0FBQ3VCLENBQUQsQ0FBTixDQUFVbEYsS0FBVixJQUFtQixPQUFPUSxLQUFQLEtBQWlCLFFBQWpCLEdBQTRCQSxLQUFLLENBQUMyRSxJQUFOLEVBQTVCLEdBQTJDM0UsS0FBOUQ7QUFDQTBFLFFBQUFBLENBQUM7QUFDRDVCLFFBQUFBLENBQUM7QUFDRixPQUxNLE1BS0E7QUFDTEEsUUFBQUEsQ0FBQztBQUNGO0FBQ0Y7QUFDRixHQXBCRDtBQXNCQSxTQUFPSyxNQUFQO0FBQ0Q7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDTyxTQUFTYSxpQkFBVCxDQUEyQnhCLElBQTNCLEVBQTBDc0IsVUFBMUMsRUFBeUU7QUFDOUU7QUFDQSxNQUFNYyxRQUFRLEdBQUdwQix1QkFBU0MsY0FBVCxDQUNmakIsSUFEZSxFQUVmLENBQ0U7QUFBQ3FDLElBQUFBLEtBQUssRUFBRSx1QkFBUjtBQUFpQ0MsSUFBQUEsUUFBUSxFQUFFO0FBQTNDLEdBREYsRUFFRTtBQUFDRCxJQUFBQSxLQUFLLEVBQUUsV0FBUjtBQUFxQkMsSUFBQUEsUUFBUSxFQUFFO0FBQS9CLEdBRkYsQ0FGZSxFQU1mO0FBQUNDLElBQUFBLGdCQUFnQixFQUFFNUM7QUFBbkIsR0FOZSxDQUFqQjs7QUFGOEUsOEJBV3ZENkMscUJBQXFCLENBQUNsQixVQUFELENBWGtDO0FBQUEsTUFXdkVtQixZQVh1RSx5QkFXdkVBLFlBWHVFOztBQWE5RSxNQUFNQyxNQUFNLEdBQUdwQixVQUFVLENBQUNsRixHQUFYLENBQWUsVUFBQ1ksS0FBRCxFQUFRVixLQUFSLEVBQWtCO0FBQzlDLFFBQU1tQixJQUFJLEdBQUdnRixZQUFZLENBQUNuRyxLQUFELENBQXpCO0FBRUEsUUFBTXFHLFNBQVMsR0FBR1AsUUFBUSxDQUFDL0UsSUFBVCxDQUFjLFVBQUF1RixDQUFDO0FBQUEsYUFBSUEsQ0FBQyxDQUFDQyxHQUFGLEtBQVU3RixLQUFkO0FBQUEsS0FBZixDQUFsQjs7QUFIOEMsZ0JBSXZCMkYsU0FBUyxJQUFJLEVBSlU7QUFBQSxRQUl2QzFGLElBSnVDLFNBSXZDQSxJQUp1QztBQUFBLFFBSWpDa0UsTUFKaUMsU0FJakNBLE1BSmlDOztBQU05QyxXQUFPO0FBQ0wxRCxNQUFBQSxJQUFJLEVBQUpBLElBREs7QUFFTHFGLE1BQUFBLEVBQUUsRUFBRXJGLElBRkM7QUFHTHNGLE1BQUFBLFdBQVcsRUFBRXRGLElBSFI7QUFJTDBELE1BQUFBLE1BQU0sRUFBTkEsTUFKSztBQUtMTyxNQUFBQSxRQUFRLEVBQUVwRixLQUxMO0FBTUxXLE1BQUFBLElBQUksRUFBRStGLHVCQUF1QixDQUFDL0YsSUFBRCxDQU54QjtBQU9Md0QsTUFBQUEsWUFBWSxFQUFFeEQsSUFQVDtBQVFMZ0csTUFBQUEsYUFBYSxFQUFFLHVCQUFBQyxFQUFFO0FBQUEsZUFBSSxVQUFBbEIsQ0FBQyxFQUFJO0FBQ3hCLGlCQUFPa0IsRUFBRSxDQUFDQyxPQUFILENBQVduQixDQUFDLENBQUMxRixLQUFiLEVBQW9CQSxLQUFwQixDQUFQO0FBQ0QsU0FGZ0I7QUFBQTtBQVJaLEtBQVA7QUFZRCxHQWxCYyxDQUFmO0FBb0JBLFNBQU9vRyxNQUFQO0FBQ0Q7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ08sU0FBU0YscUJBQVQsQ0FDTGxCLFVBREssRUFFeUM7QUFDOUMsU0FBT0EsVUFBVSxDQUFDOEIsTUFBWCxDQUNMLFVBQUNDLElBQUQsRUFBT3JHLEtBQVAsRUFBY3NELENBQWQsRUFBb0I7QUFBQSxRQUNYZ0QsUUFEVyxHQUNDRCxJQURELENBQ1hDLFFBRFc7QUFFbEIsUUFBSUMsU0FBUyxHQUFHdkcsS0FBaEIsQ0FGa0IsQ0FJbEI7O0FBQ0EsUUFBSXNHLFFBQVEsQ0FBQ3hELFFBQVQsQ0FBa0I5QyxLQUFsQixDQUFKLEVBQThCO0FBQzVCLFVBQUl3RyxPQUFPLEdBQUcsQ0FBZDs7QUFDQSxhQUFPRixRQUFRLENBQUN4RCxRQUFULFdBQXFCOUMsS0FBckIsY0FBOEJ3RyxPQUE5QixFQUFQLEVBQWlEO0FBQy9DQSxRQUFBQSxPQUFPO0FBQ1I7O0FBQ0RELE1BQUFBLFNBQVMsYUFBTXZHLEtBQU4sY0FBZXdHLE9BQWYsQ0FBVDtBQUNEOztBQUVESCxJQUFBQSxJQUFJLENBQUNaLFlBQUwsQ0FBa0JuQyxDQUFsQixJQUF1QmlELFNBQXZCO0FBQ0FGLElBQUFBLElBQUksQ0FBQ0MsUUFBTCxDQUFjMUIsSUFBZCxDQUFtQjJCLFNBQW5CO0FBRUEsV0FBT0YsSUFBUDtBQUNELEdBbEJJLEVBbUJMO0FBQUNDLElBQUFBLFFBQVEsRUFBRSxFQUFYO0FBQWViLElBQUFBLFlBQVksRUFBRTtBQUE3QixHQW5CSyxDQUFQO0FBcUJEO0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBOzs7QUFDTyxTQUFTTyx1QkFBVCxDQUFpQ1MsS0FBakMsRUFBd0Q7QUFBQSxNQUUzRDVFLElBRjJELEdBZ0J6REQsd0JBaEJ5RCxDQUUzREMsSUFGMkQ7QUFBQSxNQUczREMsSUFIMkQsR0FnQnpERix3QkFoQnlELENBRzNERSxJQUgyRDtBQUFBLE1BSTNEQyxRQUoyRCxHQWdCekRILHdCQWhCeUQsQ0FJM0RHLFFBSjJEO0FBQUEsTUFLM0RDLE1BTDJELEdBZ0J6REosd0JBaEJ5RCxDQUszREksTUFMMkQ7QUFBQSxNQU0zREMsR0FOMkQsR0FnQnpETCx3QkFoQnlELENBTTNESyxHQU4yRDtBQUFBLE1BTzNEQyxLQVAyRCxHQWdCekROLHdCQWhCeUQsQ0FPM0RNLEtBUDJEO0FBQUEsTUFRM0RDLE9BUjJELEdBZ0J6RFAsd0JBaEJ5RCxDQVEzRE8sT0FSMkQ7QUFBQSxNQVMzREMsTUFUMkQsR0FnQnpEUix3QkFoQnlELENBUzNEUSxNQVQyRDtBQUFBLE1BVTNEQyxRQVYyRCxHQWdCekRULHdCQWhCeUQsQ0FVM0RTLFFBVjJEO0FBQUEsTUFXM0RDLG9CQVgyRCxHQWdCekRWLHdCQWhCeUQsQ0FXM0RVLG9CQVgyRDtBQUFBLE1BWTNEQyx5QkFaMkQsR0FnQnpEWCx3QkFoQnlELENBWTNEVyx5QkFaMkQ7QUFBQSxNQWEzREMsT0FiMkQsR0FnQnpEWix3QkFoQnlELENBYTNEWSxPQWIyRDtBQUFBLE1BYzNEQyxLQWQyRCxHQWdCekRiLHdCQWhCeUQsQ0FjM0RhLEtBZDJEO0FBQUEsTUFlM0RDLE1BZjJELEdBZ0J6RGQsd0JBaEJ5RCxDQWUzRGMsTUFmMkQsRUFrQjdEO0FBQ0E7O0FBQ0EsVUFBUStELEtBQVI7QUFDRSxTQUFLNUUsSUFBTDtBQUNFLGFBQU8zQiwyQkFBZ0J3RyxJQUF2Qjs7QUFDRixTQUFLNUUsSUFBTDtBQUNBLFNBQUtDLFFBQUw7QUFDRSxhQUFPN0IsMkJBQWdCd0QsU0FBdkI7O0FBQ0YsU0FBS3hCLEtBQUw7QUFDRSxhQUFPaEMsMkJBQWdCQyxJQUF2Qjs7QUFDRixTQUFLOEIsR0FBTDtBQUNFLGFBQU8vQiwyQkFBZ0JFLE9BQXZCOztBQUNGLFNBQUsrQixPQUFMO0FBQ0UsYUFBT2pDLHFDQUFQOztBQUNGLFNBQUttQyxRQUFMO0FBQ0EsU0FBS0Msb0JBQUw7QUFDQSxTQUFLQyx5QkFBTDtBQUNBLFNBQUtFLEtBQUw7QUFDQSxTQUFLQyxNQUFMO0FBQ0U7QUFDQSxhQUFPeEMsMkJBQWdCeUcsT0FBdkI7O0FBQ0YsU0FBSzNFLE1BQUw7QUFDQSxTQUFLSSxNQUFMO0FBQ0EsU0FBS0ksT0FBTDtBQUNFLGFBQU90QywyQkFBZ0IwRyxNQUF2Qjs7QUFDRjtBQUNFQyxzQkFBY0MsSUFBZCxzQ0FBaURMLEtBQWpEOztBQUNBLGFBQU92RywyQkFBZ0IwRyxNQUF2QjtBQXpCSjtBQTJCRCIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAyMiBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5cbmltcG9ydCB7Y29uc29sZSBhcyBnbG9iYWxDb25zb2xlfSBmcm9tICdnbG9iYWwvd2luZG93JztcbmltcG9ydCB7QUxMX0ZJRUxEX1RZUEVTfSBmcm9tICdAa2VwbGVyLmdsL2NvbnN0YW50cyc7XG5pbXBvcnQge0FuYWx5emVyLCBEQVRBX1RZUEVTIGFzIEFuYWx5emVyREFUQV9UWVBFU30gZnJvbSAndHlwZS1hbmFseXplcic7XG5pbXBvcnQgYXNzZXJ0IGZyb20gJ2Fzc2VydCc7XG5cbmltcG9ydCB7UHJvY2Vzc29yUmVzdWx0LCBSR0JDb2xvciwgUm93RGF0YSwgRmllbGQsIEZpZWxkUGFpcn0gZnJvbSAnQGtlcGxlci5nbC90eXBlcyc7XG5cbmltcG9ydCB7bm90TnVsbG9yVW5kZWZpbmVkLCBpc1BsYWluT2JqZWN0fSBmcm9tICcuL2RhdGEtdXRpbHMnO1xuaW1wb3J0IHtyYW5nZX0gZnJvbSAnZDMtYXJyYXknO1xuaW1wb3J0IHtoZXhUb1JnYn0gZnJvbSAnLi9jb2xvci11dGlscyc7XG5cbi8vIGFwcGx5IGEgY29sb3IgZm9yIGVhY2ggZGF0YXNldFxuLy8gdG8gdXNlIGFzIGxhYmVsIGNvbG9yc1xuY29uc3QgZGF0YXNldENvbG9ycyA9IFtcbiAgJyM4RjJGQkYnLFxuICAnIzAwNUNGRicsXG4gICcjQzA2Qzg0JyxcbiAgJyNGOEIxOTUnLFxuICAnIzU0N0E4MicsXG4gICcjM0VBQ0E4JyxcbiAgJyNBMkQ0QUInXG5dLm1hcChoZXhUb1JnYik7XG5cbi8qKlxuICogUmFuZG9tIGNvbG9yIGdlbmVyYXRvclxuICovXG5mdW5jdGlvbiogZ2VuZXJhdGVDb2xvcigpOiBHZW5lcmF0b3I8UkdCQ29sb3I+IHtcbiAgbGV0IGluZGV4ID0gMDtcbiAgd2hpbGUgKGluZGV4IDwgZGF0YXNldENvbG9ycy5sZW5ndGggKyAxKSB7XG4gICAgaWYgKGluZGV4ID09PSBkYXRhc2V0Q29sb3JzLmxlbmd0aCkge1xuICAgICAgaW5kZXggPSAwO1xuICAgIH1cbiAgICB5aWVsZCBkYXRhc2V0Q29sb3JzW2luZGV4KytdO1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCBkYXRhc2V0Q29sb3JNYWtlciA9IGdlbmVyYXRlQ29sb3IoKTtcblxuLyoqXG4gKiBGaWVsZCBuYW1lIHByZWZpeGVzIGFuZCBzdWZmaXhlcyB3aGljaCBzaG91bGQgbm90IGJlIGNvbnNpZGVyZWRcbiAqIGFzIG1ldHJpY3MuIEZpZWxkcyB3aWxsIHN0aWxsIGJlIGluY2x1ZGVkIGlmIGEgJ21ldHJpYyB3b3JkJ1xuICogaXMgZm91bmQgb24gdGhlIGZpZWxkIG5hbWUsIGhvd2V2ZXIuXG4gKi9cbmNvbnN0IEVYQ0xVREVEX0RFRkFVTFRfRklFTERTID0gW1xuICAvLyBTZXJpYWwgbnVtYmVycyBhbmQgaWRlbnRpZmljYXRpb24gbnVtYmVyc1xuICAnX2lkJyxcbiAgJ2lkJyxcbiAgJ2luZGV4JyxcbiAgJ3V1aWQnLFxuICAnZ3VpZCcsXG4gICd1aWQnLFxuICAnZ2lkJyxcbiAgJ3NlcmlhbCcsXG4gIC8vIEdlb2dyYXBoaWMgSURzIGFyZSB1bmxpa2VseSB0byBiZSBpbnRlcmVzdGluZyB0byBjb2xvclxuICAnemlwJyxcbiAgJ2NvZGUnLFxuICAncG9zdCcsXG4gICdyZWdpb24nLFxuICAnZmlwcycsXG4gICdjYmdzJyxcbiAgJ2gzJyxcbiAgJ3MyJyxcbiAgLy8gR2VvZ3JhcGhpYyBjb29yZHMgKGJ1dCBub3Qgei9lbGV2YXRpb24vYWx0aXR1ZGVcbiAgLy8gc2luY2UgdGhhdCBtaWdodCBiZSBhIG1ldHJpYylcbiAgJ2xhdCcsXG4gICdsb24nLFxuICAnbG5nJyxcbiAgJ2xhdGl0dWRlJyxcbiAgJ2xvbmdpdHVkZScsXG4gICdfeCcsXG4gICdfeSdcbl07XG5cbi8qKlxuICogUHJlZml4ZXMgYW5kIHN1ZmZpeGVzIHRoYXQgaW5kaWNhdGUgYSBmaWVsZCBpcyBhIG1ldHJpYy5cbiAqXG4gKiBOb3RlIHRoYXQgdGhlc2UgYXJlIGluIG9yZGVyIG9mIHByZWZlcmVuY2UsIGZpcnN0IGJlaW5nXG4gKiBtb3N0IHByZWZlcnJlZC5cbiAqL1xuY29uc3QgTUVUUklDX0RFRkFVTFRfRklFTERTID0gW1xuICAnbWV0cmljJyxcbiAgJ3ZhbHVlJyxcbiAgJ3N1bScsXG4gICdjb3VudCcsXG4gICd1bmlxdWUnLFxuICAnbWVhbicsXG4gICdtb2RlJyxcbiAgJ21lZGlhbicsXG4gICdtYXgnLFxuICAnbWluJyxcbiAgJ2RldmlhdGlvbicsXG4gICd2YXJpYW5jZScsXG4gICdwOTknLFxuICAncDk1JyxcbiAgJ3A3NScsXG4gICdwNTAnLFxuICAncDI1JyxcbiAgJ3AwNScsXG4gIC8vIEFiYnJldmlhdGlvbnMgYXJlIGxlc3MgcHJlZmVycmVkXG4gICdjbnQnLFxuICAndmFsJ1xuXTtcblxuLyoqXG4gKiBDaG9vc2UgYSBmaWVsZCB0byB1c2UgYXMgdGhlIGRlZmF1bHQgY29sb3IgZmllbGQgb2YgYSBsYXllci5cbiAqXG4gKiBUaGUgaGV1cmlzdGljIGlzOlxuICpcbiAqIEZpcnN0LCBleGNsdWRlIGZpZWxkcyB0aGF0IGFyZSBvbiB0aGUgZXhjbHVzaW9uIGxpc3QgYW5kIGRvbid0XG4gKiBoYXZlIG5hbWVzIHRoYXQgc3VnZ2VzdCB0aGV5IGNvbnRhaW4gbWV0cmljcy4gQWxzbyBleGNsdWRlXG4gKiBmaWVsZCBuYW1lcyB0aGF0IGFyZSBibGFuay5cbiAqXG4gKiBOZXh0LCBsb29rIGZvciBhIGZpZWxkIHRoYXQgaXMgb2YgcmVhbCB0eXBlIGFuZCBjb250YWlucyBvbmVcbiAqIG9mIHRoZSBwcmVmZXJyZWQgbmFtZXMgKGluIG9yZGVyIG9mIHRoZSBwcmVmZXJyZWQgbmFtZXMpLlxuICpcbiAqIE5leHQsIGxvb2sgZm9yIGEgZmllbGQgdGhhdCBpcyBvZiBpbnRlZ2VyIHR5cGUgYW5kIGNvbnRhaW5zXG4gKiBvbmUgb2YgdGhlIHByZWZlcnJlZCBuYW1lcyAoaW4gb3JkZXIgb2YgdGhlIHByZWZlcnJlZCBuYW1lcykuXG4gKlxuICogTmV4dCwgbG9vayBmb3IgdGhlIGZpcnN0IGZpZWxkIHRoYXQgaXMgb2YgcmVhbCB0eXBlIChpbiBvcmRlclxuICogb2YgZmllbGQgaW5kZXgpLlxuICpcbiAqIE5leHQsIGxvb2sgZm9yIHRoZSBmaXJzdCBmaWVsZCB0aGF0IGlzIG9mIGludGVnZXIgdHlwZSAoaW5cbiAqIG9yZGVyIG9mIGZpZWxkIGluZGV4KS5cbiAqXG4gKiBJdCdzIHBvc3NpYmxlIG5vIGZpZWxkIHdpbGwgYmUgY2hvc2VuIChpLmUuIGJlY2F1c2UgYWxsIGZpZWxkc1xuICogYXJlIHN0cmluZ3MuKVxuICpcbiAqIEBwYXJhbSBkYXRhc2V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaW5kRGVmYXVsdENvbG9yRmllbGQoe1xuICBmaWVsZHMsXG4gIGZpZWxkUGFpcnMgPSBbXVxufToge1xuICBmaWVsZHM6IEZpZWxkW107XG4gIGZpZWxkUGFpcnM6IEZpZWxkUGFpcltdO1xufSk6IG51bGwgfCBGaWVsZCB7XG4gIGNvbnN0IGZpZWxkc1dpdGhvdXRFeGNsdWRlZCA9IGZpZWxkcy5maWx0ZXIoZmllbGQgPT4ge1xuICAgIGlmIChmaWVsZC50eXBlICE9PSBBTExfRklFTERfVFlQRVMucmVhbCAmJiBmaWVsZC50eXBlICE9PSBBTExfRklFTERfVFlQRVMuaW50ZWdlcikge1xuICAgICAgLy8gT25seSBzZWxlY3QgbnVtZXJpYyBmaWVsZHMuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChcbiAgICAgIGZpZWxkUGFpcnMuZmluZChcbiAgICAgICAgcGFpciA9PiBwYWlyLnBhaXIubGF0LnZhbHVlID09PSBmaWVsZC5uYW1lIHx8IHBhaXIucGFpci5sbmcudmFsdWUgPT09IGZpZWxkLm5hbWVcbiAgICAgIClcbiAgICApIHtcbiAgICAgIC8vIERvIG5vdCBwZXJtaXQgbGF0LCBsb24gZmllbGRzXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3Qgbm9ybWFsaXplZEZpZWxkTmFtZSA9IGZpZWxkLm5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAobm9ybWFsaXplZEZpZWxkTmFtZSA9PT0gJycpIHtcbiAgICAgIC8vIFNwZWNpYWwgY2FzZSBleGNsdWRlZCBuYW1lIHdoZW4gdGhlIG5hbWUgaXMgYmxhbmsuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGhhc0V4Y2x1ZGVkID0gRVhDTFVERURfREVGQVVMVF9GSUVMRFMuZmluZChcbiAgICAgIGYgPT4gbm9ybWFsaXplZEZpZWxkTmFtZS5zdGFydHNXaXRoKGYpIHx8IG5vcm1hbGl6ZWRGaWVsZE5hbWUuZW5kc1dpdGgoZilcbiAgICApO1xuICAgIGNvbnN0IGhhc0luY2x1c2lvbiA9IE1FVFJJQ19ERUZBVUxUX0ZJRUxEUy5maW5kKFxuICAgICAgZiA9PiBub3JtYWxpemVkRmllbGROYW1lLnN0YXJ0c1dpdGgoZikgfHwgbm9ybWFsaXplZEZpZWxkTmFtZS5lbmRzV2l0aChmKVxuICAgICk7XG4gICAgcmV0dXJuICFoYXNFeGNsdWRlZCB8fCBoYXNJbmNsdXNpb247XG4gIH0pO1xuXG4gIGNvbnN0IHNvcnRlZEZpZWxkcyA9IGZpZWxkc1dpdGhvdXRFeGNsdWRlZC5zb3J0KChsZWZ0LCByaWdodCkgPT4ge1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRMZWZ0ID0gbGVmdC5uYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgY29uc3Qgbm9ybWFsaXplZFJpZ2h0ID0gcmlnaHQubmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIGNvbnN0IGxlZnRIYXNJbmNsdXNpb24gPSBNRVRSSUNfREVGQVVMVF9GSUVMRFMuZmluZEluZGV4KFxuICAgICAgZiA9PiBub3JtYWxpemVkTGVmdC5zdGFydHNXaXRoKGYpIHx8IG5vcm1hbGl6ZWRMZWZ0LmVuZHNXaXRoKGYpXG4gICAgKTtcbiAgICBjb25zdCByaWdodEhhc0luY2x1c2lvbiA9IE1FVFJJQ19ERUZBVUxUX0ZJRUxEUy5maW5kSW5kZXgoXG4gICAgICBmID0+IG5vcm1hbGl6ZWRSaWdodC5zdGFydHNXaXRoKGYpIHx8IG5vcm1hbGl6ZWRSaWdodC5lbmRzV2l0aChmKVxuICAgICk7XG4gICAgaWYgKGxlZnRIYXNJbmNsdXNpb24gIT09IHJpZ2h0SGFzSW5jbHVzaW9uKSB7XG4gICAgICBpZiAobGVmdEhhc0luY2x1c2lvbiA9PT0gLTEpIHtcbiAgICAgICAgLy8gRWxlbWVudHMgdGhhdCBkbyBub3QgaGF2ZSB0aGUgaW5jbHVzaW9uIGxpc3Qgc2hvdWxkIGdvIGFmdGVyIHRob3NlIHRoYXQgZG8uXG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfSBlbHNlIGlmIChyaWdodEhhc0luY2x1c2lvbiA9PT0gLTEpIHtcbiAgICAgICAgLy8gRWxlbWVudHMgdGhhdCBkbyBoYXZlIHRoZSBpbmNsdXNpb24gbGlzdCBzaG91bGQgZ28gYmVmb3JlIHRob3NlIHRoYXQgZG9uJ3QuXG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIC8vIENvbXBhcmUgYmFzZWQgb24gb3JkZXIgaW4gdGhlIGluY2x1c2lvbiBsaXN0XG4gICAgICByZXR1cm4gbGVmdEhhc0luY2x1c2lvbiAtIHJpZ2h0SGFzSW5jbHVzaW9uO1xuICAgIH1cblxuICAgIC8vIENvbXBhcmUgYmFzZWQgb24gdHlwZVxuICAgIGlmIChsZWZ0LnR5cGUgIT09IHJpZ2h0LnR5cGUpIHtcbiAgICAgIGlmIChsZWZ0LnR5cGUgPT09IEFMTF9GSUVMRF9UWVBFUy5yZWFsKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIC8vIGxlZnQgaXMgYW4gaW50ZWdlciBhbmQgcmlnaHQgaXMgbm90XG4gICAgICAvLyBhbmQgcmVhbHMgY29tZSBiZWZvcmUgaW50ZWdlcnNcbiAgICAgIHJldHVybiAxO1xuICAgIH1cblxuICAgIC8vIEZpbmFsbHksIG9yZGVyIGJhc2VkIG9uIHRoZSBvcmRlciBpbiB0aGUgZGF0YXNldHMgY29sdW1uc1xuICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICByZXR1cm4gbGVmdC5pbmRleCAtIHJpZ2h0LmluZGV4O1xuICB9KTtcblxuICBpZiAoc29ydGVkRmllbGRzLmxlbmd0aCkge1xuICAgIC8vIFRoZXJlIHdhcyBhIGJlc3QgbWF0Y2hcbiAgICByZXR1cm4gc29ydGVkRmllbGRzWzBdO1xuICB9XG4gIC8vIE5vIG1hdGNoZXNcbiAgcmV0dXJuIG51bGw7XG59XG5cbmV4cG9ydCBjb25zdCBBQ0NFUFRFRF9BTkFMWVpFUl9UWVBFUyA9IFtcbiAgQW5hbHl6ZXJEQVRBX1RZUEVTLkRBVEUsXG4gIEFuYWx5emVyREFUQV9UWVBFUy5USU1FLFxuICBBbmFseXplckRBVEFfVFlQRVMuREFURVRJTUUsXG4gIEFuYWx5emVyREFUQV9UWVBFUy5OVU1CRVIsXG4gIEFuYWx5emVyREFUQV9UWVBFUy5JTlQsXG4gIEFuYWx5emVyREFUQV9UWVBFUy5GTE9BVCxcbiAgQW5hbHl6ZXJEQVRBX1RZUEVTLkJPT0xFQU4sXG4gIEFuYWx5emVyREFUQV9UWVBFUy5TVFJJTkcsXG4gIEFuYWx5emVyREFUQV9UWVBFUy5HRU9NRVRSWSxcbiAgQW5hbHl6ZXJEQVRBX1RZUEVTLkdFT01FVFJZX0ZST01fU1RSSU5HLFxuICBBbmFseXplckRBVEFfVFlQRVMuUEFJUl9HRU9NRVRSWV9GUk9NX1NUUklORyxcbiAgQW5hbHl6ZXJEQVRBX1RZUEVTLlpJUENPREUsXG4gIEFuYWx5emVyREFUQV9UWVBFUy5BUlJBWSxcbiAgQW5hbHl6ZXJEQVRBX1RZUEVTLk9CSkVDVFxuXTtcblxuY29uc3QgSUdOT1JFX0RBVEFfVFlQRVMgPSBPYmplY3Qua2V5cyhBbmFseXplckRBVEFfVFlQRVMpLmZpbHRlcihcbiAgdHlwZSA9PiAhQUNDRVBURURfQU5BTFlaRVJfVFlQRVMuaW5jbHVkZXModHlwZSlcbik7XG5cbi8qKlxuICogVmFsaWRhdGUgaW5wdXQgZGF0YSwgYWRkaW5nIG1pc3NpbmcgZmllbGQgdHlwZXMsIHJlbmFtZSBkdXBsaWNhdGUgY29sdW1uc1xuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVJbnB1dERhdGEoZGF0YTogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pOiBQcm9jZXNzb3JSZXN1bHQge1xuICBpZiAoIWlzUGxhaW5PYmplY3QoZGF0YSkpIHtcbiAgICBhc3NlcnQoJ2FkZERhdGFUb01hcCBFcnJvcjogZGF0YXNldC5kYXRhIGNhbm5vdCBiZSBudWxsJyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0gZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkoZGF0YS5maWVsZHMpKSB7XG4gICAgYXNzZXJ0KCdhZGREYXRhVG9NYXAgRXJyb3I6IGV4cGVjdCBkYXRhc2V0LmRhdGEuZmllbGRzIHRvIGJlIGFuIGFycmF5Jyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0gZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkoZGF0YS5yb3dzKSkge1xuICAgIGFzc2VydCgnYWRkRGF0YVRvTWFwIEVycm9yOiBleHBlY3QgZGF0YXNldC5kYXRhLnJvd3MgdG8gYmUgYW4gYXJyYXknKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGNvbnN0IHtmaWVsZHMsIHJvd3N9ID0gZGF0YTtcblxuICAvLyBjaGVjayBpZiBhbGwgZmllbGRzIGhhcyBuYW1lLCBmb3JtYXQgYW5kIHR5cGVcbiAgY29uc3QgYWxsVmFsaWQgPSBmaWVsZHMuZXZlcnkoKGYsIGkpID0+IHtcbiAgICBpZiAoIWlzUGxhaW5PYmplY3QoZikpIHtcbiAgICAgIGFzc2VydChgZmllbGRzIG5lZWRzIHRvIGJlIGFuIGFycmF5IG9mIG9iamVjdCwgYnV0IGZpbmQgJHt0eXBlb2YgZn1gKTtcbiAgICAgIGZpZWxkc1tpXSA9IHt9O1xuICAgIH1cblxuICAgIGlmICghZi5uYW1lKSB7XG4gICAgICBhc3NlcnQoYGZpZWxkLm5hbWUgaXMgcmVxdWlyZWQgYnV0IG1pc3NpbmcgaW4gJHtKU09OLnN0cmluZ2lmeShmKX1gKTtcbiAgICAgIC8vIGFzc2lnbiBhIG5hbWVcbiAgICAgIGZpZWxkc1tpXS5uYW1lID0gYGNvbHVtbl8ke2l9YDtcbiAgICB9XG5cbiAgICBpZiAoIUFMTF9GSUVMRF9UWVBFU1tmLnR5cGVdKSB7XG4gICAgICBhc3NlcnQoYHVua25vd24gZmllbGQgdHlwZSAke2YudHlwZX1gKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoIWZpZWxkcy5ldmVyeShmaWVsZCA9PiBmaWVsZC5hbmFseXplclR5cGUpKSB7XG4gICAgICBhc3NlcnQoJ2ZpZWxkIG1pc3NpbmcgYW5hbHl6ZXJUeXBlJyk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgdGltZSBmb3JtYXQgaXMgY29ycmVjdCBiYXNlZCBvbiBmaXJzdCAxMCBub3QgZW1wdHkgZWxlbWVudFxuICAgIGlmIChmLnR5cGUgPT09IEFMTF9GSUVMRF9UWVBFUy50aW1lc3RhbXApIHtcbiAgICAgIGNvbnN0IHNhbXBsZSA9IGZpbmROb25FbXB0eVJvd3NBdEZpZWxkKHJvd3MsIGksIDEwKS5tYXAociA9PiAoe3RzOiByW2ldfSkpO1xuICAgICAgY29uc3QgYW5hbHl6ZWRUeXBlID0gQW5hbHl6ZXIuY29tcHV0ZUNvbE1ldGEoc2FtcGxlKVswXTtcbiAgICAgIHJldHVybiBhbmFseXplZFR5cGUgJiYgYW5hbHl6ZWRUeXBlLmNhdGVnb3J5ID09PSAnVElNRScgJiYgYW5hbHl6ZWRUeXBlLmZvcm1hdCA9PT0gZi5mb3JtYXQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH0pO1xuXG4gIGlmIChhbGxWYWxpZCkge1xuICAgIHJldHVybiB7cm93cywgZmllbGRzfTtcbiAgfVxuXG4gIC8vIGlmIGFueSBmaWVsZCBoYXMgbWlzc2luZyB0eXBlLCByZWNhbGN1bGF0ZSBpdCBmb3IgZXZlcnlvbmVcbiAgLy8gYmVjYXVzZSB3ZSBzaW1wbHkgbG9zdCBmYWl0aCBpbiBodW1hbml0eVxuICBjb25zdCBzYW1wbGVEYXRhID0gZ2V0U2FtcGxlRm9yVHlwZUFuYWx5emUoe1xuICAgIGZpZWxkczogZmllbGRzLm1hcChmID0+IGYubmFtZSksXG4gICAgcm93c1xuICB9KTtcbiAgY29uc3QgZmllbGRPcmRlciA9IGZpZWxkcy5tYXAoZiA9PiBmLm5hbWUpO1xuICBjb25zdCBtZXRhID0gZ2V0RmllbGRzRnJvbURhdGEoc2FtcGxlRGF0YSwgZmllbGRPcmRlcik7XG4gIGNvbnN0IHVwZGF0ZWRGaWVsZHMgPSBmaWVsZHMubWFwKChmLCBpKSA9PiAoe1xuICAgIC4uLmYsXG4gICAgdHlwZTogbWV0YVtpXS50eXBlLFxuICAgIGZvcm1hdDogbWV0YVtpXS5mb3JtYXQsXG4gICAgYW5hbHl6ZXJUeXBlOiBtZXRhW2ldLmFuYWx5emVyVHlwZVxuICB9KSk7XG5cbiAgcmV0dXJuIHtmaWVsZHM6IHVwZGF0ZWRGaWVsZHMsIHJvd3N9O1xufVxuXG5mdW5jdGlvbiBmaW5kTm9uRW1wdHlSb3dzQXRGaWVsZChyb3dzOiB1bmtub3duW11bXSwgZmllbGRJZHg6IG51bWJlciwgdG90YWw6IG51bWJlcik6IGFueVtdIHtcbiAgY29uc3Qgc2FtcGxlOiBhbnlbXSA9IFtdO1xuICBsZXQgaSA9IDA7XG4gIHdoaWxlIChzYW1wbGUubGVuZ3RoIDwgdG90YWwgJiYgaSA8IHJvd3MubGVuZ3RoKSB7XG4gICAgaWYgKG5vdE51bGxvclVuZGVmaW5lZChyb3dzW2ldPy5bZmllbGRJZHhdKSkge1xuICAgICAgc2FtcGxlLnB1c2gocm93c1tpXSk7XG4gICAgfVxuICAgIGkrKztcbiAgfVxuICByZXR1cm4gc2FtcGxlO1xufVxuLyoqXG4gKiBHZXR0aW5nIHNhbXBsZSBkYXRhIGZvciBhbmFseXppbmcgZmllbGQgdHlwZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFNhbXBsZUZvclR5cGVBbmFseXplKHtcbiAgZmllbGRzLFxuICByb3dzLFxuICBzYW1wbGVDb3VudCA9IDUwXG59OiB7XG4gIGZpZWxkczogc3RyaW5nW107XG4gIHJvd3M6IHVua25vd25bXVtdO1xuICBzYW1wbGVDb3VudD86IG51bWJlcjtcbn0pOiBSb3dEYXRhIHtcbiAgY29uc3QgdG90YWwgPSBNYXRoLm1pbihzYW1wbGVDb3VudCwgcm93cy5sZW5ndGgpO1xuICAvLyBjb25zdCBmaWVsZE9yZGVyID0gZmllbGRzLm1hcChmID0+IGYubmFtZSk7XG4gIGNvbnN0IHNhbXBsZSA9IHJhbmdlKDAsIHRvdGFsLCAxKS5tYXAoZCA9PiAoe30pKTtcblxuICAvLyBjb2xsZWN0IHNhbXBsZSBkYXRhIGZvciBlYWNoIGZpZWxkXG4gIGZpZWxkcy5mb3JFYWNoKChmaWVsZCwgZmllbGRJZHgpID0+IHtcbiAgICAvLyBkYXRhIGNvdW50ZXJcbiAgICBsZXQgaSA9IDA7XG4gICAgLy8gc2FtcGxlIGNvdW50ZXJcbiAgICBsZXQgaiA9IDA7XG5cbiAgICB3aGlsZSAoaiA8IHRvdGFsKSB7XG4gICAgICBpZiAoaSA+PSByb3dzLmxlbmd0aCkge1xuICAgICAgICAvLyBpZiBkZXBsZXRlZCBkYXRhIHBvb2xcbiAgICAgICAgc2FtcGxlW2pdW2ZpZWxkXSA9IG51bGw7XG4gICAgICAgIGorKztcbiAgICAgIH0gZWxzZSBpZiAobm90TnVsbG9yVW5kZWZpbmVkKHJvd3NbaV1bZmllbGRJZHhdKSkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHJvd3NbaV1bZmllbGRJZHhdO1xuICAgICAgICBzYW1wbGVbal1bZmllbGRdID0gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyA/IHZhbHVlLnRyaW0oKSA6IHZhbHVlO1xuICAgICAgICBqKys7XG4gICAgICAgIGkrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGkrKztcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBzYW1wbGU7XG59XG5cbi8qKlxuICogQW5hbHl6ZSBmaWVsZCB0eXBlcyBmcm9tIGRhdGEgaW4gYHN0cmluZ2AgZm9ybWF0LCBlLmcuIHVwbG9hZGVkIGNzdi5cbiAqIEFzc2lnbiBgdHlwZWAsIGBmaWVsZElkeGAgYW5kIGBmb3JtYXRgICh0aW1lc3RhbXAgb25seSkgdG8gZWFjaCBmaWVsZFxuICpcbiAqIEBwYXJhbSBkYXRhIGFycmF5IG9mIHJvdyBvYmplY3RcbiAqIEBwYXJhbSBmaWVsZE9yZGVyIGFycmF5IG9mIGZpZWxkIG5hbWVzIGFzIHN0cmluZ1xuICogQHJldHVybnMgZm9ybWF0dGVkIGZpZWxkc1xuICogQHB1YmxpY1xuICogQGV4YW1wbGVcbiAqXG4gKiBpbXBvcnQge2dldEZpZWxkc0Zyb21EYXRhfSBmcm9tICdrZXBsZXIuZ2wvcHJvY2Vzc29ycyc7XG4gKiBjb25zdCBkYXRhID0gW3tcbiAqICAgdGltZTogJzIwMTYtMDktMTcgMDA6MDk6NTUnLFxuICogICB2YWx1ZTogJzQnLFxuICogICBzdXJnZTogJzEuMicsXG4gKiAgIGlzVHJpcDogJ3RydWUnLFxuICogICB6ZXJvT25lczogJzAnXG4gKiB9LCB7XG4gKiAgIHRpbWU6ICcyMDE2LTA5LTE3IDAwOjMwOjA4JyxcbiAqICAgdmFsdWU6ICczJyxcbiAqICAgc3VyZ2U6IG51bGwsXG4gKiAgIGlzVHJpcDogJ2ZhbHNlJyxcbiAqICAgemVyb09uZXM6ICcxJ1xuICogfSwge1xuICogICB0aW1lOiBudWxsLFxuICogICB2YWx1ZTogJzInLFxuICogICBzdXJnZTogJzEuMycsXG4gKiAgIGlzVHJpcDogbnVsbCxcbiAqICAgemVyb09uZXM6ICcxJ1xuICogfV07XG4gKlxuICogY29uc3QgZmllbGRPcmRlciA9IFsndGltZScsICd2YWx1ZScsICdzdXJnZScsICdpc1RyaXAnLCAnemVyb09uZXMnXTtcbiAqIGNvbnN0IGZpZWxkcyA9IGdldEZpZWxkc0Zyb21EYXRhKGRhdGEsIGZpZWxkT3JkZXIpO1xuICogLy8gZmllbGRzID0gW1xuICogLy8ge25hbWU6ICd0aW1lJywgZm9ybWF0OiAnWVlZWS1NLUQgSDptOnMnLCBmaWVsZElkeDogMSwgdHlwZTogJ3RpbWVzdGFtcCd9LFxuICogLy8ge25hbWU6ICd2YWx1ZScsIGZvcm1hdDogJycsIGZpZWxkSWR4OiA0LCB0eXBlOiAnaW50ZWdlcid9LFxuICogLy8ge25hbWU6ICdzdXJnZScsIGZvcm1hdDogJycsIGZpZWxkSWR4OiA1LCB0eXBlOiAncmVhbCd9LFxuICogLy8ge25hbWU6ICdpc1RyaXAnLCBmb3JtYXQ6ICcnLCBmaWVsZElkeDogNiwgdHlwZTogJ2Jvb2xlYW4nfSxcbiAqIC8vIHtuYW1lOiAnemVyb09uZXMnLCBmb3JtYXQ6ICcnLCBmaWVsZElkeDogNywgdHlwZTogJ2ludGVnZXInfV07XG4gKlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RmllbGRzRnJvbURhdGEoZGF0YTogUm93RGF0YSwgZmllbGRPcmRlcjogc3RyaW5nW10pOiBGaWVsZFtdIHtcbiAgLy8gYWRkIGEgY2hlY2sgZm9yIGVwb2NoIHRpbWVzdGFtcFxuICBjb25zdCBtZXRhZGF0YSA9IEFuYWx5emVyLmNvbXB1dGVDb2xNZXRhKFxuICAgIGRhdGEsXG4gICAgW1xuICAgICAge3JlZ2V4OiAvLipnZW9qc29ufGFsbF9wb2ludHMvZywgZGF0YVR5cGU6ICdHRU9NRVRSWSd9LFxuICAgICAge3JlZ2V4OiAvLipjZW5zdXMvZywgZGF0YVR5cGU6ICdTVFJJTkcnfVxuICAgIF0sXG4gICAge2lnbm9yZWREYXRhVHlwZXM6IElHTk9SRV9EQVRBX1RZUEVTfVxuICApO1xuXG4gIGNvbnN0IHtmaWVsZEJ5SW5kZXh9ID0gcmVuYW1lRHVwbGljYXRlRmllbGRzKGZpZWxkT3JkZXIpO1xuXG4gIGNvbnN0IHJlc3VsdCA9IGZpZWxkT3JkZXIubWFwKChmaWVsZCwgaW5kZXgpID0+IHtcbiAgICBjb25zdCBuYW1lID0gZmllbGRCeUluZGV4W2luZGV4XTtcblxuICAgIGNvbnN0IGZpZWxkTWV0YSA9IG1ldGFkYXRhLmZpbmQobSA9PiBtLmtleSA9PT0gZmllbGQpO1xuICAgIGNvbnN0IHt0eXBlLCBmb3JtYXR9ID0gZmllbGRNZXRhIHx8IHt9O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWUsXG4gICAgICBpZDogbmFtZSxcbiAgICAgIGRpc3BsYXlOYW1lOiBuYW1lLFxuICAgICAgZm9ybWF0LFxuICAgICAgZmllbGRJZHg6IGluZGV4LFxuICAgICAgdHlwZTogYW5hbHl6ZXJUeXBlVG9GaWVsZFR5cGUodHlwZSksXG4gICAgICBhbmFseXplclR5cGU6IHR5cGUsXG4gICAgICB2YWx1ZUFjY2Vzc29yOiBkYyA9PiBkID0+IHtcbiAgICAgICAgcmV0dXJuIGRjLnZhbHVlQXQoZC5pbmRleCwgaW5kZXgpO1xuICAgICAgfVxuICAgIH07XG4gIH0pO1xuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogcGFzcyBpbiBhbiBhcnJheSBvZiBmaWVsZCBuYW1lcywgcmVuYW1lIGR1cGxpY2F0ZWQgb25lXG4gKiBhbmQgcmV0dXJuIGEgbWFwIGZyb20gb2xkIGZpZWxkIGluZGV4IHRvIG5ldyBuYW1lXG4gKlxuICogQHBhcmFtIGZpZWxkT3JkZXJcbiAqIEByZXR1cm5zIG5ldyBmaWVsZCBuYW1lIGJ5IGluZGV4XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW5hbWVEdXBsaWNhdGVGaWVsZHMoXG4gIGZpZWxkT3JkZXI6IHN0cmluZ1tdXG4pOiB7YWxsTmFtZXM6IHN0cmluZ1tdOyBmaWVsZEJ5SW5kZXg6IHN0cmluZ1tdfSB7XG4gIHJldHVybiBmaWVsZE9yZGVyLnJlZHVjZTx7YWxsTmFtZXM6IHN0cmluZ1tdOyBmaWVsZEJ5SW5kZXg6IHN0cmluZ1tdfT4oXG4gICAgKGFjY3UsIGZpZWxkLCBpKSA9PiB7XG4gICAgICBjb25zdCB7YWxsTmFtZXN9ID0gYWNjdTtcbiAgICAgIGxldCBmaWVsZE5hbWUgPSBmaWVsZDtcblxuICAgICAgLy8gYWRkIGEgY291bnRlciB0byBkdXBsaWNhdGVkIG5hbWVzXG4gICAgICBpZiAoYWxsTmFtZXMuaW5jbHVkZXMoZmllbGQpKSB7XG4gICAgICAgIGxldCBjb3VudGVyID0gMDtcbiAgICAgICAgd2hpbGUgKGFsbE5hbWVzLmluY2x1ZGVzKGAke2ZpZWxkfS0ke2NvdW50ZXJ9YCkpIHtcbiAgICAgICAgICBjb3VudGVyKys7XG4gICAgICAgIH1cbiAgICAgICAgZmllbGROYW1lID0gYCR7ZmllbGR9LSR7Y291bnRlcn1gO1xuICAgICAgfVxuXG4gICAgICBhY2N1LmZpZWxkQnlJbmRleFtpXSA9IGZpZWxkTmFtZTtcbiAgICAgIGFjY3UuYWxsTmFtZXMucHVzaChmaWVsZE5hbWUpO1xuXG4gICAgICByZXR1cm4gYWNjdTtcbiAgICB9LFxuICAgIHthbGxOYW1lczogW10sIGZpZWxkQnlJbmRleDogW119XG4gICk7XG59XG5cbi8qKlxuICogQ29udmVydCB0eXBlLWFuYWx5emVyIG91dHB1dCB0byBrZXBsZXIuZ2wgZmllbGQgdHlwZXNcbiAqXG4gKiBAcGFyYW0gYVR5cGVcbiAqIEByZXR1cm5zIGNvcnJlc3BvbmRpbmcgdHlwZSBpbiBgQUxMX0ZJRUxEX1RZUEVTYFxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBjb21wbGV4aXR5ICovXG5leHBvcnQgZnVuY3Rpb24gYW5hbHl6ZXJUeXBlVG9GaWVsZFR5cGUoYVR5cGU6IHN0cmluZyk6IHN0cmluZyB7XG4gIGNvbnN0IHtcbiAgICBEQVRFLFxuICAgIFRJTUUsXG4gICAgREFURVRJTUUsXG4gICAgTlVNQkVSLFxuICAgIElOVCxcbiAgICBGTE9BVCxcbiAgICBCT09MRUFOLFxuICAgIFNUUklORyxcbiAgICBHRU9NRVRSWSxcbiAgICBHRU9NRVRSWV9GUk9NX1NUUklORyxcbiAgICBQQUlSX0dFT01FVFJZX0ZST01fU1RSSU5HLFxuICAgIFpJUENPREUsXG4gICAgQVJSQVksXG4gICAgT0JKRUNUXG4gIH0gPSBBbmFseXplckRBVEFfVFlQRVM7XG5cbiAgLy8gVE9ETzogdW4gcmVjb2duaXplZCB0eXBlc1xuICAvLyBDVVJSRU5DWSBQRVJDRU5UIE5PTkVcbiAgc3dpdGNoIChhVHlwZSkge1xuICAgIGNhc2UgREFURTpcbiAgICAgIHJldHVybiBBTExfRklFTERfVFlQRVMuZGF0ZTtcbiAgICBjYXNlIFRJTUU6XG4gICAgY2FzZSBEQVRFVElNRTpcbiAgICAgIHJldHVybiBBTExfRklFTERfVFlQRVMudGltZXN0YW1wO1xuICAgIGNhc2UgRkxPQVQ6XG4gICAgICByZXR1cm4gQUxMX0ZJRUxEX1RZUEVTLnJlYWw7XG4gICAgY2FzZSBJTlQ6XG4gICAgICByZXR1cm4gQUxMX0ZJRUxEX1RZUEVTLmludGVnZXI7XG4gICAgY2FzZSBCT09MRUFOOlxuICAgICAgcmV0dXJuIEFMTF9GSUVMRF9UWVBFUy5ib29sZWFuO1xuICAgIGNhc2UgR0VPTUVUUlk6XG4gICAgY2FzZSBHRU9NRVRSWV9GUk9NX1NUUklORzpcbiAgICBjYXNlIFBBSVJfR0VPTUVUUllfRlJPTV9TVFJJTkc6XG4gICAgY2FzZSBBUlJBWTpcbiAgICBjYXNlIE9CSkVDVDpcbiAgICAgIC8vIFRPRE86IGNyZWF0ZSBhIG5ldyBkYXRhIHR5cGUgZm9yIG9iamVjdHMgYW5kIGFycmF5c1xuICAgICAgcmV0dXJuIEFMTF9GSUVMRF9UWVBFUy5nZW9qc29uO1xuICAgIGNhc2UgTlVNQkVSOlxuICAgIGNhc2UgU1RSSU5HOlxuICAgIGNhc2UgWklQQ09ERTpcbiAgICAgIHJldHVybiBBTExfRklFTERfVFlQRVMuc3RyaW5nO1xuICAgIGRlZmF1bHQ6XG4gICAgICBnbG9iYWxDb25zb2xlLndhcm4oYFVuc3VwcG9ydGVkIGFuYWx5emVyIHR5cGU6ICR7YVR5cGV9YCk7XG4gICAgICByZXR1cm4gQUxMX0ZJRUxEX1RZUEVTLnN0cmluZztcbiAgfVxufVxuIl19