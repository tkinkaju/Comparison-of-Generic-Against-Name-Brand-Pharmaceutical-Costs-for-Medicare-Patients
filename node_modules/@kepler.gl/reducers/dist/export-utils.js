// Copyright (c) 2022 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.exportData = exportData;
exports.formatCsv = formatCsv;
exports["default"] = void 0;

var _window = require("global/window");

var _d3Dsv = require("d3-dsv");

var _constants = require("@kepler.gl/constants");

var _utils = require("@kepler.gl/utils");

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function exportData(state, options) {
  var visState = state.visState,
      appName = state.appName;
  var datasets = visState.datasets;
  var selectedDataset = options.selectedDataset,
      dataType = options.dataType,
      filtered = options.filtered; // get the selected data

  var filename = appName ? appName : _utils.DEFAULT_DATA_NAME;
  var selectedDatasets = datasets[selectedDataset] ? [datasets[selectedDataset]] : Object.values(datasets);

  if (!selectedDatasets.length) {
    // error: selected dataset not found.
    return;
  }

  selectedDatasets.forEach(function (selectedData) {
    var _ref = selectedData,
        dataContainer = _ref.dataContainer,
        fields = _ref.fields,
        label = _ref.label,
        _ref$filteredIdxCPU = _ref.filteredIdxCPU,
        filteredIdxCPU = _ref$filteredIdxCPU === void 0 ? [] : _ref$filteredIdxCPU;
    var toExport = filtered ? (0, _utils.createIndexedDataContainer)(dataContainer, filteredIdxCPU) : dataContainer; // start to export data according to selected data type

    switch (dataType) {
      case _constants.EXPORT_DATA_TYPE.CSV:
        {
          var csv = formatCsv(toExport, fields);
          var fileBlob = new _window.Blob([csv], {
            type: 'text/csv'
          });
          (0, _utils.downloadFile)(fileBlob, "".concat(filename, "_").concat(label, ".csv"));
          break;
        }
      // TODO: support more file types.

      default:
        break;
    }
  });
}
/**
 * On export data to csv
 * @param dataContainer
 * @param fields `dataset.fields`
 * @returns csv string
 */


function formatCsv(data, fields) {
  var columns = fields.map(function (f) {
    return f.displayName || f.name;
  });
  var formattedData = [columns]; // parse geojson object as string

  var _iterator = _createForOfIteratorHelper(data.rows(true)),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var row = _step.value;
      formattedData.push(row.map(function (d, i) {
        return (0, _utils.parseFieldValue)(d, fields[i].type);
      }));
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  return (0, _d3Dsv.csvFormatRows)(formattedData);
}

var exporters = {
  exportData: exportData
};
var _default = exporters;
exports["default"] = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9leHBvcnQtdXRpbHMudHMiXSwibmFtZXMiOlsiZXhwb3J0RGF0YSIsInN0YXRlIiwib3B0aW9ucyIsInZpc1N0YXRlIiwiYXBwTmFtZSIsImRhdGFzZXRzIiwic2VsZWN0ZWREYXRhc2V0IiwiZGF0YVR5cGUiLCJmaWx0ZXJlZCIsImZpbGVuYW1lIiwiREVGQVVMVF9EQVRBX05BTUUiLCJzZWxlY3RlZERhdGFzZXRzIiwiT2JqZWN0IiwidmFsdWVzIiwibGVuZ3RoIiwiZm9yRWFjaCIsInNlbGVjdGVkRGF0YSIsImRhdGFDb250YWluZXIiLCJmaWVsZHMiLCJsYWJlbCIsImZpbHRlcmVkSWR4Q1BVIiwidG9FeHBvcnQiLCJFWFBPUlRfREFUQV9UWVBFIiwiQ1NWIiwiY3N2IiwiZm9ybWF0Q3N2IiwiZmlsZUJsb2IiLCJCbG9iIiwidHlwZSIsImRhdGEiLCJjb2x1bW5zIiwibWFwIiwiZiIsImRpc3BsYXlOYW1lIiwibmFtZSIsImZvcm1hdHRlZERhdGEiLCJyb3dzIiwicm93IiwicHVzaCIsImQiLCJpIiwiZXhwb3J0ZXJzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFvQkE7O0FBQ0E7O0FBRUE7O0FBSUE7Ozs7Ozs7O0FBYU8sU0FBU0EsVUFBVCxDQUFvQkMsS0FBcEIsRUFBc0NDLE9BQXRDLEVBQStDO0FBQUEsTUFDN0NDLFFBRDZDLEdBQ3hCRixLQUR3QixDQUM3Q0UsUUFENkM7QUFBQSxNQUNuQ0MsT0FEbUMsR0FDeEJILEtBRHdCLENBQ25DRyxPQURtQztBQUFBLE1BRTdDQyxRQUY2QyxHQUVqQ0YsUUFGaUMsQ0FFN0NFLFFBRjZDO0FBQUEsTUFHN0NDLGVBSDZDLEdBR05KLE9BSE0sQ0FHN0NJLGVBSDZDO0FBQUEsTUFHNUJDLFFBSDRCLEdBR05MLE9BSE0sQ0FHNUJLLFFBSDRCO0FBQUEsTUFHbEJDLFFBSGtCLEdBR05OLE9BSE0sQ0FHbEJNLFFBSGtCLEVBSXBEOztBQUNBLE1BQU1DLFFBQVEsR0FBR0wsT0FBTyxHQUFHQSxPQUFILEdBQWFNLHdCQUFyQztBQUNBLE1BQU1DLGdCQUFnQixHQUFHTixRQUFRLENBQUNDLGVBQUQsQ0FBUixHQUNyQixDQUFDRCxRQUFRLENBQUNDLGVBQUQsQ0FBVCxDQURxQixHQUVyQk0sTUFBTSxDQUFDQyxNQUFQLENBQWNSLFFBQWQsQ0FGSjs7QUFHQSxNQUFJLENBQUNNLGdCQUFnQixDQUFDRyxNQUF0QixFQUE4QjtBQUM1QjtBQUNBO0FBQ0Q7O0FBRURILEVBQUFBLGdCQUFnQixDQUFDSSxPQUFqQixDQUF5QixVQUFBQyxZQUFZLEVBQUk7QUFBQSxlQUNxQkEsWUFEckI7QUFBQSxRQUNoQ0MsYUFEZ0MsUUFDaENBLGFBRGdDO0FBQUEsUUFDakJDLE1BRGlCLFFBQ2pCQSxNQURpQjtBQUFBLFFBQ1RDLEtBRFMsUUFDVEEsS0FEUztBQUFBLG1DQUNGQyxjQURFO0FBQUEsUUFDRkEsY0FERSxvQ0FDZSxFQURmO0FBRXZDLFFBQU1DLFFBQVEsR0FBR2IsUUFBUSxHQUNyQix1Q0FBMkJTLGFBQTNCLEVBQTBDRyxjQUExQyxDQURxQixHQUVyQkgsYUFGSixDQUZ1QyxDQU12Qzs7QUFDQSxZQUFRVixRQUFSO0FBQ0UsV0FBS2UsNEJBQWlCQyxHQUF0QjtBQUEyQjtBQUN6QixjQUFNQyxHQUFHLEdBQUdDLFNBQVMsQ0FBQ0osUUFBRCxFQUFXSCxNQUFYLENBQXJCO0FBRUEsY0FBTVEsUUFBUSxHQUFHLElBQUlDLFlBQUosQ0FBUyxDQUFDSCxHQUFELENBQVQsRUFBZ0I7QUFBQ0ksWUFBQUEsSUFBSSxFQUFFO0FBQVAsV0FBaEIsQ0FBakI7QUFDQSxtQ0FBYUYsUUFBYixZQUEwQmpCLFFBQTFCLGNBQXNDVSxLQUF0QztBQUNBO0FBQ0Q7QUFDRDs7QUFDQTtBQUNFO0FBVko7QUFZRCxHQW5CRDtBQW9CRDtBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ08sU0FBU00sU0FBVCxDQUFtQkksSUFBbkIsRUFBaURYLE1BQWpELEVBQTBFO0FBQy9FLE1BQU1ZLE9BQU8sR0FBR1osTUFBTSxDQUFDYSxHQUFQLENBQVcsVUFBQUMsQ0FBQztBQUFBLFdBQUlBLENBQUMsQ0FBQ0MsV0FBRixJQUFpQkQsQ0FBQyxDQUFDRSxJQUF2QjtBQUFBLEdBQVosQ0FBaEI7QUFDQSxNQUFNQyxhQUFhLEdBQUcsQ0FBQ0wsT0FBRCxDQUF0QixDQUYrRSxDQUkvRTs7QUFKK0UsNkNBSzdERCxJQUFJLENBQUNPLElBQUwsQ0FBVSxJQUFWLENBTDZEO0FBQUE7O0FBQUE7QUFLL0Usd0RBQW1DO0FBQUEsVUFBeEJDLEdBQXdCO0FBQ2pDRixNQUFBQSxhQUFhLENBQUNHLElBQWQsQ0FBbUJELEdBQUcsQ0FBQ04sR0FBSixDQUFRLFVBQUNRLENBQUQsRUFBSUMsQ0FBSjtBQUFBLGVBQVUsNEJBQWdCRCxDQUFoQixFQUFtQnJCLE1BQU0sQ0FBQ3NCLENBQUQsQ0FBTixDQUFVWixJQUE3QixDQUFWO0FBQUEsT0FBUixDQUFuQjtBQUNEO0FBUDhFO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBUy9FLFNBQU8sMEJBQWNPLGFBQWQsQ0FBUDtBQUNEOztBQUVELElBQU1NLFNBQVMsR0FBRztBQUNoQnpDLEVBQUFBLFVBQVUsRUFBVkE7QUFEZ0IsQ0FBbEI7ZUFJZXlDLFMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMjIgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5pbXBvcnQge0Jsb2J9IGZyb20gJ2dsb2JhbC93aW5kb3cnO1xuaW1wb3J0IHtjc3ZGb3JtYXRSb3dzfSBmcm9tICdkMy1kc3YnO1xuXG5pbXBvcnQge0VYUE9SVF9EQVRBX1RZUEV9IGZyb20gJ0BrZXBsZXIuZ2wvY29uc3RhbnRzJztcbmltcG9ydCB7RmllbGR9IGZyb20gJ0BrZXBsZXIuZ2wvdHlwZXMnO1xuaW1wb3J0IEtlcGxlclRhYmxlLCB7RGF0YXNldHN9IGZyb20gJ0BrZXBsZXIuZ2wvdGFibGUnO1xuXG5pbXBvcnQge1xuICBjcmVhdGVJbmRleGVkRGF0YUNvbnRhaW5lcixcbiAgRGF0YUNvbnRhaW5lckludGVyZmFjZSxcbiAgcGFyc2VGaWVsZFZhbHVlLFxuICBkb3dubG9hZEZpbGUsXG4gIERFRkFVTFRfREFUQV9OQU1FXG59IGZyb20gJ0BrZXBsZXIuZ2wvdXRpbHMnO1xuXG5pbnRlcmZhY2UgU3RhdGVUeXBlIHtcbiAgdmlzU3RhdGU6IHtkYXRhc2V0czogRGF0YXNldHN9O1xuICBhcHBOYW1lPzogc3RyaW5nO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZXhwb3J0RGF0YShzdGF0ZTogU3RhdGVUeXBlLCBvcHRpb25zKSB7XG4gIGNvbnN0IHt2aXNTdGF0ZSwgYXBwTmFtZX0gPSBzdGF0ZTtcbiAgY29uc3Qge2RhdGFzZXRzfSA9IHZpc1N0YXRlO1xuICBjb25zdCB7c2VsZWN0ZWREYXRhc2V0LCBkYXRhVHlwZSwgZmlsdGVyZWR9ID0gb3B0aW9ucztcbiAgLy8gZ2V0IHRoZSBzZWxlY3RlZCBkYXRhXG4gIGNvbnN0IGZpbGVuYW1lID0gYXBwTmFtZSA/IGFwcE5hbWUgOiBERUZBVUxUX0RBVEFfTkFNRTtcbiAgY29uc3Qgc2VsZWN0ZWREYXRhc2V0cyA9IGRhdGFzZXRzW3NlbGVjdGVkRGF0YXNldF1cbiAgICA/IFtkYXRhc2V0c1tzZWxlY3RlZERhdGFzZXRdXVxuICAgIDogT2JqZWN0LnZhbHVlcyhkYXRhc2V0cyk7XG4gIGlmICghc2VsZWN0ZWREYXRhc2V0cy5sZW5ndGgpIHtcbiAgICAvLyBlcnJvcjogc2VsZWN0ZWQgZGF0YXNldCBub3QgZm91bmQuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgc2VsZWN0ZWREYXRhc2V0cy5mb3JFYWNoKHNlbGVjdGVkRGF0YSA9PiB7XG4gICAgY29uc3Qge2RhdGFDb250YWluZXIsIGZpZWxkcywgbGFiZWwsIGZpbHRlcmVkSWR4Q1BVID0gW119ID0gc2VsZWN0ZWREYXRhIGFzIEtlcGxlclRhYmxlO1xuICAgIGNvbnN0IHRvRXhwb3J0ID0gZmlsdGVyZWRcbiAgICAgID8gY3JlYXRlSW5kZXhlZERhdGFDb250YWluZXIoZGF0YUNvbnRhaW5lciwgZmlsdGVyZWRJZHhDUFUpXG4gICAgICA6IGRhdGFDb250YWluZXI7XG5cbiAgICAvLyBzdGFydCB0byBleHBvcnQgZGF0YSBhY2NvcmRpbmcgdG8gc2VsZWN0ZWQgZGF0YSB0eXBlXG4gICAgc3dpdGNoIChkYXRhVHlwZSkge1xuICAgICAgY2FzZSBFWFBPUlRfREFUQV9UWVBFLkNTVjoge1xuICAgICAgICBjb25zdCBjc3YgPSBmb3JtYXRDc3YodG9FeHBvcnQsIGZpZWxkcyk7XG5cbiAgICAgICAgY29uc3QgZmlsZUJsb2IgPSBuZXcgQmxvYihbY3N2XSwge3R5cGU6ICd0ZXh0L2Nzdid9KTtcbiAgICAgICAgZG93bmxvYWRGaWxlKGZpbGVCbG9iLCBgJHtmaWxlbmFtZX1fJHtsYWJlbH0uY3N2YCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgLy8gVE9ETzogc3VwcG9ydCBtb3JlIGZpbGUgdHlwZXMuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBicmVhaztcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIE9uIGV4cG9ydCBkYXRhIHRvIGNzdlxuICogQHBhcmFtIGRhdGFDb250YWluZXJcbiAqIEBwYXJhbSBmaWVsZHMgYGRhdGFzZXQuZmllbGRzYFxuICogQHJldHVybnMgY3N2IHN0cmluZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0Q3N2KGRhdGE6IERhdGFDb250YWluZXJJbnRlcmZhY2UsIGZpZWxkczogRmllbGRbXSk6IHN0cmluZyB7XG4gIGNvbnN0IGNvbHVtbnMgPSBmaWVsZHMubWFwKGYgPT4gZi5kaXNwbGF5TmFtZSB8fCBmLm5hbWUpO1xuICBjb25zdCBmb3JtYXR0ZWREYXRhID0gW2NvbHVtbnNdO1xuXG4gIC8vIHBhcnNlIGdlb2pzb24gb2JqZWN0IGFzIHN0cmluZ1xuICBmb3IgKGNvbnN0IHJvdyBvZiBkYXRhLnJvd3ModHJ1ZSkpIHtcbiAgICBmb3JtYXR0ZWREYXRhLnB1c2gocm93Lm1hcCgoZCwgaSkgPT4gcGFyc2VGaWVsZFZhbHVlKGQsIGZpZWxkc1tpXS50eXBlKSkpO1xuICB9XG5cbiAgcmV0dXJuIGNzdkZvcm1hdFJvd3MoZm9ybWF0dGVkRGF0YSk7XG59XG5cbmNvbnN0IGV4cG9ydGVycyA9IHtcbiAgZXhwb3J0RGF0YVxufTtcblxuZXhwb3J0IGRlZmF1bHQgZXhwb3J0ZXJzO1xuIl19