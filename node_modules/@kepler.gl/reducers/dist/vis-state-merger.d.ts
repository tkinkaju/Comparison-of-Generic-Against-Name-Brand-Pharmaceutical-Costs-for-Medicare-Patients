import { LayerColumns, LayerColumn, Layer } from '@kepler.gl/layers';
import { Merger, VisState, VisStateMergers, ParsedConfig } from '@kepler.gl/schemas';
import { ParsedLayer, SavedInteractionConfig, TooltipInfo } from '@kepler.gl/types';
import { KeplerTable, Datasets } from '@kepler.gl/table';
/**
 * Merge loaded filters with current state, if no fields or data are loaded
 * save it for later
 *
 */
export declare function mergeFilters<S extends VisState>(state: S, filtersToMerge: NonNullable<ParsedConfig['visState']>['filters'], fromConfig?: boolean): S;
export declare function createLayerFromConfig(state: VisState, layerConfig: any): Layer | null;
export declare function serializeLayer(newLayer: any): ParsedLayer;
/**
 * Merge layers from de-serialized state, if no fields or data are loaded
 * save it for later
 *
 */
export declare function mergeLayers<S extends VisState>(state: S, layersToMerge?: NonNullable<ParsedConfig['visState']>['layers'], fromConfig?: boolean): S;
export declare function insertLayerAtRightOrder(currentLayers: any, layersToInsert: any, currentOrder: any, preservedOrder?: string[]): {
    newLayerOrder: any;
    newLayers: any;
};
/**
 * Merge interactions with saved config
 *
 */
export declare function mergeInteractions<S extends VisState>(state: S, interactionToBeMerged: Partial<SavedInteractionConfig> | undefined, fromConfig?: boolean): S;
/**
 * Merge splitMaps config with current visStete.
 * 1. if current map is split, but splitMap DOESNOT contain maps
 *    : don't merge anything
 * 2. if current map is NOT split, but splitMaps contain maps
 *    : add to splitMaps, and add current layers to splitMaps
 */
export declare function mergeSplitMaps<S extends VisState>(state: S, splitMaps?: NonNullable<ParsedConfig['visState']>['splitMaps'], fromConfig?: boolean): S;
/**
 * Merge interactionConfig.tooltip with saved config,
 * validate fieldsToShow
 *
 * @param state
 * @param tooltipConfig
 * @return - {mergedTooltip: {}, unmergedTooltip: {}}
 */
export declare function mergeInteractionTooltipConfig(state: VisState, tooltipConfig?: Pick<TooltipInfo['config'], 'fieldsToShow'> | null): {
    mergedTooltip: {
        [key: string]: import("@kepler.gl/types").TooltipField[];
    };
    unmergedTooltip: {
        [key: string]: import("@kepler.gl/types").TooltipField[];
    };
};
/**
 * Merge layerBlending with saved
 *
 */
export declare function mergeLayerBlending<S extends VisState>(state: S, layerBlending: NonNullable<ParsedConfig['visState']>['layerBlending'], fromConfig?: boolean): S;
/**
 * Merge animation config
 */
export declare function mergeAnimationConfig<S extends VisState>(state: S, animation: NonNullable<ParsedConfig['visState']>['animationConfig'], fromConfig?: boolean): S;
/**
 * Validate saved layer columns with new data,
 * update fieldIdx based on new fields
 *
 * @param fields
 * @param savedCols
 * @param emptyCols
 * @return - validated columns or null
 */
export declare function validateSavedLayerColumns(fields: KeplerTable['fields'], savedCols: {
    [key: string]: string;
} | undefined, emptyCols: LayerColumns): LayerColumns | null;
export declare function validateColumn(column: LayerColumn & {
    validator?: typeof validateColumn;
}, columns: LayerColumns, allFields: KeplerTable['fields']): boolean;
/**
 * Validate saved text label config with new data
 * refer to vis-state-schema.js TextLabelSchemaV1
 *
 * @param {Array<Object>} fields
 * @param {Object} savedTextLabel
 * @return {Object} - validated textlabel
 */
export declare function validateSavedTextLabel(fields: any, [layerTextLabel]: [any], savedTextLabel: any): {}[];
/**
 * Validate saved visual channels config with new data,
 * refer to vis-state-schema.js VisualChannelSchemaV1
 */
export declare function validateSavedVisualChannels(fields: KeplerTable['fields'], newLayer: Layer, savedLayer: ParsedLayer): null | Layer;
export declare function validateLayersByDatasets(datasets: Datasets, layerClasses: VisState['layerClasses'], layers?: NonNullable<ParsedConfig['visState']>['layers']): {
    validated: Layer[];
    failed: ParsedLayer[];
};
/**
 * Validate saved layer config with new data,
 * update fieldIdx based on new fields
 */
export declare function validateLayerWithData({ fields, id: dataId }: KeplerTable, savedLayer: ParsedLayer, layerClasses: VisState['layerClasses'], options?: {
    allowEmptyColumn?: boolean;
}): Layer | null;
export declare function isValidMerger(merger: Merger): boolean;
export declare const VIS_STATE_MERGERS: VisStateMergers;
