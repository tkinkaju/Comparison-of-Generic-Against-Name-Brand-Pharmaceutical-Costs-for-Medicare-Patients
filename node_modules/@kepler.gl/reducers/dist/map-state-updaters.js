// Copyright (c) 2022 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getMapDimForSplitMap = getMapDimForSplitMap;
exports.toggleSplitMapUpdater = exports.receiveMapConfigUpdater = exports.resetMapConfigUpdater = exports.togglePerspectiveUpdater = exports.fitBoundsUpdater = exports.updateMapUpdater = exports.INITIAL_MAP_STATE = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _utils = require("@kepler.gl/utils");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/**
 * Updaters for `mapState` reducer. Can be used in your root reducer to directly modify kepler.gl's state.
 * Read more about [Using updaters](../advanced-usage/using-updaters.md)
 * @public
 * @example
 *
 * import keplerGlReducer, {mapStateUpdaters} from 'kepler.gl/reducers';
 * // Root Reducer
 * const reducers = combineReducers({
 *  keplerGl: keplerGlReducer,
 *  app: appReducer
 * });
 *
 * const composedReducer = (state, action) => {
 *  switch (action.type) {
 *    // click button to close side panel
 *    case 'CLICK_BUTTON':
 *      return {
 *        ...state,
 *        keplerGl: {
 *          ...state.keplerGl,
 *          foo: {
 *             ...state.keplerGl.foo,
 *             mapState: mapStateUpdaters.fitBoundsUpdater(
 *               mapState, {payload: [127.34, 31.09, 127.56, 31.59]]}
 *             )
 *          }
 *        }
 *      };
 *  }
 *  return reducers(state, action);
 * };
 *
 * export default composedReducer;
 */

/* eslint-disable no-unused-vars */
// @ts-ignore
var mapStateUpdaters = null;
/* eslint-enable no-unused-vars */

/**
 * Default initial `mapState`
 * @memberof mapStateUpdaters
 * @constant
 * @property pitch Default: `0`
 * @property bearing Default: `0`
 * @property latitude Default: `37.75043`
 * @property longitude Default: `-122.34679`
 * @property zoom Default: `9`
 * @property dragRotate Default: `false`
 * @property width Default: `800`
 * @property height Default: `800`
 * @property isSplit Default: `false`
 * @public
 */

var INITIAL_MAP_STATE = {
  pitch: 0,
  bearing: 0,
  latitude: 37.75043,
  longitude: -122.34679,
  zoom: 9,
  dragRotate: false,
  width: 800,
  height: 800,
  isSplit: false
};
/* Updaters */

/**
 * Update map viewport
 * @memberof mapStateUpdaters
 * @public
 */

exports.INITIAL_MAP_STATE = INITIAL_MAP_STATE;

var updateMapUpdater = function updateMapUpdater(state, action) {
  return _objectSpread(_objectSpread({}, state), action.payload || {});
};
/**
 * Fit map viewport to bounds
 * @memberof mapStateUpdaters
 * @public
 */


exports.updateMapUpdater = updateMapUpdater;

var fitBoundsUpdater = function fitBoundsUpdater(state, action) {
  var centerAndZoom = (0, _utils.getCenterAndZoomFromBounds)(action.payload, {
    width: state.width,
    height: state.height
  });

  if (!centerAndZoom) {
    // bounds is invalid
    return state;
  }

  return _objectSpread(_objectSpread({}, state), {}, {
    latitude: centerAndZoom.center[1],
    longitude: centerAndZoom.center[0]
  }, Number.isFinite(centerAndZoom.zoom) ? {
    zoom: centerAndZoom.zoom
  } : {});
};
/**
 * Toggle between 3d and 2d map.
 * @memberof mapStateUpdaters
 * @public
 */


exports.fitBoundsUpdater = fitBoundsUpdater;

var togglePerspectiveUpdater = function togglePerspectiveUpdater(state, action) {
  return _objectSpread(_objectSpread(_objectSpread({}, state), {
    pitch: state.dragRotate ? 0 : 50,
    bearing: state.dragRotate ? 0 : 24
  }), {}, {
    dragRotate: !state.dragRotate
  });
};
/**
 * reset mapState to initial State
 * @memberof mapStateUpdaters
 * @public
 */


exports.togglePerspectiveUpdater = togglePerspectiveUpdater;

var resetMapConfigUpdater = function resetMapConfigUpdater(state) {
  return _objectSpread(_objectSpread(_objectSpread({}, INITIAL_MAP_STATE), state.initialState), {}, {
    initialState: state.initialState
  });
}; // consider case where you have a split map and user wants to reset

/**
 * Update `mapState` to propagate a new config
 * @memberof mapStateUpdaters
 * @public
 */


exports.resetMapConfigUpdater = resetMapConfigUpdater;

var receiveMapConfigUpdater = function receiveMapConfigUpdater(state, _ref) {
  var _ref$payload = _ref.payload,
      _ref$payload$config = _ref$payload.config,
      config = _ref$payload$config === void 0 ? {} : _ref$payload$config,
      _ref$payload$options = _ref$payload.options,
      options = _ref$payload$options === void 0 ? {} : _ref$payload$options,
      _ref$payload$bounds = _ref$payload.bounds,
      bounds = _ref$payload$bounds === void 0 ? null : _ref$payload$bounds;

  var _ref2 = config || {},
      mapState = _ref2.mapState; // merged received mapstate with previous state


  var mergedState = _objectSpread(_objectSpread({}, state), mapState); // if center map
  // center map will override mapState config


  if (options.centerMap && bounds) {
    mergedState = fitBoundsUpdater(mergedState, {
      payload: bounds
    });
  }

  return _objectSpread(_objectSpread({}, mergedState), getMapDimForSplitMap(mergedState.isSplit, state));
};
/**
 * Toggle between one or split maps
 * @memberof mapStateUpdaters
 * @public
 */


exports.receiveMapConfigUpdater = receiveMapConfigUpdater;

var toggleSplitMapUpdater = function toggleSplitMapUpdater(state, action) {
  return _objectSpread(_objectSpread({}, state), {}, {
    isSplit: !state.isSplit
  }, getMapDimForSplitMap(!state.isSplit, state));
}; // Helpers


exports.toggleSplitMapUpdater = toggleSplitMapUpdater;

function getMapDimForSplitMap(isSplit, state) {
  // cases:
  // 1. state split: true - isSplit: true
  // do nothing
  // 2. state split: false - isSplit: false
  // do nothing
  if (state.isSplit === isSplit) {
    return {};
  }

  var width = state.isSplit && !isSplit ? // 3. state split: true - isSplit: false
  // double width
  state.width * 2 : // 4. state split: false - isSplit: true
  // split width
  state.width / 2;
  return {
    width: width
  };
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9tYXAtc3RhdGUtdXBkYXRlcnMudHMiXSwibmFtZXMiOlsibWFwU3RhdGVVcGRhdGVycyIsIklOSVRJQUxfTUFQX1NUQVRFIiwicGl0Y2giLCJiZWFyaW5nIiwibGF0aXR1ZGUiLCJsb25naXR1ZGUiLCJ6b29tIiwiZHJhZ1JvdGF0ZSIsIndpZHRoIiwiaGVpZ2h0IiwiaXNTcGxpdCIsInVwZGF0ZU1hcFVwZGF0ZXIiLCJzdGF0ZSIsImFjdGlvbiIsInBheWxvYWQiLCJmaXRCb3VuZHNVcGRhdGVyIiwiY2VudGVyQW5kWm9vbSIsImNlbnRlciIsIk51bWJlciIsImlzRmluaXRlIiwidG9nZ2xlUGVyc3BlY3RpdmVVcGRhdGVyIiwicmVzZXRNYXBDb25maWdVcGRhdGVyIiwiaW5pdGlhbFN0YXRlIiwicmVjZWl2ZU1hcENvbmZpZ1VwZGF0ZXIiLCJjb25maWciLCJvcHRpb25zIiwiYm91bmRzIiwibWFwU3RhdGUiLCJtZXJnZWRTdGF0ZSIsImNlbnRlck1hcCIsImdldE1hcERpbUZvclNwbGl0TWFwIiwidG9nZ2xlU3BsaXRNYXBVcGRhdGVyIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFvQkE7Ozs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBLElBQU1BLGdCQUFnQixHQUFHLElBQXpCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNPLElBQU1DLGlCQUEyQixHQUFHO0FBQ3pDQyxFQUFBQSxLQUFLLEVBQUUsQ0FEa0M7QUFFekNDLEVB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QUFDQSxNQUFJRixPQUFPLENBQUNJLFNBQVIsSUFBcUJILE1BQXpCLEVBQWlDO0FBQy9CRSxJQUFBQSxXQUFXLEdBQUdiLGdCQUFnQixDQUFDYSxXQUFELEVBQWM7QUFDMUNkLE1BQUFBLE9BQU8sRUFBRVk7QUFEaUMsS0FBZCxDQUE5QjtBQUdEOztBQUVELHlDQUNLRSxXQURMLEdBR0tFLG9CQUFvQixDQUFDRixXQUFXLENBQUNsQixPQUFiLEVBQXNCRSxLQUF0QixDQUh6QjtBQUtELENBNUJNO0FBOEJQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBQ08sSUFBTW1CLHFCQUFxQixHQUFHLFNBQXhCQSxxQkFBd0IsQ0FDbkNuQixLQURtQyxFQUVuQ0MsTUFGbUM7QUFBQSx5Q0FJaENELEtBSmdDO0FBS25DRixJQUFBQSxPQUFPLEVBQUUsQ0FBQ0UsS0FBSyxDQUFDRjtBQUxtQixLQU1oQ29CLG9CQUFvQixDQUFDLENBQUNsQixLQUFLLENBQUNGLE9BQVIsRUFBaUJFLEtBQWpCLENBTlk7QUFBQSxDQUE5QixDLENBU1A7Ozs7O0FBQ08sU0FBU2tCLG9CQUFULENBQThCcEIsT0FBOUIsRUFBdUNFLEtBQXZDLEVBQThDO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFJQSxLQUFLLENBQUNGLE9BQU4sS0FBa0JBLE9BQXRCLEVBQStCO0FBQzdCLFdBQU8sRUFBUDtBQUNEOztBQUVELE1BQU1GLEtBQUssR0FDVEksS0FBSyxDQUFDRixPQUFOLElBQWlCLENBQUNBLE9BQWxCLEdBQ0k7QUFDQTtBQUNBRSxFQUFBQSxLQUFLLENBQUNKLEtBQU4sR0FBYyxDQUhsQixHQUlJO0FBQ0E7QUFDQUksRUFBQUEsS0FBSyxDQUFDSixLQUFOLEdBQWMsQ0FQcEI7QUFTQSxTQUFPO0FBQ0xBLElBQUFBLEtBQUssRUFBTEE7QUFESyxHQUFQO0FBR0QiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMjIgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5pbXBvcnQge2dldENlbnRlckFuZFpvb21Gcm9tQm91bmRzfSBmcm9tICdAa2VwbGVyLmdsL3V0aWxzJztcbmltcG9ydCB7TWFwU3RhdGVBY3Rpb25zLCBSZWNlaXZlTWFwQ29uZmlnUGF5bG9hZCwgQWN0aW9uVHlwZXN9IGZyb20gJ0BrZXBsZXIuZ2wvYWN0aW9ucyc7XG5pbXBvcnQge01hcFN0YXRlfSBmcm9tICdAa2VwbGVyLmdsL3R5cGVzJztcblxuLyoqXG4gKiBVcGRhdGVycyBmb3IgYG1hcFN0YXRlYCByZWR1Y2VyLiBDYW4gYmUgdXNlZCBpbiB5b3VyIHJvb3QgcmVkdWNlciB0byBkaXJlY3RseSBtb2RpZnkga2VwbGVyLmdsJ3Mgc3RhdGUuXG4gKiBSZWFkIG1vcmUgYWJvdXQgW1VzaW5nIHVwZGF0ZXJzXSguLi9hZHZhbmNlZC11c2FnZS91c2luZy11cGRhdGVycy5tZClcbiAqIEBwdWJsaWNcbiAqIEBleGFtcGxlXG4gKlxuICogaW1wb3J0IGtlcGxlckdsUmVkdWNlciwge21hcFN0YXRlVXBkYXRlcnN9IGZyb20gJ2tlcGxlci5nbC9yZWR1Y2Vycyc7XG4gKiAvLyBSb290IFJlZHVjZXJcbiAqIGNvbnN0IHJlZHVjZXJzID0gY29tYmluZVJlZHVjZXJzKHtcbiAqICBrZXBsZXJHbDoga2VwbGVyR2xSZWR1Y2VyLFxuICogIGFwcDogYXBwUmVkdWNlclxuICogfSk7XG4gKlxuICogY29uc3QgY29tcG9zZWRSZWR1Y2VyID0gKHN0YXRlLCBhY3Rpb24pID0+IHtcbiAqICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gKiAgICAvLyBjbGljayBidXR0b24gdG8gY2xvc2Ugc2lkZSBwYW5lbFxuICogICAgY2FzZSAnQ0xJQ0tfQlVUVE9OJzpcbiAqICAgICAgcmV0dXJuIHtcbiAqICAgICAgICAuLi5zdGF0ZSxcbiAqICAgICAgICBrZXBsZXJHbDoge1xuICogICAgICAgICAgLi4uc3RhdGUua2VwbGVyR2wsXG4gKiAgICAgICAgICBmb286IHtcbiAqICAgICAgICAgICAgIC4uLnN0YXRlLmtlcGxlckdsLmZvbyxcbiAqICAgICAgICAgICAgIG1hcFN0YXRlOiBtYXBTdGF0ZVVwZGF0ZXJzLmZpdEJvdW5kc1VwZGF0ZXIoXG4gKiAgICAgICAgICAgICAgIG1hcFN0YXRlLCB7cGF5bG9hZDogWzEyNy4zNCwgMzEuMDksIDEyNy41NiwgMzEuNTldXX1cbiAqICAgICAgICAgICAgIClcbiAqICAgICAgICAgIH1cbiAqICAgICAgICB9XG4gKiAgICAgIH07XG4gKiAgfVxuICogIHJldHVybiByZWR1Y2VycyhzdGF0ZSwgYWN0aW9uKTtcbiAqIH07XG4gKlxuICogZXhwb3J0IGRlZmF1bHQgY29tcG9zZWRSZWR1Y2VyO1xuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuLy8gQHRzLWlnbm9yZVxuY29uc3QgbWFwU3RhdGVVcGRhdGVycyA9IG51bGw7XG4vKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC12YXJzICovXG5cbi8qKlxuICogRGVmYXVsdCBpbml0aWFsIGBtYXBTdGF0ZWBcbiAqIEBtZW1iZXJvZiBtYXBTdGF0ZVVwZGF0ZXJzXG4gKiBAY29uc3RhbnRcbiAqIEBwcm9wZXJ0eSBwaXRjaCBEZWZhdWx0OiBgMGBcbiAqIEBwcm9wZXJ0eSBiZWFyaW5nIERlZmF1bHQ6IGAwYFxuICogQHByb3BlcnR5IGxhdGl0dWRlIERlZmF1bHQ6IGAzNy43NTA0M2BcbiAqIEBwcm9wZXJ0eSBsb25naXR1ZGUgRGVmYXVsdDogYC0xMjIuMzQ2NzlgXG4gKiBAcHJvcGVydHkgem9vbSBEZWZhdWx0OiBgOWBcbiAqIEBwcm9wZXJ0eSBkcmFnUm90YXRlIERlZmF1bHQ6IGBmYWxzZWBcbiAqIEBwcm9wZXJ0eSB3aWR0aCBEZWZhdWx0OiBgODAwYFxuICogQHByb3BlcnR5IGhlaWdodCBEZWZhdWx0OiBgODAwYFxuICogQHByb3BlcnR5IGlzU3BsaXQgRGVmYXVsdDogYGZhbHNlYFxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgSU5JVElBTF9NQVBfU1RBVEU6IE1hcFN0YXRlID0ge1xuICBwaXRjaDogMCxcbiAgYmVhcmluZzogMCxcbiAgbGF0aXR1ZGU6IDM3Ljc1MDQzLFxuICBsb25naXR1ZGU6IC0xMjIuMzQ2NzksXG4gIHpvb206IDksXG4gIGRyYWdSb3RhdGU6IGZhbHNlLFxuICB3aWR0aDogODAwLFxuICBoZWlnaHQ6IDgwMCxcbiAgaXNTcGxpdDogZmFsc2Vcbn07XG5cbi8qIFVwZGF0ZXJzICovXG4vKipcbiAqIFVwZGF0ZSBtYXAgdmlld3BvcnRcbiAqIEBtZW1iZXJvZiBtYXBTdGF0ZVVwZGF0ZXJzXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCB1cGRhdGVNYXBVcGRhdGVyID0gKFxuICBzdGF0ZTogTWFwU3RhdGUsXG4gIGFjdGlvbjogTWFwU3RhdGVBY3Rpb25zLlVwZGF0ZU1hcFVwZGF0ZXJBY3Rpb25cbik6IE1hcFN0YXRlID0+ICh7XG4gIC4uLnN0YXRlLFxuICAuLi4oYWN0aW9uLnBheWxvYWQgfHwge30pXG59KTtcblxuLyoqXG4gKiBGaXQgbWFwIHZpZXdwb3J0IHRvIGJvdW5kc1xuICogQG1lbWJlcm9mIG1hcFN0YXRlVXBkYXRlcnNcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IGZpdEJvdW5kc1VwZGF0ZXIgPSAoXG4gIHN0YXRlOiBNYXBTdGF0ZSxcbiAgYWN0aW9uOiBNYXBTdGF0ZUFjdGlvbnMuRml0Qm91bmRzVXBkYXRlckFjdGlvblxuKTogTWFwU3RhdGUgPT4ge1xuICBjb25zdCBjZW50ZXJBbmRab29tID0gZ2V0Q2VudGVyQW5kWm9vbUZyb21Cb3VuZHMoYWN0aW9uLnBheWxvYWQsIHtcbiAgICB3aWR0aDogc3RhdGUud2lkdGgsXG4gICAgaGVpZ2h0OiBzdGF0ZS5oZWlnaHRcbiAgfSk7XG4gIGlmICghY2VudGVyQW5kWm9vbSkge1xuICAgIC8vIGJvdW5kcyBpcyBpbnZhbGlkXG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICAuLi5zdGF0ZSxcbiAgICBsYXRpdHVkZTogY2VudGVyQW5kWm9vbS5jZW50ZXJbMV0sXG4gICAgbG9uZ2l0dWRlOiBjZW50ZXJBbmRab29tLmNlbnRlclswXSxcbiAgICAvLyBGb3IgbWFyZ2luYWwgb3IgaW52YWxpZCBib3VuZHMsIHpvb20gbWF5IGJlIE5hTi4gTWFrZSBzdXJlIHRvIHByb3ZpZGUgYSB2YWxpZCB2YWx1ZSBpbiBvcmRlclxuICAgIC8vIHRvIGF2b2lkIGNvcnJ1cHQgc3RhdGUgYW5kIHBvdGVudGlhbCBjcmFzaGVzIGFzIHpvb20gaXMgZXhwZWN0ZWQgdG8gYmUgYSBudW1iZXJcbiAgICAuLi4oTnVtYmVyLmlzRmluaXRlKGNlbnRlckFuZFpvb20uem9vbSkgPyB7em9vbTogY2VudGVyQW5kWm9vbS56b29tfSA6IHt9KVxuICB9O1xufTtcblxuLyoqXG4gKiBUb2dnbGUgYmV0d2VlbiAzZCBhbmQgMmQgbWFwLlxuICogQG1lbWJlcm9mIG1hcFN0YXRlVXBkYXRlcnNcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IHRvZ2dsZVBlcnNwZWN0aXZlVXBkYXRlciA9IChcbiAgc3RhdGU6IE1hcFN0YXRlLFxuICBhY3Rpb246IE1hcFN0YXRlQWN0aW9ucy5Ub2dnbGVQZXJzcGVjdGl2ZVVwZGF0ZXJBY3Rpb25cbik6IE1hcFN0YXRlID0+ICh7XG4gIC4uLnN0YXRlLFxuICAuLi57XG4gICAgcGl0Y2g6IHN0YXRlLmRyYWdSb3RhdGUgPyAwIDogNTAsXG4gICAgYmVhcmluZzogc3RhdGUuZHJhZ1JvdGF0ZSA/IDAgOiAyNFxuICB9LFxuICBkcmFnUm90YXRlOiAhc3RhdGUuZHJhZ1JvdGF0ZVxufSk7XG5cbi8qKlxuICogcmVzZXQgbWFwU3RhdGUgdG8gaW5pdGlhbCBTdGF0ZVxuICogQG1lbWJlcm9mIG1hcFN0YXRlVXBkYXRlcnNcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IHJlc2V0TWFwQ29uZmlnVXBkYXRlciA9IChzdGF0ZTogTWFwU3RhdGUpOiBNYXBTdGF0ZSA9PiAoe1xuICAuLi5JTklUSUFMX01BUF9TVEFURSxcbiAgLi4uc3RhdGUuaW5pdGlhbFN0YXRlLFxuICBpbml0aWFsU3RhdGU6IHN0YXRlLmluaXRpYWxTdGF0ZVxufSk7XG5cbi8vIGNvbnNpZGVyIGNhc2Ugd2hlcmUgeW91IGhhdmUgYSBzcGxpdCBtYXAgYW5kIHVzZXIgd2FudHMgdG8gcmVzZXRcbi8qKlxuICogVXBkYXRlIGBtYXBTdGF0ZWAgdG8gcHJvcGFnYXRlIGEgbmV3IGNvbmZpZ1xuICogQG1lbWJlcm9mIG1hcFN0YXRlVXBkYXRlcnNcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IHJlY2VpdmVNYXBDb25maWdVcGRhdGVyID0gKFxuICBzdGF0ZTogTWFwU3RhdGUsXG4gIHtcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgcGF5bG9hZDoge2NvbmZpZyA9IHt9LCBvcHRpb25zID0ge30sIGJvdW5kcyA9IG51bGx9XG4gIH06IHtcbiAgICB0eXBlPzogdHlwZW9mIEFjdGlvblR5cGVzLlJFQ0VJVkVfTUFQX0NPTkZJRztcbiAgICBwYXlsb2FkOiBSZWNlaXZlTWFwQ29uZmlnUGF5bG9hZDtcbiAgfVxuKTogTWFwU3RhdGUgPT4ge1xuICBjb25zdCB7bWFwU3RhdGV9ID0gY29uZmlnIHx8IHt9O1xuXG4gIC8vIG1lcmdlZCByZWNlaXZlZCBtYXBzdGF0ZSB3aXRoIHByZXZpb3VzIHN0YXRlXG4gIGxldCBtZXJnZWRTdGF0ZSA9IHsuLi5zdGF0ZSwgLi4ubWFwU3RhdGV9O1xuXG4gIC8vIGlmIGNlbnRlciBtYXBcbiAgLy8gY2VudGVyIG1hcCB3aWxsIG92ZXJyaWRlIG1hcFN0YXRlIGNvbmZpZ1xuICBpZiAob3B0aW9ucy5jZW50ZXJNYXAgJiYgYm91bmRzKSB7XG4gICAgbWVyZ2VkU3RhdGUgPSBmaXRCb3VuZHNVcGRhdGVyKG1lcmdlZFN0YXRlLCB7XG4gICAgICBwYXlsb2FkOiBib3VuZHNcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgLi4ubWVyZ2VkU3RhdGUsXG4gICAgLy8gdXBkYXRlIHdpZHRoIGlmIGBpc1NwbGl0YCBoYXMgY2hhbmdlZFxuICAgIC4uLmdldE1hcERpbUZvclNwbGl0TWFwKG1lcmdlZFN0YXRlLmlzU3BsaXQsIHN0YXRlKVxuICB9O1xufTtcblxuLyoqXG4gKiBUb2dnbGUgYmV0d2VlbiBvbmUgb3Igc3BsaXQgbWFwc1xuICogQG1lbWJlcm9mIG1hcFN0YXRlVXBkYXRlcnNcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IHRvZ2dsZVNwbGl0TWFwVXBkYXRlciA9IChcbiAgc3RhdGU6IE1hcFN0YXRlLFxuICBhY3Rpb246IE1hcFN0YXRlQWN0aW9ucy5Ub2dnbGVTcGxpdE1hcFVwZGF0ZXJBY3Rpb25cbik6IE1hcFN0YXRlID0+ICh7XG4gIC4uLnN0YXRlLFxuICBpc1NwbGl0OiAhc3RhdGUuaXNTcGxpdCxcbiAgLi4uZ2V0TWFwRGltRm9yU3BsaXRNYXAoIXN0YXRlLmlzU3BsaXQsIHN0YXRlKVxufSk7XG5cbi8vIEhlbHBlcnNcbmV4cG9ydCBmdW5jdGlvbiBnZXRNYXBEaW1Gb3JTcGxpdE1hcChpc1NwbGl0LCBzdGF0ZSkge1xuICAvLyBjYXNlczpcbiAgLy8gMS4gc3RhdGUgc3BsaXQ6IHRydWUgLSBpc1NwbGl0OiB0cnVlXG4gIC8vIGRvIG5vdGhpbmdcbiAgLy8gMi4gc3RhdGUgc3BsaXQ6IGZhbHNlIC0gaXNTcGxpdDogZmFsc2VcbiAgLy8gZG8gbm90aGluZ1xuICBpZiAoc3RhdGUuaXNTcGxpdCA9PT0gaXNTcGxpdCkge1xuICAgIHJldHVybiB7fTtcbiAgfVxuXG4gIGNvbnN0IHdpZHRoID1cbiAgICBzdGF0ZS5pc1NwbGl0ICYmICFpc1NwbGl0XG4gICAgICA/IC8vIDMuIHN0YXRlIHNwbGl0OiB0cnVlIC0gaXNTcGxpdDogZmFsc2VcbiAgICAgICAgLy8gZG91YmxlIHdpZHRoXG4gICAgICAgIHN0YXRlLndpZHRoICogMlxuICAgICAgOiAvLyA0LiBzdGF0ZSBzcGxpdDogZmFsc2UgLSBpc1NwbGl0OiB0cnVlXG4gICAgICAgIC8vIHNwbGl0IHdpZHRoXG4gICAgICAgIHN0YXRlLndpZHRoIC8gMjtcblxuICByZXR1cm4ge1xuICAgIHdpZHRoXG4gIH07XG59XG4iXX0=