// Copyright (c) 2022 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.findDefaultLayer = findDefaultLayer;
exports.calculateLayerData = calculateLayerData;
exports.getLayerHoverProp = getLayerHoverProp;
exports.renderDeckGlLayer = renderDeckGlLayer;
exports.isLayerRenderable = isLayerRenderable;
exports.isLayerVisible = isLayerVisible;
exports.prepareLayersForDeck = prepareLayersForDeck;
exports.prepareLayersToRender = prepareLayersToRender;
exports.getCustomDeckLayers = getCustomDeckLayers;
exports.computeDeckLayers = computeDeckLayers;

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _constants = require("@kepler.gl/constants");

var _layers = require("@kepler.gl/layers");

var _utils = require("@kepler.gl/utils");

var _deckglLayers = require("@kepler.gl/deckgl-layers");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/**
 * Find default layers from fields
 */
function findDefaultLayer(dataset, layerClasses) {
  if (!dataset) {
    return [];
  }

  var layerProps = Object.keys(layerClasses).reduce(function (previous, lc) {
    var result = typeof layerClasses[lc].findDefaultLayerProps === 'function' ? layerClasses[lc].findDefaultLayerProps(dataset, previous) : {
      props: []
    };
    var props = Array.isArray(result) ? result : result.props || [];
    var foundLayers = result.foundLayers || previous;
    return foundLayers.concat(props.map(function (p) {
      return _objectSpread(_objectSpread({}, p), {}, {
        type: lc,
        dataId: dataset.id
      });
    }));
  }, []); // go through all layerProps to create layer

  return layerProps.map(function (props) {
    // @ts-expect-error TODO: checking props.type !== null
    var layer = new layerClasses[props.type](props);
    return typeof layer.setInitialLayerConfig === 'function' && dataset.dataContainer ? layer.setInitialLayerConfig(dataset) : layer;
  });
}
/**
 * calculate layer data based on layer type, col Config,
 * return updated layer if colorDomain, dataMap has changed
 */


function calculateLayerData(layer, state, oldLayerData) {
  var type = layer.type;

  if (!type || !layer.hasAllColumns() || !layer.config.dataId) {
    return {
      layer: layer,
      layerData: {}
    };
  }

  var layerData = layer.formatLayerData(state.datasets, oldLayerData);
  return {
    layerData: layerData,
    layer: layer
  };
}
/**
 * Calculate props passed to LayerHoverInfo
 * @type {typeof import('./layer-utils').getLayerHoverProp}
 */


function getLayerHoverProp(_ref) {
  var interactionConfig = _ref.interactionConfig,
      hoverInfo = _ref.hoverInfo,
      layers = _ref.layers,
      layersToRender = _ref.layersToRender,
      datasets = _ref.datasets;

  if (interactionConfig.tooltip.enabled && hoverInfo && hoverInfo.picked) {
    // if anything hovered
    var object = hoverInfo.object,
        overlay = hoverInfo.layer; // deckgl layer to kepler-gl layer

    var layer = layers[overlay.props.idx];

    if (object && layer && layer.getHoverData && layersToRender[layer.id]) {
      // if layer is visible and have hovered data
      var dataId = layer.config.dataId;

      if (!dataId) {
        return null;
      }

      var _datasets$dataId = datasets[dataId],
          dataContainer = _datasets$dataId.dataContainer,
          fields = _datasets$dataId.fields;
      var data = layer.getHoverData(object, dataContainer, fields);
      var fieldsToShow = interactionConfig.tooltip.config.fieldsToShow[dataId];
      return {
        data: data,
        fields: fields,
        fieldsToShow: fieldsToShow,
        layer: layer
      };
    }
  }

  return null;
}

function renderDeckGlLayer(props, layerCallbacks, idx) {
  var datasets = props.datasets,
      layers = props.layers,
      layerData = props.layerData,
      hoverInfo = props.hoverInfo,
      clicked = props.clicked,
      mapState = props.mapState,
      interactionConfig = props.interactionConfig,
      animationConfig = props.animationConfig,
      mapLayers = props.mapLayers;
  var layer = layers[idx];
  var data = layerData[idx];

  var _ref2 = datasets[layer.config.dataId] || {},
      gpuFilter = _ref2.gpuFilter;

  var objectHovered = clicked || hoverInfo;
  var visible = !mapLayers || mapLayers && mapLayers[layer.id]; // Layer is Layer class

  return layer.renderLayer({
    data: data,
    gpuFilter: gpuFilter,
    idx: idx,
    interactionConfig: interactionConfig,
    layerCallbacks: layerCallbacks,
    mapState: mapState,
    animationConfig: animationConfig,
    objectHovered: objectHovered,
    visible: visible
  });
}

function isLayerRenderable(layer, layerData) {
  return layer.id !== _constants.GEOCODER_LAYER_ID && layer.shouldRenderLayer(layerData);
}

function isLayerVisible(layer, mapLayers) {
  return layer.config.isVisible && ( // if layer.id is not in mapLayers, don't render it
  !mapLayers || mapLayers && mapLayers[layer.id]);
} // Prepare a dict of layers rendered by the deck.gl
// Note, isVisible: false layer is passed to deck.gl here
// return {[id]: true \ false}


function prepareLayersForDeck(layers, layerData) {
  return layers.reduce(function (accu, layer, idx) {
    return _objectSpread(_objectSpread({}, accu), {}, (0, _defineProperty2["default"])({}, layer.id, isLayerRenderable(layer, layerData[idx]) && layer.overlayType === _layers.OVERLAY_TYPE_CONST.deckgl));
  }, {});
} // Prepare a dict of rendered layers rendered in the map
// This includes only the visibile layers for single map view and split map view
// return {[id]: true \ false}


function prepareLayersToRender(layers, layerData, mapLayers) {
  return layers.reduce(function (accu, layer, idx) {
    return _objectSpread(_objectSpread({}, accu), {}, (0, _defineProperty2["default"])({}, layer.id, isLayerRenderable(layer, layerData[idx]) && isLayerVisible(layer, mapLayers)));
  }, {});
}

function getCustomDeckLayers(deckGlProps) {
  var bottomDeckLayers = Array.isArray(deckGlProps === null || deckGlProps === void 0 ? void 0 : deckGlProps.layers) ? deckGlProps === null || deckGlProps === void 0 ? void 0 : deckGlProps.layers : (0, _utils.isFunction)(deckGlProps === null || deckGlProps === void 0 ? void 0 : deckGlProps.layers) ? deckGlProps === null || deckGlProps === void 0 ? void 0 : deckGlProps.layers() : [];
  var topDeckLayers = Array.isArray(deckGlProps === null || deckGlProps === void 0 ? void 0 : deckGlProps.topLayers) ? deckGlProps === null || deckGlProps === void 0 ? void 0 : deckGlProps.topLayers : (0, _utils.isFunction)(deckGlProps === null || deckGlProps === void 0 ? void 0 : deckGlProps.topLayers) ? deckGlProps === null || deckGlProps === void 0 ? void 0 : deckGlProps.topLayers() : [];
  return [bottomDeckLayers, topDeckLayers];
}

function computeDeckLayers(_ref3, options, _onSetLayerDomain, deckGlProps) {
  var visState = _ref3.visState,
      mapState = _ref3.mapState,
      mapStyle = _ref3.mapStyle;
  var datasets = visState.datasets,
      layers = visState.layers,
      layerOrder = visState.layerOrder,
      layerData = visState.layerData,
      hoverInfo = visState.hoverInfo,
      clicked = visState.clicked,
      interactionConfig = visState.interactionConfig,
      animationConfig = visState.animationConfig,
      splitMaps = visState.splitMaps;

  var _ref4 = options || {},
      mapIndex = _ref4.mapIndex,
      mapboxApiAccessToken = _ref4.mapboxApiAccessToken,
      mapboxApiUrl = _ref4.mapboxApiUrl,
      primaryMap = _ref4.primaryMap,
      layersForDeck = _ref4.layersForDeck;

  var dataLayers = [];

  if (layerData && layerData.length) {
    var mapLayers = (0, _utils.getMapLayersFromSplitMaps)(splitMaps, mapIndex || 0);
    var currentLayersForDeck = layersForDeck || prepareLayersForDeck(layers, layerData);
    dataLayers = layerOrder.slice().reverse().filter(function (idx) {
      return currentLayersForDeck[layers[idx].id];
    }).reduce(function (overlays, idx) {
      var layerCallbacks = _onSetLayerDomain ? {
        onSetLayerDomain: function onSetLayerDomain(val) {
          return _onSetLayerDomain(idx, val);
        }
      } : {};
      var layerOverlay = renderDeckGlLayer({
        datasets: datasets,
        layers: layers,
        layerData: layerData,
        hoverInfo: hoverInfo,
        clicked: clicked,
        mapState: mapState,
        interactionConfig: interactionConfig,
        animationConfig: animationConfig,
        mapLayers: mapLayers
      }, layerCallbacks, idx);
      return overlays.concat(layerOverlay || []);
    }, []);
  }

  if (!primaryMap) {
    return dataLayers;
  }

  if (mapStyle !== null && mapStyle !== void 0 && mapStyle.visibleLayerGroups['3d building'] && primaryMap && mapboxApiAccessToken && mapboxApiUrl) {
    dataLayers.push(new _deckglLayers.ThreeDBuildingLayer({
      id: '_keplergl_3d-building',
      mapboxApiAccessToken: mapboxApiAccessToken,
      mapboxApiUrl: mapboxApiUrl,
      threeDBuildingColor: mapStyle.threeDBuildingColor,
      updateTriggers: {
        getFillColor: mapStyle.threeDBuildingColor
      }
    }));
  }

  var _getCustomDeckLayers = getCustomDeckLayers(deckGlProps),
      _getCustomDeckLayers2 = (0, _slicedToArray2["default"])(_getCustomDeckLayers, 2),
      customBottomDeckLayers = _getCustomDeckLayers2[0],
      customTopDeckLayers = _getCustomDeckLayers2[1];

  return [].concat((0, _toConsumableArray2["default"])(customBottomDeckLayers), (0, _toConsumableArray2["default"])(dataLayers), (0, _toConsumableArray2["default"])(customTopDeckLayers));
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9sYXllci11dGlscy50cyJdLCJuYW1lcyI6WyJmaW5kRGVmYXVsdExheWVyIiwiZGF0YXNldCIsImxheWVyQ2xhc3NlcyIsImxheWVyUHJvcHMiLCJPYmplY3QiLCJrZXlzIiwicmVkdWNlIiwicHJldmlvdXMiLCJsYyIsInJlc3VsdCIsImZpbmREZWZhdWx0TGF5ZXJQcm9wcyIsInByb3BzIiwiQXJyYXkiLCJpc0FycmF5IiwiZm91bmRMYXllcnMiLCJjb25jYXQiLCJtYXAiLCJwIiwidHlwZSIsImRhdGFJZCIsImlkIiwibGF5ZXIiLCJzZXRJbml0aWFsTGF5ZXJDb25maWciLCJkYXRhQ29udGFpbmVyIiwiY2FsY3VsYXRlTGF5ZXJEYXRhIiwic3RhdGUiLCJvbGRMYXllckRhdGEiLCJoYXNBbGxDb2x1bW5zIiwiY29uZmlnIiwibGF5ZXJEYXRhIiwiZm9ybWF0TGF5ZXJEYXRhIiwiZGF0YXNldHMiLCJnZXRMYXllckhvdmVyUHJvcCIsImludGVyYWN0aW9uQ29uZmlnIiwiaG92ZXJJbmZvIiwibGF5ZXJzIiwibGF5ZXJzVG9SZW5kZXIiLCJ0b29sdGlwIiwiZW5hYmxlZCIsInBpY2tlZCIsIm9iamVjdCIsIm92ZXJsYXkiLCJpZHgiLCJnZXRIb3ZlckRhdGEiLCJmaWVsZHMiLCJkYXRhIiwiZmllbGRzVG9TaG93IiwicmVuZGVyRGVja0dsTGF5ZXIiLCJsYXllckNhbGxiYWNrcyIsImNsaWNrZWQiLCJtYXBTdGF0ZSIsImFuaW1hdGlvbkNvbmZpZyIsIm1hcExheWVycyIsImdwdUZpbHRlciIsIm9iamVjdEhvdmVyZWQiLCJ2aXNpYmxlIiwicmVuZGVyTGF5ZXIiLCJpc0xheWVyUmVuZGVyYWJsZSIsIkdFT0NPREVSX0xBWUVSX0lEIiwic2hvdWxkUmVuZGVyTGF5ZXIiLCJpc0xheWVyVmlzaWJsZSIsImlzVmlzaWJsZSIsInByZXBhcmVMYXllcnNGb3JEZWNrIiwiYWNjdSIsIm92ZXJsYXlUeXBlIiwiT1ZFUkxBWV9UWVBFX0NPTlNUIiwiZGVja2dsIiwicHJlcGFyZUxheWVyc1RvUmVuZGVyIiwiZ2V0Q3VzdG9tRGVja0xheWVycyIsImRlY2tHbFByb3BzIiwiYm90dG9tRGVja0xheWVycyIsInRvcERlY2tMYXllcnMiLCJ0b3BMYXllcnMiLCJjb21wdXRlRGVja0xheWVycyIsIm9wdGlvbnMiLCJvblNldExheWVyRG9tYWluIiwidmlzU3RhdGUiLCJtYXBTdHlsZSIsImxheWVyT3JkZXIiLCJzcGxpdE1hcHMiLCJtYXBJbmRleCIsIm1hcGJveEFwaUFjY2Vzc1Rva2VuIiwibWFwYm94QXBpVXJsIiwicHJpbWFyeU1hcCIsImxheWVyc0ZvckRlY2siLCJkYXRhTGF5ZXJzIiwibGVuZ3RoIiwiY3VycmVudExheWVyc0ZvckRlY2siLCJzbGljZSIsInJldmVyc2UiLCJmaWx0ZXIiLCJvdmVybGF5cyIsInZhbCIsImxheWVyT3ZlcmxheSIsInZpc2libGVMYXllckdyb3VwcyIsInB1c2giLCJUaHJlZURCdWlsZGluZ0xheWVyIiwidGhyZWVEQnVpbGRpbmdDb2xvciIsInVwZGF0ZVRyaWdnZXJzIiwiZ2V0RmlsbENvbG9yIiwiY3VzdG9tQm90dG9tRGVja0xheWVycyIsImN1c3RvbVRvcERlY2tMYXllcnMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW9CQTs7QUFRQTs7QUFTQTs7QUFDQTs7Ozs7O0FBaUJBO0FBQ0E7QUFDQTtBQUNPLFNBQVNBLGdCQUFULENBQTBCQyxPQUExQixFQUFnREMsWUFBaEQsRUFBeUY7QUFDOUYsTUFBSSxDQUFDRCxPQUFMLEVBQWM7QUFDWixXQUFPLEVBQVA7QUFDRDs7QUFDRCxNQUFNRSxVQUFVLEdBQUlDLE1BQU0sQ0FBQ0MsSUFBUCxDQUFZSCxZQUFaLENBQUQsQ0FBNkRJLE1BQTdELENBQ2pCLFVBQUNDLFFBQUQsRUFBV0MsRUFBWCxFQUFrQjtBQUNoQixRQUFNQyxNQUF3QyxHQUM1QyxPQUFPUCxZQUFZLENBQUNNLEVBQUQsQ0FBWixDQUFpQkUscUJBQXhCLEtBQWtELFVBQWxE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Qjs7QUE0RVQsdURBQVdELHNCQUFYLHVDQUFzQ2YsVUFBdEMsdUNBQXFEZ0IsbUJBQXJEO0FBQ0QiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMjIgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5pbXBvcnQge0dFT0NPREVSX0xBWUVSX0lEfSBmcm9tICdAa2VwbGVyLmdsL2NvbnN0YW50cyc7XG5pbXBvcnQge1xuICBGaWVsZCxcbiAgVG9vbHRpcEZpZWxkLFxuICBDb21wYXJlVHlwZSxcbiAgU3BsaXRNYXBMYXllcnMsXG4gIEludGVyYWN0aW9uQ29uZmlnXG59IGZyb20gJ0BrZXBsZXIuZ2wvdHlwZXMnO1xuaW1wb3J0IHtcbiAgRmluZERlZmF1bHRMYXllclByb3BzUmV0dXJuVmFsdWUsXG4gIExheWVyLFxuICBMYXllckNsYXNzZXNUeXBlLFxuICBPVkVSTEFZX1RZUEVfQ09OU1Rcbn0gZnJvbSAnQGtlcGxlci5nbC9sYXllcnMnO1xuXG5pbXBvcnQgS2VwbGVyVGFibGUsIHtEYXRhc2V0c30gZnJvbSAnQGtlcGxlci5nbC90YWJsZSc7XG5pbXBvcnQge1Zpc1N0YXRlfSBmcm9tICdAa2VwbGVyLmdsL3NjaGVtYXMnO1xuaW1wb3J0IHtpc0Z1bmN0aW9uLCBnZXRNYXBMYXllcnNGcm9tU3BsaXRNYXBzLCBEYXRhUm93fSBmcm9tICdAa2VwbGVyLmdsL3V0aWxzJztcbmltcG9ydCB7VGhyZWVEQnVpbGRpbmdMYXllcn0gZnJvbSAnQGtlcGxlci5nbC9kZWNrZ2wtbGF5ZXJzJztcblxuZXhwb3J0IHR5cGUgTGF5ZXJzVG9SZW5kZXIgPSB7XG4gIFtsYXllcklkOiBzdHJpbmddOiBib29sZWFuO1xufTtcblxuZXhwb3J0IHR5cGUgQWdncmVnYXRpb25MYXllckhvdmVyRGF0YSA9IHtwb2ludHM6IGFueVtdOyBjb2xvclZhbHVlPzogYW55OyBlbGV2YXRpb25WYWx1ZT86IGFueX07XG5cbmV4cG9ydCB0eXBlIExheWVySG92ZXJQcm9wID0ge1xuICBkYXRhOiBEYXRhUm93IHwgQWdncmVnYXRpb25MYXllckhvdmVyRGF0YSB8IG51bGw7XG4gIGZpZWxkczogRmllbGRbXTtcbiAgZmllbGRzVG9TaG93OiBUb29sdGlwRmllbGRbXTtcbiAgbGF5ZXI6IExheWVyO1xuICBwcmltYXJ5RGF0YT86IERhdGFSb3cgfCBBZ2dyZWdhdGlvbkxheWVySG92ZXJEYXRhIHwgbnVsbDtcbiAgY29tcGFyZVR5cGU/OiBDb21wYXJlVHlwZTtcbn07XG5cbi8qKlxuICogRmluZCBkZWZhdWx0IGxheWVycyBmcm9tIGZpZWxkc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZmluZERlZmF1bHRMYXllcihkYXRhc2V0OiBLZXBsZXJUYWJsZSwgbGF5ZXJDbGFzc2VzOiBMYXllckNsYXNzZXNUeXBlKTogTGF5ZXJbXSB7XG4gIGlmICghZGF0YXNldCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBjb25zdCBsYXllclByb3BzID0gKE9iamVjdC5rZXlzKGxheWVyQ2xhc3NlcykgYXMgQXJyYXk8a2V5b2YgTGF5ZXJDbGFzc2VzVHlwZT4pLnJlZHVjZShcbiAgICAocHJldmlvdXMsIGxjKSA9PiB7XG4gICAgICBjb25zdCByZXN1bHQ6IEZpbmREZWZhdWx0TGF5ZXJQcm9wc1JldHVyblZhbHVlID1cbiAgICAgICAgdHlwZW9mIGxheWVyQ2xhc3Nlc1tsY10uZmluZERlZmF1bHRMYXllclByb3BzID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgPyBsYXllckNsYXNzZXNbbGNdLmZpbmREZWZhdWx0TGF5ZXJQcm9wcyhkYXRhc2V0LCBwcmV2aW91cylcbiAgICAgICAgICA6IHtwcm9wczogW119O1xuXG4gICAgICBjb25zdCBwcm9wcyA9IEFycmF5LmlzQXJyYXkocmVzdWx0KSA/IHJlc3VsdCA6IHJlc3VsdC5wcm9wcyB8fCBbXTtcbiAgICAgIGNvbnN0IGZvdW5kTGF5ZXJzID0gcmVzdWx0LmZvdW5kTGF5ZXJzIHx8IHByZXZpb3VzO1xuXG4gICAgICByZXR1cm4gZm91bmRMYXllcnMuY29uY2F0KFxuICAgICAgICBwcm9wcy5tYXAocCA9PiAoe1xuICAgICAgICAgIC4uLnAsXG4gICAgICAgICAgdHlwZTogbGMsXG4gICAgICAgICAgZGF0YUlkOiBkYXRhc2V0LmlkXG4gICAgICAgIH0pKVxuICAgICAgKTtcbiAgICB9LFxuICAgIFtdIGFzIExheWVyQ2xhc3Nlc1R5cGVba2V5b2YgTGF5ZXJDbGFzc2VzVHlwZV1bXVxuICApO1xuXG4gIC8vIGdvIHRocm91Z2ggYWxsIGxheWVyUHJvcHMgdG8gY3JlYXRlIGxheWVyXG4gIHJldHVybiBsYXllclByb3BzLm1hcChwcm9wcyA9PiB7XG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciBUT0RPOiBjaGVja2luZyBwcm9wcy50eXBlICE9PSBudWxsXG4gICAgY29uc3QgbGF5ZXIgPSBuZXcgbGF5ZXJDbGFzc2VzW3Byb3BzLnR5cGVdKHByb3BzKTtcbiAgICByZXR1cm4gdHlwZW9mIGxheWVyLnNldEluaXRpYWxMYXllckNvbmZpZyA9PT0gJ2Z1bmN0aW9uJyAmJiBkYXRhc2V0LmRhdGFDb250YWluZXJcbiAgICAgID8gbGF5ZXIuc2V0SW5pdGlhbExheWVyQ29uZmlnKGRhdGFzZXQpXG4gICAgICA6IGxheWVyO1xuICB9KTtcbn1cblxuLyoqXG4gKiBjYWxjdWxhdGUgbGF5ZXIgZGF0YSBiYXNlZCBvbiBsYXllciB0eXBlLCBjb2wgQ29uZmlnLFxuICogcmV0dXJuIHVwZGF0ZWQgbGF5ZXIgaWYgY29sb3JEb21haW4sIGRhdGFNYXAgaGFzIGNoYW5nZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZUxheWVyRGF0YShcbiAgbGF5ZXI6IExheWVyLFxuICBzdGF0ZToge2RhdGFzZXRzOiBEYXRhc2V0c30sXG4gIG9sZExheWVyRGF0YT86IGFueVxuKToge1xuICBsYXllckRhdGE6IGFueTtcbiAgbGF5ZXI6IExheWVyO1xufSB7XG4gIGNvbnN0IHt0eXBlfSA9IGxheWVyO1xuXG4gIGlmICghdHlwZSB8fCAhbGF5ZXIuaGFzQWxsQ29sdW1ucygpIHx8ICFsYXllci5jb25maWcuZGF0YUlkKSB7XG4gICAgcmV0dXJuIHtsYXllciwgbGF5ZXJEYXRhOiB7fX07XG4gIH1cblxuICBjb25zdCBsYXllckRhdGEgPSBsYXllci5mb3JtYXRMYXllckRhdGEoc3RhdGUuZGF0YXNldHMsIG9sZExheWVyRGF0YSk7XG4gIHJldHVybiB7bGF5ZXJEYXRhLCBsYXllcn07XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlIHByb3BzIHBhc3NlZCB0byBMYXllckhvdmVySW5mb1xuICogQHR5cGUge3R5cGVvZiBpbXBvcnQoJy4vbGF5ZXItdXRpbHMnKS5nZXRMYXllckhvdmVyUHJvcH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldExheWVySG92ZXJQcm9wKHtcbiAgaW50ZXJhY3Rpb25Db25maWcsXG4gIGhvdmVySW5mbyxcbiAgbGF5ZXJzLFxuICBsYXllcnNUb1JlbmRlcixcbiAgZGF0YXNldHNcbn06IHtcbiAgaW50ZXJhY3Rpb25Db25maWc6IEludGVyYWN0aW9uQ29uZmlnO1xuICBob3ZlckluZm86IGFueTtcbiAgbGF5ZXJzOiBMYXllcltdO1xuICBsYXllcnNUb1JlbmRlcjogTGF5ZXJzVG9SZW5kZXI7XG4gIGRhdGFzZXRzOiBEYXRhc2V0cztcbn0pOiBMYXllckhvdmVyUHJvcCB8IG51bGwge1xuICBpZiAoaW50ZXJhY3Rpb25Db25maWcudG9vbHRpcC5lbmFibGVkICYmIGhvdmVySW5mbyAmJiBob3ZlckluZm8ucGlja2VkKSB7XG4gICAgLy8gaWYgYW55dGhpbmcgaG92ZXJlZFxuICAgIGNvbnN0IHtvYmplY3QsIGxheWVyOiBvdmVybGF5fSA9IGhvdmVySW5mbztcblxuICAgIC8vIGRlY2tnbCBsYXllciB0byBrZXBsZXItZ2wgbGF5ZXJcbiAgICBjb25zdCBsYXllciA9IGxheWVyc1tvdmVybGF5LnByb3BzLmlkeF07XG5cbiAgICBpZiAob2JqZWN0ICYmIGxheWVyICYmIGxheWVyLmdldEhvdmVyRGF0YSAmJiBsYXllcnNUb1JlbmRlcltsYXllci5pZF0pIHtcbiAgICAgIC8vIGlmIGxheWVyIGlzIHZpc2libGUgYW5kIGhhdmUgaG92ZXJlZCBkYXRhXG4gICAgICBjb25zdCB7XG4gICAgICAgIGNvbmZpZzoge2RhdGFJZH1cbiAgICAgIH0gPSBsYXllcjtcbiAgICAgIGlmICghZGF0YUlkKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgY29uc3Qge2RhdGFDb250YWluZXIsIGZpZWxkc30gPSBkYXRhc2V0c1tkYXRhSWRdO1xuICAgICAgY29uc3QgZGF0YTogRGF0YVJvdyB8IG51bGwgPSBsYXllci5nZXRIb3ZlckRhdGEob2JqZWN0LCBkYXRhQ29udGFpbmVyLCBmaWVsZHMpO1xuICAgICAgY29uc3QgZmllbGRzVG9TaG93ID0gaW50ZXJhY3Rpb25Db25maWcudG9vbHRpcC5jb25maWcuZmllbGRzVG9TaG93W2RhdGFJZF07XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRhdGEsXG4gICAgICAgIGZpZWxkcyxcbiAgICAgICAgZmllbGRzVG9TaG93LFxuICAgICAgICBsYXllclxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlbmRlckRlY2tHbExheWVyKHByb3BzOiBhbnksIGxheWVyQ2FsbGJhY2tzOiB7W2tleTogc3RyaW5nXTogYW55fSwgaWR4OiBudW1iZXIpIHtcbiAgY29uc3Qge1xuICAgIGRhdGFzZXRzLFxuICAgIGxheWVycyxcbiAgICBsYXllckRhdGEsXG4gICAgaG92ZXJJbmZvLFxuICAgIGNsaWNrZWQsXG4gICAgbWFwU3RhdGUsXG4gICAgaW50ZXJhY3Rpb25Db25maWcsXG4gICAgYW5pbWF0aW9uQ29uZmlnLFxuICAgIG1hcExheWVyc1xuICB9ID0gcHJvcHM7XG4gIGNvbnN0IGxheWVyID0gbGF5ZXJzW2lkeF07XG4gIGNvbnN0IGRhdGEgPSBsYXllckRhdGFbaWR4XTtcbiAgY29uc3Qge2dwdUZpbHRlcn0gPSBkYXRhc2V0c1tsYXllci5jb25maWcuZGF0YUlkXSB8fCB7fTtcbiAgY29uc3Qgb2JqZWN0SG92ZXJlZCA9IGNsaWNrZWQgfHwgaG92ZXJJbmZvO1xuICBjb25zdCB2aXNpYmxlID0gIW1hcExheWVycyB8fCAobWFwTGF5ZXJzICYmIG1hcExheWVyc1tsYXllci5pZF0pO1xuICAvLyBMYXllciBpcyBMYXllciBjbGFzc1xuICByZXR1cm4gbGF5ZXIucmVuZGVyTGF5ZXIoe1xuICAgIGRhdGEsXG4gICAgZ3B1RmlsdGVyLFxuICAgIGlkeCxcbiAgICBpbnRlcmFjdGlvbkNvbmZpZyxcbiAgICBsYXllckNhbGxiYWNrcyxcbiAgICBtYXBTdGF0ZSxcbiAgICBhbmltYXRpb25Db25maWcsXG4gICAgb2JqZWN0SG92ZXJlZCxcbiAgICB2aXNpYmxlXG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNMYXllclJlbmRlcmFibGUobGF5ZXI6IExheWVyLCBsYXllckRhdGEpIHtcbiAgcmV0dXJuIGxheWVyLmlkICE9PSBHRU9DT0RFUl9MQVlFUl9JRCAmJiBsYXllci5zaG91bGRSZW5kZXJMYXllcihsYXllckRhdGEpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNMYXllclZpc2libGUobGF5ZXIsIG1hcExheWVycykge1xuICByZXR1cm4gKFxuICAgIGxheWVyLmNvbmZpZy5pc1Zpc2libGUgJiZcbiAgICAvLyBpZiBsYXllci5pZCBpcyBub3QgaW4gbWFwTGF5ZXJzLCBkb24ndCByZW5kZXIgaXRcbiAgICAoIW1hcExheWVycyB8fCAobWFwTGF5ZXJzICYmIG1hcExheWVyc1tsYXllci5pZF0pKVxuICApO1xufVxuXG4vLyBQcmVwYXJlIGEgZGljdCBvZiBsYXllcnMgcmVuZGVyZWQgYnkgdGhlIGRlY2suZ2xcbi8vIE5vdGUsIGlzVmlzaWJsZTogZmFsc2UgbGF5ZXIgaXMgcGFzc2VkIHRvIGRlY2suZ2wgaGVyZVxuLy8gcmV0dXJuIHtbaWRdOiB0cnVlIFxcIGZhbHNlfVxuZXhwb3J0IGZ1bmN0aW9uIHByZXBhcmVMYXllcnNGb3JEZWNrKFxuICBsYXllcnM6IExheWVyW10sXG4gIGxheWVyRGF0YTogYW55W11cbik6IHtcbiAgW2tleTogc3RyaW5nXTogYm9vbGVhbjtcbn0ge1xuICByZXR1cm4gbGF5ZXJzLnJlZHVjZShcbiAgICAoYWNjdSwgbGF5ZXIsIGlkeCkgPT4gKHtcbiAgICAgIC4uLmFjY3UsXG4gICAgICBbbGF5ZXIuaWRdOlxuICAgICAgICBpc0xheWVyUmVuZGVyYWJsZShsYXllciwgbGF5ZXJEYXRhW2lkeF0pICYmIGxheWVyLm92ZXJsYXlUeXBlID09PSBPVkVSTEFZX1RZUEVfQ09OU1QuZGVja2dsXG4gICAgfSksXG4gICAge31cbiAgKTtcbn1cblxuLy8gUHJlcGFyZSBhIGRpY3Qgb2YgcmVuZGVyZWQgbGF5ZXJzIHJlbmRlcmVkIGluIHRoZSBtYXBcbi8vIFRoaXMgaW5jbHVkZXMgb25seSB0aGUgdmlzaWJpbGUgbGF5ZXJzIGZvciBzaW5nbGUgbWFwIHZpZXcgYW5kIHNwbGl0IG1hcCB2aWV3XG4vLyByZXR1cm4ge1tpZF06IHRydWUgXFwgZmFsc2V9XG5leHBvcnQgZnVuY3Rpb24gcHJlcGFyZUxheWVyc1RvUmVuZGVyKFxuICBsYXllcnM6IExheWVyW10sXG4gIGxheWVyRGF0YTogVmlzU3RhdGVbJ2xheWVyRGF0YSddLFxuICBtYXBMYXllcnM/OiBTcGxpdE1hcExheWVycyB8IHVuZGVmaW5lZCB8IG51bGxcbik6IExheWVyc1RvUmVuZGVyIHtcbiAgcmV0dXJuIGxheWVycy5yZWR1Y2UoXG4gICAgKGFjY3UsIGxheWVyLCBpZHgpID0+ICh7XG4gICAgICAuLi5hY2N1LFxuICAgICAgW2xheWVyLmlkXTogaXNMYXllclJlbmRlcmFibGUobGF5ZXIsIGxheWVyRGF0YVtpZHhdKSAmJiBpc0xheWVyVmlzaWJsZShsYXllciwgbWFwTGF5ZXJzKVxuICAgIH0pLFxuICAgIHt9XG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRDdXN0b21EZWNrTGF5ZXJzKGRlY2tHbFByb3BzKSB7XG4gIGNvbnN0IGJvdHRvbURlY2tMYXllcnMgPSBBcnJheS5pc0FycmF5KGRlY2tHbFByb3BzPy5sYXllcnMpXG4gICAgPyBkZWNrR2xQcm9wcz8ubGF5ZXJzXG4gICAgOiBpc0Z1bmN0aW9uKGRlY2tHbFByb3BzPy5sYXllcnMpXG4gICAgPyBkZWNrR2xQcm9wcz8ubGF5ZXJzKClcbiAgICA6IFtdO1xuICBjb25zdCB0b3BEZWNrTGF5ZXJzID0gQXJyYXkuaXNBcnJheShkZWNrR2xQcm9wcz8udG9wTGF5ZXJzKVxuICAgID8gZGVja0dsUHJvcHM/LnRvcExheWVyc1xuICAgIDogaXNGdW5jdGlvbihkZWNrR2xQcm9wcz8udG9wTGF5ZXJzKVxuICAgID8gZGVja0dsUHJvcHM/LnRvcExheWVycygpXG4gICAgOiBbXTtcblxuICByZXR1cm4gW2JvdHRvbURlY2tMYXllcnMsIHRvcERlY2tMYXllcnNdO1xufVxuXG5leHBvcnQgdHlwZSBDb21wdXRlRGVja0xheWVyc1Byb3BzID0ge1xuICBtYXBJbmRleD86IG51bWJlcjtcbiAgbWFwYm94QXBpQWNjZXNzVG9rZW4/OiBzdHJpbmc7XG4gIG1hcGJveEFwaVVybD86IHN0cmluZztcbiAgcHJpbWFyeU1hcD86IGJvb2xlYW47XG4gIGxheWVyc0ZvckRlY2s/OiB7W2tleTogc3RyaW5nXTogYm9vbGVhbn07XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZURlY2tMYXllcnMoXG4gIHt2aXNTdGF0ZSwgbWFwU3RhdGUsIG1hcFN0eWxlfTogYW55LFxuICBvcHRpb25zPzogQ29tcHV0ZURlY2tMYXllcnNQcm9wcyxcbiAgb25TZXRMYXllckRvbWFpbj86IChpZHg6IG51bWJlciwgdmFsdWU6IGFueSkgPT4gdm9pZCxcbiAgZGVja0dsUHJvcHM/OiBhbnlcbik6IExheWVyW10ge1xuICBjb25zdCB7XG4gICAgZGF0YXNldHMsXG4gICAgbGF5ZXJzLFxuICAgIGxheWVyT3JkZXIsXG4gICAgbGF5ZXJEYXRhLFxuICAgIGhvdmVySW5mbyxcbiAgICBjbGlja2VkLFxuICAgIGludGVyYWN0aW9uQ29uZmlnLFxuICAgIGFuaW1hdGlvbkNvbmZpZyxcbiAgICBzcGxpdE1hcHNcbiAgfSA9IHZpc1N0YXRlO1xuXG4gIGNvbnN0IHttYXBJbmRleCwgbWFwYm94QXBpQWNjZXNzVG9rZW4sIG1hcGJveEFwaVVybCwgcHJpbWFyeU1hcCwgbGF5ZXJzRm9yRGVja30gPSBvcHRpb25zIHx8IHt9O1xuXG4gIGxldCBkYXRhTGF5ZXJzOiBhbnlbXSA9IFtdO1xuXG4gIGlmIChsYXllckRhdGEgJiYgbGF5ZXJEYXRhLmxlbmd0aCkge1xuICAgIGNvbnN0IG1hcExheWVycyA9IGdldE1hcExheWVyc0Zyb21TcGxpdE1hcHMoc3BsaXRNYXBzLCBtYXBJbmRleCB8fCAwKTtcblxuICAgIGNvbnN0IGN1cnJlbnRMYXllcnNGb3JEZWNrID0gbGF5ZXJzRm9yRGVjayB8fCBwcmVwYXJlTGF5ZXJzRm9yRGVjayhsYXllcnMsIGxheWVyRGF0YSk7XG5cbiAgICBkYXRhTGF5ZXJzID0gbGF5ZXJPcmRlclxuICAgICAgLnNsaWNlKClcbiAgICAgIC5yZXZlcnNlKClcbiAgICAgIC5maWx0ZXIoaWR4ID0+IGN1cnJlbnRMYXllcnNGb3JEZWNrW2xheWVyc1tpZHhdLmlkXSlcbiAgICAgIC5yZWR1Y2UoKG92ZXJsYXlzLCBpZHgpID0+IHtcbiAgICAgICAgY29uc3QgbGF5ZXJDYWxsYmFja3MgPSBvblNldExheWVyRG9tYWluXG4gICAgICAgICAgPyB7XG4gICAgICAgICAgICAgIG9uU2V0TGF5ZXJEb21haW46IHZhbCA9PiBvblNldExheWVyRG9tYWluKGlkeCwgdmFsKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIDoge307XG4gICAgICAgIGNvbnN0IGxheWVyT3ZlcmxheSA9IHJlbmRlckRlY2tHbExheWVyKFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGRhdGFzZXRzLFxuICAgICAgICAgICAgbGF5ZXJzLFxuICAgICAgICAgICAgbGF5ZXJEYXRhLFxuICAgICAgICAgICAgaG92ZXJJbmZvLFxuICAgICAgICAgICAgY2xpY2tlZCxcbiAgICAgICAgICAgIG1hcFN0YXRlLFxuICAgICAgICAgICAgaW50ZXJhY3Rpb25Db25maWcsXG4gICAgICAgICAgICBhbmltYXRpb25Db25maWcsXG4gICAgICAgICAgICBtYXBMYXllcnNcbiAgICAgICAgICB9LFxuICAgICAgICAgIGxheWVyQ2FsbGJhY2tzLFxuICAgICAgICAgIGlkeFxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gb3ZlcmxheXMuY29uY2F0KGxheWVyT3ZlcmxheSB8fCBbXSk7XG4gICAgICB9LCBbXSk7XG4gIH1cblxuICBpZiAoIXByaW1hcnlNYXApIHtcbiAgICByZXR1cm4gZGF0YUxheWVycztcbiAgfVxuXG4gIGlmIChcbiAgICBtYXBTdHlsZT8udmlzaWJsZUxheWVyR3JvdXBzWyczZCBidWlsZGluZyddICYmXG4gICAgcHJpbWFyeU1hcCAmJlxuICAgIG1hcGJveEFwaUFjY2Vzc1Rva2VuICYmXG4gICAgbWFwYm94QXBpVXJsXG4gICkge1xuICAgIGRhdGFMYXllcnMucHVzaChcbiAgICAgIG5ldyBUaHJlZURCdWlsZGluZ0xheWVyKHtcbiAgICAgICAgaWQ6ICdfa2VwbGVyZ2xfM2QtYnVpbGRpbmcnLFxuICAgICAgICBtYXBib3hBcGlBY2Nlc3NUb2tlbixcbiAgICAgICAgbWFwYm94QXBpVXJsLFxuICAgICAgICB0aHJlZURCdWlsZGluZ0NvbG9yOiBtYXBTdHlsZS50aHJlZURCdWlsZGluZ0NvbG9yLFxuICAgICAgICB1cGRhdGVUcmlnZ2Vyczoge1xuICAgICAgICAgIGdldEZpbGxDb2xvcjogbWFwU3R5bGUudGhyZWVEQnVpbGRpbmdDb2xvclxuICAgICAgICB9XG4gICAgICB9KVxuICAgICk7XG4gIH1cblxuICBjb25zdCBbY3VzdG9tQm90dG9tRGVja0xheWVycywgY3VzdG9tVG9wRGVja0xheWVyc10gPSBnZXRDdXN0b21EZWNrTGF5ZXJzKGRlY2tHbFByb3BzKTtcblxuICByZXR1cm4gWy4uLmN1c3RvbUJvdHRvbURlY2tMYXllcnMsIC4uLmRhdGFMYXllcnMsIC4uLmN1c3RvbVRvcERlY2tMYXllcnNdO1xufVxuIl19