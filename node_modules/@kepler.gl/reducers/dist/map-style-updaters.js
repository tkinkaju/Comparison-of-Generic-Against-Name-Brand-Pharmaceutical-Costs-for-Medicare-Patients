// Copyright (c) 2022 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getMapStyles = getMapStyles;
exports.getInitialInputStyle = getInitialInputStyle;
exports.set3dBuildingColorUpdater = exports.addCustomMapStyleUpdater = exports.inputMapStyleUpdater = exports.loadCustomMapStyleUpdater = exports.resetMapConfigMapStyleUpdater = exports.receiveMapConfigUpdater = exports.requestMapStylesUpdater = exports.loadMapStyleErrUpdater = exports.loadMapStylesUpdater = exports.mapStyleChangeUpdater = exports.mapConfigChangeUpdater = exports.initMapStyleUpdater = exports.INITIAL_MAP_STYLE = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _tasks = _interopRequireWildcard(require("react-palm/tasks"));

var _lodash = _interopRequireDefault(require("lodash.clonedeep"));

var _utils = require("@kepler.gl/utils");

var _constants = require("@kepler.gl/constants");

var _tasks2 = require("@kepler.gl/tasks");

var _d3Color = require("d3-color");

var _actions = require("@kepler.gl/actions");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var DEFAULT_BLDG_COLOR = '#D1CEC7';

var getDefaultState = function getDefaultState() {
  var visibleLayerGroups = {};
  var styleType = 'dark';
  var topLayerGroups = {};
  return {
    styleType: styleType,
    visibleLayerGroups: visibleLayerGroups,
    topLayerGroups: topLayerGroups,
    mapStyles: _constants.DEFAULT_MAP_STYLES.reduce(function (accu, curr) {
      return _objectSpread(_objectSpread({}, accu), {}, (0, _defineProperty2["default"])({}, curr.id, curr));
    }, {}),
    // save mapbox access token
    mapboxApiAccessToken: null,
    mapboxApiUrl: _constants.DEFAULT_MAPBOX_API_URL,
    mapStylesReplaceDefault: false,
    inputStyle: getInitialInputStyle(),
    threeDBuildingColor: (0, _utils.hexToRgb)(DEFAULT_BLDG_COLOR),
    custom3DBuildingColor: false,
    bottomMapStyle: undefined,
    topMapStyle: undefined
  };
};
/**
 * Updaters for `mapStyle`. Can be used in your root reducer to directly modify kepler.gl's state.
 * Read more about [Using updaters](../advanced-usage/using-updaters.md)
 * @public
 * @example
 *
 * import keplerGlReducer, {mapStyleUpdaters} from 'kepler.gl/reducers';
 * // Root Reducer
 * const reducers = combineReducers({
 *  keplerGl: keplerGlReducer,
 *  app: appReducer
 * });
 *
 * const composedReducer = (state, action) => {
 *  switch (action.type) {
 *    // click button to hide label from background map
 *    case 'CLICK_BUTTON':
 *      return {
 *        ...state,
 *        keplerGl: {
 *          ...state.keplerGl,
 *          foo: {
 *             ...state.keplerGl.foo,
 *             mapStyle: mapStyleUpdaters.mapConfigChangeUpdater(
 *               mapStyle,
 *               {payload: {visibleLayerGroups: {label: false, road: true, background: true}}}
 *             )
 *          }
 *        }
 *      };
 *  }
 *  return reducers(state, action);
 * };
 *
 * export default composedReducer;
 */

/* eslint-disable no-unused-vars */
// @ts-ignore


var mapStyleUpdaters = null;
/* eslint-enable no-unused-vars */

/**
 * Default initial `mapStyle`
 * @memberof mapStyleUpdaters
 * @constant
 * @property styleType - Default: `'dark'`
 * @property visibleLayerGroups - Default: `{}`
 * @property topLayerGroups - Default: `{}`
 * @property mapStyles - mapping from style key to style object
 * @property mapboxApiAccessToken - Default: `null`
 * @Property mapboxApiUrl - Default null
 * @Property mapStylesReplaceDefault - Default: `false`
 * @property inputStyle - Default: `{}`
 * @property threeDBuildingColor - Default: `[r, g, b]`
 * @public
 */

var INITIAL_MAP_STYLE = getDefaultState();
exports.INITIAL_MAP_STYLE = INITIAL_MAP_STYLE;

/**
 * Create two map styles from preset map style, one for top map one for bottom
 *
 * @param {string} styleType - current map style
 * @param {Object} visibleLayerGroups - visible layers of bottom map
 * @param {Object} topLayerGroups - visible layers of top map
 * @param {Object} mapStyles - a dictionary of all map styles
 * @returns {Object} bottomMapStyle | topMapStyle | isRaster
 */
function getMapStyles(_ref) {
  var styleType = _ref.styleType,
      visibleLayerGroups = _ref.visibleLayerGroups,
      topLayerGroups = _ref.topLayerGroups,
      mapStyles = _ref.mapStyles;
  var mapStyle = mapStyles[styleType]; // style might not be loaded yet

  if (!mapStyle || !mapStyle.style) {
    return {};
  }

  var editable = Object.keys(visibleLayerGroups).length;
  var bottomMapStyle = !editable ? mapStyle.style : (0, _utils.editBottomMapStyle)({
    id: styleType,
    mapStyle: mapStyle,
    visibleLayerGroups: visibleLayerGroups
  });
  var hasTopLayer = editable > 0 && Object.values(topLayerGroups).some(function (v) {
    return v;
  }); // mute top layer if not visible in bottom layer

  var topLayers = hasTopLayer && Object.keys(topLayerGroups).reduce(function (accu, key) {
    return _objectSpread(_objectSpread({}, accu), {}, (0, _defineProperty2["default"])({}, key, topLayerGroups[key] && visibleLayerGroups[key]));
  }, {});
  var topMapStyle = hasTopLayer ? (0, _utils.editTopMapStyle)({
    mapStyle: mapStyle,
    visibleLayerGroups: topLayers
  }) : null;
  return {
    bottomMapStyle: bottomMapStyle,
    topMapStyle: topMapStyle,
    editable: editable
  };
}

function findLayerFillColor(layer) {
  return layer && layer.paint && layer.paint['background-color'];
}

function get3DBuildingColor(style) {
  // set building color to be the same as the background color.
  if (!style.style) {
    return (0, _utils.hexToRgb)(DEFAULT_BLDG_COLOR);
  }

  var backgroundLayer = (style.style.layers || []).find(function (_ref2) {
    var id = _ref2.id;
    return id === 'background';
  });
  var buildingLayer = (style.style.layers || []).find(function (_ref3) {
    var id = _ref3.id;
    return id.match(/building/);
  });
  var buildingColor = findLayerFillColor(buildingLayer) || findLayerFillColor(backgroundLayer) || DEFAULT_BLDG_COLOR; // brighten or darken building based on style

  var operation = style.id.match(/(?=(dark|night))/) ? 'brighter' : 'darker';
  var alpha = 0.2;
  var rgbObj = (0, _d3Color.rgb)(buildingColor)[operation]([alpha]);
  return [rgbObj.r, rgbObj.g, rgbObj.b];
}

function getLayerGroupsFromStyle(style) {
  return Array.isArray(style.layers) ? _constants.DEFAULT_LAYER_GROUPS.filter(function (lg) {
    return style.layers.filter(lg.filter).length;
  }) : [];
} // Updaters

/**
 * Propagate `mapStyle` reducer with `mapboxApiAccessToken` and `mapStylesReplaceDefault`.
 * if mapStylesReplaceDefault is true mapStyles is emptied; loadMapStylesUpdater() will
 * populate mapStyles.
 *
 * @memberof mapStyleUpdaters
 * @public
 */


var initMapStyleUpdater = function initMapStyleUpdater(state, _ref4) {
  var _ref4$payload = _ref4.payload,
      payload = _ref4$payload === void 0 ? {} : _ref4$payload;
  return _objectSpread(_objectSpread({}, state), {}, {
    // save mapbox access token to map style state
    mapboxApiAccessToken: payload.mapboxApiAccessToken || state.mapboxApiAccessToken,
    mapboxApiUrl: payload.mapboxApiUrl || state.mapboxApiUrl,
    mapStyles: !payload.mapStylesReplaceDefault ? state.mapStyles : {},
    mapStylesReplaceDefault: payload.mapStylesReplaceDefault || false
  });
}; // });

/**
 * Update `visibleLayerGroups`to change layer group visibility
 * @memberof mapStyleUpdaters
 * @public
 */


exports.initMapStyleUpdater = initMapStyleUpdater;

var mapConfigChangeUpdater = function mapConfigChangeUpdater(state, action) {
  return _objectSpread(_objectSpread(_objectSpread({}, state), action.payload), getMapStyles(_objectSpread(_objectSpread({}, state), action.payload)));
};
/**
 * Change to another map style. The selected style should already been loaded into `mapStyle.mapStyles`
 * @memberof mapStyleUpdaters
 * @public
 */


exports.mapConfigChangeUpdater = mapConfigChangeUpdater;

var mapStyleChangeUpdater = function mapStyleChangeUpdater(state, _ref5) {
  var styleType = _ref5.payload;

  if (!state.mapStyles[styleType]) {
    // we might not have received the style yet
    return state;
  }

  var defaultLGVisibility = (0, _utils.getDefaultLayerGroupVisibility)(state.mapStyles[styleType]);
  var visibleLayerGroups = (0, _utils.mergeLayerGroupVisibility)(defaultLGVisibility, state.visibleLayerGroups);
  var threeDBuildingColor = state.custom3DBuildingColor ? state.threeDBuildingColor : get3DBuildingColor(state.mapStyles[styleType]);
  return _objectSpread(_objectSpread({}, state), {}, {
    styleType: styleType,
    visibleLayerGroups: visibleLayerGroups,
    threeDBuildingColor: threeDBuildingColor
  }, getMapStyles(_objectSpread(_objectSpread({}, state), {}, {
    visibleLayerGroups: visibleLayerGroups,
    styleType: styleType
  })));
};
/**
 * Callback when load map style success
 * @memberof mapStyleUpdaters
 * @public
 */


exports.mapStyleChangeUpdater = mapStyleChangeUpdater;

var loadMapStylesUpdater = function loadMapStylesUpdater(state, action) {
  var newStyles = action.payload || {};
  var addLayerGroups = Object.keys(newStyles).reduce(function (accu, id) {
    return _objectSpread(_objectSpread({}, accu), {}, (0, _defineProperty2["default"])({}, id, _objectSpread(_objectSpread({}, newStyles[id]), {}, {
      layerGroups: newStyles[id].layerGroups || getLayerGroupsFromStyle(newStyles[id].style)
    })));
  }, {}); // add new styles to state

  var newState = _objectSpread(_objectSpread({}, state), {}, {
    mapStyles: _objectSpread(_objectSpread({}, state.mapStyles), addLayerGroups)
  });

  return newStyles[state.styleType] ? mapStyleChangeUpdater(newState, {
    payload: state.styleType
  }) : newState;
};
/**
 * Callback when load map style error
 * @memberof mapStyleUpdaters
 * @public
 */
// do nothing for now, if didn't load, skip it


exports.loadMapStylesUpdater = loadMapStylesUpdater;

var loadMapStyleErrUpdater = function loadMapStyleErrUpdater(state, action) {
  return state;
};
/**
 * @memberof mapStyleUpdaters
 * @public
 */


exports.loadMapStyleErrUpdater = loadMapStyleErrUpdater;

var requestMapStylesUpdater = function requestMapStylesUpdater(state, _ref6) {
  var mapStyles = _ref6.payload;
  var loadMapStyleTasks = getLoadMapStyleTasks(mapStyles, state.mapboxApiAccessToken, state.mapboxApiUrl);
  return (0, _tasks.withTask)(state, loadMapStyleTasks);
};
/**
 * Load map style object when pass in saved map config
 * @memberof mapStyleUpdaters
 * @param state `mapStyle`
 * @param action
 * @param action.payload saved map config `{mapStyle, visState, mapState}`
 * @returns nextState or `react-pam` tasks to load map style object
 */


exports.requestMapStylesUpdater = requestMapStylesUpdater;

var receiveMapConfigUpdater = function receiveMapConfigUpdater(state, _ref7) {
  var config = _ref7.payload.config;

  var _ref8 = config || {},
      mapStyle = _ref8.mapStyle;

  if (!mapStyle) {
    return state;
  } // if saved custom mapStyles load the style object


  var loadMapStyleTasks = mapStyle.mapStyles ? getLoadMapStyleTasks(mapStyle.mapStyles, state.mapboxApiAccessToken, state.mapboxApiUrl) : null; // merge default mapStyles

  var merged = mapStyle.mapStyles ? _objectSpread(_objectSpread({}, mapStyle), {}, {
    mapStyles: _objectSpread(_objectSpread({}, mapStyle.mapStyles), state.mapStyles)
  }) : mapStyle; // set custom3DBuildingColor: true if mapStyle contains threeDBuildingColor
  // @ts-expect-error

  merged.custom3DBuildingColor = // @ts-expect-error
  Boolean(mapStyle.threeDBuildingColor) || merged.custom3DBuildingColor;
  var newState = mapConfigChangeUpdater(state, {
    payload: merged
  });
  return loadMapStyleTasks ? (0, _tasks.withTask)(newState, loadMapStyleTasks) : newState;
};

exports.receiveMapConfigUpdater = receiveMapConfigUpdater;

function getLoadMapStyleTasks(mapStyles, mapboxApiAccessToken, mapboxApiUrl) {
  return [_tasks["default"].all(Object.values(mapStyles) // @ts-expect-error
  .map(function (_ref9) {
    var id = _ref9.id,
        url = _ref9.url,
        accessToken = _ref9.accessToken;
    return {
      id: id,
      url: (0, _utils.isValidStyleUrl)(url) ? (0, _utils.getStyleDownloadUrl)(url, accessToken || mapboxApiAccessToken, mapboxApiUrl) : url
    };
  }).map(_tasks2.LOAD_MAP_STYLE_TASK)).bimap( // success
  function (results) {
    return (0, _actions.loadMapStyles)(results.reduce(function (accu, _ref10) {
      var id = _ref10.id,
          style = _ref10.style;
      return _objectSpread(_objectSpread({}, accu), {}, (0, _defineProperty2["default"])({}, id, _objectSpread(_objectSpread({}, mapStyles[id]), {}, {
        style: style
      })));
    }, {}));
  }, // error
  _actions.loadMapStyleErr)];
}
/**
 * Reset map style config to initial state
 * @memberof mapStyleUpdaters
 * @param state `mapStyle`
 * @returns nextState
 * @public
 */


var resetMapConfigMapStyleUpdater = function resetMapConfigMapStyleUpdater(state) {
  var emptyConfig = _objectSpread(_objectSpread(_objectSpread({}, INITIAL_MAP_STYLE), {}, {
    mapboxApiAccessToken: state.mapboxApiAccessToken,
    mapboxApiUrl: state.mapboxApiUrl,
    mapStylesReplaceDefault: state.mapStylesReplaceDefault
  }, state.initialState), {}, {
    mapStyles: state.mapStyles,
    initialState: state.initialState
  });

  return mapStyleChangeUpdater(emptyConfig, {
    payload: emptyConfig.styleType
  });
};
/**
 * Callback when a custom map style object is received
 * @memberof mapStyleUpdaters
 * @public
 */


exports.resetMapConfigMapStyleUpdater = resetMapConfigMapStyleUpdater;

var loadCustomMapStyleUpdater = function loadCustomMapStyleUpdater(state, _ref11) {
  var _ref11$payload = _ref11.payload,
      icon = _ref11$payload.icon,
      style = _ref11$payload.style,
      error = _ref11$payload.error;
  return _objectSpread(_objectSpread({}, state), {}, {
    // @ts-expect-error
    inputStyle: _objectSpread(_objectSpread(_objectSpread(_objectSpread({}, state.inputStyle), style ? {
      // @ts-expect-error
      id: style.id || (0, _utils.generateHashId)(),
      // make a copy of the style object
      style: (0, _lodash["default"])(style),
      // @ts-expect-error
      label: style.name,
      // gathering layer group info from style json
      layerGroups: getLayerGroupsFromStyle(style)
    } : {}), icon ? {
      icon: icon
    } : {}), error !== undefined ? {
      error: error
    } : {})
  });
};
/**
 * Input a custom map style object
 * @memberof mapStyleUpdaters
 * @public
 */


exports.loadCustomMapStyleUpdater = loadCustomMapStyleUpdater;

var inputMapStyleUpdater = function inputMapStyleUpdater(state, _ref12) {
  var _ref12$payload = _ref12.payload,
      inputStyle = _ref12$payload.inputStyle,
      mapState = _ref12$payload.mapState;

  var updated = _objectSpread(_objectSpread({}, state.inputStyle), inputStyle);

  var isValid = (0, _utils.isValidStyleUrl)(updated.url);
  var icon = isValid ? (0, _utils.getStyleImageIcon)({
    mapState: mapState,
    styleUrl: updated.url || '',
    mapboxApiAccessToken: updated.accessToken || state.mapboxApiAccessToken || '',
    mapboxApiUrl: state.mapboxApiUrl || _constants.DEFAULT_MAPBOX_API_URL
  }) : state.inputStyle.icon;
  return _objectSpread(_objectSpread({}, state), {}, {
    inputStyle: _objectSpread(_objectSpread({}, updated), {}, {
      isValid: isValid,
      icon: icon
    })
  });
};
/**
 * Add map style from user input to reducer and set it to current style
 * This action is called when user click confirm after putting in a valid style url in the custom map style dialog.
 * It should not be called from outside kepler.gl without a valid `inputStyle` in the `mapStyle` reducer.
 * @memberof mapStyleUpdaters
 */


exports.inputMapStyleUpdater = inputMapStyleUpdater;

var addCustomMapStyleUpdater = function addCustomMapStyleUpdater(state) {
  // @ts-expect-error
  var styleId = state.inputStyle.id;

  var newState = _objectSpread(_objectSpread({}, state), {}, {
    mapStyles: _objectSpread(_objectSpread({}, state.mapStyles), {}, (0, _defineProperty2["default"])({}, styleId, state.inputStyle)),
    // set to default
    inputStyle: getInitialInputStyle()
  }); // set new style


  return mapStyleChangeUpdater(newState, {
    payload: styleId
  });
};
/**
 * Updates 3d building color
 * @memberof mapStyleUpdaters
 */


exports.addCustomMapStyleUpdater = addCustomMapStyleUpdater;

var set3dBuildingColorUpdater = function set3dBuildingColorUpdater(state, _ref13) {
  var color = _ref13.payload;
  return _objectSpread(_objectSpread({}, state), {}, {
    threeDBuildingColor: color,
    custom3DBuildingColor: true
  });
};
/**
 * Return the initial input style
 * @return Object
 */


exports.set3dBuildingColorUpdater = set3dBuildingColorUpdater;

function getInitialInputStyle() {
  return {
    accessToken: null,
    error: false,
    isValid: false,
    label: null,
    style: null,
    url: null,
    icon: null,
    custom: true
  };
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9tYXAtc3R5bGUtdXBkYXRlcnMudHMiXSwibmFtZXMiOlsiREVGQVVMVF9CTERHX0NPTE9SIiwiZ2V0RGVmYXVsdFN0YXRlIiwidmlzaWJsZUxheWVyR3JvdXBzIiwic3R5bGVUeXBlIiwidG9wTGF5ZXJHcm91cHMiLCJtYXBTdHlsZXMiLCJERUZBVUxUX01BUF9TVFlMRVMiLCJyZWR1Y2UiLCJhY2N1IiwiY3VyciIsImlkIiwibWFwYm94QXBpQWNjZXNzVG9rZW4iLCJtYXBib3hBcGlVcmwiLCJERUZBVUxUX01BUEJPWF9BUElfVVJMIiwibWFwU3R5bGVzUmVwbGFjZURlZmF1bHQiLCJpbnB1dFN0eWxlIiwiZ2V0SW5pdGlhbElucHV0U3R5bGUiLCJ0aHJlZURCdWlsZGluZ0NvbG9yIiwiY3VzdG9tM0RCdWlsZGluZ0NvbG9yIiwiYm90dG9tTWFwU3R5bGUiLCJ1bmRlZmluZWQiLCJ0b3BNYXBTdHlsZSIsIm1hcFN0eWxlVXBkYXRlcnMiLCJJTklUSUFMX01BUF9TVFlMRSIsImdldE1hcFN0eWxlcyIsIm1hcFN0eWxlIiwic3R5bGUiLCJlZGl0YWJsZSIsIk9iamVjdCIsImtleXMiLCJsZW5ndGgiLCJoYXNUb3BMYXllciIsInZhbHVlcyIsInNvbWUiLCJ2IiwidG9wTGF5ZXJzIiwia2V5IiwiZmluZExheWVyRmlsbENvbG9yIiwibGF5ZXIiLCJwYWludCIsImdldDNEQnVpbGRpbmdDb2xvciIsImJhY2tncm91bmRMYXllciIsImxheWVycyIsImZpbmQiLCJidWlsZGluZ0xheWVyIiwibWF0Y2giLCJidWlsZGluZ0NvbG9yIiwib3BlcmF0aW9uIiwiYWxwaGEiLCJyZ2JPYmoiLCJyIiwiZyIsImIiLCJnZXRMYXllckdyb3Vwc0Zyb21TdHlsZSIsIkFycmF5IiwiaXNBcnJheSIsIkRFRkFVTFRfTEFZRVJfR1JPVVBTIiwiZmlsdGVyIiwibGciLCJpbml0TWFwU3R5bGVVcGRhdGVyIiwic3RhdGUiLCJwYXlsb2FkIiwibWFwQ29uZmlnQ2hhbmdlVXBkYXRlciIsImFjdGlvbiIsIm1hcFN0eWxlQ2hhbmdlVXBkYXRlciIsImRlZmF1bHRMR1Zpc2liaWxpdHkiLCJsb2FkTWFwU3R5bGVzVXBkYXRlciIsIm5ld1N0eWxlcyIsImFkZExheWVyR3JvdXBzIiwibGF5ZXJHcm91cHMiLCJuZXdTdGF0ZSIsImxvYWRNYXBTdHlsZUVyclVwZGF0ZXIiLCJyZXF1ZXN0TWFwU3R5bGVzVXBkYXRlciIsImxvYWRNYXBTdHlsZVRhc2tzIiwiZ2V0TG9hZE1hcFN0eWxlVGFza3MiLCJyZWNlaXZlTWFwQ29uZmlnVXBkYXRlciIsImNvbmZpZyIsIm1lcmdlZCIsIkJvb2xlYW4iLCJUYXNrIiwiYWxsIiwibWFwIiwidXJsIiwiYWNjZXNzVG9rZW4iLCJMT0FEX01BUF9TVFlMRV9UQVNLIiwiYmltYXAiLCJyZXN1bHRzIiwibG9hZE1hcFN0eWxlRXJyIiwicmVzZXRNYXBDb25maWdNYXBTdHlsZVVwZGF0ZXIiLCJlbXB0eUNvbmZpZyIsImluaXRpYWxTdGF0ZSIsImxvYWRDdXN0b21NYXBTdHlsZVVwZGF0ZXIiLCJpY29uIiwiZXJyb3IiLCJsYWJlbCIsIm5hbWUiLCJpbnB1dE1hcFN0eWxlVXBkYXRlciIsIm1hcFN0YXRlIiwidXBkYXRlZCIsImlzVmFsaWQiLCJzdHlsZVVybCIsImFkZEN1c3RvbU1hcFN0eWxlVXBkYXRlciIsInN0eWxlSWQiLCJzZXQzZEJ1aWxkaW5nQ29sb3JVcGRhdGVyIiwiY29sb3IiLCJjdXN0b20iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQW9CQTs7QUFDQTs7QUFHQTs7QUFXQTs7QUFLQTs7QUFDQTs7QUFTQTs7Ozs7O0FBNEJBLElBQU1BLGtCQUFrQixHQUFHLFNBQTNCOztBQUVBLElBQU1DLGVBQWUsR0FBRyxTQUFsQkEsZUFBa0IsR0FBZ0I7QUFDdEMsTUFBTUMsa0JBQWtCLEdBQUcsRUFBM0I7QUFDQSxNQUFNQyxTQUFTLEdBQUcsTUFBbEI7QUFDQSxNQUFNQyxjQUFjLEdBQUcsRUFBdkI7QUFFQSxTQUFPO0FBQ0xELElB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S0FBSyxFQUFFLElBTEY7QUFNTHdELElBQUFBLEdBQUcsRUFBRSxJQU5BO0FBT0xVLElBQUFBLElBQUksRUFBRSxJQVBEO0FBUUxhLElBQUFBLE1BQU0sRUFBRTtBQVJILEdBQVA7QUFVRCIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAyMiBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5cbmltcG9ydCBUYXNrLCB7d2l0aFRhc2t9IGZyb20gJ3JlYWN0LXBhbG0vdGFza3MnO1xuaW1wb3J0IGNsb25lRGVlcCBmcm9tICdsb2Rhc2guY2xvbmVkZWVwJztcblxuLy8gVXRpbHNcbmltcG9ydCB7XG4gIGdldERlZmF1bHRMYXllckdyb3VwVmlzaWJpbGl0eSxcbiAgaXNWYWxpZFN0eWxlVXJsLFxuICBnZXRTdHlsZURvd25sb2FkVXJsLFxuICBtZXJnZUxheWVyR3JvdXBWaXNpYmlsaXR5LFxuICBlZGl0VG9wTWFwU3R5bGUsXG4gIGVkaXRCb3R0b21NYXBTdHlsZSxcbiAgZ2V0U3R5bGVJbWFnZUljb24sXG4gIGdlbmVyYXRlSGFzaElkLFxuICBoZXhUb1JnYlxufSBmcm9tICdAa2VwbGVyLmdsL3V0aWxzJztcbmltcG9ydCB7XG4gIERFRkFVTFRfTUFQX1NUWUxFUyxcbiAgREVGQVVMVF9MQVlFUl9HUk9VUFMsXG4gIERFRkFVTFRfTUFQQk9YX0FQSV9VUkxcbn0gZnJvbSAnQGtlcGxlci5nbC9jb25zdGFudHMnO1xuaW1wb3J0IHtMT0FEX01BUF9TVFlMRV9UQVNLfSBmcm9tICdAa2VwbGVyLmdsL3Rhc2tzJztcbmltcG9ydCB7cmdifSBmcm9tICdkMy1jb2xvcic7XG5cbmltcG9ydCB7XG4gIFJHQkNvbG9yLFxuICBMYXllckdyb3VwLFxuICBNYXBTdHlsZXMsXG4gIElucHV0U3R5bGUsXG4gIFZpc2libGVMYXllckdyb3Vwc1xufSBmcm9tICdAa2VwbGVyLmdsL3R5cGVzJztcbmltcG9ydCB7XG4gIEFjdGlvblR5cGVzLFxuICBSZWNlaXZlTWFwQ29uZmlnUGF5bG9hZCxcbiAgS2VwbGVyR2xJbml0UGF5bG9hZCxcbiAgTWFwU3R5bGVBY3Rpb25zLFxuICBsb2FkTWFwU3R5bGVzLFxuICBsb2FkTWFwU3R5bGVFcnJcbn0gZnJvbSAnQGtlcGxlci5nbC9hY3Rpb25zJztcblxuZXhwb3J0IHR5cGUgTWFwYm94U3R5bGVVcmwgPSBzdHJpbmc7XG5cbmV4cG9ydCB0eXBlIE1hcFN0eWxlID0ge1xuICBzdHlsZVR5cGU6IHN0cmluZztcbiAgdmlzaWJsZUxheWVyR3JvdXBzOiBWaXNpYmxlTGF5ZXJHcm91cHM7XG4gIHRvcExheWVyR3JvdXBzOiBWaXNpYmxlTGF5ZXJHcm91cHM7XG4gIG1hcFN0eWxlczogTWFwU3R5bGVzO1xuICAvLyBzYXZlIG1hcGJveCBhY2Nlc3MgdG9rZW5cbiAgbWFwYm94QXBpQWNjZXNzVG9rZW46IHN0cmluZyB8IG51bGw7XG4gIG1hcGJveEFwaVVybDogc3RyaW5nO1xuICBtYXBTdHlsZXNSZXBsYWNlRGVmYXVsdDogYm9vbGVhbjtcbiAgaW5wdXRTdHlsZTogSW5wdXRTdHlsZTtcbiAgdGhyZWVEQnVpbGRpbmdDb2xvcjogUkdCQ29sb3I7XG4gIGN1c3RvbTNEQnVpbGRpbmdDb2xvcjogYm9vbGVhbjtcbiAgYm90dG9tTWFwU3R5bGU6IGFueTtcbiAgdG9wTWFwU3R5bGU6IGFueTtcbiAgaW5pdGlhbFN0YXRlPzogTWFwU3R5bGU7XG59O1xuXG5jb25zdCBERUZBVUxUX0JMREdfQ09MT1IgPSAnI0QxQ0VDNyc7XG5cbmNvbnN0IGdldERlZmF1bHRTdGF0ZSA9ICgpOiBNYXBTdHlsZSA9PiB7XG4gIGNvbnN0IHZpc2libGVMYXllckdyb3VwcyA9IHt9O1xuICBjb25zdCBzdHlsZVR5cGUgPSAnZGFyayc7XG4gIGNvbnN0IHRvcExheWVyR3JvdXBzID0ge307XG5cbiAgcmV0dXJuIHtcbiAgICBzdHlsZVR5cGUsXG4gICAgdmlzaWJsZUxheWVyR3JvdXBzLFxuICAgIHRvcExheWVyR3JvdXBzLFxuICAgIG1hcFN0eWxlczogREVGQVVMVF9NQVBfU1RZTEVTLnJlZHVjZShcbiAgICAgIChhY2N1LCBjdXJyKSA9PiAoe1xuICAgICAgICAuLi5hY2N1LFxuICAgICAgICBbY3Vyci5pZF06IGN1cnJcbiAgICAgIH0pLFxuICAgICAge31cbiAgICApLFxuICAgIC8vIHNhdmUgbWFwYm94IGFjY2VzcyB0b2tlblxuICAgIG1hcGJveEFwaUFjY2Vzc1Rva2VuOiBudWxsLFxuICAgIG1hcGJveEFwaVVybDogREVGQVVMVF9NQVBCT1hfQVBJX1VSTCxcbiAgICBtYXBTdHlsZXNSZXBsYWNlRGVmYXVsdDogZmFsc2UsXG4gICAgaW5wdXRTdHlsZTogZ2V0SW5pdGlhbElucHV0U3R5bGUoKSxcbiAgICB0aHJlZURCdWlsZGluZ0NvbG9yOiBoZXhUb1JnYihERUZBVUxUX0JMREdfQ09MT1IpLFxuICAgIGN1c3RvbTNEQnVpbGRpbmdDb2xvcjogZmFsc2UsXG4gICAgYm90dG9tTWFwU3R5bGU6IHVuZGVmaW5lZCxcbiAgICB0b3BNYXBTdHlsZTogdW5kZWZpbmVkXG4gIH07XG59O1xuXG4vKipcbiAqIFVwZGF0ZXJzIGZvciBgbWFwU3R5bGVgLiBDYW4gYmUgdXNlZCBpbiB5b3VyIHJvb3QgcmVkdWNlciB0byBkaXJlY3RseSBtb2RpZnkga2VwbGVyLmdsJ3Mgc3RhdGUuXG4gKiBSZWFkIG1vcmUgYWJvdXQgW1VzaW5nIHVwZGF0ZXJzXSguLi9hZHZhbmNlZC11c2FnZS91c2luZy11cGRhdGVycy5tZClcbiAqIEBwdWJsaWNcbiAqIEBleGFtcGxlXG4gKlxuICogaW1wb3J0IGtlcGxlckdsUmVkdWNlciwge21hcFN0eWxlVXBkYXRlcnN9IGZyb20gJ2tlcGxlci5nbC9yZWR1Y2Vycyc7XG4gKiAvLyBSb290IFJlZHVjZXJcbiAqIGNvbnN0IHJlZHVjZXJzID0gY29tYmluZVJlZHVjZXJzKHtcbiAqICBrZXBsZXJHbDoga2VwbGVyR2xSZWR1Y2VyLFxuICogIGFwcDogYXBwUmVkdWNlclxuICogfSk7XG4gKlxuICogY29uc3QgY29tcG9zZWRSZWR1Y2VyID0gKHN0YXRlLCBhY3Rpb24pID0+IHtcbiAqICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gKiAgICAvLyBjbGljayBidXR0b24gdG8gaGlkZSBsYWJlbCBmcm9tIGJhY2tncm91bmQgbWFwXG4gKiAgICBjYXNlICdDTElDS19CVVRUT04nOlxuICogICAgICByZXR1cm4ge1xuICogICAgICAgIC4uLnN0YXRlLFxuICogICAgICAgIGtlcGxlckdsOiB7XG4gKiAgICAgICAgICAuLi5zdGF0ZS5rZXBsZXJHbCxcbiAqICAgICAgICAgIGZvbzoge1xuICogICAgICAgICAgICAgLi4uc3RhdGUua2VwbGVyR2wuZm9vLFxuICogICAgICAgICAgICAgbWFwU3R5bGU6IG1hcFN0eWxlVXBkYXRlcnMubWFwQ29uZmlnQ2hhbmdlVXBkYXRlcihcbiAqICAgICAgICAgICAgICAgbWFwU3R5bGUsXG4gKiAgICAgICAgICAgICAgIHtwYXlsb2FkOiB7dmlzaWJsZUxheWVyR3JvdXBzOiB7bGFiZWw6IGZhbHNlLCByb2FkOiB0cnVlLCBiYWNrZ3JvdW5kOiB0cnVlfX19XG4gKiAgICAgICAgICAgICApXG4gKiAgICAgICAgICB9XG4gKiAgICAgICAgfVxuICogICAgICB9O1xuICogIH1cbiAqICByZXR1cm4gcmVkdWNlcnMoc3RhdGUsIGFjdGlvbik7XG4gKiB9O1xuICpcbiAqIGV4cG9ydCBkZWZhdWx0IGNvbXBvc2VkUmVkdWNlcjtcbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbi8vIEB0cy1pZ25vcmVcbmNvbnN0IG1hcFN0eWxlVXBkYXRlcnMgPSBudWxsO1xuLyogZXNsaW50LWVuYWJsZSBuby11bnVzZWQtdmFycyAqL1xuLyoqXG4gKiBEZWZhdWx0IGluaXRpYWwgYG1hcFN0eWxlYFxuICogQG1lbWJlcm9mIG1hcFN0eWxlVXBkYXRlcnNcbiAqIEBjb25zdGFudFxuICogQHByb3BlcnR5IHN0eWxlVHlwZSAtIERlZmF1bHQ6IGAnZGFyaydgXG4gKiBAcHJvcGVydHkgdmlzaWJsZUxheWVyR3JvdXBzIC0gRGVmYXVsdDogYHt9YFxuICogQHByb3BlcnR5IHRvcExheWVyR3JvdXBzIC0gRGVmYXVsdDogYHt9YFxuICogQHByb3BlcnR5IG1hcFN0eWxlcyAtIG1hcHBpbmcgZnJvbSBzdHlsZSBrZXkgdG8gc3R5bGUgb2JqZWN0XG4gKiBAcHJvcGVydHkgbWFwYm94QXBpQWNjZXNzVG9rZW4gLSBEZWZhdWx0OiBgbnVsbGBcbiAqIEBQcm9wZXJ0eSBtYXBib3hBcGlVcmwgLSBEZWZhdWx0IG51bGxcbiAqIEBQcm9wZXJ0eSBtYXBTdHlsZXNSZXBsYWNlRGVmYXVsdCAtIERlZmF1bHQ6IGBmYWxzZWBcbiAqIEBwcm9wZXJ0eSBpbnB1dFN0eWxlIC0gRGVmYXVsdDogYHt9YFxuICogQHByb3BlcnR5IHRocmVlREJ1aWxkaW5nQ29sb3IgLSBEZWZhdWx0OiBgW3IsIGcsIGJdYFxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgSU5JVElBTF9NQVBfU1RZTEU6IE1hcFN0eWxlID0gZ2V0RGVmYXVsdFN0YXRlKCk7XG5cbmludGVyZmFjZSBHZXRNYXBTdHlsZXNQYXJhbSB7XG4gIHN0eWxlVHlwZTogc3RyaW5nO1xuICB2aXNpYmxlTGF5ZXJHcm91cHM6IHtbaWQ6IHN0cmluZ106IExheWVyR3JvdXAgfCBib29sZWFufTtcbiAgdG9wTGF5ZXJHcm91cHM6IHtbaWQ6IHN0cmluZ106IExheWVyR3JvdXAgfCBib29sZWFufTtcbiAgbWFwU3R5bGVzOiB7W2lkOiBzdHJpbmddOiBhbnl9O1xufVxuXG4vKipcbiAqIENyZWF0ZSB0d28gbWFwIHN0eWxlcyBmcm9tIHByZXNldCBtYXAgc3R5bGUsIG9uZSBmb3IgdG9wIG1hcCBvbmUgZm9yIGJvdHRvbVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHlsZVR5cGUgLSBjdXJyZW50IG1hcCBzdHlsZVxuICogQHBhcmFtIHtPYmplY3R9IHZpc2libGVMYXllckdyb3VwcyAtIHZpc2libGUgbGF5ZXJzIG9mIGJvdHRvbSBtYXBcbiAqIEBwYXJhbSB7T2JqZWN0fSB0b3BMYXllckdyb3VwcyAtIHZpc2libGUgbGF5ZXJzIG9mIHRvcCBtYXBcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXBTdHlsZXMgLSBhIGRpY3Rpb25hcnkgb2YgYWxsIG1hcCBzdHlsZXNcbiAqIEByZXR1cm5zIHtPYmplY3R9IGJvdHRvbU1hcFN0eWxlIHwgdG9wTWFwU3R5bGUgfCBpc1Jhc3RlclxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0TWFwU3R5bGVzKHtcbiAgc3R5bGVUeXBlLFxuICB2aXNpYmxlTGF5ZXJHcm91cHMsXG4gIHRvcExheWVyR3JvdXBzLFxuICBtYXBTdHlsZXNcbn06IEdldE1hcFN0eWxlc1BhcmFtKSB7XG4gIGNvbnN0IG1hcFN0eWxlID0gbWFwU3R5bGVzW3N0eWxlVHlwZV07XG5cbiAgLy8gc3R5bGUgbWlnaHQgbm90IGJlIGxvYWRlZCB5ZXRcbiAgaWYgKCFtYXBTdHlsZSB8fCAhbWFwU3R5bGUuc3R5bGUpIHtcbiAgICByZXR1cm4ge307XG4gIH1cblxuICBjb25zdCBlZGl0YWJsZSA9IE9iamVjdC5rZXlzKHZpc2libGVMYXllckdyb3VwcykubGVuZ3RoO1xuXG4gIGNvbnN0IGJvdHRvbU1hcFN0eWxlID0gIWVkaXRhYmxlXG4gICAgPyBtYXBTdHlsZS5zdHlsZVxuICAgIDogZWRpdEJvdHRvbU1hcFN0eWxlKHtcbiAgICAgICAgaWQ6IHN0eWxlVHlwZSxcbiAgICAgICAgbWFwU3R5bGUsXG4gICAgICAgIHZpc2libGVMYXllckdyb3Vwc1xuICAgICAgfSk7XG5cbiAgY29uc3QgaGFzVG9wTGF5ZXIgPSBlZGl0YWJsZSA+IDAgJiYgT2JqZWN0LnZhbHVlcyh0b3BMYXllckdyb3Vwcykuc29tZSh2ID0+IHYpO1xuXG4gIC8vIG11dGUgdG9wIGxheWVyIGlmIG5vdCB2aXNpYmxlIGluIGJvdHRvbSBsYXllclxuICBjb25zdCB0b3BMYXllcnMgPVxuICAgIGhhc1RvcExheWVyICYmXG4gICAgT2JqZWN0LmtleXModG9wTGF5ZXJHcm91cHMpLnJlZHVjZShcbiAgICAgIChhY2N1LCBrZXkpID0+ICh7XG4gICAgICAgIC4uLmFjY3UsXG4gICAgICAgIFtrZXldOiB0b3BMYXllckdyb3Vwc1trZXldICYmIHZpc2libGVMYXllckdyb3Vwc1trZXldXG4gICAgICB9KSxcbiAgICAgIHt9IGFzIHtbaWQ6IHN0cmluZ106IExheWVyR3JvdXAgfCBib29sZWFufVxuICAgICk7XG5cbiAgY29uc3QgdG9wTWFwU3R5bGUgPSBoYXNUb3BMYXllclxuICAgID8gZWRpdFRvcE1hcFN0eWxlKHtcbiAgICAgICAgbWFwU3R5bGUsXG4gICAgICAgIHZpc2libGVMYXllckdyb3VwczogdG9wTGF5ZXJzXG4gICAgICB9KVxuICAgIDogbnVsbDtcblxuICByZXR1cm4ge2JvdHRvbU1hcFN0eWxlLCB0b3BNYXBTdHlsZSwgZWRpdGFibGV9O1xufVxuXG5mdW5jdGlvbiBmaW5kTGF5ZXJGaWxsQ29sb3IobGF5ZXIpIHtcbiAgcmV0dXJuIGxheWVyICYmIGxheWVyLnBhaW50ICYmIGxheWVyLnBhaW50WydiYWNrZ3JvdW5kLWNvbG9yJ107XG59XG5cbmZ1bmN0aW9uIGdldDNEQnVpbGRpbmdDb2xvcihzdHlsZSk6IFJHQkNvbG9yIHtcbiAgLy8gc2V0IGJ1aWxkaW5nIGNvbG9yIHRvIGJlIHRoZSBzYW1lIGFzIHRoZSBiYWNrZ3JvdW5kIGNvbG9yLlxuICBpZiAoIXN0eWxlLnN0eWxlKSB7XG4gICAgcmV0dXJuIGhleFRvUmdiKERFRkFVTFRfQkxER19DT0xPUik7XG4gIH1cblxuICBjb25zdCBiYWNrZ3JvdW5kTGF5ZXIgPSAoc3R5bGUuc3R5bGUubGF5ZXJzIHx8IFtdKS5maW5kKCh7aWR9KSA9PiBpZCA9PT0gJ2JhY2tncm91bmQnKTtcblxuICBjb25zdCBidWlsZGluZ0xheWVyID0gKHN0eWxlLnN0eWxlLmxheWVycyB8fCBbXSkuZmluZCgoe2lkfSkgPT4gaWQubWF0Y2goL2J1aWxkaW5nLykpO1xuXG4gIGNvbnN0IGJ1aWxkaW5nQ29sb3IgPVxuICAgIGZpbmRMYXllckZpbGxDb2xvcihidWlsZGluZ0xheWVyKSB8fCBmaW5kTGF5ZXJGaWxsQ29sb3IoYmFja2dyb3VuZExheWVyKSB8fCBERUZBVUxUX0JMREdfQ09MT1I7XG5cbiAgLy8gYnJpZ2h0ZW4gb3IgZGFya2VuIGJ1aWxkaW5nIGJhc2VkIG9uIHN0eWxlXG4gIGNvbnN0IG9wZXJhdGlvbiA9IHN0eWxlLmlkLm1hdGNoKC8oPz0oZGFya3xuaWdodCkpLykgPyAnYnJpZ2h0ZXInIDogJ2Rhcmtlcic7XG5cbiAgY29uc3QgYWxwaGEgPSAwLjI7XG4gIGNvbnN0IHJnYk9iaiA9IHJnYihidWlsZGluZ0NvbG9yKVtvcGVyYXRpb25dKFthbHBoYV0pO1xuICByZXR1cm4gW3JnYk9iai5yLCByZ2JPYmouZywgcmdiT2JqLmJdO1xufVxuXG5mdW5jdGlvbiBnZXRMYXllckdyb3Vwc0Zyb21TdHlsZShzdHlsZSkge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShzdHlsZS5sYXllcnMpXG4gICAgPyBERUZBVUxUX0xBWUVSX0dST1VQUy5maWx0ZXIobGcgPT4gc3R5bGUubGF5ZXJzLmZpbHRlcihsZy5maWx0ZXIpLmxlbmd0aClcbiAgICA6IFtdO1xufVxuXG4vLyBVcGRhdGVyc1xuLyoqXG4gKiBQcm9wYWdhdGUgYG1hcFN0eWxlYCByZWR1Y2VyIHdpdGggYG1hcGJveEFwaUFjY2Vzc1Rva2VuYCBhbmQgYG1hcFN0eWxlc1JlcGxhY2VEZWZhdWx0YC5cbiAqIGlmIG1hcFN0eWxlc1JlcGxhY2VEZWZhdWx0IGlzIHRydWUgbWFwU3R5bGVzIGlzIGVtcHRpZWQ7IGxvYWRNYXBTdHlsZXNVcGRhdGVyKCkgd2lsbFxuICogcG9wdWxhdGUgbWFwU3R5bGVzLlxuICpcbiAqIEBtZW1iZXJvZiBtYXBTdHlsZVVwZGF0ZXJzXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCBpbml0TWFwU3R5bGVVcGRhdGVyID0gKFxuICBzdGF0ZTogTWFwU3R5bGUsXG4gIHtcbiAgICBwYXlsb2FkID0ge31cbiAgfToge1xuICAgIHR5cGU/OiB0eXBlb2YgQWN0aW9uVHlwZXMuSU5JVDtcbiAgICBwYXlsb2FkOiBLZXBsZXJHbEluaXRQYXlsb2FkO1xuICB9XG4pOiBNYXBTdHlsZSA9PiAoe1xuICAuLi5zdGF0ZSxcbiAgLy8gc2F2ZSBtYXBib3ggYWNjZXNzIHRva2VuIHRvIG1hcCBzdHlsZSBzdGF0ZVxuICBtYXBib3hBcGlBY2Nlc3NUb2tlbjogcGF5bG9hZC5tYXBib3hBcGlBY2Nlc3NUb2tlbiB8fCBzdGF0ZS5tYXBib3hBcGlBY2Nlc3NUb2tlbixcbiAgbWFwYm94QXBpVXJsOiBwYXlsb2FkLm1hcGJveEFwaVVybCB8fCBzdGF0ZS5tYXBib3hBcGlVcmwsXG4gIG1hcFN0eWxlczogIXBheWxvYWQubWFwU3R5bGVzUmVwbGFjZURlZmF1bHQgPyBzdGF0ZS5tYXBTdHlsZXMgOiB7fSxcbiAgbWFwU3R5bGVzUmVwbGFjZURlZmF1bHQ6IHBheWxvYWQubWFwU3R5bGVzUmVwbGFjZURlZmF1bHQgfHwgZmFsc2Vcbn0pO1xuLy8gfSk7XG5cbi8qKlxuICogVXBkYXRlIGB2aXNpYmxlTGF5ZXJHcm91cHNgdG8gY2hhbmdlIGxheWVyIGdyb3VwIHZpc2liaWxpdHlcbiAqIEBtZW1iZXJvZiBtYXBTdHlsZVVwZGF0ZXJzXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCBtYXBDb25maWdDaGFuZ2VVcGRhdGVyID0gKFxuICBzdGF0ZTogTWFwU3R5bGUsXG4gIGFjdGlvbjogTWFwU3R5bGVBY3Rpb25zLk1hcENvbmZpZ0NoYW5nZVVwZGF0ZXJBY3Rpb25cbik6IE1hcFN0eWxlID0+ICh7XG4gIC4uLnN0YXRlLFxuICAuLi5hY3Rpb24ucGF5bG9hZCxcbiAgLi4uZ2V0TWFwU3R5bGVzKHtcbiAgICAuLi5zdGF0ZSxcbiAgICAuLi5hY3Rpb24ucGF5bG9hZFxuICB9KVxufSk7XG5cbi8qKlxuICogQ2hhbmdlIHRvIGFub3RoZXIgbWFwIHN0eWxlLiBUaGUgc2VsZWN0ZWQgc3R5bGUgc2hvdWxkIGFscmVhZHkgYmVlbiBsb2FkZWQgaW50byBgbWFwU3R5bGUubWFwU3R5bGVzYFxuICogQG1lbWJlcm9mIG1hcFN0eWxlVXBkYXRlcnNcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IG1hcFN0eWxlQ2hhbmdlVXBkYXRlciA9IChcbiAgc3RhdGU6IE1hcFN0eWxlLFxuICB7cGF5bG9hZDogc3R5bGVUeXBlfTogTWFwU3R5bGVBY3Rpb25zLk1hcFN0eWxlQ2hhbmdlVXBkYXRlckFjdGlvblxuKTogTWFwU3R5bGUgPT4ge1xuICBpZiAoIXN0YXRlLm1hcFN0eWxlc1tzdHlsZVR5cGVdKSB7XG4gICAgLy8gd2UgbWlnaHQgbm90IGhhdmUgcmVjZWl2ZWQgdGhlIHN0eWxlIHlldFxuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuICBjb25zdCBkZWZhdWx0TEdWaXNpYmlsaXR5ID0gZ2V0RGVmYXVsdExheWVyR3JvdXBWaXNpYmlsaXR5KHN0YXRlLm1hcFN0eWxlc1tzdHlsZVR5cGVdKTtcblxuICBjb25zdCB2aXNpYmxlTGF5ZXJHcm91cHMgPSBtZXJnZUxheWVyR3JvdXBWaXNpYmlsaXR5KFxuICAgIGRlZmF1bHRMR1Zpc2liaWxpdHksXG4gICAgc3RhdGUudmlzaWJsZUxheWVyR3JvdXBzXG4gICk7XG5cbiAgY29uc3QgdGhyZWVEQnVpbGRpbmdDb2xvcjogUkdCQ29sb3IgPSBzdGF0ZS5jdXN0b20zREJ1aWxkaW5nQ29sb3JcbiAgICA/IHN0YXRlLnRocmVlREJ1aWxkaW5nQ29sb3JcbiAgICA6IGdldDNEQnVpbGRpbmdDb2xvcihzdGF0ZS5tYXBTdHlsZXNbc3R5bGVUeXBlXSk7XG5cbiAgcmV0dXJuIHtcbiAgICAuLi5zdGF0ZSxcbiAgICBzdHlsZVR5cGUsXG4gICAgdmlzaWJsZUxheWVyR3JvdXBzLFxuICAgIHRocmVlREJ1aWxkaW5nQ29sb3IsXG4gICAgLi4uZ2V0TWFwU3R5bGVzKHtcbiAgICAgIC4uLnN0YXRlLFxuICAgICAgdmlzaWJsZUxheWVyR3JvdXBzLFxuICAgICAgc3R5bGVUeXBlXG4gICAgfSlcbiAgfTtcbn07XG5cbi8qKlxuICogQ2FsbGJhY2sgd2hlbiBsb2FkIG1hcCBzdHlsZSBzdWNjZXNzXG4gKiBAbWVtYmVyb2YgbWFwU3R5bGVVcGRhdGVyc1xuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgbG9hZE1hcFN0eWxlc1VwZGF0ZXIgPSAoXG4gIHN0YXRlOiBNYXBTdHlsZSxcbiAgYWN0aW9uOiBNYXBTdHlsZUFjdGlvbnMuTG9hZE1hcFN0eWxlc1VwZGF0ZXJBY3Rpb25cbik6IE1hcFN0eWxlID0+IHtcbiAgY29uc3QgbmV3U3R5bGVzID0gYWN0aW9uLnBheWxvYWQgfHwge307XG4gIGNvbnN0IGFkZExheWVyR3JvdXBzID0gT2JqZWN0LmtleXMobmV3U3R5bGVzKS5yZWR1Y2UoXG4gICAgKGFjY3UsIGlkKSA9PiAoe1xuICAgICAgLi4uYWNjdSxcbiAgICAgIFtpZF06IHtcbiAgICAgICAgLi4ubmV3U3R5bGVzW2lkXSxcbiAgICAgICAgbGF5ZXJHcm91cHM6IG5ld1N0eWxlc1tpZF0ubGF5ZXJHcm91cHMgfHwgZ2V0TGF5ZXJHcm91cHNGcm9tU3R5bGUobmV3U3R5bGVzW2lkXS5zdHlsZSlcbiAgICAgIH1cbiAgICB9KSxcbiAgICB7fVxuICApO1xuXG4gIC8vIGFkZCBuZXcgc3R5bGVzIHRvIHN0YXRlXG4gIGNvbnN0IG5ld1N0YXRlID0ge1xuICAgIC4uLnN0YXRlLFxuICAgIG1hcFN0eWxlczoge1xuICAgICAgLi4uc3RhdGUubWFwU3R5bGVzLFxuICAgICAgLi4uYWRkTGF5ZXJHcm91cHNcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIG5ld1N0eWxlc1tzdGF0ZS5zdHlsZVR5cGVdXG4gICAgPyBtYXBTdHlsZUNoYW5nZVVwZGF0ZXIobmV3U3RhdGUsIHtwYXlsb2FkOiBzdGF0ZS5zdHlsZVR5cGV9KVxuICAgIDogbmV3U3RhdGU7XG59O1xuXG4vKipcbiAqIENhbGxiYWNrIHdoZW4gbG9hZCBtYXAgc3R5bGUgZXJyb3JcbiAqIEBtZW1iZXJvZiBtYXBTdHlsZVVwZGF0ZXJzXG4gKiBAcHVibGljXG4gKi9cbi8vIGRvIG5vdGhpbmcgZm9yIG5vdywgaWYgZGlkbid0IGxvYWQsIHNraXAgaXRcbmV4cG9ydCBjb25zdCBsb2FkTWFwU3R5bGVFcnJVcGRhdGVyID0gKFxuICBzdGF0ZTogTWFwU3R5bGUsXG4gIGFjdGlvbjogTWFwU3R5bGVBY3Rpb25zLkxvYWRNYXBTdHlsZUVyclVwZGF0ZXJBY3Rpb25cbik6IE1hcFN0eWxlID0+IHN0YXRlO1xuXG4vKipcbiAqIEBtZW1iZXJvZiBtYXBTdHlsZVVwZGF0ZXJzXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCByZXF1ZXN0TWFwU3R5bGVzVXBkYXRlciA9IChcbiAgc3RhdGU6IE1hcFN0eWxlLFxuICB7cGF5bG9hZDogbWFwU3R5bGVzfTogTWFwU3R5bGVBY3Rpb25zLlJlcXVlc3RNYXBTdHlsZXNVcGRhdGVyQWN0aW9uXG4pOiBNYXBTdHlsZSA9PiB7XG4gIGNvbnN0IGxvYWRNYXBTdHlsZVRhc2tzID0gZ2V0TG9hZE1hcFN0eWxlVGFza3MoXG4gICAgbWFwU3R5bGVzLFxuICAgIHN0YXRlLm1hcGJveEFwaUFjY2Vzc1Rva2VuLFxuICAgIHN0YXRlLm1hcGJveEFwaVVybFxuICApO1xuICByZXR1cm4gd2l0aFRhc2soc3RhdGUsIGxvYWRNYXBTdHlsZVRhc2tzKTtcbn07XG5cbi8qKlxuICogTG9hZCBtYXAgc3R5bGUgb2JqZWN0IHdoZW4gcGFzcyBpbiBzYXZlZCBtYXAgY29uZmlnXG4gKiBAbWVtYmVyb2YgbWFwU3R5bGVVcGRhdGVyc1xuICogQHBhcmFtIHN0YXRlIGBtYXBTdHlsZWBcbiAqIEBwYXJhbSBhY3Rpb25cbiAqIEBwYXJhbSBhY3Rpb24ucGF5bG9hZCBzYXZlZCBtYXAgY29uZmlnIGB7bWFwU3R5bGUsIHZpc1N0YXRlLCBtYXBTdGF0ZX1gXG4gKiBAcmV0dXJucyBuZXh0U3RhdGUgb3IgYHJlYWN0LXBhbWAgdGFza3MgdG8gbG9hZCBtYXAgc3R5bGUgb2JqZWN0XG4gKi9cbmV4cG9ydCBjb25zdCByZWNlaXZlTWFwQ29uZmlnVXBkYXRlciA9IChcbiAgc3RhdGU6IE1hcFN0eWxlLFxuICB7XG4gICAgcGF5bG9hZDoge2NvbmZpZ31cbiAgfToge1xuICAgIHR5cGU/OiB0eXBlb2YgQWN0aW9uVHlwZXMuUkVDRUlWRV9NQVBfQ09ORklHO1xuICAgIHBheWxvYWQ6IFJlY2VpdmVNYXBDb25maWdQYXlsb2FkO1xuICB9XG4pOiBNYXBTdHlsZSA9PiB7XG4gIGNvbnN0IHttYXBTdHlsZX0gPSBjb25maWcgfHwge307XG5cbiAgaWYgKCFtYXBTdHlsZSkge1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuXG4gIC8vIGlmIHNhdmVkIGN1c3RvbSBtYXBTdHlsZXMgbG9hZCB0aGUgc3R5bGUgb2JqZWN0XG4gIGNvbnN0IGxvYWRNYXBTdHlsZVRhc2tzID0gbWFwU3R5bGUubWFwU3R5bGVzXG4gICAgPyBnZXRMb2FkTWFwU3R5bGVUYXNrcyhtYXBTdHlsZS5tYXBTdHlsZXMsIHN0YXRlLm1hcGJveEFwaUFjY2Vzc1Rva2VuLCBzdGF0ZS5tYXBib3hBcGlVcmwpXG4gICAgOiBudWxsO1xuXG4gIC8vIG1lcmdlIGRlZmF1bHQgbWFwU3R5bGVzXG4gIGNvbnN0IG1lcmdlZCA9IG1hcFN0eWxlLm1hcFN0eWxlc1xuICAgID8ge1xuICAgICAgICAuLi5tYXBTdHlsZSxcbiAgICAgICAgbWFwU3R5bGVzOiB7XG4gICAgICAgICAgLi4ubWFwU3R5bGUubWFwU3R5bGVzLFxuICAgICAgICAgIC4uLnN0YXRlLm1hcFN0eWxlc1xuICAgICAgICB9XG4gICAgICB9XG4gICAgOiBtYXBTdHlsZTtcblxuICAvLyBzZXQgY3VzdG9tM0RCdWlsZGluZ0NvbG9yOiB0cnVlIGlmIG1hcFN0eWxlIGNvbnRhaW5zIHRocmVlREJ1aWxkaW5nQ29sb3JcbiAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICBtZXJnZWQuY3VzdG9tM0RCdWlsZGluZ0NvbG9yID1cbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgQm9vbGVhbihtYXBTdHlsZS50aHJlZURCdWlsZGluZ0NvbG9yKSB8fCBtZXJnZWQuY3VzdG9tM0RCdWlsZGluZ0NvbG9yO1xuICBjb25zdCBuZXdTdGF0ZSA9IG1hcENvbmZpZ0NoYW5nZVVwZGF0ZXIoc3RhdGUsIHtwYXlsb2FkOiBtZXJnZWR9KTtcblxuICByZXR1cm4gbG9hZE1hcFN0eWxlVGFza3MgPyB3aXRoVGFzayhuZXdTdGF0ZSwgbG9hZE1hcFN0eWxlVGFza3MpIDogbmV3U3RhdGU7XG59O1xuXG5mdW5jdGlvbiBnZXRMb2FkTWFwU3R5bGVUYXNrcyhtYXBTdHlsZXMsIG1hcGJveEFwaUFjY2Vzc1Rva2VuLCBtYXBib3hBcGlVcmwpIHtcbiAgcmV0dXJuIFtcbiAgICBUYXNrLmFsbChcbiAgICAgIE9iamVjdC52YWx1ZXMobWFwU3R5bGVzKVxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIC5tYXAoKHtpZCwgdXJsLCBhY2Nlc3NUb2tlbn0pID0+ICh7XG4gICAgICAgICAgaWQsXG4gICAgICAgICAgdXJsOiBpc1ZhbGlkU3R5bGVVcmwodXJsKVxuICAgICAgICAgICAgPyBnZXRTdHlsZURvd25sb2FkVXJsKHVybCwgYWNjZXNzVG9rZW4gfHwgbWFwYm94QXBpQWNjZXNzVG9rZW4sIG1hcGJveEFwaVVybClcbiAgICAgICAgICAgIDogdXJsXG4gICAgICAgIH0pKVxuICAgICAgICAubWFwKExPQURfTUFQX1NUWUxFX1RBU0spXG4gICAgKS5iaW1hcChcbiAgICAgIC8vIHN1Y2Nlc3NcbiAgICAgIHJlc3VsdHMgPT5cbiAgICAgICAgbG9hZE1hcFN0eWxlcyhcbiAgICAgICAgICByZXN1bHRzLnJlZHVjZShcbiAgICAgICAgICAgIChhY2N1LCB7aWQsIHN0eWxlfSkgPT4gKHtcbiAgICAgICAgICAgICAgLi4uYWNjdSxcbiAgICAgICAgICAgICAgW2lkXToge1xuICAgICAgICAgICAgICAgIC4uLm1hcFN0eWxlc1tpZF0sXG4gICAgICAgICAgICAgICAgc3R5bGVcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB7fVxuICAgICAgICAgIClcbiAgICAgICAgKSxcbiAgICAgIC8vIGVycm9yXG4gICAgICBsb2FkTWFwU3R5bGVFcnJcbiAgICApXG4gIF07XG59XG4vKipcbiAqIFJlc2V0IG1hcCBzdHlsZSBjb25maWcgdG8gaW5pdGlhbCBzdGF0ZVxuICogQG1lbWJlcm9mIG1hcFN0eWxlVXBkYXRlcnNcbiAqIEBwYXJhbSBzdGF0ZSBgbWFwU3R5bGVgXG4gKiBAcmV0dXJucyBuZXh0U3RhdGVcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IHJlc2V0TWFwQ29uZmlnTWFwU3R5bGVVcGRhdGVyID0gKHN0YXRlOiBNYXBTdHlsZSk6IE1hcFN0eWxlID0+IHtcbiAgY29uc3QgZW1wdHlDb25maWcgPSB7XG4gICAgLi4uSU5JVElBTF9NQVBfU1RZTEUsXG4gICAgbWFwYm94QXBpQWNjZXNzVG9rZW46IHN0YXRlLm1hcGJveEFwaUFjY2Vzc1Rva2VuLFxuICAgIG1hcGJveEFwaVVybDogc3RhdGUubWFwYm94QXBpVXJsLFxuICAgIG1hcFN0eWxlc1JlcGxhY2VEZWZhdWx0OiBzdGF0ZS5tYXBTdHlsZXNSZXBsYWNlRGVmYXVsdCxcbiAgICAuLi5zdGF0ZS5pbml0aWFsU3RhdGUsXG4gICAgbWFwU3R5bGVzOiBzdGF0ZS5tYXBTdHlsZXMsXG4gICAgaW5pdGlhbFN0YXRlOiBzdGF0ZS5pbml0aWFsU3RhdGVcbiAgfTtcblxuICByZXR1cm4gbWFwU3R5bGVDaGFuZ2VVcGRhdGVyKGVtcHR5Q29uZmlnLCB7cGF5bG9hZDogZW1wdHlDb25maWcuc3R5bGVUeXBlfSk7XG59O1xuXG4vKipcbiAqIENhbGxiYWNrIHdoZW4gYSBjdXN0b20gbWFwIHN0eWxlIG9iamVjdCBpcyByZWNlaXZlZFxuICogQG1lbWJlcm9mIG1hcFN0eWxlVXBkYXRlcnNcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IGxvYWRDdXN0b21NYXBTdHlsZVVwZGF0ZXIgPSAoXG4gIHN0YXRlOiBNYXBTdHlsZSxcbiAge3BheWxvYWQ6IHtpY29uLCBzdHlsZSwgZXJyb3J9fTogTWFwU3R5bGVBY3Rpb25zLkxvYWRDdXN0b21NYXBTdHlsZVVwZGF0ZXJBY3Rpb25cbik6IE1hcFN0eWxlID0+ICh7XG4gIC4uLnN0YXRlLFxuICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gIGlucHV0U3R5bGU6IHtcbiAgICAuLi5zdGF0ZS5pbnB1dFN0eWxlLFxuICAgIC8vIHN0eWxlIGpzb24gYW5kIGljb24gd2lsbCBsb2FkIGFzeW5jaHJvbm91c2x5XG4gICAgLi4uKHN0eWxlXG4gICAgICA/IHtcbiAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgaWQ6IHN0eWxlLmlkIHx8IGdlbmVyYXRlSGFzaElkKCksXG4gICAgICAgICAgLy8gbWFrZSBhIGNvcHkgb2YgdGhlIHN0eWxlIG9iamVjdFxuICAgICAgICAgIHN0eWxlOiBjbG9uZURlZXAoc3R5bGUpLFxuICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICBsYWJlbDogc3R5bGUubmFtZSxcbiAgICAgICAgICAvLyBnYXRoZXJpbmcgbGF5ZXIgZ3JvdXAgaW5mbyBmcm9tIHN0eWxlIGpzb25cbiAgICAgICAgICBsYXllckdyb3VwczogZ2V0TGF5ZXJHcm91cHNGcm9tU3R5bGUoc3R5bGUpXG4gICAgICAgIH1cbiAgICAgIDoge30pLFxuICAgIC4uLihpY29uID8ge2ljb259IDoge30pLFxuICAgIC4uLihlcnJvciAhPT0gdW5kZWZpbmVkID8ge2Vycm9yfSA6IHt9KVxuICB9XG59KTtcblxuLyoqXG4gKiBJbnB1dCBhIGN1c3RvbSBtYXAgc3R5bGUgb2JqZWN0XG4gKiBAbWVtYmVyb2YgbWFwU3R5bGVVcGRhdGVyc1xuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgaW5wdXRNYXBTdHlsZVVwZGF0ZXIgPSAoXG4gIHN0YXRlOiBNYXBTdHlsZSxcbiAge3BheWxvYWQ6IHtpbnB1dFN0eWxlLCBtYXBTdGF0ZX19OiBNYXBTdHlsZUFjdGlvbnMuSW5wdXRNYXBTdHlsZVVwZGF0ZXJBY3Rpb25cbik6IE1hcFN0eWxlID0+IHtcbiAgY29uc3QgdXBkYXRlZCA9IHtcbiAgICAuLi5zdGF0ZS5pbnB1dFN0eWxlLFxuICAgIC4uLmlucHV0U3R5bGVcbiAgfTtcblxuICBjb25zdCBpc1ZhbGlkID0gaXNWYWxpZFN0eWxlVXJsKHVwZGF0ZWQudXJsKTtcbiAgY29uc3QgaWNvbiA9IGlzVmFsaWRcbiAgICA/IGdldFN0eWxlSW1hZ2VJY29uKHtcbiAgICAgICAgbWFwU3RhdGUsXG4gICAgICAgIHN0eWxlVXJsOiB1cGRhdGVkLnVybCB8fCAnJyxcbiAgICAgICAgbWFwYm94QXBpQWNjZXNzVG9rZW46IHVwZGF0ZWQuYWNjZXNzVG9rZW4gfHwgc3RhdGUubWFwYm94QXBpQWNjZXNzVG9rZW4gfHwgJycsXG4gICAgICAgIG1hcGJveEFwaVVybDogc3RhdGUubWFwYm94QXBpVXJsIHx8IERFRkFVTFRfTUFQQk9YX0FQSV9VUkxcbiAgICAgIH0pXG4gICAgOiBzdGF0ZS5pbnB1dFN0eWxlLmljb247XG5cbiAgcmV0dXJuIHtcbiAgICAuLi5zdGF0ZSxcbiAgICBpbnB1dFN0eWxlOiB7XG4gICAgICAuLi51cGRhdGVkLFxuICAgICAgaXNWYWxpZCxcbiAgICAgIGljb25cbiAgICB9XG4gIH07XG59O1xuXG4vKipcbiAqIEFkZCBtYXAgc3R5bGUgZnJvbSB1c2VyIGlucHV0IHRvIHJlZHVjZXIgYW5kIHNldCBpdCB0byBjdXJyZW50IHN0eWxlXG4gKiBUaGlzIGFjdGlvbiBpcyBjYWxsZWQgd2hlbiB1c2VyIGNsaWNrIGNvbmZpcm0gYWZ0ZXIgcHV0dGluZyBpbiBhIHZhbGlkIHN0eWxlIHVybCBpbiB0aGUgY3VzdG9tIG1hcCBzdHlsZSBkaWFsb2cuXG4gKiBJdCBzaG91bGQgbm90IGJlIGNhbGxlZCBmcm9tIG91dHNpZGUga2VwbGVyLmdsIHdpdGhvdXQgYSB2YWxpZCBgaW5wdXRTdHlsZWAgaW4gdGhlIGBtYXBTdHlsZWAgcmVkdWNlci5cbiAqIEBtZW1iZXJvZiBtYXBTdHlsZVVwZGF0ZXJzXG4gKi9cbmV4cG9ydCBjb25zdCBhZGRDdXN0b21NYXBTdHlsZVVwZGF0ZXIgPSAoc3RhdGU6IE1hcFN0eWxlKTogTWFwU3R5bGUgPT4ge1xuICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gIGNvbnN0IHN0eWxlSWQgPSBzdGF0ZS5pbnB1dFN0eWxlLmlkO1xuICBjb25zdCBuZXdTdGF0ZSA9IHtcbiAgICAuLi5zdGF0ZSxcbiAgICBtYXBTdHlsZXM6IHtcbiAgICAgIC4uLnN0YXRlLm1hcFN0eWxlcyxcbiAgICAgIFtzdHlsZUlkXTogc3RhdGUuaW5wdXRTdHlsZVxuICAgIH0sXG4gICAgLy8gc2V0IHRvIGRlZmF1bHRcbiAgICBpbnB1dFN0eWxlOiBnZXRJbml0aWFsSW5wdXRTdHlsZSgpXG4gIH07XG4gIC8vIHNldCBuZXcgc3R5bGVcbiAgcmV0dXJuIG1hcFN0eWxlQ2hhbmdlVXBkYXRlcihuZXdTdGF0ZSwge3BheWxvYWQ6IHN0eWxlSWR9KTtcbn07XG5cbi8qKlxuICogVXBkYXRlcyAzZCBidWlsZGluZyBjb2xvclxuICogQG1lbWJlcm9mIG1hcFN0eWxlVXBkYXRlcnNcbiAqL1xuZXhwb3J0IGNvbnN0IHNldDNkQnVpbGRpbmdDb2xvclVwZGF0ZXIgPSAoXG4gIHN0YXRlOiBNYXBTdHlsZSxcbiAge3BheWxvYWQ6IGNvbG9yfTogTWFwU3R5bGVBY3Rpb25zLlNldDNkQnVpbGRpbmdDb2xvclVwZGF0ZXJBY3Rpb25cbik6IE1hcFN0eWxlID0+ICh7XG4gIC4uLnN0YXRlLFxuICB0aHJlZURCdWlsZGluZ0NvbG9yOiBjb2xvcixcbiAgY3VzdG9tM0RCdWlsZGluZ0NvbG9yOiB0cnVlXG59KTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIGluaXRpYWwgaW5wdXQgc3R5bGVcbiAqIEByZXR1cm4gT2JqZWN0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRJbml0aWFsSW5wdXRTdHlsZSgpIHtcbiAgcmV0dXJuIHtcbiAgICBhY2Nlc3NUb2tlbjogbnVsbCxcbiAgICBlcnJvcjogZmFsc2UsXG4gICAgaXNWYWxpZDogZmFsc2UsXG4gICAgbGFiZWw6IG51bGwsXG4gICAgc3R5bGU6IG51bGwsXG4gICAgdXJsOiBudWxsLFxuICAgIGljb246IG51bGwsXG4gICAgY3VzdG9tOiB0cnVlXG4gIH07XG59XG4iXX0=