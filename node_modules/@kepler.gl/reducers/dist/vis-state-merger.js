// Copyright (c) 2022 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.mergeFilters = mergeFilters;
exports.createLayerFromConfig = createLayerFromConfig;
exports.serializeLayer = serializeLayer;
exports.mergeLayers = mergeLayers;
exports.insertLayerAtRightOrder = insertLayerAtRightOrder;
exports.mergeInteractions = mergeInteractions;
exports.mergeSplitMaps = mergeSplitMaps;
exports.mergeInteractionTooltipConfig = mergeInteractionTooltipConfig;
exports.mergeLayerBlending = mergeLayerBlending;
exports.mergeAnimationConfig = mergeAnimationConfig;
exports.validateSavedLayerColumns = validateSavedLayerColumns;
exports.validateColumn = validateColumn;
exports.validateSavedTextLabel = validateSavedTextLabel;
exports.validateSavedVisualChannels = validateSavedVisualChannels;
exports.validateLayersByDatasets = validateLayersByDatasets;
exports.validateLayerWithData = validateLayerWithData;
exports.isValidMerger = isValidMerger;
exports.VIS_STATE_MERGERS = void 0;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _lodash = _interopRequireDefault(require("lodash.uniq"));

var _lodash2 = _interopRequireDefault(require("lodash.pick"));

var _lodash3 = _interopRequireDefault(require("lodash.flattendeep"));

var _utils = require("@kepler.gl/utils");

var _constants = require("@kepler.gl/constants");

var _schemas = require("@kepler.gl/schemas");

var _table = require("@kepler.gl/table");

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/**
 * Merge loaded filters with current state, if no fields or data are loaded
 * save it for later
 *
 */
function mergeFilters(state, filtersToMerge, fromConfig) {
  if (!Array.isArray(filtersToMerge) || !filtersToMerge.length) {
    return state;
  }

  var _validateFiltersUpdat = (0, _utils.validateFiltersUpdateDatasets)(state, filtersToMerge),
      validated = _validateFiltersUpdat.validated,
      failed = _validateFiltersUpdat.failed,
      updatedDatasets = _validateFiltersUpdat.updatedDatasets; // merge filter with existing


  var updatedFilters = [].concat((0, _toConsumableArray2["default"])(state.filters || []), (0, _toConsumableArray2["default"])(validated));
  updatedFilters = (0, _table.resetFilterGpuMode)(updatedFilters);
  updatedFilters = (0, _table.assignGpuChannels)(updatedFilters); // filter data

  var datasetsToFilter = (0, _lodash["default"])((0, _lodash3["default"])(validated.map(function (f) {
    return f.dataId;
  })));
  var filtered = (0, _utils.applyFiltersToDatasets)(datasetsToFilter, updatedDatasets, updatedFilters, state.layers);
  return _objectSpread(_objectSpread({}, state), {}, {
    filters: updatedFilters,
    datasets: filtered,
    filterToBeMerged: [].concat((0, _toConsumableArray2["default"])(state.filterToBeMerged), (0, _toConsumableArray2["default"])(failed))
  });
}

function createLayerFromConfig(state, layerConfig) {
  // first validate config against dataset
  var _validateLayersByData = validateLayersByDatasets(state.datasets, state.layerClasses, [layerConfig]),
      validated = _validateLayersByData.validated,
      failed = _validateLayersByData.failed;

  if (failed !== null && failed !== void 0 && failed.length || !validated.length) {
    // failed
    return null;
  }

  var newLayer = validated[0];
  newLayer.updateLayerDomain(state.datasets);
  return newLayer;
}

function serializeLayer(newLayer) {
  var _visStateSchema$CURRE, _visStateSchema$CURRE2;

  var savedVisState = _schemas.visStateSchema[_schemas.CURRENT_VERSION].save( // @ts-expect-error not all expected properties are provided
  {
    layers: [newLayer],
    layerOrder: [0]
  }).visState;

  var loadedLayer = (_visStateSchema$CURRE = _schemas.visStateSchema[_schemas.CURRENT_VERSION].load(savedVisState).visState) === null || _visStateSchema$CURRE === void 0 ? void 0 : (_visStateSchema$CURRE2 = _visStateSchema$CURRE.layers) === null || _visStateSchema$CURRE2 === void 0 ? void 0 : _visStateSchema$CURRE2[0]; // @ts-expect-error

  return loadedLayer;
}
/**
 * Merge layers from de-serialized state, if no fields or data are loaded
 * save it for later
 *
 */


function mergeLayers(state) {
  var layersToMerge = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  var fromConfig = arguments.length > 2 ? arguments[2] : undefined;
  var preserveLayerOrder = fromConfig ? layersToMerge.map(function (l) {
    return l.id;
  }) : state.preserveLayerOrder;

  if (!Array.isArray(layersToMerge) || !layersToMerge.length) {
    return state;
  }

  var _validateLayersByData2 = validateLayersByDatasets(state.datasets, state.layerClasses, layersToMerge),
      mergedLayer = _validateLayersByData2.validated,
      unmerged = _validateLayersByData2.failed; // put new layers in front of current layers


  var _insertLayerAtRightOr = insertLayerAtRightOrder(state.layers, mergedLayer, state.layerOrder, // @ts-expect-error
  preserveLayerOrder),
      newLayerOrder = _insertLayerAtRightOr.newLayerOrder,
      newLayers = _insertLayerAtRightOr.newLayers;

  return _objectSpread(_objectSpread({}, state), {}, {
    layers: newLayers,
    layerOrder: newLayerOrder,
    preserveLayerOrder: preserveLayerOrder,
    layerToBeMerged: [].concat((0, _toConsumableArray2["default"])(state.layerToBeMerged), (0, _toConsumableArray2["default"])(unmerged))
  });
}

function insertLayerAtRightOrder(currentLayers, layersToInsert, currentOrder) {
  var preservedOrder = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
  // perservedOrder ['a', 'b', 'c'];
  // layerOrder [1, 0, 3]
  // layerOrderMap ['a', 'c']
  var layerOrderQueue = currentOrder.map(function (i) {
    return currentLayers[i].id;
  });
  var newLayers = currentLayers;

  var _iterator = _createForOfIteratorHelper(layersToInsert),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var newLayer = _step.value;
      // find where to insert it
      var expectedIdx = preservedOrder.indexOf(newLayer.id); // if cant find place to insert, insert at the front

      var insertAt = 0;

      if (expectedIdx > 0) {
        // look for layer to insert after
        var i = expectedIdx + 1;
        var preceedIdx = -1;

        while (i-- > 0 && preceedIdx < 0) {
          // keep looking for preceed layer that is already loaded
          var preceedLayer = preservedOrder[i - 1];
          preceedIdx = layerOrderQueue.indexOf(preceedLayer);
        }

        if (preceedIdx > -1) {
          // if found
          insertAt = preceedIdx + 1;
        }
      }

      layerOrderQueue = (0, _utils.arrayInsert)(layerOrderQueue, insertAt, newLayer.id);
      newLayers = newLayers.concat(newLayer);
    } // reconstruct layerOrder after insert

  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  var newLayerOrder = layerOrderQueue.map(function (id) {
    return newLayers.findIndex(function (l) {
      return l.id === id;
    });
  });
  return {
    newLayerOrder: newLayerOrder,
    newLayers: newLayers
  };
}
/**
 * Merge interactions with saved config
 *
 */


function mergeInteractions(state, interactionToBeMerged, fromConfig) {
  var merged = {};
  var unmerged = {};

  if (interactionToBeMerged) {
    Object.keys(interactionToBeMerged).forEach(function (key) {
      if (!state.interactionConfig[key]) {
        return;
      }

      var currentConfig = key === 'tooltip' || key === 'brush' ? state.interactionConfig[key].config : null;

      var _ref = interactionToBeMerged[key] || {},
          enabled = _ref.enabled,
          configSaved = (0, _objectWithoutProperties2["default"])(_ref, ["enabled"]);

      var configToMerge = configSaved;

      if (key === 'tooltip') {
        var _mergeInteractionTool = mergeInteractionTooltipConfig(state, configSaved),
            mergedTooltip = _mergeInteractionTool.mergedTooltip,
            unmergedTooltip = _mergeInteractionTool.unmergedTooltip; // merge new dataset tooltips with original dataset tooltips


        configToMerge = {
          fieldsToShow: _objectSpread(_objectSpread({}, currentConfig.fieldsToShow), mergedTooltip)
        };

        if (Object.keys(unmergedTooltip).length) {
          // @ts-expect-error
          unmerged.tooltip = {
            fieldsToShow: unmergedTooltip,
            enabled: Boolean(enabled)
          };
        }
      }

      merged[key] = _objectSpread(_objectSpread({}, state.interactionConfig[key]), {}, {
        enabled: Boolean(enabled)
      }, currentConfig ? {
        config: (0, _lodash2["default"])(_objectSpread(_objectSpread({}, currentConfig), configToMerge), Object.keys(currentConfig))
      } : {});
    });
  }

  return _objectSpread(_objectSpread({}, state), {}, {
    interactionConfig: _objectSpread(_objectSpread({}, state.interactionConfig), merged),
    interactionToBeMerged: unmerged
  });
}
/**
 * Merge splitMaps config with current visStete.
 * 1. if current map is split, but splitMap DOESNOT contain maps
 *    : don't merge anything
 * 2. if current map is NOT split, but splitMaps contain maps
 *    : add to splitMaps, and add current layers to splitMaps
 */


function mergeSplitMaps(state) {
  var splitMaps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  var fromConfig = arguments.length > 2 ? arguments[2] : undefined;
  var merged = (0, _toConsumableArray2["default"])(state.splitMaps);
  var unmerged = [];
  splitMaps.forEach(function (sm, i) {
    Object.entries(sm.layers).forEach(function (_ref2) {
      var _ref3 = (0, _slicedToArray2["default"])(_ref2, 2),
          id = _ref3[0],
          value = _ref3[1];

      // check if layer exists
      var pushTo = state.layers.find(function (l) {
        return l.id === id;
      }) ? merged : unmerged; // create map panel if current map is not split

      pushTo[i] = pushTo[i] || {
        layers: pushTo === merged ? (0, _utils.getInitialMapLayersForSplitMap)(state.layers) : []
      };
      pushTo[i].layers = _objectSpread(_objectSpread({}, pushTo[i].layers), {}, (0, _defineProperty2["default"])({}, id, value));
    });
  });
  return _objectSpread(_objectSpread({}, state), {}, {
    splitMaps: merged,
    splitMapsToBeMerged: [].concat((0, _toConsumableArray2["default"])(state.splitMapsToBeMerged), unmerged)
  });
}
/**
 * Merge interactionConfig.tooltip with saved config,
 * validate fieldsToShow
 *
 * @param state
 * @param tooltipConfig
 * @return - {mergedTooltip: {}, unmergedTooltip: {}}
 */


function mergeInteractionTooltipConfig(state) {
  var tooltipConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var unmergedTooltip = {};
  var mergedTooltip = {};

  if (!tooltipConfig || !tooltipConfig.fieldsToShow || !Object.keys(tooltipConfig.fieldsToShow).length) {
    return {
      mergedTooltip: mergedTooltip,
      unmergedTooltip: unmergedTooltip
    };
  }

  for (var dataId in tooltipConfig.fieldsToShow) {
    if (!state.datasets[dataId]) {
      // is not yet loaded
      unmergedTooltip[dataId] = tooltipConfig.fieldsToShow[dataId];
    } else {
      (function () {
        // if dataset is loaded
        var allFields = state.datasets[dataId].fields.map(function (d) {
          return d.name;
        });
        var foundFieldsToShow = tooltipConfig.fieldsToShow[dataId].filter(function (field) {
          return allFields.includes(field.name);
        });
        mergedTooltip[dataId] = foundFieldsToShow;
      })();
    }
  }

  return {
    mergedTooltip: mergedTooltip,
    unmergedTooltip: unmergedTooltip
  };
}
/**
 * Merge layerBlending with saved
 *
 */


function mergeLayerBlending(state, layerBlending, fromConfig) {
  if (layerBlending && _constants.LAYER_BLENDINGS[layerBlending]) {
    return _objectSpread(_objectSpread({}, state), {}, {
      layerBlending: layerBlending
    });
  }

  return state;
}
/**
 * Merge animation config
 */


function mergeAnimationConfig(state, animation, fromConfig) {
  if (animation && animation.currentTime) {
    return _objectSpread(_objectSpread({}, state), {}, {
      animationConfig: _objectSpread(_objectSpread(_objectSpread({}, state.animationConfig), animation), {}, {
        domain: null
      })
    });
  }

  return state;
}
/**
 * Validate saved layer columns with new data,
 * update fieldIdx based on new fields
 *
 * @param fields
 * @param savedCols
 * @param emptyCols
 * @return - validated columns or null
 */


function validateSavedLayerColumns(fields) {
  var savedCols = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var emptyCols = arguments.length > 2 ? arguments[2] : undefined;
  // Prepare columns for the validator
  var columns = {};

  var _loop = function _loop() {
    var key = _Object$keys[_i];
    columns[key] = _objectSpread({}, emptyCols[key]);
    var saved = savedCols[key];

    if (saved) {
      var fieldIdx = fields.findIndex(function (_ref4) {
        var name = _ref4.name;
        return name === saved;
      });

      if (fieldIdx > -1) {
        // update found columns
        columns[key].fieldIdx = fieldIdx;
        columns[key].value = saved;
      }
    }
  };

  for (var _i = 0, _Object$keys = Object.keys(emptyCols); _i < _Object$keys.length; _i++) {
    _loop();
  } // find actual column fieldIdx, in case it has changed


  var allColFound = Object.keys(columns).every(function (key) {
    return validateColumn(columns[key], columns, fields);
  });

  if (allColFound) {
    return columns;
  }

  return null;
}

function validateColumn(column, columns, allFields) {
  if (column.optional || column.value) {
    return true;
  }

  if (column.validator) {
    return column.validator(column, columns, allFields);
  }

  return false;
}
/**
 * Validate saved text label config with new data
 * refer to vis-state-schema.js TextLabelSchemaV1
 *
 * @param {Array<Object>} fields
 * @param {Object} savedTextLabel
 * @return {Object} - validated textlabel
 */


function validateSavedTextLabel(fields, _ref5, savedTextLabel) {
  var _ref6 = (0, _slicedToArray2["default"])(_ref5, 1),
      layerTextLabel = _ref6[0];

  var savedTextLabels = Array.isArray(savedTextLabel) ? savedTextLabel : [savedTextLabel]; // validate field

  return savedTextLabels.map(function (textLabel) {
    var field = textLabel.field ? fields.find(function (fd) {
      return Object.keys(textLabel.field).every(function (key) {
        return textLabel.field[key] === fd[key];
      });
    }) : null;
    return Object.keys(layerTextLabel).reduce(function (accu, key) {
      return _objectSpread(_objectSpread({}, accu), {}, (0, _defineProperty2["default"])({}, key, key === 'field' ? field : textLabel[key] || layerTextLabel[key]));
    }, {});
  });
}
/**
 * Validate saved visual channels config with new data,
 * refer to vis-state-schema.js VisualChannelSchemaV1
 */


function validateSavedVisualChannels(fields, newLayer, savedLayer) {
  Object.values(newLayer.visualChannels).forEach(function (_ref7) {
    var field = _ref7.field,
        scale = _ref7.scale,
        key = _ref7.key;
    var foundField;

    if (savedLayer.config) {
      if (savedLayer.config[field]) {
        foundField = fields.find(function (fd) {
          return savedLayer.config && fd.name === savedLayer.config[field].name;
        });
      }

      var foundChannel = _objectSpread(_objectSpread({}, foundField ? (0, _defineProperty2["default"])({}, field, foundField) : {}), savedLayer.config[scale] ? (0, _defineProperty2["default"])({}, scale, savedLayer.config[scale]) : {});

      if (Object.keys(foundChannel).length) {
        newLayer.updateLayerConfig(foundChannel);
      }

      newLayer.validateVisualChannel(key);
    }
  });
  return newLayer;
}

function validateLayersByDatasets(datasets, layerClasses) {
  var layers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
  var validated = [];
  var failed = [];
  layers.forEach(function (layer) {
    var _layer$config;

    var validateLayer = null;

    if (layer !== null && layer !== void 0 && (_layer$config = layer.config) !== null && _layer$config !== void 0 && _layer$config.dataId) {
      if (datasets[layer.config.dataId]) {
        // datasets are already loaded
        validateLayer = validateLayerWithData(datasets[layer.config.dataId], layer, layerClasses);
      }
    }

    if (validateLayer) {
      validated.push(validateLayer);
    } else {
      // datasets not yet loaded
      failed.push(layer);
    }
  });
  return {
    validated: validated,
    failed: failed
  };
}
/**
 * Validate saved layer config with new data,
 * update fieldIdx based on new fields
 */


function validateLayerWithData(_ref10, savedLayer, layerClasses) {
  var fields = _ref10.fields,
      dataId = _ref10.id;
  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  var type = savedLayer.type; // layer doesnt have a valid type

  if (!type || !layerClasses.hasOwnProperty(type) || !savedLayer.config) {
    return null;
  }

  var newLayer = new layerClasses[type]({
    id: savedLayer.id,
    dataId: dataId,
    label: savedLayer.config.label,
    color: savedLayer.config.color,
    isVisible: savedLayer.config.isVisible,
    hidden: savedLayer.config.hidden,
    highlightColor: savedLayer.config.highlightColor
  }); // find column fieldIdx

  var columnConfig = newLayer.getLayerColumns();

  if (Object.keys(columnConfig).length) {
    var columns = validateSavedLayerColumns(fields, savedLayer.config.columns, columnConfig);

    if (columns) {
      newLayer.updateLayerConfig({
        columns: columns
      });
    } else if (!options.allowEmptyColumn) {
      return null;
    }
  } // visual channel field is saved to be {name, type}
  // find visual channel field by matching both name and type
  // refer to vis-state-schema.js VisualChannelSchemaV1


  newLayer = validateSavedVisualChannels(fields, newLayer, savedLayer);
  var textLabel = savedLayer.config.textLabel && newLayer.config.textLabel ? validateSavedTextLabel(fields, newLayer.config.textLabel, savedLayer.config.textLabel) : newLayer.config.textLabel; // copy visConfig over to emptyLayer to make sure it has all the props

  var visConfig = newLayer.copyLayerConfig(newLayer.config.visConfig, savedLayer.config.visConfig || {}, {
    shallowCopy: ['colorRange', 'strokeColorRange']
  });
  newLayer.updateLayerConfig({
    visConfig: visConfig,
    textLabel: textLabel
  });
  return newLayer;
}

function isValidMerger(merger) {
  return (0, _utils.isObject)(merger) && typeof merger.merge === 'function' && typeof merger.prop === 'string';
}

var VIS_STATE_MERGERS = [{
  merge: mergeLayers,
  prop: 'layers',
  toMergeProp: 'layerToBeMerged'
}, {
  merge: mergeFilters,
  prop: 'filters',
  toMergeProp: 'filterToBeMerged'
}, {
  merge: mergeInteractions,
  prop: 'interactionConfig',
  toMergeProp: 'interactionToBeMerged'
}, {
  merge: mergeLayerBlending,
  prop: 'layerBlending'
}, {
  merge: mergeSplitMaps,
  prop: 'splitMaps',
  toMergeProp: 'splitMapsToBeMerged'
}, {
  merge: mergeAnimationConfig,
  prop: 'animationConfig'
}];
exports.VIS_STATE_MERGERS = VIS_STATE_MERGERS;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy92aXMtc3RhdGUtbWVyZ2VyLnRzIl0sIm5hbWVzIjpbIm1lcmdlRmlsdGVycyIsInN0YXRlIiwiZmlsdGVyc1RvTWVyZ2UiLCJmcm9tQ29uZmlnIiwiQXJyYXkiLCJpc0FycmF5IiwibGVuZ3RoIiwidmFsaWRhdGVkIiwiZmFpbGVkIiwidXBkYXRlZERhdGFzZXRzIiwidXBkYXRlZEZpbHRlcnMiLCJmaWx0ZXJzIiwiZGF0YXNldHNUb0ZpbHRlciIsIm1hcCIsImYiLCJkYXRhSWQiLCJmaWx0ZXJlZCIsImxheWVycyIsImRhdGFzZXRzIiwiZmlsdGVyVG9CZU1lcmdlZCIsImNyZWF0ZUxheWVyRnJvbUNvbmZpZyIsImxheWVyQ29uZmlnIiwidmFsaWRhdGVMYXllcnNCeURhdGFzZXRzIiwibGF5ZXJDbGFzc2VzIiwibmV3TGF5ZXIiLCJ1cGRhdGVMYXllckRvbWFpbiIsInNlcmlhbGl6ZUxheWVyIiwic2F2ZWRWaXNTdGF0ZSIsInZpc1N0YXRlU2NoZW1hIiwiQ1VSUkVOVF9WRVJTSU9OIiwic2F2ZSIsImxheWVyT3JkZXIiLCJ2aXNTdGF0ZSIsImxvYWRlZExheWVyIiwibG9hZCIsIm1lcmdlTGF5ZXJzIiwibGF5ZXJzVG9NZXJnZSIsInByZXNlcnZlTGF5ZXJPcmRlciIsImwiLCJpZCIsIm1lcmdlZExheWVyIiwidW5tZXJnZWQiLCJpbnNlcnRMYXllckF0UmlnaHRPcmRlciIsIm5ld0xheWVyT3JkZXIiLCJuZXdMYXllcnMiLCJsYXllclRvQmVNZXJnZWQiLCJjdXJyZW50TGF5ZXJzIiwibGF5ZXJzVG9JbnNlcnQiLCJjdXJyZW50T3JkZXIiLCJwcmVzZXJ2ZWRPcmRlciIsImxheWVyT3JkZXJRdWV1ZSIsImkiLCJleHBlY3RlZElkeCIsImluZGV4T2YiLCJpbnNlcnRBdCIsInByZWNlZWRJZHgiLCJwcmVjZWVkTGF5ZXIiLCJjb25jYXQiLCJmaW5kSW5kZXgiLCJtZXJnZUludGVyYWN0aW9ucyIsImludGVyYWN0aW9uVG9CZU1lcmdlZCIsIm1lcmdlZCIsIk9iamVjdCIsImtleXMiLCJmb3JFYWNoIiwia2V5IiwiaW50ZXJhY3Rpb25Db25maWciLCJjdXJyZW50Q29uZmlnIiwiY29uZmlnIiwiZW5hYmxlZCIsImNvbmZpZ1NhdmVkIiwiY29uZmlnVG9NZXJnZSIsIm1lcmdlSW50ZXJhY3Rpb25Ub29sdGlwQ29uZmlnIiwibWVyZ2VkVG9vbHRpcCIsInVubWVyZ2VkVG9vbHRpcCIsImZpZWxkc1RvU2hvdyIsInRvb2x0aXAiLCJCb29sZWFuIiwibWVyZ2VTcGxpdE1hcHMiLCJzcGxpdE1hcHMiLCJzbSIsImVudHJpZXMiLCJ2YWx1ZSIsInB1c2hUbyIsImZpbmQiLCJzcGxpdE1hcHNUb0JlTWVyZ2VkIiwidG9vbHRpcENvbmZpZyIsImFsbEZpZWxkcyIsImZpZWxkcyIsImQiLCJuYW1lIiwiZm91bmRGaWVsZHNUb1Nob3ciLCJmaWx0ZXIiLCJmaWVsZCIsImluY2x1ZGVzIiwibWVyZ2VMYXllckJsZW5kaW5nIiwibGF5ZXJCbGVuZGluZyIsIkxBWUVSX0JMRU5ESU5HUyIsIm1lcmdlQW5pbWF0aW9uQ29uZmlnIiwiYW5pbWF0aW9uIiwiY3VycmVudFRpbWUiLCJhbmltYXRpb25Db25maWciLCJkb21haW4iLCJ2YWxpZGF0ZVNhdmVkTGF5ZXJDb2x1bW5zIiwic2F2ZWRDb2xzIiwiZW1wdHlDb2xzIiwiY29sdW1ucyIsInNhdmVkIiwiZmllbGRJZHgiLCJhbGxDb2xGb3VuZCIsImV2ZXJ5IiwidmFsaWRhdGVDb2x1bW4iLCJjb2x1bW4iLCJvcHRpb25hbCIsInZhbGlkYXRvciIsInZhbGlkYXRlU2F2ZWRUZXh0TGFiZWwiLCJzYXZlZFRleHRMYWJlbCIsImxheWVyVGV4dExhYmVsIiwic2F2ZWRUZXh0TGFiZWxzIiwidGV4dExhYmVsIiwiZmQiLCJyZWR1Y2UiLCJhY2N1IiwidmFsaWRhdGVTYXZlZFZpc3VhbENoYW5uZWxzIiwic2F2ZWRMYXllciIsInZhbHVlcyIsInZpc3VhbENoYW5uZWxzIiwic2NhbGUiLCJmb3VuZEZpZWxkIiwiZm91bmRDaGFubmVsIiwidXBkYXRlTGF5ZXJDb25maWciLCJ2YWxpZGF0ZVZpc3VhbENoYW5uZWwiLCJsYXllciIsInZhbGlkYXRlTGF5ZXIiLCJ2YWxpZGF0ZUxheWVyV2l0aERhdGEiLCJwdXNoIiwib3B0aW9ucyIsInR5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImxhYmVsIiwiY29sb3IiLCJpc1Zpc2libGUiLCJoaWRkZW4iLCJoaWdobGlnaHRDb2xvciIsImNvbHVtbkNvbmZpZyIsImdldExheWVyQ29sdW1ucyIsImFsbG93RW1wdHlDb2x1bW4iLCJ2aXNDb25maWciLCJjb3B5TGF5ZXJDb25maWciLCJzaGFsbG93Q29weSIsImlzVmFsaWRNZXJnZXIiLCJtZXJnZXIiLCJtZXJnZSIsInByb3AiLCJWSVNfU1RBVEVfTUVSR0VSUyIsInRvTWVyZ2VQcm9wIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBb0JBOztBQUNBOztBQUNBOztBQUNBOztBQVNBOztBQUNBOztBQVVBOzs7Ozs7Ozs7Ozs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sU0FBU0EsWUFBVCxDQUNMQyxLQURLLEVBRUxDLGNBRkssRUFHTEMsVUFISyxFQUlGO0FBQ0gsTUFBSSxDQUFDQyxLQUFLLENBQUNDLE9BQU4sQ0FBY0gsY0FBZCxDQUFELElBQWtDLENBQUNBLGNBQWMsQ0FBQ0ksTUFBdEQsRUFBOEQ7QUFDNUQsV0FBT0wsS0FBUDtBQUNEOztBQUhFLDhCQUswQywwQ0FBOEJBLEtBQTlCLEVBQXFDQyxjQUFyQyxDQUwxQztBQUFBLE1BS0lLLFNBTEoseUJBS0lBLFNBTEo7QUFBQSxNQUtlQyxNQUxmLHlCQUtlQSxNQUxmO0FBQUEsTUFLdUJDLGVBTHZCLHlCQUt1QkEsZUFMdkIsRUFPSDs7O0FBQ0EsTUFBSUMsY0FBYyxpREFBUVQsS0FBSyxDQUFDVSxPQUFOLElBQWlCLEVBQXpCLHVDQUFpQ0osU0FBakMsRUFBbEI7QUFDQUcsRUFBQUEsY0FBYyxHQUFHLCtCQUFtQkEsY0FBbkIs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UyxFQUFUQTtBQUZ5QixHQUEzQjtBQUtBLFNBQU8vRixRQUFQO0FBQ0Q7O0FBRU0sU0FBUzhILGFBQVQsQ0FBdUJDLE1BQXZCLEVBQWdEO0FBQ3JELFNBQU8scUJBQVNBLE1BQVQsS0FBb0IsT0FBT0EsTUFBTSxDQUFDQyxLQUFkLEtBQXdCLFVBQTVDLElBQTBELE9BQU9ELE1BQU0sQ0FBQ0UsSUFBZCxLQUF1QixRQUF4RjtBQUNEOztBQUVNLElBQU1DLGlCQUFrQyxHQUFHLENBQ2hEO0FBQUNGLEVBQUFBLEtBQUssRUFBRXJILFdBQVI7QUFBcUJzSCxFQUFBQSxJQUFJLEVBQUUsUUFBM0I7QUFBcUNFLEVBQUFBLFdBQVcsRUFBRTtBQUFsRCxDQURnRCxFQUVoRDtBQUFDSCxFQUFBQSxLQUFLLEVBQUV4SixZQUFSO0FBQXNCeUosRUFBQUEsSUFBSSxFQUFFLFNBQTVCO0FBQXVDRSxFQUFBQSxXQUFXLEVBQUU7QUFBcEQsQ0FGZ0QsRUFHaEQ7QUFBQ0gsRUFBQUEsS0FBSyxFQUFFN0YsaUJBQVI7QUFBMkI4RixFQUFBQSxJQUFJLEVBQUUsbUJBQWpDO0FBQXNERSxFQUFBQSxXQUFXLEVBQUU7QUFBbkUsQ0FIZ0QsRUFJaEQ7QUFBQ0gsRUFBQUEsS0FBSyxFQUFFekQsa0JBQVI7QUFBNEIwRCxFQUFBQSxJQUFJLEVBQUU7QUFBbEMsQ0FKZ0QsRUFLaEQ7QUFBQ0QsRUFBQUEsS0FBSyxFQUFFMUUsY0FBUjtBQUF3QjJFLEVBQUFBLElBQUksRUFBRSxXQUE5QjtBQUEyQ0UsRUFBQUEsV0FBVyxFQUFFO0FBQXhELENBTGdELEVBTWhEO0FBQUNILEVBQUFBLEtBQUssRUFBRXRELG9CQUFSO0FBQThCdUQsRUFBQUEsSUFBSSxFQUFFO0FBQXBDLENBTmdELENBQTNDIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDIyIFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuaW1wb3J0IHVuaXEgZnJvbSAnbG9kYXNoLnVuaXEnO1xuaW1wb3J0IHBpY2sgZnJvbSAnbG9kYXNoLnBpY2snO1xuaW1wb3J0IGZsYXR0ZW5EZWVwIGZyb20gJ2xvZGFzaC5mbGF0dGVuZGVlcCc7XG5pbXBvcnQge1xuICBpc09iamVjdCxcbiAgYXJyYXlJbnNlcnQsXG4gIGdldEluaXRpYWxNYXBMYXllcnNGb3JTcGxpdE1hcCxcbiAgYXBwbHlGaWx0ZXJzVG9EYXRhc2V0cyxcbiAgdmFsaWRhdGVGaWx0ZXJzVXBkYXRlRGF0YXNldHNcbn0gZnJvbSAnQGtlcGxlci5nbC91dGlscyc7XG5cbmltcG9ydCB7TGF5ZXJDb2x1bW5zLCBMYXllckNvbHVtbiwgTGF5ZXJ9IGZyb20gJ0BrZXBsZXIuZ2wvbGF5ZXJzJztcbmltcG9ydCB7TEFZRVJfQkxFTkRJTkdTfSBmcm9tICdAa2VwbGVyLmdsL2NvbnN0YW50cyc7XG5pbXBvcnQge1xuICBDVVJSRU5UX1ZFUlNJT04sXG4gIE1lcmdlcixcbiAgVmlzU3RhdGUsXG4gIFZpc1N0YXRlTWVyZ2VycyxcbiAgdmlzU3RhdGVTY2hlbWEsXG4gIFBhcnNlZENvbmZpZ1xufSBmcm9tICdAa2VwbGVyLmdsL3NjaGVtYXMnO1xuXG5pbXBvcnQge1BhcnNlZExheWVyLCBTYXZlZEludGVyYWN0aW9uQ29uZmlnLCBUb29sdGlwSW5mb30gZnJvbSAnQGtlcGxlci5nbC90eXBlcyc7XG5pbXBvcnQge0tlcGxlclRhYmxlLCBEYXRhc2V0cywgYXNzaWduR3B1Q2hhbm5lbHMsIHJlc2V0RmlsdGVyR3B1TW9kZX0gZnJvbSAnQGtlcGxlci5nbC90YWJsZSc7XG5cbi8qKlxuICogTWVyZ2UgbG9hZGVkIGZpbHRlcnMgd2l0aCBjdXJyZW50IHN0YXRlLCBpZiBubyBmaWVsZHMgb3IgZGF0YSBhcmUgbG9hZGVkXG4gKiBzYXZlIGl0IGZvciBsYXRlclxuICpcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlRmlsdGVyczxTIGV4dGVuZHMgVmlzU3RhdGU+KFxuICBzdGF0ZTogUyxcbiAgZmlsdGVyc1RvTWVyZ2U6IE5vbk51bGxhYmxlPFBhcnNlZENvbmZpZ1sndmlzU3RhdGUnXT5bJ2ZpbHRlcnMnXSxcbiAgZnJvbUNvbmZpZz86IGJvb2xlYW5cbik6IFMge1xuICBpZiAoIUFycmF5LmlzQXJyYXkoZmlsdGVyc1RvTWVyZ2UpIHx8ICFmaWx0ZXJzVG9NZXJnZS5sZW5ndGgpIHtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cblxuICBjb25zdCB7dmFsaWRhdGVkLCBmYWlsZWQsIHVwZGF0ZWREYXRhc2V0c30gPSB2YWxpZGF0ZUZpbHRlcnNVcGRhdGVEYXRhc2V0cyhzdGF0ZSwgZmlsdGVyc1RvTWVyZ2UpO1xuXG4gIC8vIG1lcmdlIGZpbHRlciB3aXRoIGV4aXN0aW5nXG4gIGxldCB1cGRhdGVkRmlsdGVycyA9IFsuLi4oc3RhdGUuZmlsdGVycyB8fCBbXSksIC4uLnZhbGlkYXRlZF07XG4gIHVwZGF0ZWRGaWx0ZXJzID0gcmVzZXRGaWx0ZXJHcHVNb2RlKHVwZGF0ZWRGaWx0ZXJzKTtcbiAgdXBkYXRlZEZpbHRlcnMgPSBhc3NpZ25HcHVDaGFubmVscyh1cGRhdGVkRmlsdGVycyk7XG4gIC8vIGZpbHRlciBkYXRhXG4gIGNvbnN0IGRhdGFzZXRzVG9GaWx0ZXIgPSB1bmlxKGZsYXR0ZW5EZWVwKHZhbGlkYXRlZC5tYXAoZiA9PiBmLmRhdGFJZCkpKTtcblxuICBjb25zdCBmaWx0ZXJlZCA9IGFwcGx5RmlsdGVyc1RvRGF0YXNldHMoXG4gICAgZGF0YXNldHNUb0ZpbHRlcixcbiAgICB1cGRhdGVkRGF0YXNldHMsXG4gICAgdXBkYXRlZEZpbHRlcnMsXG4gICAgc3RhdGUubGF5ZXJzXG4gICk7XG5cbiAgcmV0dXJuIHtcbiAgICAuLi5zdGF0ZSxcbiAgICBmaWx0ZXJzOiB1cGRhdGVkRmlsdGVycyxcbiAgICBkYXRhc2V0czogZmlsdGVyZWQsXG4gICAgZmlsdGVyVG9CZU1lcmdlZDogWy4uLnN0YXRlLmZpbHRlclRvQmVNZXJnZWQsIC4uLmZhaWxlZF1cbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUxheWVyRnJvbUNvbmZpZyhzdGF0ZTogVmlzU3RhdGUsIGxheWVyQ29uZmlnOiBhbnkpOiBMYXllciB8IG51bGwge1xuICAvLyBmaXJzdCB2YWxpZGF0ZSBjb25maWcgYWdhaW5zdCBkYXRhc2V0XG4gIGNvbnN0IHt2YWxpZGF0ZWQsIGZhaWxlZH0gPSB2YWxpZGF0ZUxheWVyc0J5RGF0YXNldHMoc3RhdGUuZGF0YXNldHMsIHN0YXRlLmxheWVyQ2xhc3NlcywgW1xuICAgIGxheWVyQ29uZmlnXG4gIF0pO1xuXG4gIGlmIChmYWlsZWQ/Lmxlbmd0aCB8fCAhdmFsaWRhdGVkLmxlbmd0aCkge1xuICAgIC8vIGZhaWxlZFxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgY29uc3QgbmV3TGF5ZXIgPSB2YWxpZGF0ZWRbMF07XG4gIG5ld0xheWVyLnVwZGF0ZUxheWVyRG9tYWluKHN0YXRlLmRhdGFzZXRzKTtcbiAgcmV0dXJuIG5ld0xheWVyO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2VyaWFsaXplTGF5ZXIobmV3TGF5ZXIpOiBQYXJzZWRMYXllciB7XG4gIGNvbnN0IHNhdmVkVmlzU3RhdGUgPSB2aXNTdGF0ZVNjaGVtYVtDVVJSRU5UX1ZFUlNJT05dLnNhdmUoXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciBub3QgYWxsIGV4cGVjdGVkIHByb3BlcnRpZXMgYXJlIHByb3ZpZGVkXG4gICAge1xuICAgICAgbGF5ZXJzOiBbbmV3TGF5ZXJdLFxuICAgICAgbGF5ZXJPcmRlcjogWzBdXG4gICAgfVxuICApLnZpc1N0YXRlO1xuICBjb25zdCBsb2FkZWRMYXllciA9IHZpc1N0YXRlU2NoZW1hW0NVUlJFTlRfVkVSU0lPTl0ubG9hZChzYXZlZFZpc1N0YXRlKS52aXNTdGF0ZT8ubGF5ZXJzPy5bMF07XG4gIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgcmV0dXJuIGxvYWRlZExheWVyO1xufVxuXG4vKipcbiAqIE1lcmdlIGxheWVycyBmcm9tIGRlLXNlcmlhbGl6ZWQgc3RhdGUsIGlmIG5vIGZpZWxkcyBvciBkYXRhIGFyZSBsb2FkZWRcbiAqIHNhdmUgaXQgZm9yIGxhdGVyXG4gKlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VMYXllcnM8UyBleHRlbmRzIFZpc1N0YXRlPihcbiAgc3RhdGU6IFMsXG4gIGxheWVyc1RvTWVyZ2U6IE5vbk51bGxhYmxlPFBhcnNlZENvbmZpZ1sndmlzU3RhdGUnXT5bJ2xheWVycyddID0gW10sXG4gIGZyb21Db25maWc/OiBib29sZWFuXG4pOiBTIHtcbiAgY29uc3QgcHJlc2VydmVMYXllck9yZGVyID0gZnJvbUNvbmZpZyA/IGxheWVyc1RvTWVyZ2UubWFwKGwgPT4gbC5pZCkgOiBzdGF0ZS5wcmVzZXJ2ZUxheWVyT3JkZXI7XG5cbiAgaWYgKCFBcnJheS5pc0FycmF5KGxheWVyc1RvTWVyZ2UpIHx8ICFsYXllcnNUb01lcmdlLmxlbmd0aCkge1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuXG4gIGNvbnN0IHt2YWxpZGF0ZWQ6IG1lcmdlZExheWVyLCBmYWlsZWQ6IHVubWVyZ2VkfSA9IHZhbGlkYXRlTGF5ZXJzQnlEYXRhc2V0cyhcbiAgICBzdGF0ZS5kYXRhc2V0cyxcbiAgICBzdGF0ZS5sYXllckNsYXNzZXMsXG4gICAgbGF5ZXJzVG9NZXJnZVxuICApO1xuXG4gIC8vIHB1dCBuZXcgbGF5ZXJzIGluIGZyb250IG9mIGN1cnJlbnQgbGF5ZXJzXG4gIGNvbnN0IHtuZXdMYXllck9yZGVyLCBuZXdMYXllcnN9ID0gaW5zZXJ0TGF5ZXJBdFJpZ2h0T3JkZXIoXG4gICAgc3RhdGUubGF5ZXJzLFxuICAgIG1lcmdlZExheWVyLFxuICAgIHN0YXRlLmxheWVyT3JkZXIsXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgIHByZXNlcnZlTGF5ZXJPcmRlclxuICApO1xuXG4gIHJldHVybiB7XG4gICAgLi4uc3RhdGUsXG4gICAgbGF5ZXJzOiBuZXdMYXllcnMsXG4gICAgbGF5ZXJPcmRlcjogbmV3TGF5ZXJPcmRlcixcbiAgICBwcmVzZXJ2ZUxheWVyT3JkZXIsXG4gICAgbGF5ZXJUb0JlTWVyZ2VkOiBbLi4uc3RhdGUubGF5ZXJUb0JlTWVyZ2VkLCAuLi51bm1lcmdlZF1cbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGluc2VydExheWVyQXRSaWdodE9yZGVyKFxuICBjdXJyZW50TGF5ZXJzLFxuICBsYXllcnNUb0luc2VydCxcbiAgY3VycmVudE9yZGVyLFxuICBwcmVzZXJ2ZWRPcmRlcjogc3RyaW5nW10gPSBbXVxuKSB7XG4gIC8vIHBlcnNlcnZlZE9yZGVyIFsnYScsICdiJywgJ2MnXTtcbiAgLy8gbGF5ZXJPcmRlciBbMSwgMCwgM11cbiAgLy8gbGF5ZXJPcmRlck1hcCBbJ2EnLCAnYyddXG4gIGxldCBsYXllck9yZGVyUXVldWUgPSBjdXJyZW50T3JkZXIubWFwKGkgPT4gY3VycmVudExheWVyc1tpXS5pZCk7XG4gIGxldCBuZXdMYXllcnMgPSBjdXJyZW50TGF5ZXJzO1xuXG4gIGZvciAoY29uc3QgbmV3TGF5ZXIgb2YgbGF5ZXJzVG9JbnNlcnQpIHtcbiAgICAvLyBmaW5kIHdoZXJlIHRvIGluc2VydCBpdFxuICAgIGNvbnN0IGV4cGVjdGVkSWR4ID0gcHJlc2VydmVkT3JkZXIuaW5kZXhPZihuZXdMYXllci5pZCk7XG4gICAgLy8gaWYgY2FudCBmaW5kIHBsYWNlIHRvIGluc2VydCwgaW5zZXJ0IGF0IHRoZSBmcm9udFxuICAgIGxldCBpbnNlcnRBdCA9IDA7XG5cbiAgICBpZiAoZXhwZWN0ZWRJZHggPiAwKSB7XG4gICAgICAvLyBsb29rIGZvciBsYXllciB0byBpbnNlcnQgYWZ0ZXJcbiAgICAgIGxldCBpID0gZXhwZWN0ZWRJZHggKyAxO1xuICAgICAgbGV0IHByZWNlZWRJZHggPSAtMTtcbiAgICAgIHdoaWxlIChpLS0gPiAwICYmIHByZWNlZWRJZHggPCAwKSB7XG4gICAgICAgIC8vIGtlZXAgbG9va2luZyBmb3IgcHJlY2VlZCBsYXllciB0aGF0IGlzIGFscmVhZHkgbG9hZGVkXG4gICAgICAgIGNvbnN0IHByZWNlZWRMYXllciA9IHByZXNlcnZlZE9yZGVyW2kgLSAxXTtcbiAgICAgICAgcHJlY2VlZElkeCA9IGxheWVyT3JkZXJRdWV1ZS5pbmRleE9mKHByZWNlZWRMYXllcik7XG4gICAgICB9XG4gICAgICBpZiAocHJlY2VlZElkeCA+IC0xKSB7XG4gICAgICAgIC8vIGlmIGZvdW5kXG4gICAgICAgIGluc2VydEF0ID0gcHJlY2VlZElkeCArIDE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGF5ZXJPcmRlclF1ZXVlID0gYXJyYXlJbnNlcnQobGF5ZXJPcmRlclF1ZXVlLCBpbnNlcnRBdCwgbmV3TGF5ZXIuaWQpO1xuICAgIG5ld0xheWVycyA9IG5ld0xheWVycy5jb25jYXQobmV3TGF5ZXIpO1xuICB9XG5cbiAgLy8gcmVjb25zdHJ1Y3QgbGF5ZXJPcmRlciBhZnRlciBpbnNlcnRcbiAgY29uc3QgbmV3TGF5ZXJPcmRlciA9IGxheWVyT3JkZXJRdWV1ZS5tYXAoaWQgPT4gbmV3TGF5ZXJzLmZpbmRJbmRleChsID0+IGwuaWQgPT09IGlkKSk7XG5cbiAgcmV0dXJuIHtcbiAgICBuZXdMYXllck9yZGVyLFxuICAgIG5ld0xheWVyc1xuICB9O1xufVxuXG4vKipcbiAqIE1lcmdlIGludGVyYWN0aW9ucyB3aXRoIHNhdmVkIGNvbmZpZ1xuICpcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlSW50ZXJhY3Rpb25zPFMgZXh0ZW5kcyBWaXNTdGF0ZT4oXG4gIHN0YXRlOiBTLFxuICBpbnRlcmFjdGlvblRvQmVNZXJnZWQ6IFBhcnRpYWw8U2F2ZWRJbnRlcmFjdGlvbkNvbmZpZz4gfCB1bmRlZmluZWQsXG4gIGZyb21Db25maWc/OiBib29sZWFuXG4pOiBTIHtcbiAgY29uc3QgbWVyZ2VkOiBQYXJ0aWFsPFNhdmVkSW50ZXJhY3Rpb25Db25maWc+ID0ge307XG4gIGNvbnN0IHVubWVyZ2VkOiBQYXJ0aWFsPFNhdmVkSW50ZXJhY3Rpb25Db25maWc+ID0ge307XG5cbiAgaWYgKGludGVyYWN0aW9uVG9CZU1lcmdlZCkge1xuICAgIChPYmplY3Qua2V5cyhpbnRlcmFjdGlvblRvQmVNZXJnZWQpIGFzIEFycmF5PGtleW9mIFNhdmVkSW50ZXJhY3Rpb25Db25maWc+KS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICBpZiAoIXN0YXRlLmludGVyYWN0aW9uQ29uZmlnW2tleV0pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBjdXJyZW50Q29uZmlnID1cbiAgICAgICAga2V5ID09PSAndG9vbHRpcCcgfHwga2V5ID09PSAnYnJ1c2gnID8gc3RhdGUuaW50ZXJhY3Rpb25Db25maWdba2V5XS5jb25maWcgOiBudWxsO1xuXG4gICAgICBjb25zdCB7ZW5hYmxlZCwgLi4uY29uZmlnU2F2ZWR9ID0gaW50ZXJhY3Rpb25Ub0JlTWVyZ2VkW2tleV0gfHwge307XG5cbiAgICAgIGxldCBjb25maWdUb01lcmdlID0gY29uZmlnU2F2ZWQ7XG5cbiAgICAgIGlmIChrZXkgPT09ICd0b29sdGlwJykge1xuICAgICAgICBjb25zdCB7bWVyZ2VkVG9vbHRpcCwgdW5tZXJnZWRUb29sdGlwfSA9IG1lcmdlSW50ZXJhY3Rpb25Ub29sdGlwQ29uZmlnKFxuICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgIGNvbmZpZ1NhdmVkIGFzIFNhdmVkSW50ZXJhY3Rpb25Db25maWdbJ3Rvb2x0aXAnXVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIG1lcmdlIG5ldyBkYXRhc2V0IHRvb2x0aXBzIHdpdGggb3JpZ2luYWwgZGF0YXNldCB0b29sdGlwc1xuICAgICAgICBjb25maWdUb01lcmdlID0ge1xuICAgICAgICAgIGZpZWxkc1RvU2hvdzoge1xuICAgICAgICAgICAgLi4uKGN1cnJlbnRDb25maWcgYXMgVG9vbHRpcEluZm9bJ2NvbmZpZyddKS5maWVsZHNUb1Nob3csXG4gICAgICAgICAgICAuLi5tZXJnZWRUb29sdGlwXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChPYmplY3Qua2V5cyh1bm1lcmdlZFRvb2x0aXApLmxlbmd0aCkge1xuICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICB1bm1lcmdlZC50b29sdGlwID0ge2ZpZWxkc1RvU2hvdzogdW5tZXJnZWRUb29sdGlwLCBlbmFibGVkOiBCb29sZWFuKGVuYWJsZWQpfTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBtZXJnZWRba2V5XSA9IHtcbiAgICAgICAgLi4uc3RhdGUuaW50ZXJhY3Rpb25Db25maWdba2V5XSxcbiAgICAgICAgZW5hYmxlZDogQm9vbGVhbihlbmFibGVkKSxcbiAgICAgICAgLi4uKGN1cnJlbnRDb25maWdcbiAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgY29uZmlnOiBwaWNrKFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIC4uLmN1cnJlbnRDb25maWcsXG4gICAgICAgICAgICAgICAgICAuLi5jb25maWdUb01lcmdlXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhjdXJyZW50Q29uZmlnKVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9XG4gICAgICAgICAgOiB7fSlcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIC4uLnN0YXRlLFxuICAgIGludGVyYWN0aW9uQ29uZmlnOiB7XG4gICAgICAuLi5zdGF0ZS5pbnRlcmFjdGlvbkNvbmZpZyxcbiAgICAgIC4uLm1lcmdlZFxuICAgIH0sXG4gICAgaW50ZXJhY3Rpb25Ub0JlTWVyZ2VkOiB1bm1lcmdlZFxuICB9O1xufVxuXG4vKipcbiAqIE1lcmdlIHNwbGl0TWFwcyBjb25maWcgd2l0aCBjdXJyZW50IHZpc1N0ZXRlLlxuICogMS4gaWYgY3VycmVudCBtYXAgaXMgc3BsaXQsIGJ1dCBzcGxpdE1hcCBET0VTTk9UIGNvbnRhaW4gbWFwc1xuICogICAgOiBkb24ndCBtZXJnZSBhbnl0aGluZ1xuICogMi4gaWYgY3VycmVudCBtYXAgaXMgTk9UIHNwbGl0LCBidXQgc3BsaXRNYXBzIGNvbnRhaW4gbWFwc1xuICogICAgOiBhZGQgdG8gc3BsaXRNYXBzLCBhbmQgYWRkIGN1cnJlbnQgbGF5ZXJzIHRvIHNwbGl0TWFwc1xuICovXG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VTcGxpdE1hcHM8UyBleHRlbmRzIFZpc1N0YXRlPihcbiAgc3RhdGU6IFMsXG4gIHNwbGl0TWFwczogTm9uTnVsbGFibGU8UGFyc2VkQ29uZmlnWyd2aXNTdGF0ZSddPlsnc3BsaXRNYXBzJ10gPSBbXSxcbiAgZnJvbUNvbmZpZz86IGJvb2xlYW5cbik6IFMge1xuICBjb25zdCBtZXJnZWQgPSBbLi4uc3RhdGUuc3BsaXRNYXBzXTtcbiAgY29uc3QgdW5tZXJnZWQgPSBbXTtcbiAgc3BsaXRNYXBzLmZvckVhY2goKHNtLCBpKSA9PiB7XG4gICAgT2JqZWN0LmVudHJpZXMoc20ubGF5ZXJzKS5mb3JFYWNoKChbaWQsIHZhbHVlXSkgPT4ge1xuICAgICAgLy8gY2hlY2sgaWYgbGF5ZXIgZXhpc3RzXG4gICAgICBjb25zdCBwdXNoVG8gPSBzdGF0ZS5sYXllcnMuZmluZChsID0+IGwuaWQgPT09IGlkKSA/IG1lcmdlZCA6IHVubWVyZ2VkO1xuXG4gICAgICAvLyBjcmVhdGUgbWFwIHBhbmVsIGlmIGN1cnJlbnQgbWFwIGlzIG5vdCBzcGxpdFxuICAgICAgcHVzaFRvW2ldID0gcHVzaFRvW2ldIHx8IHtcbiAgICAgICAgbGF5ZXJzOiBwdXNoVG8gPT09IG1lcmdlZCA/IGdldEluaXRpYWxNYXBMYXllcnNGb3JTcGxpdE1hcChzdGF0ZS5sYXllcnMpIDogW11cbiAgICAgIH07XG4gICAgICBwdXNoVG9baV0ubGF5ZXJzID0ge1xuICAgICAgICAuLi5wdXNoVG9baV0ubGF5ZXJzLFxuICAgICAgICBbaWRdOiB2YWx1ZVxuICAgICAgfTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgcmV0dXJuIHtcbiAgICAuLi5zdGF0ZSxcbiAgICBzcGxpdE1hcHM6IG1lcmdlZCxcbiAgICBzcGxpdE1hcHNUb0JlTWVyZ2VkOiBbLi4uc3RhdGUuc3BsaXRNYXBzVG9CZU1lcmdlZCwgLi4udW5tZXJnZWRdXG4gIH07XG59XG5cbi8qKlxuICogTWVyZ2UgaW50ZXJhY3Rpb25Db25maWcudG9vbHRpcCB3aXRoIHNhdmVkIGNvbmZpZyxcbiAqIHZhbGlkYXRlIGZpZWxkc1RvU2hvd1xuICpcbiAqIEBwYXJhbSBzdGF0ZVxuICogQHBhcmFtIHRvb2x0aXBDb25maWdcbiAqIEByZXR1cm4gLSB7bWVyZ2VkVG9vbHRpcDoge30sIHVubWVyZ2VkVG9vbHRpcDoge319XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtZXJnZUludGVyYWN0aW9uVG9vbHRpcENvbmZpZyhcbiAgc3RhdGU6IFZpc1N0YXRlLFxuICB0b29sdGlwQ29uZmlnOiBQaWNrPFRvb2x0aXBJbmZvWydjb25maWcnXSwgJ2ZpZWxkc1RvU2hvdyc+IHwgbnVsbCA9IG51bGxcbikge1xuICBjb25zdCB1bm1lcmdlZFRvb2x0aXA6IFRvb2x0aXBJbmZvWydjb25maWcnXVsnZmllbGRzVG9TaG93J10gPSB7fTtcbiAgY29uc3QgbWVyZ2VkVG9vbHRpcDogVG9vbHRpcEluZm9bJ2NvbmZpZyddWydmaWVsZHNUb1Nob3cnXSA9IHt9O1xuXG4gIGlmIChcbiAgICAhdG9vbHRpcENvbmZpZyB8fFxuICAgICF0b29sdGlwQ29uZmlnLmZpZWxkc1RvU2hvdyB8fFxuICAgICFPYmplY3Qua2V5cyh0b29sdGlwQ29uZmlnLmZpZWxkc1RvU2hvdykubGVuZ3RoXG4gICkge1xuICAgIHJldHVybiB7bWVyZ2VkVG9vbHRpcCwgdW5tZXJnZWRUb29sdGlwfTtcbiAgfVxuXG4gIGZvciAoY29uc3QgZGF0YUlkIGluIHRvb2x0aXBDb25maWcuZmllbGRzVG9TaG93KSB7XG4gICAgaWYgKCFzdGF0ZS5kYXRhc2V0c1tkYXRhSWRdKSB7XG4gICAgICAvLyBpcyBub3QgeWV0IGxvYWRlZFxuICAgICAgdW5tZXJnZWRUb29sdGlwW2RhdGFJZF0gPSB0b29sdGlwQ29uZmlnLmZpZWxkc1RvU2hvd1tkYXRhSWRdO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpZiBkYXRhc2V0IGlzIGxvYWRlZFxuICAgICAgY29uc3QgYWxsRmllbGRzID0gc3RhdGUuZGF0YXNldHNbZGF0YUlkXS5maWVsZHMubWFwKGQgPT4gZC5uYW1lKTtcbiAgICAgIGNvbnN0IGZvdW5kRmllbGRzVG9TaG93ID0gdG9vbHRpcENvbmZpZy5maWVsZHNUb1Nob3dbZGF0YUlkXS5maWx0ZXIoZmllbGQgPT5cbiAgICAgICAgYWxsRmllbGRzLmluY2x1ZGVzKGZpZWxkLm5hbWUpXG4gICAgICApO1xuXG4gICAgICBtZXJnZWRUb29sdGlwW2RhdGFJZF0gPSBmb3VuZEZpZWxkc1RvU2hvdztcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge21lcmdlZFRvb2x0aXAsIHVubWVyZ2VkVG9vbHRpcH07XG59XG4vKipcbiAqIE1lcmdlIGxheWVyQmxlbmRpbmcgd2l0aCBzYXZlZFxuICpcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlTGF5ZXJCbGVuZGluZzxTIGV4dGVuZHMgVmlzU3RhdGU+KFxuICBzdGF0ZTogUyxcbiAgbGF5ZXJCbGVuZGluZzogTm9uTnVsbGFibGU8UGFyc2VkQ29uZmlnWyd2aXNTdGF0ZSddPlsnbGF5ZXJCbGVuZGluZyddLFxuICBmcm9tQ29uZmlnPzogYm9vbGVhblxuKTogUyB7XG4gIGlmIChsYXllckJsZW5kaW5nICYmIExBWUVSX0JMRU5ESU5HU1tsYXllckJsZW5kaW5nXSkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5zdGF0ZSxcbiAgICAgIGxheWVyQmxlbmRpbmdcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHN0YXRlO1xufVxuXG4vKipcbiAqIE1lcmdlIGFuaW1hdGlvbiBjb25maWdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlQW5pbWF0aW9uQ29uZmlnPFMgZXh0ZW5kcyBWaXNTdGF0ZT4oXG4gIHN0YXRlOiBTLFxuICBhbmltYXRpb246IE5vbk51bGxhYmxlPFBhcnNlZENvbmZpZ1sndmlzU3RhdGUnXT5bJ2FuaW1hdGlvbkNvbmZpZyddLFxuICBmcm9tQ29uZmlnPzogYm9vbGVhblxuKTogUyB7XG4gIGlmIChhbmltYXRpb24gJiYgYW5pbWF0aW9uLmN1cnJlbnRUaW1lKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnN0YXRlLFxuICAgICAgYW5pbWF0aW9uQ29uZmlnOiB7XG4gICAgICAgIC4uLnN0YXRlLmFuaW1hdGlvbkNvbmZpZyxcbiAgICAgICAgLi4uYW5pbWF0aW9uLFxuICAgICAgICBkb21haW46IG51bGxcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHN0YXRlO1xufVxuXG4vKipcbiAqIFZhbGlkYXRlIHNhdmVkIGxheWVyIGNvbHVtbnMgd2l0aCBuZXcgZGF0YSxcbiAqIHVwZGF0ZSBmaWVsZElkeCBiYXNlZCBvbiBuZXcgZmllbGRzXG4gKlxuICogQHBhcmFtIGZpZWxkc1xuICogQHBhcmFtIHNhdmVkQ29sc1xuICogQHBhcmFtIGVtcHR5Q29sc1xuICogQHJldHVybiAtIHZhbGlkYXRlZCBjb2x1bW5zIG9yIG51bGxcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVTYXZlZExheWVyQ29sdW1ucyhcbiAgZmllbGRzOiBLZXBsZXJUYWJsZVsnZmllbGRzJ10sXG4gIHNhdmVkQ29sczoge1xuICAgIFtrZXk6IHN0cmluZ106IHN0cmluZztcbiAgfSA9IHt9LFxuICBlbXB0eUNvbHM6IExheWVyQ29sdW1uc1xuKSB7XG4gIC8vIFByZXBhcmUgY29sdW1ucyBmb3IgdGhlIHZhbGlkYXRvclxuICBjb25zdCBjb2x1bW5zOiB0eXBlb2YgZW1wdHlDb2xzID0ge307XG4gIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKGVtcHR5Q29scykpIHtcbiAgICBjb2x1bW5zW2tleV0gPSB7Li4uZW1wdHlDb2xzW2tleV19O1xuXG4gICAgY29uc3Qgc2F2ZWQgPSBzYXZlZENvbHNba2V5XTtcbiAgICBpZiAoc2F2ZWQpIHtcbiAgICAgIGNvbnN0IGZpZWxkSWR4ID0gZmllbGRzLmZpbmRJbmRleCgoe25hbWV9KSA9PiBuYW1lID09PSBzYXZlZCk7XG5cbiAgICAgIGlmIChmaWVsZElkeCA+IC0xKSB7XG4gICAgICAgIC8vIHVwZGF0ZSBmb3VuZCBjb2x1bW5zXG4gICAgICAgIGNvbHVtbnNba2V5XS5maWVsZElkeCA9IGZpZWxkSWR4O1xuICAgICAgICBjb2x1bW5zW2tleV0udmFsdWUgPSBzYXZlZDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBmaW5kIGFjdHVhbCBjb2x1bW4gZmllbGRJZHgsIGluIGNhc2UgaXQgaGFzIGNoYW5nZWRcbiAgY29uc3QgYWxsQ29sRm91bmQgPSBPYmplY3Qua2V5cyhjb2x1bW5zKS5ldmVyeShrZXkgPT5cbiAgICB2YWxpZGF0ZUNvbHVtbihjb2x1bW5zW2tleV0sIGNvbHVtbnMsIGZpZWxkcylcbiAgKTtcblxuICBpZiAoYWxsQ29sRm91bmQpIHtcbiAgICByZXR1cm4gY29sdW1ucztcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVDb2x1bW4oXG4gIGNvbHVtbjogTGF5ZXJDb2x1bW4gJiB7dmFsaWRhdG9yPzogdHlwZW9mIHZhbGlkYXRlQ29sdW1ufSxcbiAgY29sdW1uczogTGF5ZXJDb2x1bW5zLFxuICBhbGxGaWVsZHM6IEtlcGxlclRhYmxlWydmaWVsZHMnXVxuKTogYm9vbGVhbiB7XG4gIGlmIChjb2x1bW4ub3B0aW9uYWwgfHwgY29sdW1uLnZhbHVlKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGNvbHVtbi52YWxpZGF0b3IpIHtcbiAgICByZXR1cm4gY29sdW1uLnZhbGlkYXRvcihjb2x1bW4sIGNvbHVtbnMsIGFsbEZpZWxkcyk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIFZhbGlkYXRlIHNhdmVkIHRleHQgbGFiZWwgY29uZmlnIHdpdGggbmV3IGRhdGFcbiAqIHJlZmVyIHRvIHZpcy1zdGF0ZS1zY2hlbWEuanMgVGV4dExhYmVsU2NoZW1hVjFcbiAqXG4gKiBAcGFyYW0ge0FycmF5PE9iamVjdD59IGZpZWxkc1xuICogQHBhcmFtIHtPYmplY3R9IHNhdmVkVGV4dExhYmVsXG4gKiBAcmV0dXJuIHtPYmplY3R9IC0gdmFsaWRhdGVkIHRleHRsYWJlbFxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVTYXZlZFRleHRMYWJlbChmaWVsZHMsIFtsYXllclRleHRMYWJlbF0sIHNhdmVkVGV4dExhYmVsKSB7XG4gIGNvbnN0IHNhdmVkVGV4dExhYmVscyA9IEFycmF5LmlzQXJyYXkoc2F2ZWRUZXh0TGFiZWwpID8gc2F2ZWRUZXh0TGFiZWwgOiBbc2F2ZWRUZXh0TGFiZWxdO1xuXG4gIC8vIHZhbGlkYXRlIGZpZWxkXG4gIHJldHVybiBzYXZlZFRleHRMYWJlbHMubWFwKHRleHRMYWJlbCA9PiB7XG4gICAgY29uc3QgZmllbGQgPSB0ZXh0TGFiZWwuZmllbGRcbiAgICAgID8gZmllbGRzLmZpbmQoZmQgPT5cbiAgICAgICAgICBPYmplY3Qua2V5cyh0ZXh0TGFiZWwuZmllbGQpLmV2ZXJ5KGtleSA9PiB0ZXh0TGFiZWwuZmllbGRba2V5XSA9PT0gZmRba2V5XSlcbiAgICAgICAgKVxuICAgICAgOiBudWxsO1xuXG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKGxheWVyVGV4dExhYmVsKS5yZWR1Y2UoXG4gICAgICAoYWNjdSwga2V5KSA9PiAoe1xuICAgICAgICAuLi5hY2N1LFxuICAgICAgICBba2V5XToga2V5ID09PSAnZmllbGQnID8gZmllbGQgOiB0ZXh0TGFiZWxba2V5XSB8fCBsYXllclRleHRMYWJlbFtrZXldXG4gICAgICB9KSxcbiAgICAgIHt9XG4gICAgKTtcbiAgfSk7XG59XG5cbi8qKlxuICogVmFsaWRhdGUgc2F2ZWQgdmlzdWFsIGNoYW5uZWxzIGNvbmZpZyB3aXRoIG5ldyBkYXRhLFxuICogcmVmZXIgdG8gdmlzLXN0YXRlLXNjaGVtYS5qcyBWaXN1YWxDaGFubmVsU2NoZW1hVjFcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlU2F2ZWRWaXN1YWxDaGFubmVscyhcbiAgZmllbGRzOiBLZXBsZXJUYWJsZVsnZmllbGRzJ10sXG4gIG5ld0xheWVyOiBMYXllcixcbiAgc2F2ZWRMYXllcjogUGFyc2VkTGF5ZXJcbik6IG51bGwgfCBMYXllciB7XG4gIE9iamVjdC52YWx1ZXMobmV3TGF5ZXIudmlzdWFsQ2hhbm5lbHMpLmZvckVhY2goKHtmaWVsZCwgc2NhbGUsIGtleX0pID0+IHtcbiAgICBsZXQgZm91bmRGaWVsZDtcbiAgICBpZiAoc2F2ZWRMYXllci5jb25maWcpIHtcbiAgICAgIGlmIChzYXZlZExheWVyLmNvbmZpZ1tmaWVsZF0pIHtcbiAgICAgICAgZm91bmRGaWVsZCA9IGZpZWxkcy5maW5kKFxuICAgICAgICAgIGZkID0+IHNhdmVkTGF5ZXIuY29uZmlnICYmIGZkLm5hbWUgPT09IHNhdmVkTGF5ZXIuY29uZmlnW2ZpZWxkXS5uYW1lXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGZvdW5kQ2hhbm5lbCA9IHtcbiAgICAgICAgLi4uKGZvdW5kRmllbGQgPyB7W2ZpZWxkXTogZm91bmRGaWVsZH0gOiB7fSksXG4gICAgICAgIC4uLihzYXZlZExheWVyLmNvbmZpZ1tzY2FsZV0gPyB7W3NjYWxlXTogc2F2ZWRMYXllci5jb25maWdbc2NhbGVdfSA6IHt9KVxuICAgICAgfTtcbiAgICAgIGlmIChPYmplY3Qua2V5cyhmb3VuZENoYW5uZWwpLmxlbmd0aCkge1xuICAgICAgICBuZXdMYXllci51cGRhdGVMYXllckNvbmZpZyhmb3VuZENoYW5uZWwpO1xuICAgICAgfVxuXG4gICAgICBuZXdMYXllci52YWxpZGF0ZVZpc3VhbENoYW5uZWwoa2V5KTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gbmV3TGF5ZXI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUxheWVyc0J5RGF0YXNldHMoXG4gIGRhdGFzZXRzOiBEYXRhc2V0cyxcbiAgbGF5ZXJDbGFzc2VzOiBWaXNTdGF0ZVsnbGF5ZXJDbGFzc2VzJ10sXG4gIGxheWVyczogTm9uTnVsbGFibGU8UGFyc2VkQ29uZmlnWyd2aXNTdGF0ZSddPlsnbGF5ZXJzJ10gPSBbXVxuKSB7XG4gIGNvbnN0IHZhbGlkYXRlZDogTGF5ZXJbXSA9IFtdO1xuICBjb25zdCBmYWlsZWQ6IE5vbk51bGxhYmxlPFBhcnNlZENvbmZpZ1sndmlzU3RhdGUnXT5bJ2xheWVycyddID0gW107XG5cbiAgbGF5ZXJzLmZvckVhY2gobGF5ZXIgPT4ge1xuICAgIGxldCB2YWxpZGF0ZUxheWVyOiBMYXllciB8IG51bGwgPSBudWxsO1xuXG4gICAgaWYgKGxheWVyPy5jb25maWc/LmRhdGFJZCkge1xuICAgICAgaWYgKGRhdGFzZXRzW2xheWVyLmNvbmZpZy5kYXRhSWRdKSB7XG4gICAgICAgIC8vIGRhdGFzZXRzIGFyZSBhbHJlYWR5IGxvYWRlZFxuICAgICAgICB2YWxpZGF0ZUxheWVyID0gdmFsaWRhdGVMYXllcldpdGhEYXRhKGRhdGFzZXRzW2xheWVyLmNvbmZpZy5kYXRhSWRdLCBsYXllciwgbGF5ZXJDbGFzc2VzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodmFsaWRhdGVMYXllcikge1xuICAgICAgdmFsaWRhdGVkLnB1c2godmFsaWRhdGVMYXllcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGRhdGFzZXRzIG5vdCB5ZXQgbG9hZGVkXG4gICAgICBmYWlsZWQucHVzaChsYXllcik7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4ge3ZhbGlkYXRlZCwgZmFpbGVkfTtcbn1cbi8qKlxuICogVmFsaWRhdGUgc2F2ZWQgbGF5ZXIgY29uZmlnIHdpdGggbmV3IGRhdGEsXG4gKiB1cGRhdGUgZmllbGRJZHggYmFzZWQgb24gbmV3IGZpZWxkc1xuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVMYXllcldpdGhEYXRhKFxuICB7ZmllbGRzLCBpZDogZGF0YUlkfTogS2VwbGVyVGFibGUsXG4gIHNhdmVkTGF5ZXI6IFBhcnNlZExheWVyLFxuICBsYXllckNsYXNzZXM6IFZpc1N0YXRlWydsYXllckNsYXNzZXMnXSxcbiAgb3B0aW9uczoge1xuICAgIGFsbG93RW1wdHlDb2x1bW4/OiBib29sZWFuO1xuICB9ID0ge31cbik6IExheWVyIHwgbnVsbCB7XG4gIGNvbnN0IHt0eXBlfSA9IHNhdmVkTGF5ZXI7XG4gIC8vIGxheWVyIGRvZXNudCBoYXZlIGEgdmFsaWQgdHlwZVxuICBpZiAoIXR5cGUgfHwgIWxheWVyQ2xhc3Nlcy5oYXNPd25Qcm9wZXJ0eSh0eXBlKSB8fCAhc2F2ZWRMYXllci5jb25maWcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGxldCBuZXdMYXllciA9IG5ldyBsYXllckNsYXNzZXNbdHlwZV0oe1xuICAgIGlkOiBzYXZlZExheWVyLmlkLFxuICAgIGRhdGFJZCxcbiAgICBsYWJlbDogc2F2ZWRMYXllci5jb25maWcubGFiZWwsXG4gICAgY29sb3I6IHNhdmVkTGF5ZXIuY29uZmlnLmNvbG9yLFxuICAgIGlzVmlzaWJsZTogc2F2ZWRMYXllci5jb25maWcuaXNWaXNpYmxlLFxuICAgIGhpZGRlbjogc2F2ZWRMYXllci5jb25maWcuaGlkZGVuLFxuICAgIGhpZ2hsaWdodENvbG9yOiBzYXZlZExheWVyLmNvbmZpZy5oaWdobGlnaHRDb2xvclxuICB9KTtcblxuICAvLyBmaW5kIGNvbHVtbiBmaWVsZElkeFxuICBjb25zdCBjb2x1bW5Db25maWcgPSBuZXdMYXllci5nZXRMYXllckNvbHVtbnMoKTtcbiAgaWYgKE9iamVjdC5rZXlzKGNvbHVtbkNvbmZpZykubGVuZ3RoKSB7XG4gICAgY29uc3QgY29sdW1ucyA9IHZhbGlkYXRlU2F2ZWRMYXllckNvbHVtbnMoZmllbGRzLCBzYXZlZExheWVyLmNvbmZpZy5jb2x1bW5zLCBjb2x1bW5Db25maWcpO1xuICAgIGlmIChjb2x1bW5zKSB7XG4gICAgICBuZXdMYXllci51cGRhdGVMYXllckNvbmZpZyh7Y29sdW1uc30pO1xuICAgIH0gZWxzZSBpZiAoIW9wdGlvbnMuYWxsb3dFbXB0eUNvbHVtbikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgLy8gdmlzdWFsIGNoYW5uZWwgZmllbGQgaXMgc2F2ZWQgdG8gYmUge25hbWUsIHR5cGV9XG4gIC8vIGZpbmQgdmlzdWFsIGNoYW5uZWwgZmllbGQgYnkgbWF0Y2hpbmcgYm90aCBuYW1lIGFuZCB0eXBlXG4gIC8vIHJlZmVyIHRvIHZpcy1zdGF0ZS1zY2hlbWEuanMgVmlzdWFsQ2hhbm5lbFNjaGVtYVYxXG4gIG5ld0xheWVyID0gdmFsaWRhdGVTYXZlZFZpc3VhbENoYW5uZWxzKGZpZWxkcywgbmV3TGF5ZXIsIHNhdmVkTGF5ZXIpO1xuXG4gIGNvbnN0IHRleHRMYWJlbCA9XG4gICAgc2F2ZWRMYXllci5jb25maWcudGV4dExhYmVsICYmIG5ld0xheWVyLmNvbmZpZy50ZXh0TGFiZWxcbiAgICAgID8gdmFsaWRhdGVTYXZlZFRleHRMYWJlbChmaWVsZHMsIG5ld0xheWVyLmNvbmZpZy50ZXh0TGFiZWwsIHNhdmVkTGF5ZXIuY29uZmlnLnRleHRMYWJlbClcbiAgICAgIDogbmV3TGF5ZXIuY29uZmlnLnRleHRMYWJlbDtcblxuICAvLyBjb3B5IHZpc0NvbmZpZyBvdmVyIHRvIGVtcHR5TGF5ZXIgdG8gbWFrZSBzdXJlIGl0IGhhcyBhbGwgdGhlIHByb3BzXG4gIGNvbnN0IHZpc0NvbmZpZyA9IG5ld0xheWVyLmNvcHlMYXllckNvbmZpZyhcbiAgICBuZXdMYXllci5jb25maWcudmlzQ29uZmlnLFxuICAgIHNhdmVkTGF5ZXIuY29uZmlnLnZpc0NvbmZpZyB8fCB7fSxcbiAgICB7c2hhbGxvd0NvcHk6IFsnY29sb3JSYW5nZScsICdzdHJva2VDb2xvclJhbmdlJ119XG4gICk7XG5cbiAgbmV3TGF5ZXIudXBkYXRlTGF5ZXJDb25maWcoe1xuICAgIHZpc0NvbmZpZyxcbiAgICB0ZXh0TGFiZWxcbiAgfSk7XG5cbiAgcmV0dXJuIG5ld0xheWVyO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNWYWxpZE1lcmdlcihtZXJnZXI6IE1lcmdlcik6IGJvb2xlYW4ge1xuICByZXR1cm4gaXNPYmplY3QobWVyZ2VyKSAmJiB0eXBlb2YgbWVyZ2VyLm1lcmdlID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBtZXJnZXIucHJvcCA9PT0gJ3N0cmluZyc7XG59XG5cbmV4cG9ydCBjb25zdCBWSVNfU1RBVEVfTUVSR0VSUzogVmlzU3RhdGVNZXJnZXJzID0gW1xuICB7bWVyZ2U6IG1lcmdlTGF5ZXJzLCBwcm9wOiAnbGF5ZXJzJywgdG9NZXJnZVByb3A6ICdsYXllclRvQmVNZXJnZWQnfSxcbiAge21lcmdlOiBtZXJnZUZpbHRlcnMsIHByb3A6ICdmaWx0ZXJzJywgdG9NZXJnZVByb3A6ICdmaWx0ZXJUb0JlTWVyZ2VkJ30sXG4gIHttZXJnZTogbWVyZ2VJbnRlcmFjdGlvbnMsIHByb3A6ICdpbnRlcmFjdGlvbkNvbmZpZycsIHRvTWVyZ2VQcm9wOiAnaW50ZXJhY3Rpb25Ub0JlTWVyZ2VkJ30sXG4gIHttZXJnZTogbWVyZ2VMYXllckJsZW5kaW5nLCBwcm9wOiAnbGF5ZXJCbGVuZGluZyd9LFxuICB7bWVyZ2U6IG1lcmdlU3BsaXRNYXBzLCBwcm9wOiAnc3BsaXRNYXBzJywgdG9NZXJnZVByb3A6ICdzcGxpdE1hcHNUb0JlTWVyZ2VkJ30sXG4gIHttZXJnZTogbWVyZ2VBbmltYXRpb25Db25maWcsIHByb3A6ICdhbmltYXRpb25Db25maWcnfVxuXTtcbiJdfQ==