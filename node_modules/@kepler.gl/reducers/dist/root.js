// Copyright (c) 2022 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.provideInitialState = provideInitialState;
exports["default"] = void 0;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _actions = require("@kepler.gl/actions");

var _reduxActions = require("redux-actions");

var _core = require("./core");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

// INITIAL_STATE
var initialCoreState = {};

function provideInitialState(initialState) {
  var coreReducer = (0, _core.coreReducerFactory)(initialState);

  var handleRegisterEntry = function handleRegisterEntry(state, _ref) {
    var _ref$payload = _ref.payload,
        id = _ref$payload.id,
        mint = _ref$payload.mint,
        mapboxApiAccessToken = _ref$payload.mapboxApiAccessToken,
        mapboxApiUrl = _ref$payload.mapboxApiUrl,
        mapStylesReplaceDefault = _ref$payload.mapStylesReplaceDefault,
        initialUiState = _ref$payload.initialUiState;
    // by default, always create a mint state even if the same id already exist
    // if state.id exist and mint=false, keep the existing state
    var previousState = state[id] && mint === false ? state[id] : undefined;
    return _objectSpread(_objectSpread({}, state), {}, (0, _defineProperty2["default"])({}, id, coreReducer(previousState, (0, _actions.keplerGlInit)({
      mapboxApiAccessToken: mapboxApiAccessToken,
      mapboxApiUrl: mapboxApiUrl,
      mapStylesReplaceDefault: mapStylesReplaceDefault,
      initialUiState: initialUiState
    }))));
  };

  var handleDeleteEntry = function handleDeleteEntry(state, _ref2) {
    var id = _ref2.payload;
    return Object.keys(state).reduce(function (accu, curr) {
      return _objectSpread(_objectSpread({}, accu), curr === id ? {} : (0, _defineProperty2["default"])({}, curr, state[curr]));
    }, {});
  };

  var handleRenameEntry = function handleRenameEntry(state, _ref4) {
    var _ref4$payload = _ref4.payload,
        oldId = _ref4$payload.oldId,
        newId = _ref4$payload.newId;
    return Object.keys(state).reduce(function (accu, curr) {
      return _objectSpread(_objectSpread({}, accu), (0, _defineProperty2["default"])({}, curr === oldId ? newId : curr, state[curr]));
    }, {});
  };

  return function () {
    var _handlers;

    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialCoreState;
    var action = arguments.length > 1 ? arguments[1] : undefined;
    // update child states
    Object.keys(state).forEach(function (id) {
      var updateItemState = coreReducer(state[id], (0, _actions._actionFor)(id, action));
      state = (0, _actions._updateProperty)(state, id, updateItemState);
    }); // perform additional state reducing (e.g. switch action.type etc...)

    var handlers = (_handlers = {}, (0, _defineProperty2["default"])(_handlers, _actions.ActionTypes.REGISTER_ENTRY, handleRegisterEntry), (0, _defineProperty2["default"])(_handlers, _actions.ActionTypes.DELETE_ENTRY, handleDeleteEntry), (0, _defineProperty2["default"])(_handlers, _actions.ActionTypes.RENAME_ENTRY, handleRenameEntry), _handlers); // TODO: Understand why the Lint sees an error here, while the IDE does not.
    // @ts-expect-error

    return (0, _reduxActions.handleActions)(handlers, initialCoreState)(state, action);
  };
}

var _keplerGlReducer = provideInitialState(initialCoreState);

function mergeInitialState() {
  var saved = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var provided = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var keys = ['mapState', 'mapStyle', 'visState', 'uiState']; // shallow merge each reducer

  return keys.reduce(function (accu, key) {
    return _objectSpread(_objectSpread({}, accu), saved[key] && provided[key] ? (0, _defineProperty2["default"])({}, key, _objectSpread(_objectSpread({}, saved[key]), provided[key])) : (0, _defineProperty2["default"])({}, key, saved[key] || provided[key] || {}));
  }, {});
}

function decorate(target) {
  var savedInitialState = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var targetInitialState = savedInitialState;
  /**
   * Returns a kepler.gl reducer that will also pass each action through additional reducers spiecified.
   * The parameter should be either a reducer map or a reducer function.
   * The state passed into the additional action handler is the instance state.
   * It will include all the subreducers `visState`, `uiState`, `mapState` and `mapStyle`.
   * `.plugin` is only meant to be called once when mounting the keplerGlReducer to the store.
   * **Note** This is an advanced option to give you more freedom to modify the internal state of the kepler.gl instance.
   * You should only use this to adding additional actions instead of replacing default actions.
   *
   * @mixin keplerGlReducer.plugin
   * @memberof keplerGlReducer
   * @param {Object|Function} customReducer - A reducer map or a reducer
   * @public
   * @example
   * const myKeplerGlReducer = keplerGlReducer
   *  .plugin({
   *    // 1. as reducer map
   *    HIDE_AND_SHOW_SIDE_PANEL: (state, action) => ({
   *      ...state,
   *      uiState: {
   *        ...state.uiState,
   *        readOnly: !state.uiState.readOnly
   *      }
   *    })
   *  })
   * .plugin(handleActions({
   *   // 2. as reducer
   *   'HIDE_MAP_CONTROLS': (state, action) => ({
   *     ...state,
   *     uiState: {
   *       ...state.uiState,
   *       mapControls: hiddenMapControl
   *     }
   *   })
   * }, {}));
   */

  target.plugin = function plugin(customReducer) {
    var _this = this;

    if ((0, _typeof2["default"])(customReducer) === 'object') {
      // if only provided a reducerMap, wrap it in a reducer
      customReducer = (0, _reduxActions.handleActions)(customReducer, {});
    } // use 'function' keyword to enable 'this'


    return decorate(function () {
      var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var action = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var nextState = _this(state, action); // for each entry in the staten


      Object.keys(nextState).forEach(function (id) {
        // update child states
        nextState = (0, _actions._updateProperty)(nextState, id, customReducer(nextState[id], (0, _actions._actionFor)(id, action)));
      });
      return nextState;
    });
  };
  /**
   * Return a reducer that initiated with custom initial state.
   * The parameter should be an object mapping from `subreducer` name to custom subreducer state,
   * which will be shallow **merged** with default initial state.
   *
   * Default subreducer state:
   *  - [`visState`](./vis-state.md#INITIAL_VIS_STATE)
   *  - [`mapState`](./map-state.md#INITIAL_MAP_STATE)
   *  - [`mapStyle`](./map-style.md#INITIAL_MAP_STYLE)
   *  - [`uiState`](./ui-state.md#INITIAL_UI_STATE)
   * @mixin keplerGlReducer.initialState
   * @memberof keplerGlReducer
   * @param {Object} iniSt - custom state to be merged with default initial state
   * @public
   * @example
   * const myKeplerGlReducer = keplerGlReducer
   *  .initialState({
   *    uiState: {readOnly: true}
   *  });
   */


  target.initialState = function initialState(iniSt) {
    var merged = mergeInitialState(targetInitialState, iniSt);
    var targetReducer = provideInitialState(merged);
    return decorate(targetReducer, merged);
  };

  return target;
}
/**
 * Kepler.gl reducer to be mounted to your store. You can mount `keplerGlReducer` at property `keplerGl`, if you choose
 * to mount it at another address e.g. `foo` you will need to specify it when you mount `KeplerGl` component in your app with `getState: state => state.foo`
 * @public
 * @example
 * import keplerGlReducer from 'kepler.gl/reducers';
 * import {createStore, combineReducers, applyMiddleware, compose} from 'redux';
 * import {taskMiddleware} from 'react-palm/tasks';
 *
 * const initialState = {};
 * const reducers = combineReducers({
 *   // <-- mount kepler.gl reducer in your app
 *   keplerGl: keplerGlReducer,
 *
 *   // Your other reducers here
 *   app: appReducer
 * });
 *
 * // using createStore
 * export default createStore(reducer, initialState, applyMiddleware(taskMiddleware));
 */


var keplerGlReducer = decorate(_keplerGlReducer);
var _default = keplerGlReducer;
exports["default"] = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9yb290LnRzIl0sIm5hbWVzIjpbImluaXRpYWxDb3JlU3RhdGUiLCJwcm92aWRlSW5pdGlhbFN0YXRlIiwiaW5pdGlhbFN0YXRlIiwiY29yZVJlZHVjZXIiLCJoYW5kbGVSZWdpc3RlckVudHJ5Iiwic3RhdGUiLCJwYXlsb2FkIiwiaWQiLCJtaW50IiwibWFwYm94QXBpQWNjZXNzVG9rZW4iLCJtYXBib3hBcGlVcmwiLCJtYXBTdHlsZXNSZXBsYWNlRGVmYXVsdCIsImluaXRpYWxVaVN0YXRlIiwicHJldmlvdXNTdGF0ZSIsInVuZGVmaW5lZCIsImhhbmRsZURlbGV0ZUVudHJ5IiwiT2JqZWN0Iiwia2V5cyIsInJlZHVjZSIsImFjY3UiLCJjdXJyIiwiaGFuZGxlUmVuYW1lRW50cnkiLCJvbGRJZCIsIm5ld0lkIiwiYWN0aW9uIiwiZm9yRWFjaCIsInVwZGF0ZUl0ZW1TdGF0ZSIsImhhbmRsZXJzIiwiQWN0aW9uVHlwZXMiLCJSRUdJU1RFUl9FTlRSWSIsIkRFTEVURV9FTlRSWSIsIlJFTkFNRV9FTlRSWSIsIl9rZXBsZXJHbFJlZHVjZXIiLCJtZXJnZUluaXRpYWxTdGF0ZSIsInNhdmVkIiwicHJvdmlkZWQiLCJrZXkiLCJkZWNvcmF0ZSIsInRhcmdldCIsInNhdmVkSW5pdGlhbFN0YXRlIiwidGFyZ2V0SW5pdGlhbFN0YXRlIiwicGx1Z2luIiwiY3VzdG9tUmVkdWNlciIsIm5leHRTdGF0ZSIsImluaVN0IiwibWVyZ2VkIiwidGFyZ2V0UmVkdWNlciIsImtlcGxlckdsUmVkdWNlciJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFvQkE7O0FBQ0E7O0FBRUE7Ozs7OztBQUVBO0FBQ0EsSUFBTUEsZ0JBQWdCLEdBQUcsRUFBekI7O0FBRU8sU0FBU0MsbUJBQVQsQ0FBNkJDLFlBQTdCLEVBQTJDO0FBQ2hELE1BQU1DLFdBQVcsR0FBRyw4QkFBbUJELFlBQW5CLENBQXBCOztBQUVBLE1BQU1FLG1CQUFtQixHQUFHLFNBQXRCQSxtQkFBc0Is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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxJQUFNUyxlQUFlLEdBQUdWLFFBQVEsQ0FBQ0wsZ0JBQUQsQ0FBaEM7ZUFDZWUsZSIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAyMiBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5cbmltcG9ydCB7QWN0aW9uVHlwZXMsIGtlcGxlckdsSW5pdCwgX2FjdGlvbkZvciwgX3VwZGF0ZVByb3BlcnR5fSBmcm9tICdAa2VwbGVyLmdsL2FjdGlvbnMnO1xuaW1wb3J0IHtoYW5kbGVBY3Rpb25zfSBmcm9tICdyZWR1eC1hY3Rpb25zJztcblxuaW1wb3J0IHtjb3JlUmVkdWNlckZhY3Rvcnl9IGZyb20gJy4vY29yZSc7XG5cbi8vIElOSVRJQUxfU1RBVEVcbmNvbnN0IGluaXRpYWxDb3JlU3RhdGUgPSB7fTtcblxuZXhwb3J0IGZ1bmN0aW9uIHByb3ZpZGVJbml0aWFsU3RhdGUoaW5pdGlhbFN0YXRlKSB7XG4gIGNvbnN0IGNvcmVSZWR1Y2VyID0gY29yZVJlZHVjZXJGYWN0b3J5KGluaXRpYWxTdGF0ZSk7XG5cbiAgY29uc3QgaGFuZGxlUmVnaXN0ZXJFbnRyeSA9IChcbiAgICBzdGF0ZSxcbiAgICB7XG4gICAgICBwYXlsb2FkOiB7XG4gICAgICAgIGlkLFxuICAgICAgICBtaW50LFxuICAgICAgICBtYXBib3hBcGlBY2Nlc3NUb2tlbixcbiAgICAgICAgbWFwYm94QXBpVXJsLFxuICAgICAgICBtYXBTdHlsZXNSZXBsYWNlRGVmYXVsdCxcbiAgICAgICAgaW5pdGlhbFVpU3RhdGVcbiAgICAgIH1cbiAgICB9XG4gICkgPT4ge1xuICAgIC8vIGJ5IGRlZmF1bHQsIGFsd2F5cyBjcmVhdGUgYSBtaW50IHN0YXRlIGV2ZW4gaWYgdGhlIHNhbWUgaWQgYWxyZWFkeSBleGlzdFxuICAgIC8vIGlmIHN0YXRlLmlkIGV4aXN0IGFuZCBtaW50PWZhbHNlLCBrZWVwIHRoZSBleGlzdGluZyBzdGF0ZVxuICAgIGNvbnN0IHByZXZpb3VzU3RhdGUgPSBzdGF0ZVtpZF0gJiYgbWludCA9PT0gZmFsc2UgPyBzdGF0ZVtpZF0gOiB1bmRlZmluZWQ7XG5cbiAgICByZXR1cm4ge1xuICAgICAgLy8gcmVnaXN0ZXIgZW50cnkgdG8ga2VwbGVyLmdsIHBhc3NpbmcgaW4gbWFwYm94IGNvbmZpZyB0byBtYXBTdHlsZVxuICAgICAgLi4uc3RhdGUsXG4gICAgICBbaWRdOiBjb3JlUmVkdWNlcihcbiAgICAgICAgcHJldmlvdXNTdGF0ZSxcbiAgICAgICAga2VwbGVyR2xJbml0KHttYXBib3hBcGlBY2Nlc3NUb2tlbiwgbWFwYm94QXBpVXJsLCBtYXBTdHlsZXNSZXBsYWNlRGVmYXVsdCwgaW5pdGlhbFVpU3RhdGV9KVxuICAgICAgKVxuICAgIH07XG4gIH07XG5cbiAgY29uc3QgaGFuZGxlRGVsZXRlRW50cnkgPSAoc3RhdGUsIHtwYXlsb2FkOiBpZH0pID0+XG4gICAgT2JqZWN0LmtleXMoc3RhdGUpLnJlZHVjZShcbiAgICAgIChhY2N1LCBjdXJyKSA9PiAoe1xuICAgICAgICAuLi5hY2N1LFxuICAgICAgICAuLi4oY3VyciA9PT0gaWQgPyB7fSA6IHtbY3Vycl06IHN0YXRlW2N1cnJdfSlcbiAgICAgIH0pLFxuICAgICAge31cbiAgICApO1xuXG4gIGNvbnN0IGhhbmRsZVJlbmFtZUVudHJ5ID0gKHN0YXRlLCB7cGF5bG9hZDoge29sZElkLCBuZXdJZH19KSA9PlxuICAgIE9iamVjdC5rZXlzKHN0YXRlKS5yZWR1Y2UoXG4gICAgICAoYWNjdSwgY3VycikgPT4gKHtcbiAgICAgICAgLi4uYWNjdSxcbiAgICAgICAgLi4ue1tjdXJyID09PSBvbGRJZCA/IG5ld0lkIDogY3Vycl06IHN0YXRlW2N1cnJdfVxuICAgICAgfSksXG4gICAgICB7fVxuICAgICk7XG5cbiAgcmV0dXJuIChzdGF0ZSA9IGluaXRpYWxDb3JlU3RhdGUsIGFjdGlvbikgPT4ge1xuICAgIC8vIHVwZGF0ZSBjaGlsZCBzdGF0ZXNcbiAgICBPYmplY3Qua2V5cyhzdGF0ZSkuZm9yRWFjaChpZCA9PiB7XG4gICAgICBjb25zdCB1cGRhdGVJdGVtU3RhdGUgPSBjb3JlUmVkdWNlcihzdGF0ZVtpZF0sIF9hY3Rpb25Gb3IoaWQsIGFjdGlvbikpO1xuICAgICAgc3RhdGUgPSBfdXBkYXRlUHJvcGVydHkoc3RhdGUsIGlkLCB1cGRhdGVJdGVtU3RhdGUpO1xuICAgIH0pO1xuXG4gICAgLy8gcGVyZm9ybSBhZGRpdGlvbmFsIHN0YXRlIHJlZHVjaW5nIChlLmcuIHN3aXRjaCBhY3Rpb24udHlwZSBldGMuLi4pXG4gICAgY29uc3QgaGFuZGxlcnMgPSB7XG4gICAgICBbQWN0aW9uVHlwZXMuUkVHSVNURVJfRU5UUlldOiBoYW5kbGVSZWdpc3RlckVudHJ5LFxuICAgICAgW0FjdGlvblR5cGVzLkRFTEVURV9FTlRSWV06IGhhbmRsZURlbGV0ZUVudHJ5LFxuICAgICAgW0FjdGlvblR5cGVzLlJFTkFNRV9FTlRSWV06IGhhbmRsZVJlbmFtZUVudHJ5XG4gICAgfTtcblxuICAgIC8vIFRPRE86IFVuZGVyc3RhbmQgd2h5IHRoZSBMaW50IHNlZXMgYW4gZXJyb3IgaGVyZSwgd2hpbGUgdGhlIElERSBkb2VzIG5vdC5cbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgcmV0dXJuIGhhbmRsZUFjdGlvbnMoaGFuZGxlcnMsIGluaXRpYWxDb3JlU3RhdGUpKHN0YXRlLCBhY3Rpb24pO1xuICB9O1xufVxuXG5jb25zdCBfa2VwbGVyR2xSZWR1Y2VyID0gcHJvdmlkZUluaXRpYWxTdGF0ZShpbml0aWFsQ29yZVN0YXRlKTtcblxuZnVuY3Rpb24gbWVyZ2VJbml0aWFsU3RhdGUoc2F2ZWQgPSB7fSwgcHJvdmlkZWQgPSB7fSkge1xuICBjb25zdCBrZXlzID0gWydtYXBTdGF0ZScsICdtYXBTdHlsZScsICd2aXNTdGF0ZScsICd1aVN0YXRlJ107XG5cbiAgLy8gc2hhbGxvdyBtZXJnZSBlYWNoIHJlZHVjZXJcbiAgcmV0dXJuIGtleXMucmVkdWNlKFxuICAgIChhY2N1LCBrZXkpID0+ICh7XG4gICAgICAuLi5hY2N1LFxuICAgICAgLi4uKHNhdmVkW2tleV0gJiYgcHJvdmlkZWRba2V5XVxuICAgICAgICA/IHtba2V5XTogey4uLnNhdmVkW2tleV0sIC4uLnByb3ZpZGVkW2tleV19fVxuICAgICAgICA6IHtba2V5XTogc2F2ZWRba2V5XSB8fCBwcm92aWRlZFtrZXldIHx8IHt9fSlcbiAgICB9KSxcbiAgICB7fVxuICApO1xufVxuXG5mdW5jdGlvbiBkZWNvcmF0ZSh0YXJnZXQsIHNhdmVkSW5pdGlhbFN0YXRlID0ge30pIHtcbiAgY29uc3QgdGFyZ2V0SW5pdGlhbFN0YXRlID0gc2F2ZWRJbml0aWFsU3RhdGU7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBrZXBsZXIuZ2wgcmVkdWNlciB0aGF0IHdpbGwgYWxzbyBwYXNzIGVhY2ggYWN0aW9uIHRocm91Z2ggYWRkaXRpb25hbCByZWR1Y2VycyBzcGllY2lmaWVkLlxuICAgKiBUaGUgcGFyYW1ldGVyIHNob3VsZCBiZSBlaXRoZXIgYSByZWR1Y2VyIG1hcCBvciBhIHJlZHVjZXIgZnVuY3Rpb24uXG4gICAqIFRoZSBzdGF0ZSBwYXNzZWQgaW50byB0aGUgYWRkaXRpb25hbCBhY3Rpb24gaGFuZGxlciBpcyB0aGUgaW5zdGFuY2Ugc3RhdGUuXG4gICAqIEl0IHdpbGwgaW5jbHVkZSBhbGwgdGhlIHN1YnJlZHVjZXJzIGB2aXNTdGF0ZWAsIGB1aVN0YXRlYCwgYG1hcFN0YXRlYCBhbmQgYG1hcFN0eWxlYC5cbiAgICogYC5wbHVnaW5gIGlzIG9ubHkgbWVhbnQgdG8gYmUgY2FsbGVkIG9uY2Ugd2hlbiBtb3VudGluZyB0aGUga2VwbGVyR2xSZWR1Y2VyIHRvIHRoZSBzdG9yZS5cbiAgICogKipOb3RlKiogVGhpcyBpcyBhbiBhZHZhbmNlZCBvcHRpb24gdG8gZ2l2ZSB5b3UgbW9yZSBmcmVlZG9tIHRvIG1vZGlmeSB0aGUgaW50ZXJuYWwgc3RhdGUgb2YgdGhlIGtlcGxlci5nbCBpbnN0YW5jZS5cbiAgICogWW91IHNob3VsZCBvbmx5IHVzZSB0aGlzIHRvIGFkZGluZyBhZGRpdGlvbmFsIGFjdGlvbnMgaW5zdGVhZCBvZiByZXBsYWNpbmcgZGVmYXVsdCBhY3Rpb25zLlxuICAgKlxuICAgKiBAbWl4aW4ga2VwbGVyR2xSZWR1Y2VyLnBsdWdpblxuICAgKiBAbWVtYmVyb2Yga2VwbGVyR2xSZWR1Y2VyXG4gICAqIEBwYXJhbSB7T2JqZWN0fEZ1bmN0aW9ufSBjdXN0b21SZWR1Y2VyIC0gQSByZWR1Y2VyIG1hcCBvciBhIHJlZHVjZXJcbiAgICogQHB1YmxpY1xuICAgKiBAZXhhbXBsZVxuICAgKiBjb25zdCBteUtlcGxlckdsUmVkdWNlciA9IGtlcGxlckdsUmVkdWNlclxuICAgKiAgLnBsdWdpbih7XG4gICAqICAgIC8vIDEuIGFzIHJlZHVjZXIgbWFwXG4gICAqICAgIEhJREVfQU5EX1NIT1dfU0lERV9QQU5FTDogKHN0YXRlLCBhY3Rpb24pID0+ICh7XG4gICAqICAgICAgLi4uc3RhdGUsXG4gICAqICAgICAgdWlTdGF0ZToge1xuICAgKiAgICAgICAgLi4uc3RhdGUudWlTdGF0ZSxcbiAgICogICAgICAgIHJlYWRPbmx5OiAhc3RhdGUudWlTdGF0ZS5yZWFkT25seVxuICAgKiAgICAgIH1cbiAgICogICAgfSlcbiAgICogIH0pXG4gICAqIC5wbHVnaW4oaGFuZGxlQWN0aW9ucyh7XG4gICAqICAgLy8gMi4gYXMgcmVkdWNlclxuICAgKiAgICdISURFX01BUF9DT05UUk9MUyc6IChzdGF0ZSwgYWN0aW9uKSA9PiAoe1xuICAgKiAgICAgLi4uc3RhdGUsXG4gICAqICAgICB1aVN0YXRlOiB7XG4gICAqICAgICAgIC4uLnN0YXRlLnVpU3RhdGUsXG4gICAqICAgICAgIG1hcENvbnRyb2xzOiBoaWRkZW5NYXBDb250cm9sXG4gICAqICAgICB9XG4gICAqICAgfSlcbiAgICogfSwge30pKTtcbiAgICovXG4gIHRhcmdldC5wbHVnaW4gPSBmdW5jdGlvbiBwbHVnaW4oY3VzdG9tUmVkdWNlcikge1xuICAgIGlmICh0eXBlb2YgY3VzdG9tUmVkdWNlciA9PT0gJ29iamVjdCcpIHtcbiAgICAgIC8vIGlmIG9ubHkgcHJvdmlkZWQgYSByZWR1Y2VyTWFwLCB3cmFwIGl0IGluIGEgcmVkdWNlclxuICAgICAgY3VzdG9tUmVkdWNlciA9IGhhbmRsZUFjdGlvbnMoY3VzdG9tUmVkdWNlciwge30pO1xuICAgIH1cblxuICAgIC8vIHVzZSAnZnVuY3Rpb24nIGtleXdvcmQgdG8gZW5hYmxlICd0aGlzJ1xuICAgIHJldHVybiBkZWNvcmF0ZSgoc3RhdGUgPSB7fSwgYWN0aW9uID0ge30pID0+IHtcbiAgICAgIGxldCBuZXh0U3RhdGUgPSB0aGlzKHN0YXRlLCBhY3Rpb24pO1xuXG4gICAgICAvLyBmb3IgZWFjaCBlbnRyeSBpbiB0aGUgc3RhdGVuXG4gICAgICBPYmplY3Qua2V5cyhuZXh0U3RhdGUpLmZvckVhY2goaWQgPT4ge1xuICAgICAgICAvLyB1cGRhdGUgY2hpbGQgc3RhdGVzXG4gICAgICAgIG5leHRTdGF0ZSA9IF91cGRhdGVQcm9wZXJ0eShcbiAgICAgICAgICBuZXh0U3RhdGUsXG4gICAgICAgICAgaWQsXG4gICAgICAgICAgY3VzdG9tUmVkdWNlcihuZXh0U3RhdGVbaWRdLCBfYWN0aW9uRm9yKGlkLCBhY3Rpb24pKVxuICAgICAgICApO1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBuZXh0U3RhdGU7XG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybiBhIHJlZHVjZXIgdGhhdCBpbml0aWF0ZWQgd2l0aCBjdXN0b20gaW5pdGlhbCBzdGF0ZS5cbiAgICogVGhlIHBhcmFtZXRlciBzaG91bGQgYmUgYW4gb2JqZWN0IG1hcHBpbmcgZnJvbSBgc3VicmVkdWNlcmAgbmFtZSB0byBjdXN0b20gc3VicmVkdWNlciBzdGF0ZSxcbiAgICogd2hpY2ggd2lsbCBiZSBzaGFsbG93ICoqbWVyZ2VkKiogd2l0aCBkZWZhdWx0IGluaXRpYWwgc3RhdGUuXG4gICAqXG4gICAqIERlZmF1bHQgc3VicmVkdWNlciBzdGF0ZTpcbiAgICogIC0gW2B2aXNTdGF0ZWBdKC4vdmlzLXN0YXRlLm1kI0lOSVRJQUxfVklTX1NUQVRFKVxuICAgKiAgLSBbYG1hcFN0YXRlYF0oLi9tYXAtc3RhdGUubWQjSU5JVElBTF9NQVBfU1RBVEUpXG4gICAqICAtIFtgbWFwU3R5bGVgXSguL21hcC1zdHlsZS5tZCNJTklUSUFMX01BUF9TVFlMRSlcbiAgICogIC0gW2B1aVN0YXRlYF0oLi91aS1zdGF0ZS5tZCNJTklUSUFMX1VJX1NUQVRFKVxuICAgKiBAbWl4aW4ga2VwbGVyR2xSZWR1Y2VyLmluaXRpYWxTdGF0ZVxuICAgKiBAbWVtYmVyb2Yga2VwbGVyR2xSZWR1Y2VyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBpbmlTdCAtIGN1c3RvbSBzdGF0ZSB0byBiZSBtZXJnZWQgd2l0aCBkZWZhdWx0IGluaXRpYWwgc3RhdGVcbiAgICogQHB1YmxpY1xuICAgKiBAZXhhbXBsZVxuICAgKiBjb25zdCBteUtlcGxlckdsUmVkdWNlciA9IGtlcGxlckdsUmVkdWNlclxuICAgKiAgLmluaXRpYWxTdGF0ZSh7XG4gICAqICAgIHVpU3RhdGU6IHtyZWFkT25seTogdHJ1ZX1cbiAgICogIH0pO1xuICAgKi9cbiAgdGFyZ2V0LmluaXRpYWxTdGF0ZSA9IGZ1bmN0aW9uIGluaXRpYWxTdGF0ZShpbmlTdCkge1xuICAgIGNvbnN0IG1lcmdlZCA9IG1lcmdlSW5pdGlhbFN0YXRlKHRhcmdldEluaXRpYWxTdGF0ZSwgaW5pU3QpO1xuICAgIGNvbnN0IHRhcmdldFJlZHVjZXIgPSBwcm92aWRlSW5pdGlhbFN0YXRlKG1lcmdlZCk7XG5cbiAgICByZXR1cm4gZGVjb3JhdGUodGFyZ2V0UmVkdWNlciwgbWVyZ2VkKTtcbiAgfTtcblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG4vKipcbiAqIEtlcGxlci5nbCByZWR1Y2VyIHRvIGJlIG1vdW50ZWQgdG8geW91ciBzdG9yZS4gWW91IGNhbiBtb3VudCBga2VwbGVyR2xSZWR1Y2VyYCBhdCBwcm9wZXJ0eSBga2VwbGVyR2xgLCBpZiB5b3UgY2hvb3NlXG4gKiB0byBtb3VudCBpdCBhdCBhbm90aGVyIGFkZHJlc3MgZS5nLiBgZm9vYCB5b3Ugd2lsbCBuZWVkIHRvIHNwZWNpZnkgaXQgd2hlbiB5b3UgbW91bnQgYEtlcGxlckdsYCBjb21wb25lbnQgaW4geW91ciBhcHAgd2l0aCBgZ2V0U3RhdGU6IHN0YXRlID0+IHN0YXRlLmZvb2BcbiAqIEBwdWJsaWNcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQga2VwbGVyR2xSZWR1Y2VyIGZyb20gJ2tlcGxlci5nbC9yZWR1Y2Vycyc7XG4gKiBpbXBvcnQge2NyZWF0ZVN0b3JlLCBjb21iaW5lUmVkdWNlcnMsIGFwcGx5TWlkZGxld2FyZSwgY29tcG9zZX0gZnJvbSAncmVkdXgnO1xuICogaW1wb3J0IHt0YXNrTWlkZGxld2FyZX0gZnJvbSAncmVhY3QtcGFsbS90YXNrcyc7XG4gKlxuICogY29uc3QgaW5pdGlhbFN0YXRlID0ge307XG4gKiBjb25zdCByZWR1Y2VycyA9IGNvbWJpbmVSZWR1Y2Vycyh7XG4gKiAgIC8vIDwtLSBtb3VudCBrZXBsZXIuZ2wgcmVkdWNlciBpbiB5b3VyIGFwcFxuICogICBrZXBsZXJHbDoga2VwbGVyR2xSZWR1Y2VyLFxuICpcbiAqICAgLy8gWW91ciBvdGhlciByZWR1Y2VycyBoZXJlXG4gKiAgIGFwcDogYXBwUmVkdWNlclxuICogfSk7XG4gKlxuICogLy8gdXNpbmcgY3JlYXRlU3RvcmVcbiAqIGV4cG9ydCBkZWZhdWx0IGNyZWF0ZVN0b3JlKHJlZHVjZXIsIGluaXRpYWxTdGF0ZSwgYXBwbHlNaWRkbGV3YXJlKHRhc2tNaWRkbGV3YXJlKSk7XG4gKi9cbmNvbnN0IGtlcGxlckdsUmVkdWNlciA9IGRlY29yYXRlKF9rZXBsZXJHbFJlZHVjZXIpO1xuZXhwb3J0IGRlZmF1bHQga2VwbGVyR2xSZWR1Y2VyO1xuIl19