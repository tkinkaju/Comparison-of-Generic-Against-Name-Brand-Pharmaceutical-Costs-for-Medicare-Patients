// Copyright (c) 2022 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addDataToMapComposed = exports.loadFilesSuccessUpdater = exports.addDataToMapUpdater = exports.defaultAddDataToMapOptions = exports.isValidConfig = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _uiStateUpdaters = require("./ui-state-updaters");

var _visStateUpdaters = require("./vis-state-updaters");

var _mapStateUpdaters = require("./map-state-updaters");

var _mapStyleUpdaters = require("./map-style-updaters");

var _processors = require("@kepler.gl/processors");

var _composerHelpers = require("./composer-helpers");

var _utils = require("@kepler.gl/utils");

var _dataUtils = require("./data-utils");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

// compose action to apply result multiple reducers, with the output of one

/**
 * Some actions will affect the entire kepler.lg instance state.
 * The updaters for these actions is exported as `combinedUpdaters`. These updater take the entire instance state
 * as the first argument. Read more about [Using updaters](../advanced-usage/using-updaters.md)
 * @public
 * @example
 *
 * import keplerGlReducer, {combinedUpdaters} from 'kepler.gl/reducers';
 * // Root Reducer
 * const reducers = combineReducers({
 *  keplerGl: keplerGlReducer,
 *  app: appReducer
 * });
 *
 * const composedReducer = (state, action) => {
 *  switch (action.type) {
 *    // add data to map after receiving data from remote sources
 *    case 'LOAD_REMOTE_RESOURCE_SUCCESS':
 *      return {
 *        ...state,
 *        keplerGl: {
 *          ...state.keplerGl,
 *          // pass in kepler.gl instance state to combinedUpdaters
 *          map:  combinedUpdaters.addDataToMapUpdater(
 *           state.keplerGl.map,
 *           {
 *             payload: {
 *               datasets: action.datasets,
 *               options: {readOnly: true},
 *               config: action.config
 *              }
 *            }
 *          )
 *        }
 *      };
 *  }
 *  return reducers(state, action);
 * };
 *
 * export default composedReducer;
 */

/* eslint-disable no-unused-vars */
// @ts-ignore
var combinedUpdaters = null;
/* eslint-enable no-unused-vars */

var isValidConfig = function isValidConfig(config) {
  return (0, _utils.isPlainObject)(config) && (0, _utils.isPlainObject)(config.config) && config.version;
};

exports.isValidConfig = isValidConfig;
var defaultAddDataToMapOptions = {
  centerMap: true,
  keepExistingConfig: false,
  autoCreateLayers: true
};
/**
 * Combine data and full configuration update in a single action
 *
 * @memberof combinedUpdaters
 * @param {Object} state kepler.gl instance state, containing all subreducer state
 * @param {Object} action
 * @param {Object} action.payload `{datasets, options, config}`
 * @param action.payload.datasets - ***required** datasets can be a dataset or an array of datasets
 * Each dataset object needs to have `info` and `data` property.
 * @param [action.payload.options] option object `{centerMap: true}`
 * @param [action.payload.config] map config
 * @param [action.payload.info] map info contains title and description
 * @returns nextState
 *
 * @typedef {Object} Dataset
 * @property info -info of a dataset
 * @property info.id - id of this dataset. If config is defined, `id` should matches the `dataId` in config.
 * @property info.label - A display name of this dataset
 * @property data - ***required** The data object, in a tabular format with 2 properties `fields` and `rows`
 * @property data.fields - ***required** Array of fields,
 * @property data.fields.name - ***required** Name of the field,
 * @property data.rows - ***required** Array of rows, in a tabular format with `fields` and `rows`
 *
 * @public
 */

exports.defaultAddDataToMapOptions = defaultAddDataToMapOptions;

var addDataToMapUpdater = function addDataToMapUpdater(state, _ref) {
  var payload = _ref.payload;
  var datasets = payload.datasets,
      config = payload.config,
      info = payload.info;

  var options = _objectSpread(_objectSpread({}, defaultAddDataToMapOptions), payload.options); // @ts-expect-error


  var parsedConfig = config;

  if (isValidConfig(config)) {
    // if passed in saved config
    // @ts-expect-error
    parsedConfig = state.visState.schema.parseSavedConfig(config);
  }

  var oldLayers = state.visState.layers;

  var filterNewlyAddedLayers = function filterNewlyAddedLayers(layers) {
    return layers.filter(function (nl) {
      return !oldLayers.find(function (ol) {
        return ol === nl;
      });
    });
  }; // Returns undefined if not found, to make typescript happy


  var findMapBoundsIfCentered = function findMapBoundsIfCentered(layers) {
    var bounds = options.centerMap && (0, _dataUtils.findMapBounds)(layers);
    return bounds ? bounds : undefined;
  };

  return (0, _composerHelpers.compose_)([(0, _composerHelpers.pick_)('visState')((0, _composerHelpers.apply_)(_visStateUpdaters.updateVisDataUpdater, {
    datasets: datasets,
    options: options,
    config: parsedConfig
  })), (0, _composerHelpers.if_)(Boolean(info), (0, _composerHelpers.pick_)('visState')((0, _composerHelpers.apply_)(_visStateUpdaters.setMapInfoUpdater, {
    info: info
  }))), (0, _composerHelpers.with_)(function (_ref2) {
    var visState = _ref2.visState;
    return (0, _composerHelpers.pick_)('mapState')((0, _composerHelpers.apply_)(_mapStateUpdaters.receiveMapConfigUpdater, (0, _composerHelpers.payload_)({
      config: parsedConfig,
      options: options,
      bounds: findMapBoundsIfCentered(filterNewlyAddedLayers(visState.layers))
    })));
  }), (0, _composerHelpers.pick_)('mapStyle')((0, _composerHelpers.apply_)(_mapStyleUpdaters.receiveMapConfigUpdater, (0, _composerHelpers.payload_)({
    config: parsedConfig,
    options: options
  }))), (0, _composerHelpers.pick_)('uiState')((0, _composerHelpers.apply_)(_uiStateUpdaters.loadFilesSuccessUpdater, (0, _composerHelpers.payload_)(null))), (0, _composerHelpers.pick_)('uiState')((0, _composerHelpers.apply_)(_uiStateUpdaters.toggleModalUpdater, (0, _composerHelpers.payload_)(null))), (0, _composerHelpers.pick_)('uiState')((0, _composerHelpers.merge_)(options.hasOwnProperty('readOnly') ? {
    readOnly: options.readOnly
  } : {}))])(state);
};

exports.addDataToMapUpdater = addDataToMapUpdater;

var loadFilesSuccessUpdater = function loadFilesSuccessUpdater(state, action) {
  // still more to load
  var payloads = (0, _processors.filesToDataPayload)(action.result);
  var nextState = (0, _composerHelpers.compose_)([(0, _composerHelpers.pick_)('visState')((0, _composerHelpers.merge_)({
    fileLoading: false,
    fileLoadingProgress: {}
  }))])(state); // make multiple add data to map calls

  var stateWithData = (0, _composerHelpers.compose_)(payloads.map(function (p) {
    return (0, _composerHelpers.apply_)(addDataToMapUpdater, (0, _composerHelpers.payload_)(p));
  }))(nextState);
  return stateWithData;
};

exports.loadFilesSuccessUpdater = loadFilesSuccessUpdater;
var addDataToMapComposed = addDataToMapUpdater;
exports.addDataToMapComposed = addDataToMapComposed;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9jb21iaW5lZC11cGRhdGVycy50cyJdLCJuYW1lcyI6WyJjb21iaW5lZFVwZGF0ZXJzIiwiaXNWYWxpZENvbmZpZyIsImNvbmZpZyIsInZlcnNpb24iLCJkZWZhdWx0QWRkRGF0YVRvTWFwT3B0aW9ucyIsImNlbnRlck1hcCIsImtlZXBFeGlzdGluZ0NvbmZpZyIsImF1dG9DcmVhdGVMYXllcnMiLCJhZGREYXRhVG9NYXBVcGRhdGVyIiwic3RhdGUiLCJwYXlsb2FkIiwiZGF0YXNldHMiLCJpbmZvIiwib3B0aW9ucyIsInBhcnNlZENvbmZpZyIsInZpc1N0YXRlIiwic2NoZW1hIiwicGFyc2VTYXZlZENvbmZpZyIsIm9sZExheWVycyIsImxheWVycyIsImZpbHRlck5ld2x5QWRkZWRMYXllcnMiLCJmaWx0ZXIiLCJubCIsImZpbmQiLCJvbCIsImZpbmRNYXBCb3VuZHNJZkNlbnRlcmVkIiwiYm91bmRzIiwidW5kZWZpbmVkIiwidmlzU3RhdGVVcGRhdGVWaXNEYXRhVXBkYXRlciIsIkJvb2xlYW4iLCJzZXRNYXBJbmZvVXBkYXRlciIsInN0YXRlTWFwQ29uZmlnVXBkYXRlciIsInN0eWxlTWFwQ29uZmlnVXBkYXRlciIsInVpU3RhdGVMb2FkRmlsZXNTdWNjZXNzVXBkYXRlciIsInRvZ2dsZU1vZGFsVXBkYXRlciIsImhhc093blByb3BlcnR5IiwicmVhZE9ubHkiLCJsb2FkRmlsZXNTdWNjZXNzVXBkYXRlciIsImFjdGlvbiIsInBheWxvYWRzIiwicmVzdWx0IiwibmV4dFN0YXRlIiwiZmlsZUxvYWRpbmciLCJmaWxlTG9hZGluZ1Byb2dyZXNzIiwic3RhdGVXaXRoRGF0YSIsIm1hcCIsInAiLCJhZGREYXRhVG9NYXBDb21wb3NlZCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFvQkE7O0FBSUE7O0FBSUE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBT0E7O0FBQ0E7Ozs7OztBQVVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QyxJQUFBQSxXQUFXLEVBQUUsS0FEUjtBQUVMQyxJQUFBQSxtQkFBbUIsRUFBRTtBQUZoQixHQUFQLENBREYsQ0FEeUIsQ0FBVCxFQU9mbEMsS0FQZSxDQUFsQixDQUhrQixDQVdsQjs7QUFDQSxNQUFNbUMsYUFBYSxHQUFHLCtCQUFTTCxRQUFRLENBQUNNLEdBQVQsQ0FBYSxVQUFBQyxDQUFDO0FBQUEsV0FBSSw2QkFBT3RDLG1CQUFQLEVBQTRCLCtCQUFTc0MsQ0FBVCxDQUE1QixDQUFKO0FBQUEsR0FBZCxDQUFULEVBQ3BCTCxTQURvQixDQUF0QjtBQUdBLFNBQU9HLGFBQVA7QUFDRCxDQW5CTTs7O0FBcUJBLElBQU1HLG9CQUFvQixHQUFHdkMsbUJBQTdCIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDIyIFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuaW1wb3J0IHtcbiAgdG9nZ2xlTW9kYWxVcGRhdGVyLFxuICBsb2FkRmlsZXNTdWNjZXNzVXBkYXRlciBhcyB1aVN0YXRlTG9hZEZpbGVzU3VjY2Vzc1VwZGF0ZXJcbn0gZnJvbSAnLi91aS1zdGF0ZS11cGRhdGVycyc7XG5pbXBvcnQge1xuICB1cGRhdGVWaXNEYXRhVXBkYXRlciBhcyB2aXNTdGF0ZVVwZGF0ZVZpc0RhdGFVcGRhdGVyLFxuICBzZXRNYXBJbmZvVXBkYXRlclxufSBmcm9tICcuL3Zpcy1zdGF0ZS11cGRhdGVycyc7XG5pbXBvcnQge3JlY2VpdmVNYXBDb25maWdVcGRhdGVyIGFzIHN0YXRlTWFwQ29uZmlnVXBkYXRlcn0gZnJvbSAnLi9tYXAtc3RhdGUtdXBkYXRlcnMnO1xuaW1wb3J0IHtyZWNlaXZlTWFwQ29uZmlnVXBkYXRlciBhcyBzdHlsZU1hcENvbmZpZ1VwZGF0ZXJ9IGZyb20gJy4vbWFwLXN0eWxlLXVwZGF0ZXJzJztcbmltcG9ydCB7ZmlsZXNUb0RhdGFQYXlsb2FkfSBmcm9tICdAa2VwbGVyLmdsL3Byb2Nlc3NvcnMnO1xuaW1wb3J0IHtwYXlsb2FkXywgYXBwbHlfLCB3aXRoXywgaWZfLCBjb21wb3NlXywgbWVyZ2VfLCBwaWNrX30gZnJvbSAnLi9jb21wb3Nlci1oZWxwZXJzJztcbmltcG9ydCB7TWFwU3RhdGUsIFVpU3RhdGUsIEFkZERhdGFUb01hcFBheWxvYWQsIFBhcnNlZENvbmZpZ30gZnJvbSAnQGtlcGxlci5nbC90eXBlcyc7XG5pbXBvcnQge01hcFN0eWxlfSBmcm9tICcuL21hcC1zdHlsZS11cGRhdGVycyc7XG5pbXBvcnQge1Byb3ZpZGVyU3RhdGV9IGZyb20gJy4vcHJvdmlkZXItc3RhdGUtdXBkYXRlcnMnO1xuaW1wb3J0IHtsb2FkRmlsZXNTdWNjZXNzVXBkYXRlckFjdGlvbn0gZnJvbSAnQGtlcGxlci5nbC9hY3Rpb25zJztcbmltcG9ydCB7VmlzU3RhdGV9IGZyb20gJ0BrZXBsZXIuZ2wvc2NoZW1hcyc7XG5pbXBvcnQge0xheWVyfSBmcm9tICdAa2VwbGVyLmdsL2xheWVycyc7XG5pbXBvcnQge2lzUGxhaW5PYmplY3R9IGZyb20gJ0BrZXBsZXIuZ2wvdXRpbHMnO1xuaW1wb3J0IHtmaW5kTWFwQm91bmRzfSBmcm9tICcuL2RhdGEtdXRpbHMnO1xuXG5leHBvcnQgdHlwZSBLZXBsZXJHbFN0YXRlID0ge1xuICB2aXNTdGF0ZTogVmlzU3RhdGU7XG4gIG1hcFN0YXRlOiBNYXBTdGF0ZTtcbiAgbWFwU3R5bGU6IE1hcFN0eWxlO1xuICB1aVN0YXRlOiBVaVN0YXRlO1xuICBwcm92aWRlclN0YXRlOiBQcm92aWRlclN0YXRlO1xufTtcblxuLy8gY29tcG9zZSBhY3Rpb24gdG8gYXBwbHkgcmVzdWx0IG11bHRpcGxlIHJlZHVjZXJzLCB3aXRoIHRoZSBvdXRwdXQgb2Ygb25lXG5cbi8qKlxuICogU29tZSBhY3Rpb25zIHdpbGwgYWZmZWN0IHRoZSBlbnRpcmUga2VwbGVyLmxnIGluc3RhbmNlIHN0YXRlLlxuICogVGhlIHVwZGF0ZXJzIGZvciB0aGVzZSBhY3Rpb25zIGlzIGV4cG9ydGVkIGFzIGBjb21iaW5lZFVwZGF0ZXJzYC4gVGhlc2UgdXBkYXRlciB0YWtlIHRoZSBlbnRpcmUgaW5zdGFuY2Ugc3RhdGVcbiAqIGFzIHRoZSBmaXJzdCBhcmd1bWVudC4gUmVhZCBtb3JlIGFib3V0IFtVc2luZyB1cGRhdGVyc10oLi4vYWR2YW5jZWQtdXNhZ2UvdXNpbmctdXBkYXRlcnMubWQpXG4gKiBAcHVibGljXG4gKiBAZXhhbXBsZVxuICpcbiAqIGltcG9ydCBrZXBsZXJHbFJlZHVjZXIsIHtjb21iaW5lZFVwZGF0ZXJzfSBmcm9tICdrZXBsZXIuZ2wvcmVkdWNlcnMnO1xuICogLy8gUm9vdCBSZWR1Y2VyXG4gKiBjb25zdCByZWR1Y2VycyA9IGNvbWJpbmVSZWR1Y2Vycyh7XG4gKiAga2VwbGVyR2w6IGtlcGxlckdsUmVkdWNlcixcbiAqICBhcHA6IGFwcFJlZHVjZXJcbiAqIH0pO1xuICpcbiAqIGNvbnN0IGNvbXBvc2VkUmVkdWNlciA9IChzdGF0ZSwgYWN0aW9uKSA9PiB7XG4gKiAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICogICAgLy8gYWRkIGRhdGEgdG8gbWFwIGFmdGVyIHJlY2VpdmluZyBkYXRhIGZyb20gcmVtb3RlIHNvdXJjZXNcbiAqICAgIGNhc2UgJ0xPQURfUkVNT1RFX1JFU09VUkNFX1NVQ0NFU1MnOlxuICogICAgICByZXR1cm4ge1xuICogICAgICAgIC4uLnN0YXRlLFxuICogICAgICAgIGtlcGxlckdsOiB7XG4gKiAgICAgICAgICAuLi5zdGF0ZS5rZXBsZXJHbCxcbiAqICAgICAgICAgIC8vIHBhc3MgaW4ga2VwbGVyLmdsIGluc3RhbmNlIHN0YXRlIHRvIGNvbWJpbmVkVXBkYXRlcnNcbiAqICAgICAgICAgIG1hcDogIGNvbWJpbmVkVXBkYXRlcnMuYWRkRGF0YVRvTWFwVXBkYXRlcihcbiAqICAgICAgICAgICBzdGF0ZS5rZXBsZXJHbC5tYXAsXG4gKiAgICAgICAgICAge1xuICogICAgICAgICAgICAgcGF5bG9hZDoge1xuICogICAgICAgICAgICAgICBkYXRhc2V0czogYWN0aW9uLmRhdGFzZXRzLFxuICogICAgICAgICAgICAgICBvcHRpb25zOiB7cmVhZE9ubHk6IHRydWV9LFxuICogICAgICAgICAgICAgICBjb25maWc6IGFjdGlvbi5jb25maWdcbiAqICAgICAgICAgICAgICB9XG4gKiAgICAgICAgICAgIH1cbiAqICAgICAgICAgIClcbiAqICAgICAgICB9XG4gKiAgICAgIH07XG4gKiAgfVxuICogIHJldHVybiByZWR1Y2VycyhzdGF0ZSwgYWN0aW9uKTtcbiAqIH07XG4gKlxuICogZXhwb3J0IGRlZmF1bHQgY29tcG9zZWRSZWR1Y2VyO1xuICovXG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG4vLyBAdHMtaWdub3JlXG5jb25zdCBjb21iaW5lZFVwZGF0ZXJzID0gbnVsbDtcbi8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLXZhcnMgKi9cblxuZXhwb3J0IGNvbnN0IGlzVmFsaWRDb25maWcgPSBjb25maWcgPT5cbiAgaXNQbGFpbk9iamVjdChjb25maWcpICYmIGlzUGxhaW5PYmplY3QoY29uZmlnLmNvbmZpZykgJiYgY29uZmlnLnZlcnNpb247XG5cbmV4cG9ydCBjb25zdCBkZWZhdWx0QWRkRGF0YVRvTWFwT3B0aW9ucyA9IHtcbiAgY2VudGVyTWFwOiB0cnVlLFxuICBrZWVwRXhpc3RpbmdDb25maWc6IGZhbHNlLFxuICBhdXRvQ3JlYXRlTGF5ZXJzOiB0cnVlXG59O1xuXG4vKipcbiAqIENvbWJpbmUgZGF0YSBhbmQgZnVsbCBjb25maWd1cmF0aW9uIHVwZGF0ZSBpbiBhIHNpbmdsZSBhY3Rpb25cbiAqXG4gKiBAbWVtYmVyb2YgY29tYmluZWRVcGRhdGVyc1xuICogQHBhcmFtIHtPYmplY3R9IHN0YXRlIGtlcGxlci5nbCBpbnN0YW5jZSBzdGF0ZSwgY29udGFpbmluZyBhbGwgc3VicmVkdWNlciBzdGF0ZVxuICogQHBhcmFtIHtPYmplY3R9IGFjdGlvblxuICogQHBhcmFtIHtPYmplY3R9IGFjdGlvbi5wYXlsb2FkIGB7ZGF0YXNldHMsIG9wdGlvbnMsIGNvbmZpZ31gXG4gKiBAcGFyYW0gYWN0aW9uLnBheWxvYWQuZGF0YXNldHMgLSAqKipyZXF1aXJlZCoqIGRhdGFzZXRzIGNhbiBiZSBhIGRhdGFzZXQgb3IgYW4gYXJyYXkgb2YgZGF0YXNldHNcbiAqIEVhY2ggZGF0YXNldCBvYmplY3QgbmVlZHMgdG8gaGF2ZSBgaW5mb2AgYW5kIGBkYXRhYCBwcm9wZXJ0eS5cbiAqIEBwYXJhbSBbYWN0aW9uLnBheWxvYWQub3B0aW9uc10gb3B0aW9uIG9iamVjdCBge2NlbnRlck1hcDogdHJ1ZX1gXG4gKiBAcGFyYW0gW2FjdGlvbi5wYXlsb2FkLmNvbmZpZ10gbWFwIGNvbmZpZ1xuICogQHBhcmFtIFthY3Rpb24ucGF5bG9hZC5pbmZvXSBtYXAgaW5mbyBjb250YWlucyB0aXRsZSBhbmQgZGVzY3JpcHRpb25cbiAqIEByZXR1cm5zIG5leHRTdGF0ZVxuICpcbiAqIEB0eXBlZGVmIHtPYmplY3R9IERhdGFzZXRcbiAqIEBwcm9wZXJ0eSBpbmZvIC1pbmZvIG9mIGEgZGF0YXNldFxuICogQHByb3BlcnR5IGluZm8uaWQgLSBpZCBvZiB0aGlzIGRhdGFzZXQuIElmIGNvbmZpZyBpcyBkZWZpbmVkLCBgaWRgIHNob3VsZCBtYXRjaGVzIHRoZSBgZGF0YUlkYCBpbiBjb25maWcuXG4gKiBAcHJvcGVydHkgaW5mby5sYWJlbCAtIEEgZGlzcGxheSBuYW1lIG9mIHRoaXMgZGF0YXNldFxuICogQHByb3BlcnR5IGRhdGEgLSAqKipyZXF1aXJlZCoqIFRoZSBkYXRhIG9iamVjdCwgaW4gYSB0YWJ1bGFyIGZvcm1hdCB3aXRoIDIgcHJvcGVydGllcyBgZmllbGRzYCBhbmQgYHJvd3NgXG4gKiBAcHJvcGVydHkgZGF0YS5maWVsZHMgLSAqKipyZXF1aXJlZCoqIEFycmF5IG9mIGZpZWxkcyxcbiAqIEBwcm9wZXJ0eSBkYXRhLmZpZWxkcy5uYW1lIC0gKioqcmVxdWlyZWQqKiBOYW1lIG9mIHRoZSBmaWVsZCxcbiAqIEBwcm9wZXJ0eSBkYXRhLnJvd3MgLSAqKipyZXF1aXJlZCoqIEFycmF5IG9mIHJvd3MsIGluIGEgdGFidWxhciBmb3JtYXQgd2l0aCBgZmllbGRzYCBhbmQgYHJvd3NgXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgYWRkRGF0YVRvTWFwVXBkYXRlciA9IChcbiAgc3RhdGU6IEtlcGxlckdsU3RhdGUsXG4gIHtwYXlsb2FkfToge3BheWxvYWQ6IEFkZERhdGFUb01hcFBheWxvYWR9XG4pOiBLZXBsZXJHbFN0YXRlID0+IHtcbiAgY29uc3Qge2RhdGFzZXRzLCBjb25maWcsIGluZm99ID0gcGF5bG9hZDtcblxuICBjb25zdCBvcHRpb25zID0ge1xuICAgIC4uLmRlZmF1bHRBZGREYXRhVG9NYXBPcHRpb25zLFxuICAgIC4uLnBheWxvYWQub3B0aW9uc1xuICB9O1xuXG4gIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgbGV0IHBhcnNlZENvbmZpZzogUGFyc2VkQ29uZmlnID0gY29uZmlnO1xuXG4gIGlmIChpc1ZhbGlkQ29uZmlnKGNvbmZpZykpIHtcbiAgICAvLyBpZiBwYXNzZWQgaW4gc2F2ZWQgY29uZmlnXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgIHBhcnNlZENvbmZpZyA9IHN0YXRlLnZpc1N0YXRlLnNjaGVtYS5wYXJzZVNhdmVkQ29uZmlnKGNvbmZpZyk7XG4gIH1cbiAgY29uc3Qgb2xkTGF5ZXJzID0gc3RhdGUudmlzU3RhdGUubGF5ZXJzO1xuICBjb25zdCBmaWx0ZXJOZXdseUFkZGVkTGF5ZXJzID0gKGxheWVyczogTGF5ZXJbXSkgPT5cbiAgICBsYXllcnMuZmlsdGVyKG5sID0+ICFvbGRMYXllcnMuZmluZChvbCA9PiBvbCA9PT0gbmwpKTtcblxuICAvLyBSZXR1cm5zIHVuZGVmaW5lZCBpZiBub3QgZm91bmQsIHRvIG1ha2UgdHlwZXNjcmlwdCBoYXBweVxuICBjb25zdCBmaW5kTWFwQm91bmRzSWZDZW50ZXJlZCA9IChsYXllcnM6IExheWVyW10pID0+IHtcbiAgICBjb25zdCBib3VuZHMgPSBvcHRpb25zLmNlbnRlck1hcCAmJiBmaW5kTWFwQm91bmRzKGxheWVycyk7XG4gICAgcmV0dXJuIGJvdW5kcyA/IGJvdW5kcyA6IHVuZGVmaW5lZDtcbiAgfTtcblxuICByZXR1cm4gY29tcG9zZV88S2VwbGVyR2xTdGF0ZT4oW1xuICAgIHBpY2tfKCd2aXNTdGF0ZScpKFxuICAgICAgYXBwbHlfPFZpc1N0YXRlLCBhbnk+KHZpc1N0YXRlVXBkYXRlVmlzRGF0YVVwZGF0ZXIsIHtcbiAgICAgICAgZGF0YXNldHMsXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICAgIGNvbmZpZzogcGFyc2VkQ29uZmlnXG4gICAgICB9KVxuICAgICksXG5cbiAgICBpZl8oXG4gICAgICBCb29sZWFuKGluZm8pLFxuICAgICAgcGlja18oJ3Zpc1N0YXRlJykoXG4gICAgICAgIGFwcGx5XzxWaXNTdGF0ZSwgYW55PihzZXRNYXBJbmZvVXBkYXRlciwge2luZm99KVxuICAgICAgKVxuICAgICksXG5cbiAgICB3aXRoXygoe3Zpc1N0YXRlfSkgPT5cbiAgICAgIHBpY2tfKCdtYXBTdGF0ZScpKFxuICAgICAgICBhcHBseV8oXG4gICAgICAgICAgc3RhdGVNYXBDb25maWdVcGRhdGVyLFxuICAgICAgICAgIHBheWxvYWRfKHtcbiAgICAgICAgICAgIGNvbmZpZzogcGFyc2VkQ29uZmlnLFxuICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgIGJvdW5kczogZmluZE1hcEJvdW5kc0lmQ2VudGVyZWQoZmlsdGVyTmV3bHlBZGRlZExheWVycyh2aXNTdGF0ZS5sYXllcnMpKVxuICAgICAgICAgIH0pXG4gICAgICAgIClcbiAgICAgIClcbiAgICApLFxuICAgIHBpY2tfKCdtYXBTdHlsZScpKGFwcGx5XyhzdHlsZU1hcENvbmZpZ1VwZGF0ZXIsIHBheWxvYWRfKHtjb25maWc6IHBhcnNlZENvbmZpZywgb3B0aW9uc30pKSksXG4gICAgcGlja18oJ3VpU3RhdGUnKShhcHBseV8odWlTdGF0ZUxvYWRGaWxlc1N1Y2Nlc3NVcGRhdGVyLCBwYXlsb2FkXyhudWxsKSkpLFxuICAgIHBpY2tfKCd1aVN0YXRlJykoYXBwbHlfKHRvZ2dsZU1vZGFsVXBkYXRlciwgcGF5bG9hZF8obnVsbCkpKSxcbiAgICBwaWNrXygndWlTdGF0ZScpKG1lcmdlXyhvcHRpb25zLmhhc093blByb3BlcnR5KCdyZWFkT25seScpID8ge3JlYWRPbmx5OiBvcHRpb25zLnJlYWRPbmx5fSA6IHt9KSlcbiAgXSkoc3RhdGUpO1xufTtcblxuZXhwb3J0IGNvbnN0IGxvYWRGaWxlc1N1Y2Nlc3NVcGRhdGVyID0gKFxuICBzdGF0ZTogS2VwbGVyR2xTdGF0ZSxcbiAgYWN0aW9uOiBsb2FkRmlsZXNTdWNjZXNzVXBkYXRlckFjdGlvblxuKTogS2VwbGVyR2xTdGF0ZSA9PiB7XG4gIC8vIHN0aWxsIG1vcmUgdG8gbG9hZFxuICBjb25zdCBwYXlsb2FkcyA9IGZpbGVzVG9EYXRhUGF5bG9hZChhY3Rpb24ucmVzdWx0KTtcbiAgY29uc3QgbmV4dFN0YXRlID0gY29tcG9zZV8oW1xuICAgIHBpY2tfKCd2aXNTdGF0ZScpKFxuICAgICAgbWVyZ2VfKHtcbiAgICAgICAgZmlsZUxvYWRpbmc6IGZhbHNlLFxuICAgICAgICBmaWxlTG9hZGluZ1Byb2dyZXNzOiB7fVxuICAgICAgfSlcbiAgICApXG4gIF0pKHN0YXRlKTtcbiAgLy8gbWFrZSBtdWx0aXBsZSBhZGQgZGF0YSB0byBtYXAgY2FsbHNcbiAgY29uc3Qgc3RhdGVXaXRoRGF0YSA9IGNvbXBvc2VfKHBheWxvYWRzLm1hcChwID0+IGFwcGx5XyhhZGREYXRhVG9NYXBVcGRhdGVyLCBwYXlsb2FkXyhwKSkpKShcbiAgICBuZXh0U3RhdGVcbiAgKTtcbiAgcmV0dXJuIHN0YXRlV2l0aERhdGEgYXMgS2VwbGVyR2xTdGF0ZTtcbn07XG5cbmV4cG9ydCBjb25zdCBhZGREYXRhVG9NYXBDb21wb3NlZCA9IGFkZERhdGFUb01hcFVwZGF0ZXI7XG4iXX0=