// Copyright (c) 2022 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof = require("@babel/runtime/helpers/typeof");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.updateStateWithLayerAndData = updateStateWithLayerAndData;
exports.updateStateOnLayerVisibilityChange = updateStateOnLayerVisibilityChange;
exports.layerConfigChangeUpdater = layerConfigChangeUpdater;
exports.layerTextLabelChangeUpdater = layerTextLabelChangeUpdater;
exports.layerDataIdChangeUpdater = layerDataIdChangeUpdater;
exports.layerTypeChangeUpdater = layerTypeChangeUpdater;
exports.layerVisualChannelChangeUpdater = layerVisualChannelChangeUpdater;
exports.layerVisConfigChangeUpdater = layerVisConfigChangeUpdater;
exports.setFilterAnimationTimeUpdater = setFilterAnimationTimeUpdater;
exports.setFilterAnimationWindowUpdater = setFilterAnimationWindowUpdater;
exports.setFilterUpdater = setFilterUpdater;
exports.interactionConfigChangeUpdater = interactionConfigChangeUpdater;
exports.renameDatasetUpdater = renameDatasetUpdater;
exports.closeSpecificMapAtIndex = closeSpecificMapAtIndex;
exports.loadFileStepSuccessUpdater = loadFileStepSuccessUpdater;
exports.loadNextFileUpdater = loadNextFileUpdater;
exports.makeLoadFileTask = makeLoadFileTask;
exports.processFileContentUpdater = processFileContentUpdater;
exports.parseProgress = parseProgress;
exports.addDefaultLayers = addDefaultLayers;
exports.addDefaultTooltips = addDefaultTooltips;
exports.initialFileLoadingProgress = initialFileLoadingProgress;
exports.updateFileLoadingProgressUpdater = updateFileLoadingProgressUpdater;
exports.updateAllLayerDomainData = updateAllLayerDomainData;
exports.updateAnimationDomain = updateAnimationDomain;
exports.setFeaturesUpdater = setFeaturesUpdater;
exports.deleteFeatureUpdater = deleteFeatureUpdater;
exports.setPolygonFilterLayerUpdater = setPolygonFilterLayerUpdater;
exports.sortTableColumnUpdater = sortTableColumnUpdater;
exports.pinTableColumnUpdater = pinTableColumnUpdater;
exports.copyTableColumnUpdater = copyTableColumnUpdater;
exports.toggleEditorVisibilityUpdater = toggleEditorVisibilityUpdater;
exports.setFilterAnimationTimeConfigUpdater = setFilterAnimationTimeConfigUpdater;
exports.setLayerAnimationTimeConfigUpdater = setLayerAnimationTimeConfigUpdater;
exports.setSelectedFeatureUpdater = exports.setEditorModeUpdater = exports.setMapInfoUpdater = exports.applyCPUFilterUpdater = exports.loadFilesErrUpdater = exports.nextFileBatchUpdater = exports.loadFilesUpdater = exports.updateVisDataUpdater = exports.toggleLayerForMapUpdater = exports.toggleSplitMapUpdater = exports.mouseMoveUpdater = exports.mapClickUpdater = exports.layerClickUpdater = exports.layerHoverUpdater = exports.receiveMapConfigUpdater = exports.resetMapConfigUpdater = exports.updateTableColorUpdater = exports.showDatasetTableUpdater = exports.updateLayerBlendingUpdater = exports.removeDatasetUpdater = exports.reorderLayerUpdater = exports.duplicateLayerUpdater = exports.removeLayerUpdater = exports.addLayerUpdater = exports.removeFilterUpdater = exports.toggleFilterFeatureUpdater = exports.enlargeFilterUpdater = exports.updateLayerAnimationSpeedUpdater = exports.setLayerAnimationTimeUpdater = exports.updateFilterAnimationSpeedUpdater = exports.toggleLayerAnimationControlUpdater = exports.toggleLayerAnimationUpdater = exports.toggleFilterAnimationUpdater = exports.layerColorUIChangeUpdater = exports.addFilterUpdater = exports.setFilterPlotUpdater = exports.INITIAL_VIS_STATE = exports.DEFAULT_EDITOR = exports.DEFAULT_ANIMATION_CONFIG = exports.defaultInteractionConfig = void 0;

var _toArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toArray"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _window = require("global/window");

var _tasks = require("react-palm/tasks");

var _lodash = _interopRequireDefault(require("lodash.clonedeep"));

var _lodash2 = _interopRequireDefault(require("lodash.uniq"));

var _lodash3 = _interopRequireDefault(require("lodash.get"));

var _lodash4 = _interopRequireDefault(require("lodash.xor"));

var _copyToClipboard = _interopRequireDefault(require("copy-to-clipboard"));

var _tasks2 = require("@kepler.gl/tasks");

var _actions = require("@kepler.gl/actions");

var _utils = require("@kepler.gl/utils");

var _visStateMerger = require("./vis-state-merger");

var _layers = require("@kepler.gl/layers");

var _constants = require("@kepler.gl/constants");

var _composerHelpers = require("./composer-helpers");

var _schemas = _interopRequireDefault(require("@kepler.gl/schemas"));

var _layerUtils = require("./layer-utils");

var _table = require("@kepler.gl/table");

var _interactionUtils = require("./interaction-utils");

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }

function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

// react-palm
// disable capture exception for react-palm call to withTask
(0, _tasks.disableStackCapturing)();
/**
 * Updaters for `visState` reducer. Can be used in your root reducer to directly modify kepler.gl's state.
 * Read more about [Using updaters](../advanced-usage/using-updaters.md)
 *
 * @public
 * @example
 *
 * import keplerGlReducer, {visStateUpdaters} from 'kepler.gl/reducers';
 * // Root Reducer
 * const reducers = combineReducers({
 *  keplerGl: keplerGlReducer,
 *  app: appReducer
 * });
 *
 * const composedReducer = (state, action) => {
 *  switch (action.type) {
 *    case 'CLICK_BUTTON':
 *      return {
 *        ...state,
 *        keplerGl: {
 *          ...state.keplerGl,
 *          foo: {
 *             ...state.keplerGl.foo,
 *             visState: visStateUpdaters.enlargeFilterUpdater(
 *               state.keplerGl.foo.visState,
 *               {idx: 0}
 *             )
 *          }
 *        }
 *      };
 *  }
 *  return reducers(state, action);
 * };
 *
 * export default composedReducer;
 */

/* eslint-disable no-unused-vars */
// @ts-ignore

var visStateUpdaters = null;
/* eslint-enable no-unused-vars */

var defaultInteractionConfig = {
  tooltip: {
    id: 'tooltip',
    label: 'interactions.tooltip',
    enabled: true,
    config: {
      fieldsToShow: {},
      compareMode: false,
      compareType: _constants.COMPARE_TYPES.ABSOLUTE
    }
  },
  geocoder: {
    id: 'geocoder',
    label: 'interactions.geocoder',
    enabled: false,
    position: null
  },
  brush: {
    id: 'brush',
    label: 'interactions.brush',
    enabled: false,
    config: {
      // size is in km
      size: 0.5
    }
  },
  coordinate: {
    id: 'coordinate',
    label: 'interactions.coordinate',
    enabled: false,
    position: null
  }
};
exports.defaultInteractionConfig = defaultInteractionConfig;
var DEFAULT_ANIMATION_CONFIG = {
  domain: null,
  currentTime: null,
  speed: 1,
  isAnimating: false,
  timeFormat: null,
  timezone: null,
  defaultTimeFormat: null
};
exports.DEFAULT_ANIMATION_CONFIG = DEFAULT_ANIMATION_CONFIG;
var DEFAULT_EDITOR = {
  mode: _constants.EDITOR_MODES.DRAW_POLYGON,
  features: [],
  selectedFeature: null,
  visible: true
};
/**
 * Default initial `visState`
 * @memberof visStateUpdaters
 * @constant
 * @public
 */

exports.DEFAULT_EDITOR = DEFAULT_EDITOR;
var INITIAL_VIS_STATE = {
  // map info
  mapInfo: {
    title: '',
    description: ''
  },
  // layers
  layers: [],
  layerData: [],
  layerToBeMerged: [],
  layerOrder: [],
  // filters
  filters: [],
  filterToBeMerged: [],
  // a collection of multiple dataset
  datasets: {},
  editingDataset: undefined,
  interactionConfig: defaultInteractionConfig,
  interactionToBeMerged: undefined,
  layerBlending: 'normal',
  hoverInfo: undefined,
  clicked: undefined,
  mousePos: {},
  maxDefaultTooltips: _constants.MAX_DEFAULT_TOOLTIPS,
  // this is used when user split maps
  splitMaps: [// this will contain a list of objects to
    // describe the state of layer availability and visibility for each map
    // [
    //   {
    //      layers: {layer_id: true | false}
    //   }
    // ]
  ],
  splitMapsToBeMerged: [],
  // defaults layer classes
  layerClasses: _layers.LayerClasses,
  // default animation
  // time in unix timestamp (milliseconds) (the number of seconds since the Unix Epoch)
  animationConfig: DEFAULT_ANIMATION_CONFIG,
  editor: DEFAULT_EDITOR,
  fileLoading: false,
  fileLoadingProgress: {},
  loaders: [],
  loadOptions: {},
  // visStateMergers
  mergers: _visStateMerger.VIS_STATE_MERGERS,
  // kepler schemas
  schema: _schemas["default"]
};
/**
 * Update state with updated layer and layerData
 *
 */

exports.INITIAL_VIS_STATE = INITIAL_VIS_STATE;

function updateStateWithLayerAndData(state, _ref) {
  var layerData = _ref.layerData,
      layer = _ref.layer,
      idx = _ref.idx;
  return _objectSpread(_objectSpread({}, state), {}, {
    layers: state.layers.map(function (lyr, i) {
      return i === idx ? layer : lyr;
    }),
    layerData: layerData ? state.layerData.map(function (d, i) {
      return i === idx ? layerData : d;
    }) : state.layerData
  });
}

function updateStateOnLayerVisibilityChange(state, layer) {
  var newState = state;

  if (state.splitMaps.length) {
    newState = _objectSpread(_objectSpread({}, state), {}, {
      splitMaps: layer.config.isVisible ? (0, _utils.addNewLayersToSplitMap)(state.splitMaps, layer) : (0, _utils.removeLayerFromSplitMaps)(state.splitMaps, layer)
    });
  }

  if (layer.config.animation.enabled) {
    newState = updateAnimationDomain(state);
  }

  return newState;
}
/**
 * Update layer base config: dataId, label, column, isVisible
 * @memberof visStateUpdaters
 * @returns nextState
 */


function layerConfigChangeUpdater(state, action) {
  var oldLayer = action.oldLayer;
  var idx = state.layers.findIndex(function (l) {
    return l.id === oldLayer.id;
  });
  var props = Object.keys(action.newConfig);

  if (typeof action.newConfig.dataId === 'string') {
    var _action$newConfig = action.newConfig,
        dataId = _action$newConfig.dataId,
        restConfig = (0, _objectWithoutProperties2["default"])(_action$newConfig, ["dataId"]);
    var stateWithDataId = layerDataIdChangeUpdater(state, {
      oldLayer: oldLayer,
      newConfig: {
        dataId: dataId
      }
    });
    var nextLayer = stateWithDataId.layers.find(function (l) {
      return l.id === oldLayer.id;
    });
    return nextLayer && Object.keys(restConfig).length ? layerConfigChangeUpdater(stateWithDataId, {
      oldLayer: nextLayer,
      newConfig: restConfig
    }) : stateWithDataId;
  }

  var newLayer = oldLayer.updateLayerConfig(action.newConfig);
  var layerData; // let newLayer;

  if (newLayer.shouldCalculateLayerData(props)) {
    var oldLayerData = state.layerData[idx];
    var updateLayerDataResult = (0, _layerUtils.calculateLayerData)(newLayer, state, oldLayerData);
    layerData = updateLayerDataResult.layerData;
    newLayer = updateLayerDataResult.layer;
  }

  var newState = state;

  if ('isVisible' in action.newConfig) {
    newState = updateStateOnLayerVisibilityChange(state, newLayer);
  }

  return updateStateWithLayerAndData(newState, {
    layer: newLayer,
    layerData: layerData,
    idx: idx
  });
}

function addOrRemoveTextLabels(newFields, textLabel) {
  var newTextLabel = textLabel.slice();
  var currentFields = textLabel.map(function (tl) {
    return tl.field && tl.field.name;
  }).filter(function (d) {
    return d;
  });
  var addFields = newFields.filter(function (f) {
    return !currentFields.includes(f.name);
  });
  var deleteFields = currentFields.filter(function (f) {
    return !newFields.find(function (fd) {
      return fd.name === f;
    });
  }); // delete

  newTextLabel = newTextLabel.filter(function (tl) {
    return tl.field && !deleteFields.includes(tl.field.name);
  });
  newTextLabel = !newTextLabel.length ? [_constants.DEFAULT_TEXT_LABEL] : newTextLabel; // add

  newTextLabel = [].concat((0, _toConsumableArray2["default"])(newTextLabel.filter(function (tl) {
    return tl.field;
  })), (0, _toConsumableArray2["default"])(addFields.map(function (af) {
    return _objectSpread(_objectSpread({}, _constants.DEFAULT_TEXT_LABEL), {}, {
      field: af
    });
  })));
  return newTextLabel;
}

function updateTextLabelPropAndValue(idx, prop, value, textLabel) {
  if (!textLabel[idx].hasOwnProperty(prop)) {
    return textLabel;
  }

  var newTextLabel = textLabel.slice();

  if (prop && (value || textLabel.length === 1)) {
    newTextLabel = textLabel.map(function (tl, i) {
      return i === idx ? _objectSpread(_objectSpread({}, tl), {}, (0, _defineProperty2["default"])({}, prop, value)) : tl;
    });
  } else if (prop === 'field' && value === null && textLabel.length > 1) {
    // remove label when field value is set to null
    newTextLabel.splice(idx, 1);
  }

  return newTextLabel;
}
/**
 * Update layer base config: dataId, label, column, isVisible
 * @memberof visStateUpdaters
 * @returns nextState
 */


function layerTextLabelChangeUpdater(state, action) {
  var oldLayer = action.oldLayer,
      idx = action.idx,
      prop = action.prop,
      value = action.value;
  var textLabel = oldLayer.config.textLabel;
  var newTextLabel = textLabel.slice();

  if (!textLabel[idx] && idx === textLabel.length) {
    // if idx is set to length, add empty text label
    newTextLabel = [].concat((0, _toConsumableArray2["default"])(textLabel), [_constants.DEFAULT_TEXT_LABEL]);
  }

  if (idx === 'all' && prop === 'fields') {
    newTextLabel = addOrRemoveTextLabels(value, textLabel);
  } else {
    newTextLabel = updateTextLabelPropAndValue(idx, prop, value, newTextLabel);
  } // update text label prop and value


  return layerConfigChangeUpdater(state, {
    oldLayer: oldLayer,
    newConfig: {
      textLabel: newTextLabel
    }
  });
}

function validateExistingLayerWithData(dataset, layerClasses, layer) {
  var loadedLayer = (0, _visStateMerger.serializeLayer)(layer);
  return (0, _visStateMerger.validateLayerWithData)(dataset, loadedLayer, layerClasses, {
    allowEmptyColumn: true
  });
}
/**
 * Update layer config dataId
 * @memberof visStateUpdaters
 * @returns nextState
 */


function layerDataIdChangeUpdater(state, action) {
  var oldLayer = action.oldLayer,
      newConfig = action.newConfig;
  var dataId = newConfig.dataId;

  if (!oldLayer || !state.datasets[dataId]) {
    return state;
  }

  var idx = state.layers.findIndex(function (l) {
    return l.id === oldLayer.id;
  });
  var newLayer = oldLayer.updateLayerConfig({
    dataId: dataId
  }); // this may happen when a layer is new (type: null and no columns) but it's not ready to be saved

  if (newLayer.isValidToSave()) {
    var validated = validateExistingLayerWithData(state.datasets[dataId], state.layerClasses, newLayer); // if cant validate it with data create a new one

    if (!validated) {
      // @ts-expect-error TODO: checking oldLayer.type !== null
      newLayer = new state.layerClasses[oldLayer.type]({
        dataId: dataId,
        id: oldLayer.id
      });
    } else {
      newLayer = validated;
    }
  }

  newLayer = newLayer.updateLayerConfig({
    isVisible: oldLayer.config.isVisible,
    isConfigActive: true
  });
  newLayer.updateLayerDomain(state.datasets);

  var _calculateLayerData = (0, _layerUtils.calculateLayerData)(newLayer, state, undefined),
      layerData = _calculateLayerData.layerData,
      layer = _calculateLayerData.layer;

  return updateStateWithLayerAndData(state, {
    layerData: layerData,
    layer: layer,
    idx: idx
  });
}

function setInitialLayerConfig(layer, datasets, layerClasses) {
  var newLayer = layer;

  if (!Object.keys(datasets).length) {
    // no data is loaded
    return layer;
  }

  if (!layer.config.dataId) {
    // set layer dataId
    newLayer = layer.updateLayerConfig({
      dataId: Object.keys(datasets)[0]
    });
  }

  var dataset = datasets[newLayer.config.dataId];

  if (!dataset) {
    return layer;
  } // find defaut layer props


  var result = typeof layerClasses[newLayer.type].findDefaultLayerProps === 'function' ? layerClasses[newLayer.type].findDefaultLayerProps(dataset, []) : {
    props: []
  }; // an array of possible props, use 1st one

  var props = Array.isArray(result) ? result : result.props || [];

  if (props.length) {
    newLayer = new layerClasses[layer.type](_objectSpread(_objectSpread({}, props[0]), {}, {
      label: newLayer.config.label,
      dataId: newLayer.config.dataId,
      isVisible: true,
      isConfigActive: newLayer.config.isConfigActive
    }));
    return typeof newLayer.setInitialLayerConfig === 'function' ? newLayer.setInitialLayerConfig(dataset) : newLayer;
  }

  return newLayer;
}
/**
 * Update layer type. Previews layer config will be copied if applicable.
 * @memberof visStateUpdaters
 * @public
 */


function layerTypeChangeUpdater(state, action) {
  var oldLayer = action.oldLayer,
      newType = action.newType;

  if (!oldLayer) {
    return state;
  }

  var oldId = oldLayer.id;
  var idx = state.layers.findIndex(function (l) {
    return l.id === oldId;
  });

  if (!state.layerClasses[newType]) {
    _window.console.error("".concat(newType, " is not a valid layer type"));

    return state;
  }

  var newLayer = new state.layerClasses[newType]({
    // keep old layer lable and isConfigActive
    label: oldLayer.config.label,
    isConfigActive: oldLayer.config.isConfigActive
  });

  if (!oldLayer.type) {
    // if setting layer type on an empty layer
    newLayer = setInitialLayerConfig(newLayer, state.datasets, state.layerClasses);
  } else {
    // get a mint layer, with new id and type
    // because deck.gl uses id to match between new and old layer.
    // If type has changed but id is the same, it will break
    newLayer.assignConfigToLayer(oldLayer.config, oldLayer.visConfigSettings);
    newLayer.updateLayerDomain(state.datasets);
  }

  var clicked = state.clicked,
      hoverInfo = state.hoverInfo;

  var newState = _objectSpread(_objectSpread({}, state), {}, {
    clicked: oldLayer.isLayerHovered(clicked) ? undefined : clicked,
    hoverInfo: oldLayer.isLayerHovered(hoverInfo) ? undefined : hoverInfo
  });

  var _calculateLayerData2 = (0, _layerUtils.calculateLayerData)(newLayer, newState),
      layerData = _calculateLayerData2.layerData,
      layer = _calculateLayerData2.layer;

  newState = updateStateWithLayerAndData(newState, {
    layerData: layerData,
    layer: layer,
    idx: idx
  });

  if (layer.config.animation.enabled || oldLayer.config.animation.enabled) {
    newState = updateAnimationDomain(newState);
  } // update splitMap layer id


  if (state.splitMaps.length) {
    newState = _objectSpread(_objectSpread({}, newState), {}, {
      splitMaps: newState.splitMaps.map(function (settings) {
        var _settings$layers = settings.layers,
            oldLayerMap = _settings$layers[oldId],
            otherLayers = (0, _objectWithoutProperties2["default"])(_settings$layers, [oldId].map(_toPropertyKey));
        return oldId in settings.layers ? _objectSpread(_objectSpread({}, settings), {}, {
          layers: _objectSpread(_objectSpread({}, otherLayers), {}, (0, _defineProperty2["default"])({}, layer.id, oldLayerMap))
        }) : settings;
      })
    });
  }

  return newState;
}
/**
 * Update layer visual channel
 * @memberof visStateUpdaters
 * @returns {Object} nextState
 * @public
 */


function layerVisualChannelChangeUpdater(state, action) {
  var oldLayer = action.oldLayer,
      newConfig = action.newConfig,
      channel = action.channel;

  if (!oldLayer.config.dataId) {
    return state;
  }

  var dataset = state.datasets[oldLayer.config.dataId];
  var idx = state.layers.findIndex(function (l) {
    return l.id === oldLayer.id;
  });
  var newLayer = oldLayer.updateLayerConfig(newConfig);
  newLayer.updateLayerVisualChannel(dataset, channel);
  var oldLayerData = state.layerData[idx];

  var _calculateLayerData3 = (0, _layerUtils.calculateLayerData)(newLayer, state, oldLayerData),
      layerData = _calculateLayerData3.layerData,
      layer = _calculateLayerData3.layer;

  return updateStateWithLayerAndData(state, {
    layerData: layerData,
    layer: layer,
    idx: idx
  });
}
/**
 * Update layer `visConfig`
 * @memberof visStateUpdaters
 * @public
 */


function layerVisConfigChangeUpdater(state, action) {
  var oldLayer = action.oldLayer;
  var idx = state.layers.findIndex(function (l) {
    return l.id === oldLayer.id;
  });
  var props = Object.keys(action.newVisConfig);

  var newVisConfig = _objectSpread(_objectSpread({}, oldLayer.config.visConfig), action.newVisConfig);

  var newLayer = oldLayer.updateLayerConfig({
    visConfig: newVisConfig
  });

  if (newLayer.shouldCalculateLayerData(props)) {
    var oldLayerData = state.layerData[idx];

    var _calculateLayerData4 = (0, _layerUtils.calculateLayerData)(newLayer, state, oldLayerData),
        layerData = _calculateLayerData4.layerData,
        layer = _calculateLayerData4.layer;

    return updateStateWithLayerAndData(state, {
      layerData: layerData,
      layer: layer,
      idx: idx
    });
  }

  return updateStateWithLayerAndData(state, {
    layer: newLayer,
    idx: idx
  });
}
/**
 * Update filter property
 * @memberof visStateUpdaters
 * @public
 */


function setFilterAnimationTimeUpdater(state, action) {
  return setFilterUpdater(state, action);
}
/**
 * Update filter animation window
 * @memberof visStateUpdaters
 * @public
 */


function setFilterAnimationWindowUpdater(state, _ref2) {
  var id = _ref2.id,
      animationWindow = _ref2.animationWindow;
  return _objectSpread(_objectSpread({}, state), {}, {
    filters: state.filters.map(function (f) {
      return f.id === id ? _objectSpread(_objectSpread({}, f), {}, {
        animationWindow: animationWindow
      }) : f;
    })
  });
}
/**
 * Update filter property
 * @memberof visStateUpdaters
 * @public
 */


function setFilterUpdater(state, action) {
  var idx = action.idx,
      prop = action.prop,
      value = action.value,
      _action$valueIndex = action.valueIndex,
      valueIndex = _action$valueIndex === void 0 ? 0 : _action$valueIndex;
  var oldFilter = state.filters[idx];

  if (!oldFilter) {
    _window.console.error("filters.".concat(idx, " is undefined"));

    return state;
  }

  var newFilter = (0, _utils.set)([prop], value, oldFilter);
  var newState = state;
  var _newFilter = newFilter,
      dataId = _newFilter.dataId; // Ensuring backward compatibility

  var datasetIds = (0, _utils.toArray)(dataId);

  switch (prop) {
    // TODO: Next PR for UI if we update dataId, we need to consider two cases:
    // 1. dataId is empty: create a default filter
    // 2. Add a new dataset id
    case _utils.FILTER_UPDATER_PROPS.dataId:
      // if trying to update filter dataId. create an empty new filter
      newFilter = (0, _utils.updateFilterDataId)(dataId);
      break;

    case _utils.FILTER_UPDATER_PROPS.name:
      // we are supporting the current functionality
      // TODO: Next PR for UI filter name will only update filter name but it won't have side effects
      // we are gonna use pair of datasets and fieldIdx to update the filter
      var datasetId = newFilter.dataId[valueIndex];

      var _applyFilterFieldName = (0, _utils.applyFilterFieldName)(newFilter, state.datasets[datasetId], value, valueIndex, {
        mergeDomain: false
      }),
          updatedFilter = _applyFilterFieldName.filter,
          newDataset = _applyFilterFieldName.dataset;

      if (!updatedFilter) {
        return state;
      }

      newFilter = updatedFilter;

      if (newFilter.gpu) {
        newFilter = (0, _table.setFilterGpuMode)(newFilter, state.filters);
        newFilter = (0, _table.assignGpuChannel)(newFilter, state.filters);
      }

      newState = (0, _utils.set)(['datasets', datasetId], newDataset, state); // only filter the current dataset

      break;

    case _utils.FILTER_UPDATER_PROPS.layerId:
      // We need to update only datasetId/s if we have added/removed layers
      // - check for layerId changes (XOR works because of string values)
      // if no differences between layerIds, don't do any filtering
      // @ts-ignore
      var layerIdDifference = (0, _lodash4["default"])(newFilter.layerId, oldFilter.layerId);
      var layerDataIds = (0, _lodash2["default"])(layerIdDifference.map(function (lid) {
        return (0, _lodash3["default"])(state.layers.find(function (l) {
          return l.id === lid;
        }), ['config', 'dataId']);
      }).filter(function (d) {
        return d;
      })); // only filter datasetsIds

      datasetIds = layerDataIds; // Update newFilter dataIds

      var newDataIds = (0, _lodash2["default"])(newFilter.layerId.map(function (lid) {
        return (0, _lodash3["default"])(state.layers.find(function (l) {
          return l.id === lid;
        }), ['config', 'dataId']);
      }).filter(function (d) {
        return d;
      }));
      newFilter = _objectSpread(_objectSpread({}, newFilter), {}, {
        dataId: newDataIds
      });
      break;

    default:
      break;
  }

  var enlargedFilter = state.filters.find(function (f) {
    return f.enlarged;
  });

  if (enlargedFilter && enlargedFilter.id !== newFilter.id) {
    // there should be only one enlarged filter
    newFilter.enlarged = false;
  } // save new filters to newState


  newState = (0, _utils.set)(['filters', idx], newFilter, newState); // if we are currently setting a prop that only requires to filter the current
  // dataset we will pass only the current dataset to applyFiltersToDatasets and
  // updateAllLayerDomainData otherwise we pass the all list of datasets as defined in dataId

  var datasetIdsToFilter = _utils.LIMITED_FILTER_EFFECT_PROPS[prop] ? [datasetIds[valueIndex]] : datasetIds; // filter data

  var filteredDatasets = (0, _utils.applyFiltersToDatasets)(datasetIdsToFilter, newState.datasets, newState.filters, newState.layers);
  newState = (0, _utils.set)(['datasets'], filteredDatasets, newState); // dataId is an array
  // pass only the dataset we need to update

  newState = updateAllLayerDomainData(newState, datasetIdsToFilter, newFilter);
  return newState;
}
/**
 * Set the property of a filter plot
 * @memberof visStateUpdaters
 * @public
 */


var setFilterPlotUpdater = function setFilterPlotUpdater(state, _ref3) {
  var idx = _ref3.idx,
      newProp = _ref3.newProp,
      _ref3$valueIndex = _ref3.valueIndex,
      valueIndex = _ref3$valueIndex === void 0 ? 0 : _ref3$valueIndex;

  var newFilter = _objectSpread(_objectSpread({}, state.filters[idx]), newProp);

  var prop = Object.keys(newProp)[0];

  if (prop === 'yAxis') {
    var plotType = (0, _utils.getDefaultFilterPlotType)(newFilter); // TODO: plot is not supported in multi dataset filter for now

    if (plotType) {
      newFilter = _objectSpread(_objectSpread(_objectSpread({}, newFilter), (0, _utils.getFilterPlot)(_objectSpread(_objectSpread({}, newFilter), {}, {
        plotType: plotType
      }), state.datasets[newFilter.dataId[valueIndex]])), {}, {
        plotType: plotType
      });
    }
  }

  return _objectSpread(_objectSpread({}, state), {}, {
    filters: state.filters.map(function (f, i) {
      return i === idx ? newFilter : f;
    })
  });
};
/**
 * Add a new filter
 * @memberof visStateUpdaters
 * @public
 */


exports.setFilterPlotUpdater = setFilterPlotUpdater;

var addFilterUpdater = function addFilterUpdater(state, action) {
  return !action.dataId ? state : _objectSpread(_objectSpread({}, state), {}, {
    filters: [].concat((0, _toConsumableArray2["default"])(state.filters), [(0, _utils.getDefaultFilter)(action.dataId)])
  });
};
/**
 * Set layer color palette ui state
 * @memberof visStateUpdaters
 */


exports.addFilterUpdater = addFilterUpdater;

var layerColorUIChangeUpdater = function layerColorUIChangeUpdater(state, _ref4) {
  var oldLayer = _ref4.oldLayer,
      prop = _ref4.prop,
      newConfig = _ref4.newConfig;
  var oldVixConfig = oldLayer.config.visConfig[prop];
  var newLayer = oldLayer.updateLayerColorUI(prop, newConfig);
  var newVisConfig = newLayer.config.visConfig[prop];

  if (oldVixConfig !== newVisConfig) {
    return layerVisConfigChangeUpdater(state, {
      oldLayer: oldLayer,
      newVisConfig: (0, _defineProperty2["default"])({}, prop, newVisConfig)
    });
  }

  return _objectSpread(_objectSpread({}, state), {}, {
    layers: state.layers.map(function (l) {
      return l.id === oldLayer.id ? newLayer : l;
    })
  });
};
/**
 * Start and end filter animation
 * @memberof visStateUpdaters
 * @public
 */


exports.layerColorUIChangeUpdater = layerColorUIChangeUpdater;

var toggleFilterAnimationUpdater = function toggleFilterAnimationUpdater(state, action) {
  return _objectSpread(_objectSpread({}, state), {}, {
    filters: state.filters.map(function (f, i) {
      return i === action.idx ? _objectSpread(_objectSpread({}, f), {}, {
        isAnimating: !f.isAnimating
      }) : f;
    })
  });
};
/**
 * @memberof visStateUpdaters
 * @public
 */


exports.toggleFilterAnimationUpdater = toggleFilterAnimationUpdater;

var toggleLayerAnimationUpdater = function toggleLayerAnimationUpdater(state, action) {
  return _objectSpread(_objectSpread({}, state), {}, {
    animationConfig: _objectSpread(_objectSpread({}, state.animationConfig), {}, {
      isAnimating: !state.animationConfig.isAnimating
    })
  });
};
/**
 * Hide and show layer animation control
 * @memberof visStateUpdaters
 * @public
 */


exports.toggleLayerAnimationUpdater = toggleLayerAnimationUpdater;

var toggleLayerAnimationControlUpdater = function toggleLayerAnimationControlUpdater(state, action) {
  return _objectSpread(_objectSpread({}, state), {}, {
    animationConfig: _objectSpread(_objectSpread({}, state.animationConfig), {}, {
      hideControl: !state.animationConfig.hideControl
    })
  });
};
/**
 * Change filter animation speed
 * @memberof visStateUpdaters
 * @public
 */


exports.toggleLayerAnimationControlUpdater = toggleLayerAnimationControlUpdater;

var updateFilterAnimationSpeedUpdater = function updateFilterAnimationSpeedUpdater(state, action) {
  return _objectSpread(_objectSpread({}, state), {}, {
    filters: state.filters.map(function (f, i) {
      return i === action.idx ? _objectSpread(_objectSpread({}, f), {}, {
        speed: action.speed
      }) : f;
    })
  });
};
/**
 * Reset animation config current time to a specified value
 * @memberof visStateUpdaters
 * @public
 *
 */


exports.updateFilterAnimationSpeedUpdater = updateFilterAnimationSpeedUpdater;

var setLayerAnimationTimeUpdater = function setLayerAnimationTimeUpdater(state, _ref5) {
  var value = _ref5.value;
  return _objectSpread(_objectSpread({}, state), {}, {
    animationConfig: _objectSpread(_objectSpread({}, state.animationConfig), {}, {
      currentTime: value
    })
  });
};
/**
 * Update animation speed with the vertical speed slider
 * @memberof visStateUpdaters
 * @public
 *
 */


exports.setLayerAnimationTimeUpdater = setLayerAnimationTimeUpdater;

var updateLayerAnimationSpeedUpdater = function updateLayerAnimationSpeedUpdater(state, _ref6) {
  var speed = _ref6.speed;
  return _objectSpread(_objectSpread({}, state), {}, {
    animationConfig: _objectSpread(_objectSpread({}, state.animationConfig), {}, {
      speed: speed
    })
  });
};
/**
 * Show larger time filter at bottom for time playback (apply to time filter only)
 * @memberof visStateUpdaters
 * @public
 */


exports.updateLayerAnimationSpeedUpdater = updateLayerAnimationSpeedUpdater;

var enlargeFilterUpdater = function enlargeFilterUpdater(state, action) {
  return _objectSpread(_objectSpread({}, state), {}, {
    filters: state.filters.map(function (f, i) {
      return i === action.idx ? _objectSpread(_objectSpread({}, f), {}, {
        enlarged: !f.enlarged
      }) : f;
    })
  });
};
/**
 * Toggles filter feature visibility
 * @memberof visStateUpdaters
 */


exports.enlargeFilterUpdater = enlargeFilterUpdater;

var toggleFilterFeatureUpdater = function toggleFilterFeatureUpdater(state, action) {
  var filter = state.filters[action.idx];
  var isVisible = (0, _lodash3["default"])(filter, ['value', 'properties', 'isVisible']);

  var newFilter = _objectSpread(_objectSpread({}, filter), {}, {
    value: (0, _utils.featureToFilterValue)(filter.value, filter.id, {
      isVisible: !isVisible
    })
  });

  return _objectSpread(_objectSpread({}, state), {}, {
    filters: Object.assign((0, _toConsumableArray2["default"])(state.filters), (0, _defineProperty2["default"])({}, action.idx, newFilter))
  });
};
/**
 * Remove a filter
 * @memberof visStateUpdaters
 * @public
 */


exports.toggleFilterFeatureUpdater = toggleFilterFeatureUpdater;

var removeFilterUpdater = function removeFilterUpdater(state, action) {
  var idx = action.idx;
  var _state$filters$idx = state.filters[idx],
      dataId = _state$filters$idx.dataId,
      id = _state$filters$idx.id;
  var newFilters = [].concat((0, _toConsumableArray2["default"])(state.filters.slice(0, idx)), (0, _toConsumableArray2["default"])(state.filters.slice(idx + 1, state.filters.length)));
  var filteredDatasets = (0, _utils.applyFiltersToDatasets)(dataId, state.datasets, newFilters, state.layers);
  var newEditor = (0, _utils.getFilterIdInFeature)(state.editor.selectedFeature) === id ? _objectSpread(_objectSpread({}, state.editor), {}, {
    selectedFeature: null
  }) : state.editor;
  var newState = (0, _utils.set)(['filters'], newFilters, state);
  newState = (0, _utils.set)(['datasets'], filteredDatasets, newState);
  newState = (0, _utils.set)(['editor'], newEditor, newState);
  return updateAllLayerDomainData(newState, dataId, undefined);
};
/**
 * Add a new layer
 * @memberof visStateUpdaters
 * @public
 */


exports.removeFilterUpdater = removeFilterUpdater;

var addLayerUpdater = function addLayerUpdater(state, action) {
  var newLayer;
  var newLayerData;

  if (action.config) {
    newLayer = (0, _visStateMerger.createLayerFromConfig)(state, action.config);

    if (!newLayer) {
      _window.console.warn('Failed to create layer from config, it usually means the config is not be in correct format', action.config);

      return state;
    }

    var result = (0, _layerUtils.calculateLayerData)(newLayer, state);
    newLayer = result.layer;
    newLayerData = result.layerData;
  } else {
    var _action$datasetId;

    // create an empty layer with a specific dataset or a default one
    var defaultDataset = (_action$datasetId = action.datasetId) !== null && _action$datasetId !== void 0 ? _action$datasetId : Object.keys(state.datasets)[0];
    newLayer = new _layers.Layer({
      isVisible: true,
      isConfigActive: true,
      dataId: defaultDataset
    });
    newLayerData = {};
  }

  return _objectSpread(_objectSpread({}, state), {}, {
    layers: [].concat((0, _toConsumableArray2["default"])(state.layers), [newLayer]),
    layerData: [].concat((0, _toConsumableArray2["default"])(state.layerData), [newLayerData]),
    layerOrder: [].concat((0, _toConsumableArray2["default"])(state.layerOrder), [state.layerOrder.length]),
    splitMaps: (0, _utils.addNewLayersToSplitMap)(state.splitMaps, newLayer)
  });
};
/**
 * remove layer
 * @memberof visStateUpdaters
 * @public
 */


exports.addLayerUpdater = addLayerUpdater;

var removeLayerUpdater = function removeLayerUpdater(state, _ref7) {
  var idx = _ref7.idx;
  var layers = state.layers,
      layerData = state.layerData,
      clicked = state.clicked,
      hoverInfo = state.hoverInfo;
  var layerToRemove = state.layers[idx];
  var newMaps = (0, _utils.removeLayerFromSplitMaps)(state.splitMaps, layerToRemove);

  var newState = _objectSpread(_objectSpread({}, state), {}, {
    layers: [].concat((0, _toConsumableArray2["default"])(layers.slice(0, idx)), (0, _toConsumableArray2["default"])(layers.slice(idx + 1, layers.length))),
    layerData: [].concat((0, _toConsumableArray2["default"])(layerData.slice(0, idx)), (0, _toConsumableArray2["default"])(layerData.slice(idx + 1, layerData.length))),
    layerOrder: state.layerOrder.filter(function (i) {
      return i !== idx;
    }).map(function (pid) {
      return pid > idx ? pid - 1 : pid;
    }),
    clicked: layerToRemove.isLayerHovered(clicked) ? undefined : clicked,
    hoverInfo: layerToRemove.isLayerHovered(hoverInfo) ? undefined : hoverInfo,
    splitMaps: newMaps // TODO: update filters, create helper to remove layer form filter (remove layerid and dataid) if mapped

  });

  return updateAnimationDomain(newState);
};
/**
 * duplicate layer
 * @memberof visStateUpdaters
 * @public
 */


exports.removeLayerUpdater = removeLayerUpdater;

var duplicateLayerUpdater = function duplicateLayerUpdater(state, _ref8) {
  var idx = _ref8.idx;
  var layers = state.layers;
  var original = state.layers[idx];
  var originalLayerOrderIdx = state.layerOrder.findIndex(function (i) {
    return i === idx;
  });

  if (!original) {
    _window.console.warn("layer.".concat(idx, " is undefined"));

    return state;
  }

  var newLabel = "Copy of ".concat(original.config.label);
  var postfix = 0; // eslint-disable-next-line no-loop-func

  while (layers.find(function (l) {
    return l.config.label === newLabel;
  })) {
    newLabel = "Copy of ".concat(original.config.label, " ").concat(++postfix);
  } // collect layer config from original


  var loadedLayer = (0, _visStateMerger.serializeLayer)(original); // assign new id and label to copied layer

  if (!(loadedLayer !== null && loadedLayer !== void 0 && loadedLayer.config)) {
    return state;
  }

  loadedLayer.config.label = newLabel;
  loadedLayer.id = (0, _utils.generateHashId)(_layers.LAYER_ID_LENGTH); // add layer to state

  var nextState = addLayerUpdater(state, {
    config: loadedLayer
  }); // new added layer are at the end, move it to be on top of original layer

  var newLayerOrderIdx = nextState.layerOrder.length - 1;
  var newLayerOrder = (0, _utils.arrayInsert)(nextState.layerOrder.slice(0, newLayerOrderIdx), originalLayerOrderIdx, newLayerOrderIdx);
  nextState = _objectSpread(_objectSpread({}, nextState), {}, {
    layerOrder: newLayerOrder
  });
  return updateAnimationDomain(nextState);
};
/**
 * Reorder layer
 * @memberof visStateUpdaters
 * @public
 */


exports.duplicateLayerUpdater = duplicateLayerUpdater;

var reorderLayerUpdater = function reorderLayerUpdater(state, _ref9) {
  var order = _ref9.order;
  return _objectSpread(_objectSpread({}, state), {}, {
    layerOrder: order
  });
};
/**
 * Remove a dataset and all layers, filters, tooltip configs that based on it
 * @memberof visStateUpdaters
 * @public
 */


exports.reorderLayerUpdater = reorderLayerUpdater;

var removeDatasetUpdater = function removeDatasetUpdater(state, action) {
  // extract dataset key
  var datasetKey = action.dataId;
  var datasets = state.datasets; // check if dataset is present

  if (!datasets[datasetKey]) {
    return state;
  }
  /* eslint-disable no-unused-vars */


  var layers = state.layers,
      _state$datasets = state.datasets,
      dataset = _state$datasets[datasetKey],
      newDatasets = (0, _objectWithoutProperties2["default"])(_state$datasets, [datasetKey].map(_toPropertyKey));
  /* eslint-enable no-unused-vars */

  var indexes = layers.reduce(function (listOfIndexes, layer, index) {
    if (layer.config.dataId === datasetKey) {
      // @ts-ignore
      listOfIndexes.push(index);
    }

    return listOfIndexes;
  }, []); // remove layers and datasets

  var _indexes$reduce = indexes.reduce(function (_ref10, idx) {
    var currentState = _ref10.newState,
        indexCounter = _ref10.indexCounter;
    var currentIndex = idx - indexCounter;
    currentState = removeLayerUpdater(currentState, {
      idx: currentIndex
    });
    indexCounter++;
    return {
      newState: currentState,
      indexCounter: indexCounter
    };
  }, {
    newState: _objectSpread(_objectSpread({}, state), {}, {
      datasets: newDatasets
    }),
    indexCounter: 0
  }),
      newState = _indexes$reduce.newState; // remove filters


  var filters = state.filters.filter(function (filter) {
    return !filter.dataId.includes(datasetKey);
  }); // update interactionConfig

  var interactionConfig = state.interactionConfig;
  var _interactionConfig = interactionConfig,
      tooltip = _interactionConfig.tooltip;

  if (tooltip) {
    var config = tooltip.config;
    /* eslint-disable no-unused-vars */

    var _config$fieldsToShow = config.fieldsToShow,
        fields = _config$fieldsToShow[datasetKey],
        fieldsToShow = (0, _objectWithoutProperties2["default"])(_config$fieldsToShow, [datasetKey].map(_toPropertyKey));
    /* eslint-enable no-unused-vars */

    interactionConfig = _objectSpread(_objectSpread({}, interactionConfig), {}, {
      tooltip: _objectSpread(_objectSpread({}, tooltip), {}, {
        config: _objectSpread(_objectSpread({}, config), {}, {
          fieldsToShow: fieldsToShow
        })
      })
    });
  }

  return _objectSpread(_objectSpread({}, newState), {}, {
    filters: filters,
    interactionConfig: interactionConfig
  });
};
/**
 * update layer blending mode
 * @memberof visStateUpdaters
 * @public
 */


exports.removeDatasetUpdater = removeDatasetUpdater;

var updateLayerBlendingUpdater = function updateLayerBlendingUpdater(state, action) {
  return _objectSpread(_objectSpread({}, state), {}, {
    layerBlending: action.mode
  });
};
/**
 * Display dataset table in a modal
 * @memberof visStateUpdaters
 * @public
 */


exports.updateLayerBlendingUpdater = updateLayerBlendingUpdater;

var showDatasetTableUpdater = function showDatasetTableUpdater(state, action) {
  return _objectSpread(_objectSpread({}, state), {}, {
    editingDataset: action.dataId
  });
};
/**
 * Add custom color for datasets and layers
 * @memberof visStateUpdaters
 * @public
 */


exports.showDatasetTableUpdater = showDatasetTableUpdater;

var updateTableColorUpdater = function updateTableColorUpdater(state, action) {
  var dataId = action.dataId,
      newColor = action.newColor;
  var datasets = state.datasets;

  if ((0, _utils.isRgbColor)(newColor)) {
    var existing = datasets[dataId];
    existing.updateTableColor(newColor);
    return _objectSpread(_objectSpread({}, state), {}, {
      datasets: _objectSpread(_objectSpread({}, state.datasets), {}, (0, _defineProperty2["default"])({}, dataId, (0, _table.copyTableAndUpdate)(existing, {})))
    });
  }

  return state;
};
/**
 * reset visState to initial State
 * @memberof visStateUpdaters
 * @public
 */


exports.updateTableColorUpdater = updateTableColorUpdater;

var resetMapConfigUpdater = function resetMapConfigUpdater(state) {
  return _objectSpread(_objectSpread(_objectSpread({}, INITIAL_VIS_STATE), state.initialState), {}, {
    initialState: state.initialState
  });
};
/**
 * Propagate `visState` reducer with a new configuration. Current config will be override.
 * @memberof visStateUpdaters
 * @public
 */


exports.resetMapConfigUpdater = resetMapConfigUpdater;

var receiveMapConfigUpdater = function receiveMapConfigUpdater(state, _ref11) {
  var _ref11$payload = _ref11.payload,
      _ref11$payload$config = _ref11$payload.config,
      config = _ref11$payload$config === void 0 ? {
    version: ''
  } : _ref11$payload$config,
      _ref11$payload$option = _ref11$payload.options,
      options = _ref11$payload$option === void 0 ? {} : _ref11$payload$option;

  if (!config.visState) {
    return state;
  }

  var keepExistingConfig = options.keepExistingConfig; // reset config if keepExistingConfig is falsy

  var mergedState = !keepExistingConfig ? resetMapConfigUpdater(state) : state;

  var _iterator = _createForOfIteratorHelper(state.mergers),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var merger = _step.value;

      if ((0, _visStateMerger.isValidMerger)(merger) && config.visState[merger.prop]) {
        mergedState = merger.merge(mergedState, config.visState[merger.prop], true);
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  return mergedState;
};
/**
 * Trigger layer hover event with hovered object
 * @memberof visStateUpdaters
 * @public
 */


exports.receiveMapConfigUpdater = receiveMapConfigUpdater;

var layerHoverUpdater = function layerHoverUpdater(state, action) {
  return _objectSpread(_objectSpread({}, state), {}, {
    hoverInfo: _objectSpread({}, action.info)
  });
};
/* eslint-enable max-statements */

/**
 * Update `interactionConfig`
 * @memberof visStateUpdaters
 * @public
 */


exports.layerHoverUpdater = layerHoverUpdater;

function interactionConfigChangeUpdater(state, action) {
  var config = action.config;

  var interactionConfig = _objectSpread(_objectSpread({}, state.interactionConfig), (0, _defineProperty2["default"])({}, config.id, config)); // Don't enable tooltip and brush at the same time
  // but coordinates can be shown at all time


  var contradict = ['brush', 'tooltip'];

  if (contradict.includes(config.id) && config.enabled && !state.interactionConfig[config.id].enabled) {
    // only enable one interaction at a time
    contradict.forEach(function (k) {
      if (k !== config.id) {
        interactionConfig[k] = _objectSpread(_objectSpread({}, interactionConfig[k]), {}, {
          enabled: false
        });
      }
    });
  }

  var newState = _objectSpread(_objectSpread({}, state), {}, {
    interactionConfig: interactionConfig
  });

  if (config.id === 'geocoder' && !config.enabled) {
    return removeDatasetUpdater(newState, {
      dataId: 'geocoder_dataset'
    });
  }

  return newState;
}
/**
 * Trigger layer click event with clicked object
 * @memberof visStateUpdaters
 * @public
 */


var layerClickUpdater = function layerClickUpdater(state, action) {
  return _objectSpread(_objectSpread({}, state), {}, {
    mousePos: state.interactionConfig.coordinate.enabled ? _objectSpread(_objectSpread({}, state.mousePos), {}, {
      pinned: state.mousePos.pinned ? null : (0, _lodash["default"])(state.mousePos)
    }) : state.mousePos,
    clicked: action.info && action.info.picked ? action.info : null
  });
};
/**
 * Trigger map click event, unselect clicked object
 * @memberof visStateUpdaters
 * @public
 */


exports.layerClickUpdater = layerClickUpdater;

var mapClickUpdater = function mapClickUpdater(state, action) {
  return _objectSpread(_objectSpread({}, state), {}, {
    clicked: null
  });
};
/**
 * Trigger map move event
 * @memberof visStateUpdaters
 * @public
 */


exports.mapClickUpdater = mapClickUpdater;

var mouseMoveUpdater = function mouseMoveUpdater(state, _ref12) {
  var evt = _ref12.evt;

  if (Object.values(state.interactionConfig).some(function (config) {
    return config.enabled;
  })) {
    return _objectSpread(_objectSpread({}, state), {}, {
      mousePos: _objectSpread(_objectSpread(_objectSpread({}, state.mousePos), Array.isArray(evt.point) ? {
        mousePosition: (0, _toConsumableArray2["default"])(evt.point)
      } : {}), Array.isArray(evt.lngLat) ? {
        coordinate: (0, _toConsumableArray2["default"])(evt.lngLat)
      } : {})
    });
  }

  return state;
};
/**
 * Toggle visibility of a layer for a split map
 * @memberof visStateUpdaters
 * @public
 */


exports.mouseMoveUpdater = mouseMoveUpdater;

var toggleSplitMapUpdater = function toggleSplitMapUpdater(state, action) {
  return state.splitMaps && state.splitMaps.length === 0 ? _objectSpread(_objectSpread({}, state), {}, {
    // maybe we should use an array to store state for a single map as well
    // if current maps length is equal to 0 it means that we are about to split the view
    splitMaps: (0, _utils.computeSplitMapLayers)(state.layers)
  }) : closeSpecificMapAtIndex(state, action);
};
/**
 * Toggle visibility of a layer in a split map
 * @memberof visStateUpdaters
 * @public
 */


exports.toggleSplitMapUpdater = toggleSplitMapUpdater;

var toggleLayerForMapUpdater = function toggleLayerForMapUpdater(state, _ref13) {
  var mapIndex = _ref13.mapIndex,
      layerId = _ref13.layerId;
  var splitMaps = state.splitMaps;
  return _objectSpread(_objectSpread({}, state), {}, {
    splitMaps: splitMaps.map(function (sm, i) {
      return i === mapIndex ? _objectSpread(_objectSpread({}, splitMaps[i]), {}, {
        layers: _objectSpread(_objectSpread({}, splitMaps[i].layers), {}, (0, _defineProperty2["default"])({}, layerId, !splitMaps[i].layers[layerId]))
      }) : sm;
    })
  });
};
/**
 * Add new dataset to `visState`, with option to load a map config along with the datasets
 * @memberof visStateUpdaters
 * @public
 */

/* eslint-disable max-statements */
// eslint-disable-next-line complexity


exports.toggleLayerForMapUpdater = toggleLayerForMapUpdater;

var updateVisDataUpdater = function updateVisDataUpdater(state, action) {
  // datasets can be a single data entries or an array of multiple data entries
  var config = action.config,
      options = action.options;
  var datasets = (0, _utils.toArray)(action.datasets);
  var newDataEntries = datasets.reduce(function (accu) {
    var _ref14 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        _ref14$info = _ref14.info,
        info = _ref14$info === void 0 ? {} : _ref14$info,
        rest = (0, _objectWithoutProperties2["default"])(_ref14, ["info"]);

    return _objectSpread(_objectSpread({}, accu), (0, _table.createNewDataEntry)(_objectSpread({
      info: info
    }, rest), state.datasets) || {});
  }, {});
  var dataEmpty = Object.keys(newDataEntries).length < 1; // apply config if passed from action

  var previousState = config ? receiveMapConfigUpdater(state, {
    payload: {
      config: config,
      options: options
    }
  }) : state;

  var mergedState = _objectSpread(_objectSpread({}, previousState), {}, {
    datasets: _objectSpread(_objectSpread({}, previousState.datasets), newDataEntries)
  }); // merge state with config to be merged


  var _iterator2 = _createForOfIteratorHelper(mergedState.mergers),
      _step2;

  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var merger = _step2.value;

      if ((0, _visStateMerger.isValidMerger)(merger) && merger.toMergeProp && mergedState[merger.toMergeProp]) {
        var toMerge = mergedState[merger.toMergeProp];
        mergedState[merger.toMergeProp] = INITIAL_VIS_STATE[merger.toMergeProp];
        mergedState = merger.merge(mergedState, toMerge);
      }
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }

  var newLayers = !dataEmpty ? mergedState.layers.filter(function (l) {
    return l.config.dataId && l.config.dataId in newDataEntries;
  }) : [];

  if (!newLayers.length && (options || {}).autoCreateLayers !== false) {
    // no layer merged, find defaults
    var result = addDefaultLayers(mergedState, newDataEntries);
    mergedState = result.state;
    newLayers = result.newLayers;
  }

  if (mergedState.splitMaps.length) {
    // if map is split, add new layers to splitMaps
    newLayers = mergedState.layers.filter(function (l) {
      return l.config.dataId && l.config.dataId in newDataEntries;
    });
    mergedState = _objectSpread(_objectSpread({}, mergedState), {}, {
      splitMaps: (0, _utils.addNewLayersToSplitMap)(mergedState.splitMaps, newLayers)
    });
  } // if no tooltips merged add default tooltips


  Object.keys(newDataEntries).forEach(function (dataId) {
    var tooltipFields = mergedState.interactionConfig.tooltip.config.fieldsToShow[dataId];

    if (!Array.isArray(tooltipFields) || !tooltipFields.length) {
      mergedState = addDefaultTooltips(mergedState, newDataEntries[dataId]);
    }
  });
  var updatedState = updateAllLayerDomainData(mergedState, dataEmpty ? Object.keys(mergedState.datasets) : Object.keys(newDataEntries), undefined); // register layer animation domain,
  // need to be called after layer data is calculated

  updatedState = updateAnimationDomain(updatedState);
  return updatedState;
};
/* eslint-enable max-statements */

/**
 * Rename an existing dataset in `visState`
 * @memberof visStateUpdaters
 * @public
 */


exports.updateVisDataUpdater = updateVisDataUpdater;

function renameDatasetUpdater(state, action) {
  var dataId = action.dataId,
      label = action.label;
  var datasets = state.datasets;
  var existing = datasets[dataId];

  if (existing) {
    var newDataset = (0, _table.copyTableAndUpdate)(existing, {
      label: label
    });
    return _objectSpread(_objectSpread({}, state), {}, {
      datasets: _objectSpread(_objectSpread({}, datasets), {}, (0, _defineProperty2["default"])({}, dataId, newDataset))
    });
  } // No-op if the dataset doesn't exist


  return state;
}
/**
 * When a user clicks on the specific map closing icon
 * the application will close the selected map
 * and will merge the remaining one with the global state
 * TODO: i think in the future this action should be called merge map layers with global settings
 * @param {Object} state `visState`
 * @param {Object} action action
 * @returns {Object} nextState
 */


function closeSpecificMapAtIndex(state, action) {
  var _state$splitMaps$inde;

  // retrieve layers meta data from the remaining map that we need to keep
  var indexToRetrieve = 1 - action.payload;
  var mapLayers = (_state$splitMaps$inde = state.splitMaps[indexToRetrieve]) === null || _state$splitMaps$inde === void 0 ? void 0 : _state$splitMaps$inde.layers;
  var layers = state.layers; // update layer visibility

  var newLayers = layers.map(function (layer) {
    return mapLayers && !mapLayers[layer.id] && layer.config.isVisible ? layer.updateLayerConfig({
      // if layer.id is not in mapLayers, it should be inVisible
      isVisible: false
    }) : layer;
  }); // delete map

  return _objectSpread(_objectSpread({}, state), {}, {
    layers: newLayers,
    splitMaps: []
  });
}
/**
 * Trigger file loading dispatch `addDataToMap` if succeed, or `loadFilesErr` if failed
 * @memberof visStateUpdaters
 * @public
 */


var loadFilesUpdater = function loadFilesUpdater(state, action) {
  var files = action.files,
      _action$onFinish = action.onFinish,
      onFinish = _action$onFinish === void 0 ? _actions.loadFilesSuccess : _action$onFinish;

  if (!files.length) {
    return state;
  }

  var fileLoadingProgress = Array.from(files).reduce(function (accu, f, i) {
    return (0, _composerHelpers.merge_)(initialFileLoadingProgress(f, i))(accu);
  }, {});
  var fileLoading = {
    fileCache: [],
    filesToLoad: files,
    onFinish: onFinish
  };
  var nextState = (0, _composerHelpers.merge_)({
    fileLoadingProgress: fileLoadingProgress,
    fileLoading: fileLoading
  })(state);
  return loadNextFileUpdater(nextState);
};
/**
 * Sucessfully loaded one file, move on to the next one
 * @memberof visStateUpdaters
 * @public
 */


exports.loadFilesUpdater = loadFilesUpdater;

function loadFileStepSuccessUpdater(state, action) {
  if (!state.fileLoading) {
    return state;
  }

  var fileName = action.fileName,
      fileCache = action.fileCache;
  var _state$fileLoading = state.fileLoading,
      filesToLoad = _state$fileLoading.filesToLoad,
      onFinish = _state$fileLoading.onFinish;
  var stateWithProgress = updateFileLoadingProgressUpdater(state, {
    fileName: fileName,
    progress: {
      percent: 1,
      message: 'Done'
    }
  }); // save processed file to fileCache

  var stateWithCache = (0, _composerHelpers.pick_)('fileLoading')((0, _composerHelpers.merge_)({
    fileCache: fileCache
  }))(stateWithProgress);
  return (0, _tasks.withTask)(stateWithCache, (0, _tasks2.DELAY_TASK)(200).map(filesToLoad.length ? _actions.loadNextFile : function () {
    return onFinish(fileCache);
  }));
} // withTask<T>(state: T, task: any): T

/**
 *
 * @memberof visStateUpdaters
 * @public
 */


function loadNextFileUpdater(state) {
  if (!state.fileLoading) {
    return state;
  }

  var filesToLoad = state.fileLoading.filesToLoad;

  var _filesToLoad = (0, _toArray2["default"])(filesToLoad),
      file = _filesToLoad[0],
      remainingFilesToLoad = _filesToLoad.slice(1); // save filesToLoad to state


  var nextState = (0, _composerHelpers.pick_)('fileLoading')((0, _composerHelpers.merge_)({
    filesToLoad: remainingFilesToLoad
  }))(state);
  var stateWithProgress = updateFileLoadingProgressUpdater(nextState, {
    fileName: file.name,
    progress: {
      percent: 0,
      message: 'loading...'
    }
  });
  var loaders = state.loaders,
      loadOptions = state.loadOptions;
  return (0, _tasks.withTask)(stateWithProgress, makeLoadFileTask(file, nextState.fileLoading && nextState.fileLoading.fileCache, loaders, loadOptions));
}

function makeLoadFileTask(file, fileCache) {
  var loaders = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
  var loadOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  return (0, _tasks2.LOAD_FILE_TASK)({
    file: file,
    fileCache: fileCache,
    loaders: loaders,
    loadOptions: loadOptions
  }).bimap( // prettier ignore
  // success
  function (gen) {
    return (0, _actions.nextFileBatch)({
      gen: gen,
      fileName: file.name,
      onFinish: function onFinish(result) {
        return (0, _actions.processFileContent)({
          content: result,
          fileCache: fileCache
        });
      }
    });
  }, // error
  function (err) {
    return (0, _actions.loadFilesErr)(file.name, err);
  });
}
/**
 *
 * @memberof visStateUpdaters
 * @public
 */


function processFileContentUpdater(state, action) {
  var _action$payload = action.payload,
      content = _action$payload.content,
      fileCache = _action$payload.fileCache;
  var stateWithProgress = updateFileLoadingProgressUpdater(state, {
    fileName: content.fileName,
    progress: {
      percent: 1,
      message: 'processing...'
    }
  });
  return (0, _tasks.withTask)(stateWithProgress, (0, _tasks2.PROCESS_FILE_DATA)({
    content: content,
    fileCache: fileCache
  }).bimap(function (result) {
    return (0, _actions.loadFileStepSuccess)({
      fileName: content.fileName,
      fileCache: result
    });
  }, function (err) {
    return (0, _actions.loadFilesErr)(content.fileName, err);
  }));
}

function parseProgress() {
  var prevProgress = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var progress = arguments.length > 1 ? arguments[1] : undefined;

  // This happens when receiving query metadata or other cases we don't
  // have an update for the user.
  if (!progress || !progress.percent) {
    return {};
  }

  return {
    percent: progress.percent
  };
}
/**
 * gets called with payload = AsyncGenerator<???>
 * @memberof visStateUpdaters
 * @public
 */


var nextFileBatchUpdater = function nextFileBatchUpdater(state, _ref15) {
  var _ref15$payload = _ref15.payload,
      gen = _ref15$payload.gen,
      fileName = _ref15$payload.fileName,
      progress = _ref15$payload.progress,
      accumulated = _ref15$payload.accumulated,
      onFinish = _ref15$payload.onFinish;
  var stateWithProgress = updateFileLoadingProgressUpdater(state, {
    fileName: fileName,
    progress: parseProgress(state.fileLoadingProgress[fileName], progress)
  });
  return (0, _tasks.withTask)(stateWithProgress, (0, _tasks2.UNWRAP_TASK)(gen.next()).bimap(function (_ref16) {
    var value = _ref16.value,
        done = _ref16.done;
    return done ? onFinish(accumulated) : (0, _actions.nextFileBatch)({
      gen: gen,
      fileName: fileName,
      progress: value.progress,
      accumulated: value,
      onFinish: onFinish
    });
  }, function (err) {
    return (0, _actions.loadFilesErr)(fileName, err);
  }));
};
/**
 * Trigger loading file error
 * @memberof visStateUpdaters
 * @public
 */


exports.nextFileBatchUpdater = nextFileBatchUpdater;

var loadFilesErrUpdater = function loadFilesErrUpdater(state, _ref17) {
  var error = _ref17.error,
      fileName = _ref17.fileName;

  // update ui with error message
  _window.console.warn(error);

  if (!state.fileLoading) {
    return state;
  }

  var _state$fileLoading2 = state.fileLoading,
      filesToLoad = _state$fileLoading2.filesToLoad,
      onFinish = _state$fileLoading2.onFinish,
      fileCache = _state$fileLoading2.fileCache;
  var nextState = updateFileLoadingProgressUpdater(state, {
    fileName: fileName,
    progress: {
      error: error
    }
  }); // kick off next file or finish

  return (0, _tasks.withTask)(nextState, (0, _tasks2.DELAY_TASK)(200).map(filesToLoad.length ? _actions.loadNextFile : function () {
    return onFinish(fileCache);
  }));
};
/**
 * When select dataset for export, apply cpu filter to selected dataset
 * @memberof visStateUpdaters
 * @public
 */


exports.loadFilesErrUpdater = loadFilesErrUpdater;

var applyCPUFilterUpdater = function applyCPUFilterUpdater(state, _ref18) {
  var dataId = _ref18.dataId;
  // apply cpuFilter
  var dataIds = (0, _utils.toArray)(dataId);
  return dataIds.reduce(function (accu, id) {
    return (0, _utils.filterDatasetCPU)(accu, id);
  }, state);
};
/**
 * User input to update the info of the map
 * @memberof visStateUpdaters
 * @public
 */


exports.applyCPUFilterUpdater = applyCPUFilterUpdater;

var setMapInfoUpdater = function setMapInfoUpdater(state, action) {
  return _objectSpread(_objectSpread({}, state), {}, {
    mapInfo: _objectSpread(_objectSpread({}, state.mapInfo), action.info)
  });
};
/**
 * Helper function to update All layer domain and layer data of state
 */


exports.setMapInfoUpdater = setMapInfoUpdater;

function addDefaultLayers(state, datasets) {
  var empty = [];
  var defaultLayers = Object.values(datasets).reduce(function (accu, dataset) {
    var foundLayers = (0, _layerUtils.findDefaultLayer)(dataset, state.layerClasses);
    return foundLayers && foundLayers.length ? accu.concat(foundLayers) : accu;
  }, empty);
  return {
    state: _objectSpread(_objectSpread({}, state), {}, {
      layers: [].concat((0, _toConsumableArray2["default"])(state.layers), (0, _toConsumableArray2["default"])(defaultLayers)),
      layerOrder: [].concat((0, _toConsumableArray2["default"])(defaultLayers.map(function (_, i) {
        return state.layers.length + i;
      })), (0, _toConsumableArray2["default"])(state.layerOrder))
    }),
    newLayers: defaultLayers
  };
}
/**
 * helper function to find default tooltips
 * @param {Object} state
 * @param {Object} dataset
 * @returns {Object} nextState
 */


function addDefaultTooltips(state, dataset) {
  var tooltipFields = (0, _interactionUtils.findFieldsToShow)(_objectSpread(_objectSpread({}, dataset), {}, {
    maxDefaultTooltips: state.maxDefaultTooltips
  }));

  var merged = _objectSpread(_objectSpread({}, state.interactionConfig.tooltip.config.fieldsToShow), tooltipFields);

  return (0, _utils.set)(['interactionConfig', 'tooltip', 'config', 'fieldsToShow'], merged, state);
}

function initialFileLoadingProgress(file, index) {
  var fileName = file.name || "Untitled File ".concat(index);
  return (0, _defineProperty2["default"])({}, fileName, {
    // percent of current file
    percent: 0,
    message: '',
    fileName: fileName,
    error: null
  });
}

function updateFileLoadingProgressUpdater(state, _ref20) {
  var fileName = _ref20.fileName,
      progress = _ref20.progress;
  // @ts-expect-error
  return (0, _composerHelpers.pick_)('fileLoadingProgress')((0, _composerHelpers.pick_)(fileName)((0, _composerHelpers.merge_)(progress)))(state);
}
/**
 * Helper function to update layer domains for an array of datasets
 */


function updateAllLayerDomainData(state, dataId, updatedFilter) {
  var dataIds = typeof dataId === 'string' ? [dataId] : dataId;
  var newLayers = [];
  var newLayerData = [];
  state.layers.forEach(function (oldLayer, i) {
    if (oldLayer.config.dataId && dataIds.includes(oldLayer.config.dataId)) {
      // No need to recalculate layer domain if filter has fixed domain
      var newLayer = updatedFilter && updatedFilter.fixedDomain ? oldLayer : oldLayer.updateLayerDomain(state.datasets, updatedFilter);

      var _calculateLayerData5 = (0, _layerUtils.calculateLayerData)(newLayer, state, state.layerData[i]),
          layerData = _calculateLayerData5.layerData,
          layer = _calculateLayerData5.layer;

      newLayers.push(layer);
      newLayerData.push(layerData);
    } else {
      newLayers.push(oldLayer);
      newLayerData.push(state.layerData[i]);
    }
  });

  var newState = _objectSpread(_objectSpread({}, state), {}, {
    layers: newLayers,
    layerData: newLayerData
  });

  return newState;
}

function updateAnimationDomain(state) {
  // merge all animatable layer domain and update global config
  var animatableLayers = state.layers.filter(function (l) {
    return l.config.isVisible && l.config.animation && l.config.animation.enabled && // @ts-expect-error trip-layer-only
    Array.isArray(l.animationDomain);
  });

  if (!animatableLayers.length) {
    return _objectSpread(_objectSpread({}, state), {}, {
      animationConfig: _objectSpread(_objectSpread({}, state.animationConfig), {}, {
        domain: null,
        defaultTimeFormat: null
      })
    });
  }

  var mergedDomain = animatableLayers.reduce(function (accu, layer) {
    return [// @ts-expect-error trip-layer-only
    Math.min(accu[0], layer.animationDomain[0]), // @ts-expect-error trip-layer-only
    Math.max(accu[1], layer.animationDomain[1])];
  }, [Number(Infinity), -Infinity]);
  var defaultTimeFormat = (0, _utils.getTimeWidgetTitleFormatter)(mergedDomain);
  return _objectSpread(_objectSpread({}, state), {}, {
    animationConfig: _objectSpread(_objectSpread({}, state.animationConfig), {}, {
      currentTime: (0, _utils.isInRange)(state.animationConfig.currentTime, mergedDomain) ? state.animationConfig.currentTime : mergedDomain[0],
      domain: mergedDomain,
      defaultTimeFormat: defaultTimeFormat
    })
  });
}
/**
 * Update the status of the editor
 * @memberof visStateUpdaters
 */


var setEditorModeUpdater = function setEditorModeUpdater(state, _ref21) {
  var mode = _ref21.mode;
  return _objectSpread(_objectSpread({}, state), {}, {
    editor: _objectSpread(_objectSpread({}, state.editor), {}, {
      mode: mode,
      selectedFeature: null
    })
  });
}; // const featureToFilterValue = (feature) => ({...feature, id: feature.id});

/**
 * Update editor features
 * @memberof visStateUpdaters
 */


exports.setEditorModeUpdater = setEditorModeUpdater;

function setFeaturesUpdater(state, _ref22) {
  var _ref22$features = _ref22.features,
      features = _ref22$features === void 0 ? [] : _ref22$features;
  var lastFeature = features.length && features[features.length - 1];

  var newState = _objectSpread(_objectSpread({}, state), {}, {
    editor: _objectSpread(_objectSpread({}, state.editor), {}, {
      // only save none filter features to editor
      features: features.filter(function (f) {
        return !(0, _utils.getFilterIdInFeature)(f);
      }),
      mode: lastFeature && lastFeature.properties.isClosed ? _constants.EDITOR_MODES.EDIT : state.editor.mode
    })
  }); // Retrieve existing feature


  var selectedFeature = state.editor.selectedFeature; // If no feature is selected we can simply return since no operations

  if (!selectedFeature) {
    return newState;
  } // TODO: check if the feature has changed


  var feature = features.find(function (f) {
    return f.id === selectedFeature.id;
  }); // if feature is part of a filter

  var filterId = feature && (0, _utils.getFilterIdInFeature)(feature);

  if (filterId && feature) {
    var featureValue = (0, _utils.featureToFilterValue)(feature, filterId);
    var filterIdx = state.filters.findIndex(function (fil) {
      return fil.id === filterId;
    }); // @ts-ignore

    return setFilterUpdater(newState, {
      idx: filterIdx,
      prop: 'value',
      value: featureValue
    });
  }

  return newState;
}
/**
 * Set the current selected feature
 * @memberof uiStateUpdaters
 */


var setSelectedFeatureUpdater = function setSelectedFeatureUpdater(state, _ref23) {
  var feature = _ref23.feature;
  return _objectSpread(_objectSpread({}, state), {}, {
    editor: _objectSpread(_objectSpread({}, state.editor), {}, {
      selectedFeature: feature
    })
  });
};
/**
 * Delete existing feature from filters
 * @memberof visStateUpdaters
 */


exports.setSelectedFeatureUpdater = setSelectedFeatureUpdater;

function deleteFeatureUpdater(state, _ref24) {
  var feature = _ref24.feature;

  if (!feature) {
    return state;
  }

  var newState = _objectSpread(_objectSpread({}, state), {}, {
    editor: _objectSpread(_objectSpread({}, state.editor), {}, {
      selectedFeature: null
    })
  });

  if ((0, _utils.getFilterIdInFeature)(feature)) {
    var filterIdx = newState.filters.findIndex(function (f) {
      return f.id === (0, _utils.getFilterIdInFeature)(feature);
    });
    return filterIdx > -1 ? removeFilterUpdater(newState, {
      idx: filterIdx
    }) : newState;
  } // modify editor object


  var newEditor = _objectSpread(_objectSpread({}, state.editor), {}, {
    features: state.editor.features.filter(function (f) {
      return f.id !== feature.id;
    }),
    selectedFeature: null
  });

  return _objectSpread(_objectSpread({}, state), {}, {
    editor: newEditor
  });
}
/**
 * Toggle feature as layer filter
 * @memberof visStateUpdaters
 */


function setPolygonFilterLayerUpdater(state, payload) {
  var layer = payload.layer,
      feature = payload.feature;
  var filterId = (0, _utils.getFilterIdInFeature)(feature); // let newFilter = null;

  var filterIdx;
  var newLayerId = [layer.id];
  var newState = state; // If polygon filter already exists, we need to find out if the current layer is already included

  if (filterId) {
    filterIdx = state.filters.findIndex(function (f) {
      return f.id === filterId;
    });

    if (!state.filters[filterIdx]) {
      // what if filter doesn't exist?... not possible.
      // because features in the editor is passed in from filters and editors.
      // but we will move this feature back to editor just in case
      var noneFilterFeature = _objectSpread(_objectSpread({}, feature), {}, {
        properties: _objectSpread(_objectSpread({}, feature.properties), {}, {
          filterId: null
        })
      });

      return _objectSpread(_objectSpread({}, state), {}, {
        editor: _objectSpread(_objectSpread({}, state.editor), {}, {
          features: [].concat((0, _toConsumableArray2["default"])(state.editor.features), [noneFilterFeature]),
          selectedFeature: noneFilterFeature
        })
      });
    }

    var filter = state.filters[filterIdx];
    var _filter$layerId = filter.layerId,
        layerId = _filter$layerId === void 0 ? [] : _filter$layerId;
    var isLayerIncluded = layerId.includes(layer.id);
    newLayerId = isLayerIncluded ? // if layer is included, remove it
    layerId.filter(function (l) {
      return l !== layer.id;
    }) : [].concat((0, _toConsumableArray2["default"])(layerId), [layer.id]);
  } else {
    // if we haven't create the polygon filter, create it
    var newFilter = (0, _utils.generatePolygonFilter)([], feature);
    filterIdx = state.filters.length; // add feature, remove feature from eidtor

    newState = _objectSpread(_objectSpread({}, state), {}, {
      filters: [].concat((0, _toConsumableArray2["default"])(state.filters), [newFilter]),
      editor: _objectSpread(_objectSpread({}, state.editor), {}, {
        features: state.editor.features.filter(function (f) {
          return f.id !== feature.id;
        }),
        selectedFeature: newFilter.value
      })
    });
  }

  return setFilterUpdater(newState, {
    idx: filterIdx,
    prop: 'layerId',
    value: newLayerId
  });
}
/**
 * @memberof visStateUpdaters
 * @public
 */


function sortTableColumnUpdater(state, _ref25) {
  var dataId = _ref25.dataId,
      column = _ref25.column,
      mode = _ref25.mode;
  var dataset = state.datasets[dataId];

  if (!dataset) {
    return state;
  }

  var sortMode = mode;

  if (!sortMode) {
    var currentMode = (0, _lodash3["default"])(dataset, ['sortColumn', column]); // @ts-ignore - should be fixable in a TS file

    sortMode = currentMode ? Object.keys(_constants.SORT_ORDER).find(function (m) {
      return m !== currentMode;
    }) : _constants.SORT_ORDER.ASCENDING;
  }

  var sorted = (0, _table.sortDatasetByColumn)(dataset, column, sortMode);
  return (0, _utils.set)(['datasets', dataId], sorted, state);
}
/**
 * @memberof visStateUpdaters
 * @public
 */


function pinTableColumnUpdater(state, _ref26) {
  var dataId = _ref26.dataId,
      column = _ref26.column;
  var dataset = state.datasets[dataId];

  if (!dataset) {
    return state;
  }

  var newDataset = (0, _table.pinTableColumns)(dataset, column);
  return (0, _utils.set)(['datasets', dataId], newDataset, state);
}
/**
 * Copy column content as strings
 * @memberof visStateUpdaters
 * @public
 */


function copyTableColumnUpdater(state, _ref27) {
  var dataId = _ref27.dataId,
      column = _ref27.column;
  var dataset = state.datasets[dataId];

  if (!dataset) {
    return state;
  }

  var fieldIdx = dataset.fields.findIndex(function (f) {
    return f.name === column;
  });

  if (fieldIdx < 0) {
    return state;
  }

  var type = dataset.fields[fieldIdx].type;
  var text = dataset.dataContainer.map(function (row) {
    return (0, _utils.parseFieldValue)(row.valueAt(fieldIdx), type);
  }, true).join('\n');
  (0, _copyToClipboard["default"])(text);
  return state;
}
/**
 * Update editor
 */


function toggleEditorVisibilityUpdater(state, action) {
  return _objectSpread(_objectSpread({}, state), {}, {
    editor: _objectSpread(_objectSpread({}, state.editor), {}, {
      visible: !state.editor.visible
    })
  });
}

function setFilterAnimationTimeConfigUpdater(state, _ref28) {
  var idx = _ref28.idx,
      config = _ref28.config;
  var oldFilter = state.filters[idx];

  if (!oldFilter) {
    _window.console.error("filters.".concat(idx, " is undefined"));

    return state;
  }

  if (oldFilter.type !== _constants.FILTER_TYPES.timeRange) {
    _window.console.error("setFilterAnimationTimeConfig can only be called to update a time filter. check filter.type === 'timeRange'");

    return state;
  }

  var updates = checkTimeConfigArgs(config);
  return (0, _composerHelpers.pick_)('filters')((0, _composerHelpers.swap_)((0, _composerHelpers.merge_)(updates)(oldFilter)))(state);
}

function checkTimeConfigArgs(config) {
  var allowed = ['timeFormat', 'timezone'];
  return Object.keys(config).reduce(function (accu, prop) {
    if (!allowed.includes(prop)) {
      _window.console.error("setLayerAnimationTimeConfig takes timeFormat and/or timezone as options, found ".concat(prop));

      return accu;
    } // here we are NOT checking if timezone or timeFormat input is valid


    accu[prop] = config[prop];
    return accu;
  }, {});
}
/**
 * Update editor
 */


function setLayerAnimationTimeConfigUpdater(state, _ref29) {
  var config = _ref29.config;

  if (!config) {
    return state;
  }

  var updates = checkTimeConfigArgs(config);
  return (0, _composerHelpers.pick_)('animationConfig')((0, _composerHelpers.merge_)(updates))(state);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy92aXMtc3RhdGUtdXBkYXRlcnMudHMiXSwibmFtZXMiOlsidmlzU3RhdGVVcGRhdGVycyIsImRlZmF1bHRJbnRlcmFjdGlvbkNvbmZpZyIsInRvb2x0aXAiLCJpZCIsImxhYmVsIiwiZW5hYmxlZCIsImNvbmZpZyIsImZpZWxkc1RvU2hvdyIsImNvbXBhcmVNb2RlIiwiY29tcGFyZVR5cGUiLCJDT01QQVJFX1RZUEVTIiwiQUJTT0xVVEUiLCJnZW9jb2RlciIsInBvc2l0aW9uIiwiYnJ1c2giLCJzaXplIiwiY29vcmRpbmF0ZSIsIkRFRkFVTFRfQU5JTUFUSU9OX0NPTkZJRyIsImRvbWFpbiIsImN1cnJlbnRUaW1lIiwic3BlZWQiLCJpc0FuaW1hdGluZyIsInRpbWVGb3JtYXQiLCJ0aW1lem9uZSIsImRlZmF1bHRUaW1lRm9ybWF0IiwiREVGQVVMVF9FRElUT1IiLCJtb2RlIiwiRURJVE9SX01PREVTIiwiRFJBV19QT0xZR09OIiwiZmVhdHVyZXMiLCJzZWxlY3RlZEZlYXR1cmUiLCJ2aXNpYmxlIiwiSU5JVElBTF9WSVNfU1RBVEUiLCJtYXBJbmZvIiwidGl0bGUiLCJkZXNjcmlwdGlvbiIsImxheWVycyIsImxheWVyRGF0YSIsImxheWVyVG9CZU1lcmdlZCIsImxheWVyT3JkZXIiLCJmaWx0ZXJzIiwiZmlsdGVyVG9CZU1lcmdlZCIsImRhdGFzZXRzIiwiZWRpdGluZ0RhdGFzZXQiLCJ1bmRlZmluZWQiLCJpbnRlcmFjdGlvbkNvbmZpZyIsImludGVyYWN0aW9uVG9CZU1lcmdlZCIsImxheWVyQmxlbmRpbmciLCJob3ZlckluZm8iLCJjbGlja2VkIiwibW91c2VQb3MiLCJtYXhEZWZhdWx0VG9vbHRpcHMiLCJNQVhfREVGQVVMVF9UT09MVElQUyIsInNwbGl0TWFwcyIsInNwbGl0TWFwc1RvQmVNZXJnZWQiLCJsYXllckNsYXNzZXMiLCJMYXllckNsYXNzZXMiLCJhbmltYXRpb25Db25maWciLCJlZGl0b3IiLCJmaWxlTG9hZGluZyIsImZpbGVMb2FkaW5nUHJvZ3Jlc3MiLCJsb2FkZXJzIiwibG9hZE9wdGlvbnMiLCJtZXJnZXJzIiwiVklTX1NUQVRFX01FUkdFUlMiLCJzY2hlbWEiLCJLZXBsZXJHTFNjaGVtYSIsInVwZGF0ZVN0YXRlV2l0aExheWVyQW5kRGF0YSIsInN0YXRlIiwibGF5ZXIiLCJpZHgiLCJtYXAiLCJseXIiLCJpIiwiZCIsInVwZGF0ZVN0YXRlT25MYXllclZpc2liaWxpdHlDaGFuZ2UiLCJuZXdTdGF0ZSIsImxlbmd0aCIsImlzVmlzaWJsZSIsImFuaW1hdGlvbiIsInVwZGF0ZUFuaW1hdGlvbkRvbWFpbiIsImxheWVyQ29uZmlnQ2hhbmdlVXBkYXRlciIsImFjdGlvbiIsIm9sZExheWVyIiwiZmluZEluZGV4IiwibCIsInByb3BzIiwiT2JqZWN0Iiwia2V5cyIsIm5ld0NvbmZpZyIsImRhdGFJZCIsInJlc3RDb25maWciLCJzdGF0ZVdpdGhEYXRhSWQiLCJsYXllckRhdGFJZENoYW5nZVVwZGF0ZXIiLCJuZXh0TGF5ZXIiLCJmaW5kIiwibmV3TGF5ZXIiLCJ1cGRhdGVMYXllckNvbmZpZyIsInNob3VsZENhbGN1bGF0ZUxheWVyRGF0YSIsIm9sZExheWVyRGF0YSIsInVwZGF0ZUxheWVyRGF0YVJlc3VsdCIsImFkZE9yUmVtb3ZlVGV4dExhYmVscyIsIm5ld0ZpZWxkcyIsInRleHRMYWJlbCIsIm5ld1RleHRMYWJlbCIsInNsaWNlIiwiY3VycmVudEZpZWxkcyIsInRsIiwiZmllbGQiLCJuYW1lIiwiZmlsdGVyIiwiYWRkRmllbGRzIiwiZiIsImluY2x1ZGVzIiwiZGVsZXRlRmllbGRzIiwiZmQiLCJERUZBVUxUX1RFWFRfTEFCRUwiLCJhZiIsInVwZGF0ZVRleHRMYWJlbFByb3BBbmRWYWx1ZSIsInByb3AiLCJ2YWx1ZSIsImhhc093blByb3BlcnR5Iiwic3BsaWNlIiwibGF5ZXJUZXh0TGFiZWxDaGFuZ2VVcGRhdGVyIiwidmFsaWRhdGVFeGlzdGluZ0xheWVyV2l0aERhdGEiLCJkYXRhc2V0IiwibG9hZGVkTGF5ZXIiLCJhbGxvd0VtcHR5Q29sdW1uIiwiaXNWYWxpZFRvU2F2ZSIsInZhbGlkYXRlZCIsInR5cGUiLCJpc0NvbmZpZ0FjdGl2ZSIsInVwZGF0ZUxheWVyRG9tYWluIiwic2V0SW5pdGlhbExheWVyQ29uZmlnIiwicmVzdWx0IiwiZmluZERlZmF1bHRMYXllclByb3BzIiwiQXJyYXkiLCJpc0FycmF5IiwibGF5ZXJUeXBlQ2hhbmdlVXBkYXRlciIsIm5ld1R5cGUiLCJvbGRJZCIsIkNvbnNvbGUiLCJlcnJvciIsImFzc2lnbkNvbmZpZ1RvTGF5ZXIiLCJ2aXNDb25maWdTZXR0aW5ncyIsImlzTGF5ZXJIb3ZlcmVkIiwic2V0dGluZ3MiLCJvbGRMYXllck1hcCIsIm90aGVyTGF5ZXJzIiwibGF5ZXJWaXN1YWxDaGFubmVsQ2hhbmdlVXBkYXRlciIsImNoYW5uZWwiLCJ1cGRhdGVMYXllclZpc3VhbENoYW5uZWwiLCJsYXllclZpc0NvbmZpZ0NoYW5nZVVwZGF0ZXIiLCJuZXdWaXNDb25maWciLCJ2aXNDb25maWciLCJzZXRGaWx0ZXJBbmltYXRpb25UaW1lVXBkYXRlciIsInNldEZpbHRlclVwZGF0ZXIiLCJzZXRGaWx0ZXJBbmltYXRpb25XaW5kb3dVcGRhdGVyIiwiYW5pbWF0aW9uV2luZG93IiwidmFsdWVJbmRleCIsIm9sZEZpbHRlciIsIm5ld0ZpbHRlciIsImRhdGFzZXRJZHMiLCJGSUxURVJfVVBEQVRFUl9QUk9QUyIsImRhdGFzZXRJZCIsIm1lcmdlRG9tYWluIiwidXBkYXRlZEZpbHRlciIsIm5ld0RhdGFzZXQiLCJncHUiLCJsYXllcklkIiwibGF5ZXJJZERpZmZlcmVuY2UiLCJsYXllckRhdGFJZHMiLCJsaWQiLCJuZXdEYXRhSWRzIiwiZW5sYXJnZWRGaWx0ZXIiLCJlbmxhcmdlZCIsImRhdGFzZXRJZHNUb0ZpbHRlciIsIkxJTUlURURfRklMVEVSX0VGRkVDVF9QUk9QUyIsImZpbHRlcmVkRGF0YXNldHMiLCJ1cGRhdGVBbGxMYXllckRvbWFpbkRhdGEiLCJzZXRGaWx0ZXJQbG90VXBkYXRlciIsIm5ld1Byb3AiLCJwbG90VHlwZSIsImFkZEZpbHRlclVwZGF0ZXIiLCJsYXllckNvbG9yVUlDaGFuZ2VVcGRhdGVyIiwib2xkVml4Q29uZmlnIiwidXBkYXRlTGF5ZXJDb2xvclVJIiwidG9nZ2xlRmlsdGVyQW5pbWF0aW9uVXBkYXRlciIsInRvZ2dsZUxheWVyQW5pbWF0aW9uVXBkYXRlciIsInRvZ2dsZUxheWVyQW5pbWF0aW9uQ29udHJvbFVwZGF0ZXIiLCJoaWRlQ29udHJvbCIsInVwZGF0ZUZpbHRlckFuaW1hdGlvblNwZWVkVXBkYXRlciIsInNldExheWVyQW5pbWF0aW9uVGltZVVwZGF0ZXIiLCJ1cGRhdGVMYXllckFuaW1hdGlvblNwZWVkVXBkYXRlciIsImVubGFyZ2VGaWx0ZXJVcGRhdGVyIiwidG9nZ2xlRmlsdGVyRmVhdHVyZVVwZGF0ZXIiLCJhc3NpZ24iLCJyZW1vdmVGaWx0ZXJVcGRhdGVyIiwibmV3RmlsdGVycyIsIm5ld0VkaXRvciIsImFkZExheWVyVXBkYXRlciIsIm5ld0xheWVyRGF0YSIsIndhcm4iLCJkZWZhdWx0RGF0YXNldCIsIkxheWVyIiwicmVtb3ZlTGF5ZXJVcGRhdGVyIiwibGF5ZXJUb1JlbW92ZSIsIm5ld01hcHMiLCJwaWQiLCJkdXBsaWNhdGVMYXllclVwZGF0ZXIiLCJvcmlnaW5hbCIsIm9yaWdpbmFsTGF5ZXJPcmRlcklkeCIsIm5ld0xhYmVsIiwicG9zdGZpeCIsIkxBWUVSX0lEX0xFTkdUSCIsIm5leHRTdGF0ZSIsIm5ld0xheWVyT3JkZXJJZHgiLCJuZXdMYXllck9yZGVyIiwicmVvcmRlckxheWVyVXBkYXRlciIsIm9yZGVyIiwicmVtb3ZlRGF0YXNldFVwZGF0ZXIiLCJkYXRhc2V0S2V5IiwibmV3RGF0YXNldHMiLCJpbmRleGVzIiwicmVkdWNlIiwibGlzdE9mSW5kZXhlcyIsImluZGV4IiwicHVzaCIsImN1cnJlbnRTdGF0ZSIsImluZGV4Q291bnRlciIsImN1cnJlbnRJbmRleCIsImZpZWxkcyIsInVwZGF0ZUxheWVyQmxlbmRpbmdVcGRhdGVyIiwic2hvd0RhdGFzZXRUYWJsZVVwZGF0ZXIiLCJ1cGRhdGVUYWJsZUNvbG9yVXBkYXRlciIsIm5ld0NvbG9yIiwiZXhpc3RpbmciLCJ1cGRhdGVUYWJsZUNvbG9yIiwicmVzZXRNYXBDb25maWdVcGRhdGVyIiwiaW5pdGlhbFN0YXRlIiwicmVjZWl2ZU1hcENvbmZpZ1VwZGF0ZXIiLCJwYXlsb2FkIiwidmVyc2lvbiIsIm9wdGlvbnMiLCJ2aXNTdGF0ZSIsImtlZXBFeGlzdGluZ0NvbmZpZyIsIm1lcmdlZFN0YXRlIiwibWVyZ2VyIiwibWVyZ2UiLCJsYXllckhvdmVyVXBkYXRlciIsImluZm8iLCJpbnRlcmFjdGlvbkNvbmZpZ0NoYW5nZVVwZGF0ZXIiLCJjb250cmFkaWN0IiwiZm9yRWFjaCIsImsiLCJsYXllckNsaWNrVXBkYXRlciIsInBpbm5lZCIsInBpY2tlZCIsIm1hcENsaWNrVXBkYXRlciIsIm1vdXNlTW92ZVVwZGF0ZXIiLCJldnQiLCJ2YWx1ZXMiLCJzb21lIiwicG9pbnQiLCJtb3VzZVBvc2l0aW9uIiwibG5nTGF0IiwidG9nZ2xlU3BsaXRNYXBVcGRhdGVyIiwiY2xvc2VTcGVjaWZpY01hcEF0SW5kZXgiLCJ0b2dnbGVMYXllckZvck1hcFVwZGF0ZXIiLCJtYXBJbmRleCIsInNtIiwidXBkYXRlVmlzRGF0YVVwZGF0ZXIiLCJuZXdEYXRhRW50cmllcyIsImFjY3UiLCJyZXN0IiwiZGF0YUVtcHR5IiwicHJldmlvdXNTdGF0ZSIsInRvTWVyZ2VQcm9wIiwidG9NZXJnZSIsIm5ld0xheWVycyIsImF1dG9DcmVhdGVMYXllcnMiLCJhZGREZWZhdWx0TGF5ZXJzIiwidG9vbHRpcEZpZWxkcyIsImFkZERlZmF1bHRUb29sdGlwcyIsInVwZGF0ZWRTdGF0ZSIsInJlbmFtZURhdGFzZXRVcGRhdGVyIiwiaW5kZXhUb1JldHJpZXZlIiwibWFwTGF5ZXJzIiwibG9hZEZpbGVzVXBkYXRlciIsImZpbGVzIiwib25GaW5pc2giLCJsb2FkRmlsZXNTdWNjZXNzIiwiZnJvbSIsImluaXRpYWxGaWxlTG9hZGluZ1Byb2dyZXNzIiwiZmlsZUNhY2hlIiwiZmlsZXNUb0xvYWQiLCJsb2FkTmV4dEZpbGVVcGRhdGVyIiwibG9hZEZpbGVTdGVwU3VjY2Vzc1VwZGF0ZXIiLCJmaWxlTmFtZSIsInN0YXRlV2l0aFByb2dyZXNzIiwidXBkYXRlRmlsZUxvYWRpbmdQcm9ncmVzc1VwZGF0ZXIiLCJwcm9ncmVzcyIsInBlcmNlbnQiLCJtZXNzYWdlIiwic3RhdGVXaXRoQ2FjaGUiLCJsb2FkTmV4dEZpbGUiLCJmaWxlIiwicmVtYWluaW5nRmlsZXNUb0xvYWQiLCJtYWtlTG9hZEZpbGVUYXNrIiwiYmltYXAiLCJnZW4iLCJjb250ZW50IiwiZXJyIiwicHJvY2Vzc0ZpbGVDb250ZW50VXBkYXRlciIsInBhcnNlUHJvZ3Jlc3MiLCJwcmV2UHJvZ3Jlc3MiLCJuZXh0RmlsZUJhdGNoVXBkYXRlciIsImFjY3VtdWxhdGVkIiwibmV4dCIsImRvbmUiLCJsb2FkRmlsZXNFcnJVcGRhdGVyIiwiYXBwbHlDUFVGaWx0ZXJVcGRhdGVyIiwiZGF0YUlkcyIsInNldE1hcEluZm9VcGRhdGVyIiwiZW1wdHkiLCJkZWZhdWx0TGF5ZXJzIiwiZm91bmRMYXllcnMiLCJjb25jYXQiLCJfIiwibWVyZ2VkIiwiZml4ZWREb21haW4iLCJhbmltYXRhYmxlTGF5ZXJzIiwiYW5pbWF0aW9uRG9tYWluIiwibWVyZ2VkRG9tYWluIiwiTWF0aCIsIm1pbiIsIm1heCIsIk51bWJlciIsIkluZmluaXR5Iiwic2V0RWRpdG9yTW9kZVVwZGF0ZXIiLCJzZXRGZWF0dXJlc1VwZGF0ZXIiLCJsYXN0RmVhdHVyZSIsInByb3BlcnRpZXMiLCJpc0Nsb3NlZCIsIkVESVQiLCJmZWF0dXJlIiwiZmlsdGVySWQiLCJmZWF0dXJlVmFsdWUiLCJmaWx0ZXJJZHgiLCJmaWwiLCJzZXRTZWxlY3RlZEZlYXR1cmVVcGRhdGVyIiwiZGVsZXRlRmVhdHVyZVVwZGF0ZXIiLCJzZXRQb2x5Z29uRmlsdGVyTGF5ZXJVcGRhdGVyIiwibmV3TGF5ZXJJZCIsIm5vbmVGaWx0ZXJGZWF0dXJlIiwiaXNMYXllckluY2x1ZGVkIiwic29ydFRhYmxlQ29sdW1uVXBkYXRlciIsImNvbHVtbiIsInNvcnRNb2RlIiwiY3VycmVudE1vZGUiLCJTT1JUX09SREVSIiwibSIsIkFTQ0VORElORyIsInNvcnRlZCIsInBpblRhYmxlQ29sdW1uVXBkYXRlciIsImNvcHlUYWJsZUNvbHVtblVwZGF0ZXIiLCJmaWVsZElkeCIsInRleHQiLCJkYXRhQ29udGFpbmVyIiwicm93IiwidmFsdWVBdCIsImpvaW4iLCJ0b2dnbGVFZGl0b3JWaXNpYmlsaXR5VXBkYXRlciIsInNldEZpbHRlckFuaW1hdGlvblRpbWVDb25maWdVcGRhdGVyIiwiRklMVEVSX1RZUEVTIiwidGltZVJhbmdlIiwidXBkYXRlcyIsImNoZWNrVGltZUNvbmZpZ0FyZ3MiLCJhbGxvd2VkIiwic2V0TGF5ZXJBbmltYXRpb25UaW1lQ29uZmlnVXBkYXRlciJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFvQkE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBRUE7O0FBRUE7O0FBY0E7O0FBMEJBOztBQVFBOztBQUNBOztBQVFBOztBQUVBOztBQUtBOztBQUNBOztBQVNBOzs7Ozs7Ozs7Ozs7Ozs7O0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0EsSUFBTUEsZ0JBQWdCLEdBQUcsSUFBekI7QUFDQTs7QUFFTyxJQUFNQyx3QkFBMkMsR0FBRztBQUN6REMsRUFBQUEsT0FBTyxFQUFFO0FBQ1BDLElB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O0FBRUQsTUFBTW9ULE9BQU8sR0FBR0MsbUJBQW1CLENBQUNuWCxNQUFELENBQW5DO0FBRUEsU0FBTyw0QkFBTSxTQUFOLEVBQWlCLDRCQUFNLDZCQUFPa1gsT0FBUCxFQUFnQnhOLFNBQWhCLENBQU4sQ0FBakIsRUFBb0Q1RixLQUFwRCxDQUFQO0FBQ0Q7O0FBRUQsU0FBU3FULG1CQUFULENBQTZCblgsTUFBN0IsRUFBcUM7QUFDbkMsTUFBTW9YLE9BQU8sR0FBRyxDQUFDLFlBQUQsRUFBZSxVQUFmLENBQWhCO0FBQ0EsU0FBT25TLE1BQU0sQ0FBQ0MsSUFBUCxDQUFZbEYsTUFBWixFQUFvQjBOLE1BQXBCLENBQTJCLFVBQUNpRCxJQUFELEVBQU8xSixJQUFQLEVBQWdCO0FBQ2hELFFBQUksQ0FBQ21RLE9BQU8sQ0FBQ3pRLFFBQVIsQ0FBaUJNLElBQWpCLENBQUwsRUFBNkI7QUFDM0JzQixzQkFBUUMsS0FBUiwwRkFDb0Z2QixJQURwRjs7QUFHQSxhQUFPMEosSUFBUDtBQUNELEtBTitDLENBUWhEOzs7QUFDQUEsSUFBQUEsSUFBSSxDQUFDMUosSUFBRCxDQUFKLEdBQWFqSCxNQUFNLENBQUNpSCxJQUFELENBQW5CO0FBQ0EsV0FBTzBKLElBQVA7QUFDRCxHQVhNLEVBV0osRUFYSSxDQUFQO0FBWUQ7QUFDRDtBQUNBO0FBQ0E7OztBQUNPLFNBQVMwRyxrQ0FBVCxDQUNMdlQsS0FESyxVQUdLO0FBQUEsTUFEVDlELE1BQ1MsVUFEVEEsTUFDUzs7QUFDVixNQUFJLENBQUNBLE1BQUwsRUFBYTtBQUNYLFdBQU84RCxLQUFQO0FBQ0Q7O0FBQ0QsTUFBTW9ULE9BQU8sR0FBR0MsbUJBQW1CLENBQUNuWCxNQUFELENBQW5DO0FBQ0EsU0FBTyw0QkFBTSxpQkFBTixFQUF5Qiw2QkFBT2tYLE9BQVAsQ0FBekIsRUFBMENwVCxLQUExQyxDQUFQO0FBQ0QiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMjIgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5pbXBvcnQge2NvbnNvbGUgYXMgQ29uc29sZX0gZnJvbSAnZ2xvYmFsL3dpbmRvdyc7XG5pbXBvcnQge2Rpc2FibGVTdGFja0NhcHR1cmluZywgd2l0aFRhc2t9IGZyb20gJ3JlYWN0LXBhbG0vdGFza3MnO1xuaW1wb3J0IGNsb25lRGVlcCBmcm9tICdsb2Rhc2guY2xvbmVkZWVwJztcbmltcG9ydCB1bmlxIGZyb20gJ2xvZGFzaC51bmlxJztcbmltcG9ydCBnZXQgZnJvbSAnbG9kYXNoLmdldCc7XG5pbXBvcnQgeG9yIGZyb20gJ2xvZGFzaC54b3InO1xuaW1wb3J0IGNvcHkgZnJvbSAnY29weS10by1jbGlwYm9hcmQnO1xuLy8gVGFza3NcbmltcG9ydCB7TE9BRF9GSUxFX1RBU0ssIFVOV1JBUF9UQVNLLCBQUk9DRVNTX0ZJTEVfREFUQSwgREVMQVlfVEFTS30gZnJvbSAnQGtlcGxlci5nbC90YXNrcyc7XG4vLyBBY3Rpb25zXG5pbXBvcnQge1xuICBsb2FkRmlsZXNFcnIsXG4gIGxvYWRGaWxlc1N1Y2Nlc3MsXG4gIGxvYWRGaWxlU3RlcFN1Y2Nlc3MsXG4gIGxvYWROZXh0RmlsZSxcbiAgbmV4dEZpbGVCYXRjaCxcbiAgUmVjZWl2ZU1hcENvbmZpZ1BheWxvYWQsXG4gIFZpc1N0YXRlQWN0aW9ucyxcbiAgTWFwU3RhdGVBY3Rpb25zLFxuICBwcm9jZXNzRmlsZUNvbnRlbnQsXG4gIEFjdGlvblR5cGVzXG59IGZyb20gJ0BrZXBsZXIuZ2wvYWN0aW9ucyc7XG5cbi8vIFV0aWxzXG5pbXBvcnQge1xuICBzZXQsXG4gIHRvQXJyYXksXG4gIGFycmF5SW5zZXJ0LFxuICBnZW5lcmF0ZUhhc2hJZCxcbiAgYWRkTmV3TGF5ZXJzVG9TcGxpdE1hcCxcbiAgY29tcHV0ZVNwbGl0TWFwTGF5ZXJzLFxuICByZW1vdmVMYXllckZyb21TcGxpdE1hcHMsXG4gIGlzUmdiQ29sb3IsXG4gIHBhcnNlRmllbGRWYWx1ZSxcbiAgYXBwbHlGaWx0ZXJGaWVsZE5hbWUsXG4gIGFwcGx5RmlsdGVyc1RvRGF0YXNldHMsXG4gIGZlYXR1cmVUb0ZpbHRlclZhbHVlLFxuICBmaWx0ZXJEYXRhc2V0Q1BVLFxuICBGSUxURVJfVVBEQVRFUl9QUk9QUyxcbiAgZ2VuZXJhdGVQb2x5Z29uRmlsdGVyLFxuICBnZXREZWZhdWx0RmlsdGVyLFxuICBnZXRGaWx0ZXJJZEluRmVhdHVyZSxcbiAgZ2V0VGltZVdpZGdldFRpdGxlRm9ybWF0dGVyLFxuICBpc0luUmFuZ2UsXG4gIExJTUlURURfRklMVEVSX0VGRkVDVF9QUk9QUyxcbiAgdXBkYXRlRmlsdGVyRGF0YUlkLFxuICBnZXRGaWx0ZXJQbG90LFxuICBnZXREZWZhdWx0RmlsdGVyUGxvdFR5cGVcbn0gZnJvbSAnQGtlcGxlci5nbC91dGlscyc7XG5cbmltcG9ydCB7XG4gIGlzVmFsaWRNZXJnZXIsXG4gIFZJU19TVEFURV9NRVJHRVJTLFxuICB2YWxpZGF0ZUxheWVyV2l0aERhdGEsXG4gIGNyZWF0ZUxheWVyRnJvbUNvbmZpZyxcbiAgc2VyaWFsaXplTGF5ZXJcbn0gZnJvbSAnLi92aXMtc3RhdGUtbWVyZ2VyJztcblxuaW1wb3J0IHtMYXllciwgTGF5ZXJDbGFzc2VzLCBMQVlFUl9JRF9MRU5HVEh9IGZyb20gJ0BrZXBsZXIuZ2wvbGF5ZXJzJztcbmltcG9ydCB7XG4gIEVESVRPUl9NT0RFUyxcbiAgU09SVF9PUkRFUixcbiAgRklMVEVSX1RZUEVTLFxuICBNQVhfREVGQVVMVF9UT09MVElQUyxcbiAgREVGQVVMVF9URVhUX0xBQkVMLFxuICBDT01QQVJFX1RZUEVTXG59IGZyb20gJ0BrZXBsZXIuZ2wvY29uc3RhbnRzJztcbmltcG9ydCB7cGlja18sIG1lcmdlXywgc3dhcF99IGZyb20gJy4vY29tcG9zZXItaGVscGVycyc7XG5cbmltcG9ydCBLZXBsZXJHTFNjaGVtYSwge1Zpc1N0YXRlfSBmcm9tICdAa2VwbGVyLmdsL3NjaGVtYXMnO1xuXG5pbXBvcnQge0ZpbHRlciwgSW50ZXJhY3Rpb25Db25maWcsIEFuaW1hdGlvbkNvbmZpZywgRWRpdG9yfSBmcm9tICdAa2VwbGVyLmdsL3R5cGVzJztcbmltcG9ydCB7TG9hZGVyfSBmcm9tICdAbG9hZGVycy5nbC9sb2FkZXItdXRpbHMnO1xuXG5pbXBvcnQge2NhbGN1bGF0ZUxheWVyRGF0YSwgZmluZERlZmF1bHRMYXllcn0gZnJvbSAnLi9sYXllci11dGlscyc7XG5pbXBvcnQge1xuICBjb3B5VGFibGVBbmRVcGRhdGUsXG4gIERhdGFzZXRzLFxuICBwaW5UYWJsZUNvbHVtbnMsXG4gIHNvcnREYXRhc2V0QnlDb2x1bW4sXG4gIGFzc2lnbkdwdUNoYW5uZWwsXG4gIHNldEZpbHRlckdwdU1vZGUsXG4gIGNyZWF0ZU5ld0RhdGFFbnRyeVxufSBmcm9tICdAa2VwbGVyLmdsL3RhYmxlJztcbmltcG9ydCB7ZmluZEZpZWxkc1RvU2hvd30gZnJvbSAnLi9pbnRlcmFjdGlvbi11dGlscyc7XG5cbi8vIHJlYWN0LXBhbG1cbi8vIGRpc2FibGUgY2FwdHVyZSBleGNlcHRpb24gZm9yIHJlYWN0LXBhbG0gY2FsbCB0byB3aXRoVGFza1xuZGlzYWJsZVN0YWNrQ2FwdHVyaW5nKCk7XG5cbi8qKlxuICogVXBkYXRlcnMgZm9yIGB2aXNTdGF0ZWAgcmVkdWNlci4gQ2FuIGJlIHVzZWQgaW4geW91ciByb290IHJlZHVjZXIgdG8gZGlyZWN0bHkgbW9kaWZ5IGtlcGxlci5nbCdzIHN0YXRlLlxuICogUmVhZCBtb3JlIGFib3V0IFtVc2luZyB1cGRhdGVyc10oLi4vYWR2YW5jZWQtdXNhZ2UvdXNpbmctdXBkYXRlcnMubWQpXG4gKlxuICogQHB1YmxpY1xuICogQGV4YW1wbGVcbiAqXG4gKiBpbXBvcnQga2VwbGVyR2xSZWR1Y2VyLCB7dmlzU3RhdGVVcGRhdGVyc30gZnJvbSAna2VwbGVyLmdsL3JlZHVjZXJzJztcbiAqIC8vIFJvb3QgUmVkdWNlclxuICogY29uc3QgcmVkdWNlcnMgPSBjb21iaW5lUmVkdWNlcnMoe1xuICogIGtlcGxlckdsOiBrZXBsZXJHbFJlZHVjZXIsXG4gKiAgYXBwOiBhcHBSZWR1Y2VyXG4gKiB9KTtcbiAqXG4gKiBjb25zdCBjb21wb3NlZFJlZHVjZXIgPSAoc3RhdGUsIGFjdGlvbikgPT4ge1xuICogIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAqICAgIGNhc2UgJ0NMSUNLX0JVVFRPTic6XG4gKiAgICAgIHJldHVybiB7XG4gKiAgICAgICAgLi4uc3RhdGUsXG4gKiAgICAgICAga2VwbGVyR2w6IHtcbiAqICAgICAgICAgIC4uLnN0YXRlLmtlcGxlckdsLFxuICogICAgICAgICAgZm9vOiB7XG4gKiAgICAgICAgICAgICAuLi5zdGF0ZS5rZXBsZXJHbC5mb28sXG4gKiAgICAgICAgICAgICB2aXNTdGF0ZTogdmlzU3RhdGVVcGRhdGVycy5lbmxhcmdlRmlsdGVyVXBkYXRlcihcbiAqICAgICAgICAgICAgICAgc3RhdGUua2VwbGVyR2wuZm9vLnZpc1N0YXRlLFxuICogICAgICAgICAgICAgICB7aWR4OiAwfVxuICogICAgICAgICAgICAgKVxuICogICAgICAgICAgfVxuICogICAgICAgIH1cbiAqICAgICAgfTtcbiAqICB9XG4gKiAgcmV0dXJuIHJlZHVjZXJzKHN0YXRlLCBhY3Rpb24pO1xuICogfTtcbiAqXG4gKiBleHBvcnQgZGVmYXVsdCBjb21wb3NlZFJlZHVjZXI7XG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG4vLyBAdHMtaWdub3JlXG5jb25zdCB2aXNTdGF0ZVVwZGF0ZXJzID0gbnVsbDtcbi8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLXZhcnMgKi9cblxuZXhwb3J0IGNvbnN0IGRlZmF1bHRJbnRlcmFjdGlvbkNvbmZpZzogSW50ZXJhY3Rpb25Db25maWcgPSB7XG4gIHRvb2x0aXA6IHtcbiAgICBpZDogJ3Rvb2x0aXAnLFxuICAgIGxhYmVsOiAnaW50ZXJhY3Rpb25zLnRvb2x0aXAnLFxuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgY29uZmlnOiB7XG4gICAgICBmaWVsZHNUb1Nob3c6IHt9LFxuICAgICAgY29tcGFyZU1vZGU6IGZhbHNlLFxuICAgICAgY29tcGFyZVR5cGU6IENPTVBBUkVfVFlQRVMuQUJTT0xVVEVcbiAgICB9XG4gIH0sXG4gIGdlb2NvZGVyOiB7XG4gICAgaWQ6ICdnZW9jb2RlcicsXG4gICAgbGFiZWw6ICdpbnRlcmFjdGlvbnMuZ2VvY29kZXInLFxuICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgIHBvc2l0aW9uOiBudWxsXG4gIH0sXG4gIGJydXNoOiB7XG4gICAgaWQ6ICdicnVzaCcsXG4gICAgbGFiZWw6ICdpbnRlcmFjdGlvbnMuYnJ1c2gnLFxuICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgIGNvbmZpZzoge1xuICAgICAgLy8gc2l6ZSBpcyBpbiBrbVxuICAgICAgc2l6ZTogMC41XG4gICAgfVxuICB9LFxuICBjb29yZGluYXRlOiB7XG4gICAgaWQ6ICdjb29yZGluYXRlJyxcbiAgICBsYWJlbDogJ2ludGVyYWN0aW9ucy5jb29yZGluYXRlJyxcbiAgICBlbmFibGVkOiBmYWxzZSxcbiAgICBwb3NpdGlvbjogbnVsbFxuICB9XG59O1xuXG5leHBvcnQgY29uc3QgREVGQVVMVF9BTklNQVRJT05fQ09ORklHOiBBbmltYXRpb25Db25maWcgPSB7XG4gIGRvbWFpbjogbnVsbCxcbiAgY3VycmVudFRpbWU6IG51bGwsXG4gIHNwZWVkOiAxLFxuICBpc0FuaW1hdGluZzogZmFsc2UsXG4gIHRpbWVGb3JtYXQ6IG51bGwsXG4gIHRpbWV6b25lOiBudWxsLFxuICBkZWZhdWx0VGltZUZvcm1hdDogbnVsbFxufTtcblxuZXhwb3J0IGNvbnN0IERFRkFVTFRfRURJVE9SOiBFZGl0b3IgPSB7XG4gIG1vZGU6IEVESVRPUl9NT0RFUy5EUkFXX1BPTFlHT04sXG4gIGZlYXR1cmVzOiBbXSxcbiAgc2VsZWN0ZWRGZWF0dXJlOiBudWxsLFxuICB2aXNpYmxlOiB0cnVlXG59O1xuXG4vKipcbiAqIERlZmF1bHQgaW5pdGlhbCBgdmlzU3RhdGVgXG4gKiBAbWVtYmVyb2YgdmlzU3RhdGVVcGRhdGVyc1xuICogQGNvbnN0YW50XG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCBJTklUSUFMX1ZJU19TVEFURTogVmlzU3RhdGUgPSB7XG4gIC8vIG1hcCBpbmZvXG4gIG1hcEluZm86IHtcbiAgICB0aXRsZTogJycsXG4gICAgZGVzY3JpcHRpb246ICcnXG4gIH0sXG4gIC8vIGxheWVyc1xuICBsYXllcnM6IFtdLFxuICBsYXllckRhdGE6IFtdLFxuICBsYXllclRvQmVNZXJnZWQ6IFtdLFxuICBsYXllck9yZGVyOiBbXSxcblxuICAvLyBmaWx0ZXJzXG4gIGZpbHRlcnM6IFtdLFxuICBmaWx0ZXJUb0JlTWVyZ2VkOiBbXSxcblxuICAvLyBhIGNvbGxlY3Rpb24gb2YgbXVsdGlwbGUgZGF0YXNldFxuICBkYXRhc2V0czoge30sXG4gIGVkaXRpbmdEYXRhc2V0OiB1bmRlZmluZWQsXG5cbiAgaW50ZXJhY3Rpb25Db25maWc6IGRlZmF1bHRJbnRlcmFjdGlvbkNvbmZpZyxcbiAgaW50ZXJhY3Rpb25Ub0JlTWVyZ2VkOiB1bmRlZmluZWQsXG5cbiAgbGF5ZXJCbGVuZGluZzogJ25vcm1hbCcsXG4gIGhvdmVySW5mbzogdW5kZWZpbmVkLFxuICBjbGlja2VkOiB1bmRlZmluZWQsXG4gIG1vdXNlUG9zOiB7fSxcbiAgbWF4RGVmYXVsdFRvb2x0aXBzOiBNQVhfREVGQVVMVF9UT09MVElQUyxcblxuICAvLyB0aGlzIGlzIHVzZWQgd2hlbiB1c2VyIHNwbGl0IG1hcHNcbiAgc3BsaXRNYXBzOiBbXG4gICAgLy8gdGhpcyB3aWxsIGNvbnRhaW4gYSBsaXN0IG9mIG9iamVjdHMgdG9cbiAgICAvLyBkZXNjcmliZSB0aGUgc3RhdGUgb2YgbGF5ZXIgYXZhaWxhYmlsaXR5IGFuZCB2aXNpYmlsaXR5IGZvciBlYWNoIG1hcFxuICAgIC8vIFtcbiAgICAvLyAgIHtcbiAgICAvLyAgICAgIGxheWVyczoge2xheWVyX2lkOiB0cnVlIHwgZmFsc2V9XG4gICAgLy8gICB9XG4gICAgLy8gXVxuICBdLFxuICBzcGxpdE1hcHNUb0JlTWVyZ2VkOiBbXSxcblxuICAvLyBkZWZhdWx0cyBsYXllciBjbGFzc2VzXG4gIGxheWVyQ2xhc3NlczogTGF5ZXJDbGFzc2VzLFxuXG4gIC8vIGRlZmF1bHQgYW5pbWF0aW9uXG4gIC8vIHRpbWUgaW4gdW5peCB0aW1lc3RhbXAgKG1pbGxpc2Vjb25kcykgKHRoZSBudW1iZXIgb2Ygc2Vjb25kcyBzaW5jZSB0aGUgVW5peCBFcG9jaClcbiAgYW5pbWF0aW9uQ29uZmlnOiBERUZBVUxUX0FOSU1BVElPTl9DT05GSUcsXG5cbiAgZWRpdG9yOiBERUZBVUxUX0VESVRPUixcblxuICBmaWxlTG9hZGluZzogZmFsc2UsXG4gIGZpbGVMb2FkaW5nUHJvZ3Jlc3M6IHt9LFxuXG4gIGxvYWRlcnM6IFtdLFxuICBsb2FkT3B0aW9uczoge30sXG5cbiAgLy8gdmlzU3RhdGVNZXJnZXJzXG4gIG1lcmdlcnM6IFZJU19TVEFURV9NRVJHRVJTLFxuXG4gIC8vIGtlcGxlciBzY2hlbWFzXG4gIHNjaGVtYTogS2VwbGVyR0xTY2hlbWFcbn07XG5cbi8qKlxuICogVXBkYXRlIHN0YXRlIHdpdGggdXBkYXRlZCBsYXllciBhbmQgbGF5ZXJEYXRhXG4gKlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlU3RhdGVXaXRoTGF5ZXJBbmREYXRhKFxuICBzdGF0ZTogVmlzU3RhdGUsXG4gIHtsYXllckRhdGEsIGxheWVyLCBpZHh9OiB7bGF5ZXJEYXRhPzogYW55OyBsYXllcjogTGF5ZXI7IGlkeDogbnVtYmVyfVxuKTogVmlzU3RhdGUge1xuICByZXR1cm4ge1xuICAgIC4uLnN0YXRlLFxuICAgIGxheWVyczogc3RhdGUubGF5ZXJzLm1hcCgobHlyLCBpKSA9PiAoaSA9PT0gaWR4ID8gbGF5ZXIgOiBseXIpKSxcbiAgICBsYXllckRhdGE6IGxheWVyRGF0YVxuICAgICAgPyBzdGF0ZS5sYXllckRhdGEubWFwKChkLCBpKSA9PiAoaSA9PT0gaWR4ID8gbGF5ZXJEYXRhIDogZCkpXG4gICAgICA6IHN0YXRlLmxheWVyRGF0YVxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlU3RhdGVPbkxheWVyVmlzaWJpbGl0eUNoYW5nZTxTIGV4dGVuZHMgVmlzU3RhdGU+KHN0YXRlOiBTLCBsYXllcjogTGF5ZXIpOiBTIHtcbiAgbGV0IG5ld1N0YXRlID0gc3RhdGU7XG4gIGlmIChzdGF0ZS5zcGxpdE1hcHMubGVuZ3RoKSB7XG4gICAgbmV3U3RhdGUgPSB7XG4gICAgICAuLi5zdGF0ZSxcbiAgICAgIHNwbGl0TWFwczogbGF5ZXIuY29uZmlnLmlzVmlzaWJsZVxuICAgICAgICA/IGFkZE5ld0xheWVyc1RvU3BsaXRNYXAoc3RhdGUuc3BsaXRNYXBzLCBsYXllcilcbiAgICAgICAgOiByZW1vdmVMYXllckZyb21TcGxpdE1hcHMoc3RhdGUuc3BsaXRNYXBzLCBsYXllcilcbiAgICB9O1xuICB9XG5cbiAgaWYgKGxheWVyLmNvbmZpZy5hbmltYXRpb24uZW5hYmxlZCkge1xuICAgIG5ld1N0YXRlID0gdXBkYXRlQW5pbWF0aW9uRG9tYWluKHN0YXRlKTtcbiAgfVxuXG4gIHJldHVybiBuZXdTdGF0ZTtcbn1cblxuLyoqXG4gKiBVcGRhdGUgbGF5ZXIgYmFzZSBjb25maWc6IGRhdGFJZCwgbGFiZWwsIGNvbHVtbiwgaXNWaXNpYmxlXG4gKiBAbWVtYmVyb2YgdmlzU3RhdGVVcGRhdGVyc1xuICogQHJldHVybnMgbmV4dFN0YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsYXllckNvbmZpZ0NoYW5nZVVwZGF0ZXIoXG4gIHN0YXRlOiBWaXNTdGF0ZSxcbiAgYWN0aW9uOiBWaXNTdGF0ZUFjdGlvbnMuTGF5ZXJDb25maWdDaGFuZ2VVcGRhdGVyQWN0aW9uXG4pOiBWaXNTdGF0ZSB7XG4gIGNvbnN0IHtvbGRMYXllcn0gPSBhY3Rpb247XG4gIGNvbnN0IGlkeCA9IHN0YXRlLmxheWVycy5maW5kSW5kZXgobCA9PiBsLmlkID09PSBvbGRMYXllci5pZCk7XG4gIGNvbnN0IHByb3BzID0gT2JqZWN0LmtleXMoYWN0aW9uLm5ld0NvbmZpZyk7XG4gIGlmICh0eXBlb2YgYWN0aW9uLm5ld0NvbmZpZy5kYXRhSWQgPT09ICdzdHJpbmcnKSB7XG4gICAgY29uc3Qge2RhdGFJZCwgLi4ucmVzdENvbmZpZ30gPSBhY3Rpb24ubmV3Q29uZmlnO1xuICAgIGNvbnN0IHN0YXRlV2l0aERhdGFJZCA9IGxheWVyRGF0YUlkQ2hhbmdlVXBkYXRlcihzdGF0ZSwge1xuICAgICAgb2xkTGF5ZXIsXG4gICAgICBuZXdDb25maWc6IHtkYXRhSWR9XG4gICAgfSk7XG4gICAgY29uc3QgbmV4dExheWVyID0gc3RhdGVXaXRoRGF0YUlkLmxheWVycy5maW5kKGwgPT4gbC5pZCA9PT0gb2xkTGF5ZXIuaWQpO1xuICAgIHJldHVybiBuZXh0TGF5ZXIgJiYgT2JqZWN0LmtleXMocmVzdENvbmZpZykubGVuZ3RoXG4gICAgICA/IGxheWVyQ29uZmlnQ2hhbmdlVXBkYXRlcihzdGF0ZVdpdGhEYXRhSWQsIHtvbGRMYXllcjogbmV4dExheWVyLCBuZXdDb25maWc6IHJlc3RDb25maWd9KVxuICAgICAgOiBzdGF0ZVdpdGhEYXRhSWQ7XG4gIH1cblxuICBsZXQgbmV3TGF5ZXIgPSBvbGRMYXllci51cGRhdGVMYXllckNvbmZpZyhhY3Rpb24ubmV3Q29uZmlnKTtcblxuICBsZXQgbGF5ZXJEYXRhO1xuXG4gIC8vIGxldCBuZXdMYXllcjtcbiAgaWYgKG5ld0xheWVyLnNob3VsZENhbGN1bGF0ZUxheWVyRGF0YShwcm9wcykpIHtcbiAgICBjb25zdCBvbGRMYXllckRhdGEgPSBzdGF0ZS5sYXllckRhdGFbaWR4XTtcbiAgICBjb25zdCB1cGRhdGVMYXllckRhdGFSZXN1bHQgPSBjYWxjdWxhdGVMYXllckRhdGEobmV3TGF5ZXIsIHN0YXRlLCBvbGRMYXllckRhdGEpO1xuXG4gICAgbGF5ZXJEYXRhID0gdXBkYXRlTGF5ZXJEYXRhUmVzdWx0LmxheWVyRGF0YTtcbiAgICBuZXdMYXllciA9IHVwZGF0ZUxheWVyRGF0YVJlc3VsdC5sYXllcjtcbiAgfVxuXG4gIGxldCBuZXdTdGF0ZSA9IHN0YXRlO1xuICBpZiAoJ2lzVmlzaWJsZScgaW4gYWN0aW9uLm5ld0NvbmZpZykge1xuICAgIG5ld1N0YXRlID0gdXBkYXRlU3RhdGVPbkxheWVyVmlzaWJpbGl0eUNoYW5nZShzdGF0ZSwgbmV3TGF5ZXIpO1xuICB9XG5cbiAgcmV0dXJuIHVwZGF0ZVN0YXRlV2l0aExheWVyQW5kRGF0YShuZXdTdGF0ZSwge1xuICAgIGxheWVyOiBuZXdMYXllcixcbiAgICBsYXllckRhdGEsXG4gICAgaWR4XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBhZGRPclJlbW92ZVRleHRMYWJlbHMobmV3RmllbGRzLCB0ZXh0TGFiZWwpIHtcbiAgbGV0IG5ld1RleHRMYWJlbCA9IHRleHRMYWJlbC5zbGljZSgpO1xuXG4gIGNvbnN0IGN1cnJlbnRGaWVsZHMgPSB0ZXh0TGFiZWwubWFwKHRsID0+IHRsLmZpZWxkICYmIHRsLmZpZWxkLm5hbWUpLmZpbHRlcihkID0+IGQpO1xuXG4gIGNvbnN0IGFkZEZpZWxkcyA9IG5ld0ZpZWxkcy5maWx0ZXIoZiA9PiAhY3VycmVudEZpZWxkcy5pbmNsdWRlcyhmLm5hbWUpKTtcbiAgY29uc3QgZGVsZXRlRmllbGRzID0gY3VycmVudEZpZWxkcy5maWx0ZXIoZiA9PiAhbmV3RmllbGRzLmZpbmQoZmQgPT4gZmQubmFtZSA9PT0gZikpO1xuXG4gIC8vIGRlbGV0ZVxuICBuZXdUZXh0TGFiZWwgPSBuZXdUZXh0TGFiZWwuZmlsdGVyKHRsID0+IHRsLmZpZWxkICYmICFkZWxldGVGaWVsZHMuaW5jbHVkZXModGwuZmllbGQubmFtZSkpO1xuICBuZXdUZXh0TGFiZWwgPSAhbmV3VGV4dExhYmVsLmxlbmd0aCA/IFtERUZBVUxUX1RFWFRfTEFCRUxdIDogbmV3VGV4dExhYmVsO1xuXG4gIC8vIGFkZFxuICBuZXdUZXh0TGFiZWwgPSBbXG4gICAgLi4ubmV3VGV4dExhYmVsLmZpbHRlcih0bCA9PiB0bC5maWVsZCksXG4gICAgLi4uYWRkRmllbGRzLm1hcChhZiA9PiAoe1xuICAgICAgLi4uREVGQVVMVF9URVhUX0xBQkVMLFxuICAgICAgZmllbGQ6IGFmXG4gICAgfSkpXG4gIF07XG5cbiAgcmV0dXJuIG5ld1RleHRMYWJlbDtcbn1cblxuZnVuY3Rpb24gdXBkYXRlVGV4dExhYmVsUHJvcEFuZFZhbHVlKGlkeCwgcHJvcCwgdmFsdWUsIHRleHRMYWJlbCkge1xuICBpZiAoIXRleHRMYWJlbFtpZHhdLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgcmV0dXJuIHRleHRMYWJlbDtcbiAgfVxuXG4gIGxldCBuZXdUZXh0TGFiZWwgPSB0ZXh0TGFiZWwuc2xpY2UoKTtcblxuICBpZiAocHJvcCAmJiAodmFsdWUgfHwgdGV4dExhYmVsLmxlbmd0aCA9PT0gMSkpIHtcbiAgICBuZXdUZXh0TGFiZWwgPSB0ZXh0TGFiZWwubWFwKCh0bCwgaSkgPT4gKGkgPT09IGlkeCA/IHsuLi50bCwgW3Byb3BdOiB2YWx1ZX0gOiB0bCkpO1xuICB9IGVsc2UgaWYgKHByb3AgPT09ICdmaWVsZCcgJiYgdmFsdWUgPT09IG51bGwgJiYgdGV4dExhYmVsLmxlbmd0aCA+IDEpIHtcbiAgICAvLyByZW1vdmUgbGFiZWwgd2hlbiBmaWVsZCB2YWx1ZSBpcyBzZXQgdG8gbnVsbFxuICAgIG5ld1RleHRMYWJlbC5zcGxpY2UoaWR4LCAxKTtcbiAgfVxuXG4gIHJldHVybiBuZXdUZXh0TGFiZWw7XG59XG5cbi8qKlxuICogVXBkYXRlIGxheWVyIGJhc2UgY29uZmlnOiBkYXRhSWQsIGxhYmVsLCBjb2x1bW4sIGlzVmlzaWJsZVxuICogQG1lbWJlcm9mIHZpc1N0YXRlVXBkYXRlcnNcbiAqIEByZXR1cm5zIG5leHRTdGF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gbGF5ZXJUZXh0TGFiZWxDaGFuZ2VVcGRhdGVyKFxuICBzdGF0ZTogVmlzU3RhdGUsXG4gIGFjdGlvbjogVmlzU3RhdGVBY3Rpb25zLkxheWVyVGV4dExhYmVsQ2hhbmdlVXBkYXRlckFjdGlvblxuKTogVmlzU3RhdGUge1xuICBjb25zdCB7b2xkTGF5ZXIsIGlkeCwgcHJvcCwgdmFsdWV9ID0gYWN0aW9uO1xuICBjb25zdCB7dGV4dExhYmVsfSA9IG9sZExheWVyLmNvbmZpZztcblxuICBsZXQgbmV3VGV4dExhYmVsID0gdGV4dExhYmVsLnNsaWNlKCk7XG4gIGlmICghdGV4dExhYmVsW2lkeF0gJiYgaWR4ID09PSB0ZXh0TGFiZWwubGVuZ3RoKSB7XG4gICAgLy8gaWYgaWR4IGlzIHNldCB0byBsZW5ndGgsIGFkZCBlbXB0eSB0ZXh0IGxhYmVsXG4gICAgbmV3VGV4dExhYmVsID0gWy4uLnRleHRMYWJlbCwgREVGQVVMVF9URVhUX0xBQkVMXTtcbiAgfVxuXG4gIGlmIChpZHggPT09ICdhbGwnICYmIHByb3AgPT09ICdmaWVsZHMnKSB7XG4gICAgbmV3VGV4dExhYmVsID0gYWRkT3JSZW1vdmVUZXh0TGFiZWxzKHZhbHVlLCB0ZXh0TGFiZWwpO1xuICB9IGVsc2Uge1xuICAgIG5ld1RleHRMYWJlbCA9IHVwZGF0ZVRleHRMYWJlbFByb3BBbmRWYWx1ZShpZHgsIHByb3AsIHZhbHVlLCBuZXdUZXh0TGFiZWwpO1xuICB9XG4gIC8vIHVwZGF0ZSB0ZXh0IGxhYmVsIHByb3AgYW5kIHZhbHVlXG4gIHJldHVybiBsYXllckNvbmZpZ0NoYW5nZVVwZGF0ZXIoc3RhdGUsIHtcbiAgICBvbGRMYXllcixcbiAgICBuZXdDb25maWc6IHt0ZXh0TGFiZWw6IG5ld1RleHRMYWJlbH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlRXhpc3RpbmdMYXllcldpdGhEYXRhKGRhdGFzZXQsIGxheWVyQ2xhc3NlcywgbGF5ZXIpIHtcbiAgY29uc3QgbG9hZGVkTGF5ZXIgPSBzZXJpYWxpemVMYXllcihsYXllcik7XG4gIHJldHVybiB2YWxpZGF0ZUxheWVyV2l0aERhdGEoZGF0YXNldCwgbG9hZGVkTGF5ZXIsIGxheWVyQ2xhc3Nlcywge1xuICAgIGFsbG93RW1wdHlDb2x1bW46IHRydWVcbiAgfSk7XG59XG5cbi8qKlxuICogVXBkYXRlIGxheWVyIGNvbmZpZyBkYXRhSWRcbiAqIEBtZW1iZXJvZiB2aXNTdGF0ZVVwZGF0ZXJzXG4gKiBAcmV0dXJucyBuZXh0U3RhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxheWVyRGF0YUlkQ2hhbmdlVXBkYXRlcihcbiAgc3RhdGU6IFZpc1N0YXRlLFxuICBhY3Rpb246IHtcbiAgICBvbGRMYXllcjogTGF5ZXI7XG4gICAgbmV3Q29uZmlnOiB7XG4gICAgICBkYXRhSWQ6IHN0cmluZztcbiAgICB9O1xuICB9XG4pOiBWaXNTdGF0ZSB7XG4gIGNvbnN0IHtvbGRMYXllciwgbmV3Q29uZmlnfSA9IGFjdGlvbjtcbiAgY29uc3Qge2RhdGFJZH0gPSBuZXdDb25maWc7XG5cbiAgaWYgKCFvbGRMYXllciB8fCAhc3RhdGUuZGF0YXNldHNbZGF0YUlkXSkge1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuICBjb25zdCBpZHggPSBzdGF0ZS5sYXllcnMuZmluZEluZGV4KGwgPT4gbC5pZCA9PT0gb2xkTGF5ZXIuaWQpO1xuXG4gIGxldCBuZXdMYXllciA9IG9sZExheWVyLnVwZGF0ZUxheWVyQ29uZmlnKHtkYXRhSWR9KTtcbiAgLy8gdGhpcyBtYXkgaGFwcGVuIHdoZW4gYSBsYXllciBpcyBuZXcgKHR5cGU6IG51bGwgYW5kIG5vIGNvbHVtbnMpIGJ1dCBpdCdzIG5vdCByZWFkeSB0byBiZSBzYXZlZFxuICBpZiAobmV3TGF5ZXIuaXNWYWxpZFRvU2F2ZSgpKSB7XG4gICAgY29uc3QgdmFsaWRhdGVkID0gdmFsaWRhdGVFeGlzdGluZ0xheWVyV2l0aERhdGEoXG4gICAgICBzdGF0ZS5kYXRhc2V0c1tkYXRhSWRdLFxuICAgICAgc3RhdGUubGF5ZXJDbGFzc2VzLFxuICAgICAgbmV3TGF5ZXJcbiAgICApO1xuICAgIC8vIGlmIGNhbnQgdmFsaWRhdGUgaXQgd2l0aCBkYXRhIGNyZWF0ZSBhIG5ldyBvbmVcbiAgICBpZiAoIXZhbGlkYXRlZCkge1xuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBUT0RPOiBjaGVja2luZyBvbGRMYXllci50eXBlICE9PSBudWxsXG4gICAgICBuZXdMYXllciA9IG5ldyBzdGF0ZS5sYXllckNsYXNzZXNbb2xkTGF5ZXIudHlwZV0oe2RhdGFJZCwgaWQ6IG9sZExheWVyLmlkfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld0xheWVyID0gdmFsaWRhdGVkO1xuICAgIH1cbiAgfVxuXG4gIG5ld0xheWVyID0gbmV3TGF5ZXIudXBkYXRlTGF5ZXJDb25maWcoe1xuICAgIGlzVmlzaWJsZTogb2xkTGF5ZXIuY29uZmlnLmlzVmlzaWJsZSxcbiAgICBpc0NvbmZpZ0FjdGl2ZTogdHJ1ZVxuICB9KTtcblxuICBuZXdMYXllci51cGRhdGVMYXllckRvbWFpbihzdGF0ZS5kYXRhc2V0cyk7XG4gIGNvbnN0IHtsYXllckRhdGEsIGxheWVyfSA9IGNhbGN1bGF0ZUxheWVyRGF0YShuZXdMYXllciwgc3RhdGUsIHVuZGVmaW5lZCk7XG5cbiAgcmV0dXJuIHVwZGF0ZVN0YXRlV2l0aExheWVyQW5kRGF0YShzdGF0ZSwge2xheWVyRGF0YSwgbGF5ZXIsIGlkeH0pO1xufVxuXG5mdW5jdGlvbiBzZXRJbml0aWFsTGF5ZXJDb25maWcobGF5ZXIsIGRhdGFzZXRzLCBsYXllckNsYXNzZXMpIHtcbiAgbGV0IG5ld0xheWVyID0gbGF5ZXI7XG4gIGlmICghT2JqZWN0LmtleXMoZGF0YXNldHMpLmxlbmd0aCkge1xuICAgIC8vIG5vIGRhdGEgaXMgbG9hZGVkXG4gICAgcmV0dXJuIGxheWVyO1xuICB9XG4gIGlmICghbGF5ZXIuY29uZmlnLmRhdGFJZCkge1xuICAgIC8vIHNldCBsYXllciBkYXRhSWRcbiAgICBuZXdMYXllciA9IGxheWVyLnVwZGF0ZUxheWVyQ29uZmlnKHtkYXRhSWQ6IE9iamVjdC5rZXlzKGRhdGFzZXRzKVswXX0pO1xuICB9XG4gIGNvbnN0IGRhdGFzZXQgPSBkYXRhc2V0c1tuZXdMYXllci5jb25maWcuZGF0YUlkXTtcbiAgaWYgKCFkYXRhc2V0KSB7XG4gICAgcmV0dXJuIGxheWVyO1xuICB9XG5cbiAgLy8gZmluZCBkZWZhdXQgbGF5ZXIgcHJvcHNcbiAgY29uc3QgcmVzdWx0ID1cbiAgICB0eXBlb2YgbGF5ZXJDbGFzc2VzW25ld0xheWVyLnR5cGVdLmZpbmREZWZhdWx0TGF5ZXJQcm9wcyA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgPyBsYXllckNsYXNzZXNbbmV3TGF5ZXIudHlwZV0uZmluZERlZmF1bHRMYXllclByb3BzKGRhdGFzZXQsIFtdKVxuICAgICAgOiB7cHJvcHM6IFtdfTtcblxuICAvLyBhbiBhcnJheSBvZiBwb3NzaWJsZSBwcm9wcywgdXNlIDFzdCBvbmVcbiAgY29uc3QgcHJvcHMgPSBBcnJheS5pc0FycmF5KHJlc3VsdCkgPyByZXN1bHQgOiByZXN1bHQucHJvcHMgfHwgW107XG5cbiAgaWYgKHByb3BzLmxlbmd0aCkge1xuICAgIG5ld0xheWVyID0gbmV3IGxheWVyQ2xhc3Nlc1tsYXllci50eXBlXSh7XG4gICAgICAuLi5wcm9wc1swXSxcbiAgICAgIGxhYmVsOiBuZXdMYXllci5jb25maWcubGFiZWwsXG4gICAgICBkYXRhSWQ6IG5ld0xheWVyLmNvbmZpZy5kYXRhSWQsXG4gICAgICBpc1Zpc2libGU6IHRydWUsXG4gICAgICBpc0NvbmZpZ0FjdGl2ZTogbmV3TGF5ZXIuY29uZmlnLmlzQ29uZmlnQWN0aXZlXG4gICAgfSk7XG5cbiAgICByZXR1cm4gdHlwZW9mIG5ld0xheWVyLnNldEluaXRpYWxMYXllckNvbmZpZyA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgPyBuZXdMYXllci5zZXRJbml0aWFsTGF5ZXJDb25maWcoZGF0YXNldClcbiAgICAgIDogbmV3TGF5ZXI7XG4gIH1cblxuICByZXR1cm4gbmV3TGF5ZXI7XG59XG4vKipcbiAqIFVwZGF0ZSBsYXllciB0eXBlLiBQcmV2aWV3cyBsYXllciBjb25maWcgd2lsbCBiZSBjb3BpZWQgaWYgYXBwbGljYWJsZS5cbiAqIEBtZW1iZXJvZiB2aXNTdGF0ZVVwZGF0ZXJzXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsYXllclR5cGVDaGFuZ2VVcGRhdGVyKFxuICBzdGF0ZTogVmlzU3RhdGUsXG4gIGFjdGlvbjogVmlzU3RhdGVBY3Rpb25zLkxheWVyVHlwZUNoYW5nZVVwZGF0ZXJBY3Rpb25cbik6IFZpc1N0YXRlIHtcbiAgY29uc3Qge29sZExheWVyLCBuZXdUeXBlfSA9IGFjdGlvbjtcbiAgaWYgKCFvbGRMYXllcikge1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuICBjb25zdCBvbGRJZCA9IG9sZExheWVyLmlkO1xuICBjb25zdCBpZHggPSBzdGF0ZS5sYXllcnMuZmluZEluZGV4KGwgPT4gbC5pZCA9PT0gb2xkSWQpO1xuXG4gIGlmICghc3RhdGUubGF5ZXJDbGFzc2VzW25ld1R5cGVdKSB7XG4gICAgQ29uc29sZS5lcnJvcihgJHtuZXdUeXBlfSBpcyBub3QgYSB2YWxpZCBsYXllciB0eXBlYCk7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG4gIGxldCBuZXdMYXllciA9IG5ldyBzdGF0ZS5sYXllckNsYXNzZXNbbmV3VHlwZV0oe1xuICAgIC8vIGtlZXAgb2xkIGxheWVyIGxhYmxlIGFuZCBpc0NvbmZpZ0FjdGl2ZVxuICAgIGxhYmVsOiBvbGRMYXllci5jb25maWcubGFiZWwsXG4gICAgaXNDb25maWdBY3RpdmU6IG9sZExheWVyLmNvbmZpZy5pc0NvbmZpZ0FjdGl2ZVxuICB9KTtcblxuICBpZiAoIW9sZExheWVyLnR5cGUpIHtcbiAgICAvLyBpZiBzZXR0aW5nIGxheWVyIHR5cGUgb24gYW4gZW1wdHkgbGF5ZXJcbiAgICBuZXdMYXllciA9IHNldEluaXRpYWxMYXllckNvbmZpZyhuZXdMYXllciwgc3RhdGUuZGF0YXNldHMsIHN0YXRlLmxheWVyQ2xhc3Nlcyk7XG4gIH0gZWxzZSB7XG4gICAgLy8gZ2V0IGEgbWludCBsYXllciwgd2l0aCBuZXcgaWQgYW5kIHR5cGVcbiAgICAvLyBiZWNhdXNlIGRlY2suZ2wgdXNlcyBpZCB0byBtYXRjaCBiZXR3ZWVuIG5ldyBhbmQgb2xkIGxheWVyLlxuICAgIC8vIElmIHR5cGUgaGFzIGNoYW5nZWQgYnV0IGlkIGlzIHRoZSBzYW1lLCBpdCB3aWxsIGJyZWFrXG4gICAgbmV3TGF5ZXIuYXNzaWduQ29uZmlnVG9MYXllcihvbGRMYXllci5jb25maWcsIG9sZExheWVyLnZpc0NvbmZpZ1NldHRpbmdzKTtcbiAgICBuZXdMYXllci51cGRhdGVMYXllckRvbWFpbihzdGF0ZS5kYXRhc2V0cyk7XG4gIH1cblxuICBjb25zdCB7Y2xpY2tlZCwgaG92ZXJJbmZvfSA9IHN0YXRlO1xuXG4gIGxldCBuZXdTdGF0ZSA9IHtcbiAgICAuLi5zdGF0ZSxcbiAgICBjbGlja2VkOiBvbGRMYXllci5pc0xheWVySG92ZXJlZChjbGlja2VkKSA/IHVuZGVmaW5lZCA6IGNsaWNrZWQsXG4gICAgaG92ZXJJbmZvOiBvbGRMYXllci5pc0xheWVySG92ZXJlZChob3ZlckluZm8pID8gdW5kZWZpbmVkIDogaG92ZXJJbmZvXG4gIH07XG5cbiAgY29uc3Qge2xheWVyRGF0YSwgbGF5ZXJ9ID0gY2FsY3VsYXRlTGF5ZXJEYXRhKG5ld0xheWVyLCBuZXdTdGF0ZSk7XG4gIG5ld1N0YXRlID0gdXBkYXRlU3RhdGVXaXRoTGF5ZXJBbmREYXRhKG5ld1N0YXRlLCB7bGF5ZXJEYXRhLCBsYXllciwgaWR4fSk7XG5cbiAgaWYgKGxheWVyLmNvbmZpZy5hbmltYXRpb24uZW5hYmxlZCB8fCBvbGRMYXllci5jb25maWcuYW5pbWF0aW9uLmVuYWJsZWQpIHtcbiAgICBuZXdTdGF0ZSA9IHVwZGF0ZUFuaW1hdGlvbkRvbWFpbihuZXdTdGF0ZSk7XG4gIH1cblxuICAvLyB1cGRhdGUgc3BsaXRNYXAgbGF5ZXIgaWRcbiAgaWYgKHN0YXRlLnNwbGl0TWFwcy5sZW5ndGgpIHtcbiAgICBuZXdTdGF0ZSA9IHtcbiAgICAgIC4uLm5ld1N0YXRlLFxuICAgICAgc3BsaXRNYXBzOiBuZXdTdGF0ZS5zcGxpdE1hcHMubWFwKHNldHRpbmdzID0+IHtcbiAgICAgICAgY29uc3Qge1tvbGRJZF06IG9sZExheWVyTWFwLCAuLi5vdGhlckxheWVyc30gPSBzZXR0aW5ncy5sYXllcnM7XG4gICAgICAgIHJldHVybiBvbGRJZCBpbiBzZXR0aW5ncy5sYXllcnNcbiAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgLi4uc2V0dGluZ3MsXG4gICAgICAgICAgICAgIGxheWVyczoge1xuICAgICAgICAgICAgICAgIC4uLm90aGVyTGF5ZXJzLFxuICAgICAgICAgICAgICAgIFtsYXllci5pZF06IG9sZExheWVyTWFwXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICA6IHNldHRpbmdzO1xuICAgICAgfSlcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIG5ld1N0YXRlO1xufVxuXG4vKipcbiAqIFVwZGF0ZSBsYXllciB2aXN1YWwgY2hhbm5lbFxuICogQG1lbWJlcm9mIHZpc1N0YXRlVXBkYXRlcnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IG5leHRTdGF0ZVxuICogQHB1YmxpY1xuICovXG5leHBvcnQgZnVuY3Rpb24gbGF5ZXJWaXN1YWxDaGFubmVsQ2hhbmdlVXBkYXRlcihcbiAgc3RhdGU6IFZpc1N0YXRlLFxuICBhY3Rpb246IFZpc1N0YXRlQWN0aW9ucy5MYXllclZpc3VhbENoYW5uZWxDb25maWdDaGFuZ2VVcGRhdGVyQWN0aW9uXG4pOiBWaXNTdGF0ZSB7XG4gIGNvbnN0IHtvbGRMYXllciwgbmV3Q29uZmlnLCBjaGFubmVsfSA9IGFjdGlvbjtcbiAgaWYgKCFvbGRMYXllci5jb25maWcuZGF0YUlkKSB7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG4gIGNvbnN0IGRhdGFzZXQgPSBzdGF0ZS5kYXRhc2V0c1tvbGRMYXllci5jb25maWcuZGF0YUlkXTtcblxuICBjb25zdCBpZHggPSBzdGF0ZS5sYXllcnMuZmluZEluZGV4KGwgPT4gbC5pZCA9PT0gb2xkTGF5ZXIuaWQpO1xuICBjb25zdCBuZXdMYXllciA9IG9sZExheWVyLnVwZGF0ZUxheWVyQ29uZmlnKG5ld0NvbmZpZyk7XG5cbiAgbmV3TGF5ZXIudXBkYXRlTGF5ZXJWaXN1YWxDaGFubmVsKGRhdGFzZXQsIGNoYW5uZWwpO1xuXG4gIGNvbnN0IG9sZExheWVyRGF0YSA9IHN0YXRlLmxheWVyRGF0YVtpZHhdO1xuICBjb25zdCB7bGF5ZXJEYXRhLCBsYXllcn0gPSBjYWxjdWxhdGVMYXllckRhdGEobmV3TGF5ZXIsIHN0YXRlLCBvbGRMYXllckRhdGEpO1xuXG4gIHJldHVybiB1cGRhdGVTdGF0ZVdpdGhMYXllckFuZERhdGEoc3RhdGUsIHtsYXllckRhdGEsIGxheWVyLCBpZHh9KTtcbn1cblxuLyoqXG4gKiBVcGRhdGUgbGF5ZXIgYHZpc0NvbmZpZ2BcbiAqIEBtZW1iZXJvZiB2aXNTdGF0ZVVwZGF0ZXJzXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsYXllclZpc0NvbmZpZ0NoYW5nZVVwZGF0ZXIoXG4gIHN0YXRlOiBWaXNTdGF0ZSxcbiAgYWN0aW9uOiBWaXNTdGF0ZUFjdGlvbnMuTGF5ZXJWaXNDb25maWdDaGFuZ2VVcGRhdGVyQWN0aW9uXG4pOiBWaXNTdGF0ZSB7XG4gIGNvbnN0IHtvbGRMYXllcn0gPSBhY3Rpb247XG4gIGNvbnN0IGlkeCA9IHN0YXRlLmxheWVycy5maW5kSW5kZXgobCA9PiBsLmlkID09PSBvbGRMYXllci5pZCk7XG4gIGNvbnN0IHByb3BzID0gT2JqZWN0LmtleXMoYWN0aW9uLm5ld1Zpc0NvbmZpZyk7XG4gIGNvbnN0IG5ld1Zpc0NvbmZpZyA9IHtcbiAgICAuLi5vbGRMYXllci5jb25maWcudmlzQ29uZmlnLFxuICAgIC4uLmFjdGlvbi5uZXdWaXNDb25maWdcbiAgfTtcblxuICBjb25zdCBuZXdMYXllciA9IG9sZExheWVyLnVwZGF0ZUxheWVyQ29uZmlnKHt2aXNDb25maWc6IG5ld1Zpc0NvbmZpZ30pO1xuXG4gIGlmIChuZXdMYXllci5zaG91bGRDYWxjdWxhdGVMYXllckRhdGEocHJvcHMpKSB7XG4gICAgY29uc3Qgb2xkTGF5ZXJEYXRhID0gc3RhdGUubGF5ZXJEYXRhW2lkeF07XG4gICAgY29uc3Qge2xheWVyRGF0YSwgbGF5ZXJ9ID0gY2FsY3VsYXRlTGF5ZXJEYXRhKG5ld0xheWVyLCBzdGF0ZSwgb2xkTGF5ZXJEYXRhKTtcbiAgICByZXR1cm4gdXBkYXRlU3RhdGVXaXRoTGF5ZXJBbmREYXRhKHN0YXRlLCB7bGF5ZXJEYXRhLCBsYXllciwgaWR4fSk7XG4gIH1cblxuICByZXR1cm4gdXBkYXRlU3RhdGVXaXRoTGF5ZXJBbmREYXRhKHN0YXRlLCB7bGF5ZXI6IG5ld0xheWVyLCBpZHh9KTtcbn1cblxuLyoqXG4gKiBVcGRhdGUgZmlsdGVyIHByb3BlcnR5XG4gKiBAbWVtYmVyb2YgdmlzU3RhdGVVcGRhdGVyc1xuICogQHB1YmxpY1xuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0RmlsdGVyQW5pbWF0aW9uVGltZVVwZGF0ZXIoXG4gIHN0YXRlOiBWaXNTdGF0ZSxcbiAgYWN0aW9uOiBWaXNTdGF0ZUFjdGlvbnMuU2V0RmlsdGVyQW5pbWF0aW9uVGltZVVwZGF0ZXJBY3Rpb25cbik6IFZpc1N0YXRlIHtcbiAgcmV0dXJuIHNldEZpbHRlclVwZGF0ZXIoc3RhdGUsIGFjdGlvbik7XG59XG5cbi8qKlxuICogVXBkYXRlIGZpbHRlciBhbmltYXRpb24gd2luZG93XG4gKiBAbWVtYmVyb2YgdmlzU3RhdGVVcGRhdGVyc1xuICogQHB1YmxpY1xuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0RmlsdGVyQW5pbWF0aW9uV2luZG93VXBkYXRlcihcbiAgc3RhdGU6IFZpc1N0YXRlLFxuICB7aWQsIGFuaW1hdGlvbldpbmRvd306IFZpc1N0YXRlQWN0aW9ucy5TZXRGaWx0ZXJBbmltYXRpb25XaW5kb3dVcGRhdGVyQWN0aW9uXG4pOiBWaXNTdGF0ZSB7XG4gIHJldHVybiB7XG4gICAgLi4uc3RhdGUsXG4gICAgZmlsdGVyczogc3RhdGUuZmlsdGVycy5tYXAoZiA9PlxuICAgICAgZi5pZCA9PT0gaWRcbiAgICAgICAgPyB7XG4gICAgICAgICAgICAuLi5mLFxuICAgICAgICAgICAgYW5pbWF0aW9uV2luZG93XG4gICAgICAgICAgfVxuICAgICAgICA6IGZcbiAgICApXG4gIH07XG59XG4vKipcbiAqIFVwZGF0ZSBmaWx0ZXIgcHJvcGVydHlcbiAqIEBtZW1iZXJvZiB2aXNTdGF0ZVVwZGF0ZXJzXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRGaWx0ZXJVcGRhdGVyKFxuICBzdGF0ZTogVmlzU3RhdGUsXG4gIGFjdGlvbjogVmlzU3RhdGVBY3Rpb25zLlNldEZpbHRlclVwZGF0ZXJBY3Rpb25cbik6IFZpc1N0YXRlIHtcbiAgY29uc3Qge2lkeCwgcHJvcCwgdmFsdWUsIHZhbHVlSW5kZXggPSAwfSA9IGFjdGlvbjtcbiAgY29uc3Qgb2xkRmlsdGVyID0gc3RhdGUuZmlsdGVyc1tpZHhdO1xuXG4gIGlmICghb2xkRmlsdGVyKSB7XG4gICAgQ29uc29sZS5lcnJvcihgZmlsdGVycy4ke2lkeH0gaXMgdW5kZWZpbmVkYCk7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG4gIGxldCBuZXdGaWx0ZXIgPSBzZXQoW3Byb3BdLCB2YWx1ZSwgb2xkRmlsdGVyKTtcbiAgbGV0IG5ld1N0YXRlID0gc3RhdGU7XG5cbiAgY29uc3Qge2RhdGFJZH0gPSBuZXdGaWx0ZXI7XG5cbiAgLy8gRW5zdXJpbmcgYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuICBsZXQgZGF0YXNldElkcyA9IHRvQXJyYXkoZGF0YUlkKTtcblxuICBzd2l0Y2ggKHByb3ApIHtcbiAgICAvLyBUT0RPOiBOZXh0IFBSIGZvciBVSSBpZiB3ZSB1cGRhdGUgZGF0YUlkLCB3ZSBuZWVkIHRvIGNvbnNpZGVyIHR3byBjYXNlczpcbiAgICAvLyAxLiBkYXRhSWQgaXMgZW1wdHk6IGNyZWF0ZSBhIGRlZmF1bHQgZmlsdGVyXG4gICAgLy8gMi4gQWRkIGEgbmV3IGRhdGFzZXQgaWRcbiAgICBjYXNlIEZJTFRFUl9VUERBVEVSX1BST1BTLmRhdGFJZDpcbiAgICAgIC8vIGlmIHRyeWluZyB0byB1cGRhdGUgZmlsdGVyIGRhdGFJZC4gY3JlYXRlIGFuIGVtcHR5IG5ldyBmaWx0ZXJcbiAgICAgIG5ld0ZpbHRlciA9IHVwZGF0ZUZpbHRlckRhdGFJZChkYXRhSWQpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIEZJTFRFUl9VUERBVEVSX1BST1BTLm5hbWU6XG4gICAgICAvLyB3ZSBhcmUgc3VwcG9ydGluZyB0aGUgY3VycmVudCBmdW5jdGlvbmFsaXR5XG4gICAgICAvLyBUT0RPOiBOZXh0IFBSIGZvciBVSSBmaWx0ZXIgbmFtZSB3aWxsIG9ubHkgdXBkYXRlIGZpbHRlciBuYW1lIGJ1dCBpdCB3b24ndCBoYXZlIHNpZGUgZWZmZWN0c1xuICAgICAgLy8gd2UgYXJlIGdvbm5hIHVzZSBwYWlyIG9mIGRhdGFzZXRzIGFuZCBmaWVsZElkeCB0byB1cGRhdGUgdGhlIGZpbHRlclxuICAgICAgY29uc3QgZGF0YXNldElkID0gbmV3RmlsdGVyLmRhdGFJZFt2YWx1ZUluZGV4XTtcbiAgICAgIGNvbnN0IHtmaWx0ZXI6IHVwZGF0ZWRGaWx0ZXIsIGRhdGFzZXQ6IG5ld0RhdGFzZXR9ID0gYXBwbHlGaWx0ZXJGaWVsZE5hbWUoXG4gICAgICAgIG5ld0ZpbHRlcixcbiAgICAgICAgc3RhdGUuZGF0YXNldHNbZGF0YXNldElkXSxcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIHZhbHVlSW5kZXgsXG4gICAgICAgIHttZXJnZURvbWFpbjogZmFsc2V9XG4gICAgICApO1xuICAgICAgaWYgKCF1cGRhdGVkRmlsdGVyKSB7XG4gICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICAgIH1cblxuICAgICAgbmV3RmlsdGVyID0gdXBkYXRlZEZpbHRlcjtcblxuICAgICAgaWYgKG5ld0ZpbHRlci5ncHUpIHtcbiAgICAgICAgbmV3RmlsdGVyID0gc2V0RmlsdGVyR3B1TW9kZShuZXdGaWx0ZXIsIHN0YXRlLmZpbHRlcnMpO1xuICAgICAgICBuZXdGaWx0ZXIgPSBhc3NpZ25HcHVDaGFubmVsKG5ld0ZpbHRlciwgc3RhdGUuZmlsdGVycyk7XG4gICAgICB9XG5cbiAgICAgIG5ld1N0YXRlID0gc2V0KFsnZGF0YXNldHMnLCBkYXRhc2V0SWRdLCBuZXdEYXRhc2V0LCBzdGF0ZSk7XG5cbiAgICAgIC8vIG9ubHkgZmlsdGVyIHRoZSBjdXJyZW50IGRhdGFzZXRcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgRklMVEVSX1VQREFURVJfUFJPUFMubGF5ZXJJZDpcbiAgICAgIC8vIFdlIG5lZWQgdG8gdXBkYXRlIG9ubHkgZGF0YXNldElkL3MgaWYgd2UgaGF2ZSBhZGRlZC9yZW1vdmVkIGxheWVyc1xuICAgICAgLy8gLSBjaGVjayBmb3IgbGF5ZXJJZCBjaGFuZ2VzIChYT1Igd29ya3MgYmVjYXVzZSBvZiBzdHJpbmcgdmFsdWVzKVxuICAgICAgLy8gaWYgbm8gZGlmZmVyZW5jZXMgYmV0d2VlbiBsYXllcklkcywgZG9uJ3QgZG8gYW55IGZpbHRlcmluZ1xuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgY29uc3QgbGF5ZXJJZERpZmZlcmVuY2UgPSB4b3IobmV3RmlsdGVyLmxheWVySWQsIG9sZEZpbHRlci5sYXllcklkKTtcblxuICAgICAgY29uc3QgbGF5ZXJEYXRhSWRzID0gdW5pcShcbiAgICAgICAgbGF5ZXJJZERpZmZlcmVuY2VcbiAgICAgICAgICAubWFwKGxpZCA9PlxuICAgICAgICAgICAgZ2V0KFxuICAgICAgICAgICAgICBzdGF0ZS5sYXllcnMuZmluZChsID0+IGwuaWQgPT09IGxpZCksXG4gICAgICAgICAgICAgIFsnY29uZmlnJywgJ2RhdGFJZCddXG4gICAgICAgICAgICApXG4gICAgICAgICAgKVxuICAgICAgICAgIC5maWx0ZXIoZCA9PiBkKVxuICAgICAgKTtcblxuICAgICAgLy8gb25seSBmaWx0ZXIgZGF0YXNldHNJZHNcbiAgICAgIGRhdGFzZXRJZHMgPSBsYXllckRhdGFJZHM7XG5cbiAgICAgIC8vIFVwZGF0ZSBuZXdGaWx0ZXIgZGF0YUlkc1xuICAgICAgY29uc3QgbmV3RGF0YUlkcyA9IHVuaXEoXG4gICAgICAgIG5ld0ZpbHRlci5sYXllcklkXG4gICAgICAgICAgLm1hcChsaWQgPT5cbiAgICAgICAgICAgIGdldChcbiAgICAgICAgICAgICAgc3RhdGUubGF5ZXJzLmZpbmQobCA9PiBsLmlkID09PSBsaWQpLFxuICAgICAgICAgICAgICBbJ2NvbmZpZycsICdkYXRhSWQnXVxuICAgICAgICAgICAgKVxuICAgICAgICAgIClcbiAgICAgICAgICAuZmlsdGVyKGQgPT4gZClcbiAgICAgICk7XG5cbiAgICAgIG5ld0ZpbHRlciA9IHtcbiAgICAgICAgLi4ubmV3RmlsdGVyLFxuICAgICAgICBkYXRhSWQ6IG5ld0RhdGFJZHNcbiAgICAgIH07XG5cbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBicmVhaztcbiAgfVxuXG4gIGNvbnN0IGVubGFyZ2VkRmlsdGVyID0gc3RhdGUuZmlsdGVycy5maW5kKGYgPT4gZi5lbmxhcmdlZCk7XG5cbiAgaWYgKGVubGFyZ2VkRmlsdGVyICYmIGVubGFyZ2VkRmlsdGVyLmlkICE9PSBuZXdGaWx0ZXIuaWQpIHtcbiAgICAvLyB0aGVyZSBzaG91bGQgYmUgb25seSBvbmUgZW5sYXJnZWQgZmlsdGVyXG4gICAgbmV3RmlsdGVyLmVubGFyZ2VkID0gZmFsc2U7XG4gIH1cblxuICAvLyBzYXZlIG5ldyBmaWx0ZXJzIHRvIG5ld1N0YXRlXG4gIG5ld1N0YXRlID0gc2V0KFsnZmlsdGVycycsIGlkeF0sIG5ld0ZpbHRlciwgbmV3U3RhdGUpO1xuXG4gIC8vIGlmIHdlIGFyZSBjdXJyZW50bHkgc2V0dGluZyBhIHByb3AgdGhhdCBvbmx5IHJlcXVpcmVzIHRvIGZpbHRlciB0aGUgY3VycmVudFxuICAvLyBkYXRhc2V0IHdlIHdpbGwgcGFzcyBvbmx5IHRoZSBjdXJyZW50IGRhdGFzZXQgdG8gYXBwbHlGaWx0ZXJzVG9EYXRhc2V0cyBhbmRcbiAgLy8gdXBkYXRlQWxsTGF5ZXJEb21haW5EYXRhIG90aGVyd2lzZSB3ZSBwYXNzIHRoZSBhbGwgbGlzdCBvZiBkYXRhc2V0cyBhcyBkZWZpbmVkIGluIGRhdGFJZFxuICBjb25zdCBkYXRhc2V0SWRzVG9GaWx0ZXIgPSBMSU1JVEVEX0ZJTFRFUl9FRkZFQ1RfUFJPUFNbcHJvcF1cbiAgICA/IFtkYXRhc2V0SWRzW3ZhbHVlSW5kZXhdXVxuICAgIDogZGF0YXNldElkcztcblxuICAvLyBmaWx0ZXIgZGF0YVxuICBjb25zdCBmaWx0ZXJlZERhdGFzZXRzID0gYXBwbHlGaWx0ZXJzVG9EYXRhc2V0cyhcbiAgICBkYXRhc2V0SWRzVG9GaWx0ZXIsXG4gICAgbmV3U3RhdGUuZGF0YXNldHMsXG4gICAgbmV3U3RhdGUuZmlsdGVycyxcbiAgICBuZXdTdGF0ZS5sYXllcnNcbiAgKTtcblxuICBuZXdTdGF0ZSA9IHNldChbJ2RhdGFzZXRzJ10sIGZpbHRlcmVkRGF0YXNldHMsIG5ld1N0YXRlKTtcbiAgLy8gZGF0YUlkIGlzIGFuIGFycmF5XG4gIC8vIHBhc3Mgb25seSB0aGUgZGF0YXNldCB3ZSBuZWVkIHRvIHVwZGF0ZVxuICBuZXdTdGF0ZSA9IHVwZGF0ZUFsbExheWVyRG9tYWluRGF0YShuZXdTdGF0ZSwgZGF0YXNldElkc1RvRmlsdGVyLCBuZXdGaWx0ZXIpO1xuXG4gIHJldHVybiBuZXdTdGF0ZTtcbn1cblxuLyoqXG4gKiBTZXQgdGhlIHByb3BlcnR5IG9mIGEgZmlsdGVyIHBsb3RcbiAqIEBtZW1iZXJvZiB2aXNTdGF0ZVVwZGF0ZXJzXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCBzZXRGaWx0ZXJQbG90VXBkYXRlciA9IChcbiAgc3RhdGU6IFZpc1N0YXRlLFxuICB7aWR4LCBuZXdQcm9wLCB2YWx1ZUluZGV4ID0gMH06IFZpc1N0YXRlQWN0aW9ucy5TZXRGaWx0ZXJQbG90VXBkYXRlckFjdGlvblxuKTogVmlzU3RhdGUgPT4ge1xuICBsZXQgbmV3RmlsdGVyID0gey4uLnN0YXRlLmZpbHRlcnNbaWR4XSwgLi4ubmV3UHJvcH07XG4gIGNvbnN0IHByb3AgPSBPYmplY3Qua2V5cyhuZXdQcm9wKVswXTtcbiAgaWYgKHByb3AgPT09ICd5QXhpcycpIHtcbiAgICBjb25zdCBwbG90VHlwZSA9IGdldERlZmF1bHRGaWx0ZXJQbG90VHlwZShuZXdGaWx0ZXIpO1xuICAgIC8vIFRPRE86IHBsb3QgaXMgbm90IHN1cHBvcnRlZCBpbiBtdWx0aSBkYXRhc2V0IGZpbHRlciBmb3Igbm93XG4gICAgaWYgKHBsb3RUeXBlKSB7XG4gICAgICBuZXdGaWx0ZXIgPSB7XG4gICAgICAgIC4uLm5ld0ZpbHRlcixcbiAgICAgICAgLi4uZ2V0RmlsdGVyUGxvdCh7Li4ubmV3RmlsdGVyLCBwbG90VHlwZX0sIHN0YXRlLmRhdGFzZXRzW25ld0ZpbHRlci5kYXRhSWRbdmFsdWVJbmRleF1dKSxcbiAgICAgICAgcGxvdFR5cGVcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICAuLi5zdGF0ZSxcbiAgICBmaWx0ZXJzOiBzdGF0ZS5maWx0ZXJzLm1hcCgoZiwgaSkgPT4gKGkgPT09IGlkeCA/IG5ld0ZpbHRlciA6IGYpKVxuICB9O1xufTtcblxuLyoqXG4gKiBBZGQgYSBuZXcgZmlsdGVyXG4gKiBAbWVtYmVyb2YgdmlzU3RhdGVVcGRhdGVyc1xuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgYWRkRmlsdGVyVXBkYXRlciA9IChcbiAgc3RhdGU6IFZpc1N0YXRlLFxuICBhY3Rpb246IFZpc1N0YXRlQWN0aW9ucy5BZGRGaWx0ZXJVcGRhdGVyQWN0aW9uXG4pOiBWaXNTdGF0ZSA9PlxuICAhYWN0aW9uLmRhdGFJZFxuICAgID8gc3RhdGVcbiAgICA6IHtcbiAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgIGZpbHRlcnM6IFsuLi5zdGF0ZS5maWx0ZXJzLCBnZXREZWZhdWx0RmlsdGVyKGFjdGlvbi5kYXRhSWQpXVxuICAgICAgfTtcblxuLyoqXG4gKiBTZXQgbGF5ZXIgY29sb3IgcGFsZXR0ZSB1aSBzdGF0ZVxuICogQG1lbWJlcm9mIHZpc1N0YXRlVXBkYXRlcnNcbiAqL1xuZXhwb3J0IGNvbnN0IGxheWVyQ29sb3JVSUNoYW5nZVVwZGF0ZXIgPSAoXG4gIHN0YXRlOiBWaXNTdGF0ZSxcbiAge29sZExheWVyLCBwcm9wLCBuZXdDb25maWd9OiBWaXNTdGF0ZUFjdGlvbnMuTGF5ZXJDb2xvclVJQ2hhbmdlVXBkYXRlckFjdGlvblxuKTogVmlzU3RhdGUgPT4ge1xuICBjb25zdCBvbGRWaXhDb25maWcgPSBvbGRMYXllci5jb25maWcudmlzQ29uZmlnW3Byb3BdO1xuICBjb25zdCBuZXdMYXllciA9IG9sZExheWVyLnVwZGF0ZUxheWVyQ29sb3JVSShwcm9wLCBuZXdDb25maWcpO1xuICBjb25zdCBuZXdWaXNDb25maWcgPSBuZXdMYXllci5jb25maWcudmlzQ29uZmlnW3Byb3BdO1xuICBpZiAob2xkVml4Q29uZmlnICE9PSBuZXdWaXNDb25maWcpIHtcbiAgICByZXR1cm4gbGF5ZXJWaXNDb25maWdDaGFuZ2VVcGRhdGVyKHN0YXRlLCB7XG4gICAgICBvbGRMYXllcixcbiAgICAgIG5ld1Zpc0NvbmZpZzoge1xuICAgICAgICBbcHJvcF06IG5ld1Zpc0NvbmZpZ1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHJldHVybiB7XG4gICAgLi4uc3RhdGUsXG4gICAgbGF5ZXJzOiBzdGF0ZS5sYXllcnMubWFwKGwgPT4gKGwuaWQgPT09IG9sZExheWVyLmlkID8gbmV3TGF5ZXIgOiBsKSlcbiAgfTtcbn07XG5cbi8qKlxuICogU3RhcnQgYW5kIGVuZCBmaWx0ZXIgYW5pbWF0aW9uXG4gKiBAbWVtYmVyb2YgdmlzU3RhdGVVcGRhdGVyc1xuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgdG9nZ2xlRmlsdGVyQW5pbWF0aW9uVXBkYXRlciA9IChcbiAgc3RhdGU6IFZpc1N0YXRlLFxuICBhY3Rpb246IFZpc1N0YXRlQWN0aW9ucy5Ub2dnbGVGaWx0ZXJBbmltYXRpb25VcGRhdGVyQWN0aW9uXG4pOiBWaXNTdGF0ZSA9PiAoe1xuICAuLi5zdGF0ZSxcbiAgZmlsdGVyczogc3RhdGUuZmlsdGVycy5tYXAoKGYsIGkpID0+IChpID09PSBhY3Rpb24uaWR4ID8gey4uLmYsIGlzQW5pbWF0aW5nOiAhZi5pc0FuaW1hdGluZ30gOiBmKSlcbn0pO1xuXG4vKipcbiAqIEBtZW1iZXJvZiB2aXNTdGF0ZVVwZGF0ZXJzXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCB0b2dnbGVMYXllckFuaW1hdGlvblVwZGF0ZXIgPSAoXG4gIHN0YXRlOiBWaXNTdGF0ZSxcbiAgYWN0aW9uOiBWaXNTdGF0ZUFjdGlvbnMuVG9nZ2xlTGF5ZXJBbmltYXRpb25VcGRhdGVyQWN0aW9uXG4pOiBWaXNTdGF0ZSA9PiAoe1xuICAuLi5zdGF0ZSxcbiAgYW5pbWF0aW9uQ29uZmlnOiB7XG4gICAgLi4uc3RhdGUuYW5pbWF0aW9uQ29uZmlnLFxuICAgIGlzQW5pbWF0aW5nOiAhc3RhdGUuYW5pbWF0aW9uQ29uZmlnLmlzQW5pbWF0aW5nXG4gIH1cbn0pO1xuXG4vKipcbiAqIEhpZGUgYW5kIHNob3cgbGF5ZXIgYW5pbWF0aW9uIGNvbnRyb2xcbiAqIEBtZW1iZXJvZiB2aXNTdGF0ZVVwZGF0ZXJzXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCB0b2dnbGVMYXllckFuaW1hdGlvbkNvbnRyb2xVcGRhdGVyID0gKFxuICBzdGF0ZTogVmlzU3RhdGUsXG4gIGFjdGlvbjogVmlzU3RhdGVBY3Rpb25zLlRvZ2dsZUxheWVyQW5pbWF0aW9uQ29udHJvbFVwZGF0ZXJBY3Rpb25cbik6IFZpc1N0YXRlID0+ICh7XG4gIC4uLnN0YXRlLFxuICBhbmltYXRpb25Db25maWc6IHtcbiAgICAuLi5zdGF0ZS5hbmltYXRpb25Db25maWcsXG4gICAgaGlkZUNvbnRyb2w6ICFzdGF0ZS5hbmltYXRpb25Db25maWcuaGlkZUNvbnRyb2xcbiAgfVxufSk7XG5cbi8qKlxuICogQ2hhbmdlIGZpbHRlciBhbmltYXRpb24gc3BlZWRcbiAqIEBtZW1iZXJvZiB2aXNTdGF0ZVVwZGF0ZXJzXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCB1cGRhdGVGaWx0ZXJBbmltYXRpb25TcGVlZFVwZGF0ZXIgPSAoXG4gIHN0YXRlOiBWaXNTdGF0ZSxcbiAgYWN0aW9uOiBWaXNTdGF0ZUFjdGlvbnMuVXBkYXRlRmlsdGVyQW5pbWF0aW9uU3BlZWRVcGRhdGVyQWN0aW9uXG4pOiBWaXNTdGF0ZSA9PiAoe1xuICAuLi5zdGF0ZSxcbiAgZmlsdGVyczogc3RhdGUuZmlsdGVycy5tYXAoKGYsIGkpID0+IChpID09PSBhY3Rpb24uaWR4ID8gey4uLmYsIHNwZWVkOiBhY3Rpb24uc3BlZWR9IDogZikpXG59KTtcblxuLyoqXG4gKiBSZXNldCBhbmltYXRpb24gY29uZmlnIGN1cnJlbnQgdGltZSB0byBhIHNwZWNpZmllZCB2YWx1ZVxuICogQG1lbWJlcm9mIHZpc1N0YXRlVXBkYXRlcnNcbiAqIEBwdWJsaWNcbiAqXG4gKi9cbmV4cG9ydCBjb25zdCBzZXRMYXllckFuaW1hdGlvblRpbWVVcGRhdGVyID0gKFxuICBzdGF0ZTogVmlzU3RhdGUsXG4gIHt2YWx1ZX06IFZpc1N0YXRlQWN0aW9ucy5TZXRMYXllckFuaW1hdGlvblRpbWVVcGRhdGVyQWN0aW9uXG4pOiBWaXNTdGF0ZSA9PiAoe1xuICAuLi5zdGF0ZSxcbiAgYW5pbWF0aW9uQ29uZmlnOiB7XG4gICAgLi4uc3RhdGUuYW5pbWF0aW9uQ29uZmlnLFxuICAgIGN1cnJlbnRUaW1lOiB2YWx1ZVxuICB9XG59KTtcblxuLyoqXG4gKiBVcGRhdGUgYW5pbWF0aW9uIHNwZWVkIHdpdGggdGhlIHZlcnRpY2FsIHNwZWVkIHNsaWRlclxuICogQG1lbWJlcm9mIHZpc1N0YXRlVXBkYXRlcnNcbiAqIEBwdWJsaWNcbiAqXG4gKi9cbmV4cG9ydCBjb25zdCB1cGRhdGVMYXllckFuaW1hdGlvblNwZWVkVXBkYXRlciA9IChcbiAgc3RhdGU6IFZpc1N0YXRlLFxuICB7c3BlZWR9OiBWaXNTdGF0ZUFjdGlvbnMuVXBkYXRlTGF5ZXJBbmltYXRpb25TcGVlZFVwZGF0ZXJBY3Rpb25cbik6IFZpc1N0YXRlID0+IHtcbiAgcmV0dXJuIHtcbiAgICAuLi5zdGF0ZSxcbiAgICBhbmltYXRpb25Db25maWc6IHtcbiAgICAgIC4uLnN0YXRlLmFuaW1hdGlvbkNvbmZpZyxcbiAgICAgIHNwZWVkXG4gICAgfVxuICB9O1xufTtcblxuLyoqXG4gKiBTaG93IGxhcmdlciB0aW1lIGZpbHRlciBhdCBib3R0b20gZm9yIHRpbWUgcGxheWJhY2sgKGFwcGx5IHRvIHRpbWUgZmlsdGVyIG9ubHkpXG4gKiBAbWVtYmVyb2YgdmlzU3RhdGVVcGRhdGVyc1xuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgZW5sYXJnZUZpbHRlclVwZGF0ZXIgPSAoXG4gIHN0YXRlOiBWaXNTdGF0ZSxcbiAgYWN0aW9uOiBWaXNTdGF0ZUFjdGlvbnMuRW5sYXJnZUZpbHRlclVwZGF0ZXJBY3Rpb25cbik6IFZpc1N0YXRlID0+IHtcbiAgcmV0dXJuIHtcbiAgICAuLi5zdGF0ZSxcbiAgICBmaWx0ZXJzOiBzdGF0ZS5maWx0ZXJzLm1hcCgoZiwgaSkgPT5cbiAgICAgIGkgPT09IGFjdGlvbi5pZHhcbiAgICAgICAgPyB7XG4gICAgICAgICAgICAuLi5mLFxuICAgICAgICAgICAgZW5sYXJnZWQ6ICFmLmVubGFyZ2VkXG4gICAgICAgICAgfVxuICAgICAgICA6IGZcbiAgICApXG4gIH07XG59O1xuXG4vKipcbiAqIFRvZ2dsZXMgZmlsdGVyIGZlYXR1cmUgdmlzaWJpbGl0eVxuICogQG1lbWJlcm9mIHZpc1N0YXRlVXBkYXRlcnNcbiAqL1xuZXhwb3J0IGNvbnN0IHRvZ2dsZUZpbHRlckZlYXR1cmVVcGRhdGVyID0gKFxuICBzdGF0ZTogVmlzU3RhdGUsXG4gIGFjdGlvbjogVmlzU3RhdGVBY3Rpb25zLlRvZ2dsZUZpbHRlckZlYXR1cmVVcGRhdGVyQWN0aW9uXG4pOiBWaXNTdGF0ZSA9PiB7XG4gIGNvbnN0IGZpbHRlciA9IHN0YXRlLmZpbHRlcnNbYWN0aW9uLmlkeF07XG4gIGNvbnN0IGlzVmlzaWJsZSA9IGdldChmaWx0ZXIsIFsndmFsdWUnLCAncHJvcGVydGllcycsICdpc1Zpc2libGUnXSk7XG4gIGNvbnN0IG5ld0ZpbHRlciA9IHtcbiAgICAuLi5maWx0ZXIsXG4gICAgdmFsdWU6IGZlYXR1cmVUb0ZpbHRlclZhbHVlKGZpbHRlci52YWx1ZSwgZmlsdGVyLmlkLCB7XG4gICAgICBpc1Zpc2libGU6ICFpc1Zpc2libGVcbiAgICB9KVxuICB9O1xuXG4gIHJldHVybiB7XG4gICAgLi4uc3RhdGUsXG4gICAgZmlsdGVyczogT2JqZWN0LmFzc2lnbihbLi4uc3RhdGUuZmlsdGVyc10sIHtbYWN0aW9uLmlkeF06IG5ld0ZpbHRlcn0pXG4gIH07XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhIGZpbHRlclxuICogQG1lbWJlcm9mIHZpc1N0YXRlVXBkYXRlcnNcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IHJlbW92ZUZpbHRlclVwZGF0ZXIgPSAoXG4gIHN0YXRlOiBWaXNTdGF0ZSxcbiAgYWN0aW9uOiBWaXNTdGF0ZUFjdGlvbnMuUmVtb3ZlRmlsdGVyVXBkYXRlckFjdGlvblxuKTogVmlzU3RhdGUgPT4ge1xuICBjb25zdCB7aWR4fSA9IGFjdGlvbjtcbiAgY29uc3Qge2RhdGFJZCwgaWR9ID0gc3RhdGUuZmlsdGVyc1tpZHhdO1xuXG4gIGNvbnN0IG5ld0ZpbHRlcnMgPSBbXG4gICAgLi4uc3RhdGUuZmlsdGVycy5zbGljZSgwLCBpZHgpLFxuICAgIC4uLnN0YXRlLmZpbHRlcnMuc2xpY2UoaWR4ICsgMSwgc3RhdGUuZmlsdGVycy5sZW5ndGgpXG4gIF07XG5cbiAgY29uc3QgZmlsdGVyZWREYXRhc2V0cyA9IGFwcGx5RmlsdGVyc1RvRGF0YXNldHMoZGF0YUlkLCBzdGF0ZS5kYXRhc2V0cywgbmV3RmlsdGVycywgc3RhdGUubGF5ZXJzKTtcbiAgY29uc3QgbmV3RWRpdG9yID1cbiAgICBnZXRGaWx0ZXJJZEluRmVhdHVyZShzdGF0ZS5lZGl0b3Iuc2VsZWN0ZWRGZWF0dXJlKSA9PT0gaWRcbiAgICAgID8ge1xuICAgICAgICAgIC4uLnN0YXRlLmVkaXRvcixcbiAgICAgICAgICBzZWxlY3RlZEZlYXR1cmU6IG51bGxcbiAgICAgICAgfVxuICAgICAgOiBzdGF0ZS5lZGl0b3I7XG5cbiAgbGV0IG5ld1N0YXRlID0gc2V0KFsnZmlsdGVycyddLCBuZXdGaWx0ZXJzLCBzdGF0ZSk7XG4gIG5ld1N0YXRlID0gc2V0KFsnZGF0YXNldHMnXSwgZmlsdGVyZWREYXRhc2V0cywgbmV3U3RhdGUpO1xuICBuZXdTdGF0ZSA9IHNldChbJ2VkaXRvciddLCBuZXdFZGl0b3IsIG5ld1N0YXRlKTtcblxuICByZXR1cm4gdXBkYXRlQWxsTGF5ZXJEb21haW5EYXRhKG5ld1N0YXRlLCBkYXRhSWQsIHVuZGVmaW5lZCk7XG59O1xuXG4vKipcbiAqIEFkZCBhIG5ldyBsYXllclxuICogQG1lbWJlcm9mIHZpc1N0YXRlVXBkYXRlcnNcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IGFkZExheWVyVXBkYXRlciA9IChcbiAgc3RhdGU6IFZpc1N0YXRlLFxuICBhY3Rpb246IFZpc1N0YXRlQWN0aW9ucy5BZGRMYXllclVwZGF0ZXJBY3Rpb25cbik6IFZpc1N0YXRlID0+IHtcbiAgbGV0IG5ld0xheWVyO1xuICBsZXQgbmV3TGF5ZXJEYXRhO1xuICBpZiAoYWN0aW9uLmNvbmZpZykge1xuICAgIG5ld0xheWVyID0gY3JlYXRlTGF5ZXJGcm9tQ29uZmlnKHN0YXRlLCBhY3Rpb24uY29uZmlnKTtcbiAgICBpZiAoIW5ld0xheWVyKSB7XG4gICAgICBDb25zb2xlLndhcm4oXG4gICAgICAgICdGYWlsZWQgdG8gY3JlYXRlIGxheWVyIGZyb20gY29uZmlnLCBpdCB1c3VhbGx5IG1lYW5zIHRoZSBjb25maWcgaXMgbm90IGJlIGluIGNvcnJlY3QgZm9ybWF0JyxcbiAgICAgICAgYWN0aW9uLmNvbmZpZ1xuICAgICAgKTtcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG5cbiAgICBjb25zdCByZXN1bHQgPSBjYWxjdWxhdGVMYXllckRhdGEobmV3TGF5ZXIsIHN0YXRlKTtcbiAgICBuZXdMYXllciA9IHJlc3VsdC5sYXllcjtcbiAgICBuZXdMYXllckRhdGEgPSByZXN1bHQubGF5ZXJEYXRhO1xuICB9IGVsc2Uge1xuICAgIC8vIGNyZWF0ZSBhbiBlbXB0eSBsYXllciB3aXRoIGEgc3BlY2lmaWMgZGF0YXNldCBvciBhIGRlZmF1bHQgb25lXG4gICAgY29uc3QgZGVmYXVsdERhdGFzZXQgPSBhY3Rpb24uZGF0YXNldElkID8/IE9iamVjdC5rZXlzKHN0YXRlLmRhdGFzZXRzKVswXTtcbiAgICBuZXdMYXllciA9IG5ldyBMYXllcih7XG4gICAgICBpc1Zpc2libGU6IHRydWUsXG4gICAgICBpc0NvbmZpZ0FjdGl2ZTogdHJ1ZSxcbiAgICAgIGRhdGFJZDogZGVmYXVsdERhdGFzZXRcbiAgICB9KTtcbiAgICBuZXdMYXllckRhdGEgPSB7fTtcbiAgfVxuICByZXR1cm4ge1xuICAgIC4uLnN0YXRlLFxuICAgIGxheWVyczogWy4uLnN0YXRlLmxheWVycywgbmV3TGF5ZXJdLFxuICAgIGxheWVyRGF0YTogWy4uLnN0YXRlLmxheWVyRGF0YSwgbmV3TGF5ZXJEYXRhXSxcbiAgICBsYXllck9yZGVyOiBbLi4uc3RhdGUubGF5ZXJPcmRlciwgc3RhdGUubGF5ZXJPcmRlci5sZW5ndGhdLFxuICAgIHNwbGl0TWFwczogYWRkTmV3TGF5ZXJzVG9TcGxpdE1hcChzdGF0ZS5zcGxpdE1hcHMsIG5ld0xheWVyKVxuICB9O1xufTtcblxuLyoqXG4gKiByZW1vdmUgbGF5ZXJcbiAqIEBtZW1iZXJvZiB2aXNTdGF0ZVVwZGF0ZXJzXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCByZW1vdmVMYXllclVwZGF0ZXIgPSAoXG4gIHN0YXRlOiBWaXNTdGF0ZSxcbiAge2lkeH06IFZpc1N0YXRlQWN0aW9ucy5SZW1vdmVMYXllclVwZGF0ZXJBY3Rpb25cbik6IFZpc1N0YXRlID0+IHtcbiAgY29uc3Qge2xheWVycywgbGF5ZXJEYXRhLCBjbGlja2VkLCBob3ZlckluZm99ID0gc3RhdGU7XG4gIGNvbnN0IGxheWVyVG9SZW1vdmUgPSBzdGF0ZS5sYXllcnNbaWR4XTtcbiAgY29uc3QgbmV3TWFwcyA9IHJlbW92ZUxheWVyRnJvbVNwbGl0TWFwcyhzdGF0ZS5zcGxpdE1hcHMsIGxheWVyVG9SZW1vdmUpO1xuXG4gIGNvbnN0IG5ld1N0YXRlID0ge1xuICAgIC4uLnN0YXRlLFxuICAgIGxheWVyczogWy4uLmxheWVycy5zbGljZSgwLCBpZHgpLCAuLi5sYXllcnMuc2xpY2UoaWR4ICsgMSwgbGF5ZXJzLmxlbmd0aCldLFxuICAgIGxheWVyRGF0YTogWy4uLmxheWVyRGF0YS5zbGljZSgwLCBpZHgpLCAuLi5sYXllckRhdGEuc2xpY2UoaWR4ICsgMSwgbGF5ZXJEYXRhLmxlbmd0aCldLFxuICAgIGxheWVyT3JkZXI6IHN0YXRlLmxheWVyT3JkZXIuZmlsdGVyKGkgPT4gaSAhPT0gaWR4KS5tYXAocGlkID0+IChwaWQgPiBpZHggPyBwaWQgLSAxIDogcGlkKSksXG4gICAgY2xpY2tlZDogbGF5ZXJUb1JlbW92ZS5pc0xheWVySG92ZXJlZChjbGlja2VkKSA/IHVuZGVmaW5lZCA6IGNsaWNrZWQsXG4gICAgaG92ZXJJbmZvOiBsYXllclRvUmVtb3ZlLmlzTGF5ZXJIb3ZlcmVkKGhvdmVySW5mbykgPyB1bmRlZmluZWQgOiBob3ZlckluZm8sXG4gICAgc3BsaXRNYXBzOiBuZXdNYXBzXG4gICAgLy8gVE9ETzogdXBkYXRlIGZpbHRlcnMsIGNyZWF0ZSBoZWxwZXIgdG8gcmVtb3ZlIGxheWVyIGZvcm0gZmlsdGVyIChyZW1vdmUgbGF5ZXJpZCBhbmQgZGF0YWlkKSBpZiBtYXBwZWRcbiAgfTtcblxuICByZXR1cm4gdXBkYXRlQW5pbWF0aW9uRG9tYWluKG5ld1N0YXRlKTtcbn07XG5cbi8qKlxuICogZHVwbGljYXRlIGxheWVyXG4gKiBAbWVtYmVyb2YgdmlzU3RhdGVVcGRhdGVyc1xuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgZHVwbGljYXRlTGF5ZXJVcGRhdGVyID0gKFxuICBzdGF0ZTogVmlzU3RhdGUsXG4gIHtpZHh9OiBWaXNTdGF0ZUFjdGlvbnMuRHVwbGljYXRlTGF5ZXJVcGRhdGVyQWN0aW9uXG4pOiBWaXNTdGF0ZSA9PiB7XG4gIGNvbnN0IHtsYXllcnN9ID0gc3RhdGU7XG4gIGNvbnN0IG9yaWdpbmFsID0gc3RhdGUubGF5ZXJzW2lkeF07XG4gIGNvbnN0IG9yaWdpbmFsTGF5ZXJPcmRlcklkeCA9IHN0YXRlLmxheWVyT3JkZXIuZmluZEluZGV4KGkgPT4gaSA9PT0gaWR4KTtcblxuICBpZiAoIW9yaWdpbmFsKSB7XG4gICAgQ29uc29sZS53YXJuKGBsYXllci4ke2lkeH0gaXMgdW5kZWZpbmVkYCk7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG4gIGxldCBuZXdMYWJlbCA9IGBDb3B5IG9mICR7b3JpZ2luYWwuY29uZmlnLmxhYmVsfWA7XG4gIGxldCBwb3N0Zml4ID0gMDtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWxvb3AtZnVuY1xuICB3aGlsZSAobGF5ZXJzLmZpbmQobCA9PiBsLmNvbmZpZy5sYWJlbCA9PT0gbmV3TGFiZWwpKSB7XG4gICAgbmV3TGFiZWwgPSBgQ29weSBvZiAke29yaWdpbmFsLmNvbmZpZy5sYWJlbH0gJHsrK3Bvc3RmaXh9YDtcbiAgfVxuXG4gIC8vIGNvbGxlY3QgbGF5ZXIgY29uZmlnIGZyb20gb3JpZ2luYWxcbiAgY29uc3QgbG9hZGVkTGF5ZXIgPSBzZXJpYWxpemVMYXllcihvcmlnaW5hbCk7XG5cbiAgLy8gYXNzaWduIG5ldyBpZCBhbmQgbGFiZWwgdG8gY29waWVkIGxheWVyXG4gIGlmICghbG9hZGVkTGF5ZXI/LmNvbmZpZykge1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuICBsb2FkZWRMYXllci5jb25maWcubGFiZWwgPSBuZXdMYWJlbDtcbiAgbG9hZGVkTGF5ZXIuaWQgPSBnZW5lcmF0ZUhhc2hJZChMQVlFUl9JRF9MRU5HVEgpO1xuXG4gIC8vIGFkZCBsYXllciB0byBzdGF0ZVxuICBsZXQgbmV4dFN0YXRlID0gYWRkTGF5ZXJVcGRhdGVyKHN0YXRlLCB7Y29uZmlnOiBsb2FkZWRMYXllcn0pO1xuXG4gIC8vIG5ldyBhZGRlZCBsYXllciBhcmUgYXQgdGhlIGVuZCwgbW92ZSBpdCB0byBiZSBvbiB0b3Agb2Ygb3JpZ2luYWwgbGF5ZXJcbiAgY29uc3QgbmV3TGF5ZXJPcmRlcklkeCA9IG5leHRTdGF0ZS5sYXllck9yZGVyLmxlbmd0aCAtIDE7XG4gIGNvbnN0IG5ld0xheWVyT3JkZXIgPSBhcnJheUluc2VydChcbiAgICBuZXh0U3RhdGUubGF5ZXJPcmRlci5zbGljZSgwLCBuZXdMYXllck9yZGVySWR4KSxcbiAgICBvcmlnaW5hbExheWVyT3JkZXJJZHgsXG4gICAgbmV3TGF5ZXJPcmRlcklkeFxuICApO1xuXG4gIG5leHRTdGF0ZSA9IHtcbiAgICAuLi5uZXh0U3RhdGUsXG4gICAgbGF5ZXJPcmRlcjogbmV3TGF5ZXJPcmRlclxuICB9O1xuXG4gIHJldHVybiB1cGRhdGVBbmltYXRpb25Eb21haW4obmV4dFN0YXRlKTtcbn07XG5cbi8qKlxuICogUmVvcmRlciBsYXllclxuICogQG1lbWJlcm9mIHZpc1N0YXRlVXBkYXRlcnNcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IHJlb3JkZXJMYXllclVwZGF0ZXIgPSAoXG4gIHN0YXRlOiBWaXNTdGF0ZSxcbiAge29yZGVyfTogVmlzU3RhdGVBY3Rpb25zLlJlb3JkZXJMYXllclVwZGF0ZXJBY3Rpb25cbik6IFZpc1N0YXRlID0+ICh7XG4gIC4uLnN0YXRlLFxuICBsYXllck9yZGVyOiBvcmRlclxufSk7XG5cbi8qKlxuICogUmVtb3ZlIGEgZGF0YXNldCBhbmQgYWxsIGxheWVycywgZmlsdGVycywgdG9vbHRpcCBjb25maWdzIHRoYXQgYmFzZWQgb24gaXRcbiAqIEBtZW1iZXJvZiB2aXNTdGF0ZVVwZGF0ZXJzXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCByZW1vdmVEYXRhc2V0VXBkYXRlciA9IChcbiAgc3RhdGU6IFZpc1N0YXRlLFxuICBhY3Rpb246IFZpc1N0YXRlQWN0aW9ucy5SZW1vdmVEYXRhc2V0VXBkYXRlckFjdGlvblxuKTogVmlzU3RhdGUgPT4ge1xuICAvLyBleHRyYWN0IGRhdGFzZXQga2V5XG4gIGNvbnN0IHtkYXRhSWQ6IGRhdGFzZXRLZXl9ID0gYWN0aW9uO1xuICBjb25zdCB7ZGF0YXNldHN9ID0gc3RhdGU7XG5cbiAgLy8gY2hlY2sgaWYgZGF0YXNldCBpcyBwcmVzZW50XG4gIGlmICghZGF0YXNldHNbZGF0YXNldEtleV0pIHtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cblxuICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuICBjb25zdCB7XG4gICAgbGF5ZXJzLFxuICAgIGRhdGFzZXRzOiB7W2RhdGFzZXRLZXldOiBkYXRhc2V0LCAuLi5uZXdEYXRhc2V0c31cbiAgfSA9IHN0YXRlO1xuICAvKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC12YXJzICovXG5cbiAgY29uc3QgaW5kZXhlcyA9IGxheWVycy5yZWR1Y2UoKGxpc3RPZkluZGV4ZXMsIGxheWVyLCBpbmRleCkgPT4ge1xuICAgIGlmIChsYXllci5jb25maWcuZGF0YUlkID09PSBkYXRhc2V0S2V5KSB7XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBsaXN0T2ZJbmRleGVzLnB1c2goaW5kZXgpO1xuICAgIH1cbiAgICByZXR1cm4gbGlzdE9mSW5kZXhlcztcbiAgfSwgW10pO1xuXG4gIC8vIHJlbW92ZSBsYXllcnMgYW5kIGRhdGFzZXRzXG4gIGNvbnN0IHtuZXdTdGF0ZX0gPSBpbmRleGVzLnJlZHVjZShcbiAgICAoe25ld1N0YXRlOiBjdXJyZW50U3RhdGUsIGluZGV4Q291bnRlcn0sIGlkeCkgPT4ge1xuICAgICAgY29uc3QgY3VycmVudEluZGV4ID0gaWR4IC0gaW5kZXhDb3VudGVyO1xuICAgICAgY3VycmVudFN0YXRlID0gcmVtb3ZlTGF5ZXJVcGRhdGVyKGN1cnJlbnRTdGF0ZSwge2lkeDogY3VycmVudEluZGV4fSk7XG4gICAgICBpbmRleENvdW50ZXIrKztcbiAgICAgIHJldHVybiB7bmV3U3RhdGU6IGN1cnJlbnRTdGF0ZSwgaW5kZXhDb3VudGVyfTtcbiAgICB9LFxuICAgIHtuZXdTdGF0ZTogey4uLnN0YXRlLCBkYXRhc2V0czogbmV3RGF0YXNldHN9LCBpbmRleENvdW50ZXI6IDB9XG4gICk7XG5cbiAgLy8gcmVtb3ZlIGZpbHRlcnNcbiAgY29uc3QgZmlsdGVycyA9IHN0YXRlLmZpbHRlcnMuZmlsdGVyKGZpbHRlciA9PiAhZmlsdGVyLmRhdGFJZC5pbmNsdWRlcyhkYXRhc2V0S2V5KSk7XG5cbiAgLy8gdXBkYXRlIGludGVyYWN0aW9uQ29uZmlnXG4gIGxldCB7aW50ZXJhY3Rpb25Db25maWd9ID0gc3RhdGU7XG4gIGNvbnN0IHt0b29sdGlwfSA9IGludGVyYWN0aW9uQ29uZmlnO1xuICBpZiAodG9vbHRpcCkge1xuICAgIGNvbnN0IHtjb25maWd9ID0gdG9vbHRpcDtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuICAgIGNvbnN0IHtbZGF0YXNldEtleV06IGZpZWxkcywgLi4uZmllbGRzVG9TaG93fSA9IGNvbmZpZy5maWVsZHNUb1Nob3c7XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby11bnVzZWQtdmFycyAqL1xuICAgIGludGVyYWN0aW9uQ29uZmlnID0ge1xuICAgICAgLi4uaW50ZXJhY3Rpb25Db25maWcsXG4gICAgICB0b29sdGlwOiB7Li4udG9vbHRpcCwgY29uZmlnOiB7Li4uY29uZmlnLCBmaWVsZHNUb1Nob3d9fVxuICAgIH07XG4gIH1cblxuICByZXR1cm4gey4uLm5ld1N0YXRlLCBmaWx0ZXJzLCBpbnRlcmFjdGlvbkNvbmZpZ307XG59O1xuXG4vKipcbiAqIHVwZGF0ZSBsYXllciBibGVuZGluZyBtb2RlXG4gKiBAbWVtYmVyb2YgdmlzU3RhdGVVcGRhdGVyc1xuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgdXBkYXRlTGF5ZXJCbGVuZGluZ1VwZGF0ZXIgPSAoXG4gIHN0YXRlOiBWaXNTdGF0ZSxcbiAgYWN0aW9uOiBWaXNTdGF0ZUFjdGlvbnMuVXBkYXRlTGF5ZXJCbGVuZGluZ1VwZGF0ZXJBY3Rpb25cbik6IFZpc1N0YXRlID0+ICh7XG4gIC4uLnN0YXRlLFxuICBsYXllckJsZW5kaW5nOiBhY3Rpb24ubW9kZVxufSk7XG5cbi8qKlxuICogRGlzcGxheSBkYXRhc2V0IHRhYmxlIGluIGEgbW9kYWxcbiAqIEBtZW1iZXJvZiB2aXNTdGF0ZVVwZGF0ZXJzXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCBzaG93RGF0YXNldFRhYmxlVXBkYXRlciA9IChcbiAgc3RhdGU6IFZpc1N0YXRlLFxuICBhY3Rpb246IFZpc1N0YXRlQWN0aW9ucy5TaG93RGF0YXNldFRhYmxlVXBkYXRlckFjdGlvblxuKTogVmlzU3RhdGUgPT4ge1xuICByZXR1cm4ge1xuICAgIC4uLnN0YXRlLFxuICAgIGVkaXRpbmdEYXRhc2V0OiBhY3Rpb24uZGF0YUlkXG4gIH07XG59O1xuXG4vKipcbiAqIEFkZCBjdXN0b20gY29sb3IgZm9yIGRhdGFzZXRzIGFuZCBsYXllcnNcbiAqIEBtZW1iZXJvZiB2aXNTdGF0ZVVwZGF0ZXJzXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCB1cGRhdGVUYWJsZUNvbG9yVXBkYXRlciA9IChcbiAgc3RhdGU6IFZpc1N0YXRlLFxuICBhY3Rpb246IFZpc1N0YXRlQWN0aW9ucy5VcGRhdGVEYXRhc2V0Q29sb3JVcGRhdGVyXG4pOiBWaXNTdGF0ZSA9PiB7XG4gIGNvbnN0IHtkYXRhSWQsIG5ld0NvbG9yfSA9IGFjdGlvbjtcbiAgY29uc3Qge2RhdGFzZXRzfSA9IHN0YXRlO1xuXG4gIGlmIChpc1JnYkNvbG9yKG5ld0NvbG9yKSkge1xuICAgIGNvbnN0IGV4aXN0aW5nID0gZGF0YXNldHNbZGF0YUlkXTtcbiAgICBleGlzdGluZy51cGRhdGVUYWJsZUNvbG9yKG5ld0NvbG9yKTtcblxuICAgIHJldHVybiB7XG4gICAgICAuLi5zdGF0ZSxcbiAgICAgIGRhdGFzZXRzOiB7XG4gICAgICAgIC4uLnN0YXRlLmRhdGFzZXRzLFxuICAgICAgICBbZGF0YUlkXTogY29weVRhYmxlQW5kVXBkYXRlKGV4aXN0aW5nLCB7fSlcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIHJldHVybiBzdGF0ZTtcbn07XG5cbi8qKlxuICogcmVzZXQgdmlzU3RhdGUgdG8gaW5pdGlhbCBTdGF0ZVxuICogQG1lbWJlcm9mIHZpc1N0YXRlVXBkYXRlcnNcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IHJlc2V0TWFwQ29uZmlnVXBkYXRlciA9IChzdGF0ZTogVmlzU3RhdGUpOiBWaXNTdGF0ZSA9PiAoe1xuICAuLi5JTklUSUFMX1ZJU19TVEFURSxcbiAgLi4uc3RhdGUuaW5pdGlhbFN0YXRlLFxuICBpbml0aWFsU3RhdGU6IHN0YXRlLmluaXRpYWxTdGF0ZVxufSk7XG5cbi8qKlxuICogUHJvcGFnYXRlIGB2aXNTdGF0ZWAgcmVkdWNlciB3aXRoIGEgbmV3IGNvbmZpZ3VyYXRpb24uIEN1cnJlbnQgY29uZmlnIHdpbGwgYmUgb3ZlcnJpZGUuXG4gKiBAbWVtYmVyb2YgdmlzU3RhdGVVcGRhdGVyc1xuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgcmVjZWl2ZU1hcENvbmZpZ1VwZGF0ZXIgPSAoXG4gIHN0YXRlOiBWaXNTdGF0ZSxcbiAge1xuICAgIHBheWxvYWQ6IHtjb25maWcgPSB7dmVyc2lvbjogJyd9LCBvcHRpb25zID0ge319XG4gIH06IHtcbiAgICB0eXBlPzogdHlwZW9mIEFjdGlvblR5cGVzLlJFQ0VJVkVfTUFQX0NPTkZJRztcbiAgICBwYXlsb2FkOiBSZWNlaXZlTWFwQ29uZmlnUGF5bG9hZDtcbiAgfVxuKTogVmlzU3RhdGUgPT4ge1xuICBpZiAoIWNvbmZpZy52aXNTdGF0ZSkge1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuXG4gIGNvbnN0IHtrZWVwRXhpc3RpbmdDb25maWd9ID0gb3B0aW9ucztcblxuICAvLyByZXNldCBjb25maWcgaWYga2VlcEV4aXN0aW5nQ29uZmlnIGlzIGZhbHN5XG4gIGxldCBtZXJnZWRTdGF0ZSA9ICFrZWVwRXhpc3RpbmdDb25maWcgPyByZXNldE1hcENvbmZpZ1VwZGF0ZXIoc3RhdGUpIDogc3RhdGU7XG4gIGZvciAoY29uc3QgbWVyZ2VyIG9mIHN0YXRlLm1lcmdlcnMpIHtcbiAgICBpZiAoaXNWYWxpZE1lcmdlcihtZXJnZXIpICYmIGNvbmZpZy52aXNTdGF0ZVttZXJnZXIucHJvcF0pIHtcbiAgICAgIG1lcmdlZFN0YXRlID0gbWVyZ2VyLm1lcmdlKG1lcmdlZFN0YXRlLCBjb25maWcudmlzU3RhdGVbbWVyZ2VyLnByb3BdLCB0cnVlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbWVyZ2VkU3RhdGU7XG59O1xuXG4vKipcbiAqIFRyaWdnZXIgbGF5ZXIgaG92ZXIgZXZlbnQgd2l0aCBob3ZlcmVkIG9iamVjdFxuICogQG1lbWJlcm9mIHZpc1N0YXRlVXBkYXRlcnNcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IGxheWVySG92ZXJVcGRhdGVyID0gKFxuICBzdGF0ZTogVmlzU3RhdGUsXG4gIGFjdGlvbjogVmlzU3RhdGVBY3Rpb25zLk9uTGF5ZXJIb3ZlclVwZGF0ZXJBY3Rpb25cbik6IFZpc1N0YXRlID0+ICh7XG4gIC4uLnN0YXRlLFxuICBob3ZlckluZm86IHtcbiAgICAvLyBkZWNrLmdsIGluZm8gaXMgbXV0YWJsZVxuICAgIC4uLmFjdGlvbi5pbmZvXG4gIH1cbn0pO1xuXG4vKiBlc2xpbnQtZW5hYmxlIG1heC1zdGF0ZW1lbnRzICovXG5cbi8qKlxuICogVXBkYXRlIGBpbnRlcmFjdGlvbkNvbmZpZ2BcbiAqIEBtZW1iZXJvZiB2aXNTdGF0ZVVwZGF0ZXJzXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnRlcmFjdGlvbkNvbmZpZ0NoYW5nZVVwZGF0ZXIoXG4gIHN0YXRlOiBWaXNTdGF0ZSxcbiAgYWN0aW9uOiBWaXNTdGF0ZUFjdGlvbnMuSW50ZXJhY3Rpb25Db25maWdDaGFuZ2VVcGRhdGVyQWN0aW9uXG4pOiBWaXNTdGF0ZSB7XG4gIGNvbnN0IHtjb25maWd9ID0gYWN0aW9uO1xuXG4gIGNvbnN0IGludGVyYWN0aW9uQ29uZmlnID0ge1xuICAgIC4uLnN0YXRlLmludGVyYWN0aW9uQ29uZmlnLFxuICAgIC4uLntbY29uZmlnLmlkXTogY29uZmlnfVxuICB9O1xuXG4gIC8vIERvbid0IGVuYWJsZSB0b29sdGlwIGFuZCBicnVzaCBhdCB0aGUgc2FtZSB0aW1lXG4gIC8vIGJ1dCBjb29yZGluYXRlcyBjYW4gYmUgc2hvd24gYXQgYWxsIHRpbWVcbiAgY29uc3QgY29udHJhZGljdCA9IFsnYnJ1c2gnLCAndG9vbHRpcCddO1xuXG4gIGlmIChcbiAgICBjb250cmFkaWN0LmluY2x1ZGVzKGNvbmZpZy5pZCkgJiZcbiAgICBjb25maWcuZW5hYmxlZCAmJlxuICAgICFzdGF0ZS5pbnRlcmFjdGlvbkNvbmZpZ1tjb25maWcuaWRdLmVuYWJsZWRcbiAgKSB7XG4gICAgLy8gb25seSBlbmFibGUgb25lIGludGVyYWN0aW9uIGF0IGEgdGltZVxuICAgIGNvbnRyYWRpY3QuZm9yRWFjaChrID0+IHtcbiAgICAgIGlmIChrICE9PSBjb25maWcuaWQpIHtcbiAgICAgICAgaW50ZXJhY3Rpb25Db25maWdba10gPSB7Li4uaW50ZXJhY3Rpb25Db25maWdba10sIGVuYWJsZWQ6IGZhbHNlfTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGNvbnN0IG5ld1N0YXRlID0ge1xuICAgIC4uLnN0YXRlLFxuICAgIGludGVyYWN0aW9uQ29uZmlnXG4gIH07XG5cbiAgaWYgKGNvbmZpZy5pZCA9PT0gJ2dlb2NvZGVyJyAmJiAhY29uZmlnLmVuYWJsZWQpIHtcbiAgICByZXR1cm4gcmVtb3ZlRGF0YXNldFVwZGF0ZXIobmV3U3RhdGUsIHtkYXRhSWQ6ICdnZW9jb2Rlcl9kYXRhc2V0J30pO1xuICB9XG5cbiAgcmV0dXJuIG5ld1N0YXRlO1xufVxuXG4vKipcbiAqIFRyaWdnZXIgbGF5ZXIgY2xpY2sgZXZlbnQgd2l0aCBjbGlja2VkIG9iamVjdFxuICogQG1lbWJlcm9mIHZpc1N0YXRlVXBkYXRlcnNcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IGxheWVyQ2xpY2tVcGRhdGVyID0gKFxuICBzdGF0ZTogVmlzU3RhdGUsXG4gIGFjdGlvbjogVmlzU3RhdGVBY3Rpb25zLk9uTGF5ZXJDbGlja1VwZGF0ZXJBY3Rpb25cbik6IFZpc1N0YXRlID0+ICh7XG4gIC4uLnN0YXRlLFxuICBtb3VzZVBvczogc3RhdGUuaW50ZXJhY3Rpb25Db25maWcuY29vcmRpbmF0ZS5lbmFibGVkXG4gICAgPyB7XG4gICAgICAgIC4uLnN0YXRlLm1vdXNlUG9zLFxuICAgICAgICBwaW5uZWQ6IHN0YXRlLm1vdXNlUG9zLnBpbm5lZCA/IG51bGwgOiBjbG9uZURlZXAoc3RhdGUubW91c2VQb3MpXG4gICAgICB9XG4gICAgOiBzdGF0ZS5tb3VzZVBvcyxcbiAgY2xpY2tlZDogYWN0aW9uLmluZm8gJiYgYWN0aW9uLmluZm8ucGlja2VkID8gYWN0aW9uLmluZm8gOiBudWxsXG59KTtcblxuLyoqXG4gKiBUcmlnZ2VyIG1hcCBjbGljayBldmVudCwgdW5zZWxlY3QgY2xpY2tlZCBvYmplY3RcbiAqIEBtZW1iZXJvZiB2aXNTdGF0ZVVwZGF0ZXJzXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCBtYXBDbGlja1VwZGF0ZXIgPSAoXG4gIHN0YXRlOiBWaXNTdGF0ZSxcbiAgYWN0aW9uOiBWaXNTdGF0ZUFjdGlvbnMuT25NYXBDbGlja1VwZGF0ZXJBY3Rpb25cbik6IFZpc1N0YXRlID0+IHtcbiAgcmV0dXJuIHtcbiAgICAuLi5zdGF0ZSxcbiAgICBjbGlja2VkOiBudWxsXG4gIH07XG59O1xuXG4vKipcbiAqIFRyaWdnZXIgbWFwIG1vdmUgZXZlbnRcbiAqIEBtZW1iZXJvZiB2aXNTdGF0ZVVwZGF0ZXJzXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCBtb3VzZU1vdmVVcGRhdGVyID0gKFxuICBzdGF0ZTogVmlzU3RhdGUsXG4gIHtldnR9OiBWaXNTdGF0ZUFjdGlvbnMuT25Nb3VzZU1vdmVVcGRhdGVyQWN0aW9uXG4pOiBWaXNTdGF0ZSA9PiB7XG4gIGlmIChPYmplY3QudmFsdWVzKHN0YXRlLmludGVyYWN0aW9uQ29uZmlnKS5zb21lKGNvbmZpZyA9PiBjb25maWcuZW5hYmxlZCkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uc3RhdGUsXG4gICAgICBtb3VzZVBvczoge1xuICAgICAgICAuLi5zdGF0ZS5tb3VzZVBvcyxcbiAgICAgICAgLi4uKEFycmF5LmlzQXJyYXkoZXZ0LnBvaW50KSA/IHttb3VzZVBvc2l0aW9uOiBbLi4uZXZ0LnBvaW50XX0gOiB7fSksXG4gICAgICAgIC4uLihBcnJheS5pc0FycmF5KGV2dC5sbmdMYXQpID8ge2Nvb3JkaW5hdGU6IFsuLi5ldnQubG5nTGF0XX0gOiB7fSlcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHN0YXRlO1xufTtcbi8qKlxuICogVG9nZ2xlIHZpc2liaWxpdHkgb2YgYSBsYXllciBmb3IgYSBzcGxpdCBtYXBcbiAqIEBtZW1iZXJvZiB2aXNTdGF0ZVVwZGF0ZXJzXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCB0b2dnbGVTcGxpdE1hcFVwZGF0ZXIgPSAoXG4gIHN0YXRlOiBWaXNTdGF0ZSxcbiAgYWN0aW9uOiBNYXBTdGF0ZUFjdGlvbnMuVG9nZ2xlU3BsaXRNYXBVcGRhdGVyQWN0aW9uXG4pOiBWaXNTdGF0ZSA9PlxuICBzdGF0ZS5zcGxpdE1hcHMgJiYgc3RhdGUuc3BsaXRNYXBzLmxlbmd0aCA9PT0gMFxuICAgID8ge1xuICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgLy8gbWF5YmUgd2Ugc2hvdWxkIHVzZSBhbiBhcnJheSB0byBzdG9yZSBzdGF0ZSBmb3IgYSBzaW5nbGUgbWFwIGFzIHdlbGxcbiAgICAgICAgLy8gaWYgY3VycmVudCBtYXBzIGxlbmd0aCBpcyBlcXVhbCB0byAwIGl0IG1lYW5zIHRoYXQgd2UgYXJlIGFib3V0IHRvIHNwbGl0IHRoZSB2aWV3XG4gICAgICAgIHNwbGl0TWFwczogY29tcHV0ZVNwbGl0TWFwTGF5ZXJzKHN0YXRlLmxheWVycylcbiAgICAgIH1cbiAgICA6IGNsb3NlU3BlY2lmaWNNYXBBdEluZGV4KHN0YXRlLCBhY3Rpb24pO1xuXG4vKipcbiAqIFRvZ2dsZSB2aXNpYmlsaXR5IG9mIGEgbGF5ZXIgaW4gYSBzcGxpdCBtYXBcbiAqIEBtZW1iZXJvZiB2aXNTdGF0ZVVwZGF0ZXJzXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCB0b2dnbGVMYXllckZvck1hcFVwZGF0ZXIgPSAoXG4gIHN0YXRlOiBWaXNTdGF0ZSxcbiAge21hcEluZGV4LCBsYXllcklkfTogVmlzU3RhdGVBY3Rpb25zLlRvZ2dsZUxheWVyRm9yTWFwVXBkYXRlckFjdGlvblxuKTogVmlzU3RhdGUgPT4ge1xuICBjb25zdCB7c3BsaXRNYXBzfSA9IHN0YXRlO1xuXG4gIHJldHVybiB7XG4gICAgLi4uc3RhdGUsXG4gICAgc3BsaXRNYXBzOiBzcGxpdE1hcHMubWFwKChzbSwgaSkgPT5cbiAgICAgIGkgPT09IG1hcEluZGV4XG4gICAgICAgID8ge1xuICAgICAgICAgICAgLi4uc3BsaXRNYXBzW2ldLFxuICAgICAgICAgICAgbGF5ZXJzOiB7XG4gICAgICAgICAgICAgIC4uLnNwbGl0TWFwc1tpXS5sYXllcnMsXG4gICAgICAgICAgICAgIC8vIGlmIGxheWVySWQgbm90IGluIGxheWVycywgc2V0IGl0IHRvIHZpc2libGVcbiAgICAgICAgICAgICAgW2xheWVySWRdOiAhc3BsaXRNYXBzW2ldLmxheWVyc1tsYXllcklkXVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgOiBzbVxuICAgIClcbiAgfTtcbn07XG5cbi8qKlxuICogQWRkIG5ldyBkYXRhc2V0IHRvIGB2aXNTdGF0ZWAsIHdpdGggb3B0aW9uIHRvIGxvYWQgYSBtYXAgY29uZmlnIGFsb25nIHdpdGggdGhlIGRhdGFzZXRzXG4gKiBAbWVtYmVyb2YgdmlzU3RhdGVVcGRhdGVyc1xuICogQHB1YmxpY1xuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtc3RhdGVtZW50cyAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbmV4cG9ydCBjb25zdCB1cGRhdGVWaXNEYXRhVXBkYXRlciA9IChcbiAgc3RhdGU6IFZpc1N0YXRlLFxuICBhY3Rpb246IFZpc1N0YXRlQWN0aW9ucy5VcGRhdGVWaXNEYXRhVXBkYXRlckFjdGlvblxuKTogVmlzU3RhdGUgPT4ge1xuICAvLyBkYXRhc2V0cyBjYW4gYmUgYSBzaW5nbGUgZGF0YSBlbnRyaWVzIG9yIGFuIGFycmF5IG9mIG11bHRpcGxlIGRhdGEgZW50cmllc1xuICBjb25zdCB7Y29uZmlnLCBvcHRpb25zfSA9IGFjdGlvbjtcbiAgY29uc3QgZGF0YXNldHMgPSB0b0FycmF5KGFjdGlvbi5kYXRhc2V0cyk7XG5cbiAgY29uc3QgbmV3RGF0YUVudHJpZXMgPSBkYXRhc2V0cy5yZWR1Y2UoXG4gICAgKGFjY3UsIHtpbmZvID0ge30sIC4uLnJlc3R9ID0ge30pID0+ICh7XG4gICAgICAuLi5hY2N1LFxuICAgICAgLi4uKGNyZWF0ZU5ld0RhdGFFbnRyeSh7aW5mbywgLi4ucmVzdH0sIHN0YXRlLmRhdGFzZXRzKSB8fCB7fSlcbiAgICB9KSxcbiAgICB7fVxuICApO1xuXG4gIGNvbnN0IGRhdGFFbXB0eSA9IE9iamVjdC5rZXlzKG5ld0RhdGFFbnRyaWVzKS5sZW5ndGggPCAxO1xuXG4gIC8vIGFwcGx5IGNvbmZpZyBpZiBwYXNzZWQgZnJvbSBhY3Rpb25cbiAgY29uc3QgcHJldmlvdXNTdGF0ZSA9IGNvbmZpZ1xuICAgID8gcmVjZWl2ZU1hcENvbmZpZ1VwZGF0ZXIoc3RhdGUsIHtcbiAgICAgICAgcGF5bG9hZDoge2NvbmZpZywgb3B0aW9uc31cbiAgICAgIH0pXG4gICAgOiBzdGF0ZTtcblxuICBsZXQgbWVyZ2VkU3RhdGUgPSB7XG4gICAgLi4ucHJldmlvdXNTdGF0ZSxcbiAgICBkYXRhc2V0czoge1xuICAgICAgLi4ucHJldmlvdXNTdGF0ZS5kYXRhc2V0cyxcbiAgICAgIC4uLm5ld0RhdGFFbnRyaWVzXG4gICAgfVxuICB9O1xuXG4gIC8vIG1lcmdlIHN0YXRlIHdpdGggY29uZmlnIHRvIGJlIG1lcmdlZFxuICBmb3IgKGNvbnN0IG1lcmdlciBvZiBtZXJnZWRTdGF0ZS5tZXJnZXJzKSB7XG4gICAgaWYgKGlzVmFsaWRNZXJnZXIobWVyZ2VyKSAmJiBtZXJnZXIudG9NZXJnZVByb3AgJiYgbWVyZ2VkU3RhdGVbbWVyZ2VyLnRvTWVyZ2VQcm9wXSkge1xuICAgICAgY29uc3QgdG9NZXJnZSA9IG1lcmdlZFN0YXRlW21lcmdlci50b01lcmdlUHJvcF07XG4gICAgICBtZXJnZWRTdGF0ZVttZXJnZXIudG9NZXJnZVByb3BdID0gSU5JVElBTF9WSVNfU1RBVEVbbWVyZ2VyLnRvTWVyZ2VQcm9wXTtcbiAgICAgIG1lcmdlZFN0YXRlID0gbWVyZ2VyLm1lcmdlKG1lcmdlZFN0YXRlLCB0b01lcmdlKTtcbiAgICB9XG4gIH1cblxuICBsZXQgbmV3TGF5ZXJzID0gIWRhdGFFbXB0eVxuICAgID8gbWVyZ2VkU3RhdGUubGF5ZXJzLmZpbHRlcihsID0+IGwuY29uZmlnLmRhdGFJZCAmJiBsLmNvbmZpZy5kYXRhSWQgaW4gbmV3RGF0YUVudHJpZXMpXG4gICAgOiBbXTtcblxuICBpZiAoIW5ld0xheWVycy5sZW5ndGggJiYgKG9wdGlvbnMgfHwge30pLmF1dG9DcmVhdGVMYXllcnMgIT09IGZhbHNlKSB7XG4gICAgLy8gbm8gbGF5ZXIgbWVyZ2VkLCBmaW5kIGRlZmF1bHRzXG4gICAgY29uc3QgcmVzdWx0ID0gYWRkRGVmYXVsdExheWVycyhtZXJnZWRTdGF0ZSwgbmV3RGF0YUVudHJpZXMpO1xuICAgIG1lcmdlZFN0YXRlID0gcmVzdWx0LnN0YXRlO1xuICAgIG5ld0xheWVycyA9IHJlc3VsdC5uZXdMYXllcnM7XG4gIH1cblxuICBpZiAobWVyZ2VkU3RhdGUuc3BsaXRNYXBzLmxlbmd0aCkge1xuICAgIC8vIGlmIG1hcCBpcyBzcGxpdCwgYWRkIG5ldyBsYXllcnMgdG8gc3BsaXRNYXBzXG4gICAgbmV3TGF5ZXJzID0gbWVyZ2VkU3RhdGUubGF5ZXJzLmZpbHRlcihcbiAgICAgIGwgPT4gbC5jb25maWcuZGF0YUlkICYmIGwuY29uZmlnLmRhdGFJZCBpbiBuZXdEYXRhRW50cmllc1xuICAgICk7XG4gICAgbWVyZ2VkU3RhdGUgPSB7XG4gICAgICAuLi5tZXJnZWRTdGF0ZSxcbiAgICAgIHNwbGl0TWFwczogYWRkTmV3TGF5ZXJzVG9TcGxpdE1hcChtZXJnZWRTdGF0ZS5zcGxpdE1hcHMsIG5ld0xheWVycylcbiAgICB9O1xuICB9XG5cbiAgLy8gaWYgbm8gdG9vbHRpcHMgbWVyZ2VkIGFkZCBkZWZhdWx0IHRvb2x0aXBzXG4gIE9iamVjdC5rZXlzKG5ld0RhdGFFbnRyaWVzKS5mb3JFYWNoKGRhdGFJZCA9PiB7XG4gICAgY29uc3QgdG9vbHRpcEZpZWxkcyA9IG1lcmdlZFN0YXRlLmludGVyYWN0aW9uQ29uZmlnLnRvb2x0aXAuY29uZmlnLmZpZWxkc1RvU2hvd1tkYXRhSWRdO1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh0b29sdGlwRmllbGRzKSB8fCAhdG9vbHRpcEZpZWxkcy5sZW5ndGgpIHtcbiAgICAgIG1lcmdlZFN0YXRlID0gYWRkRGVmYXVsdFRvb2x0aXBzKG1lcmdlZFN0YXRlLCBuZXdEYXRhRW50cmllc1tkYXRhSWRdKTtcbiAgICB9XG4gIH0pO1xuXG4gIGxldCB1cGRhdGVkU3RhdGUgPSB1cGRhdGVBbGxMYXllckRvbWFpbkRhdGEoXG4gICAgbWVyZ2VkU3RhdGUsXG4gICAgZGF0YUVtcHR5ID8gT2JqZWN0LmtleXMobWVyZ2VkU3RhdGUuZGF0YXNldHMpIDogT2JqZWN0LmtleXMobmV3RGF0YUVudHJpZXMpLFxuICAgIHVuZGVmaW5lZFxuICApO1xuXG4gIC8vIHJlZ2lzdGVyIGxheWVyIGFuaW1hdGlvbiBkb21haW4sXG4gIC8vIG5lZWQgdG8gYmUgY2FsbGVkIGFmdGVyIGxheWVyIGRhdGEgaXMgY2FsY3VsYXRlZFxuICB1cGRhdGVkU3RhdGUgPSB1cGRhdGVBbmltYXRpb25Eb21haW4odXBkYXRlZFN0YXRlKTtcblxuICByZXR1cm4gdXBkYXRlZFN0YXRlO1xufTtcbi8qIGVzbGludC1lbmFibGUgbWF4LXN0YXRlbWVudHMgKi9cblxuLyoqXG4gKiBSZW5hbWUgYW4gZXhpc3RpbmcgZGF0YXNldCBpbiBgdmlzU3RhdGVgXG4gKiBAbWVtYmVyb2YgdmlzU3RhdGVVcGRhdGVyc1xuICogQHB1YmxpY1xuICovXG5leHBvcnQgZnVuY3Rpb24gcmVuYW1lRGF0YXNldFVwZGF0ZXIoXG4gIHN0YXRlOiBWaXNTdGF0ZSxcbiAgYWN0aW9uOiBWaXNTdGF0ZUFjdGlvbnMuUmVuYW1lRGF0YXNldFVwZGF0ZXJBY3Rpb25cbik6IFZpc1N0YXRlIHtcbiAgY29uc3Qge2RhdGFJZCwgbGFiZWx9ID0gYWN0aW9uO1xuICBjb25zdCB7ZGF0YXNldHN9ID0gc3RhdGU7XG4gIGNvbnN0IGV4aXN0aW5nID0gZGF0YXNldHNbZGF0YUlkXTtcblxuICBpZiAoZXhpc3RpbmcpIHtcbiAgICBjb25zdCBuZXdEYXRhc2V0ID0gY29weVRhYmxlQW5kVXBkYXRlKGV4aXN0aW5nLCB7bGFiZWx9KTtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uc3RhdGUsXG4gICAgICBkYXRhc2V0czoge1xuICAgICAgICAuLi5kYXRhc2V0cyxcbiAgICAgICAgW2RhdGFJZF06IG5ld0RhdGFzZXRcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLy8gTm8tb3AgaWYgdGhlIGRhdGFzZXQgZG9lc24ndCBleGlzdFxuICByZXR1cm4gc3RhdGU7XG59XG5cbi8qKlxuICogV2hlbiBhIHVzZXIgY2xpY2tzIG9uIHRoZSBzcGVjaWZpYyBtYXAgY2xvc2luZyBpY29uXG4gKiB0aGUgYXBwbGljYXRpb24gd2lsbCBjbG9zZSB0aGUgc2VsZWN0ZWQgbWFwXG4gKiBhbmQgd2lsbCBtZXJnZSB0aGUgcmVtYWluaW5nIG9uZSB3aXRoIHRoZSBnbG9iYWwgc3RhdGVcbiAqIFRPRE86IGkgdGhpbmsgaW4gdGhlIGZ1dHVyZSB0aGlzIGFjdGlvbiBzaG91bGQgYmUgY2FsbGVkIG1lcmdlIG1hcCBsYXllcnMgd2l0aCBnbG9iYWwgc2V0dGluZ3NcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZSBgdmlzU3RhdGVgXG4gKiBAcGFyYW0ge09iamVjdH0gYWN0aW9uIGFjdGlvblxuICogQHJldHVybnMge09iamVjdH0gbmV4dFN0YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbG9zZVNwZWNpZmljTWFwQXRJbmRleDxTIGV4dGVuZHMgVmlzU3RhdGU+KFxuICBzdGF0ZTogUyxcbiAgYWN0aW9uOiBNYXBTdGF0ZUFjdGlvbnMuVG9nZ2xlU3BsaXRNYXBVcGRhdGVyQWN0aW9uXG4pOiBTIHtcbiAgLy8gcmV0cmlldmUgbGF5ZXJzIG1ldGEgZGF0YSBmcm9tIHRoZSByZW1haW5pbmcgbWFwIHRoYXQgd2UgbmVlZCB0byBrZWVwXG4gIGNvbnN0IGluZGV4VG9SZXRyaWV2ZSA9IDEgLSBhY3Rpb24ucGF5bG9hZDtcbiAgY29uc3QgbWFwTGF5ZXJzID0gc3RhdGUuc3BsaXRNYXBzW2luZGV4VG9SZXRyaWV2ZV0/LmxheWVycztcbiAgY29uc3Qge2xheWVyc30gPSBzdGF0ZTtcblxuICAvLyB1cGRhdGUgbGF5ZXIgdmlzaWJpbGl0eVxuICBjb25zdCBuZXdMYXllcnMgPSBsYXllcnMubWFwKGxheWVyID0+XG4gICAgbWFwTGF5ZXJzICYmICFtYXBMYXllcnNbbGF5ZXIuaWRdICYmIGxheWVyLmNvbmZpZy5pc1Zpc2libGVcbiAgICAgID8gbGF5ZXIudXBkYXRlTGF5ZXJDb25maWcoe1xuICAgICAgICAgIC8vIGlmIGxheWVyLmlkIGlzIG5vdCBpbiBtYXBMYXllcnMsIGl0IHNob3VsZCBiZSBpblZpc2libGVcbiAgICAgICAgICBpc1Zpc2libGU6IGZhbHNlXG4gICAgICAgIH0pXG4gICAgICA6IGxheWVyXG4gICk7XG5cbiAgLy8gZGVsZXRlIG1hcFxuICByZXR1cm4ge1xuICAgIC4uLnN0YXRlLFxuICAgIGxheWVyczogbmV3TGF5ZXJzLFxuICAgIHNwbGl0TWFwczogW11cbiAgfTtcbn1cblxuLyoqXG4gKiBUcmlnZ2VyIGZpbGUgbG9hZGluZyBkaXNwYXRjaCBgYWRkRGF0YVRvTWFwYCBpZiBzdWNjZWVkLCBvciBgbG9hZEZpbGVzRXJyYCBpZiBmYWlsZWRcbiAqIEBtZW1iZXJvZiB2aXNTdGF0ZVVwZGF0ZXJzXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCBsb2FkRmlsZXNVcGRhdGVyID0gKFxuICBzdGF0ZTogVmlzU3RhdGUsXG4gIGFjdGlvbjogVmlzU3RhdGVBY3Rpb25zLkxvYWRGaWxlc1VwZGF0ZXJBY3Rpb25cbik6IFZpc1N0YXRlID0+IHtcbiAgY29uc3Qge2ZpbGVzLCBvbkZpbmlzaCA9IGxvYWRGaWxlc1N1Y2Nlc3N9ID0gYWN0aW9uO1xuICBpZiAoIWZpbGVzLmxlbmd0aCkge1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuXG4gIGNvbnN0IGZpbGVMb2FkaW5nUHJvZ3Jlc3MgPSBBcnJheS5mcm9tKGZpbGVzKS5yZWR1Y2UoXG4gICAgKGFjY3UsIGYsIGkpID0+IG1lcmdlXyhpbml0aWFsRmlsZUxvYWRpbmdQcm9ncmVzcyhmLCBpKSkoYWNjdSksXG4gICAge31cbiAgKTtcblxuICBjb25zdCBmaWxlTG9hZGluZyA9IHtcbiAgICBmaWxlQ2FjaGU6IFtdLFxuICAgIGZpbGVzVG9Mb2FkOiBmaWxlcyxcbiAgICBvbkZpbmlzaFxuICB9O1xuXG4gIGNvbnN0IG5leHRTdGF0ZSA9IG1lcmdlXyh7ZmlsZUxvYWRpbmdQcm9ncmVzcywgZmlsZUxvYWRpbmd9KShzdGF0ZSk7XG5cbiAgcmV0dXJuIGxvYWROZXh0RmlsZVVwZGF0ZXIobmV4dFN0YXRlKTtcbn07XG5cbi8qKlxuICogU3VjZXNzZnVsbHkgbG9hZGVkIG9uZSBmaWxlLCBtb3ZlIG9uIHRvIHRoZSBuZXh0IG9uZVxuICogQG1lbWJlcm9mIHZpc1N0YXRlVXBkYXRlcnNcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxvYWRGaWxlU3RlcFN1Y2Nlc3NVcGRhdGVyKFxuICBzdGF0ZTogVmlzU3RhdGUsXG4gIGFjdGlvbjogVmlzU3RhdGVBY3Rpb25zLkxvYWRGaWxlU3RlcFN1Y2Nlc3NBY3Rpb25cbik6IFZpc1N0YXRlIHtcbiAgaWYgKCFzdGF0ZS5maWxlTG9hZGluZykge1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuICBjb25zdCB7ZmlsZU5hbWUsIGZpbGVDYWNoZX0gPSBhY3Rpb247XG4gIGNvbnN0IHtmaWxlc1RvTG9hZCwgb25GaW5pc2h9ID0gc3RhdGUuZmlsZUxvYWRpbmc7XG4gIGNvbnN0IHN0YXRlV2l0aFByb2dyZXNzID0gdXBkYXRlRmlsZUxvYWRpbmdQcm9ncmVzc1VwZGF0ZXIoc3RhdGUsIHtcbiAgICBmaWxlTmFtZSxcbiAgICBwcm9ncmVzczoge3BlcmNlbnQ6IDEsIG1lc3NhZ2U6ICdEb25lJ31cbiAgfSk7XG5cbiAgLy8gc2F2ZSBwcm9jZXNzZWQgZmlsZSB0byBmaWxlQ2FjaGVcbiAgY29uc3Qgc3RhdGVXaXRoQ2FjaGUgPSBwaWNrXygnZmlsZUxvYWRpbmcnKShtZXJnZV8oe2ZpbGVDYWNoZX0pKShzdGF0ZVdpdGhQcm9ncmVzcyk7XG5cbiAgcmV0dXJuIHdpdGhUYXNrKFxuICAgIHN0YXRlV2l0aENhY2hlLFxuICAgIERFTEFZX1RBU0soMjAwKS5tYXAoZmlsZXNUb0xvYWQubGVuZ3RoID8gbG9hZE5leHRGaWxlIDogKCkgPT4gb25GaW5pc2goZmlsZUNhY2hlKSlcbiAgKTtcbn1cblxuLy8gd2l0aFRhc2s8VD4oc3RhdGU6IFQsIHRhc2s6IGFueSk6IFRcblxuLyoqXG4gKlxuICogQG1lbWJlcm9mIHZpc1N0YXRlVXBkYXRlcnNcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxvYWROZXh0RmlsZVVwZGF0ZXIoc3RhdGU6IFZpc1N0YXRlKTogVmlzU3RhdGUge1xuICBpZiAoIXN0YXRlLmZpbGVMb2FkaW5nKSB7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG4gIGNvbnN0IHtmaWxlc1RvTG9hZH0gPSBzdGF0ZS5maWxlTG9hZGluZztcbiAgY29uc3QgW2ZpbGUsIC4uLnJlbWFpbmluZ0ZpbGVzVG9Mb2FkXSA9IGZpbGVzVG9Mb2FkO1xuXG4gIC8vIHNhdmUgZmlsZXNUb0xvYWQgdG8gc3RhdGVcbiAgY29uc3QgbmV4dFN0YXRlID0gcGlja18oJ2ZpbGVMb2FkaW5nJykobWVyZ2VfKHtmaWxlc1RvTG9hZDogcmVtYWluaW5nRmlsZXNUb0xvYWR9KSkoc3RhdGUpO1xuXG4gIGNvbnN0IHN0YXRlV2l0aFByb2dyZXNzID0gdXBkYXRlRmlsZUxvYWRpbmdQcm9ncmVzc1VwZGF0ZXIobmV4dFN0YXRlLCB7XG4gICAgZmlsZU5hbWU6IGZpbGUubmFtZSxcbiAgICBwcm9ncmVzczoge3BlcmNlbnQ6IDAsIG1lc3NhZ2U6ICdsb2FkaW5nLi4uJ31cbiAgfSk7XG5cbiAgY29uc3Qge2xvYWRlcnMsIGxvYWRPcHRpb25zfSA9IHN0YXRlO1xuICByZXR1cm4gd2l0aFRhc2soXG4gICAgc3RhdGVXaXRoUHJvZ3Jlc3MsXG4gICAgbWFrZUxvYWRGaWxlVGFzayhcbiAgICAgIGZpbGUsXG4gICAgICBuZXh0U3RhdGUuZmlsZUxvYWRpbmcgJiYgbmV4dFN0YXRlLmZpbGVMb2FkaW5nLmZpbGVDYWNoZSxcbiAgICAgIGxvYWRlcnMsXG4gICAgICBsb2FkT3B0aW9uc1xuICAgIClcbiAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1ha2VMb2FkRmlsZVRhc2soZmlsZSwgZmlsZUNhY2hlLCBsb2FkZXJzOiBMb2FkZXJbXSA9IFtdLCBsb2FkT3B0aW9ucyA9IHt9KSB7XG4gIHJldHVybiBMT0FEX0ZJTEVfVEFTSyh7ZmlsZSwgZmlsZUNhY2hlLCBsb2FkZXJzLCBsb2FkT3B0aW9uc30pLmJpbWFwKFxuICAgIC8vIHByZXR0aWVyIGlnbm9yZVxuICAgIC8vIHN1Y2Nlc3NcbiAgICBnZW4gPT5cbiAgICAgIG5leHRGaWxlQmF0Y2goe1xuICAgICAgICBnZW4sXG4gICAgICAgIGZpbGVOYW1lOiBmaWxlLm5hbWUsXG4gICAgICAgIG9uRmluaXNoOiByZXN1bHQgPT5cbiAgICAgICAgICBwcm9jZXNzRmlsZUNvbnRlbnQoe1xuICAgICAgICAgICAgY29udGVudDogcmVzdWx0LFxuICAgICAgICAgICAgZmlsZUNhY2hlXG4gICAgICAgICAgfSlcbiAgICAgIH0pLFxuXG4gICAgLy8gZXJyb3JcbiAgICBlcnIgPT4gbG9hZEZpbGVzRXJyKGZpbGUubmFtZSwgZXJyKVxuICApO1xufVxuXG4vKipcbiAqXG4gKiBAbWVtYmVyb2YgdmlzU3RhdGVVcGRhdGVyc1xuICogQHB1YmxpY1xuICovXG5leHBvcnQgZnVuY3Rpb24gcHJvY2Vzc0ZpbGVDb250ZW50VXBkYXRlcihcbiAgc3RhdGU6IFZpc1N0YXRlLFxuICBhY3Rpb246IFZpc1N0YXRlQWN0aW9ucy5Qcm9jZXNzRmlsZUNvbnRlbnRVcGRhdGVyQWN0aW9uXG4pOiBWaXNTdGF0ZSB7XG4gIGNvbnN0IHtjb250ZW50LCBmaWxlQ2FjaGV9ID0gYWN0aW9uLnBheWxvYWQ7XG5cbiAgY29uc3Qgc3RhdGVXaXRoUHJvZ3Jlc3MgPSB1cGRhdGVGaWxlTG9hZGluZ1Byb2dyZXNzVXBkYXRlcihzdGF0ZSwge1xuICAgIGZpbGVOYW1lOiBjb250ZW50LmZpbGVOYW1lLFxuICAgIHByb2dyZXNzOiB7cGVyY2VudDogMSwgbWVzc2FnZTogJ3Byb2Nlc3NpbmcuLi4nfVxuICB9KTtcblxuICByZXR1cm4gd2l0aFRhc2soXG4gICAgc3RhdGVXaXRoUHJvZ3Jlc3MsXG4gICAgUFJPQ0VTU19GSUxFX0RBVEEoe2NvbnRlbnQsIGZpbGVDYWNoZX0pLmJpbWFwKFxuICAgICAgcmVzdWx0ID0+IGxvYWRGaWxlU3RlcFN1Y2Nlc3Moe2ZpbGVOYW1lOiBjb250ZW50LmZpbGVOYW1lLCBmaWxlQ2FjaGU6IHJlc3VsdH0pLFxuICAgICAgZXJyID0+IGxvYWRGaWxlc0Vycihjb250ZW50LmZpbGVOYW1lLCBlcnIpXG4gICAgKVxuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VQcm9ncmVzcyhwcmV2UHJvZ3Jlc3MgPSB7fSwgcHJvZ3Jlc3MpIHtcbiAgLy8gVGhpcyBoYXBwZW5zIHdoZW4gcmVjZWl2aW5nIHF1ZXJ5IG1ldGFkYXRhIG9yIG90aGVyIGNhc2VzIHdlIGRvbid0XG4gIC8vIGhhdmUgYW4gdXBkYXRlIGZvciB0aGUgdXNlci5cbiAgaWYgKCFwcm9ncmVzcyB8fCAhcHJvZ3Jlc3MucGVyY2VudCkge1xuICAgIHJldHVybiB7fTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgcGVyY2VudDogcHJvZ3Jlc3MucGVyY2VudFxuICB9O1xufVxuXG4vKipcbiAqIGdldHMgY2FsbGVkIHdpdGggcGF5bG9hZCA9IEFzeW5jR2VuZXJhdG9yPD8/Pz5cbiAqIEBtZW1iZXJvZiB2aXNTdGF0ZVVwZGF0ZXJzXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCBuZXh0RmlsZUJhdGNoVXBkYXRlciA9IChcbiAgc3RhdGU6IFZpc1N0YXRlLFxuICB7XG4gICAgcGF5bG9hZDoge2dlbiwgZmlsZU5hbWUsIHByb2dyZXNzLCBhY2N1bXVsYXRlZCwgb25GaW5pc2h9XG4gIH06IFZpc1N0YXRlQWN0aW9ucy5OZXh0RmlsZUJhdGNoVXBkYXRlckFjdGlvblxuKTogVmlzU3RhdGUgPT4ge1xuICBjb25zdCBzdGF0ZVdpdGhQcm9ncmVzcyA9IHVwZGF0ZUZpbGVMb2FkaW5nUHJvZ3Jlc3NVcGRhdGVyKHN0YXRlLCB7XG4gICAgZmlsZU5hbWUsXG4gICAgcHJvZ3Jlc3M6IHBhcnNlUHJvZ3Jlc3Moc3RhdGUuZmlsZUxvYWRpbmdQcm9ncmVzc1tmaWxlTmFtZV0sIHByb2dyZXNzKVxuICB9KTtcbiAgcmV0dXJuIHdpdGhUYXNrKFxuICAgIHN0YXRlV2l0aFByb2dyZXNzLFxuICAgIFVOV1JBUF9UQVNLKGdlbi5uZXh0KCkpLmJpbWFwKFxuICAgICAgKHt2YWx1ZSwgZG9uZX0pID0+IHtcbiAgICAgICAgcmV0dXJuIGRvbmVcbiAgICAgICAgICA/IG9uRmluaXNoKGFjY3VtdWxhdGVkKVxuICAgICAgICAgIDogbmV4dEZpbGVCYXRjaCh7XG4gICAgICAgICAgICAgIGdlbixcbiAgICAgICAgICAgICAgZmlsZU5hbWUsXG4gICAgICAgICAgICAgIHByb2dyZXNzOiB2YWx1ZS5wcm9ncmVzcyxcbiAgICAgICAgICAgICAgYWNjdW11bGF0ZWQ6IHZhbHVlLFxuICAgICAgICAgICAgICBvbkZpbmlzaFxuICAgICAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgZXJyID0+IGxvYWRGaWxlc0VycihmaWxlTmFtZSwgZXJyKVxuICAgIClcbiAgKTtcbn07XG5cbi8qKlxuICogVHJpZ2dlciBsb2FkaW5nIGZpbGUgZXJyb3JcbiAqIEBtZW1iZXJvZiB2aXNTdGF0ZVVwZGF0ZXJzXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCBsb2FkRmlsZXNFcnJVcGRhdGVyID0gKFxuICBzdGF0ZTogVmlzU3RhdGUsXG4gIHtlcnJvciwgZmlsZU5hbWV9OiBWaXNTdGF0ZUFjdGlvbnMuTG9hZEZpbGVzRXJyVXBkYXRlckFjdGlvblxuKTogVmlzU3RhdGUgPT4ge1xuICAvLyB1cGRhdGUgdWkgd2l0aCBlcnJvciBtZXNzYWdlXG4gIENvbnNvbGUud2FybihlcnJvcik7XG4gIGlmICghc3RhdGUuZmlsZUxvYWRpbmcpIHtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cbiAgY29uc3Qge2ZpbGVzVG9Mb2FkLCBvbkZpbmlzaCwgZmlsZUNhY2hlfSA9IHN0YXRlLmZpbGVMb2FkaW5nO1xuXG4gIGNvbnN0IG5leHRTdGF0ZSA9IHVwZGF0ZUZpbGVMb2FkaW5nUHJvZ3Jlc3NVcGRhdGVyKHN0YXRlLCB7XG4gICAgZmlsZU5hbWUsXG4gICAgcHJvZ3Jlc3M6IHtlcnJvcn1cbiAgfSk7XG5cbiAgLy8ga2ljayBvZmYgbmV4dCBmaWxlIG9yIGZpbmlzaFxuICByZXR1cm4gd2l0aFRhc2soXG4gICAgbmV4dFN0YXRlLFxuICAgIERFTEFZX1RBU0soMjAwKS5tYXAoZmlsZXNUb0xvYWQubGVuZ3RoID8gbG9hZE5leHRGaWxlIDogKCkgPT4gb25GaW5pc2goZmlsZUNhY2hlKSlcbiAgKTtcbn07XG5cbi8qKlxuICogV2hlbiBzZWxlY3QgZGF0YXNldCBmb3IgZXhwb3J0LCBhcHBseSBjcHUgZmlsdGVyIHRvIHNlbGVjdGVkIGRhdGFzZXRcbiAqIEBtZW1iZXJvZiB2aXNTdGF0ZVVwZGF0ZXJzXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCBhcHBseUNQVUZpbHRlclVwZGF0ZXIgPSAoXG4gIHN0YXRlOiBWaXNTdGF0ZSxcbiAge2RhdGFJZH06IFZpc1N0YXRlQWN0aW9ucy5BcHBseUNQVUZpbHRlclVwZGF0ZXJBY3Rpb25cbik6IFZpc1N0YXRlID0+IHtcbiAgLy8gYXBwbHkgY3B1RmlsdGVyXG4gIGNvbnN0IGRhdGFJZHMgPSB0b0FycmF5KGRhdGFJZCk7XG5cbiAgcmV0dXJuIGRhdGFJZHMucmVkdWNlKChhY2N1LCBpZCkgPT4gZmlsdGVyRGF0YXNldENQVShhY2N1LCBpZCksIHN0YXRlKTtcbn07XG5cbi8qKlxuICogVXNlciBpbnB1dCB0byB1cGRhdGUgdGhlIGluZm8gb2YgdGhlIG1hcFxuICogQG1lbWJlcm9mIHZpc1N0YXRlVXBkYXRlcnNcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IHNldE1hcEluZm9VcGRhdGVyID0gKFxuICBzdGF0ZTogVmlzU3RhdGUsXG4gIGFjdGlvbjogVmlzU3RhdGVBY3Rpb25zLlNldE1hcEluZm9VcGRhdGVyQWN0aW9uXG4pOiBWaXNTdGF0ZSA9PiAoe1xuICAuLi5zdGF0ZSxcbiAgbWFwSW5mbzoge1xuICAgIC4uLnN0YXRlLm1hcEluZm8sXG4gICAgLi4uYWN0aW9uLmluZm9cbiAgfVxufSk7XG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byB1cGRhdGUgQWxsIGxheWVyIGRvbWFpbiBhbmQgbGF5ZXIgZGF0YSBvZiBzdGF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkRGVmYXVsdExheWVycyhcbiAgc3RhdGU6IFZpc1N0YXRlLFxuICBkYXRhc2V0czogRGF0YXNldHNcbik6IHtzdGF0ZTogVmlzU3RhdGU7IG5ld0xheWVyczogTGF5ZXJbXX0ge1xuICBjb25zdCBlbXB0eTogTGF5ZXJbXSA9IFtdO1xuICBjb25zdCBkZWZhdWx0TGF5ZXJzID0gT2JqZWN0LnZhbHVlcyhkYXRhc2V0cykucmVkdWNlKChhY2N1OiBMYXllcltdLCBkYXRhc2V0KSA9PiB7XG4gICAgY29uc3QgZm91bmRMYXllcnMgPSBmaW5kRGVmYXVsdExheWVyKGRhdGFzZXQsIHN0YXRlLmxheWVyQ2xhc3Nlcyk7XG4gICAgcmV0dXJuIGZvdW5kTGF5ZXJzICYmIGZvdW5kTGF5ZXJzLmxlbmd0aCA/IGFjY3UuY29uY2F0KGZvdW5kTGF5ZXJzKSA6IGFjY3U7XG4gIH0sIGVtcHR5KTtcblxuICByZXR1cm4ge1xuICAgIHN0YXRlOiB7XG4gICAgICAuLi5zdGF0ZSxcbiAgICAgIGxheWVyczogWy4uLnN0YXRlLmxheWVycywgLi4uZGVmYXVsdExheWVyc10sXG4gICAgICBsYXllck9yZGVyOiBbXG4gICAgICAgIC8vIHB1dCBuZXcgbGF5ZXJzIG9uIHRvcCBvZiBvbGQgb25lc1xuICAgICAgICAuLi5kZWZhdWx0TGF5ZXJzLm1hcCgoXywgaSkgPT4gc3RhdGUubGF5ZXJzLmxlbmd0aCArIGkpLFxuICAgICAgICAuLi5zdGF0ZS5sYXllck9yZGVyXG4gICAgICBdXG4gICAgfSxcbiAgICBuZXdMYXllcnM6IGRlZmF1bHRMYXllcnNcbiAgfTtcbn1cblxuLyoqXG4gKiBoZWxwZXIgZnVuY3Rpb24gdG8gZmluZCBkZWZhdWx0IHRvb2x0aXBzXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhc2V0XG4gKiBAcmV0dXJucyB7T2JqZWN0fSBuZXh0U3RhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZERlZmF1bHRUb29sdGlwcyhzdGF0ZSwgZGF0YXNldCkge1xuICBjb25zdCB0b29sdGlwRmllbGRzID0gZmluZEZpZWxkc1RvU2hvdyh7XG4gICAgLi4uZGF0YXNldCxcbiAgICBtYXhEZWZhdWx0VG9vbHRpcHM6IHN0YXRlLm1heERlZmF1bHRUb29sdGlwc1xuICB9KTtcbiAgY29uc3QgbWVyZ2VkID0ge1xuICAgIC4uLnN0YXRlLmludGVyYWN0aW9uQ29uZmlnLnRvb2x0aXAuY29uZmlnLmZpZWxkc1RvU2hvdyxcbiAgICAuLi50b29sdGlwRmllbGRzXG4gIH07XG5cbiAgcmV0dXJuIHNldChbJ2ludGVyYWN0aW9uQ29uZmlnJywgJ3Rvb2x0aXAnLCAnY29uZmlnJywgJ2ZpZWxkc1RvU2hvdyddLCBtZXJnZWQsIHN0YXRlKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGluaXRpYWxGaWxlTG9hZGluZ1Byb2dyZXNzKGZpbGUsIGluZGV4KSB7XG4gIGNvbnN0IGZpbGVOYW1lID0gZmlsZS5uYW1lIHx8IGBVbnRpdGxlZCBGaWxlICR7aW5kZXh9YDtcbiAgcmV0dXJuIHtcbiAgICBbZmlsZU5hbWVdOiB7XG4gICAgICAvLyBwZXJjZW50IG9mIGN1cnJlbnQgZmlsZVxuICAgICAgcGVyY2VudDogMCxcbiAgICAgIG1lc3NhZ2U6ICcnLFxuICAgICAgZmlsZU5hbWUsXG4gICAgICBlcnJvcjogbnVsbFxuICAgIH1cbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZUZpbGVMb2FkaW5nUHJvZ3Jlc3NVcGRhdGVyKHN0YXRlLCB7ZmlsZU5hbWUsIHByb2dyZXNzfSkge1xuICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gIHJldHVybiBwaWNrXygnZmlsZUxvYWRpbmdQcm9ncmVzcycpKHBpY2tfKGZpbGVOYW1lKShtZXJnZV8ocHJvZ3Jlc3MpKSkoc3RhdGUpO1xufVxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gdXBkYXRlIGxheWVyIGRvbWFpbnMgZm9yIGFuIGFycmF5IG9mIGRhdGFzZXRzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVBbGxMYXllckRvbWFpbkRhdGEoXG4gIHN0YXRlOiBWaXNTdGF0ZSxcbiAgZGF0YUlkOiBzdHJpbmcgfCBzdHJpbmdbXSxcbiAgdXBkYXRlZEZpbHRlcj86IEZpbHRlclxuKTogVmlzU3RhdGUge1xuICBjb25zdCBkYXRhSWRzID0gdHlwZW9mIGRhdGFJZCA9PT0gJ3N0cmluZycgPyBbZGF0YUlkXSA6IGRhdGFJZDtcbiAgY29uc3QgbmV3TGF5ZXJzOiBMYXllcltdID0gW107XG4gIGNvbnN0IG5ld0xheWVyRGF0YTogYW55W10gPSBbXTtcblxuICBzdGF0ZS5sYXllcnMuZm9yRWFjaCgob2xkTGF5ZXIsIGkpID0+IHtcbiAgICBpZiAob2xkTGF5ZXIuY29uZmlnLmRhdGFJZCAmJiBkYXRhSWRzLmluY2x1ZGVzKG9sZExheWVyLmNvbmZpZy5kYXRhSWQpKSB7XG4gICAgICAvLyBObyBuZWVkIHRvIHJlY2FsY3VsYXRlIGxheWVyIGRvbWFpbiBpZiBmaWx0ZXIgaGFzIGZpeGVkIGRvbWFpblxuICAgICAgY29uc3QgbmV3TGF5ZXIgPVxuICAgICAgICB1cGRhdGVkRmlsdGVyICYmIHVwZGF0ZWRGaWx0ZXIuZml4ZWREb21haW5cbiAgICAgICAgICA/IG9sZExheWVyXG4gICAgICAgICAgOiBvbGRMYXllci51cGRhdGVMYXllckRvbWFpbihzdGF0ZS5kYXRhc2V0cywgdXBkYXRlZEZpbHRlcik7XG5cbiAgICAgIGNvbnN0IHtsYXllckRhdGEsIGxheWVyfSA9IGNhbGN1bGF0ZUxheWVyRGF0YShuZXdMYXllciwgc3RhdGUsIHN0YXRlLmxheWVyRGF0YVtpXSk7XG5cbiAgICAgIG5ld0xheWVycy5wdXNoKGxheWVyKTtcbiAgICAgIG5ld0xheWVyRGF0YS5wdXNoKGxheWVyRGF0YSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld0xheWVycy5wdXNoKG9sZExheWVyKTtcbiAgICAgIG5ld0xheWVyRGF0YS5wdXNoKHN0YXRlLmxheWVyRGF0YVtpXSk7XG4gICAgfVxuICB9KTtcblxuICBjb25zdCBuZXdTdGF0ZSA9IHtcbiAgICAuLi5zdGF0ZSxcbiAgICBsYXllcnM6IG5ld0xheWVycyxcbiAgICBsYXllckRhdGE6IG5ld0xheWVyRGF0YVxuICB9O1xuXG4gIHJldHVybiBuZXdTdGF0ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZUFuaW1hdGlvbkRvbWFpbjxTIGV4dGVuZHMgVmlzU3RhdGU+KHN0YXRlOiBTKTogUyB7XG4gIC8vIG1lcmdlIGFsbCBhbmltYXRhYmxlIGxheWVyIGRvbWFpbiBhbmQgdXBkYXRlIGdsb2JhbCBjb25maWdcbiAgY29uc3QgYW5pbWF0YWJsZUxheWVycyA9IHN0YXRlLmxheWVycy5maWx0ZXIoXG4gICAgbCA9PlxuICAgICAgbC5jb25maWcuaXNWaXNpYmxlICYmXG4gICAgICBsLmNvbmZpZy5hbmltYXRpb24gJiZcbiAgICAgIGwuY29uZmlnLmFuaW1hdGlvbi5lbmFibGVkICYmXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIHRyaXAtbGF5ZXItb25seVxuICAgICAgQXJyYXkuaXNBcnJheShsLmFuaW1hdGlvbkRvbWFpbilcbiAgKTtcblxuICBpZiAoIWFuaW1hdGFibGVMYXllcnMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnN0YXRlLFxuICAgICAgYW5pbWF0aW9uQ29uZmlnOiB7XG4gICAgICAgIC4uLnN0YXRlLmFuaW1hdGlvbkNvbmZpZyxcbiAgICAgICAgZG9tYWluOiBudWxsLFxuICAgICAgICBkZWZhdWx0VGltZUZvcm1hdDogbnVsbFxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBjb25zdCBtZXJnZWREb21haW46IFtudW1iZXIsIG51bWJlcl0gPSBhbmltYXRhYmxlTGF5ZXJzLnJlZHVjZShcbiAgICAoYWNjdSwgbGF5ZXIpID0+IFtcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgdHJpcC1sYXllci1vbmx5XG4gICAgICBNYXRoLm1pbihhY2N1WzBdLCBsYXllci5hbmltYXRpb25Eb21haW5bMF0pLFxuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciB0cmlwLWxheWVyLW9ubHlcbiAgICAgIE1hdGgubWF4KGFjY3VbMV0sIGxheWVyLmFuaW1hdGlvbkRvbWFpblsxXSlcbiAgICBdLFxuICAgIFtOdW1iZXIoSW5maW5pdHkpLCAtSW5maW5pdHldXG4gICk7XG4gIGNvbnN0IGRlZmF1bHRUaW1lRm9ybWF0ID0gZ2V0VGltZVdpZGdldFRpdGxlRm9ybWF0dGVyKG1lcmdlZERvbWFpbik7XG5cbiAgcmV0dXJuIHtcbiAgICAuLi5zdGF0ZSxcbiAgICBhbmltYXRpb25Db25maWc6IHtcbiAgICAgIC4uLnN0YXRlLmFuaW1hdGlvbkNvbmZpZyxcbiAgICAgIGN1cnJlbnRUaW1lOiBpc0luUmFuZ2Uoc3RhdGUuYW5pbWF0aW9uQ29uZmlnLmN1cnJlbnRUaW1lLCBtZXJnZWREb21haW4pXG4gICAgICAgID8gc3RhdGUuYW5pbWF0aW9uQ29uZmlnLmN1cnJlbnRUaW1lXG4gICAgICAgIDogbWVyZ2VkRG9tYWluWzBdLFxuICAgICAgZG9tYWluOiBtZXJnZWREb21haW4sXG4gICAgICBkZWZhdWx0VGltZUZvcm1hdFxuICAgIH1cbiAgfTtcbn1cblxuLyoqXG4gKiBVcGRhdGUgdGhlIHN0YXR1cyBvZiB0aGUgZWRpdG9yXG4gKiBAbWVtYmVyb2YgdmlzU3RhdGVVcGRhdGVyc1xuICovXG5leHBvcnQgY29uc3Qgc2V0RWRpdG9yTW9kZVVwZGF0ZXIgPSAoXG4gIHN0YXRlOiBWaXNTdGF0ZSxcbiAge21vZGV9OiBWaXNTdGF0ZUFjdGlvbnMuU2V0RWRpdG9yTW9kZVVwZGF0ZXJBY3Rpb25cbik6IFZpc1N0YXRlID0+ICh7XG4gIC4uLnN0YXRlLFxuICBlZGl0b3I6IHtcbiAgICAuLi5zdGF0ZS5lZGl0b3IsXG4gICAgbW9kZSxcbiAgICBzZWxlY3RlZEZlYXR1cmU6IG51bGxcbiAgfVxufSk7XG5cbi8vIGNvbnN0IGZlYXR1cmVUb0ZpbHRlclZhbHVlID0gKGZlYXR1cmUpID0+ICh7Li4uZmVhdHVyZSwgaWQ6IGZlYXR1cmUuaWR9KTtcbi8qKlxuICogVXBkYXRlIGVkaXRvciBmZWF0dXJlc1xuICogQG1lbWJlcm9mIHZpc1N0YXRlVXBkYXRlcnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldEZlYXR1cmVzVXBkYXRlcihcbiAgc3RhdGU6IFZpc1N0YXRlLFxuICB7ZmVhdHVyZXMgPSBbXX06IFZpc1N0YXRlQWN0aW9ucy5TZXRGZWF0dXJlc1VwZGF0ZXJBY3Rpb25cbik6IFZpc1N0YXRlIHtcbiAgY29uc3QgbGFzdEZlYXR1cmUgPSBmZWF0dXJlcy5sZW5ndGggJiYgZmVhdHVyZXNbZmVhdHVyZXMubGVuZ3RoIC0gMV07XG5cbiAgY29uc3QgbmV3U3RhdGUgPSB7XG4gICAgLi4uc3RhdGUsXG4gICAgZWRpdG9yOiB7XG4gICAgICAuLi5zdGF0ZS5lZGl0b3IsXG4gICAgICAvLyBvbmx5IHNhdmUgbm9uZSBmaWx0ZXIgZmVhdHVyZXMgdG8gZWRpdG9yXG4gICAgICBmZWF0dXJlczogZmVhdHVyZXMuZmlsdGVyKGYgPT4gIWdldEZpbHRlcklkSW5GZWF0dXJlKGYpKSxcbiAgICAgIG1vZGU6IGxhc3RGZWF0dXJlICYmIGxhc3RGZWF0dXJlLnByb3BlcnRpZXMuaXNDbG9zZWQgPyBFRElUT1JfTU9ERVMuRURJVCA6IHN0YXRlLmVkaXRvci5tb2RlXG4gICAgfVxuICB9O1xuXG4gIC8vIFJldHJpZXZlIGV4aXN0aW5nIGZlYXR1cmVcbiAgY29uc3Qge3NlbGVjdGVkRmVhdHVyZX0gPSBzdGF0ZS5lZGl0b3I7XG5cbiAgLy8gSWYgbm8gZmVhdHVyZSBpcyBzZWxlY3RlZCB3ZSBjYW4gc2ltcGx5IHJldHVybiBzaW5jZSBubyBvcGVyYXRpb25zXG4gIGlmICghc2VsZWN0ZWRGZWF0dXJlKSB7XG4gICAgcmV0dXJuIG5ld1N0YXRlO1xuICB9XG5cbiAgLy8gVE9ETzogY2hlY2sgaWYgdGhlIGZlYXR1cmUgaGFzIGNoYW5nZWRcbiAgY29uc3QgZmVhdHVyZSA9IGZlYXR1cmVzLmZpbmQoZiA9PiBmLmlkID09PSBzZWxlY3RlZEZlYXR1cmUuaWQpO1xuXG4gIC8vIGlmIGZlYXR1cmUgaXMgcGFydCBvZiBhIGZpbHRlclxuICBjb25zdCBmaWx0ZXJJZCA9IGZlYXR1cmUgJiYgZ2V0RmlsdGVySWRJbkZlYXR1cmUoZmVhdHVyZSk7XG4gIGlmIChmaWx0ZXJJZCAmJiBmZWF0dXJlKSB7XG4gICAgY29uc3QgZmVhdHVyZVZhbHVlID0gZmVhdHVyZVRvRmlsdGVyVmFsdWUoZmVhdHVyZSwgZmlsdGVySWQpO1xuICAgIGNvbnN0IGZpbHRlcklkeCA9IHN0YXRlLmZpbHRlcnMuZmluZEluZGV4KGZpbCA9PiBmaWwuaWQgPT09IGZpbHRlcklkKTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgcmV0dXJuIHNldEZpbHRlclVwZGF0ZXIobmV3U3RhdGUsIHtcbiAgICAgIGlkeDogZmlsdGVySWR4LFxuICAgICAgcHJvcDogJ3ZhbHVlJyxcbiAgICAgIHZhbHVlOiBmZWF0dXJlVmFsdWVcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBuZXdTdGF0ZTtcbn1cblxuLyoqXG4gKiBTZXQgdGhlIGN1cnJlbnQgc2VsZWN0ZWQgZmVhdHVyZVxuICogQG1lbWJlcm9mIHVpU3RhdGVVcGRhdGVyc1xuICovXG5leHBvcnQgY29uc3Qgc2V0U2VsZWN0ZWRGZWF0dXJlVXBkYXRlciA9IChcbiAgc3RhdGU6IFZpc1N0YXRlLFxuICB7ZmVhdHVyZX06IFZpc1N0YXRlQWN0aW9ucy5TZXRTZWxlY3RlZEZlYXR1cmVVcGRhdGVyQWN0aW9uXG4pOiBWaXNTdGF0ZSA9PiAoe1xuICAuLi5zdGF0ZSxcbiAgZWRpdG9yOiB7XG4gICAgLi4uc3RhdGUuZWRpdG9yLFxuICAgIHNlbGVjdGVkRmVhdHVyZTogZmVhdHVyZVxuICB9XG59KTtcblxuLyoqXG4gKiBEZWxldGUgZXhpc3RpbmcgZmVhdHVyZSBmcm9tIGZpbHRlcnNcbiAqIEBtZW1iZXJvZiB2aXNTdGF0ZVVwZGF0ZXJzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWxldGVGZWF0dXJlVXBkYXRlcihcbiAgc3RhdGU6IFZpc1N0YXRlLFxuICB7ZmVhdHVyZX06IFZpc1N0YXRlQWN0aW9ucy5EZWxldGVGZWF0dXJlVXBkYXRlckFjdGlvblxuKTogVmlzU3RhdGUge1xuICBpZiAoIWZlYXR1cmUpIHtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cblxuICBjb25zdCBuZXdTdGF0ZSA9IHtcbiAgICAuLi5zdGF0ZSxcbiAgICBlZGl0b3I6IHtcbiAgICAgIC4uLnN0YXRlLmVkaXRvcixcbiAgICAgIHNlbGVjdGVkRmVhdHVyZTogbnVsbFxuICAgIH1cbiAgfTtcblxuICBpZiAoZ2V0RmlsdGVySWRJbkZlYXR1cmUoZmVhdHVyZSkpIHtcbiAgICBjb25zdCBmaWx0ZXJJZHggPSBuZXdTdGF0ZS5maWx0ZXJzLmZpbmRJbmRleChmID0+IGYuaWQgPT09IGdldEZpbHRlcklkSW5GZWF0dXJlKGZlYXR1cmUpKTtcblxuICAgIHJldHVybiBmaWx0ZXJJZHggPiAtMSA/IHJlbW92ZUZpbHRlclVwZGF0ZXIobmV3U3RhdGUsIHtpZHg6IGZpbHRlcklkeH0pIDogbmV3U3RhdGU7XG4gIH1cblxuICAvLyBtb2RpZnkgZWRpdG9yIG9iamVjdFxuICBjb25zdCBuZXdFZGl0b3IgPSB7XG4gICAgLi4uc3RhdGUuZWRpdG9yLFxuICAgIGZlYXR1cmVzOiBzdGF0ZS5lZGl0b3IuZmVhdHVyZXMuZmlsdGVyKGYgPT4gZi5pZCAhPT0gZmVhdHVyZS5pZCksXG4gICAgc2VsZWN0ZWRGZWF0dXJlOiBudWxsXG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICAuLi5zdGF0ZSxcbiAgICBlZGl0b3I6IG5ld0VkaXRvclxuICB9O1xufVxuXG4vKipcbiAqIFRvZ2dsZSBmZWF0dXJlIGFzIGxheWVyIGZpbHRlclxuICogQG1lbWJlcm9mIHZpc1N0YXRlVXBkYXRlcnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldFBvbHlnb25GaWx0ZXJMYXllclVwZGF0ZXIoXG4gIHN0YXRlOiBWaXNTdGF0ZSxcbiAgcGF5bG9hZDogVmlzU3RhdGVBY3Rpb25zLlNldFBvbHlnb25GaWx0ZXJMYXllclVwZGF0ZXJBY3Rpb25cbik6IFZpc1N0YXRlIHtcbiAgY29uc3Qge2xheWVyLCBmZWF0dXJlfSA9IHBheWxvYWQ7XG4gIGNvbnN0IGZpbHRlcklkID0gZ2V0RmlsdGVySWRJbkZlYXR1cmUoZmVhdHVyZSk7XG5cbiAgLy8gbGV0IG5ld0ZpbHRlciA9IG51bGw7XG4gIGxldCBmaWx0ZXJJZHg7XG4gIGxldCBuZXdMYXllcklkID0gW2xheWVyLmlkXTtcbiAgbGV0IG5ld1N0YXRlID0gc3RhdGU7XG4gIC8vIElmIHBvbHlnb24gZmlsdGVyIGFscmVhZHkgZXhpc3RzLCB3ZSBuZWVkIHRvIGZpbmQgb3V0IGlmIHRoZSBjdXJyZW50IGxheWVyIGlzIGFscmVhZHkgaW5jbHVkZWRcbiAgaWYgKGZpbHRlcklkKSB7XG4gICAgZmlsdGVySWR4ID0gc3RhdGUuZmlsdGVycy5maW5kSW5kZXgoZiA9PiBmLmlkID09PSBmaWx0ZXJJZCk7XG5cbiAgICBpZiAoIXN0YXRlLmZpbHRlcnNbZmlsdGVySWR4XSkge1xuICAgICAgLy8gd2hhdCBpZiBmaWx0ZXIgZG9lc24ndCBleGlzdD8uLi4gbm90IHBvc3NpYmxlLlxuICAgICAgLy8gYmVjYXVzZSBmZWF0dXJlcyBpbiB0aGUgZWRpdG9yIGlzIHBhc3NlZCBpbiBmcm9tIGZpbHRlcnMgYW5kIGVkaXRvcnMuXG4gICAgICAvLyBidXQgd2Ugd2lsbCBtb3ZlIHRoaXMgZmVhdHVyZSBiYWNrIHRvIGVkaXRvciBqdXN0IGluIGNhc2VcbiAgICAgIGNvbnN0IG5vbmVGaWx0ZXJGZWF0dXJlID0ge1xuICAgICAgICAuLi5mZWF0dXJlLFxuICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgLi4uZmVhdHVyZS5wcm9wZXJ0aWVzLFxuICAgICAgICAgIGZpbHRlcklkOiBudWxsXG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLnN0YXRlLFxuICAgICAgICBlZGl0b3I6IHtcbiAgICAgICAgICAuLi5zdGF0ZS5lZGl0b3IsXG4gICAgICAgICAgZmVhdHVyZXM6IFsuLi5zdGF0ZS5lZGl0b3IuZmVhdHVyZXMsIG5vbmVGaWx0ZXJGZWF0dXJlXSxcbiAgICAgICAgICBzZWxlY3RlZEZlYXR1cmU6IG5vbmVGaWx0ZXJGZWF0dXJlXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IGZpbHRlciA9IHN0YXRlLmZpbHRlcnNbZmlsdGVySWR4XTtcbiAgICBjb25zdCB7bGF5ZXJJZCA9IFtdfSA9IGZpbHRlcjtcbiAgICBjb25zdCBpc0xheWVySW5jbHVkZWQgPSBsYXllcklkLmluY2x1ZGVzKGxheWVyLmlkKTtcblxuICAgIG5ld0xheWVySWQgPSBpc0xheWVySW5jbHVkZWRcbiAgICAgID8gLy8gaWYgbGF5ZXIgaXMgaW5jbHVkZWQsIHJlbW92ZSBpdFxuICAgICAgICBsYXllcklkLmZpbHRlcihsID0+IGwgIT09IGxheWVyLmlkKVxuICAgICAgOiBbLi4ubGF5ZXJJZCwgbGF5ZXIuaWRdO1xuICB9IGVsc2Uge1xuICAgIC8vIGlmIHdlIGhhdmVuJ3QgY3JlYXRlIHRoZSBwb2x5Z29uIGZpbHRlciwgY3JlYXRlIGl0XG4gICAgY29uc3QgbmV3RmlsdGVyID0gZ2VuZXJhdGVQb2x5Z29uRmlsdGVyKFtdLCBmZWF0dXJlKTtcbiAgICBmaWx0ZXJJZHggPSBzdGF0ZS5maWx0ZXJzLmxlbmd0aDtcblxuICAgIC8vIGFkZCBmZWF0dXJlLCByZW1vdmUgZmVhdHVyZSBmcm9tIGVpZHRvclxuICAgIG5ld1N0YXRlID0ge1xuICAgICAgLi4uc3RhdGUsXG4gICAgICBmaWx0ZXJzOiBbLi4uc3RhdGUuZmlsdGVycywgbmV3RmlsdGVyXSxcbiAgICAgIGVkaXRvcjoge1xuICAgICAgICAuLi5zdGF0ZS5lZGl0b3IsXG4gICAgICAgIGZlYXR1cmVzOiBzdGF0ZS5lZGl0b3IuZmVhdHVyZXMuZmlsdGVyKGYgPT4gZi5pZCAhPT0gZmVhdHVyZS5pZCksXG4gICAgICAgIHNlbGVjdGVkRmVhdHVyZTogbmV3RmlsdGVyLnZhbHVlXG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBzZXRGaWx0ZXJVcGRhdGVyKG5ld1N0YXRlLCB7XG4gICAgaWR4OiBmaWx0ZXJJZHgsXG4gICAgcHJvcDogJ2xheWVySWQnLFxuICAgIHZhbHVlOiBuZXdMYXllcklkXG4gIH0pO1xufVxuXG4vKipcbiAqIEBtZW1iZXJvZiB2aXNTdGF0ZVVwZGF0ZXJzXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzb3J0VGFibGVDb2x1bW5VcGRhdGVyKFxuICBzdGF0ZTogVmlzU3RhdGUsXG4gIHtkYXRhSWQsIGNvbHVtbiwgbW9kZX06IFZpc1N0YXRlQWN0aW9ucy5Tb3J0VGFibGVDb2x1bW5VcGRhdGVyQWN0aW9uXG4pOiBWaXNTdGF0ZSB7XG4gIGNvbnN0IGRhdGFzZXQgPSBzdGF0ZS5kYXRhc2V0c1tkYXRhSWRdO1xuICBpZiAoIWRhdGFzZXQpIHtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cbiAgbGV0IHNvcnRNb2RlID0gbW9kZTtcbiAgaWYgKCFzb3J0TW9kZSkge1xuICAgIGNvbnN0IGN1cnJlbnRNb2RlID0gZ2V0KGRhdGFzZXQsIFsnc29ydENvbHVtbicsIGNvbHVtbl0pO1xuICAgIC8vIEB0cy1pZ25vcmUgLSBzaG91bGQgYmUgZml4YWJsZSBpbiBhIFRTIGZpbGVcbiAgICBzb3J0TW9kZSA9IGN1cnJlbnRNb2RlXG4gICAgICA/IE9iamVjdC5rZXlzKFNPUlRfT1JERVIpLmZpbmQobSA9PiBtICE9PSBjdXJyZW50TW9kZSlcbiAgICAgIDogU09SVF9PUkRFUi5BU0NFTkRJTkc7XG4gIH1cblxuICBjb25zdCBzb3J0ZWQgPSBzb3J0RGF0YXNldEJ5Q29sdW1uKGRhdGFzZXQsIGNvbHVtbiwgc29ydE1vZGUpO1xuICByZXR1cm4gc2V0KFsnZGF0YXNldHMnLCBkYXRhSWRdLCBzb3J0ZWQsIHN0YXRlKTtcbn1cblxuLyoqXG4gKiBAbWVtYmVyb2YgdmlzU3RhdGVVcGRhdGVyc1xuICogQHB1YmxpY1xuICovXG5leHBvcnQgZnVuY3Rpb24gcGluVGFibGVDb2x1bW5VcGRhdGVyKFxuICBzdGF0ZTogVmlzU3RhdGUsXG4gIHtkYXRhSWQsIGNvbHVtbn06IFZpc1N0YXRlQWN0aW9ucy5QaW5UYWJsZUNvbHVtblVwZGF0ZXJBY3Rpb25cbik6IFZpc1N0YXRlIHtcbiAgY29uc3QgZGF0YXNldCA9IHN0YXRlLmRhdGFzZXRzW2RhdGFJZF07XG4gIGlmICghZGF0YXNldCkge1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuICBjb25zdCBuZXdEYXRhc2V0ID0gcGluVGFibGVDb2x1bW5zKGRhdGFzZXQsIGNvbHVtbik7XG5cbiAgcmV0dXJuIHNldChbJ2RhdGFzZXRzJywgZGF0YUlkXSwgbmV3RGF0YXNldCwgc3RhdGUpO1xufVxuXG4vKipcbiAqIENvcHkgY29sdW1uIGNvbnRlbnQgYXMgc3RyaW5nc1xuICogQG1lbWJlcm9mIHZpc1N0YXRlVXBkYXRlcnNcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvcHlUYWJsZUNvbHVtblVwZGF0ZXIoXG4gIHN0YXRlOiBWaXNTdGF0ZSxcbiAge2RhdGFJZCwgY29sdW1ufTogVmlzU3RhdGVBY3Rpb25zLkNvcHlUYWJsZUNvbHVtblVwZGF0ZXJBY3Rpb25cbik6IFZpc1N0YXRlIHtcbiAgY29uc3QgZGF0YXNldCA9IHN0YXRlLmRhdGFzZXRzW2RhdGFJZF07XG4gIGlmICghZGF0YXNldCkge1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuICBjb25zdCBmaWVsZElkeCA9IGRhdGFzZXQuZmllbGRzLmZpbmRJbmRleChmID0+IGYubmFtZSA9PT0gY29sdW1uKTtcbiAgaWYgKGZpZWxkSWR4IDwgMCkge1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuICBjb25zdCB7dHlwZX0gPSBkYXRhc2V0LmZpZWxkc1tmaWVsZElkeF07XG4gIGNvbnN0IHRleHQgPSBkYXRhc2V0LmRhdGFDb250YWluZXJcbiAgICAubWFwKHJvdyA9PiBwYXJzZUZpZWxkVmFsdWUocm93LnZhbHVlQXQoZmllbGRJZHgpLCB0eXBlKSwgdHJ1ZSlcbiAgICAuam9pbignXFxuJyk7XG5cbiAgY29weSh0ZXh0KTtcblxuICByZXR1cm4gc3RhdGU7XG59XG5cbi8qKlxuICogVXBkYXRlIGVkaXRvclxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9nZ2xlRWRpdG9yVmlzaWJpbGl0eVVwZGF0ZXIoXG4gIHN0YXRlOiBWaXNTdGF0ZSxcbiAgYWN0aW9uOiBWaXNTdGF0ZUFjdGlvbnMuVG9nZ2xlRWRpdG9yVmlzaWJpbGl0eVVwZGF0ZXJBY3Rpb25cbik6IFZpc1N0YXRlIHtcbiAgcmV0dXJuIHtcbiAgICAuLi5zdGF0ZSxcbiAgICBlZGl0b3I6IHtcbiAgICAgIC4uLnN0YXRlLmVkaXRvcixcbiAgICAgIHZpc2libGU6ICFzdGF0ZS5lZGl0b3IudmlzaWJsZVxuICAgIH1cbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNldEZpbHRlckFuaW1hdGlvblRpbWVDb25maWdVcGRhdGVyKFxuICBzdGF0ZTogVmlzU3RhdGUsXG4gIHtpZHgsIGNvbmZpZ306IFZpc1N0YXRlQWN0aW9ucy5TZXRGaWx0ZXJBbmltYXRpb25UaW1lQ29uZmlnQWN0aW9uXG4pOiBWaXNTdGF0ZSB7XG4gIGNvbnN0IG9sZEZpbHRlciA9IHN0YXRlLmZpbHRlcnNbaWR4XTtcbiAgaWYgKCFvbGRGaWx0ZXIpIHtcbiAgICBDb25zb2xlLmVycm9yKGBmaWx0ZXJzLiR7aWR4fSBpcyB1bmRlZmluZWRgKTtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cbiAgaWYgKG9sZEZpbHRlci50eXBlICE9PSBGSUxURVJfVFlQRVMudGltZVJhbmdlKSB7XG4gICAgQ29uc29sZS5lcnJvcihcbiAgICAgIGBzZXRGaWx0ZXJBbmltYXRpb25UaW1lQ29uZmlnIGNhbiBvbmx5IGJlIGNhbGxlZCB0byB1cGRhdGUgYSB0aW1lIGZpbHRlci4gY2hlY2sgZmlsdGVyLnR5cGUgPT09ICd0aW1lUmFuZ2UnYFxuICAgICk7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG5cbiAgY29uc3QgdXBkYXRlcyA9IGNoZWNrVGltZUNvbmZpZ0FyZ3MoY29uZmlnKTtcblxuICByZXR1cm4gcGlja18oJ2ZpbHRlcnMnKShzd2FwXyhtZXJnZV8odXBkYXRlcykob2xkRmlsdGVyKSkpKHN0YXRlKTtcbn1cblxuZnVuY3Rpb24gY2hlY2tUaW1lQ29uZmlnQXJncyhjb25maWcpIHtcbiAgY29uc3QgYWxsb3dlZCA9IFsndGltZUZvcm1hdCcsICd0aW1lem9uZSddO1xuICByZXR1cm4gT2JqZWN0LmtleXMoY29uZmlnKS5yZWR1Y2UoKGFjY3UsIHByb3ApID0+IHtcbiAgICBpZiAoIWFsbG93ZWQuaW5jbHVkZXMocHJvcCkpIHtcbiAgICAgIENvbnNvbGUuZXJyb3IoXG4gICAgICAgIGBzZXRMYXllckFuaW1hdGlvblRpbWVDb25maWcgdGFrZXMgdGltZUZvcm1hdCBhbmQvb3IgdGltZXpvbmUgYXMgb3B0aW9ucywgZm91bmQgJHtwcm9wfWBcbiAgICAgICk7XG4gICAgICByZXR1cm4gYWNjdTtcbiAgICB9XG5cbiAgICAvLyBoZXJlIHdlIGFyZSBOT1QgY2hlY2tpbmcgaWYgdGltZXpvbmUgb3IgdGltZUZvcm1hdCBpbnB1dCBpcyB2YWxpZFxuICAgIGFjY3VbcHJvcF0gPSBjb25maWdbcHJvcF07XG4gICAgcmV0dXJuIGFjY3U7XG4gIH0sIHt9KTtcbn1cbi8qKlxuICogVXBkYXRlIGVkaXRvclxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0TGF5ZXJBbmltYXRpb25UaW1lQ29uZmlnVXBkYXRlcihcbiAgc3RhdGU6IFZpc1N0YXRlLFxuICB7Y29uZmlnfTogVmlzU3RhdGVBY3Rpb25zLlNldExheWVyQW5pbWF0aW9uVGltZUNvbmZpZ0FjdGlvblxuKTogVmlzU3RhdGUge1xuICBpZiAoIWNvbmZpZykge1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuICBjb25zdCB1cGRhdGVzID0gY2hlY2tUaW1lQ29uZmlnQXJncyhjb25maWcpO1xuICByZXR1cm4gcGlja18oJ2FuaW1hdGlvbkNvbmZpZycpKG1lcmdlXyh1cGRhdGVzKSkoc3RhdGUpO1xufVxuIl19