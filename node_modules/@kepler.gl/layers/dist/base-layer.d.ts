/// <reference types="deck.gl" />
import React from 'react';
import { DataFilterExtension } from '@deck.gl/extensions';
import { ALL_FIELD_TYPES, SCALE_TYPES, ColorRange } from '@kepler.gl/constants';
import { DataContainerInterface } from '@kepler.gl/utils';
import { RGBColor, RGBAColor, ValueOf, NestedPartial, LayerTextLabel, ColorUI, LayerVisConfig, LayerVisConfigSettings, Field, MapState, Filter } from '@kepler.gl/types';
import { KeplerTable, Datasets, GpuFilter } from '@kepler.gl/table';
export declare type LayerColumn = {
    value: string | null;
    fieldIdx: number;
    optional?: boolean;
};
export declare type LayerColumns = {
    [key: string]: LayerColumn;
};
export declare type VisualChannelDomain = number[] | string[];
export declare type VisualChannelField = Field | null;
export declare type VisualChannelScale = keyof typeof SCALE_TYPES;
export declare type LayerBaseConfig = {
    dataId: string | null;
    label: string;
    color: RGBColor;
    columns: LayerColumns;
    isVisible: boolean;
    isConfigActive: boolean;
    highlightColor: RGBColor | RGBAColor;
    hidden: boolean;
    visConfig: LayerVisConfig;
    textLabel: LayerTextLabel[];
    colorUI: {
        color: ColorUI;
        colorRange: ColorUI;
    };
    animation: {
        enabled: boolean;
        domain?: null;
    };
};
export declare type LayerColorConfig = {
    colorField: VisualChannelField;
    colorDomain: VisualChannelDomain;
    colorScale: VisualChannelScale;
};
export declare type LayerSizeConfig = {
    sizeDomain: VisualChannelDomain;
    sizeScale: VisualChannelScale;
    sizeField: VisualChannelField;
};
export declare type LayerHeightConfig = {
    heightField: VisualChannelField;
    heightDomain: VisualChannelDomain;
    heightScale: VisualChannelScale;
};
export declare type LayerStrokeColorConfig = {
    strokeColorField: VisualChannelField;
    strokeColorDomain: VisualChannelDomain;
    strokeColorScale: VisualChannelScale;
};
export declare type LayerCoverageConfig = {
    coverageField: VisualChannelField;
    coverageDomain: VisualChannelDomain;
    coverageScale: VisualChannelScale;
};
export declare type LayerRadiusConfig = {
    radiusField: VisualChannelField;
    radiusDomain: VisualChannelDomain;
    radiusScale: VisualChannelScale;
};
export declare type LayerWeightConfig = {
    weightField: VisualChannelField;
};
export declare type VisualChannels = {
    [key: string]: VisualChannel;
};
export declare type VisualChannelAggregation = 'colorAggregation' | 'sizeAggregation';
export declare type VisualChannel = {
    property: string;
    field: string;
    scale: string;
    domain: string;
    range: string;
    key: string;
    channelScaleType: string;
    nullValue?: any;
    defaultMeasure?: any;
    accessor?: string;
    condition?: (config: any) => boolean;
    getAttributeValue?: (config: any) => (d: any) => any;
    defaultValue?: any;
    fixed?: any;
    supportedFieldTypes?: Array<keyof typeof ALL_FIELD_TYPES>;
    aggregation?: VisualChannelAggregation;
};
export declare type VisualChannelDescription = {
    label: string;
    measure: string | undefined;
};
export declare type ColumnPairs = {
    [key: string]: {
        pair: string;
        fieldPairKey: string;
    };
};
declare type ColumnValidator = (column: LayerColumn, columns: LayerColumns, allFields: Field[]) => boolean;
export declare type UpdateTriggers = {
    [key: string]: UpdateTrigger;
};
export declare type UpdateTrigger = {
    [key: string]: {};
};
export declare type LayerBounds = [number, number, number, number];
export declare type FindDefaultLayerPropsReturnValue = {
    props: any[];
    foundLayers?: any[];
};
/**
 * Approx. number of points to sample in a large data set
 */
export declare const LAYER_ID_LENGTH = 6;
declare const defaultDataAccessor: (dc: any) => (d: any) => any;
export declare const OVERLAY_TYPE_CONST: {
    deckgl: "deckgl";
    mapboxgl: "mapboxgl";
};
export declare const layerColors: RGBColor[];
export declare const colorMaker: Generator<RGBColor, any, unknown>;
declare class Layer {
    id: string;
    meta: {};
    visConfigSettings: {
        [key: string]: ValueOf<LayerVisConfigSettings>;
    };
    config: LayerBaseConfig;
    _oldDataUpdateTriggers: any;
    constructor(props?: {
        id?: string;
    } & Partial<LayerBaseConfig>);
    get layerIcon(): React.ElementType;
    get overlayType(): keyof typeof OVERLAY_TYPE_CONST;
    get type(): string | null;
    get name(): string | null;
    get isAggregated(): boolean;
    get requiredLayerColumns(): string[];
    get optionalColumns(): string[];
    get noneLayerDataAffectingProps(): string[];
    get visualChannels(): VisualChannels;
    get columnValidators(): {
        [key: string]: ColumnValidator;
    };
    get columnPairs(): ColumnPairs | null;
    get defaultPointColumnPairs(): ColumnPairs;
    get defaultLinkColumnPairs(): ColumnPairs;
    /**
     * Return a React component for to render layer instructions in a modal
     * @returns {object} - an object
     * @example
     *  return {
     *    id: 'iconInfo',
     *    template: IconInfoModal,
     *    modalProps: {
     *      title: 'How to draw icons'
     *   };
     * }
     */
    get layerInfoModal(): any;
    get supportedDatasetTypes(): string[] | null;
    static findDefaultLayerProps(dataset: KeplerTable, foundLayers?: any[]): FindDefaultLayerPropsReturnValue;
    /**
     * Given a array of preset required column names
     * found field that has the same name to set as layer column
     *
     * @param {object} defaultFields
     * @param {object[]} allFields
     * @returns {object[] | null} all possible required layer column pairs
     */
    static findDefaultColumnField(defaultFields: any, allFields: any): any[] | null;
    static getAllPossibleColumnParis(requiredColumns: any): any[];
    static hexToRgb(c: any): RGBColor;
    getDefaultLayerConfig(props?: Partial<LayerBaseConfig>): LayerBaseConfig & Partial<LayerColorConfig & LayerSizeConfig>;
    /**
     * Get the description of a visualChannel config
     * @param key
     * @returns
     */
    getVisualChannelDescription(key: string): VisualChannelDescription;
    /**
     * Assign a field to layer column, return column config
     * @param key - Column Key
     * @param field - Selected field
     * @returns {{}} - Column config
     */
    assignColumn(key: string, field: Field): LayerColumns;
    /**
     * Assign a field pair to column config, return column config
     * @param key - Column Key
     * @param pair - field Pair
     * @returns {object} - Column config
     */
    assignColumnPairs(key: any, pair: any): {
        [x: string]: any;
    };
    /**
     * Calculate a radius zoom multiplier to render points, so they are visible in all zoom level
     * @param {object} mapState
     * @param {number} mapState.zoom - actual zoom
     * @param {number | void} mapState.zoomOffset - zoomOffset when render in the plot container for export image
     * @returns {number}
     */
    getZoomFactor({ zoom, zoomOffset }: {
        zoom: any;
        zoomOffset?: number | undefined;
    }): number;
    /**
     * Calculate a elevation zoom multiplier to render points, so they are visible in all zoom level
     * @param {object} mapState
     * @param {number} mapState.zoom - actual zoom
     * @param {number | void} mapState.zoomOffset - zoomOffset when render in the plot container for export image
     * @returns {number}
     */
    getElevationZoomFactor({ zoom, zoomOffset }: {
        zoom: number;
        zoomOffset?: number;
    }): number;
    formatLayerData(datasets: Datasets, oldLayerData?: any): {};
    renderLayer(...args: any[]): any[];
    getHoverData(object: any, dataContainer: DataContainerInterface, fields: Field[]): import("@kepler.gl/utils").DataRow | null;
    /**
     * When change layer type, try to copy over layer configs as much as possible
     * @param configToCopy - config to copy over
     * @param visConfigSettings - visConfig settings of config to copy
     */
    assignConfigToLayer(configToCopy: any, visConfigSettings: any): void;
    copyLayerConfig(currentConfig: any, configToCopy: any, { shallowCopy, notToCopy }?: {
        shallowCopy?: string[];
        notToCopy?: string[];
    }): {};
    registerVisConfig(layerVisConfigs: {
        [key: string]: keyof LayerVisConfigSettings | ValueOf<LayerVisConfigSettings>;
    }): void;
    getLayerColumns(): {};
    updateLayerConfig<LayerConfig extends LayerBaseConfig = LayerBaseConfig>(newConfig: Partial<LayerConfig>): Layer;
    updateLayerVisConfig(newVisConfig: any): this;
    updateLayerColorUI(prop: string, newConfig: NestedPartial<ColorUI>): Layer;
    updateCustomPalette(newConfig: any, previous: any, prop: any): void;
    /**
     * if open dropdown and prop is color range
     * Automatically set colorRangeConfig's step and reversed
     * @param {*} newConfig
     * @param {*} prop
     */
    updateColorUIByColorRange(newConfig: any, prop: any): void;
    updateColorRangeByColorUI(newConfig: any, previous: any, prop: any): void;
    /**
     * Check whether layer has all columns
     * @returns yes or no
     */
    hasAllColumns(): boolean;
    /**
     * Check whether layer has data
     *
     * @param {Array | Object} layerData
     * @returns {boolean} yes or no
     */
    hasLayerData(layerData: any): boolean;
    isValidToSave(): boolean;
    shouldRenderLayer(data: any): boolean;
    getColorScale(colorScale: string, colorDomain: VisualChannelDomain, colorRange: ColorRange): import("d3-scale").ScaleOrdinal<string, unknown, any> | (() => any);
    /**
     * Mapping from visual channels to deck.gl accesors
     * @param {Object} param Parameters
     * @param {Function} param.dataAccessor Access kepler.gl layer data from deck.gl layer
     * @param {import('utils/table-utils/data-container-interface').DataContainerInterface} param.dataContainer DataContainer to use use with dataAccessor
     * @return {Object} attributeAccessors - deck.gl layer attribute accessors
     */
    getAttributeAccessors({ dataAccessor, dataContainer }: {
        dataAccessor?: typeof defaultDataAccessor;
        dataContainer: DataContainerInterface;
    }): {
        [key: string]: any;
    };
    getVisChannelScale(scale: string, domain: VisualChannelDomain, range: any, fixed?: boolean): () => any | null;
    /**
     * Get longitude and latitude bounds of the data.
     * @param {import('utils/table-utils/data-container-interface').DataContainerInterface} dataContainer DataContainer to calculate bounds for.
     * @param {(d: {index: number}, dc: import('utils/table-utils/data-container-interface').DataContainerInterface) => number[]} getPosition Access kepler.gl layer data from deck.gl layer
     * @return {number[]|null} bounds of the data.
     */
    getPointsBounds(dataContainer: any, getPosition: any): number[] | null;
    getChangedTriggers(dataUpdateTriggers: any): false | {
        [key: string]: true;
    };
    getEncodedChannelValue(scale: (value: any) => any, data: any[], field: VisualChannelField, nullValue?: RGBAColor, getValue?: (field: any, d: any) => any): any;
    updateMeta(meta: any): void;
    getDataUpdateTriggers({ filteredIndex, id, dataContainer }: KeplerTable): any;
    updateData(datasets: any, oldLayerData: any): {
        data?: undefined;
        triggerChanged?: undefined;
    } | {
        data: never[];
        triggerChanged: boolean | {
            [key: string]: true;
        };
    };
    /**
     * helper function to update one layer domain when state.data changed
     * if state.data change is due ot update filter, newFiler will be passed
     * called by updateAllLayerDomainData
     * @param datasets
     * @param newFilter
     * @returns layer
     */
    updateLayerDomain(datasets: Datasets, newFilter?: Filter): Layer;
    getDataset(datasets: any): any;
    /**
     * Validate visual channel field and scales based on supported field & scale type
     * @param channel
     */
    validateVisualChannel(channel: string): void;
    /**
     * Validate field type based on channelScaleType
     */
    validateFieldType(channel: string): void;
    /**
     * Validate scale type based on aggregation
     */
    validateScale(channel: any): void;
    /**
     * Get scale options based on current field
     * @param {string} channel
     * @returns {string[]}
     */
    getScaleOptions(channel: any): any;
    updateLayerVisualChannel(dataset: KeplerTable, channel: string): void;
    getVisualChannelUpdateTriggers(): UpdateTriggers;
    calculateLayerDomain(dataset: any, visualChannel: any): any;
    hasHoveredObject(objectInfo: any): any;
    isLayerHovered(objectInfo: any): boolean;
    getRadiusScaleByZoom(mapState: MapState, fixedRadius?: boolean): number;
    shouldCalculateLayerData(props: string[]): boolean;
    getBrushingExtensionProps(interactionConfig: any, brushingTarget?: any): {
        autoHighlight: boolean;
        brushingRadius: number;
        brushingTarget: any;
        brushingEnabled: any;
    };
    getDefaultDeckLayerProps({ idx, gpuFilter, mapState, visible }: {
        idx: number;
        gpuFilter: GpuFilter;
        mapState: MapState;
        visible: boolean;
    }): {
        id: string;
        idx: number;
        coordinateSystem: number;
        pickable: boolean;
        wrapLongitude: boolean;
        parameters: {
            depthTest: boolean;
        };
        hidden: boolean;
        opacity: any;
        highlightColor: RGBColor | RGBAColor;
        extensions: DataFilterExtension[];
        filterRange: any;
        visible: boolean;
    };
    getDefaultHoverLayerProps(): {
        id: string;
        pickable: boolean;
        wrapLongitude: boolean;
        coordinateSystem: number;
    };
    renderTextLabelLayer({ getPosition, getPixelOffset, updateTriggers, sharedProps }: {
        getPosition: any;
        getPixelOffset: any;
        updateTriggers: any;
        sharedProps: any;
    }, renderOpts: any): any;
    calculateDataAttribute(keplerTable: KeplerTable, getPosition: any): any;
    updateLayerMeta(dataContainer: DataContainerInterface, getPosition: any): void;
    getPositionAccessor(dataContainer?: DataContainerInterface): (...args: any[]) => any;
}
export default Layer;
