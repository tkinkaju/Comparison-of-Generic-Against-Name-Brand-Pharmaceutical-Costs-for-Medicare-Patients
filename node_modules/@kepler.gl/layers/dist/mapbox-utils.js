// Copyright (c) 2022 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.generateMapboxLayers = generateMapboxLayers;
exports.updateMapboxLayers = updateMapboxLayers;
exports.geoJsonFromData = geoJsonFromData;
exports.gpuFilterToMapboxFilter = gpuFilterToMapboxFilter;
exports.prefixGpuField = void 0;

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _baseLayer = require("./base-layer");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/**
 * This function will convert layers to mapbox layers
 * @param layers the layers to be converted
 * @param layerData extra layer information
 * @param layerOrder the order by which we should convert layers
 * @param layersToRender {[id]: true | false} object whether each layer should be rendered
 * @returns
 */
function generateMapboxLayers() {
  var layers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var layerData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  var layerOrder = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
  var layersToRender = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

  if (layerData.length > 0) {
    return layerOrder.slice().reverse().filter(function (idx) {
      return layers[idx].overlayType === _baseLayer.OVERLAY_TYPE_CONST.mapboxgl && layersToRender[layers[idx].id];
    }).reduce(function (accu, index) {
      var layer = layers[index];
      return _objectSpread(_objectSpread({}, accu), {}, (0, _defineProperty2["default"])({}, layer.id, {
        id: layer.id,
        data: layerData[index].data,
        isVisible: layer.config.isVisible,
        config: layerData[index].config,
        hidden: layer.config.hidden,
        sourceId: layerData[index].config.source
      }));
    }, {});
  }

  return {};
}

/**
 * Update mapbox layers on the given map
 * @param map
 * @param newLayers Map of new mapbox layers to be displayed
 * @param oldLayers Map of the old layers to be compare with the current ones to detect deleted layers
 *                  {layerId: sourceId}
 */
function updateMapboxLayers(map) {
  var newLayers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var oldLayers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

  // delete no longer existed old layers
  if (oldLayers) {
    checkAndRemoveOldLayers(map, oldLayers, newLayers);
  } // insert or update new layer


  Object.values(newLayers).forEach(function (overlay) {
    var layerId = overlay.id,
        config = overlay.config,
        data = overlay.data,
        sourceId = overlay.sourceId,
        isVisible = overlay.isVisible;

    if (!data && !config) {
      return;
    }

    var _ref = oldLayers && oldLayers[layerId] || {},
        oldData = _ref.data,
        oldConfig = _ref.config;

    if (data && data !== oldData) {
      updateSourceData(map, sourceId, data);
    } // compare with previous configs


    if (oldConfig !== config) {
      updateLayerConfig(map, layerId, config, isVisible);
    }
  });
}

function checkAndRemoveOldLayers(map, oldLayers, newLayers) {
  Object.keys(oldLayers).forEach(function (layerId) {
    if (!newLayers[layerId]) {
      map.removeLayer(layerId);
    }
  });
}

function updateLayerConfig(map, layerId, config, isVisible) {
  var mapboxLayer = map.getLayer(layerId);

  if (mapboxLayer) {
    // check if layer already is set
    // remove it if exists
    map.removeLayer(layerId);
  }

  map.addLayer(config);
  map.setLayoutProperty(layerId, 'visibility', isVisible ? 'visible' : 'none');
}

function updateSourceData(map, sourceId, data) {
  var source = map.getSource(sourceId);

  if (!source) {
    map.addSource(sourceId, {
      type: 'geojson',
      data: data
    });
  } else {
    source.setData(data);
  }
}
/**
 *
 * @param filteredIndex
 * @param getGeometry {({index: number}) => any}
 * @param getProperties {({index: number}) => any}
 * @returns FeatureCollection
 */


function geoJsonFromData() {
  var filteredIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var getGeometry = arguments.length > 1 ? arguments[1] : undefined;
  var getProperties = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function (d) {};
  var geojson = {
    type: 'FeatureCollection',
    features: []
  };

  for (var i = 0; i < filteredIndex.length; i++) {
    var index = filteredIndex[i];
    var rowIndex = {
      index: index
    };
    var geometry = getGeometry(rowIndex);

    if (geometry) {
      geojson.features.push({
        type: 'Feature',
        properties: _objectSpread({
          index: index
        }, getProperties(rowIndex)),
        geometry: geometry
      });
    }
  }

  return geojson;
}

var prefixGpuField = function prefixGpuField(name) {
  return "gpu:".concat(name);
};

exports.prefixGpuField = prefixGpuField;

function gpuFilterToMapboxFilter(gpuFilter) {
  var filterRange = gpuFilter.filterRange,
      filterValueUpdateTriggers = gpuFilter.filterValueUpdateTriggers;
  var hasFilter = Object.values(filterValueUpdateTriggers).filter(function (d) {
    return d;
  });

  if (!hasFilter.length) {
    return null;
  }

  var condition = ['all']; // [">=", key, value]
  // ["<=", key, value]

  var expressions = Object.values(filterValueUpdateTriggers).reduce(function (accu, name, i) {
    return name ? [].concat((0, _toConsumableArray2["default"])(accu), [['>=', prefixGpuField(name), filterRange[i][0]], ['<=', prefixGpuField(name), filterRange[i][1]]]) : accu;
  }, condition);
  return expressions;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9tYXBib3gtdXRpbHMudHMiXSwibmFtZXMiOlsiZ2VuZXJhdGVNYXBib3hMYXllcnMiLCJsYXllcnMiLCJsYXllckRhdGEiLCJsYXllck9yZGVyIiwibGF5ZXJzVG9SZW5kZXIiLCJsZW5ndGgiLCJzbGljZSIsInJldmVyc2UiLCJmaWx0ZXIiLCJpZHgiLCJvdmVybGF5VHlwZSIsIk9WRVJMQVlfVFlQRV9DT05TVCIsIm1hcGJveGdsIiwiaWQiLCJyZWR1Y2UiLCJhY2N1IiwiaW5kZXgiLCJsYXllciIsImRhdGEiLCJpc1Zpc2libGUiLCJjb25maWciLCJoaWRkZW4iLCJzb3VyY2VJZCIsInNvdXJjZSIsInVwZGF0ZU1hcGJveExheWVycyIsIm1hcCIsIm5ld0xheWVycyIsIm9sZExheWVycyIsImNoZWNrQW5kUmVtb3ZlT2xkTGF5ZXJzIiwiT2JqZWN0IiwidmFsdWVzIiwiZm9yRWFjaCIsIm92ZXJsYXkiLCJsYXllcklkIiwib2xkRGF0YSIsIm9sZENvbmZpZyIsInVwZGF0ZVNvdXJjZURhdGEiLCJ1cGRhdGVMYXllckNvbmZpZyIsImtleXMiLCJyZW1vdmVMYXllciIsIm1hcGJveExheWVyIiwiZ2V0TGF5ZXIiLCJhZGRMYXllciIsInNldExheW91dFByb3BlcnR5IiwiZ2V0U291cmNlIiwiYWRkU291cmNlIiwidHlwZSIsInNldERhdGEiLCJnZW9Kc29uRnJvbURhdGEiLCJmaWx0ZXJlZEluZGV4IiwiZ2V0R2VvbWV0cnkiLCJnZXRQcm9wZXJ0aWVzIiwiZCIsImdlb2pzb24iLCJmZWF0dXJlcyIsImkiLCJyb3dJbmRleCIsImdlb21ldHJ5IiwicHVzaCIsInByb3BlcnRpZXMiLCJwcmVmaXhHcHVGaWVsZCIsIm5hbWUiLCJncHVGaWx0ZXJUb01hcGJveEZpbHRlciIsImdwdUZpbHRlciIsImZpbHRlclJhbmdlIiwiZmlsdGVyVmFsdWVVcGRhdGVUcmlnZ2VycyIsImhhc0ZpbHRlciIsImNvbmRpdGlvbiIsImV4cHJlc3Npb25zIl0sIm1h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Q0FBQUMsSUFBSTtBQUFBLHVCQUFXQSxJQUFYO0FBQUEsQ0FBM0I7Ozs7QUFFQSxTQUFTQyx1QkFBVCxDQUFpQ0MsU0FBakMsRUFBNEM7QUFBQSxNQUMxQ0MsV0FEMEMsR0FDQUQsU0FEQSxDQUMxQ0MsV0FEMEM7QUFBQSxNQUM3QkMseUJBRDZCLEdBQ0FGLFNBREEsQ0FDN0JFLHlCQUQ2QjtBQUdqRCxNQUFNQyxTQUFTLEdBQUdyQyxNQUFNLENBQUNDLE1BQVAsQ0FBY21DLHlCQUFkLEVBQXlDekQsTUFBekMsQ0FBZ0QsVUFBQTRDLENBQUM7QUFBQSxXQUFJQSxDQUFKO0FBQUEsR0FBakQsQ0FBbEI7O0FBRUEsTUFBSSxDQUFDYyxTQUFTLENBQUM3RCxNQUFmLEVBQXVCO0FBQ3JCLFdBQU8sSUFBUDtBQUNEOztBQUVELE1BQU04RCxTQUFTLEdBQUcsQ0FBQyxLQUFELENBQWxCLENBVGlELENBV2pEO0FBQ0E7O0FBQ0EsTUFBTUMsV0FBVyxHQUFHdkMsTUFBTSxDQUFDQyxNQUFQLENBQWNtQyx5QkFBZCxFQUF5Q25ELE1BQXpDLENBQ2xCLFVBQUNDLElBQUQsRUFBYzhDLElBQWQsRUFBb0JOLENBQXBCO0FBQUEsV0FDRU0sSUFBSSxpREFFSzlDLElBRkwsSUFHRSxDQUFDLElBQUQsRUFBTzZDLGNBQWMsQ0FBQ0MsSUFBRCxDQUFyQixFQUE2QkcsV0FBVyxDQUFDVCxDQUFELENBQVgsQ0FBZSxDQUFmLENBQTdCLENBSEYsRUFJRSxDQUFDLElBQUQsRUFBT0ssY0FBYyxDQUFDQyxJQUFELENBQXJCLEVBQTZCRyxXQUFXLENBQUNULENBQUQsQ0FBWCxDQUFlLENBQWYsQ0FBN0IsQ0FKRixLQU1BeEMsSUFQTjtBQUFBLEdBRGtCLEVBU2xCb0QsU0FUa0IsQ0FBcEI7QUFZQSxTQUFPQyxXQUFQO0FBQ0QiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMjIgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5pbXBvcnQgTGF5ZXIsIHtPVkVSTEFZX1RZUEVfQ09OU1R9IGZyb20gJy4vYmFzZS1sYXllcic7XG5pbXBvcnQge0ZlYXR1cmV9IGZyb20gJ2dlb2pzb24nO1xuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gd2lsbCBjb252ZXJ0IGxheWVycyB0byBtYXBib3ggbGF5ZXJzXG4gKiBAcGFyYW0gbGF5ZXJzIHRoZSBsYXllcnMgdG8gYmUgY29udmVydGVkXG4gKiBAcGFyYW0gbGF5ZXJEYXRhIGV4dHJhIGxheWVyIGluZm9ybWF0aW9uXG4gKiBAcGFyYW0gbGF5ZXJPcmRlciB0aGUgb3JkZXIgYnkgd2hpY2ggd2Ugc2hvdWxkIGNvbnZlcnQgbGF5ZXJzXG4gKiBAcGFyYW0gbGF5ZXJzVG9SZW5kZXIge1tpZF06IHRydWUgfCBmYWxzZX0gb2JqZWN0IHdoZXRoZXIgZWFjaCBsYXllciBzaG91bGQgYmUgcmVuZGVyZWRcbiAqIEByZXR1cm5zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZU1hcGJveExheWVycyhcbiAgbGF5ZXJzOiBMYXllcltdID0gW10sXG4gIGxheWVyRGF0YTogYW55W10gPSBbXSxcbiAgbGF5ZXJPcmRlcjogbnVtYmVyW10gPSBbXSxcbiAgbGF5ZXJzVG9SZW5kZXI6IHtba2V5OiBzdHJpbmddOiBib29sZWFufSA9IHt9XG4pOiB7W2tleTogc3RyaW5nXTogTGF5ZXJ9IHtcbiAgaWYgKGxheWVyRGF0YS5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIGxheWVyT3JkZXJcbiAgICAgIC5zbGljZSgpXG4gICAgICAucmV2ZXJzZSgpXG4gICAgICAuZmlsdGVyKFxuICAgICAgICBpZHggPT5cbiAgICAgICAgICBsYXllcnNbaWR4XS5vdmVybGF5VHlwZSA9PT0gT1ZFUkxBWV9UWVBFX0NPTlNULm1hcGJveGdsICYmIGxheWVyc1RvUmVuZGVyW2xheWVyc1tpZHhdLmlkXVxuICAgICAgKVxuICAgICAgLnJlZHVjZSgoYWNjdSwgaW5kZXgpID0+IHtcbiAgICAgICAgY29uc3QgbGF5ZXIgPSBsYXllcnNbaW5kZXhdO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLmFjY3UsXG4gICAgICAgICAgW2xheWVyLmlkXToge1xuICAgICAgICAgICAgaWQ6IGxheWVyLmlkLFxuICAgICAgICAgICAgZGF0YTogbGF5ZXJEYXRhW2luZGV4XS5kYXRhLFxuICAgICAgICAgICAgaXNWaXNpYmxlOiBsYXllci5jb25maWcuaXNWaXNpYmxlLFxuICAgICAgICAgICAgY29uZmlnOiBsYXllckRhdGFbaW5kZXhdLmNvbmZpZyxcbiAgICAgICAgICAgIGhpZGRlbjogbGF5ZXIuY29uZmlnLmhpZGRlbixcbiAgICAgICAgICAgIHNvdXJjZUlkOiBsYXllckRhdGFbaW5kZXhdLmNvbmZpZy5zb3VyY2VcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9LCB7fSk7XG4gIH1cblxuICByZXR1cm4ge307XG59XG5cbnR5cGUgbmV3TGF5ZXJzVHlwZSA9IHtcbiAgW2tleTogc3RyaW5nXTogTGF5ZXIgJiBQYXJ0aWFsPHtkYXRhOiBhbnk7IHNvdXJjZUlkOiBhbnk7IGlzVmlzaWJsZTogYm9vbGVhbn0+O1xufTtcbnR5cGUgb2xkTGF5ZXJzVHlwZSA9IHtba2V5OiBzdHJpbmddOiBMYXllciAmIHtkYXRhPzogYW55fX07XG4vKipcbiAqIFVwZGF0ZSBtYXBib3ggbGF5ZXJzIG9uIHRoZSBnaXZlbiBtYXBcbiAqIEBwYXJhbSBtYXBcbiAqIEBwYXJhbSBuZXdMYXllcnMgTWFwIG9mIG5ldyBtYXBib3ggbGF5ZXJzIHRvIGJlIGRpc3BsYXllZFxuICogQHBhcmFtIG9sZExheWVycyBNYXAgb2YgdGhlIG9sZCBsYXllcnMgdG8gYmUgY29tcGFyZSB3aXRoIHRoZSBjdXJyZW50IG9uZXMgdG8gZGV0ZWN0IGRlbGV0ZWQgbGF5ZXJzXG4gKiAgICAgICAgICAgICAgICAgIHtsYXllcklkOiBzb3VyY2VJZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZU1hcGJveExheWVycyhcbiAgbWFwLFxuICBuZXdMYXllcnM6IG5ld0xheWVyc1R5cGUgPSB7fSxcbiAgb2xkTGF5ZXJzOiBvbGRMYXllcnNUeXBlIHwgbnVsbCA9IG51bGxcbikge1xuICAvLyBkZWxldGUgbm8gbG9uZ2VyIGV4aXN0ZWQgb2xkIGxheWVyc1xuICBpZiAob2xkTGF5ZXJzKSB7XG4gICAgY2hlY2tBbmRSZW1vdmVPbGRMYXllcnMobWFwLCBvbGRMYXllcnMsIG5ld0xheWVycyk7XG4gIH1cblxuICAvLyBpbnNlcnQgb3IgdXBkYXRlIG5ldyBsYXllclxuICBPYmplY3QudmFsdWVzKG5ld0xheWVycykuZm9yRWFjaChvdmVybGF5ID0+IHtcbiAgICBjb25zdCB7aWQ6IGxheWVySWQsIGNvbmZpZywgZGF0YSwgc291cmNlSWQsIGlzVmlzaWJsZX0gPSBvdmVybGF5O1xuICAgIGlmICghZGF0YSAmJiAhY29uZmlnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qge2RhdGE6IG9sZERhdGEsIGNvbmZpZzogb2xkQ29uZmlnfSA9IChvbGRMYXllcnMgJiYgb2xkTGF5ZXJzW2xheWVySWRdKSB8fCB7fTtcblxuICAgIGlmIChkYXRhICYmIGRhdGEgIT09IG9sZERhdGEpIHtcbiAgICAgIHVwZGF0ZVNvdXJjZURhdGEobWFwLCBzb3VyY2VJZCwgZGF0YSk7XG4gICAgfVxuXG4gICAgLy8gY29tcGFyZSB3aXRoIHByZXZpb3VzIGNvbmZpZ3NcbiAgICBpZiAob2xkQ29uZmlnICE9PSBjb25maWcpIHtcbiAgICAgIHVwZGF0ZUxheWVyQ29uZmlnKG1hcCwgbGF5ZXJJZCwgY29uZmlnLCBpc1Zpc2libGUpO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGNoZWNrQW5kUmVtb3ZlT2xkTGF5ZXJzKG1hcCwgb2xkTGF5ZXJzOiBvbGRMYXllcnNUeXBlLCBuZXdMYXllcnM6IG5ld0xheWVyc1R5cGUpIHtcbiAgT2JqZWN0LmtleXMob2xkTGF5ZXJzKS5mb3JFYWNoKGxheWVySWQgPT4ge1xuICAgIGlmICghbmV3TGF5ZXJzW2xheWVySWRdKSB7XG4gICAgICBtYXAucmVtb3ZlTGF5ZXIobGF5ZXJJZCk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlTGF5ZXJDb25maWcobWFwLCBsYXllcklkLCBjb25maWcsIGlzVmlzaWJsZSkge1xuICBjb25zdCBtYXBib3hMYXllciA9IG1hcC5nZXRMYXllcihsYXllcklkKTtcblxuICBpZiAobWFwYm94TGF5ZXIpIHtcbiAgICAvLyBjaGVjayBpZiBsYXllciBhbHJlYWR5IGlzIHNldFxuICAgIC8vIHJlbW92ZSBpdCBpZiBleGlzdHNcbiAgICBtYXAucmVtb3ZlTGF5ZXIobGF5ZXJJZCk7XG4gIH1cblxuICBtYXAuYWRkTGF5ZXIoY29uZmlnKTtcbiAgbWFwLnNldExheW91dFByb3BlcnR5KGxheWVySWQsICd2aXNpYmlsaXR5JywgaXNWaXNpYmxlID8gJ3Zpc2libGUnIDogJ25vbmUnKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlU291cmNlRGF0YShtYXAsIHNvdXJjZUlkLCBkYXRhKSB7XG4gIGNvbnN0IHNvdXJjZSA9IG1hcC5nZXRTb3VyY2Uoc291cmNlSWQpO1xuXG4gIGlmICghc291cmNlKSB7XG4gICAgbWFwLmFkZFNvdXJjZShzb3VyY2VJZCwge1xuICAgICAgdHlwZTogJ2dlb2pzb24nLFxuICAgICAgZGF0YVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHNvdXJjZS5zZXREYXRhKGRhdGEpO1xuICB9XG59XG5cbi8qKlxuICpcbiAqIEBwYXJhbSBmaWx0ZXJlZEluZGV4XG4gKiBAcGFyYW0gZ2V0R2VvbWV0cnkgeyh7aW5kZXg6IG51bWJlcn0pID0+IGFueX1cbiAqIEBwYXJhbSBnZXRQcm9wZXJ0aWVzIHsoe2luZGV4OiBudW1iZXJ9KSA9PiBhbnl9XG4gKiBAcmV0dXJucyBGZWF0dXJlQ29sbGVjdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2VvSnNvbkZyb21EYXRhKFxuICBmaWx0ZXJlZEluZGV4OiBudW1iZXJbXSA9IFtdLFxuICBnZXRHZW9tZXRyeTogeyh7aW5kZXg6IG51bWJlcn0pOiBhbnl9LFxuICBnZXRQcm9wZXJ0aWVzOiB7KHtpbmRleDogbnVtYmVyfSk6IGFueX0gPSBkID0+IHt9XG4pIHtcbiAgY29uc3QgZ2VvanNvbjoge3R5cGU6IHN0cmluZzsgZmVhdHVyZXM6IEZlYXR1cmVbXX0gPSB7XG4gICAgdHlwZTogJ0ZlYXR1cmVDb2xsZWN0aW9uJyxcbiAgICBmZWF0dXJlczogW11cbiAgfTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGZpbHRlcmVkSW5kZXgubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBpbmRleCA9IGZpbHRlcmVkSW5kZXhbaV07XG4gICAgY29uc3Qgcm93SW5kZXggPSB7aW5kZXh9O1xuICAgIGNvbnN0IGdlb21ldHJ5ID0gZ2V0R2VvbWV0cnkocm93SW5kZXgpO1xuXG4gICAgaWYgKGdlb21ldHJ5KSB7XG4gICAgICBnZW9qc29uLmZlYXR1cmVzLnB1c2goe1xuICAgICAgICB0eXBlOiAnRmVhdHVyZScsXG4gICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAuLi5nZXRQcm9wZXJ0aWVzKHJvd0luZGV4KVxuICAgICAgICB9LFxuICAgICAgICBnZW9tZXRyeVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGdlb2pzb247XG59XG5cbmV4cG9ydCBjb25zdCBwcmVmaXhHcHVGaWVsZCA9IG5hbWUgPT4gYGdwdToke25hbWV9YDtcblxuZXhwb3J0IGZ1bmN0aW9uIGdwdUZpbHRlclRvTWFwYm94RmlsdGVyKGdwdUZpbHRlcikge1xuICBjb25zdCB7ZmlsdGVyUmFuZ2UsIGZpbHRlclZhbHVlVXBkYXRlVHJpZ2dlcnN9ID0gZ3B1RmlsdGVyO1xuXG4gIGNvbnN0IGhhc0ZpbHRlciA9IE9iamVjdC52YWx1ZXMoZmlsdGVyVmFsdWVVcGRhdGVUcmlnZ2VycykuZmlsdGVyKGQgPT4gZCk7XG5cbiAgaWYgKCFoYXNGaWx0ZXIubGVuZ3RoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBjb25zdCBjb25kaXRpb24gPSBbJ2FsbCddO1xuXG4gIC8vIFtcIj49XCIsIGtleSwgdmFsdWVdXG4gIC8vIFtcIjw9XCIsIGtleSwgdmFsdWVdXG4gIGNvbnN0IGV4cHJlc3Npb25zID0gT2JqZWN0LnZhbHVlcyhmaWx0ZXJWYWx1ZVVwZGF0ZVRyaWdnZXJzKS5yZWR1Y2UoXG4gICAgKGFjY3U6IGFueVtdLCBuYW1lLCBpKSA9PlxuICAgICAgbmFtZVxuICAgICAgICA/IFtcbiAgICAgICAgICAgIC4uLmFjY3UsXG4gICAgICAgICAgICBbJz49JywgcHJlZml4R3B1RmllbGQobmFtZSksIGZpbHRlclJhbmdlW2ldWzBdXSxcbiAgICAgICAgICAgIFsnPD0nLCBwcmVmaXhHcHVGaWVsZChuYW1lKSwgZmlsdGVyUmFuZ2VbaV1bMV1dXG4gICAgICAgICAgXVxuICAgICAgICA6IGFjY3UsXG4gICAgY29uZGl0aW9uXG4gICk7XG5cbiAgcmV0dXJuIGV4cHJlc3Npb25zO1xufVxuIl19