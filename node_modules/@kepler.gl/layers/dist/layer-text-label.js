// Copyright (c) 2022 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getTextOffsetByRadius = getTextOffsetByRadius;
exports.formatTextLabelData = exports.textLabelAccessor = exports.defaultPadding = void 0;

var _viewportMercatorProject = require("viewport-mercator-project");

var _utils = require("@kepler.gl/utils");

var _lodash = _interopRequireDefault(require("lodash.uniq"));var defaultPadding = 20;
exports.defaultPadding = defaultPadding;

function getTextOffsetByRadius(radiusScale, getRadius, mapState) {
  return function (textLabel) {
    var distanceScale = (0, _viewportMercatorProject.getDistanceScales)(mapState);
    var xMult = textLabel.anchor === 'middle' ? 0 : textLabel.anchor === 'start' ? 1 : -1;
    var yMult = textLabel.alignment === 'center' ? 0 : textLabel.alignment === 'bottom' ? 1 : -1;
    var sizeOffset = textLabel.alignment === 'center' ? 0 : textLabel.alignment === 'bottom' ? textLabel.size : textLabel.size;
    var pixelRadius = radiusScale * distanceScale.pixelsPerMeter[0];
    var padding = defaultPadding;
    return typeof getRadius === 'function' ? function (d) {
      return [xMult * (getRadius(d) * pixelRadius + padding), yMult * (getRadius(d) * pixelRadius + padding + sizeOffset)];
    } : [xMult * (getRadius * pixelRadius + padding), yMult * (getRadius * pixelRadius + padding + sizeOffset)];
  };
}

var textLabelAccessor = function textLabelAccessor(textLabel) {
  return function (dc) {
    return function (d) {
      var val = textLabel.field.valueAccessor(d);
      return (0, _utils.notNullorUndefined)(val) ? String(val) : '';
    };
  };
};

exports.textLabelAccessor = textLabelAccessor;

var formatTextLabelData = function formatTextLabelData(_ref) {
  var textLabel = _ref.textLabel,
      triggerChanged = _ref.triggerChanged,
      oldLayerData = _ref.oldLayerData,
      data = _ref.data,
      dataContainer = _ref.dataContainer;
  return textLabel.map(function (tl, i) {
    if (!tl.field) {
      // if no field selected,
      return {
        getText: null,
        characterSet: []
      };
    }

    var getText = textLabelAccessor(tl)(dataContainer);
    var characterSet;

    if (!triggerChanged["getLabelCharacterSet-".concat(i)] && oldLayerData && oldLayerData.textLabels && oldLayerData.textLabels[i]) {
      characterSet = oldLayerData.textLabels[i].characterSet;
    } else {
      var allLabels = tl.field ? data.map(getText) : [];
      characterSet = (0, _lodash["default"])(allLabels.join(''));
    }

    return {
      characterSet: characterSet,
      getText: getText
    };
  });
};

exports.formatTextLabelData = formatTextLabelData;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9sYXllci10ZXh0LWxhYmVsLnRzIl0sIm5hbWVzIjpbImRlZmF1bHRQYWRkaW5nIiwiZ2V0VGV4dE9mZnNldEJ5UmFkaXVzIiwicmFkaXVzU2NhbGUiLCJnZXRSYWRpdXMiLCJtYXBTdGF0ZSIsInRleHRMYWJlbCIsImRpc3RhbmNlU2NhbGUiLCJ4TXVsdCIsImFuY2hvciIsInlNdWx0IiwiYWxpZ25tZW50Iiwic2l6ZU9mZnNldCIsInNpemUiLCJwaXhlbFJhZGl1cyIsInBpeGVsc1Blck1ldGVyIiwicGFkZGluZyIsImQiLCJ0ZXh0TGFiZWxBY2Nlc3NvciIsImRjIiwidmFsIiwiZmllbGQiLCJ2YWx1ZUFjY2Vzc29yIiwiU3RyaW5nIiwiZm9ybWF0VGV4dExhYmVsRGF0YSIsInRyaWdnZXJDaGFuZ2VkIiwib2xkTGF5ZXJEYXRhIiwiZGF0YSIsImRhdGFDb250YWluZXIiLCJtYXAiLCJ0bCIsImkiLCJnZXRUZXh0IiwiY2hhcmFjdGVyU2V0IiwidGV4dExhYmVscyIsImFsbExhYmVscyIsImpvaW4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFvQkE7O0FBQ0E7O0FBQ0E7O0FBdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTU8sSUFBTUEsY0FBYyxHQUFHLEVBQXZCOzs7QUFFQSxTQUFTQyxxQkFBVCxDQUErQkMsV0FBL0IsRUFBNENDLFNBQTVDLEVBQXVEQyxRQUF2RCxFQUFpRTtBQUN0RSxTQUFPLFVBQUFDLFNBQVMsRUFBSTtBQUNsQixRQUFNQyxhQUFhLEdBQUcsZ0RBQWtCRixRQUFsQixDQUF0QjtBQUNBLFFBQU1HLEtBQUssR0FBR0YsU0FBUyxDQUFDRyxNQUFWLEtBQXFCLFFBQXJCLEdBQWdDLENBQWhDLEdBQW9DSCxTQUFTLENBQUNHLE1BQVYsS0FBcUIsT0FBckIsR0FBK0IsQ0FBL0IsR0FBbUMsQ0FB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V0FBTztBQUNMSCxNQUFBQSxZQUFZLEVBQVpBLFlBREs7QUFFTEQsTUFBQUEsT0FBTyxFQUFQQTtBQUZLLEtBQVA7QUFJRCxHQTVCTSxDQUFQO0FBNkJELENBcENNIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDIyIFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuaW1wb3J0IHtnZXREaXN0YW5jZVNjYWxlc30gZnJvbSAndmlld3BvcnQtbWVyY2F0b3ItcHJvamVjdCc7XG5pbXBvcnQge25vdE51bGxvclVuZGVmaW5lZH0gZnJvbSAnQGtlcGxlci5nbC91dGlscyc7XG5pbXBvcnQgdW5pcSBmcm9tICdsb2Rhc2gudW5pcSc7XG5cbmV4cG9ydCBjb25zdCBkZWZhdWx0UGFkZGluZyA9IDIwO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0VGV4dE9mZnNldEJ5UmFkaXVzKHJhZGl1c1NjYWxlLCBnZXRSYWRpdXMsIG1hcFN0YXRlKSB7XG4gIHJldHVybiB0ZXh0TGFiZWwgPT4ge1xuICAgIGNvbnN0IGRpc3RhbmNlU2NhbGUgPSBnZXREaXN0YW5jZVNjYWxlcyhtYXBTdGF0ZSk7XG4gICAgY29uc3QgeE11bHQgPSB0ZXh0TGFiZWwuYW5jaG9yID09PSAnbWlkZGxlJyA/IDAgOiB0ZXh0TGFiZWwuYW5jaG9yID09PSAnc3RhcnQnID8gMSA6IC0xO1xuICAgIGNvbnN0IHlNdWx0ID0gdGV4dExhYmVsLmFsaWdubWVudCA9PT0gJ2NlbnRlcicgPyAwIDogdGV4dExhYmVsLmFsaWdubWVudCA9PT0gJ2JvdHRvbScgPyAxIDogLTE7XG5cbiAgICBjb25zdCBzaXplT2Zmc2V0ID1cbiAgICAgIHRleHRMYWJlbC5hbGlnbm1lbnQgPT09ICdjZW50ZXInXG4gICAgICAgID8gMFxuICAgICAgICA6IHRleHRMYWJlbC5hbGlnbm1lbnQgPT09ICdib3R0b20nXG4gICAgICAgID8gdGV4dExhYmVsLnNpemVcbiAgICAgICAgOiB0ZXh0TGFiZWwuc2l6ZTtcblxuICAgIGNvbnN0IHBpeGVsUmFkaXVzID0gcmFkaXVzU2NhbGUgKiBkaXN0YW5jZVNjYWxlLnBpeGVsc1Blck1ldGVyWzBdO1xuICAgIGNvbnN0IHBhZGRpbmcgPSBkZWZhdWx0UGFkZGluZztcblxuICAgIHJldHVybiB0eXBlb2YgZ2V0UmFkaXVzID09PSAnZnVuY3Rpb24nXG4gICAgICA/IGQgPT4gW1xuICAgICAgICAgIHhNdWx0ICogKGdldFJhZGl1cyhkKSAqIHBpeGVsUmFkaXVzICsgcGFkZGluZyksXG4gICAgICAgICAgeU11bHQgKiAoZ2V0UmFkaXVzKGQpICogcGl4ZWxSYWRpdXMgKyBwYWRkaW5nICsgc2l6ZU9mZnNldClcbiAgICAgICAgXVxuICAgICAgOiBbXG4gICAgICAgICAgeE11bHQgKiAoZ2V0UmFkaXVzICogcGl4ZWxSYWRpdXMgKyBwYWRkaW5nKSxcbiAgICAgICAgICB5TXVsdCAqIChnZXRSYWRpdXMgKiBwaXhlbFJhZGl1cyArIHBhZGRpbmcgKyBzaXplT2Zmc2V0KVxuICAgICAgICBdO1xuICB9O1xufVxuXG5leHBvcnQgY29uc3QgdGV4dExhYmVsQWNjZXNzb3IgPSB0ZXh0TGFiZWwgPT4gZGMgPT4gZCA9PiB7XG4gIGNvbnN0IHZhbCA9IHRleHRMYWJlbC5maWVsZC52YWx1ZUFjY2Vzc29yKGQpO1xuICByZXR1cm4gbm90TnVsbG9yVW5kZWZpbmVkKHZhbCkgPyBTdHJpbmcodmFsKSA6ICcnO1xufTtcblxuZXhwb3J0IGNvbnN0IGZvcm1hdFRleHRMYWJlbERhdGEgPSAoe1xuICB0ZXh0TGFiZWwsXG4gIHRyaWdnZXJDaGFuZ2VkLFxuICBvbGRMYXllckRhdGEsXG4gIGRhdGEsXG4gIGRhdGFDb250YWluZXJcbn0pID0+IHtcbiAgcmV0dXJuIHRleHRMYWJlbC5tYXAoKHRsLCBpKSA9PiB7XG4gICAgaWYgKCF0bC5maWVsZCkge1xuICAgICAgLy8gaWYgbm8gZmllbGQgc2VsZWN0ZWQsXG4gICAgICByZXR1cm4ge1xuICAgICAgICBnZXRUZXh0OiBudWxsLFxuICAgICAgICBjaGFyYWN0ZXJTZXQ6IFtdXG4gICAgICB9O1xuICAgIH1cblxuICAgIGNvbnN0IGdldFRleHQgPSB0ZXh0TGFiZWxBY2Nlc3Nvcih0bCkoZGF0YUNvbnRhaW5lcik7XG4gICAgbGV0IGNoYXJhY3RlclNldDtcblxuICAgIGlmIChcbiAgICAgICF0cmlnZ2VyQ2hhbmdlZFtgZ2V0TGFiZWxDaGFyYWN0ZXJTZXQtJHtpfWBdICYmXG4gICAgICBvbGRMYXllckRhdGEgJiZcbiAgICAgIG9sZExheWVyRGF0YS50ZXh0TGFiZWxzICYmXG4gICAgICBvbGRMYXllckRhdGEudGV4dExhYmVsc1tpXVxuICAgICkge1xuICAgICAgY2hhcmFjdGVyU2V0ID0gb2xkTGF5ZXJEYXRhLnRleHRMYWJlbHNbaV0uY2hhcmFjdGVyU2V0O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBhbGxMYWJlbHMgPSB0bC5maWVsZCA/IGRhdGEubWFwKGdldFRleHQpIDogW107XG4gICAgICBjaGFyYWN0ZXJTZXQgPSB1bmlxKGFsbExhYmVscy5qb2luKCcnKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGNoYXJhY3RlclNldCxcbiAgICAgIGdldFRleHRcbiAgICB9O1xuICB9KTtcbn07XG4iXX0=