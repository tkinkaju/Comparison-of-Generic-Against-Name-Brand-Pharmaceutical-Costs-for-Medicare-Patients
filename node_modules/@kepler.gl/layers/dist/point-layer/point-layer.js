// Copyright (c) 2022 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = exports.pointVisConfigs = exports.pointOptionalColumns = exports.pointRequiredColumns = exports.pointPosAccessor = void 0;

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _extensions = require("@deck.gl/extensions");

var _layers = require("@deck.gl/layers");

var _baseLayer = _interopRequireDefault(require("../base-layer"));

var _utils = require("@kepler.gl/utils");

var _pointLayerIcon = _interopRequireDefault(require("./point-layer-icon"));

var _constants = require("@kepler.gl/constants");

var _layerTextLabel = require("../layer-text-label");

var _layerUtils = require("../layer-utils");

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var pointPosAccessor = function pointPosAccessor(_ref) {
  var lat = _ref.lat,
      lng = _ref.lng,
      altitude = _ref.altitude;
  return function (dc) {
    return function (d) {
      return [dc.valueAt(d.index, lng.fieldIdx), dc.valueAt(d.index, lat.fieldIdx), altitude && altitude.fieldIdx > -1 ? dc.valueAt(d.index, altitude.fieldIdx) : 0];
    };
  };
};

exports.pointPosAccessor = pointPosAccessor;
var pointRequiredColumns = ['lat', 'lng'];
exports.pointRequiredColumns = pointRequiredColumns;
var pointOptionalColumns = ['altitude'];
exports.pointOptionalColumns = pointOptionalColumns;
var brushingExtension = new _extensions.BrushingExtension();
var pointVisConfigs = {
  radius: 'radius',
  fixedRadius: 'fixedRadius',
  opacity: 'opacity',
  outline: 'outline',
  thickness: 'thickness',
  strokeColor: 'strokeColor',
  colorRange: 'colorRange',
  strokeColorRange: 'strokeColorRange',
  radiusRange: 'radiusRange',
  filled: _objectSpread(_objectSpread({}, _constants.LAYER_VIS_CONFIGS.filled), {}, {
    type: 'boolean',
    label: 'layer.fillColor',
    defaultValue: true,
    property: 'filled'
  })
};
exports.pointVisConfigs = pointVisConfigs;

var PointLayer = /*#__PURE__*/function (_Layer) {
  (0, _inherits2["default"])(PointLayer, _Layer);

  var _super = _createSuper(PointLayer);

  function PointLayer(props) {
    var _this;

    (0, _classCallCheck2["default"])(this, PointLayer);
    _this = _super.call(this, props);

    _this.registerVisConfig(pointVisConfigs);

    _this.getPositionAccessor = function (dataContainer) {
      return pointPosAccessor(_this.config.columns)(dataContainer);
    };

    return _this;
  }

  (0, _createClass2["default"])(PointLayer, [{
    key: "type",
    get: function get() {
      return 'point';
    }
  }, {
    key: "isAggregated",
    get: function get() {
      return false;
    }
  }, {
    key: "layerIcon",
    get: function get() {
      return _pointLayerIcon["default"];
    }
  }, {
    key: "requiredLayerColumns",
    get: function get() {
      return pointRequiredColumns;
    }
  }, {
    key: "optionalColumns",
    get: function get() {
      return pointOptionalColumns;
    }
  }, {
    key: "columnPairs",
    get: function get() {
      return this.defaultPointColumnPairs;
    }
  }, {
    key: "noneLayerDataAffectingProps",
    get: function get() {
      return [].concat((0, _toConsumableArray2["default"])((0, _get2["default"])((0, _getPrototypeOf2["default"])(PointLayer.prototype), "noneLayerDataAffectingProps", this)), ['radius']);
    }
  }, {
    key: "visualChannels",
    get: function get() {
      return {
        color: _objectSpread(_objectSpread({}, (0, _get2["default"])((0, _getPrototypeOf2["default"])(PointLayer.prototype), "visualChannels", this).color), {}, {
          accessor: 'getFillColor',
          condition: function condition(config) {
            return config.visConfig.filled;
          },
          defaultValue: function defaultValue(config) {
            return config.color;
          }
        }),
        strokeColor: {
          property: 'strokeColor',
          key: 'strokeColor',
          field: 'strokeColorField',
          scale: 'strokeColorScale',
          domain: 'strokeColorDomain',
          range: 'strokeColorRange',
          channelScaleType: _constants.CHANNEL_SCALES.color,
          accessor: 'getLineColor',
          condition: function condition(config) {
            return config.visConfig.outline;
          },
          defaultValue: function defaultValue(config) {
            return config.visConfig.strokeColor || config.color;
          }
        },
        size: _objectSpread(_objectSpread({}, (0, _get2["default"])((0, _getPrototypeOf2["default"])(PointLayer.prototype), "visualChannels", this).size), {}, {
          property: 'radius',
          range: 'radiusRange',
          fixed: 'fixedRadius',
          channelScaleType: 'radius',
          accessor: 'getRadius',
          defaultValue: 1
        })
      };
    }
  }, {
    key: "setInitialLayerConfig",
    value: function setInitialLayerConfig(dataset) {
      if (!dataset.dataContainer.numRows()) {
        return this;
      }

      var defaultColorField = (0, _utils.findDefaultColorField)(dataset);

      if (defaultColorField) {
        this.updateLayerConfig({
          // @ts-expect-error Remove this after updateLayerConfig converted into generic function
          colorField: defaultColorField
        });
        this.updateLayerVisualChannel(dataset, 'color');
      }

      return this;
    }
  }, {
    key: "getDefaultLayerConfig",
    value: function getDefaultLayerConfig() {
      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      return _objectSpread(_objectSpread({}, (0, _get2["default"])((0, _getPrototypeOf2["default"])(PointLayer.prototype), "getDefaultLayerConfig", this).call(this, props)), {}, {
        // add stroke color visual channel
        strokeColorField: null,
        strokeColorDomain: [0, 1],
        strokeColorScale: 'quantile'
      });
    }
  }, {
    key: "calculateDataAttribute",
    value: function calculateDataAttribute(_ref2, getPosition) {
      var filteredIndex = _ref2.filteredIndex;
      var data = [];

      for (var i = 0; i < filteredIndex.length; i++) {
        var index = filteredIndex[i];
        var pos = getPosition({
          index: index
        }); // if doesn't have point lat or lng, do not add the point
        // deck.gl can't handle position = null

        if (pos.every(Number.isFinite)) {
          data.push({
            position: pos,
            index: index
          });
        }
      }

      return data;
    }
  }, {
    key: "formatLayerData",
    value: function formatLayerData(datasets, oldLayerData) {
      if (this.config.dataId === null) {
        return {};
      }

      var textLabel = this.config.textLabel;
      var _datasets$this$config = datasets[this.config.dataId],
          gpuFilter = _datasets$this$config.gpuFilter,
          dataContainer = _datasets$this$config.dataContainer;

      var _this$updateData = this.updateData(datasets, oldLayerData),
          data = _this$updateData.data,
          triggerChanged = _this$updateData.triggerChanged;

      var getPosition = this.getPositionAccessor(dataContainer); // get all distinct characters in the text labels

      var textLabels = (0, _layerTextLabel.formatTextLabelData)({
        textLabel: textLabel,
        triggerChanged: triggerChanged,
        oldLayerData: oldLayerData,
        data: data,
        dataContainer: dataContainer
      });
      var accessors = this.getAttributeAccessors({
        dataContainer: dataContainer
      });
      return _objectSpread({
        data: data,
        getPosition: getPosition,
        getFilterValue: gpuFilter.filterValueAccessor(dataContainer)(),
        textLabels: textLabels
      }, accessors);
    }
    /* eslint-enable complexity */

  }, {
    key: "updateLayerMeta",
    value: function updateLayerMeta(dataContainer) {
      var getPosition = this.getPositionAccessor(dataContainer);
      var bounds = this.getPointsBounds(dataContainer, getPosition);
      this.updateMeta({
        bounds: bounds
      });
    }
  }, {
    key: "renderLayer",
    value: function renderLayer(opts) {
      var _this$config$columns$;

      var data = opts.data,
          gpuFilter = opts.gpuFilter,
          objectHovered = opts.objectHovered,
          mapState = opts.mapState,
          interactionConfig = opts.interactionConfig; // if no field size is defined we need to pass fixed radius = false

      var fixedRadius = this.config.visConfig.fixedRadius && Boolean(this.config.sizeField);
      var radiusScale = this.getRadiusScaleByZoom(mapState, fixedRadius);

      var layerProps = _objectSpread({
        stroked: this.config.visConfig.outline,
        filled: this.config.visConfig.filled,
        lineWidthScale: this.config.visConfig.thickness,
        radiusScale: radiusScale
      }, this.config.visConfig.fixedRadius ? {} : {
        radiusMaxPixels: 500
      });

      var updateTriggers = _objectSpread({
        getPosition: this.config.columns,
        getFilterValue: gpuFilter.filterValueUpdateTriggers
      }, this.getVisualChannelUpdateTriggers());

      var defaultLayerProps = this.getDefaultDeckLayerProps(opts);
      var brushingProps = this.getBrushingExtensionProps(interactionConfig);
      var getPixelOffset = (0, _layerTextLabel.getTextOffsetByRadius)(radiusScale, data.getRadius, mapState);
      var extensions = [].concat((0, _toConsumableArray2["default"])(defaultLayerProps.extensions), [brushingExtension]);

      var sharedProps = _objectSpread({
        getFilterValue: data.getFilterValue,
        extensions: extensions,
        filterRange: defaultLayerProps.filterRange,
        visible: defaultLayerProps.visible
      }, brushingProps);

      var hoveredObject = this.hasHoveredObject(objectHovered);
      return [new _layers.ScatterplotLayer(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread({}, defaultLayerProps), brushingProps), layerProps), data), {}, {
        parameters: {
          // circles will be flat on the map when the altitude column is not used
          depthTest: ((_this$config$columns$ = this.config.columns.altitude) === null || _this$config$columns$ === void 0 ? void 0 : _this$config$columns$.fieldIdx) > -1
        },
        lineWidthUnits: 'pixels',
        updateTriggers: updateTriggers,
        extensions: extensions
      }))].concat((0, _toConsumableArray2["default"])(hoveredObject ? [new _layers.ScatterplotLayer(_objectSpread(_objectSpread(_objectSpread({}, this.getDefaultHoverLayerProps()), layerProps), {}, {
        data: [hoveredObject],
        getLineColor: this.config.highlightColor,
        getFillColor: this.config.highlightColor,
        getRadius: data.getRadius,
        getPosition: data.getPosition
      }))] : []), (0, _toConsumableArray2["default"])(this.renderTextLabelLayer({
        getPosition: data.getPosition,
        sharedProps: sharedProps,
        getPixelOffset: getPixelOffset,
        updateTriggers: updateTriggers
      }, opts)));
    }
  }], [{
    key: "findDefaultLayerProps",
    value: function findDefaultLayerProps(_ref3) {
      var _ref3$fieldPairs = _ref3.fieldPairs,
          fieldPairs = _ref3$fieldPairs === void 0 ? [] : _ref3$fieldPairs;
      var props = []; // Make layer for each pair

      fieldPairs.forEach(function (pair) {
        var latField = pair.pair.lat;
        var prop = {
          label: pair.defaultName || 'Point'
        }; // default layer color for begintrip and dropoff point

        if (latField.value in _constants.DEFAULT_LAYER_COLOR) {
          prop.color = (0, _utils.hexToRgb)(_constants.DEFAULT_LAYER_COLOR[latField.value]);
        } // set the first layer to be visible


        if (props.length === 0) {
          prop.isVisible = true;
        }

        prop.columns = (0, _layerUtils.assignPointPairToLayerColumn)(pair, true);
        props.push(prop);
      });
      return {
        props: props
      };
    }
  }]);
  return PointLayer;
}(_baseLayer["default"]);

exports["default"] = PointLayer;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9wb2ludC1sYXllci9wb2ludC1sYXllci50cyJdLCJuYW1lcyI6WyJwb2ludFBvc0FjY2Vzc29yIiwibGF0IiwibG5nIiwiYWx0aXR1ZGUiLCJkYyIsImQiLCJ2YWx1ZUF0IiwiaW5kZXgiLCJmaWVsZElkeCIsInBvaW50UmVxdWlyZWRDb2x1bW5zIiwicG9pbnRPcHRpb25hbENvbHVtbnMiLCJicnVzaGluZ0V4dGVuc2lvbiIsIkJydXNoaW5nRXh0ZW5zaW9uIiwicG9pbnRWaXNDb25maWdzIiwicmFkaXVzIiwiZml4ZWRSYWRpdXMiLCJvcGFjaXR5Iiwib3V0bGluZSIsInRoaWNrbmVzcyIsInN0cm9rZUNvbG9yIiwiY29sb3JSYW5nZSIsInN0cm9rZUNvbG9yUmFuZ2UiLCJyYWRpdXNSYW5nZSIsImZpbGxlZCIsIkxBWUVSX1ZJU19DT05GSUdTIiwidHlwZSIsImxhYmVsIiwiZGVmYXVsdFZhbHVlIiwicHJvcGVydHkiLCJQb2ludExheWVyIiwicHJvcHMiLCJyZWdpc3RlclZpc0NvbmZpZyIsImdldFBvc2l0aW9uQWNjZXNzb3IiLCJkYXRhQ29udGFpbmVyIiwiY29uZmlnIiwiY29sdW1ucyIsIlBvaW50TGF5ZXJJY29uIiwiZGVmYXVsdFBvaW50Q29sdW1uUGFpcnMiLCJjb2xvciIsImFjY2Vzc29yIiwiY29uZGl0aW9uIiwidmlzQ29uZmlnIiwia2V5IiwiZmllbGQiLCJzY2FsZSIsImRvbWFpbiIsInJhbmdlIiwiY2hhbm5lbFNjYWxlVHlwZSIsIkNIQU5ORUxfU0NBTEVTIiwic2l6ZSIsImZpeGVkIiwiZGF0YXNldCIsIm51bVJvd3MiLCJkZWZhdWx0Q29sb3JGaWVsZCIsInVwZGF0ZUxheWVyQ29uZmlnIiwiY29sb3JGaWVsZCIsInVwZGF0ZUxheWVyVmlzdWFsQ2hhbm5lbCIsInN0cm9rZUNvbG9yRmllbGQiLCJzdHJva2VDb2xvckRvbWFpbiIsInN0cm9rZUNvbG9yU2NhbGUiLCJnZXRQb3NpdGlvbiIsImZpbHRlcmVkSW5kZXgiLCJkYXRhIiwiaSIsImxlbmd0aCIsInBvcyIsImV2ZXJ5IiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJwdXNoIiwicG9zaXRpb24iLCJkYXRhc2V0cyIsIm9sZExheWVyRGF0YSIsImRhdGFJZCIsInRleHRMYWJlbCIsImdwdUZpbHRlciIsInVwZGF0ZURhdGEiLCJ0cmlnZ2VyQ2hhbmdlZCIsInRleHRMYWJlbHMiLCJhY2Nlc3NvcnMiLCJnZXRBdHRyaWJ1dGVBY2Nlc3NvcnMiLCJnZXRGaWx0ZXJWYWx1ZSIsImZpbHRlclZhbHVlQWNjZXNzb3IiLCJib3VuZHMiLCJnZXRQb2ludHNCb3VuZHMiLCJ1cGRhdGVNZXRhIiwib3B0cyIsIm9iamVjdEhvdmVyZWQiLCJtYXBTdGF0ZSIsImludGVyYWN0aW9uQ29uZmlnIiwiQm9vbGVhbiIsInNpemVGaWVsZCIsInJhZGl1c1NjYWxlIiwiZ2V0UmFkaXVzU2NhbGVCeVpvb20iLCJsYXllclByb3BzIiwic3Ryb2tlZCIsImxpbmVXaWR0aFNjYWxlIiwicmFkaXVzTWF4UGl4ZWxzIiwidXBkYXRlVHJpZ2dlcnMiLCJmaWx0ZXJWYWx1ZVVwZGF0ZVRyaWdnZXJzIiwiZ2V0VmlzdWFsQ2hhbm5lbFVwZGF0ZVRyaWdnZXJzIiwiZGVmYXVsdExheWVyUHJvcHMiLCJnZXREZWZhdWx0RGVja0xheWVyUHJvcHMiLCJicnVzaGluZ1Byb3BzIiwiZ2V0QnJ1c2hpbmdFeHRlbnNpb25Qcm9wcyIsImdldFBpeGVsT2Zmc2V0IiwiZ2V0UmFkaXVzIiwiZXh0ZW5zaW9ucyIsInNoYXJlZFByb3BzIiwiZmlsdGVyUmFuZ2UiLCJ2aXNpYmxlIiwiaG92ZXJlZE9iamVjdCIsImhhc0hvdmVyZWRPYmplY3QiLCJTY2F0dGVycGxvdExheWVyIiwicGFyYW1ldGVycyIsImRlcHRoVGVzdCIsImxpbmVXaWR0aFVuaXRzIiwiZ2V0RGVmYXVsdEhvdmVyTGF5ZXJQcm9wcyIsImdldExpbmVDb2xvciIsImhpZ2hsaWdodENvbG9yIiwiZ2V0RmlsbENvbG9yIiwicmVuZGVyVGV4dExhYmVsTGF5ZXIiLCJmaWVsZFBhaXJzIiwiZm9yRWFjaCIsInBhaXIiLCJsYXRGaWVsZCIsInByb3AiLCJkZWZhdWx0TmFtZSIsInZhbHVlIiwiREVGQVVMVF9MQVlFUl9DT0xPUiIsImlzVmlzaWJsZSIsIkxheWVyIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBb0JBOztBQUNBOztBQUVBOztBQU9BOztBQUVBOztBQUNBOztBQU9BOztBQUNBOzs7Ozs7Ozs7O0FBd0RPLElBQU1BLGdCQUFnQixHQUFHLFNBQW5CQSxnQkFBbUI7QUFBQSxNQUFFQyxHQUFGLFFBQUVBLEdBQUY7QUFBQSxNQUFPQyxHQUFQLFFBQU9BLEdBQVA7QUFBQSxNQUFZQyxRQUFaLFFBQVlBLFFBQVo7QUFBQSxTQUFtRCxVQUFBQyxFQUFFO0FBQUEsV0FBSSxVQUFBQyxDQUFDO0FBQUEsYUFBSSxDQUM1RkQsRUFBRSxDQUFDRSxPQUFILENBQVdELENBQUMsQ0FBQ0UsS0FBYixFQUFvQkwsR0FBRyxDQUFDTSxRQUF4QixDQUQ0RixFQUU1RkosRUFBRSxDQUFDRSxPQUFILENBQVdELENBQUMsQ0FBQ0UsS0FBYixFQUFvQk4sR0FBRyxDQUFDTyxRQUF4QixDQUY0RixFQUc1RkwsUUFBUSxJQUFJQSxRQUFRLENBQUNLLFFBQVQsR0FBb0IsQ0FBQyxDQUFqQyxHQUFxQ0osRUFBRSxDQUFDRSxPQUFILENBQVdELENBQUMsQ0FBQ0UsS0FBYixFQUFvQkosUUFBUSxDQUFDSyxRQUE3QixDQUFyQyxHQUE4RSxDQUhjLENBQUo7QUFBQSxLQUFMO0FBQUEsR0FBckQ7QUFBQSxDQUF6Qjs7O0FBTUEsSUFBTUMsb0JBQW9DLEdBQUcsQ0FBQyxLQUFELEVBQVEsS0FBUixDQUE3Qzs7QUFDQSxJQUFNQyxvQkFBa0MsR0FBRyxDQUFDLFVBQUQsQ0FBM0M7O0FBRVAsSUFBTUMsaUJBQWlCLEdBQUcsSUFBSUMsNkJBQUosRUFBMUI7QUFFTyxJQUFNQyxlQVdaLEdBQUc7QUFDRkMsRUFBQUEsTUFBTSxFQUFFLFFBRE47QUFFRkMsRUFB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S0wsR0FBRztBQUNGcEcsVUFBQUEsS0FBSyxFQUFFa0csSUFBSSxDQUFDRyxXQUFMLElBQW9CO0FBRHpCLFNBTEosQ0FIeUIsQ0FZekI7O0FBQ0EsWUFBSUYsUUFBUSxDQUFDRyxLQUFULElBQWtCQyw4QkFBdEIsRUFBMkM7QUFDekNILFVBQUFBLElBQUksQ0FBQ3hGLEtBQUwsR0FBYSxxQkFBUzJGLCtCQUFvQkosUUFBUSxDQUFDRyxLQUE3QixDQUFULENBQWI7QUFDRCxTQWZ3QixDQWlCekI7OztBQUNBLFlBQUlsRyxLQUFLLENBQUNrQyxNQUFOLEtBQWlCLENBQXJCLEVBQXdCO0FBQ3RCOEQsVUFBQUEsSUFBSSxDQUFDSSxTQUFMLEdBQWlCLElBQWpCO0FBQ0Q7O0FBQ0RKLFFBQUFBLElBQUksQ0FBQzNGLE9BQUwsR0FBZSw4Q0FBNkJ5RixJQUE3QixFQUFtQyxJQUFuQyxDQUFmO0FBRUE5RixRQUFBQSxLQUFLLENBQUN1QyxJQUFOLENBQVd5RCxJQUFYO0FBQ0QsT0F4QkQ7QUEwQkEsYUFBTztBQUFDaEcsUUFBQUEsS0FBSyxFQUFMQTtBQUFELE9BQVA7QUFDRDs7O0VBM0hxQ3FHLHFCIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDIyIFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuaW1wb3J0IHtCcnVzaGluZ0V4dGVuc2lvbn0gZnJvbSAnQGRlY2suZ2wvZXh0ZW5zaW9ucyc7XG5pbXBvcnQge1NjYXR0ZXJwbG90TGF5ZXJ9IGZyb20gJ0BkZWNrLmdsL2xheWVycyc7XG5cbmltcG9ydCBMYXllciwge1xuICBMYXllckJhc2VDb25maWcsXG4gIExheWVyQ29sb3JDb25maWcsXG4gIExheWVyQ29sdW1uLFxuICBMYXllclNpemVDb25maWcsXG4gIExheWVyU3Ryb2tlQ29sb3JDb25maWdcbn0gZnJvbSAnLi4vYmFzZS1sYXllcic7XG5pbXBvcnQge2hleFRvUmdiLCBmaW5kRGVmYXVsdENvbG9yRmllbGR9IGZyb20gJ0BrZXBsZXIuZ2wvdXRpbHMnO1xuaW1wb3J0IHtkZWZhdWx0IGFzIEtlcGxlclRhYmxlfSBmcm9tICdAa2VwbGVyLmdsL3RhYmxlJztcbmltcG9ydCBQb2ludExheWVySWNvbiBmcm9tICcuL3BvaW50LWxheWVyLWljb24nO1xuaW1wb3J0IHtcbiAgTEFZRVJfVklTX0NPTkZJR1MsXG4gIERFRkFVTFRfTEFZRVJfQ09MT1IsXG4gIENIQU5ORUxfU0NBTEVTLFxuICBDb2xvclJhbmdlXG59IGZyb20gJ0BrZXBsZXIuZ2wvY29uc3RhbnRzJztcblxuaW1wb3J0IHtnZXRUZXh0T2Zmc2V0QnlSYWRpdXMsIGZvcm1hdFRleHRMYWJlbERhdGF9IGZyb20gJy4uL2xheWVyLXRleHQtbGFiZWwnO1xuaW1wb3J0IHthc3NpZ25Qb2ludFBhaXJUb0xheWVyQ29sdW1ufSBmcm9tICcuLi9sYXllci11dGlscyc7XG5pbXBvcnQge1xuICBNZXJnZSxcbiAgUkdCQ29sb3IsXG4gIFZpc0NvbmZpZ0Jvb2xlYW4sXG4gIFZpc0NvbmZpZ0NvbG9yUmFuZ2UsXG4gIFZpc0NvbmZpZ0NvbG9yU2VsZWN0LFxuICBWaXNDb25maWdOdW1iZXIsXG4gIFZpc0NvbmZpZ1JhbmdlXG59IGZyb20gJ0BrZXBsZXIuZ2wvdHlwZXMnO1xuXG5leHBvcnQgdHlwZSBQb2ludExheWVyVmlzQ29uZmlnU2V0dGluZ3MgPSB7XG4gIHJhZGl1czogVmlzQ29uZmlnTnVtYmVyO1xuICBmaXhlZFJhZGl1czogVmlzQ29uZmlnQm9vbGVhbjtcbiAgb3BhY2l0eTogVmlzQ29uZmlnTnVtYmVyO1xuICBvdXRsaW5lOiBWaXNDb25maWdCb29sZWFuO1xuICB0aGlja25lc3M6IFZpc0NvbmZpZ051bWJlcjtcbiAgc3Ryb2tlQ29sb3I6IFZpc0NvbmZpZ0NvbG9yU2VsZWN0O1xuICBjb2xvclJhbmdlOiBWaXNDb25maWdDb2xvclJhbmdlO1xuICBzdHJva2VDb2xvclJhbmdlOiBWaXNDb25maWdDb2xvclJhbmdlO1xuICByYWRpdXNSYW5nZTogVmlzQ29uZmlnUmFuZ2U7XG4gIGZpbGxlZDogVmlzQ29uZmlnQm9vbGVhbjtcbn07XG5cbmV4cG9ydCB0eXBlIFBvaW50TGF5ZXJDb2x1bW5zQ29uZmlnID0ge1xuICBsYXQ6IExheWVyQ29sdW1uO1xuICBsbmc6IExheWVyQ29sdW1uO1xuICBhbHRpdHVkZT86IExheWVyQ29sdW1uO1xufTtcblxuZXhwb3J0IHR5cGUgUG9pbnRMYXllclZpc0NvbmZpZyA9IHtcbiAgcmFkaXVzOiBudW1iZXI7XG4gIGZpeGVkUmFkaXVzOiBib29sZWFuO1xuICBvcGFjaXR5OiBudW1iZXI7XG4gIG91dGxpbmU6IGJvb2xlYW47XG4gIHRoaWNrbmVzczogbnVtYmVyO1xuICBzdHJva2VDb2xvcjogUkdCQ29sb3I7XG4gIGNvbG9yUmFuZ2U6IENvbG9yUmFuZ2U7XG4gIHN0cm9rZUNvbG9yUmFuZ2U6IENvbG9yUmFuZ2U7XG4gIHJhZGl1c1JhbmdlOiBbbnVtYmVyLCBudW1iZXJdO1xuICBmaWxsZWQ6IGJvb2xlYW47XG59O1xuZXhwb3J0IHR5cGUgUG9pbnRMYXllclZpc3VhbENoYW5uZWxDb25maWcgPSBMYXllckNvbG9yQ29uZmlnICZcbiAgTGF5ZXJTaXplQ29uZmlnICZcbiAgTGF5ZXJTdHJva2VDb2xvckNvbmZpZztcbmV4cG9ydCB0eXBlIFBvaW50TGF5ZXJDb25maWcgPSBNZXJnZTxcbiAgTGF5ZXJCYXNlQ29uZmlnLFxuICB7Y29sdW1uczogUG9pbnRMYXllckNvbHVtbnNDb25maWc7IHZpc0NvbmZpZzogUG9pbnRMYXllclZpc0NvbmZpZ31cbj4gJlxuICBQb2ludExheWVyVmlzdWFsQ2hhbm5lbENvbmZpZztcblxuZXhwb3J0IHR5cGUgUG9pbnRMYXllckRhdGEgPSB7XG4gIHBvc2l0aW9uOiBudW1iZXJbXTtcbiAgaW5kZXg6IG51bWJlcjtcbn07XG5cbmV4cG9ydCBjb25zdCBwb2ludFBvc0FjY2Vzc29yID0gKHtsYXQsIGxuZywgYWx0aXR1ZGV9OiBQb2ludExheWVyQ29sdW1uc0NvbmZpZykgPT4gZGMgPT4gZCA9PiBbXG4gIGRjLnZhbHVlQXQoZC5pbmRleCwgbG5nLmZpZWxkSWR4KSxcbiAgZGMudmFsdWVBdChkLmluZGV4LCBsYXQuZmllbGRJZHgpLFxuICBhbHRpdHVkZSAmJiBhbHRpdHVkZS5maWVsZElkeCA+IC0xID8gZGMudmFsdWVBdChkLmluZGV4LCBhbHRpdHVkZS5maWVsZElkeCkgOiAwXG5dO1xuXG5leHBvcnQgY29uc3QgcG9pbnRSZXF1aXJlZENvbHVtbnM6IFsnbGF0JywgJ2xuZyddID0gWydsYXQnLCAnbG5nJ107XG5leHBvcnQgY29uc3QgcG9pbnRPcHRpb25hbENvbHVtbnM6IFsnYWx0aXR1ZGUnXSA9IFsnYWx0aXR1ZGUnXTtcblxuY29uc3QgYnJ1c2hpbmdFeHRlbnNpb24gPSBuZXcgQnJ1c2hpbmdFeHRlbnNpb24oKTtcblxuZXhwb3J0IGNvbnN0IHBvaW50VmlzQ29uZmlnczoge1xuICByYWRpdXM6ICdyYWRpdXMnO1xuICBmaXhlZFJhZGl1czogJ2ZpeGVkUmFkaXVzJztcbiAgb3BhY2l0eTogJ29wYWNpdHknO1xuICBvdXRsaW5lOiAnb3V0bGluZSc7XG4gIHRoaWNrbmVzczogJ3RoaWNrbmVzcyc7XG4gIHN0cm9rZUNvbG9yOiAnc3Ryb2tlQ29sb3InO1xuICBjb2xvclJhbmdlOiAnY29sb3JSYW5nZSc7XG4gIHN0cm9rZUNvbG9yUmFuZ2U6ICdzdHJva2VDb2xvclJhbmdlJztcbiAgcmFkaXVzUmFuZ2U6ICdyYWRpdXNSYW5nZSc7XG4gIGZpbGxlZDogVmlzQ29uZmlnQm9vbGVhbjtcbn0gPSB7XG4gIHJhZGl1czogJ3JhZGl1cycsXG4gIGZpeGVkUmFkaXVzOiAnZml4ZWRSYWRpdXMnLFxuICBvcGFjaXR5OiAnb3BhY2l0eScsXG4gIG91dGxpbmU6ICdvdXRsaW5lJyxcbiAgdGhpY2tuZXNzOiAndGhpY2tuZXNzJyxcbiAgc3Ryb2tlQ29sb3I6ICdzdHJva2VDb2xvcicsXG4gIGNvbG9yUmFuZ2U6ICdjb2xvclJhbmdlJyxcbiAgc3Ryb2tlQ29sb3JSYW5nZTogJ3N0cm9rZUNvbG9yUmFuZ2UnLFxuICByYWRpdXNSYW5nZTogJ3JhZGl1c1JhbmdlJyxcbiAgZmlsbGVkOiB7XG4gICAgLi4uTEFZRVJfVklTX0NPTkZJR1MuZmlsbGVkLFxuICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICBsYWJlbDogJ2xheWVyLmZpbGxDb2xvcicsXG4gICAgZGVmYXVsdFZhbHVlOiB0cnVlLFxuICAgIHByb3BlcnR5OiAnZmlsbGVkJ1xuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQb2ludExheWVyIGV4dGVuZHMgTGF5ZXIge1xuICBkZWNsYXJlIGNvbmZpZzogUG9pbnRMYXllckNvbmZpZztcbiAgZGVjbGFyZSB2aXNDb25maWdTZXR0aW5nczogUG9pbnRMYXllclZpc0NvbmZpZ1NldHRpbmdzO1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcblxuICAgIHRoaXMucmVnaXN0ZXJWaXNDb25maWcocG9pbnRWaXNDb25maWdzKTtcbiAgICB0aGlzLmdldFBvc2l0aW9uQWNjZXNzb3IgPSBkYXRhQ29udGFpbmVyID0+XG4gICAgICBwb2ludFBvc0FjY2Vzc29yKHRoaXMuY29uZmlnLmNvbHVtbnMpKGRhdGFDb250YWluZXIpO1xuICB9XG5cbiAgZ2V0IHR5cGUoKTogJ3BvaW50JyB7XG4gICAgcmV0dXJuICdwb2ludCc7XG4gIH1cblxuICBnZXQgaXNBZ2dyZWdhdGVkKCk6IGZhbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBnZXQgbGF5ZXJJY29uKCkge1xuICAgIHJldHVybiBQb2ludExheWVySWNvbjtcbiAgfVxuICBnZXQgcmVxdWlyZWRMYXllckNvbHVtbnMoKSB7XG4gICAgcmV0dXJuIHBvaW50UmVxdWlyZWRDb2x1bW5zO1xuICB9XG5cbiAgZ2V0IG9wdGlvbmFsQ29sdW1ucygpIHtcbiAgICByZXR1cm4gcG9pbnRPcHRpb25hbENvbHVtbnM7XG4gIH1cblxuICBnZXQgY29sdW1uUGFpcnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVmYXVsdFBvaW50Q29sdW1uUGFpcnM7XG4gIH1cblxuICBnZXQgbm9uZUxheWVyRGF0YUFmZmVjdGluZ1Byb3BzKCkge1xuICAgIHJldHVybiBbLi4uc3VwZXIubm9uZUxheWVyRGF0YUFmZmVjdGluZ1Byb3BzLCAncmFkaXVzJ107XG4gIH1cblxuICBnZXQgdmlzdWFsQ2hhbm5lbHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbG9yOiB7XG4gICAgICAgIC4uLnN1cGVyLnZpc3VhbENoYW5uZWxzLmNvbG9yLFxuICAgICAgICBhY2Nlc3NvcjogJ2dldEZpbGxDb2xvcicsXG4gICAgICAgIGNvbmRpdGlvbjogY29uZmlnID0+IGNvbmZpZy52aXNDb25maWcuZmlsbGVkLFxuICAgICAgICBkZWZhdWx0VmFsdWU6IGNvbmZpZyA9PiBjb25maWcuY29sb3JcbiAgICAgIH0sXG4gICAgICBzdHJva2VDb2xvcjoge1xuICAgICAgICBwcm9wZXJ0eTogJ3N0cm9rZUNvbG9yJyxcbiAgICAgICAga2V5OiAnc3Ryb2tlQ29sb3InLFxuICAgICAgICBmaWVsZDogJ3N0cm9rZUNvbG9yRmllbGQnLFxuICAgICAgICBzY2FsZTogJ3N0cm9rZUNvbG9yU2NhbGUnLFxuICAgICAgICBkb21haW46ICdzdHJva2VDb2xvckRvbWFpbicsXG4gICAgICAgIHJhbmdlOiAnc3Ryb2tlQ29sb3JSYW5nZScsXG4gICAgICAgIGNoYW5uZWxTY2FsZVR5cGU6IENIQU5ORUxfU0NBTEVTLmNvbG9yLFxuICAgICAgICBhY2Nlc3NvcjogJ2dldExpbmVDb2xvcicsXG4gICAgICAgIGNvbmRpdGlvbjogY29uZmlnID0+IGNvbmZpZy52aXNDb25maWcub3V0bGluZSxcbiAgICAgICAgZGVmYXVsdFZhbHVlOiBjb25maWcgPT4gY29uZmlnLnZpc0NvbmZpZy5zdHJva2VDb2xvciB8fCBjb25maWcuY29sb3JcbiAgICAgIH0sXG4gICAgICBzaXplOiB7XG4gICAgICAgIC4uLnN1cGVyLnZpc3VhbENoYW5uZWxzLnNpemUsXG4gICAgICAgIHByb3BlcnR5OiAncmFkaXVzJyxcbiAgICAgICAgcmFuZ2U6ICdyYWRpdXNSYW5nZScsXG4gICAgICAgIGZpeGVkOiAnZml4ZWRSYWRpdXMnLFxuICAgICAgICBjaGFubmVsU2NhbGVUeXBlOiAncmFkaXVzJyxcbiAgICAgICAgYWNjZXNzb3I6ICdnZXRSYWRpdXMnLFxuICAgICAgICBkZWZhdWx0VmFsdWU6IDFcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgc2V0SW5pdGlhbExheWVyQ29uZmlnKGRhdGFzZXQpIHtcbiAgICBpZiAoIWRhdGFzZXQuZGF0YUNvbnRhaW5lci5udW1Sb3dzKCkpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBjb25zdCBkZWZhdWx0Q29sb3JGaWVsZCA9IGZpbmREZWZhdWx0Q29sb3JGaWVsZChkYXRhc2V0KTtcblxuICAgIGlmIChkZWZhdWx0Q29sb3JGaWVsZCkge1xuICAgICAgdGhpcy51cGRhdGVMYXllckNvbmZpZyh7XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgUmVtb3ZlIHRoaXMgYWZ0ZXIgdXBkYXRlTGF5ZXJDb25maWcgY29udmVydGVkIGludG8gZ2VuZXJpYyBmdW5jdGlvblxuICAgICAgICBjb2xvckZpZWxkOiBkZWZhdWx0Q29sb3JGaWVsZFxuICAgICAgfSk7XG4gICAgICB0aGlzLnVwZGF0ZUxheWVyVmlzdWFsQ2hhbm5lbChkYXRhc2V0LCAnY29sb3InKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHN0YXRpYyBmaW5kRGVmYXVsdExheWVyUHJvcHMoe2ZpZWxkUGFpcnMgPSBbXX06IEtlcGxlclRhYmxlKSB7XG4gICAgY29uc3QgcHJvcHM6IHtcbiAgICAgIGxhYmVsOiBzdHJpbmc7XG4gICAgICBjb2xvcj86IFJHQkNvbG9yO1xuICAgICAgaXNWaXNpYmxlPzogYm9vbGVhbjtcbiAgICAgIGNvbHVtbnM/OiBQb2ludExheWVyQ29sdW1uc0NvbmZpZztcbiAgICB9W10gPSBbXTtcblxuICAgIC8vIE1ha2UgbGF5ZXIgZm9yIGVhY2ggcGFpclxuICAgIGZpZWxkUGFpcnMuZm9yRWFjaChwYWlyID0+IHtcbiAgICAgIGNvbnN0IGxhdEZpZWxkID0gcGFpci5wYWlyLmxhdDtcblxuICAgICAgY29uc3QgcHJvcDoge1xuICAgICAgICBsYWJlbDogc3RyaW5nO1xuICAgICAgICBjb2xvcj86IFJHQkNvbG9yO1xuICAgICAgICBpc1Zpc2libGU/OiBib29sZWFuO1xuICAgICAgICBjb2x1bW5zPzogUG9pbnRMYXllckNvbHVtbnNDb25maWc7XG4gICAgICB9ID0ge1xuICAgICAgICBsYWJlbDogcGFpci5kZWZhdWx0TmFtZSB8fCAnUG9pbnQnXG4gICAgICB9O1xuXG4gICAgICAvLyBkZWZhdWx0IGxheWVyIGNvbG9yIGZvciBiZWdpbnRyaXAgYW5kIGRyb3BvZmYgcG9pbnRcbiAgICAgIGlmIChsYXRGaWVsZC52YWx1ZSBpbiBERUZBVUxUX0xBWUVSX0NPTE9SKSB7XG4gICAgICAgIHByb3AuY29sb3IgPSBoZXhUb1JnYihERUZBVUxUX0xBWUVSX0NPTE9SW2xhdEZpZWxkLnZhbHVlXSk7XG4gICAgICB9XG5cbiAgICAgIC8vIHNldCB0aGUgZmlyc3QgbGF5ZXIgdG8gYmUgdmlzaWJsZVxuICAgICAgaWYgKHByb3BzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBwcm9wLmlzVmlzaWJsZSA9IHRydWU7XG4gICAgICB9XG4gICAgICBwcm9wLmNvbHVtbnMgPSBhc3NpZ25Qb2ludFBhaXJUb0xheWVyQ29sdW1uKHBhaXIsIHRydWUpO1xuXG4gICAgICBwcm9wcy5wdXNoKHByb3ApO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHtwcm9wc307XG4gIH1cblxuICBnZXREZWZhdWx0TGF5ZXJDb25maWcocHJvcHMgPSB7fSkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5zdXBlci5nZXREZWZhdWx0TGF5ZXJDb25maWcocHJvcHMpLFxuXG4gICAgICAvLyBhZGQgc3Ryb2tlIGNvbG9yIHZpc3VhbCBjaGFubmVsXG4gICAgICBzdHJva2VDb2xvckZpZWxkOiBudWxsLFxuICAgICAgc3Ryb2tlQ29sb3JEb21haW46IFswLCAxXSxcbiAgICAgIHN0cm9rZUNvbG9yU2NhbGU6ICdxdWFudGlsZSdcbiAgICB9O1xuICB9XG5cbiAgY2FsY3VsYXRlRGF0YUF0dHJpYnV0ZSh7ZmlsdGVyZWRJbmRleH06IEtlcGxlclRhYmxlLCBnZXRQb3NpdGlvbikge1xuICAgIGNvbnN0IGRhdGE6IFBvaW50TGF5ZXJEYXRhW10gPSBbXTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmlsdGVyZWRJbmRleC5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgaW5kZXggPSBmaWx0ZXJlZEluZGV4W2ldO1xuICAgICAgY29uc3QgcG9zID0gZ2V0UG9zaXRpb24oe2luZGV4fSk7XG5cbiAgICAgIC8vIGlmIGRvZXNuJ3QgaGF2ZSBwb2ludCBsYXQgb3IgbG5nLCBkbyBub3QgYWRkIHRoZSBwb2ludFxuICAgICAgLy8gZGVjay5nbCBjYW4ndCBoYW5kbGUgcG9zaXRpb24gPSBudWxsXG4gICAgICBpZiAocG9zLmV2ZXJ5KE51bWJlci5pc0Zpbml0ZSkpIHtcbiAgICAgICAgZGF0YS5wdXNoKHtcbiAgICAgICAgICBwb3NpdGlvbjogcG9zLFxuICAgICAgICAgIGluZGV4XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIGZvcm1hdExheWVyRGF0YShkYXRhc2V0cywgb2xkTGF5ZXJEYXRhKSB7XG4gICAgaWYgKHRoaXMuY29uZmlnLmRhdGFJZCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICBjb25zdCB7dGV4dExhYmVsfSA9IHRoaXMuY29uZmlnO1xuICAgIGNvbnN0IHtncHVGaWx0ZXIsIGRhdGFDb250YWluZXJ9ID0gZGF0YXNldHNbdGhpcy5jb25maWcuZGF0YUlkXTtcbiAgICBjb25zdCB7ZGF0YSwgdHJpZ2dlckNoYW5nZWR9ID0gdGhpcy51cGRhdGVEYXRhKGRhdGFzZXRzLCBvbGRMYXllckRhdGEpO1xuICAgIGNvbnN0IGdldFBvc2l0aW9uID0gdGhpcy5nZXRQb3NpdGlvbkFjY2Vzc29yKGRhdGFDb250YWluZXIpO1xuXG4gICAgLy8gZ2V0IGFsbCBkaXN0aW5jdCBjaGFyYWN0ZXJzIGluIHRoZSB0ZXh0IGxhYmVsc1xuICAgIGNvbnN0IHRleHRMYWJlbHMgPSBmb3JtYXRUZXh0TGFiZWxEYXRhKHtcbiAgICAgIHRleHRMYWJlbCxcbiAgICAgIHRyaWdnZXJDaGFuZ2VkLFxuICAgICAgb2xkTGF5ZXJEYXRhLFxuICAgICAgZGF0YSxcbiAgICAgIGRhdGFDb250YWluZXJcbiAgICB9KTtcblxuICAgIGNvbnN0IGFjY2Vzc29ycyA9IHRoaXMuZ2V0QXR0cmlidXRlQWNjZXNzb3JzKHtkYXRhQ29udGFpbmVyfSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgZGF0YSxcbiAgICAgIGdldFBvc2l0aW9uLFxuICAgICAgZ2V0RmlsdGVyVmFsdWU6IGdwdUZpbHRlci5maWx0ZXJWYWx1ZUFjY2Vzc29yKGRhdGFDb250YWluZXIpKCksXG4gICAgICB0ZXh0TGFiZWxzLFxuICAgICAgLi4uYWNjZXNzb3JzXG4gICAgfTtcbiAgfVxuICAvKiBlc2xpbnQtZW5hYmxlIGNvbXBsZXhpdHkgKi9cblxuICB1cGRhdGVMYXllck1ldGEoZGF0YUNvbnRhaW5lcikge1xuICAgIGNvbnN0IGdldFBvc2l0aW9uID0gdGhpcy5nZXRQb3NpdGlvbkFjY2Vzc29yKGRhdGFDb250YWluZXIpO1xuICAgIGNvbnN0IGJvdW5kcyA9IHRoaXMuZ2V0UG9pbnRzQm91bmRzKGRhdGFDb250YWluZXIsIGdldFBvc2l0aW9uKTtcbiAgICB0aGlzLnVwZGF0ZU1ldGEoe2JvdW5kc30pO1xuICB9XG5cbiAgcmVuZGVyTGF5ZXIob3B0cykge1xuICAgIGNvbnN0IHtkYXRhLCBncHVGaWx0ZXIsIG9iamVjdEhvdmVyZWQsIG1hcFN0YXRlLCBpbnRlcmFjdGlvbkNvbmZpZ30gPSBvcHRzO1xuXG4gICAgLy8gaWYgbm8gZmllbGQgc2l6ZSBpcyBkZWZpbmVkIHdlIG5lZWQgdG8gcGFzcyBmaXhlZCByYWRpdXMgPSBmYWxzZVxuICAgIGNvbnN0IGZpeGVkUmFkaXVzID0gdGhpcy5jb25maWcudmlzQ29uZmlnLmZpeGVkUmFkaXVzICYmIEJvb2xlYW4odGhpcy5jb25maWcuc2l6ZUZpZWxkKTtcbiAgICBjb25zdCByYWRpdXNTY2FsZSA9IHRoaXMuZ2V0UmFkaXVzU2NhbGVCeVpvb20obWFwU3RhdGUsIGZpeGVkUmFkaXVzKTtcblxuICAgIGNvbnN0IGxheWVyUHJvcHMgPSB7XG4gICAgICBzdHJva2VkOiB0aGlzLmNvbmZpZy52aXNDb25maWcub3V0bGluZSxcbiAgICAgIGZpbGxlZDogdGhpcy5jb25maWcudmlzQ29uZmlnLmZpbGxlZCxcbiAgICAgIGxpbmVXaWR0aFNjYWxlOiB0aGlzLmNvbmZpZy52aXNDb25maWcudGhpY2tuZXNzLFxuICAgICAgcmFkaXVzU2NhbGUsXG4gICAgICAuLi4odGhpcy5jb25maWcudmlzQ29uZmlnLmZpeGVkUmFkaXVzID8ge30gOiB7cmFkaXVzTWF4UGl4ZWxzOiA1MDB9KVxuICAgIH07XG5cbiAgICBjb25zdCB1cGRhdGVUcmlnZ2VycyA9IHtcbiAgICAgIGdldFBvc2l0aW9uOiB0aGlzLmNvbmZpZy5jb2x1bW5zLFxuICAgICAgZ2V0RmlsdGVyVmFsdWU6IGdwdUZpbHRlci5maWx0ZXJWYWx1ZVVwZGF0ZVRyaWdnZXJzLFxuICAgICAgLi4udGhpcy5nZXRWaXN1YWxDaGFubmVsVXBkYXRlVHJpZ2dlcnMoKVxuICAgIH07XG5cbiAgICBjb25zdCBkZWZhdWx0TGF5ZXJQcm9wcyA9IHRoaXMuZ2V0RGVmYXVsdERlY2tMYXllclByb3BzKG9wdHMpO1xuICAgIGNvbnN0IGJydXNoaW5nUHJvcHMgPSB0aGlzLmdldEJydXNoaW5nRXh0ZW5zaW9uUHJvcHMoaW50ZXJhY3Rpb25Db25maWcpO1xuICAgIGNvbnN0IGdldFBpeGVsT2Zmc2V0ID0gZ2V0VGV4dE9mZnNldEJ5UmFkaXVzKHJhZGl1c1NjYWxlLCBkYXRhLmdldFJhZGl1cywgbWFwU3RhdGUpO1xuICAgIGNvbnN0IGV4dGVuc2lvbnMgPSBbLi4uZGVmYXVsdExheWVyUHJvcHMuZXh0ZW5zaW9ucywgYnJ1c2hpbmdFeHRlbnNpb25dO1xuXG4gICAgY29uc3Qgc2hhcmVkUHJvcHMgPSB7XG4gICAgICBnZXRGaWx0ZXJWYWx1ZTogZGF0YS5nZXRGaWx0ZXJWYWx1ZSxcbiAgICAgIGV4dGVuc2lvbnMsXG4gICAgICBmaWx0ZXJSYW5nZTogZGVmYXVsdExheWVyUHJvcHMuZmlsdGVyUmFuZ2UsXG4gICAgICB2aXNpYmxlOiBkZWZhdWx0TGF5ZXJQcm9wcy52aXNpYmxlLFxuICAgICAgLi4uYnJ1c2hpbmdQcm9wc1xuICAgIH07XG4gICAgY29uc3QgaG92ZXJlZE9iamVjdCA9IHRoaXMuaGFzSG92ZXJlZE9iamVjdChvYmplY3RIb3ZlcmVkKTtcblxuICAgIHJldHVybiBbXG4gICAgICBuZXcgU2NhdHRlcnBsb3RMYXllcih7XG4gICAgICAgIC4uLmRlZmF1bHRMYXllclByb3BzLFxuICAgICAgICAuLi5icnVzaGluZ1Byb3BzLFxuICAgICAgICAuLi5sYXllclByb3BzLFxuICAgICAgICAuLi5kYXRhLFxuICAgICAgICBwYXJhbWV0ZXJzOiB7XG4gICAgICAgICAgLy8gY2lyY2xlcyB3aWxsIGJlIGZsYXQgb24gdGhlIG1hcCB3aGVuIHRoZSBhbHRpdHVkZSBjb2x1bW4gaXMgbm90IHVzZWRcbiAgICAgICAgICBkZXB0aFRlc3Q6ICh0aGlzLmNvbmZpZy5jb2x1bW5zLmFsdGl0dWRlPy5maWVsZElkeCBhcyBudW1iZXIpID4gLTFcbiAgICAgICAgfSxcbiAgICAgICAgbGluZVdpZHRoVW5pdHM6ICdwaXhlbHMnLFxuICAgICAgICB1cGRhdGVUcmlnZ2VycyxcbiAgICAgICAgZXh0ZW5zaW9uc1xuICAgICAgfSksXG4gICAgICAvLyBob3ZlciBsYXllclxuICAgICAgLi4uKGhvdmVyZWRPYmplY3RcbiAgICAgICAgPyBbXG4gICAgICAgICAgICBuZXcgU2NhdHRlcnBsb3RMYXllcih7XG4gICAgICAgICAgICAgIC4uLnRoaXMuZ2V0RGVmYXVsdEhvdmVyTGF5ZXJQcm9wcygpLFxuICAgICAgICAgICAgICAuLi5sYXllclByb3BzLFxuICAgICAgICAgICAgICBkYXRhOiBbaG92ZXJlZE9iamVjdF0sXG4gICAgICAgICAgICAgIGdldExpbmVDb2xvcjogdGhpcy5jb25maWcuaGlnaGxpZ2h0Q29sb3IsXG4gICAgICAgICAgICAgIGdldEZpbGxDb2xvcjogdGhpcy5jb25maWcuaGlnaGxpZ2h0Q29sb3IsXG4gICAgICAgICAgICAgIGdldFJhZGl1czogZGF0YS5nZXRSYWRpdXMsXG4gICAgICAgICAgICAgIGdldFBvc2l0aW9uOiBkYXRhLmdldFBvc2l0aW9uXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIF1cbiAgICAgICAgOiBbXSksXG4gICAgICAvLyB0ZXh0IGxhYmVsIGxheWVyXG4gICAgICAuLi50aGlzLnJlbmRlclRleHRMYWJlbExheWVyKFxuICAgICAgICB7XG4gICAgICAgICAgZ2V0UG9zaXRpb246IGRhdGEuZ2V0UG9zaXRpb24sXG4gICAgICAgICAgc2hhcmVkUHJvcHMsXG4gICAgICAgICAgZ2V0UGl4ZWxPZmZzZXQsXG4gICAgICAgICAgdXBkYXRlVHJpZ2dlcnNcbiAgICAgICAgfSxcbiAgICAgICAgb3B0c1xuICAgICAgKVxuICAgIF07XG4gIH1cbn1cbiJdfQ==