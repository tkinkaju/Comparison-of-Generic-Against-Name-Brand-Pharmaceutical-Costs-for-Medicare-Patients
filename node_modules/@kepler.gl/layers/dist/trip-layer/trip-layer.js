// Copyright (c) 2022 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = exports.featureResolver = exports.featureAccessor = exports.geoJsonRequiredColumns = exports.tripVisConfigs = exports.defaultLineWidth = exports.defaultThickness = void 0;

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _lodash = _interopRequireDefault(require("lodash.memoize"));

var _lodash2 = _interopRequireDefault(require("lodash.uniq"));

var _baseLayer = _interopRequireDefault(require("../base-layer"));

var _geoLayers = require("@deck.gl/geo-layers");

var _constants = require("@kepler.gl/constants");

var _tripLayerIcon = _interopRequireDefault(require("./trip-layer-icon"));

var _geojsonUtils = require("../geojson-layer/geojson-utils");

var _tripUtils = require("./trip-utils");

var _tripInfoModal = _interopRequireDefault(require("./trip-info-modal"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var zoomFactorValue = 8;
var defaultThickness = 0.5;
exports.defaultThickness = defaultThickness;
var defaultLineWidth = 1;
exports.defaultLineWidth = defaultLineWidth;
var tripVisConfigs = {
  opacity: 'opacity',
  thickness: {
    type: 'number',
    defaultValue: defaultThickness,
    label: 'Stroke Width',
    isRanged: false,
    range: [0, 100],
    step: 0.1,
    group: 'stroke',
    property: 'thickness'
  },
  colorRange: 'colorRange',
  trailLength: 'trailLength',
  sizeRange: 'strokeWidthRange'
};
exports.tripVisConfigs = tripVisConfigs;
var geoJsonRequiredColumns = ['geojson'];
exports.geoJsonRequiredColumns = geoJsonRequiredColumns;

var featureAccessor = function featureAccessor(_ref) {
  var geojson = _ref.geojson;
  return function (dc) {
    return function (d) {
      return dc.valueAt(d.index, geojson.fieldIdx);
    };
  };
};

exports.featureAccessor = featureAccessor;

var featureResolver = function featureResolver(_ref2) {
  var geojson = _ref2.geojson;
  return geojson.fieldIdx;
};

exports.featureResolver = featureResolver;

var TripLayer = /*#__PURE__*/function (_Layer) {
  (0, _inherits2["default"])(TripLayer, _Layer);

  var _super = _createSuper(TripLayer);

  function TripLayer(props) {
    var _this;

    (0, _classCallCheck2["default"])(this, TripLayer);
    _this = _super.call(this, props);
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "dataToFeature", void 0);
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "dataToTimeStamp", void 0);
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "getFeature", void 0);
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_layerInfoModal", void 0);
    _this.dataToFeature = [];
    _this.dataToTimeStamp = [];

    _this.registerVisConfig(tripVisConfigs);

    _this.getFeature = (0, _lodash["default"])(featureAccessor, featureResolver);
    _this._layerInfoModal = (0, _tripInfoModal["default"])();
    return _this;
  }

  (0, _createClass2["default"])(TripLayer, [{
    key: "type",
    get: function get() {
      return TripLayer.type;
    }
  }, {
    key: "name",
    get: function get() {
      return 'Trip';
    }
  }, {
    key: "layerIcon",
    get: function get() {
      return _tripLayerIcon["default"];
    }
  }, {
    key: "columnPairs",
    get: function get() {
      return this.defaultPointColumnPairs;
    }
  }, {
    key: "requiredLayerColumns",
    get: function get() {
      return geoJsonRequiredColumns;
    }
  }, {
    key: "visualChannels",
    get: function get() {
      var visualChannels = (0, _get2["default"])((0, _getPrototypeOf2["default"])(TripLayer.prototype), "visualChannels", this);
      return _objectSpread(_objectSpread({}, visualChannels), {}, {
        color: _objectSpread(_objectSpread({}, visualChannels.color), {}, {
          accessor: 'getColor',
          nullValue: visualChannels.color.nullValue,
          getAttributeValue: function getAttributeValue(config) {
            return function (d) {
              return d.properties.lineColor || config.color;
            };
          },
          // used this to get updateTriggers
          defaultValue: function defaultValue(config) {
            return config.color;
          }
        }),
        size: _objectSpread(_objectSpread({}, visualChannels.size), {}, {
          property: 'stroke',
          accessor: 'getWidth',
          condition: function condition(config) {
            return config.visConfig.stroked;
          },
          nullValue: 0,
          getAttributeValue: function getAttributeValue() {
            return function (d) {
              return d.properties.lineWidth || defaultLineWidth;
            };
          }
        })
      });
    }
  }, {
    key: "animationDomain",
    get: function get() {
      return this.config.animation.domain;
    }
  }, {
    key: "layerInfoModal",
    get: function get() {
      return {
        id: 'iconInfo',
        template: this._layerInfoModal,
        modalProps: {
          title: 'modal.tripInfo.title'
        }
      };
    }
  }, {
    key: "getPositionAccessor",
    value: function getPositionAccessor(dataContainer) {
      return this.getFeature(this.config.columns)(dataContainer);
    }
  }, {
    key: "getDefaultLayerConfig",
    value: function getDefaultLayerConfig(props) {
      return _objectSpread(_objectSpread({}, (0, _get2["default"])((0, _getPrototypeOf2["default"])(TripLayer.prototype), "getDefaultLayerConfig", this).call(this, props)), {}, {
        animation: {
          enabled: true,
          domain: null
        }
      });
    }
  }, {
    key: "getHoverData",
    value: function getHoverData(object, dataContainer) {
      // index for dataContainer is saved to feature.properties
      return dataContainer.row(object.properties.index);
    }
  }, {
    key: "calculateDataAttribute",
    value: function calculateDataAttribute(_ref3, getPosition) {
      var _this2 = this;

      var dataContainer = _ref3.dataContainer,
          filteredIndex = _ref3.filteredIndex;
      return filteredIndex.map(function (i) {
        return _this2.dataToFeature[i];
      }).filter(function (d) {
        return d && d.geometry.type === 'LineString';
      });
    }
  }, {
    key: "formatLayerData",
    value: function formatLayerData(datasets, oldLayerData) {
      var _this3 = this;

      if (this.config.dataId === null) {
        return {};
      } // to-do: parse segment from dataContainer


      var _datasets$this$config = datasets[this.config.dataId],
          dataContainer = _datasets$this$config.dataContainer,
          gpuFilter = _datasets$this$config.gpuFilter;

      var _this$updateData = this.updateData(datasets, oldLayerData),
          data = _this$updateData.data;

      var customFilterValueAccessor = function customFilterValueAccessor(dc, f, fieldIndex) {
        return dc.valueAt(f.properties.index, fieldIndex);
      };

      var indexAccessor = function indexAccessor(f) {
        return f.properties.index;
      };

      var dataAccessor = function dataAccessor(dc) {
        return function (d) {
          return {
            index: d.properties.index
          };
        };
      };

      var accessors = this.getAttributeAccessors({
        dataAccessor: dataAccessor,
        dataContainer: dataContainer
      });
      return _objectSpread({
        data: data,
        getFilterValue: gpuFilter.filterValueAccessor(dataContainer)(indexAccessor, customFilterValueAccessor),
        getPath: function getPath(d) {
          return d.geometry.coordinates;
        },
        getTimestamps: function getTimestamps(d) {
          return _this3.dataToTimeStamp[d.properties.index];
        }
      }, accessors);
    }
  }, {
    key: "updateAnimationDomain",
    value: function updateAnimationDomain(domain) {
      this.updateLayerConfig({
        animation: _objectSpread(_objectSpread({}, this.config.animation), {}, {
          domain: domain
        })
      });
    }
  }, {
    key: "updateLayerMeta",
    value: function updateLayerMeta(dataContainer) {
      var getFeature = this.getPositionAccessor(dataContainer);

      if (getFeature === this.meta.getFeature) {
        // TODO: revisit this after gpu filtering
        return;
      }

      this.dataToFeature = (0, _geojsonUtils.getGeojsonDataMaps)(dataContainer, getFeature);

      var _parseTripGeoJsonTime = (0, _tripUtils.parseTripGeoJsonTimestamp)(this.dataToFeature),
          dataToTimeStamp = _parseTripGeoJsonTime.dataToTimeStamp,
          animationDomain = _parseTripGeoJsonTime.animationDomain;

      this.dataToTimeStamp = dataToTimeStamp;
      this.updateAnimationDomain(animationDomain); // get bounds from features

      var bounds = (0, _geojsonUtils.getGeojsonBounds)(this.dataToFeature); // keep a record of what type of geometry the collection has

      var featureTypes = (0, _geojsonUtils.getGeojsonFeatureTypes)(this.dataToFeature);
      this.updateMeta({
        bounds: bounds,
        featureTypes: featureTypes,
        getFeature: getFeature
      });
    }
  }, {
    key: "setInitialLayerConfig",
    value: function setInitialLayerConfig(_ref4) {
      var dataContainer = _ref4.dataContainer;

      if (!dataContainer.numRows()) {
        return this;
      }

      this.updateLayerMeta(dataContainer);
      return this;
    }
  }, {
    key: "renderLayer",
    value: function renderLayer(opts) {
      var _animationConfig$doma;

      var data = opts.data,
          gpuFilter = opts.gpuFilter,
          mapState = opts.mapState,
          animationConfig = opts.animationConfig;
      var visConfig = this.config.visConfig;
      var zoomFactor = this.getZoomFactor(mapState);
      var isValidTime = animationConfig && Array.isArray(animationConfig.domain) && animationConfig.domain.every(Number.isFinite) && Number.isFinite(animationConfig.currentTime);

      if (!isValidTime) {
        return [];
      }

      var domain0 = (_animationConfig$doma = animationConfig.domain) === null || _animationConfig$doma === void 0 ? void 0 : _animationConfig$doma[0];

      var updateTriggers = _objectSpread(_objectSpread({}, this.getVisualChannelUpdateTriggers()), {}, {
        getTimestamps: {
          columns: this.config.columns,
          domain0: domain0
        },
        getFilterValue: gpuFilter.filterValueUpdateTriggers
      });

      var defaultLayerProps = this.getDefaultDeckLayerProps(opts);
      return [new _geoLayers.TripsLayer(_objectSpread(_objectSpread(_objectSpread({}, defaultLayerProps), data), {}, {
        getTimestamps: function getTimestamps(d) {
          return (data.getTimestamps(d) || []).map(function (ts) {
            return ts - domain0;
          });
        },
        widthScale: this.config.visConfig.thickness * zoomFactor * zoomFactorValue,
        capRounded: true,
        jointRounded: true,
        wrapLongitude: false,
        parameters: {
          depthTest: mapState.dragRotate,
          depthMask: false
        },
        trailLength: visConfig.trailLength * 1000,
        currentTime: animationConfig.currentTime - domain0,
        updateTriggers: updateTriggers
      }))];
    }
  }], [{
    key: "type",
    get: function get() {
      return 'trip';
    }
  }, {
    key: "findDefaultLayerProps",
    value: function findDefaultLayerProps(_ref5, foundLayers) {
      var _this4 = this;

      var label = _ref5.label,
          _ref5$fields = _ref5.fields,
          fields = _ref5$fields === void 0 ? [] : _ref5$fields,
          dataContainer = _ref5.dataContainer,
          id = _ref5.id;
      var geojsonColumns = fields.filter(function (f) {
        return f.type === 'geojson';
      }).map(function (f) {
        return f.name;
      });
      var defaultColumns = {
        geojson: (0, _lodash2["default"])([].concat((0, _toConsumableArray2["default"])(_constants.GEOJSON_FIELDS.geojson), (0, _toConsumableArray2["default"])(geojsonColumns)))
      };
      var geoJsonColumns = this.findDefaultColumnField(defaultColumns, fields);
      var tripGeojsonColumns = (geoJsonColumns || []).filter(function (col) {
        return (0, _tripUtils.isTripGeoJsonField)(dataContainer, fields[col.geojson.fieldIdx]);
      });

      if (tripGeojsonColumns.length) {
        return {
          props: tripGeojsonColumns.map(function (columns) {
            return {
              label: typeof label === 'string' && label.replace(/\.[^/.]+$/, '') || _this4.type,
              columns: columns,
              isVisible: true
            };
          }),
          // if a geojson layer is created from this column, delete it
          foundLayers: foundLayers.filter(function (prop) {
            return prop.type !== 'geojson' || prop.dataId !== id || !tripGeojsonColumns.find(function (c) {
              return prop.columns.geojson.name === c.geojson.name;
            });
          })
        };
      }

      return {
        props: []
      };
    }
  }]);
  return TripLayer;
}(_baseLayer["default"]);

exports["default"] = TripLayer;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy90cmlwLWxheWVyL3RyaXAtbGF5ZXIudHMiXSwibmFtZXMiOlsiem9vbUZhY3RvclZhbHVlIiwiZGVmYXVsdFRoaWNrbmVzcyIsImRlZmF1bHRMaW5lV2lkdGgiLCJ0cmlwVmlzQ29uZmlncyIsIm9wYWNpdHkiLCJ0aGlja25lc3MiLCJ0eXBlIiwiZGVmYXVsdFZhbHVlIiwibGFiZWwiLCJpc1JhbmdlZCIsInJhbmdlIiwic3RlcCIsImdyb3VwIiwicHJvcGVydHkiLCJjb2xvclJhbmdlIiwidHJhaWxMZW5ndGgiLCJzaXplUmFuZ2UiLCJnZW9Kc29uUmVxdWlyZWRDb2x1bW5zIiwiZmVhdHVyZUFjY2Vzc29yIiwiZ2VvanNvbiIsImRjIiwiZCIsInZhbHVlQXQiLCJpbmRleCIsImZpZWxkSWR4IiwiZmVhdHVyZVJlc29sdmVyIiwiVHJpcExheWVyIiwicHJvcHMiLCJkYXRhVG9GZWF0dXJlIiwiZGF0YVRvVGltZVN0YW1wIiwicmVnaXN0ZXJWaXNDb25maWciLCJnZXRGZWF0dXJlIiwiX2xheWVySW5mb01vZGFsIiwiVHJpcExheWVySWNvbiIsImRlZmF1bHRQb2ludENvbHVtblBhaXJzIiwidmlzdWFsQ2hhbm5lbHMiLCJjb2xvciIsImFjY2Vzc29yIiwibnVsbFZhbHVlIiwiZ2V0QXR0cmlidXRlVmFsdWUiLCJjb25maWciLCJwcm9wZXJ0aWVzIiwibGluZUNvbG9yIiwic2l6ZSIsImNvbmRpdGlvbiIsInZpc0NvbmZpZyIsInN0cm9rZWQiLCJsaW5lV2lkdGgiLCJhbmltYXRpb24iLCJkb21haW4iLCJpZCIsInRlbXBsYXRlIiwibW9kYWxQcm9wcyIsInRpdGxlIiwiZGF0YUNvbnRhaW5lciIsImNvbHVtbnMiLCJlbmFibGVkIiwib2JqZWN0Iiwicm93IiwiZ2V0UG9zaXRpb24iLCJmaWx0ZXJlZEluZGV4IiwibWFwIiwiaSIsImZpbHRlciIsImdlb21ldHJ5IiwiZGF0YXNldHMiLCJvbGRMYXllckRhdGEiLCJkYXRhSWQiLCJncHVGaWx0ZXIiLCJ1cGRhdGVEYXRhIiwiZGF0YSIsImN1c3RvbUZpbHRlclZhbHVlQWNjZXNzb3IiLCJmIiwiZmllbGRJbmRleCIsImluZGV4QWNjZXNzb3IiLCJkYXRhQWNjZXNzb3IiLCJhY2Nlc3NvcnMiLCJnZXRBdHRyaWJ1dGVBY2Nlc3NvcnMiLCJnZXRGaWx0ZXJWYWx1ZSIsImZpbHRlclZhbHVlQWNjZXNzb3IiLCJnZXRQYXRoIiwiY29vcmRpbmF0ZXMiLCJnZXRUaW1lc3RhbXBzIiwidXBkYXRlTGF5ZXJDb25maWciLCJnZXRQb3NpdGlvbkFjY2Vzc29yIiwibWV0YSIsImFuaW1hdGlvbkRvbWFpbiIsInVwZGF0ZUFuaW1hdGlvbkRvbWFpbiIsImJvdW5kcyIsImZlYXR1cmVUeXBlcyIsInVwZGF0ZU1ldGEiLCJudW1Sb3dzIiwidXBkYXRlTGF5ZXJNZXRhIiwib3B0cyIsIm1hcFN0YXRlIiwiYW5pbWF0aW9uQ29uZmlnIiwiem9vbUZhY3RvciIsImdldFpvb21GYWN0b3IiLCJpc1ZhbGlkVGltZSIsIkFycmF5IiwiaXNBcnJheSIsImV2ZXJ5IiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJjdXJyZW50VGltZSIsImRvbWFpbjAiLCJ1cGRhdGVUcmlnZ2VycyIsImdldFZpc3VhbENoYW5uZWxVcGRhdGVUcmlnZ2VycyIsImZpbHRlclZhbHVlVXBkYXRlVHJpZ2dlcnMiLCJkZWZhdWx0TGF5ZXJQcm9wcyIsImdldERlZmF1bHREZWNrTGF5ZXJQcm9wcyIsIkRlY2tHTFRyaXBzTGF5ZXIiLCJ0cyIsIndpZHRoU2NhbGUiLCJjYXBSb3VuZGVkIiwiam9pbnRSb3VuZGVkIiwid3JhcExvbmdpdHVkZSIsInBhcmFtZXRlcnMiLCJkZXB0aFRlc3QiLCJkcmFnUm90YXRlIiwiZGVwdGhNYXNrIiwiZm91bmRMYXllcnMiLCJmaWVsZHMiLCJnZW9qc29uQ29sdW1ucyIsIm5hbWUiLCJkZWZhdWx0Q29sdW1ucyIsIkdFT0pTT05fRklFTERTIiwiZ2VvSnNvbkNvbHVtbnMiLCJmaW5kRGVmYXVsdENvbHVtbkZpZWxkIiwidHJpcEdlb2pzb25Db2x1bW5zIiwiY29sIiwibGVuZ3RoIiwicmVwbGFjZSIsImlzVmlzaWJsZSIsInByb3AiLCJmaW5kIiwiYyIsIkxheWVyIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFvQkE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBRUE7O0FBQ0E7O0FBRUE7O0FBT0E7O0FBQ0E7Ozs7Ozs7Ozs7QUFrQ0EsSUFBTUEsZUFBZSxHQUFHLENBQXhCO0FBRU8sSUFBTUMsZ0JBQWdCLEdBQUcsR0FBekI7O0FBQ0EsSUFBTUMsZ0JBQWdCLEdBQUcsQ0FBekI7O0FBRUEsSUFBTUMsY0FNWixHQUFHO0FBQ0ZDLEVBQUFBLE9BQU8sRUFBRSxTQURQO0FBRUZDLEVBQUFBLFNBQVMsRUFBRTtBQUNUQyxJQUFBQSxJQUFJLEVBQUUsUUFERztBQUVUQyxJQUFBQSxZQUFZLEVBQUVOLGdCQUZMO0FBR1RPLElBQUFBLEtBQUssRUFBRSxjQUhFO0FBSVRDLElBQUFBLFFBQVEsRUFBRSxLQUpEO0FBS1RDLElBQUFBLEtBQUssRUFBRSxDQUFDLENBQUQsRUFBSSxHQUFKLENBTEU7QUFNVEMsSUFBQUEsSUFBSSxFQUFFLEdBTkc7QUFPVEMsSUFBQUEsS0FBSyxFQUFFLFFBUEU7QUFRVEMsSUFBQUEsUUFBUSxFQUFFO0FBUkQsR0FGVDtBQVlGQyxFQUFBQSxVQUFVLEVBQUUsWUFaVjtBQWFGQyxFQUFBQSxXQUFXLEVBQUUsYUFiWDtBQWNGQyxFQUFBQSxTQUFTLEVBQUU7QUFkVCxDQU5HOztBQXVCQSxJQUFNQyxzQkFBbUMsR0FBRyxDQUFDLFNBQUQsQ0FBNUM7OztBQUNBLElBQU1DLGVBQWUsR0FBRyxTQUFsQkEsZUFBa0I7QUFBQSxNQUFFQyxPQUFGLFFBQUVBLE9BQUY7QUFBQSxTQUF1QyxVQUNwRUMsRUFEb0U7QUFBQSxXQUVqRSxVQUFBQyxDQUFDO0FBQUEsYUFBSUQsRUFBRSxDQUFDRSxPQUFILENBQVdELENBQUMsQ0FBQ0UsS0FBYixFQUFvQkosT0FBTyxDQUFDSyxRQUE1QixDQUFKO0FBQUEsS0FGZ0U7QUFBQSxHQUF2QztBQUFBLENBQXhCOzs7O0FBR0EsSUFBTUMsZUFBZSxHQUFHLFNBQWxCQSxlQUFrQjtBQUFBLE1BQUVOLE9BQUYsU0FBRUEsT0FBRjtBQUFBLFNBQXVDQSxPQUFPLENBQUNLLFFBQS9DO0FBQUEsQ0FBeEI7Ozs7SUFFY0UsUzs7Ozs7QUFVbkIscUJBQVlDLEtBQVosRUFBbUI7QUFBQTs7QUFBQTtBQUNqQiw4QkFBTUEsS0FBTjtBQURpQjtBQUFBO0FBQUE7QUFBQTtBQUdqQixVQUFLQyxhQUFMLEdBQXFCLEVBQXJCO0FBQ0EsVUFBS0MsZUFBTCxHQUF1QixFQUF2Qjs7QUFDQSxVQUFLQyxpQkFBTCxDQUF1QjNCLGNBQXZCOztBQUNBLFVBQUs0QixVQUFMLEdBQWtCLHdCQUFRYixlQUFSLEVBQXlCTyxlQUF6QixDQUFsQjtBQUNBLFVBQUtPLGVBQUwsR0FBdUIsZ0NBQXZCO0FBUGlCO0FBUWxCOzs7O1NBS0QsZUFBVztBQUNULGFBQU9OLFNBQVMsQ0FBQ3BCLElBQWpCO0FBQ0Q7OztTQUVELGVBQW1CO0FBQ2pCLGFBQU8sTUFBUDtBQUNEOzs7U0FFRCxlQUFnQjtBQUNkLGFBQU8yQix5QkFBUDtBQUNEOzs7U0FFRCxlQUFrQjtBQUNoQixhQUFPLEtBQUtDLHVCQUFaO0FBQ0Q7OztTQUVELGVBQTJCO0FBQ3pCLGFBQU9qQixzQkFBUDtBQUNEOzs7U0FFRCxlQUFxQjtBQUNuQixVQUFNa0IsY0FBYyx1R0FBcEI7QUFFQSw2Q0FDS0EsY0FETDtBQUVFQyxRQUFBQSxLQUFLLGtDQUNBRCxjQUFjLENBQUNDLEtBRGY7QUFFSEMsVUFBQUEsUUFBUSxFQUFFLFVBRlA7QUFHSEMsVUFBQUEsU0FBUyxFQUFFSCxjQUFjLENBQUNDLEtBQWYsQ0FBcUJFLFNBSDdCO0FBSUhDLFVBQUFBLGlCQUFpQixFQUFFLDJCQUFBQyxNQUFNO0FBQUEsbUJBQUksVUFBQW5CLENBQUM7QUFBQSxxQkFBSUEsQ0FBQyxDQUFDb0IsVUFBRixDQUFhQyxTQUFiLElBQTBCRixNQUFNLENBQUNKLEtBQXJDO0FBQUEsYUFBTDtBQUFBLFdBSnRCO0FBS0g7QUFDQTdCLFVBQUFBLFlBQVksRUFBRSxzQkFBQWlDLE1BQU07QUFBQSxtQkFBSUEsTUFBTSxDQUFDSixLQUFYO0FBQUE7QUFOakIsVUFGUDtBQVVFTyxRQUFBQSxJQUFJLGtDQUNDUixjQUFjLENBQUNRLElBRGhCO0FBRUY5QixVQUFBQSxRQUFRLEVBQUUsUUFGUjtBQUdGd0IsVUFBQUEsUUFBUSxFQUFFLFVBSFI7QUFJRk8sVUFBQUEsU0FBUyxFQUFFLG1CQUFBSixNQUFNO0FBQUEsbUJBQUlBLE1BQU0sQ0FBQ0ssU0FBUCxDQUFpQkMsT0FBckI7QUFBQSxXQUpmO0FBS0ZSLFVBQUFBLFNBQVMsRUFBRSxDQUxUO0FBTUZDLFVBQUFBLGlCQUFpQixFQUFFO0FBQUEsbUJBQU0sVUFBQWxCLENBQUM7QUFBQSxxQkFBSUEsQ0FBQyxDQUFDb0IsVUFBRixDQUFhTSxTQUFiLElBQTBCN0MsZ0JBQTlCO0FBQUEsYUFBUDtBQUFBO0FBTmpCO0FBVk47QUFtQkQ7OztTQUVELGVBQXNCO0FBQ3BCLGFBQU8sS0FBS3NDLE1BQUwsQ0FBWVEsU0FBWixDQUFzQkMsTUFBN0I7QUFDRDs7O1NBRUQsZUFBcUI7QUFDbkIsYUFBTztBQUNMQyxRQUFBQSxFQUFFLEVBQUUsVUFEQztBQUVMQyxRQUFBQSxRQUFRLEVBQUUsS0FBS25CLGVBRlY7QUFHTG9CLFFBQUFBLFVBQVUsRUFBRTtBQUNWQyxVQUFBQSxLQUFLLEVBQUU7QUFERztBQUhQLE9BQVA7QUFPRDs7O1dBRUQsNkJBQW9CQyxhQUFwQixFQUEyRDtBQUN6RCxhQUFPLEtBQUt2QixVQUFMLENBQWdCLEtBQUtTLE1BQUwsQ0FBWWUsT0FBNUIsRUFBcUNELGFBQXJDLENBQVA7QUFDRDs7O1dBdUNELCtCQUFzQjNCLEtBQXRCLEVBQTZCO0FBQzNCLG9LQUNpQ0EsS0FEakM7QUFFRXFCLFFBQUFBLFNBQVMsRUFBRTtBQUNUUSxVQUFBQSxPQUFPLEVBQUUsSUFEQTtBQUVUUCxVQUFBQSxNQUFNLEVBQUU7QUFGQztBQUZiO0FBT0Q7OztXQUVELHNCQUFhUSxNQUFiLEVBQXFCSCxhQUFyQixFQUFvQztBQUNsQztBQUNBLGFBQU9BLGFBQWEsQ0FBQ0ksR0FBZCxDQUFrQkQsTUFBTSxDQUFDaEIsVUFBUCxDQUFrQmxCLEtBQXBDLENBQVA7QUFDRDs7O1dBRUQsdUNBQXVEb0MsV0FBdkQsRUFBb0U7QUFBQTs7QUFBQSxVQUE1Q0wsYUFBNEMsU0FBNUNBLGFBQTRDO0FBQUEsVUFBN0JNLGFBQTZCLFNBQTdCQSxhQUE2QjtBQUNsRSxhQUFPQSxhQUFhLENBQ2pCQyxHQURJLENBQ0EsVUFBQUMsQ0FBQztBQUFBLGVBQUksTUFBSSxDQUFDbEMsYUFBTCxDQUFtQmtDLENBQW5CLENBQUo7QUFBQSxPQURELEVBRUpDLE1BRkksQ0FFRyxVQUFBMUMsQ0FBQztBQUFBLGVBQUlBLENBQUMsSUFBSUEsQ0FBQyxDQUFDMkMsUUFBRixDQUFXMUQsSUFBWCxLQUFvQixZQUE3QjtBQUFBLE9BRkosQ0FBUDtBQUdEOzs7V0FFRCx5QkFBZ0IyRCxRQUFoQixFQUEwQkMsWUFBMUIsRUFBd0M7QUFBQTs7QUFDdEMsVUFBSSxLQUFLMUIsTUFBTCxDQUFZMkIsTUFBWixLQUF1QixJQUEzQixFQUFpQztBQUMvQixlQUFPLEVBQVA7QUFDRCxPQUhxQyxDQUl0Qzs7O0FBSnNDLGtDQUtIRixRQUFRLENBQUMsS0FBS3pCLE1BQUwsQ0FBWTJCLE1BQWIsQ0FMTDtBQUFBLFVBSy9CYixhQUwrQix5QkFLL0JBLGFBTCtCO0FBQUEsVUFLaEJjLFNBTGdCLHlCQUtoQkEsU0FMZ0I7O0FBQUEsNkJBTXZCLEtBQUtDLFVBQUwsQ0FBZ0JKLFFBQWhCLEVBQTBCQyxZQUExQixDQU51QjtBQUFBLFVBTS9CSSxJQU4rQixvQkFNL0JBLElBTitCOztBQVF0QyxVQUFNQyx5QkFBeUIsR0FBRyxTQUE1QkEseUJBQTRCLENBQUNuRCxFQUFELEVBQUtvRCxDQUFMLEVBQVFDLFVBQVIsRUFBdUI7QUFDdkQsZUFBT3JELEVBQUUsQ0FBQ0UsT0FBSCxDQUFXa0QsQ0FBQyxDQUFDL0IsVUFBRixDQUFhbEIsS0FBeEIsRUFBK0JrRCxVQUEvQixDQUFQO0FBQ0QsT0FGRDs7QUFHQSxVQUFNQyxhQUFhLEdBQUcsU0FBaEJBLGFBQWdCLENBQUFGLENBQUM7QUFBQSxlQUFJQSxDQUFDLENBQUMvQixVQUFGLENBQWFsQixLQUFqQjtBQUFBLE9BQXZCOztBQUVBLFVBQU1vRCxZQUFZLEdBQUcsU0FBZkEsWUFBZSxDQUFBdkQsRUFBRTtBQUFBLGVBQUksVUFBQUMsQ0FBQztBQUFBLGlCQUFLO0FBQUNFLFlBQUFBLEtBQUssRUFBRUYsQ0FBQyxDQUFDb0IsVUFBRixDQUFhbEI7QUFBckIsV0FBTDtBQUFBLFNBQUw7QUFBQSxPQUF2Qjs7QUFDQSxVQUFNcUQsU0FBUyxHQUFHLEtBQUtDLHFCQUFMLENBQTJCO0FBQUNGLFFBQUFBLFlBQVksRUFBWkEsWUFBRDtBQUFlckIsUUFBQUEsYUFBYSxFQUFiQTtBQUFmLE9BQTNCLENBQWxCO0FBRUE7QUFDRWdCLFFBQUFBLElBQUksRUFBSkEsSUFERjtBQUVFUSxRQUFBQSxjQUFjLEVBQUVWLFNBQVMsQ0FBQ1csbUJBQVYsQ0FBOEJ6QixhQUE5QixFQUNkb0IsYUFEYyxFQUVkSCx5QkFGYyxDQUZsQjtBQU1FUyxRQUFBQSxPQUFPLEVBQUUsaUJBQUEzRCxDQUFDO0FBQUEsaUJBQUlBLENBQUMsQ0FBQzJDLFFBQUYsQ0FBV2lCLFdBQWY7QUFBQSxTQU5aO0FBT0VDLFFBQUFBLGFBQWEsRUFBRSx1QkFBQTdELENBQUM7QUFBQSxpQkFBSSxNQUFJLENBQUNRLGVBQUwsQ0FBcUJSLENBQUMsQ0FBQ29CLFVBQUYsQ0FBYWxCLEtBQWxDLENBQUo7QUFBQTtBQVBsQixTQVFLcUQsU0FSTDtBQVVEOzs7V0FFRCwrQkFBc0IzQixNQUF0QixFQUE4QjtBQUM1QixXQUFLa0MsaUJBQUwsQ0FBdUI7QUFDckJuQyxRQUFBQSxTQUFTLGtDQUNKLEtBQUtSLE1BQUwsQ0FBWVEsU0FEUjtBQUVQQyxVQUFBQSxNQUFNLEVBQU5BO0FBRk87QUFEWSxPQUF2QjtBQU1EOzs7V0FFRCx5QkFBZ0JLLGFBQWhCLEVBQStCO0FBQzdCLFVBQU12QixVQUFVLEdBQUcsS0FBS3FELG1CQUFMLENBQXlCOUIsYUFBekIsQ0FBbkI7O0FBQ0EsVUFBSXZCLFVBQVUsS0FBSyxLQUFLc0QsSUFBTCxDQUFVdEQsVUFBN0IsRUFBeUM7QUFDdkM7QUFDQTtBQUNEOztBQUVELFdBQUtILGFBQUwsR0FBcUIsc0NBQW1CMEIsYUFBbkIsRUFBa0N2QixVQUFsQyxDQUFyQjs7QUFQNkIsa0NBU2MsMENBQTBCLEtBQUtILGFBQS9CLENBVGQ7QUFBQSxVQVN0QkMsZUFUc0IseUJBU3RCQSxlQVRzQjtBQUFBLFVBU0x5RCxlQVRLLHlCQVNMQSxlQVRLOztBQVc3QixXQUFLekQsZUFBTCxHQUF1QkEsZUFBdkI7QUFDQSxXQUFLMEQscUJBQUwsQ0FBMkJELGVBQTNCLEVBWjZCLENBYzdCOztBQUNBLFVBQU1FLE1BQU0sR0FBRyxvQ0FBaUIsS0FBSzVELGFBQXRCLENBQWYsQ0FmNkIsQ0FpQjdCOztBQUNBLFVBQU02RCxZQUFZLEdBQUcsMENBQXVCLEtBQUs3RCxhQUE1QixDQUFyQjtBQUVBLFdBQUs4RCxVQUFMLENBQWdCO0FBQUNGLFFBQUFBLE1BQU0sRUFBTkEsTUFBRDtBQUFTQyxRQUFBQSxZQUFZLEVBQVpBLFlBQVQ7QUFBdUIxRCxRQUFBQSxVQUFVLEVBQVZBO0FBQXZCLE9BQWhCO0FBQ0Q7OztXQUVELHNDQUF1QztBQUFBLFVBQWhCdUIsYUFBZ0IsU0FBaEJBLGFBQWdCOztBQUNyQyxVQUFJLENBQUNBLGFBQWEsQ0FBQ3FDLE9BQWQsRUFBTCxFQUE4QjtBQUM1QixlQUFPLElBQVA7QUFDRDs7QUFDRCxXQUFLQyxlQUFMLENBQXFCdEMsYUFBckI7QUFDQSxhQUFPLElBQVA7QUFDRDs7O1dBRUQscUJBQVl1QyxJQUFaLEVBQWtCO0FBQUE7O0FBQUEsVUFDVHZCLElBRFMsR0FDcUN1QixJQURyQyxDQUNUdkIsSUFEUztBQUFBLFVBQ0hGLFNBREcsR0FDcUN5QixJQURyQyxDQUNIekIsU0FERztBQUFBLFVBQ1EwQixRQURSLEdBQ3FDRCxJQURyQyxDQUNRQyxRQURSO0FBQUEsVUFDa0JDLGVBRGxCLEdBQ3FDRixJQURyQyxDQUNrQkUsZUFEbEI7QUFBQSxVQUVUbEQsU0FGUyxHQUVJLEtBQUtMLE1BRlQsQ0FFVEssU0FGUztBQUdoQixVQUFNbUQsVUFBVSxHQUFHLEtBQUtDLGFBQUwsQ0FBbUJILFFBQW5CLENBQW5CO0FBQ0EsVUFBTUksV0FBVyxHQUNmSCxlQUFlLElBQ2ZJLEtBQUssQ0FBQ0MsT0FBTixDQUFjTCxlQUFlLENBQUM5QyxNQUE5QixDQURBLElBRUE4QyxlQUFlLENBQUM5QyxNQUFoQixDQUF1Qm9ELEtBQXZCLENBQTZCQyxNQUFNLENBQUNDLFFBQXBDLENBRkEsSUFHQUQsTUFBTSxDQUFDQyxRQUFQLENBQWdCUixlQUFlLENBQUNTLFdBQWhDLENBSkY7O0FBTUEsVUFBSSxDQUFDTixXQUFMLEVBQWtCO0FBQ2hCLGVBQU8sRUFBUDtBQUNEOztBQUVELFVBQU1PLE9BQU8sNEJBQUdWLGVBQWUsQ0FBQzlDLE1BQW5CLDBEQUFHLHNCQUF5QixDQUF6QixDQUFoQjs7QUFFQSxVQUFNeUQsY0FBYyxtQ0FDZixLQUFLQyw4QkFBTCxFQURlO0FBRWxCekIsUUFBQUEsYUFBYSxFQUFFO0FBQ2IzQixVQUFBQSxPQUFPLEVBQUUsS0FBS2YsTUFBTCxDQUFZZSxPQURSO0FBRWJrRCxVQUFBQSxPQUFPLEVBQVBBO0FBRmEsU0FGRztBQU1sQjNCLFFBQUFBLGNBQWMsRUFBRVYsU0FBUyxDQUFDd0M7QUFOUixRQUFwQjs7QUFRQSxVQUFNQyxpQkFBaUIsR0FBRyxLQUFLQyx3QkFBTCxDQUE4QmpCLElBQTlCLENBQTFCO0FBRUEsYUFBTyxDQUNMLElBQUlrQixxQkFBSiwrQ0FDS0YsaUJBREwsR0FFS3ZDLElBRkw7QUFHRVksUUFBQUEsYUFBYSxFQUFFLHVCQUFBN0QsQ0FBQztBQUFBLGlCQUFJLENBQUNpRCxJQUFJLENBQUNZLGFBQUwsQ0FBbUI3RCxDQUFuQixLQUF5QixFQUExQixFQUE4QndDLEdBQTlCLENBQWtDLFVBQUFtRCxFQUFFO0FBQUEsbUJBQUlBLEVBQUUsR0FBR1AsT0FBVDtBQUFBLFdBQXBDLENBQUo7QUFBQSxTQUhsQjtBQUlFUSxRQUFBQSxVQUFVLEVBQUUsS0FBS3pFLE1BQUwsQ0FBWUssU0FBWixDQUFzQnhDLFNBQXRCLEdBQWtDMkYsVUFBbEMsR0FBK0NoRyxlQUo3RDtBQUtFa0gsUUFBQUEsVUFBVSxFQUFFLElBTGQ7QUFNRUMsUUFBQUEsWUFBWSxFQUFFLElBTmhCO0FBT0VDLFFBQUFBLGFBQWEsRUFBRSxLQVBqQjtBQVFFQyxRQUFBQSxVQUFVLEVBQUU7QUFDVkMsVUFBQUEsU0FBUyxFQUFFeEIsUUFBUSxDQUFDeUIsVUFEVjtBQUVWQyxVQUFBQSxTQUFTLEVBQUU7QUFGRCxTQVJkO0FBWUV6RyxRQUFBQSxXQUFXLEVBQUU4QixTQUFTLENBQUM5QixXQUFWLEdBQXdCLElBWnZDO0FBYUV5RixRQUFBQSxXQUFXLEVBQUVULGVBQWUsQ0FBQ1MsV0FBaEIsR0FBOEJDLE9BYjdDO0FBY0VDLFFBQUFBLGNBQWMsRUFBZEE7QUFkRixTQURLLENBQVA7QUFrQkQ7OztTQTNPRCxlQUEwQjtBQUN4QixhQUFPLE1BQVA7QUFDRDs7O1dBK0RELHNDQUVFZSxXQUZGLEVBR0U7QUFBQTs7QUFBQSxVQUZDakgsS0FFRCxTQUZDQSxLQUVEO0FBQUEsK0JBRlFrSCxNQUVSO0FBQUEsVUFGUUEsTUFFUiw2QkFGaUIsRUFFakI7QUFBQSxVQUZxQnBFLGFBRXJCLFNBRnFCQSxhQUVyQjtBQUFBLFVBRm9DSixFQUVwQyxTQUZvQ0EsRUFFcEM7QUFDQSxVQUFNeUUsY0FBYyxHQUFHRCxNQUFNLENBQUMzRCxNQUFQLENBQWMsVUFBQVMsQ0FBQztBQUFBLGVBQUlBLENBQUMsQ0FBQ2xFLElBQUYsS0FBVyxTQUFmO0FBQUEsT0FBZixFQUF5Q3VELEdBQXpDLENBQTZDLFVBQUFXLENBQUM7QUFBQSxlQUFJQSxDQUFDLENBQUNvRCxJQUFOO0FBQUEsT0FBOUMsQ0FBdkI7QUFFQSxVQUFNQyxjQUFjLEdBQUc7QUFDckIxRyxRQUFBQSxPQUFPLEVBQUUsdUVBQVMyRywwQkFBZTNHLE9BQXhCLHVDQUFvQ3dHLGNBQXBDO0FBRFksT0FBdkI7QUFJQSxVQUFNSSxjQUFjLEdBQUcsS0FBS0Msc0JBQUwsQ0FBNEJILGNBQTVCLEVBQTRDSCxNQUE1QyxDQUF2QjtBQUVBLFVBQU1PLGtCQUFrQixHQUFHLENBQUNGLGNBQWMsSUFBSSxFQUFuQixFQUF1QmhFLE1BQXZCLENBQThCLFVBQUFtRSxHQUFHO0FBQUEsZUFDMUQsbUNBQW1CNUUsYUFBbkIsRUFBa0NvRSxNQUFNLENBQUNRLEdBQUcsQ0FBQy9HLE9BQUosQ0FBWUssUUFBYixDQUF4QyxDQUQwRDtBQUFBLE9BQWpDLENBQTNCOztBQUlBLFVBQUl5RyxrQkFBa0IsQ0FBQ0UsTUFBdkIsRUFBK0I7QUFDN0IsZUFBTztBQUNMeEcsVUFBQUEsS0FBSyxFQUFFc0csa0JBQWtCLENBQUNwRSxHQUFuQixDQUF1QixVQUFBTixPQUFPO0FBQUEsbUJBQUs7QUFDeEMvQyxjQUFBQSxLQUFLLEVBQUcsT0FBT0EsS0FBUCxLQUFpQixRQUFqQixJQUE2QkEsS0FBSyxDQUFDNEgsT0FBTixDQUFjLFdBQWQsRUFBMkIsRUFBM0IsQ0FBOUIsSUFBaUUsTUFBSSxDQUFDOUgsSUFEckM7QUFFeENpRCxjQUFBQSxPQUFPLEVBQVBBLE9BRndDO0FBR3hDOEUsY0FBQUEsU0FBUyxFQUFFO0FBSDZCLGFBQUw7QUFBQSxXQUE5QixDQURGO0FBT0w7QUFDQVosVUFBQUEsV0FBVyxFQUFFQSxXQUFXLENBQUMxRCxNQUFaLENBQ1gsVUFBQXVFLElBQUk7QUFBQSxtQkFDRkEsSUFBSSxDQUFDaEksSUFBTCxLQUFjLFNBQWQsSUFDQWdJLElBQUksQ0FBQ25FLE1BQUwsS0FBZ0JqQixFQURoQixJQUVBLENBQUMrRSxrQkFBa0IsQ0FBQ00sSUFBbkIsQ0FBd0IsVUFBQUMsQ0FBQztBQUFBLHFCQUFJRixJQUFJLENBQUMvRSxPQUFMLENBQWFwQyxPQUFiLENBQXFCeUcsSUFBckIsS0FBOEJZLENBQUMsQ0FBQ3JILE9BQUYsQ0FBVXlHLElBQTVDO0FBQUEsYUFBekIsQ0FIQztBQUFBLFdBRE87QUFSUixTQUFQO0FBZUQ7O0FBRUQsYUFBTztBQUFDakcsUUFBQUEsS0FBSyxFQUFFO0FBQVIsT0FBUDtBQUNEOzs7RUF4SG9DOEcscUIiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMjIgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5pbXBvcnQgbWVtb2l6ZSBmcm9tICdsb2Rhc2gubWVtb2l6ZSc7XG5pbXBvcnQgdW5pcSBmcm9tICdsb2Rhc2gudW5pcSc7XG5pbXBvcnQgTGF5ZXIsIHtMYXllckJhc2VDb25maWcsIExheWVyQ29sdW1ufSBmcm9tICcuLi9iYXNlLWxheWVyJztcbmltcG9ydCB7VHJpcHNMYXllciBhcyBEZWNrR0xUcmlwc0xheWVyfSBmcm9tICdAZGVjay5nbC9nZW8tbGF5ZXJzJztcblxuaW1wb3J0IHtHRU9KU09OX0ZJRUxEUywgQ29sb3JSYW5nZX0gZnJvbSAnQGtlcGxlci5nbC9jb25zdGFudHMnO1xuaW1wb3J0IFRyaXBMYXllckljb24gZnJvbSAnLi90cmlwLWxheWVyLWljb24nO1xuXG5pbXBvcnQge1xuICBnZXRHZW9qc29uRGF0YU1hcHMsXG4gIGdldEdlb2pzb25Cb3VuZHMsXG4gIGdldEdlb2pzb25GZWF0dXJlVHlwZXMsXG4gIEdlb2pzb25EYXRhTWFwc1xufSBmcm9tICcuLi9nZW9qc29uLWxheWVyL2dlb2pzb24tdXRpbHMnO1xuXG5pbXBvcnQge2lzVHJpcEdlb0pzb25GaWVsZCwgcGFyc2VUcmlwR2VvSnNvblRpbWVzdGFtcH0gZnJvbSAnLi90cmlwLXV0aWxzJztcbmltcG9ydCBUcmlwSW5mb01vZGFsRmFjdG9yeSBmcm9tICcuL3RyaXAtaW5mby1tb2RhbCc7XG5pbXBvcnQge01lcmdlLCBWaXNDb25maWdDb2xvclJhbmdlLCBWaXNDb25maWdOdW1iZXIsIFZpc0NvbmZpZ1JhbmdlfSBmcm9tICdAa2VwbGVyLmdsL3R5cGVzJztcbmltcG9ydCB7ZGVmYXVsdCBhcyBLZXBsZXJUYWJsZX0gZnJvbSAnQGtlcGxlci5nbC90YWJsZSc7XG5pbXBvcnQge0RhdGFDb250YWluZXJJbnRlcmZhY2V9IGZyb20gJ0BrZXBsZXIuZ2wvdXRpbHMnO1xuXG5leHBvcnQgdHlwZSBUcmlwTGF5ZXJWaXNDb25maWdTZXR0aW5ncyA9IHtcbiAgb3BhY2l0eTogVmlzQ29uZmlnTnVtYmVyO1xuICB0aGlja25lc3M6IFZpc0NvbmZpZ051bWJlcjtcbiAgY29sb3JSYW5nZTogVmlzQ29uZmlnQ29sb3JSYW5nZTtcbiAgdHJhaWxMZW5ndGg6IFZpc0NvbmZpZ051bWJlcjtcbiAgc2l6ZVJhbmdlOiBWaXNDb25maWdSYW5nZTtcbn07XG5cbmV4cG9ydCB0eXBlIFRyaXBMYXllckNvbHVtbnNDb25maWcgPSB7XG4gIGdlb2pzb246IExheWVyQ29sdW1uO1xufTtcblxuZXhwb3J0IHR5cGUgVHJpcExheWVyVmlzQ29uZmlnID0ge1xuICBvcGFjaXR5OiBudW1iZXI7XG4gIHRoaWNrbmVzczogbnVtYmVyO1xuICBjb2xvclJhbmdlOiBDb2xvclJhbmdlO1xuICB0cmFpbExlbmd0aDogbnVtYmVyO1xuICBzaXplUmFuZ2U6IFtudW1iZXIsIG51bWJlcl07XG59O1xuXG5leHBvcnQgdHlwZSBUcmlwTGF5ZXJDb25maWcgPSBNZXJnZTxcbiAgTGF5ZXJCYXNlQ29uZmlnLFxuICB7Y29sdW1uczogVHJpcExheWVyQ29sdW1uc0NvbmZpZzsgdmlzQ29uZmlnOiBUcmlwTGF5ZXJWaXNDb25maWd9XG4+O1xuXG5leHBvcnQgdHlwZSBUcmlwTGF5ZXJNZXRhID0ge1xuICBnZXRGZWF0dXJlOiBhbnk7XG59O1xuXG5jb25zdCB6b29tRmFjdG9yVmFsdWUgPSA4O1xuXG5leHBvcnQgY29uc3QgZGVmYXVsdFRoaWNrbmVzcyA9IDAuNTtcbmV4cG9ydCBjb25zdCBkZWZhdWx0TGluZVdpZHRoID0gMTtcblxuZXhwb3J0IGNvbnN0IHRyaXBWaXNDb25maWdzOiB7XG4gIG9wYWNpdHk6ICdvcGFjaXR5JztcbiAgdGhpY2tuZXNzOiBWaXNDb25maWdOdW1iZXI7XG4gIGNvbG9yUmFuZ2U6ICdjb2xvclJhbmdlJztcbiAgdHJhaWxMZW5ndGg6ICd0cmFpbExlbmd0aCc7XG4gIHNpemVSYW5nZTogJ3N0cm9rZVdpZHRoUmFuZ2UnO1xufSA9IHtcbiAgb3BhY2l0eTogJ29wYWNpdHknLFxuICB0aGlja25lc3M6IHtcbiAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICBkZWZhdWx0VmFsdWU6IGRlZmF1bHRUaGlja25lc3MsXG4gICAgbGFiZWw6ICdTdHJva2UgV2lkdGgnLFxuICAgIGlzUmFuZ2VkOiBmYWxzZSxcbiAgICByYW5nZTogWzAsIDEwMF0sXG4gICAgc3RlcDogMC4xLFxuICAgIGdyb3VwOiAnc3Ryb2tlJyxcbiAgICBwcm9wZXJ0eTogJ3RoaWNrbmVzcydcbiAgfSxcbiAgY29sb3JSYW5nZTogJ2NvbG9yUmFuZ2UnLFxuICB0cmFpbExlbmd0aDogJ3RyYWlsTGVuZ3RoJyxcbiAgc2l6ZVJhbmdlOiAnc3Ryb2tlV2lkdGhSYW5nZSdcbn07XG5cbmV4cG9ydCBjb25zdCBnZW9Kc29uUmVxdWlyZWRDb2x1bW5zOiBbJ2dlb2pzb24nXSA9IFsnZ2VvanNvbiddO1xuZXhwb3J0IGNvbnN0IGZlYXR1cmVBY2Nlc3NvciA9ICh7Z2VvanNvbn06IFRyaXBMYXllckNvbHVtbnNDb25maWcpID0+IChcbiAgZGM6IERhdGFDb250YWluZXJJbnRlcmZhY2VcbikgPT4gZCA9PiBkYy52YWx1ZUF0KGQuaW5kZXgsIGdlb2pzb24uZmllbGRJZHgpO1xuZXhwb3J0IGNvbnN0IGZlYXR1cmVSZXNvbHZlciA9ICh7Z2VvanNvbn06IFRyaXBMYXllckNvbHVtbnNDb25maWcpID0+IGdlb2pzb24uZmllbGRJZHg7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRyaXBMYXllciBleHRlbmRzIExheWVyIHtcbiAgZGVjbGFyZSB2aXNDb25maWdTZXR0aW5nczogVHJpcExheWVyVmlzQ29uZmlnU2V0dGluZ3M7XG4gIGRlY2xhcmUgY29uZmlnOiBUcmlwTGF5ZXJDb25maWc7XG4gIGRlY2xhcmUgbWV0YTogVHJpcExheWVyTWV0YTtcblxuICBkYXRhVG9GZWF0dXJlOiBHZW9qc29uRGF0YU1hcHM7XG4gIGRhdGFUb1RpbWVTdGFtcDoge31bXTtcbiAgZ2V0RmVhdHVyZTogKGNvbHVtbnM6IFRyaXBMYXllckNvbHVtbnNDb25maWcpID0+IChkYXRhQ29udGFpbmVyOiBEYXRhQ29udGFpbmVySW50ZXJmYWNlKSA9PiBhbnk7XG4gIF9sYXllckluZm9Nb2RhbDogKCkgPT4gSlNYLkVsZW1lbnQ7XG5cbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyk7XG5cbiAgICB0aGlzLmRhdGFUb0ZlYXR1cmUgPSBbXTtcbiAgICB0aGlzLmRhdGFUb1RpbWVTdGFtcCA9IFtdO1xuICAgIHRoaXMucmVnaXN0ZXJWaXNDb25maWcodHJpcFZpc0NvbmZpZ3MpO1xuICAgIHRoaXMuZ2V0RmVhdHVyZSA9IG1lbW9pemUoZmVhdHVyZUFjY2Vzc29yLCBmZWF0dXJlUmVzb2x2ZXIpO1xuICAgIHRoaXMuX2xheWVySW5mb01vZGFsID0gVHJpcEluZm9Nb2RhbEZhY3RvcnkoKTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgdHlwZSgpOiAndHJpcCcge1xuICAgIHJldHVybiAndHJpcCc7XG4gIH1cbiAgZ2V0IHR5cGUoKSB7XG4gICAgcmV0dXJuIFRyaXBMYXllci50eXBlO1xuICB9XG5cbiAgZ2V0IG5hbWUoKTogJ1RyaXAnIHtcbiAgICByZXR1cm4gJ1RyaXAnO1xuICB9XG5cbiAgZ2V0IGxheWVySWNvbigpIHtcbiAgICByZXR1cm4gVHJpcExheWVySWNvbjtcbiAgfVxuXG4gIGdldCBjb2x1bW5QYWlycygpIHtcbiAgICByZXR1cm4gdGhpcy5kZWZhdWx0UG9pbnRDb2x1bW5QYWlycztcbiAgfVxuXG4gIGdldCByZXF1aXJlZExheWVyQ29sdW1ucygpIHtcbiAgICByZXR1cm4gZ2VvSnNvblJlcXVpcmVkQ29sdW1ucztcbiAgfVxuXG4gIGdldCB2aXN1YWxDaGFubmVscygpIHtcbiAgICBjb25zdCB2aXN1YWxDaGFubmVscyA9IHN1cGVyLnZpc3VhbENoYW5uZWxzO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnZpc3VhbENoYW5uZWxzLFxuICAgICAgY29sb3I6IHtcbiAgICAgICAgLi4udmlzdWFsQ2hhbm5lbHMuY29sb3IsXG4gICAgICAgIGFjY2Vzc29yOiAnZ2V0Q29sb3InLFxuICAgICAgICBudWxsVmFsdWU6IHZpc3VhbENoYW5uZWxzLmNvbG9yLm51bGxWYWx1ZSxcbiAgICAgICAgZ2V0QXR0cmlidXRlVmFsdWU6IGNvbmZpZyA9PiBkID0+IGQucHJvcGVydGllcy5saW5lQ29sb3IgfHwgY29uZmlnLmNvbG9yLFxuICAgICAgICAvLyB1c2VkIHRoaXMgdG8gZ2V0IHVwZGF0ZVRyaWdnZXJzXG4gICAgICAgIGRlZmF1bHRWYWx1ZTogY29uZmlnID0+IGNvbmZpZy5jb2xvclxuICAgICAgfSxcbiAgICAgIHNpemU6IHtcbiAgICAgICAgLi4udmlzdWFsQ2hhbm5lbHMuc2l6ZSxcbiAgICAgICAgcHJvcGVydHk6ICdzdHJva2UnLFxuICAgICAgICBhY2Nlc3NvcjogJ2dldFdpZHRoJyxcbiAgICAgICAgY29uZGl0aW9uOiBjb25maWcgPT4gY29uZmlnLnZpc0NvbmZpZy5zdHJva2VkLFxuICAgICAgICBudWxsVmFsdWU6IDAsXG4gICAgICAgIGdldEF0dHJpYnV0ZVZhbHVlOiAoKSA9PiBkID0+IGQucHJvcGVydGllcy5saW5lV2lkdGggfHwgZGVmYXVsdExpbmVXaWR0aFxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBnZXQgYW5pbWF0aW9uRG9tYWluKCkge1xuICAgIHJldHVybiB0aGlzLmNvbmZpZy5hbmltYXRpb24uZG9tYWluO1xuICB9XG5cbiAgZ2V0IGxheWVySW5mb01vZGFsKCkge1xuICAgIHJldHVybiB7XG4gICAgICBpZDogJ2ljb25JbmZvJyxcbiAgICAgIHRlbXBsYXRlOiB0aGlzLl9sYXllckluZm9Nb2RhbCxcbiAgICAgIG1vZGFsUHJvcHM6IHtcbiAgICAgICAgdGl0bGU6ICdtb2RhbC50cmlwSW5mby50aXRsZSdcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgZ2V0UG9zaXRpb25BY2Nlc3NvcihkYXRhQ29udGFpbmVyOiBEYXRhQ29udGFpbmVySW50ZXJmYWNlKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0RmVhdHVyZSh0aGlzLmNvbmZpZy5jb2x1bW5zKShkYXRhQ29udGFpbmVyKTtcbiAgfVxuXG4gIHN0YXRpYyBmaW5kRGVmYXVsdExheWVyUHJvcHMoXG4gICAge2xhYmVsLCBmaWVsZHMgPSBbXSwgZGF0YUNvbnRhaW5lciwgaWR9OiBLZXBsZXJUYWJsZSxcbiAgICBmb3VuZExheWVyczogYW55W11cbiAgKSB7XG4gICAgY29uc3QgZ2VvanNvbkNvbHVtbnMgPSBmaWVsZHMuZmlsdGVyKGYgPT4gZi50eXBlID09PSAnZ2VvanNvbicpLm1hcChmID0+IGYubmFtZSk7XG5cbiAgICBjb25zdCBkZWZhdWx0Q29sdW1ucyA9IHtcbiAgICAgIGdlb2pzb246IHVuaXEoWy4uLkdFT0pTT05fRklFTERTLmdlb2pzb24sIC4uLmdlb2pzb25Db2x1bW5zXSlcbiAgICB9O1xuXG4gICAgY29uc3QgZ2VvSnNvbkNvbHVtbnMgPSB0aGlzLmZpbmREZWZhdWx0Q29sdW1uRmllbGQoZGVmYXVsdENvbHVtbnMsIGZpZWxkcyk7XG5cbiAgICBjb25zdCB0cmlwR2VvanNvbkNvbHVtbnMgPSAoZ2VvSnNvbkNvbHVtbnMgfHwgW10pLmZpbHRlcihjb2wgPT5cbiAgICAgIGlzVHJpcEdlb0pzb25GaWVsZChkYXRhQ29udGFpbmVyLCBmaWVsZHNbY29sLmdlb2pzb24uZmllbGRJZHhdKVxuICAgICk7XG5cbiAgICBpZiAodHJpcEdlb2pzb25Db2x1bW5zLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcHJvcHM6IHRyaXBHZW9qc29uQ29sdW1ucy5tYXAoY29sdW1ucyA9PiAoe1xuICAgICAgICAgIGxhYmVsOiAodHlwZW9mIGxhYmVsID09PSAnc3RyaW5nJyAmJiBsYWJlbC5yZXBsYWNlKC9cXC5bXi8uXSskLywgJycpKSB8fCB0aGlzLnR5cGUsXG4gICAgICAgICAgY29sdW1ucyxcbiAgICAgICAgICBpc1Zpc2libGU6IHRydWVcbiAgICAgICAgfSkpLFxuXG4gICAgICAgIC8vIGlmIGEgZ2VvanNvbiBsYXllciBpcyBjcmVhdGVkIGZyb20gdGhpcyBjb2x1bW4sIGRlbGV0ZSBpdFxuICAgICAgICBmb3VuZExheWVyczogZm91bmRMYXllcnMuZmlsdGVyKFxuICAgICAgICAgIHByb3AgPT5cbiAgICAgICAgICAgIHByb3AudHlwZSAhPT0gJ2dlb2pzb24nIHx8XG4gICAgICAgICAgICBwcm9wLmRhdGFJZCAhPT0gaWQgfHxcbiAgICAgICAgICAgICF0cmlwR2VvanNvbkNvbHVtbnMuZmluZChjID0+IHByb3AuY29sdW1ucy5nZW9qc29uLm5hbWUgPT09IGMuZ2VvanNvbi5uYW1lKVxuICAgICAgICApXG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiB7cHJvcHM6IFtdfTtcbiAgfVxuXG4gIGdldERlZmF1bHRMYXllckNvbmZpZyhwcm9wcykge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5zdXBlci5nZXREZWZhdWx0TGF5ZXJDb25maWcocHJvcHMpLFxuICAgICAgYW5pbWF0aW9uOiB7XG4gICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgIGRvbWFpbjogbnVsbFxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBnZXRIb3ZlckRhdGEob2JqZWN0LCBkYXRhQ29udGFpbmVyKSB7XG4gICAgLy8gaW5kZXggZm9yIGRhdGFDb250YWluZXIgaXMgc2F2ZWQgdG8gZmVhdHVyZS5wcm9wZXJ0aWVzXG4gICAgcmV0dXJuIGRhdGFDb250YWluZXIucm93KG9iamVjdC5wcm9wZXJ0aWVzLmluZGV4KTtcbiAgfVxuXG4gIGNhbGN1bGF0ZURhdGFBdHRyaWJ1dGUoe2RhdGFDb250YWluZXIsIGZpbHRlcmVkSW5kZXh9LCBnZXRQb3NpdGlvbikge1xuICAgIHJldHVybiBmaWx0ZXJlZEluZGV4XG4gICAgICAubWFwKGkgPT4gdGhpcy5kYXRhVG9GZWF0dXJlW2ldKVxuICAgICAgLmZpbHRlcihkID0+IGQgJiYgZC5nZW9tZXRyeS50eXBlID09PSAnTGluZVN0cmluZycpO1xuICB9XG5cbiAgZm9ybWF0TGF5ZXJEYXRhKGRhdGFzZXRzLCBvbGRMYXllckRhdGEpIHtcbiAgICBpZiAodGhpcy5jb25maWcuZGF0YUlkID09PSBudWxsKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIC8vIHRvLWRvOiBwYXJzZSBzZWdtZW50IGZyb20gZGF0YUNvbnRhaW5lclxuICAgIGNvbnN0IHtkYXRhQ29udGFpbmVyLCBncHVGaWx0ZXJ9ID0gZGF0YXNldHNbdGhpcy5jb25maWcuZGF0YUlkXTtcbiAgICBjb25zdCB7ZGF0YX0gPSB0aGlzLnVwZGF0ZURhdGEoZGF0YXNldHMsIG9sZExheWVyRGF0YSk7XG5cbiAgICBjb25zdCBjdXN0b21GaWx0ZXJWYWx1ZUFjY2Vzc29yID0gKGRjLCBmLCBmaWVsZEluZGV4KSA9PiB7XG4gICAgICByZXR1cm4gZGMudmFsdWVBdChmLnByb3BlcnRpZXMuaW5kZXgsIGZpZWxkSW5kZXgpO1xuICAgIH07XG4gICAgY29uc3QgaW5kZXhBY2Nlc3NvciA9IGYgPT4gZi5wcm9wZXJ0aWVzLmluZGV4O1xuXG4gICAgY29uc3QgZGF0YUFjY2Vzc29yID0gZGMgPT4gZCA9PiAoe2luZGV4OiBkLnByb3BlcnRpZXMuaW5kZXh9KTtcbiAgICBjb25zdCBhY2Nlc3NvcnMgPSB0aGlzLmdldEF0dHJpYnV0ZUFjY2Vzc29ycyh7ZGF0YUFjY2Vzc29yLCBkYXRhQ29udGFpbmVyfSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgZGF0YSxcbiAgICAgIGdldEZpbHRlclZhbHVlOiBncHVGaWx0ZXIuZmlsdGVyVmFsdWVBY2Nlc3NvcihkYXRhQ29udGFpbmVyKShcbiAgICAgICAgaW5kZXhBY2Nlc3NvcixcbiAgICAgICAgY3VzdG9tRmlsdGVyVmFsdWVBY2Nlc3NvclxuICAgICAgKSxcbiAgICAgIGdldFBhdGg6IGQgPT4gZC5nZW9tZXRyeS5jb29yZGluYXRlcyxcbiAgICAgIGdldFRpbWVzdGFtcHM6IGQgPT4gdGhpcy5kYXRhVG9UaW1lU3RhbXBbZC5wcm9wZXJ0aWVzLmluZGV4XSxcbiAgICAgIC4uLmFjY2Vzc29yc1xuICAgIH07XG4gIH1cblxuICB1cGRhdGVBbmltYXRpb25Eb21haW4oZG9tYWluKSB7XG4gICAgdGhpcy51cGRhdGVMYXllckNvbmZpZyh7XG4gICAgICBhbmltYXRpb246IHtcbiAgICAgICAgLi4udGhpcy5jb25maWcuYW5pbWF0aW9uLFxuICAgICAgICBkb21haW5cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHVwZGF0ZUxheWVyTWV0YShkYXRhQ29udGFpbmVyKSB7XG4gICAgY29uc3QgZ2V0RmVhdHVyZSA9IHRoaXMuZ2V0UG9zaXRpb25BY2Nlc3NvcihkYXRhQ29udGFpbmVyKTtcbiAgICBpZiAoZ2V0RmVhdHVyZSA9PT0gdGhpcy5tZXRhLmdldEZlYXR1cmUpIHtcbiAgICAgIC8vIFRPRE86IHJldmlzaXQgdGhpcyBhZnRlciBncHUgZmlsdGVyaW5nXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5kYXRhVG9GZWF0dXJlID0gZ2V0R2VvanNvbkRhdGFNYXBzKGRhdGFDb250YWluZXIsIGdldEZlYXR1cmUpO1xuXG4gICAgY29uc3Qge2RhdGFUb1RpbWVTdGFtcCwgYW5pbWF0aW9uRG9tYWlufSA9IHBhcnNlVHJpcEdlb0pzb25UaW1lc3RhbXAodGhpcy5kYXRhVG9GZWF0dXJlKTtcblxuICAgIHRoaXMuZGF0YVRvVGltZVN0YW1wID0gZGF0YVRvVGltZVN0YW1wO1xuICAgIHRoaXMudXBkYXRlQW5pbWF0aW9uRG9tYWluKGFuaW1hdGlvbkRvbWFpbik7XG5cbiAgICAvLyBnZXQgYm91bmRzIGZyb20gZmVhdHVyZXNcbiAgICBjb25zdCBib3VuZHMgPSBnZXRHZW9qc29uQm91bmRzKHRoaXMuZGF0YVRvRmVhdHVyZSk7XG5cbiAgICAvLyBrZWVwIGEgcmVjb3JkIG9mIHdoYXQgdHlwZSBvZiBnZW9tZXRyeSB0aGUgY29sbGVjdGlvbiBoYXNcbiAgICBjb25zdCBmZWF0dXJlVHlwZXMgPSBnZXRHZW9qc29uRmVhdHVyZVR5cGVzKHRoaXMuZGF0YVRvRmVhdHVyZSk7XG5cbiAgICB0aGlzLnVwZGF0ZU1ldGEoe2JvdW5kcywgZmVhdHVyZVR5cGVzLCBnZXRGZWF0dXJlfSk7XG4gIH1cblxuICBzZXRJbml0aWFsTGF5ZXJDb25maWcoe2RhdGFDb250YWluZXJ9KSB7XG4gICAgaWYgKCFkYXRhQ29udGFpbmVyLm51bVJvd3MoKSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHRoaXMudXBkYXRlTGF5ZXJNZXRhKGRhdGFDb250YWluZXIpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgcmVuZGVyTGF5ZXIob3B0cykge1xuICAgIGNvbnN0IHtkYXRhLCBncHVGaWx0ZXIsIG1hcFN0YXRlLCBhbmltYXRpb25Db25maWd9ID0gb3B0cztcbiAgICBjb25zdCB7dmlzQ29uZmlnfSA9IHRoaXMuY29uZmlnO1xuICAgIGNvbnN0IHpvb21GYWN0b3IgPSB0aGlzLmdldFpvb21GYWN0b3IobWFwU3RhdGUpO1xuICAgIGNvbnN0IGlzVmFsaWRUaW1lID1cbiAgICAgIGFuaW1hdGlvbkNvbmZpZyAmJlxuICAgICAgQXJyYXkuaXNBcnJheShhbmltYXRpb25Db25maWcuZG9tYWluKSAmJlxuICAgICAgYW5pbWF0aW9uQ29uZmlnLmRvbWFpbi5ldmVyeShOdW1iZXIuaXNGaW5pdGUpICYmXG4gICAgICBOdW1iZXIuaXNGaW5pdGUoYW5pbWF0aW9uQ29uZmlnLmN1cnJlbnRUaW1lKTtcblxuICAgIGlmICghaXNWYWxpZFRpbWUpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICBjb25zdCBkb21haW4wID0gYW5pbWF0aW9uQ29uZmlnLmRvbWFpbj8uWzBdO1xuXG4gICAgY29uc3QgdXBkYXRlVHJpZ2dlcnMgPSB7XG4gICAgICAuLi50aGlzLmdldFZpc3VhbENoYW5uZWxVcGRhdGVUcmlnZ2VycygpLFxuICAgICAgZ2V0VGltZXN0YW1wczoge1xuICAgICAgICBjb2x1bW5zOiB0aGlzLmNvbmZpZy5jb2x1bW5zLFxuICAgICAgICBkb21haW4wXG4gICAgICB9LFxuICAgICAgZ2V0RmlsdGVyVmFsdWU6IGdwdUZpbHRlci5maWx0ZXJWYWx1ZVVwZGF0ZVRyaWdnZXJzXG4gICAgfTtcbiAgICBjb25zdCBkZWZhdWx0TGF5ZXJQcm9wcyA9IHRoaXMuZ2V0RGVmYXVsdERlY2tMYXllclByb3BzKG9wdHMpO1xuXG4gICAgcmV0dXJuIFtcbiAgICAgIG5ldyBEZWNrR0xUcmlwc0xheWVyKHtcbiAgICAgICAgLi4uZGVmYXVsdExheWVyUHJvcHMsXG4gICAgICAgIC4uLmRhdGEsXG4gICAgICAgIGdldFRpbWVzdGFtcHM6IGQgPT4gKGRhdGEuZ2V0VGltZXN0YW1wcyhkKSB8fCBbXSkubWFwKHRzID0+IHRzIC0gZG9tYWluMCksXG4gICAgICAgIHdpZHRoU2NhbGU6IHRoaXMuY29uZmlnLnZpc0NvbmZpZy50aGlja25lc3MgKiB6b29tRmFjdG9yICogem9vbUZhY3RvclZhbHVlLFxuICAgICAgICBjYXBSb3VuZGVkOiB0cnVlLFxuICAgICAgICBqb2ludFJvdW5kZWQ6IHRydWUsXG4gICAgICAgIHdyYXBMb25naXR1ZGU6IGZhbHNlLFxuICAgICAgICBwYXJhbWV0ZXJzOiB7XG4gICAgICAgICAgZGVwdGhUZXN0OiBtYXBTdGF0ZS5kcmFnUm90YXRlLFxuICAgICAgICAgIGRlcHRoTWFzazogZmFsc2VcbiAgICAgICAgfSxcbiAgICAgICAgdHJhaWxMZW5ndGg6IHZpc0NvbmZpZy50cmFpbExlbmd0aCAqIDEwMDAsXG4gICAgICAgIGN1cnJlbnRUaW1lOiBhbmltYXRpb25Db25maWcuY3VycmVudFRpbWUgLSBkb21haW4wLFxuICAgICAgICB1cGRhdGVUcmlnZ2Vyc1xuICAgICAgfSlcbiAgICBdO1xuICB9XG59XG4iXX0=