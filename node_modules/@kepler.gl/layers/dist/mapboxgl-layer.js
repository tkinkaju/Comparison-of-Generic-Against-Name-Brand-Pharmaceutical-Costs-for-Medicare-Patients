// Copyright (c) 2022 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = exports.pointColResolver = exports.mapboxRequiredColumns = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _baseLayer = _interopRequireWildcard(require("./base-layer"));

var _reselect = require("reselect");

var _mapboxUtils = require("./mapbox-utils");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var mapboxRequiredColumns = ['lat', 'lng'];
exports.mapboxRequiredColumns = mapboxRequiredColumns;

var pointColResolver = function pointColResolver(_ref) {
  var lat = _ref.lat,
      lng = _ref.lng;
  return "".concat(lat.fieldIdx, "-").concat(lng.fieldIdx);
};

exports.pointColResolver = pointColResolver;

var MapboxLayerGL = /*#__PURE__*/function (_Layer) {
  (0, _inherits2["default"])(MapboxLayerGL, _Layer);

  var _super = _createSuper(MapboxLayerGL);

  function MapboxLayerGL() {
    var _this;

    (0, _classCallCheck2["default"])(this, MapboxLayerGL);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "datasetSelector", function (config) {
      return config.dataId;
    });
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "gpuFilterSelector", function (config, datasets) {
      return (config.dataId && datasets[config.dataId] || {}).gpuFilter;
    });
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "columnsSelector", function (config) {
      return pointColResolver(config.columns);
    });
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "sourceSelector", (0, _reselect.createSelector)(_this.datasetSelector, _this.columnsSelector, function (datasetId, columns) {
      return "".concat(datasetId, "-").concat(columns);
    }));
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "filterSelector", (0, _reselect.createSelector)(_this.gpuFilterSelector, function (gpuFilter) {
      return (0, _mapboxUtils.gpuFilterToMapboxFilter)(gpuFilter);
    }));
    return _this;
  }

  (0, _createClass2["default"])(MapboxLayerGL, [{
    key: "overlayType",
    get: function get() {
      return _baseLayer.OVERLAY_TYPE_CONST.mapboxgl;
    }
  }, {
    key: "type",
    get: function get() {
      return null;
    }
  }, {
    key: "isAggregated",
    get: function get() {
      return true;
    }
  }, {
    key: "requiredLayerColumns",
    get: function get() {
      return mapboxRequiredColumns;
    }
  }, {
    key: "columnPairs",
    get: function get() {
      return this.defaultPointColumnPairs;
    }
  }, {
    key: "noneLayerDataAffectingProps",
    get: function get() {
      return [];
    }
  }, {
    key: "visualChannels",
    get: function get() {
      return {};
    }
  }, {
    key: "isValidFilter",
    value: function isValidFilter(filter) {
      // mapbox will crash if filter is not an array or empty
      return Array.isArray(filter) && filter.length;
    }
  }, {
    key: "getDataUpdateTriggers",
    value: function getDataUpdateTriggers(_ref2) {
      var _this2 = this;

      var filteredIndex = _ref2.filteredIndex,
          gpuFilter = _ref2.gpuFilter,
          id = _ref2.id;
      var columns = this.config.columns;
      var visualChannelFields = Object.values(this.visualChannels).reduce(function (accu, v) {
        return _objectSpread(_objectSpread({}, accu), _this2.config[v.field] ? (0, _defineProperty2["default"])({}, v.field, _this2.config[v.field].name) : {});
      }, {});
      var updateTriggers = {
        getData: _objectSpread(_objectSpread({
          datasetId: id,
          columns: columns,
          filteredIndex: filteredIndex
        }, visualChannelFields), gpuFilter.filterValueUpdateTriggers),
        getMeta: {
          datasetId: id,
          columns: columns
        }
      };
      return updateTriggers;
    }
  }, {
    key: "getGeometry",
    value: function getGeometry(position) {
      return position.every(Number.isFinite) ? {
        type: 'Point',
        coordinates: position
      } : null;
    }
  }, {
    key: "calculateDataAttribute",
    value: function calculateDataAttribute(_ref4, getPosition) {
      var _this3 = this;

      var dataContainer = _ref4.dataContainer,
          filteredIndex = _ref4.filteredIndex,
          gpuFilter = _ref4.gpuFilter;

      var getGeometry = function getGeometry(d) {
        return _this3.getGeometry(getPosition(d));
      };

      var vcFields = Object.values(this.visualChannels).map(function (v) {
        return _this3.config[v.field];
      }).filter(function (v) {
        return v;
      });
      var getPropertyFromVisualChanel = vcFields.length ? function (d) {
        return vcFields.reduce(function (accu, field) {
          return _objectSpread(_objectSpread({}, accu), {}, (0, _defineProperty2["default"])({}, field.name, field.valueAccessor(d)));
        }, {});
      } : function (d) {
        return {};
      };
      var filterValueUpdateTriggers = gpuFilter.filterValueUpdateTriggers,
          filterValueAccessor = gpuFilter.filterValueAccessor; // gpuField To property

      var hasFilter = Object.values(filterValueUpdateTriggers).filter(function (d) {
        return d;
      }).length;
      var valueAccessor = filterValueAccessor(dataContainer)();
      var getPropertyFromFilter = hasFilter ? function (d) {
        var filterValue = valueAccessor(d);
        return Object.values(filterValueUpdateTriggers).reduce(function (accu, name, i) {
          return _objectSpread(_objectSpread({}, accu), name ? (0, _defineProperty2["default"])({}, (0, _mapboxUtils.prefixGpuField)(name), filterValue[i]) : {});
        }, {});
      } : function (d) {
        return {};
      };

      var getProperties = function getProperties(d) {
        return _objectSpread(_objectSpread({}, getPropertyFromVisualChanel(d)), getPropertyFromFilter(d));
      };

      return (0, _mapboxUtils.geoJsonFromData)(filteredIndex, getGeometry, getProperties);
    } // this layer is rendered at mapbox level
    // todo: maybe need to find a better solution for this one

  }, {
    key: "shouldRenderLayer",
    value: function shouldRenderLayer() {
      return typeof this.type === 'string' && this.config.isVisible && this.hasAllColumns();
    }
  }]);
  return MapboxLayerGL;
}(_baseLayer["default"]);

var _default = MapboxLayerGL;
exports["default"] = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9tYXBib3hnbC1sYXllci50cyJdLCJuYW1lcyI6WyJtYXBib3hSZXF1aXJlZENvbHVtbnMiLCJwb2ludENvbFJlc29sdmVyIiwibGF0IiwibG5nIiwiZmllbGRJZHgiLCJNYXBib3hMYXllckdMIiwiY29uZmlnIiwiZGF0YUlkIiwiZGF0YXNldHMiLCJncHVGaWx0ZXIiLCJjb2x1bW5zIiwiZGF0YXNldFNlbGVjdG9yIiwiY29sdW1uc1NlbGVjdG9yIiwiZGF0YXNldElkIiwiZ3B1RmlsdGVyU2VsZWN0b3IiLCJPVkVSTEFZX1RZUEVfQ09OU1QiLCJtYXBib3hnbCIsImRlZmF1bHRQb2ludENvbHVtblBhaXJzIiwiZmlsdGVyIiwiQXJyYXkiLCJpc0FycmF5IiwibGVuZ3RoIiwiZmlsdGVyZWRJbmRleCIsImlkIiwidmlzdWFsQ2hhbm5lbEZpZWxkcyIsIk9iamVjdCIsInZhbHVlcyIsInZpc3VhbENoYW5uZWxzIiwicmVkdWNlIiwiYWNjdSIsInYiLCJmaWVsZCIsIm5hbWUiLCJ1cGRhdGVUcmlnZ2VycyIsImdldERhdGEiLCJmaWx0ZXJWYWx1ZVVwZGF0ZVRyaWdnZXJzIiwiZ2V0TWV0YSIsInBvc2l0aW9uIiwiZXZlcnkiLCJOdW1iZXIiLCJpc0Zpbml0ZSIsInR5cGUiLCJjb29yZGluYXRlcyIsImdldFBvc2l0aW9uIiwiZGF0YUNvbnRhaW5lciIsImdldEdlb21ldHJ5IiwiZCIsInZjRmllbGRzIiwibWFwIiwiZ2V0UHJvcGVydHlGcm9tVmlzdWFsQ2hhbmVsIiwidmFsdWVBY2Nlc3NvciIsImZpbHRlclZhbHVlQWNjZXNzb3IiLCJoYXNGaWx0ZXIiLCJnZXRQcm9wZXJ0eUZyb21GaWx0ZXIiLCJmaWx0ZXJWYWx1ZSIsImkiLCJnZXRQcm9wZXJ0aWVzIiwiaXNWaXNpYmxlIiwiaGFzQWxsQ29sdW1ucyIsIkxheWVyIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBb0JBOztBQU1BOztBQUVBOzs7Ozs7Ozs7O0FB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SUFBMEQsS0FBS0MsYUFBTCxFQUFqRTtBQUNEOzs7RUFySXlCQyxxQjs7ZUF3SWJ0RCxhIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDIyIFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuaW1wb3J0IExheWVyLCB7XG4gIExheWVyQmFzZUNvbmZpZyxcbiAgTGF5ZXJDb2x1bW4sXG4gIE9WRVJMQVlfVFlQRV9DT05TVCxcbiAgVmlzdWFsQ2hhbm5lbHNcbn0gZnJvbSAnLi9iYXNlLWxheWVyJztcbmltcG9ydCB7Y3JlYXRlU2VsZWN0b3J9IGZyb20gJ3Jlc2VsZWN0JztcblxuaW1wb3J0IHtnZW9Kc29uRnJvbURhdGEsIHByZWZpeEdwdUZpZWxkLCBncHVGaWx0ZXJUb01hcGJveEZpbHRlcn0gZnJvbSAnLi9tYXBib3gtdXRpbHMnO1xuaW1wb3J0IHtkZWZhdWx0IGFzIEtlcGxlclRhYmxlfSBmcm9tICdAa2VwbGVyLmdsL3RhYmxlJztcbmltcG9ydCB7TWVyZ2V9IGZyb20gJ0BrZXBsZXIuZ2wvdHlwZXMnO1xuXG50eXBlIE1hcGJveExheWVyR0xDb2x1bW5zID0ge1xuICBsYXQ6IExheWVyQ29sdW1uO1xuICBsbmc6IExheWVyQ29sdW1uO1xufTtcblxuZXhwb3J0IHR5cGUgTWFwYm94TGF5ZXJHTENvbmZpZyA9IE1lcmdlPExheWVyQmFzZUNvbmZpZywge2NvbHVtbnM6IE1hcGJveExheWVyR0xDb2x1bW5zfT47XG5cbmV4cG9ydCBjb25zdCBtYXBib3hSZXF1aXJlZENvbHVtbnM6IFsnbGF0JywgJ2xuZyddID0gWydsYXQnLCAnbG5nJ107XG5cbmV4cG9ydCBjb25zdCBwb2ludENvbFJlc29sdmVyID0gKHtsYXQsIGxuZ306IE1hcGJveExheWVyR0xDb2x1bW5zKSA9PlxuICBgJHtsYXQuZmllbGRJZHh9LSR7bG5nLmZpZWxkSWR4fWA7XG5cbmNsYXNzIE1hcGJveExheWVyR0wgZXh0ZW5kcyBMYXllciB7XG4gIGRlY2xhcmUgY29uZmlnOiBNYXBib3hMYXllckdMQ29uZmlnO1xuXG4gIGdldCBvdmVybGF5VHlwZSgpIHtcbiAgICByZXR1cm4gT1ZFUkxBWV9UWVBFX0NPTlNULm1hcGJveGdsO1xuICB9XG5cbiAgZ2V0IHR5cGUoKTogc3RyaW5nIHwgbnVsbCB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBnZXQgaXNBZ2dyZWdhdGVkKCk6IHRydWUge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgZ2V0IHJlcXVpcmVkTGF5ZXJDb2x1bW5zKCkge1xuICAgIHJldHVybiBtYXBib3hSZXF1aXJlZENvbHVtbnM7XG4gIH1cblxuICBnZXQgY29sdW1uUGFpcnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVmYXVsdFBvaW50Q29sdW1uUGFpcnM7XG4gIH1cblxuICBnZXQgbm9uZUxheWVyRGF0YUFmZmVjdGluZ1Byb3BzKCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIGdldCB2aXN1YWxDaGFubmVscygpOiBWaXN1YWxDaGFubmVscyB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG4gIGRhdGFzZXRTZWxlY3RvciA9IChjb25maWc6IE1hcGJveExheWVyR0xDb25maWcpID0+IGNvbmZpZy5kYXRhSWQ7XG4gIGdwdUZpbHRlclNlbGVjdG9yID0gKGNvbmZpZzogTWFwYm94TGF5ZXJHTENvbmZpZywgZGF0YXNldHMpID0+XG4gICAgKChjb25maWcuZGF0YUlkICYmIGRhdGFzZXRzW2NvbmZpZy5kYXRhSWRdKSB8fCB7fSkuZ3B1RmlsdGVyO1xuICBjb2x1bW5zU2VsZWN0b3IgPSAoY29uZmlnOiBNYXBib3hMYXllckdMQ29uZmlnKSA9PiBwb2ludENvbFJlc29sdmVyKGNvbmZpZy5jb2x1bW5zKTtcblxuICBzb3VyY2VTZWxlY3RvciA9IGNyZWF0ZVNlbGVjdG9yKFxuICAgIHRoaXMuZGF0YXNldFNlbGVjdG9yLFxuICAgIHRoaXMuY29sdW1uc1NlbGVjdG9yLFxuICAgIChkYXRhc2V0SWQsIGNvbHVtbnMpID0+IGAke2RhdGFzZXRJZH0tJHtjb2x1bW5zfWBcbiAgKTtcblxuICBmaWx0ZXJTZWxlY3RvciA9IGNyZWF0ZVNlbGVjdG9yKHRoaXMuZ3B1RmlsdGVyU2VsZWN0b3IsIGdwdUZpbHRlciA9PlxuICAgIGdwdUZpbHRlclRvTWFwYm94RmlsdGVyKGdwdUZpbHRlcilcbiAgKTtcblxuICBpc1ZhbGlkRmlsdGVyKGZpbHRlcikge1xuICAgIC8vIG1hcGJveCB3aWxsIGNyYXNoIGlmIGZpbHRlciBpcyBub3QgYW4gYXJyYXkgb3IgZW1wdHlcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShmaWx0ZXIpICYmIGZpbHRlci5sZW5ndGg7XG4gIH1cblxuICBnZXREYXRhVXBkYXRlVHJpZ2dlcnMoe2ZpbHRlcmVkSW5kZXgsIGdwdUZpbHRlciwgaWR9OiBLZXBsZXJUYWJsZSk6IGFueSB7XG4gICAgY29uc3Qge2NvbHVtbnN9ID0gdGhpcy5jb25maWc7XG5cbiAgICBjb25zdCB2aXN1YWxDaGFubmVsRmllbGRzID0gT2JqZWN0LnZhbHVlcyh0aGlzLnZpc3VhbENoYW5uZWxzKS5yZWR1Y2UoXG4gICAgICAoYWNjdSwgdikgPT4gKHtcbiAgICAgICAgLi4uYWNjdSxcbiAgICAgICAgLi4uKHRoaXMuY29uZmlnW3YuZmllbGRdID8ge1t2LmZpZWxkXTogdGhpcy5jb25maWdbdi5maWVsZF0ubmFtZX0gOiB7fSlcbiAgICAgIH0pLFxuICAgICAge31cbiAgICApO1xuXG4gICAgY29uc3QgdXBkYXRlVHJpZ2dlcnMgPSB7XG4gICAgICBnZXREYXRhOiB7XG4gICAgICAgIGRhdGFzZXRJZDogaWQsXG4gICAgICAgIGNvbHVtbnMsXG4gICAgICAgIGZpbHRlcmVkSW5kZXgsXG4gICAgICAgIC4uLnZpc3VhbENoYW5uZWxGaWVsZHMsXG4gICAgICAgIC4uLmdwdUZpbHRlci5maWx0ZXJWYWx1ZVVwZGF0ZVRyaWdnZXJzXG4gICAgICB9LFxuICAgICAgZ2V0TWV0YToge2RhdGFzZXRJZDogaWQsIGNvbHVtbnN9XG4gICAgfTtcblxuICAgIHJldHVybiB1cGRhdGVUcmlnZ2VycztcbiAgfVxuXG4gIGdldEdlb21ldHJ5KHBvc2l0aW9uKSB7XG4gICAgcmV0dXJuIHBvc2l0aW9uLmV2ZXJ5KE51bWJlci5pc0Zpbml0ZSlcbiAgICAgID8ge1xuICAgICAgICAgIHR5cGU6ICdQb2ludCcsXG4gICAgICAgICAgY29vcmRpbmF0ZXM6IHBvc2l0aW9uXG4gICAgICAgIH1cbiAgICAgIDogbnVsbDtcbiAgfVxuXG4gIGNhbGN1bGF0ZURhdGFBdHRyaWJ1dGUoe2RhdGFDb250YWluZXIsIGZpbHRlcmVkSW5kZXgsIGdwdUZpbHRlcn06IEtlcGxlclRhYmxlLCBnZXRQb3NpdGlvbikge1xuICAgIGNvbnN0IGdldEdlb21ldHJ5ID0gZCA9PiB0aGlzLmdldEdlb21ldHJ5KGdldFBvc2l0aW9uKGQpKTtcblxuICAgIGNvbnN0IHZjRmllbGRzID0gT2JqZWN0LnZhbHVlcyh0aGlzLnZpc3VhbENoYW5uZWxzKVxuICAgICAgLm1hcCh2ID0+IHRoaXMuY29uZmlnW3YuZmllbGRdKVxuICAgICAgLmZpbHRlcih2ID0+IHYpO1xuXG4gICAgY29uc3QgZ2V0UHJvcGVydHlGcm9tVmlzdWFsQ2hhbmVsID0gdmNGaWVsZHMubGVuZ3RoXG4gICAgICA/IGQgPT5cbiAgICAgICAgICB2Y0ZpZWxkcy5yZWR1Y2UoXG4gICAgICAgICAgICAoYWNjdSwgZmllbGQpID0+ICh7XG4gICAgICAgICAgICAgIC4uLmFjY3UsXG4gICAgICAgICAgICAgIFtmaWVsZC5uYW1lXTogZmllbGQudmFsdWVBY2Nlc3NvcihkKVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB7fVxuICAgICAgICAgIClcbiAgICAgIDogZCA9PiAoe30pO1xuXG4gICAgY29uc3Qge2ZpbHRlclZhbHVlVXBkYXRlVHJpZ2dlcnMsIGZpbHRlclZhbHVlQWNjZXNzb3J9ID0gZ3B1RmlsdGVyO1xuXG4gICAgLy8gZ3B1RmllbGQgVG8gcHJvcGVydHlcbiAgICBjb25zdCBoYXNGaWx0ZXIgPSBPYmplY3QudmFsdWVzKGZpbHRlclZhbHVlVXBkYXRlVHJpZ2dlcnMpLmZpbHRlcihkID0+IGQpLmxlbmd0aDtcbiAgICBjb25zdCB2YWx1ZUFjY2Vzc29yID0gZmlsdGVyVmFsdWVBY2Nlc3NvcihkYXRhQ29udGFpbmVyKSgpO1xuXG4gICAgY29uc3QgZ2V0UHJvcGVydHlGcm9tRmlsdGVyID0gaGFzRmlsdGVyXG4gICAgICA/IGQgPT4ge1xuICAgICAgICAgIGNvbnN0IGZpbHRlclZhbHVlID0gdmFsdWVBY2Nlc3NvcihkKTtcbiAgICAgICAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyhmaWx0ZXJWYWx1ZVVwZGF0ZVRyaWdnZXJzKS5yZWR1Y2UoXG4gICAgICAgICAgICAoYWNjdTogYW55LCBuYW1lLCBpKSA9PiAoe1xuICAgICAgICAgICAgICAuLi5hY2N1LFxuICAgICAgICAgICAgICAuLi4obmFtZSA/IHtbcHJlZml4R3B1RmllbGQobmFtZSldOiBmaWx0ZXJWYWx1ZVtpXX0gOiB7fSlcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAge31cbiAgICAgICAgICApIGFzIGFueTtcbiAgICAgICAgfVxuICAgICAgOiBkID0+ICh7fSBhcyBhbnkpO1xuXG4gICAgY29uc3QgZ2V0UHJvcGVydGllcyA9IGQgPT4gKHtcbiAgICAgIC4uLmdldFByb3BlcnR5RnJvbVZpc3VhbENoYW5lbChkKSxcbiAgICAgIC4uLmdldFByb3BlcnR5RnJvbUZpbHRlcihkKVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGdlb0pzb25Gcm9tRGF0YShmaWx0ZXJlZEluZGV4LCBnZXRHZW9tZXRyeSwgZ2V0UHJvcGVydGllcyk7XG4gIH1cblxuICAvLyB0aGlzIGxheWVyIGlzIHJlbmRlcmVkIGF0IG1hcGJveCBsZXZlbFxuICAvLyB0b2RvOiBtYXliZSBuZWVkIHRvIGZpbmQgYSBiZXR0ZXIgc29sdXRpb24gZm9yIHRoaXMgb25lXG4gIHNob3VsZFJlbmRlckxheWVyKCkge1xuICAgIHJldHVybiB0eXBlb2YgdGhpcy50eXBlID09PSAnc3RyaW5nJyAmJiB0aGlzLmNvbmZpZy5pc1Zpc2libGUgJiYgdGhpcy5oYXNBbGxDb2x1bW5zKCk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTWFwYm94TGF5ZXJHTDtcbiJdfQ==