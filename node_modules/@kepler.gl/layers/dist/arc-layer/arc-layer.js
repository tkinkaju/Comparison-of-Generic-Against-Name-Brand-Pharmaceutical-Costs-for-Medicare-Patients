// Copyright (c) 2022 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = exports.arcVisConfigs = exports.arcColumnLabels = exports.arcRequiredColumns = exports.arcPosAccessor = void 0;

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _baseLayer = _interopRequireDefault(require("../base-layer"));

var _extensions = require("@deck.gl/extensions");

var _layers = require("@deck.gl/layers");

var _utils = require("@kepler.gl/utils");

var _arcLayerIcon = _interopRequireDefault(require("./arc-layer-icon"));

var _constants = require("@kepler.gl/constants");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var arcPosAccessor = function arcPosAccessor(_ref) {
  var lat0 = _ref.lat0,
      lng0 = _ref.lng0,
      lat1 = _ref.lat1,
      lng1 = _ref.lng1;
  return function (dc) {
    return function (d) {
      return [dc.valueAt(d.index, lng0.fieldIdx), dc.valueAt(d.index, lat0.fieldIdx), 0, dc.valueAt(d.index, lng1.fieldIdx), dc.valueAt(d.index, lat1.fieldIdx), 0];
    };
  };
};

exports.arcPosAccessor = arcPosAccessor;
var arcRequiredColumns = ['lat0', 'lng0', 'lat1', 'lng1'];
exports.arcRequiredColumns = arcRequiredColumns;
var arcColumnLabels = {
  lat0: 'arc.lat0',
  lng0: 'arc.lng0',
  lat1: 'arc.lat1',
  lng1: 'arc.lng1'
};
exports.arcColumnLabels = arcColumnLabels;
var arcVisConfigs = {
  opacity: 'opacity',
  thickness: 'thickness',
  colorRange: 'colorRange',
  sizeRange: 'strokeWidthRange',
  targetColor: 'targetColor'
};
exports.arcVisConfigs = arcVisConfigs;

var ArcLayer = /*#__PURE__*/function (_Layer) {
  (0, _inherits2["default"])(ArcLayer, _Layer);

  var _super = _createSuper(ArcLayer);

  function ArcLayer(props) {
    var _this;

    (0, _classCallCheck2["default"])(this, ArcLayer);
    _this = _super.call(this, props);

    _this.registerVisConfig(arcVisConfigs);

    _this.getPositionAccessor = function (dataContainer) {
      return arcPosAccessor(_this.config.columns)(dataContainer);
    };

    return _this;
  }

  (0, _createClass2["default"])(ArcLayer, [{
    key: "type",
    get: function get() {
      return 'arc';
    }
  }, {
    key: "isAggregated",
    get: function get() {
      return false;
    }
  }, {
    key: "layerIcon",
    get: function get() {
      return _arcLayerIcon["default"];
    }
  }, {
    key: "requiredLayerColumns",
    get: function get() {
      return arcRequiredColumns;
    }
  }, {
    key: "columnLabels",
    get: function get() {
      return arcColumnLabels;
    }
  }, {
    key: "columnPairs",
    get: function get() {
      return this.defaultLinkColumnPairs;
    }
  }, {
    key: "visualChannels",
    get: function get() {
      return {
        sourceColor: _objectSpread(_objectSpread({}, (0, _get2["default"])((0, _getPrototypeOf2["default"])(ArcLayer.prototype), "visualChannels", this).color), {}, {
          property: 'color',
          key: 'sourceColor',
          accessor: 'getSourceColor',
          defaultValue: function defaultValue(config) {
            return config.color;
          }
        }),
        targetColor: _objectSpread(_objectSpread({}, (0, _get2["default"])((0, _getPrototypeOf2["default"])(ArcLayer.prototype), "visualChannels", this).color), {}, {
          property: 'targetColor',
          key: 'targetColor',
          accessor: 'getTargetColor',
          defaultValue: function defaultValue(config) {
            return config.visConfig.targetColor || config.color;
          }
        }),
        size: _objectSpread(_objectSpread({}, (0, _get2["default"])((0, _getPrototypeOf2["default"])(ArcLayer.prototype), "visualChannels", this).size), {}, {
          accessor: 'getWidth',
          property: 'stroke'
        })
      };
    }
  }, {
    key: "calculateDataAttribute",
    value: function calculateDataAttribute(_ref2, getPosition) {
      var dataContainer = _ref2.dataContainer,
          filteredIndex = _ref2.filteredIndex;
      var data = [];

      for (var i = 0; i < filteredIndex.length; i++) {
        var index = filteredIndex[i];
        var pos = getPosition({
          index: index
        }); // if doesn't have point lat or lng, do not add the point
        // deck.gl can't handle position = null

        if (pos.every(Number.isFinite)) {
          data.push({
            index: index,
            sourcePosition: [pos[0], pos[1], pos[2]],
            targetPosition: [pos[3], pos[4], pos[5]]
          });
        }
      }

      return data;
    }
  }, {
    key: "formatLayerData",
    value: function formatLayerData(datasets, oldLayerData) {
      if (this.config.dataId === null) {
        return {};
      }

      var _datasets$this$config = datasets[this.config.dataId],
          gpuFilter = _datasets$this$config.gpuFilter,
          dataContainer = _datasets$this$config.dataContainer;

      var _this$updateData = this.updateData(datasets, oldLayerData),
          data = _this$updateData.data;

      var accessors = this.getAttributeAccessors({
        dataContainer: dataContainer
      });
      return _objectSpread({
        data: data,
        getFilterValue: gpuFilter.filterValueAccessor(dataContainer)()
      }, accessors);
    }
    /* eslint-enable complexity */

  }, {
    key: "updateLayerMeta",
    value: function updateLayerMeta(dataContainer) {
      // get bounds from arcs
      var getPosition = this.getPositionAccessor(dataContainer);
      var sBounds = this.getPointsBounds(dataContainer, function (d, i) {
        var pos = getPosition(d);
        return [pos[0], pos[1]];
      });
      var tBounds = this.getPointsBounds(dataContainer, function (d, i) {
        var pos = getPosition(d);
        return [pos[3], pos[4]];
      });
      var bounds = tBounds && sBounds ? [Math.min(sBounds[0], tBounds[0]), Math.min(sBounds[1], tBounds[1]), Math.max(sBounds[2], tBounds[2]), Math.max(sBounds[3], tBounds[3])] : sBounds || tBounds;
      this.updateMeta({
        bounds: bounds
      });
    }
  }, {
    key: "renderLayer",
    value: function renderLayer(opts) {
      var data = opts.data,
          gpuFilter = opts.gpuFilter,
          objectHovered = opts.objectHovered,
          interactionConfig = opts.interactionConfig;

      var updateTriggers = _objectSpread({
        getPosition: this.config.columns,
        getFilterValue: gpuFilter.filterValueUpdateTriggers
      }, this.getVisualChannelUpdateTriggers());

      var widthScale = this.config.visConfig.thickness * _constants.PROJECTED_PIXEL_SIZE_MULTIPLIER;
      var defaultLayerProps = this.getDefaultDeckLayerProps(opts);
      var hoveredObject = this.hasHoveredObject(objectHovered);
      return [new _layers.ArcLayer(_objectSpread(_objectSpread(_objectSpread(_objectSpread({}, defaultLayerProps), this.getBrushingExtensionProps(interactionConfig, 'source_target')), data), {}, {
        widthScale: widthScale,
        updateTriggers: updateTriggers,
        extensions: [].concat((0, _toConsumableArray2["default"])(defaultLayerProps.extensions), [new _extensions.BrushingExtension()])
      }))].concat((0, _toConsumableArray2["default"])(hoveredObject ? [new _layers.ArcLayer(_objectSpread(_objectSpread({}, this.getDefaultHoverLayerProps()), {}, {
        data: [hoveredObject],
        widthScale: widthScale,
        getSourceColor: this.config.highlightColor,
        getTargetColor: this.config.highlightColor,
        getWidth: data.getWidth
      }))] : []));
    }
  }], [{
    key: "findDefaultLayerProps",
    value: function findDefaultLayerProps(_ref3) {
      var _ref3$fieldPairs = _ref3.fieldPairs,
          fieldPairs = _ref3$fieldPairs === void 0 ? [] : _ref3$fieldPairs;

      if (fieldPairs.length < 2) {
        return {
          props: []
        };
      }

      var props = {
        color: (0, _utils.hexToRgb)(_constants.DEFAULT_LAYER_COLOR.tripArc),
        // connect the first two point layer with arc
        columns: {
          lat0: fieldPairs[0].pair.lat,
          lng0: fieldPairs[0].pair.lng,
          lat1: fieldPairs[1].pair.lat,
          lng1: fieldPairs[1].pair.lng
        },
        label: "".concat(fieldPairs[0].defaultName, " -> ").concat(fieldPairs[1].defaultName, " arc")
      };
      return {
        props: [props]
      };
    }
  }]);
  return ArcLayer;
}(_baseLayer["default"]);

exports["default"] = ArcLayer;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9hcmMtbGF5ZXIvYXJjLWxheWVyLnRzIl0sIm5hbWVzIjpbImFyY1Bvc0FjY2Vzc29yIiwibGF0MCIsImxuZzAiLCJsYXQxIiwibG5nMSIsImRjIiwiZCIsInZhbHVlQXQiLCJpbmRleCIsImZpZWxkSWR4IiwiYXJjUmVxdWlyZWRDb2x1bW5zIiwiYXJjQ29sdW1uTGFiZWxzIiwiYXJjVmlzQ29uZmlncyIsIm9wYWNpdHkiLCJ0aGlja25lc3MiLCJjb2xvclJhbmdlIiwic2l6ZVJhbmdlIiwidGFyZ2V0Q29sb3IiLCJBcmNMYXllciIsInByb3BzIiwicmVnaXN0ZXJWaXNDb25maWciLCJnZXRQb3NpdGlvbkFjY2Vzc29yIiwiZGF0YUNvbnRhaW5lciIsImNvbmZpZyIsImNvbHVtbnMiLCJBcmNMYXllckljb24iLCJkZWZhdWx0TGlua0NvbHVtblBhaXJzIiwic291cmNlQ29sb3IiLCJjb2xvciIsInByb3BlcnR5Iiwia2V5IiwiYWNjZXNzb3IiLCJkZWZhdWx0VmFsdWUiLCJ2aXNDb25maWciLCJzaXplIiwiZ2V0UG9zaXRpb24iLCJmaWx0ZXJlZEluZGV4IiwiZGF0YSIsImkiLCJsZW5ndGgiLCJwb3MiLCJldmVyeSIsIk51bWJlciIsImlzRmluaXRlIiwicHVzaCIsInNvdXJjZVBvc2l0aW9uIiwidGFyZ2V0UG9zaXRpb24iLCJkYXRhc2V0cyIsIm9sZExheWVyRGF0YSIsImRhdGFJZCIsImdwdUZpbHRlciIsInVwZGF0ZURhdGEiLCJhY2Nlc3NvcnMiLCJnZXRBdHRyaWJ1dGVBY2Nlc3NvcnMiLCJnZXRGaWx0ZXJWYWx1ZSIsImZpbHRlclZhbHVlQWNjZXNzb3IiLCJzQm91bmRzIiwiZ2V0UG9pbnRzQm91bmRzIiwidEJvdW5kcyIsImJvdW5kcyIsIk1hdGgiLCJtaW4iLCJtYXgiLCJ1cGRhdGVNZXRhIiwib3B0cyIsIm9iamVjdEhvdmVyZWQiLCJpbnRlcmFjdGlvbkNvbmZpZyIsInVwZGF0ZVRyaWdnZXJzIiwiZmlsdGVyVmFsdWVVcGRhdGVUcmlnZ2VycyIsImdldFZpc3VhbENoYW5uZWxVcGRhdGVUcmlnZ2VycyIsIndpZHRoU2NhbGUiLCJQUk9KRUNURURfUElYRUxfU0laRV9NVUxUSVBMSUVSIiwiZGVmYXVsdExheWVyUHJvcHMiLCJnZXREZWZhdWx0RGVja0xheWVyUHJvcHMiLCJob3ZlcmVkT2JqZWN0IiwiaGFzSG92ZXJlZE9iamVjdCIsIkRlY2tBcmNMYXllciIsImdldEJydXNoaW5nRXh0ZW5zaW9uUHJvcHMiLCJleHRlbnNpb25zIiwiQnJ1c2hpbmdFeHRlbnNpb24iLCJnZXREZWZhdWx0SG92ZXJMYXllclByb3BzIiwiZ2V0U291cmNlQ29sb3IiLCJoaWdobGlnaHRDb2xvciIsImdldFRhcmdldENvbG9yIiwiZ2V0V2lkdGgiLCJmaWVsZFBhaXJzIiwiREVGQVVMVF9MQVlFUl9DT0xPUiIsInRyaXBBcmMiLCJwYWlyIiwibGF0IiwibG5nIiwibGFiZWwiLCJkZWZhdWx0TmFtZSIsIkxheWVyIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBb0JBOztBQU9BOztBQUNBOztBQUVBOztBQUNBOztBQUNBOzs7Ozs7Ozs7O0FBdURPLElBQU1BLGNBQWMsR0FBRyxTQUFqQkEsY0FBaUI7QUFBQSxNQUFFQyxJQUFGLFFBQUVBLElBQUY7QUFBQSxNQUFRQyxJQUFSLFFBQVFBLElBQVI7QUFBQSxNQUFjQyxJQUFkLFFBQWNBLElBQWQ7QUFBQSxNQUFvQkMsSUFBcEIsUUFBb0JBLElBQXBCO0FBQUEsU0FBcUQsVUFDakZDLEVBRGlGO0FBQUEsV0FFOUUsVUFBQUMsQ0FBQztBQUFBLGFBQUksQ0FDUkQsRUFBRSxDQUFDRSxPQUFILENBQVdELENBQUMsQ0FBQ0UsS0FBYixFQUFvQk4sSUFBSSxDQUFDTyxRQUF6QixDQURRLEVBRVJKLEVBQUUsQ0FBQ0UsT0FBSCxDQUFXRCxDQUFDLENBQUNFLEtBQWIsRUFBb0JQLElBQUksQ0FBQ1EsUUFBekIsQ0FGUSxFQUdSLENBSFEsRUFJUkosRUFBRSxDQUFDRSxPQUFI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QUFxQ1AsVUFBVSxDQUFDLENBQUQsQ0FBVixDQUFjTyxXQUFuRDtBQVR5RSxPQUFoRjtBQVlBLGFBQU87QUFBQ3pFLFFBQUFBLEtBQUssRUFBRSxDQUFDQSxLQUFEO0FBQVIsT0FBUDtBQUNEOzs7RUFoRm1DMEUscUIiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMjIgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5pbXBvcnQgTGF5ZXIsIHtcbiAgTGF5ZXJDb2x1bW4sXG4gIExheWVyQmFzZUNvbmZpZyxcbiAgTGF5ZXJDb2xvckNvbmZpZyxcbiAgTGF5ZXJTaXplQ29uZmlnLFxuICBMYXllckJvdW5kc1xufSBmcm9tICcuLi9iYXNlLWxheWVyJztcbmltcG9ydCB7QnJ1c2hpbmdFeHRlbnNpb259IGZyb20gJ0BkZWNrLmdsL2V4dGVuc2lvbnMnO1xuaW1wb3J0IHtBcmNMYXllciBhcyBEZWNrQXJjTGF5ZXJ9IGZyb20gJ0BkZWNrLmdsL2xheWVycyc7XG5cbmltcG9ydCB7aGV4VG9SZ2IsIERhdGFDb250YWluZXJJbnRlcmZhY2V9IGZyb20gJ0BrZXBsZXIuZ2wvdXRpbHMnO1xuaW1wb3J0IEFyY0xheWVySWNvbiBmcm9tICcuL2FyYy1sYXllci1pY29uJztcbmltcG9ydCB7XG4gIERFRkFVTFRfTEFZRVJfQ09MT1IsXG4gIENvbG9yUmFuZ2UsXG4gIFBST0pFQ1RFRF9QSVhFTF9TSVpFX01VTFRJUExJRVJcbn0gZnJvbSAnQGtlcGxlci5nbC9jb25zdGFudHMnO1xuXG5pbXBvcnQge1xuICBSR0JDb2xvcixcbiAgTWVyZ2UsXG4gIFZpc0NvbmZpZ0NvbG9yUmFuZ2UsXG4gIFZpc0NvbmZpZ0NvbG9yU2VsZWN0LFxuICBWaXNDb25maWdOdW1iZXIsXG4gIFZpc0NvbmZpZ1JhbmdlXG59IGZyb20gJ0BrZXBsZXIuZ2wvdHlwZXMnO1xuaW1wb3J0IHtLZXBsZXJUYWJsZX0gZnJvbSAnQGtlcGxlci5nbC90YWJsZSc7XG5cbmV4cG9ydCB0eXBlIEFyY0xheWVyVmlzQ29uZmlnU2V0dGluZ3MgPSB7XG4gIG9wYWNpdHk6IFZpc0NvbmZpZ051bWJlcjtcbiAgdGhpY2tuZXNzOiBWaXNDb25maWdOdW1iZXI7XG4gIGNvbG9yUmFuZ2U6IFZpc0NvbmZpZ0NvbG9yUmFuZ2U7XG4gIHNpemVSYW5nZTogVmlzQ29uZmlnUmFuZ2U7XG4gIHRhcmdldENvbG9yOiBWaXNDb25maWdDb2xvclNlbGVjdDtcbn07XG5cbmV4cG9ydCB0eXBlIEFyY0xheWVyQ29sdW1uc0NvbmZpZyA9IHtcbiAgbGF0MDogTGF5ZXJDb2x1bW47XG4gIGxhdDE6IExheWVyQ29sdW1uO1xuICBsbmcwOiBMYXllckNvbHVtbjtcbiAgbG5nMTogTGF5ZXJDb2x1bW47XG59O1xuXG5leHBvcnQgdHlwZSBBcmNMYXllclZpc0NvbmZpZyA9IHtcbiAgY29sb3JSYW5nZTogQ29sb3JSYW5nZTtcbiAgb3BhY2l0eTogbnVtYmVyO1xuICBzaXplUmFuZ2U6IFtudW1iZXIsIG51bWJlcl07XG4gIHRhcmdldENvbG9yOiBSR0JDb2xvcjtcbiAgdGhpY2tuZXNzOiBudW1iZXI7XG59O1xuXG5leHBvcnQgdHlwZSBBcmNMYXllclZpc3VhbENoYW5uZWxDb25maWcgPSBMYXllckNvbG9yQ29uZmlnICYgTGF5ZXJTaXplQ29uZmlnO1xuZXhwb3J0IHR5cGUgQXJjTGF5ZXJDb25maWcgPSBNZXJnZTxcbiAgTGF5ZXJCYXNlQ29uZmlnLFxuICB7Y29sdW1uczogQXJjTGF5ZXJDb2x1bW5zQ29uZmlnOyB2aXNDb25maWc6IEFyY0xheWVyVmlzQ29uZmlnfVxuPiAmXG4gIEFyY0xheWVyVmlzdWFsQ2hhbm5lbENvbmZpZztcblxuZXhwb3J0IHR5cGUgQXJjTGF5ZXJEYXRhID0ge1xuICBpbmRleDogbnVtYmVyO1xuICBzb3VyY2VQb3NpdGlvbjogW251bWJlciwgbnVtYmVyLCBudW1iZXJdO1xuICB0YXJnZXRQb3NpdGlvbjogW251bWJlciwgbnVtYmVyLCBudW1iZXJdO1xufTtcblxuZXhwb3J0IHR5cGUgQXJjTGF5ZXJNZXRhID0ge1xuICBib3VuZHM6IExheWVyQm91bmRzO1xufTtcbmV4cG9ydCBjb25zdCBhcmNQb3NBY2Nlc3NvciA9ICh7bGF0MCwgbG5nMCwgbGF0MSwgbG5nMX06IEFyY0xheWVyQ29sdW1uc0NvbmZpZykgPT4gKFxuICBkYzogRGF0YUNvbnRhaW5lckludGVyZmFjZVxuKSA9PiBkID0+IFtcbiAgZGMudmFsdWVBdChkLmluZGV4LCBsbmcwLmZpZWxkSWR4KSxcbiAgZGMudmFsdWVBdChkLmluZGV4LCBsYXQwLmZpZWxkSWR4KSxcbiAgMCxcbiAgZGMudmFsdWVBdChkLmluZGV4LCBsbmcxLmZpZWxkSWR4KSxcbiAgZGMudmFsdWVBdChkLmluZGV4LCBsYXQxLmZpZWxkSWR4KSxcbiAgMFxuXTtcblxuZXhwb3J0IGNvbnN0IGFyY1JlcXVpcmVkQ29sdW1ucyA9IFsnbGF0MCcsICdsbmcwJywgJ2xhdDEnLCAnbG5nMSddO1xuZXhwb3J0IGNvbnN0IGFyY0NvbHVtbkxhYmVscyA9IHtcbiAgbGF0MDogJ2FyYy5sYXQwJyxcbiAgbG5nMDogJ2FyYy5sbmcwJyxcbiAgbGF0MTogJ2FyYy5sYXQxJyxcbiAgbG5nMTogJ2FyYy5sbmcxJ1xufTtcblxuZXhwb3J0IGNvbnN0IGFyY1Zpc0NvbmZpZ3M6IHtcbiAgb3BhY2l0eTogJ29wYWNpdHknO1xuICB0aGlja25lc3M6ICd0aGlja25lc3MnO1xuICBjb2xvclJhbmdlOiAnY29sb3JSYW5nZSc7XG4gIHNpemVSYW5nZTogJ3N0cm9rZVdpZHRoUmFuZ2UnO1xuICB0YXJnZXRDb2xvcjogJ3RhcmdldENvbG9yJztcbn0gPSB7XG4gIG9wYWNpdHk6ICdvcGFjaXR5JyxcbiAgdGhpY2tuZXNzOiAndGhpY2tuZXNzJyxcbiAgY29sb3JSYW5nZTogJ2NvbG9yUmFuZ2UnLFxuICBzaXplUmFuZ2U6ICdzdHJva2VXaWR0aFJhbmdlJyxcbiAgdGFyZ2V0Q29sb3I6ICd0YXJnZXRDb2xvcidcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFyY0xheWVyIGV4dGVuZHMgTGF5ZXIge1xuICBkZWNsYXJlIHZpc0NvbmZpZ1NldHRpbmdzOiBBcmNMYXllclZpc0NvbmZpZ1NldHRpbmdzO1xuICBkZWNsYXJlIGNvbmZpZzogQXJjTGF5ZXJDb25maWc7XG4gIGRlY2xhcmUgbWV0YTogQXJjTGF5ZXJNZXRhO1xuXG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuXG4gICAgdGhpcy5yZWdpc3RlclZpc0NvbmZpZyhhcmNWaXNDb25maWdzKTtcbiAgICB0aGlzLmdldFBvc2l0aW9uQWNjZXNzb3IgPSAoZGF0YUNvbnRhaW5lcjogRGF0YUNvbnRhaW5lckludGVyZmFjZSkgPT5cbiAgICAgIGFyY1Bvc0FjY2Vzc29yKHRoaXMuY29uZmlnLmNvbHVtbnMpKGRhdGFDb250YWluZXIpO1xuICB9XG5cbiAgZ2V0IHR5cGUoKSB7XG4gICAgcmV0dXJuICdhcmMnO1xuICB9XG5cbiAgZ2V0IGlzQWdncmVnYXRlZCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBnZXQgbGF5ZXJJY29uKCkge1xuICAgIHJldHVybiBBcmNMYXllckljb247XG4gIH1cblxuICBnZXQgcmVxdWlyZWRMYXllckNvbHVtbnMoKSB7XG4gICAgcmV0dXJuIGFyY1JlcXVpcmVkQ29sdW1ucztcbiAgfVxuXG4gIGdldCBjb2x1bW5MYWJlbHMoKSB7XG4gICAgcmV0dXJuIGFyY0NvbHVtbkxhYmVscztcbiAgfVxuICBnZXQgY29sdW1uUGFpcnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVmYXVsdExpbmtDb2x1bW5QYWlycztcbiAgfVxuXG4gIGdldCB2aXN1YWxDaGFubmVscygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc291cmNlQ29sb3I6IHtcbiAgICAgICAgLi4uc3VwZXIudmlzdWFsQ2hhbm5lbHMuY29sb3IsXG4gICAgICAgIHByb3BlcnR5OiAnY29sb3InLFxuICAgICAgICBrZXk6ICdzb3VyY2VDb2xvcicsXG4gICAgICAgIGFjY2Vzc29yOiAnZ2V0U291cmNlQ29sb3InLFxuICAgICAgICBkZWZhdWx0VmFsdWU6IGNvbmZpZyA9PiBjb25maWcuY29sb3JcbiAgICAgIH0sXG4gICAgICB0YXJnZXRDb2xvcjoge1xuICAgICAgICAuLi5zdXBlci52aXN1YWxDaGFubmVscy5jb2xvcixcbiAgICAgICAgcHJvcGVydHk6ICd0YXJnZXRDb2xvcicsXG4gICAgICAgIGtleTogJ3RhcmdldENvbG9yJyxcbiAgICAgICAgYWNjZXNzb3I6ICdnZXRUYXJnZXRDb2xvcicsXG4gICAgICAgIGRlZmF1bHRWYWx1ZTogY29uZmlnID0+IGNvbmZpZy52aXNDb25maWcudGFyZ2V0Q29sb3IgfHwgY29uZmlnLmNvbG9yXG4gICAgICB9LFxuICAgICAgc2l6ZToge1xuICAgICAgICAuLi5zdXBlci52aXN1YWxDaGFubmVscy5zaXplLFxuICAgICAgICBhY2Nlc3NvcjogJ2dldFdpZHRoJyxcbiAgICAgICAgcHJvcGVydHk6ICdzdHJva2UnXG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIHN0YXRpYyBmaW5kRGVmYXVsdExheWVyUHJvcHMoe1xuICAgIGZpZWxkUGFpcnMgPSBbXVxuICB9OiBLZXBsZXJUYWJsZSk6IHtwcm9wczoge2NvbG9yPzogUkdCQ29sb3I7IGNvbHVtbnM6IEFyY0xheWVyQ29sdW1uc0NvbmZpZzsgbGFiZWw6IHN0cmluZ31bXX0ge1xuICAgIGlmIChmaWVsZFBhaXJzLmxlbmd0aCA8IDIpIHtcbiAgICAgIHJldHVybiB7cHJvcHM6IFtdfTtcbiAgICB9XG5cbiAgICBjb25zdCBwcm9wczoge2NvbG9yOiBSR0JDb2xvcjsgY29sdW1uczogQXJjTGF5ZXJDb2x1bW5zQ29uZmlnOyBsYWJlbDogc3RyaW5nfSA9IHtcbiAgICAgIGNvbG9yOiBoZXhUb1JnYihERUZBVUxUX0xBWUVSX0NPTE9SLnRyaXBBcmMpLFxuICAgICAgLy8gY29ubmVjdCB0aGUgZmlyc3QgdHdvIHBvaW50IGxheWVyIHdpdGggYXJjXG4gICAgICBjb2x1bW5zOiB7XG4gICAgICAgIGxhdDA6IGZpZWxkUGFpcnNbMF0ucGFpci5sYXQsXG4gICAgICAgIGxuZzA6IGZpZWxkUGFpcnNbMF0ucGFpci5sbmcsXG4gICAgICAgIGxhdDE6IGZpZWxkUGFpcnNbMV0ucGFpci5sYXQsXG4gICAgICAgIGxuZzE6IGZpZWxkUGFpcnNbMV0ucGFpci5sbmdcbiAgICAgIH0sXG4gICAgICBsYWJlbDogYCR7ZmllbGRQYWlyc1swXS5kZWZhdWx0TmFtZX0gLT4gJHtmaWVsZFBhaXJzWzFdLmRlZmF1bHROYW1lfSBhcmNgXG4gICAgfTtcblxuICAgIHJldHVybiB7cHJvcHM6IFtwcm9wc119O1xuICB9XG5cbiAgY2FsY3VsYXRlRGF0YUF0dHJpYnV0ZSh7ZGF0YUNvbnRhaW5lciwgZmlsdGVyZWRJbmRleH0sIGdldFBvc2l0aW9uKSB7XG4gICAgY29uc3QgZGF0YTogQXJjTGF5ZXJEYXRhW10gPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZpbHRlcmVkSW5kZXgubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGluZGV4ID0gZmlsdGVyZWRJbmRleFtpXTtcbiAgICAgIGNvbnN0IHBvcyA9IGdldFBvc2l0aW9uKHtpbmRleH0pO1xuXG4gICAgICAvLyBpZiBkb2Vzbid0IGhhdmUgcG9pbnQgbGF0IG9yIGxuZywgZG8gbm90IGFkZCB0aGUgcG9pbnRcbiAgICAgIC8vIGRlY2suZ2wgY2FuJ3QgaGFuZGxlIHBvc2l0aW9uID0gbnVsbFxuICAgICAgaWYgKHBvcy5ldmVyeShOdW1iZXIuaXNGaW5pdGUpKSB7XG4gICAgICAgIGRhdGEucHVzaCh7XG4gICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgc291cmNlUG9zaXRpb246IFtwb3NbMF0sIHBvc1sxXSwgcG9zWzJdXSxcbiAgICAgICAgICB0YXJnZXRQb3NpdGlvbjogW3Bvc1szXSwgcG9zWzRdLCBwb3NbNV1dXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgZm9ybWF0TGF5ZXJEYXRhKGRhdGFzZXRzLCBvbGRMYXllckRhdGEpIHtcbiAgICBpZiAodGhpcy5jb25maWcuZGF0YUlkID09PSBudWxsKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGNvbnN0IHtncHVGaWx0ZXIsIGRhdGFDb250YWluZXJ9ID0gZGF0YXNldHNbdGhpcy5jb25maWcuZGF0YUlkXTtcbiAgICBjb25zdCB7ZGF0YX0gPSB0aGlzLnVwZGF0ZURhdGEoZGF0YXNldHMsIG9sZExheWVyRGF0YSk7XG4gICAgY29uc3QgYWNjZXNzb3JzID0gdGhpcy5nZXRBdHRyaWJ1dGVBY2Nlc3NvcnMoe2RhdGFDb250YWluZXJ9KTtcbiAgICByZXR1cm4ge1xuICAgICAgZGF0YSxcbiAgICAgIGdldEZpbHRlclZhbHVlOiBncHVGaWx0ZXIuZmlsdGVyVmFsdWVBY2Nlc3NvcihkYXRhQ29udGFpbmVyKSgpLFxuICAgICAgLi4uYWNjZXNzb3JzXG4gICAgfTtcbiAgfVxuICAvKiBlc2xpbnQtZW5hYmxlIGNvbXBsZXhpdHkgKi9cblxuICB1cGRhdGVMYXllck1ldGEoZGF0YUNvbnRhaW5lcikge1xuICAgIC8vIGdldCBib3VuZHMgZnJvbSBhcmNzXG4gICAgY29uc3QgZ2V0UG9zaXRpb24gPSB0aGlzLmdldFBvc2l0aW9uQWNjZXNzb3IoZGF0YUNvbnRhaW5lcik7XG5cbiAgICBjb25zdCBzQm91bmRzID0gdGhpcy5nZXRQb2ludHNCb3VuZHMoZGF0YUNvbnRhaW5lciwgKGQsIGkpID0+IHtcbiAgICAgIGNvbnN0IHBvcyA9IGdldFBvc2l0aW9uKGQpO1xuICAgICAgcmV0dXJuIFtwb3NbMF0sIHBvc1sxXV07XG4gICAgfSk7XG4gICAgY29uc3QgdEJvdW5kcyA9IHRoaXMuZ2V0UG9pbnRzQm91bmRzKGRhdGFDb250YWluZXIsIChkLCBpKSA9PiB7XG4gICAgICBjb25zdCBwb3MgPSBnZXRQb3NpdGlvbihkKTtcbiAgICAgIHJldHVybiBbcG9zWzNdLCBwb3NbNF1dO1xuICAgIH0pO1xuXG4gICAgY29uc3QgYm91bmRzID1cbiAgICAgIHRCb3VuZHMgJiYgc0JvdW5kc1xuICAgICAgICA/IFtcbiAgICAgICAgICAgIE1hdGgubWluKHNCb3VuZHNbMF0sIHRCb3VuZHNbMF0pLFxuICAgICAgICAgICAgTWF0aC5taW4oc0JvdW5kc1sxXSwgdEJvdW5kc1sxXSksXG4gICAgICAgICAgICBNYXRoLm1heChzQm91bmRzWzJdLCB0Qm91bmRzWzJdKSxcbiAgICAgICAgICAgIE1hdGgubWF4KHNCb3VuZHNbM10sIHRCb3VuZHNbM10pXG4gICAgICAgICAgXVxuICAgICAgICA6IHNCb3VuZHMgfHwgdEJvdW5kcztcblxuICAgIHRoaXMudXBkYXRlTWV0YSh7Ym91bmRzfSk7XG4gIH1cblxuICByZW5kZXJMYXllcihvcHRzKSB7XG4gICAgY29uc3Qge2RhdGEsIGdwdUZpbHRlciwgb2JqZWN0SG92ZXJlZCwgaW50ZXJhY3Rpb25Db25maWd9ID0gb3B0cztcbiAgICBjb25zdCB1cGRhdGVUcmlnZ2VycyA9IHtcbiAgICAgIGdldFBvc2l0aW9uOiB0aGlzLmNvbmZpZy5jb2x1bW5zLFxuICAgICAgZ2V0RmlsdGVyVmFsdWU6IGdwdUZpbHRlci5maWx0ZXJWYWx1ZVVwZGF0ZVRyaWdnZXJzLFxuICAgICAgLi4udGhpcy5nZXRWaXN1YWxDaGFubmVsVXBkYXRlVHJpZ2dlcnMoKVxuICAgIH07XG4gICAgY29uc3Qgd2lkdGhTY2FsZSA9IHRoaXMuY29uZmlnLnZpc0NvbmZpZy50aGlja25lc3MgKiBQUk9KRUNURURfUElYRUxfU0laRV9NVUxUSVBMSUVSO1xuICAgIGNvbnN0IGRlZmF1bHRMYXllclByb3BzID0gdGhpcy5nZXREZWZhdWx0RGVja0xheWVyUHJvcHMob3B0cyk7XG4gICAgY29uc3QgaG92ZXJlZE9iamVjdCA9IHRoaXMuaGFzSG92ZXJlZE9iamVjdChvYmplY3RIb3ZlcmVkKTtcbiAgICByZXR1cm4gW1xuICAgICAgbmV3IERlY2tBcmNMYXllcih7XG4gICAgICAgIC4uLmRlZmF1bHRMYXllclByb3BzLFxuICAgICAgICAuLi50aGlzLmdldEJydXNoaW5nRXh0ZW5zaW9uUHJvcHMoaW50ZXJhY3Rpb25Db25maWcsICdzb3VyY2VfdGFyZ2V0JyksXG4gICAgICAgIC4uLmRhdGEsXG4gICAgICAgIHdpZHRoU2NhbGUsXG4gICAgICAgIHVwZGF0ZVRyaWdnZXJzLFxuICAgICAgICBleHRlbnNpb25zOiBbLi4uZGVmYXVsdExheWVyUHJvcHMuZXh0ZW5zaW9ucywgbmV3IEJydXNoaW5nRXh0ZW5zaW9uKCldXG4gICAgICB9KSxcbiAgICAgIC8vIGhvdmVyIGxheWVyXG4gICAgICAuLi4oaG92ZXJlZE9iamVjdFxuICAgICAgICA/IFtcbiAgICAgICAgICAgIG5ldyBEZWNrQXJjTGF5ZXIoe1xuICAgICAgICAgICAgICAuLi50aGlzLmdldERlZmF1bHRIb3ZlckxheWVyUHJvcHMoKSxcbiAgICAgICAgICAgICAgZGF0YTogW2hvdmVyZWRPYmplY3RdLFxuICAgICAgICAgICAgICB3aWR0aFNjYWxlLFxuICAgICAgICAgICAgICBnZXRTb3VyY2VDb2xvcjogdGhpcy5jb25maWcuaGlnaGxpZ2h0Q29sb3IsXG4gICAgICAgICAgICAgIGdldFRhcmdldENvbG9yOiB0aGlzLmNvbmZpZy5oaWdobGlnaHRDb2xvcixcbiAgICAgICAgICAgICAgZ2V0V2lkdGg6IGRhdGEuZ2V0V2lkdGhcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgXVxuICAgICAgICA6IFtdKVxuICAgIF07XG4gIH1cbn1cbiJdfQ==