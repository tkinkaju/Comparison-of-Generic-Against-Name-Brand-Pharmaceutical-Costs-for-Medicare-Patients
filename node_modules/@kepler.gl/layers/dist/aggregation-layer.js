// Copyright (c) 2022 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = exports.aggregateRequiredColumns = exports.getFilterDataFunc = exports.getValueAggrFunc = exports.pointPosResolver = exports.pointPosAccessor = void 0;

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _lodash = _interopRequireDefault(require("lodash.memoize"));

var _baseLayer = _interopRequireDefault(require("./base-layer"));

var _utils = require("@kepler.gl/utils");

var _constants = require("@kepler.gl/constants");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var pointPosAccessor = function pointPosAccessor(_ref) {
  var lat = _ref.lat,
      lng = _ref.lng;
  return function (dc) {
    return function (d) {
      return [dc.valueAt(d.index, lng.fieldIdx), dc.valueAt(d.index, lat.fieldIdx)];
    };
  };
};

exports.pointPosAccessor = pointPosAccessor;

var pointPosResolver = function pointPosResolver(_ref2) {
  var lat = _ref2.lat,
      lng = _ref2.lng;
  return "".concat(lat.fieldIdx, "-").concat(lng.fieldIdx);
};

exports.pointPosResolver = pointPosResolver;

var getValueAggrFunc = function getValueAggrFunc(getPointData) {
  return function (field, aggregation) {
    return function (points) {
      return field ? (0, _utils.aggregate)(points.map(function (p) {
        return field.valueAccessor(getPointData(p));
      }), aggregation) : points.length;
    };
  };
};

exports.getValueAggrFunc = getValueAggrFunc;

var getFilterDataFunc = function getFilterDataFunc(filterRange, getFilterValue) {
  return function (pt) {
    return getFilterValue(pt).every(function (val, i) {
      return val >= filterRange[i][0] && val <= filterRange[i][1];
    });
  };
};

exports.getFilterDataFunc = getFilterDataFunc;

var getLayerColorRange = function getLayerColorRange(colorRange) {
  return colorRange.colors.map(_utils.hexToRgb);
};

var aggregateRequiredColumns = ['lat', 'lng'];
exports.aggregateRequiredColumns = aggregateRequiredColumns;

var AggregationLayer = /*#__PURE__*/function (_Layer) {
  (0, _inherits2["default"])(AggregationLayer, _Layer);

  var _super = _createSuper(AggregationLayer);

  function AggregationLayer(props) {
    var _this;

    (0, _classCallCheck2["default"])(this, AggregationLayer);
    _this = _super.call(this, props);
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "getColorRange", void 0);

    _this.getPositionAccessor = function (dataContainer) {
      return pointPosAccessor(_this.config.columns)(dataContainer);
    };

    _this.getColorRange = (0, _lodash["default"])(getLayerColorRange); // Access data of a point from aggregated bins, depends on how BinSorter works
    // Deck.gl's BinSorter puts data in point.source

    _this.getPointData = function (pt) {
      return pt.source;
    };

    _this.gpuFilterGetIndex = function (pt) {
      return _this.getPointData(pt).index;
    };

    _this.gpuFilterGetData = function (dataContainer, data, fieldIndex) {
      return dataContainer.valueAt(data.index, fieldIndex);
    };

    return _this;
  }

  (0, _createClass2["default"])(AggregationLayer, [{
    key: "isAggregated",
    get: function get() {
      return true;
    }
  }, {
    key: "requiredLayerColumns",
    get: function get() {
      return aggregateRequiredColumns;
    }
  }, {
    key: "columnPairs",
    get: function get() {
      return this.defaultPointColumnPairs;
    }
  }, {
    key: "noneLayerDataAffectingProps",
    get: function get() {
      return [].concat((0, _toConsumableArray2["default"])((0, _get2["default"])((0, _getPrototypeOf2["default"])(AggregationLayer.prototype), "noneLayerDataAffectingProps", this)), ['enable3d', 'colorRange', 'colorDomain', 'sizeRange', 'sizeScale', 'sizeDomain', 'percentile', 'coverage', 'elevationPercentile', 'elevationScale', 'enableElevationZoomFactor']);
    }
  }, {
    key: "visualChannels",
    get: function get() {
      return {
        color: {
          aggregation: 'colorAggregation',
          channelScaleType: _constants.CHANNEL_SCALES.colorAggr,
          defaultMeasure: 'property.pointCount',
          domain: 'colorDomain',
          field: 'colorField',
          key: 'color',
          property: 'color',
          range: 'colorRange',
          scale: 'colorScale'
        },
        size: {
          aggregation: 'sizeAggregation',
          channelScaleType: _constants.CHANNEL_SCALES.sizeAggr,
          condition: function condition(config) {
            return config.visConfig.enable3d;
          },
          defaultMeasure: 'property.pointCount',
          domain: 'sizeDomain',
          field: 'sizeField',
          key: 'size',
          property: 'height',
          range: 'sizeRange',
          scale: 'sizeScale'
        }
      };
    }
    /**
     * Get the description of a visualChannel config
     * @param key
     * @returns
     */

  }, {
    key: "getVisualChannelDescription",
    value: function getVisualChannelDescription(key) {
      var _this$visConfigSettin;

      var channel = this.visualChannels[key];
      if (!channel) return {
        label: '',
        measure: undefined
      }; // e.g. label: Color, measure: Average of ETA

      var range = channel.range,
          field = channel.field,
          defaultMeasure = channel.defaultMeasure,
          aggregation = channel.aggregation;
      var fieldConfig = this.config[field];
      var label = (_this$visConfigSettin = this.visConfigSettings[range]) === null || _this$visConfigSettin === void 0 ? void 0 : _this$visConfigSettin.label;
      return {
        label: typeof label === 'function' ? label(this.config) : label || '',
        measure: fieldConfig && aggregation ? "".concat(this.config.visConfig[aggregation], " of ").concat(fieldConfig.displayName || fieldConfig.name) : defaultMeasure
      };
    }
  }, {
    key: "getHoverData",
    value: function getHoverData(object) {
      // return aggregated object
      return object;
    }
    /**
     * Aggregation layer handles visual channel aggregation inside deck.gl layer
     */

  }, {
    key: "updateLayerVisualChannel",
    value: function updateLayerVisualChannel(_ref3, channel) {
      var dataContainer = _ref3.dataContainer;
      this.validateVisualChannel(channel);
    }
    /**
     * Validate aggregation type on top of basic layer visual channel validation
     * @param channel
     */

  }, {
    key: "validateVisualChannel",
    value: function validateVisualChannel(channel) {
      // field type decides aggregation type decides scale type
      this.validateFieldType(channel);
      this.validateAggregationType(channel);
      this.validateScale(channel);
    }
    /**
     * Validate aggregation type based on selected field
     */

  }, {
    key: "validateAggregationType",
    value: function validateAggregationType(channel) {
      var visualChannel = this.visualChannels[channel];
      var field = visualChannel.field,
          aggregation = visualChannel.aggregation;
      var aggregationOptions = this.getAggregationOptions(channel);

      if (!aggregation) {
        return;
      }

      if (!aggregationOptions.length) {
        // if field cannot be aggregated, set field to null
        this.updateLayerConfig((0, _defineProperty2["default"])({}, field, null));
      } else if (!aggregationOptions.includes(this.config.visConfig[aggregation])) {
        // current aggregation type is not supported by this field
        // set aggregation to the first supported option
        this.updateLayerVisConfig((0, _defineProperty2["default"])({}, aggregation, aggregationOptions[0]));
      }
    }
  }, {
    key: "getAggregationOptions",
    value: function getAggregationOptions(channel) {
      var visualChannel = this.visualChannels[channel];
      var field = visualChannel.field,
          channelScaleType = visualChannel.channelScaleType;
      return Object.keys(this.config[field] ? _constants.FIELD_OPTS[this.config[field].type].scale[channelScaleType] : _constants.DEFAULT_AGGREGATION[channelScaleType]);
    }
    /**
     * Get scale options based on current field and aggregation type
     * @param channel
     * @returns
     */

  }, {
    key: "getScaleOptions",
    value: function getScaleOptions(channel) {
      var visualChannel = this.visualChannels[channel];
      var field = visualChannel.field,
          aggregation = visualChannel.aggregation,
          channelScaleType = visualChannel.channelScaleType;
      var aggregationType = aggregation ? this.config.visConfig[aggregation] : null;

      if (!aggregationType) {
        return [];
      }

      return this.config[field] ? // scale options based on aggregation
      _constants.FIELD_OPTS[this.config[field].type].scale[channelScaleType][aggregationType] : // default scale options for point count
      _constants.DEFAULT_AGGREGATION[channelScaleType][aggregationType];
    }
    /**
     * Aggregation layer handles visual channel aggregation inside deck.gl layer
     */

  }, {
    key: "updateLayerDomain",
    value: function updateLayerDomain(datasets, newFilter) {
      return this;
    }
  }, {
    key: "updateLayerMeta",
    value: function updateLayerMeta(dataContainer, getPosition) {
      // get bounds from points
      var bounds = this.getPointsBounds(dataContainer, getPosition);
      this.updateMeta({
        bounds: bounds
      });
    }
  }, {
    key: "calculateDataAttribute",
    value: function calculateDataAttribute(_ref4, getPosition) {
      var dataContainer = _ref4.dataContainer,
          filteredIndex = _ref4.filteredIndex;
      var data = [];

      for (var i = 0; i < filteredIndex.length; i++) {
        var index = filteredIndex[i];
        var pos = getPosition({
          index: index
        }); // if doesn't have point lat or lng, do not add the point
        // deck.gl can't handle position = null

        if (pos.every(Number.isFinite)) {
          data.push({
            index: index
          });
        }
      }

      return data;
    }
  }, {
    key: "formatLayerData",
    value: function formatLayerData(datasets, oldLayerData) {
      if (this.config.dataId === null) {
        return {};
      }

      var _datasets$this$config = datasets[this.config.dataId],
          gpuFilter = _datasets$this$config.gpuFilter,
          dataContainer = _datasets$this$config.dataContainer;
      var getPosition = this.getPositionAccessor(dataContainer);
      var aggregatePoints = getValueAggrFunc(this.getPointData);
      var getColorValue = aggregatePoints(this.config.colorField, this.config.visConfig.colorAggregation);
      var getElevationValue = aggregatePoints(this.config.sizeField, this.config.visConfig.sizeAggregation);
      var hasFilter = Object.values(gpuFilter.filterRange).some(function (arr) {
        return arr.some(function (v) {
          return v !== 0;
        });
      });
      var getFilterValue = gpuFilter.filterValueAccessor(dataContainer)(this.gpuFilterGetIndex, this.gpuFilterGetData);
      var filterData = hasFilter ? getFilterDataFunc(gpuFilter.filterRange, getFilterValue) : undefined;

      var _this$updateData = this.updateData(datasets, oldLayerData),
          data = _this$updateData.data;

      return _objectSpread(_objectSpread({
        data: data,
        getPosition: getPosition,
        _filterData: filterData
      }, getColorValue ? {
        getColorValue: getColorValue
      } : {}), getElevationValue ? {
        getElevationValue: getElevationValue
      } : {});
    }
  }, {
    key: "getDefaultDeckLayerProps",
    value: function getDefaultDeckLayerProps(opts) {
      var baseProp = (0, _get2["default"])((0, _getPrototypeOf2["default"])(AggregationLayer.prototype), "getDefaultDeckLayerProps", this).call(this, opts);
      return _objectSpread(_objectSpread({}, baseProp), {}, {
        highlightColor: _constants.HIGHLIGH_COLOR_3D,
        // gpu data filtering is not supported in aggregation layer
        extensions: [],
        autoHighlight: this.config.visConfig.enable3d
      });
    }
  }, {
    key: "getDefaultAggregationLayerProp",
    value: function getDefaultAggregationLayerProp(opts) {
      var gpuFilter = opts.gpuFilter,
          mapState = opts.mapState,
          _opts$layerCallbacks = opts.layerCallbacks,
          layerCallbacks = _opts$layerCallbacks === void 0 ? {} : _opts$layerCallbacks;
      var visConfig = this.config.visConfig;
      var eleZoomFactor = this.getElevationZoomFactor(mapState);
      var updateTriggers = {
        getColorValue: {
          colorField: this.config.colorField,
          colorAggregation: this.config.visConfig.colorAggregation
        },
        getElevationValue: {
          sizeField: this.config.sizeField,
          sizeAggregation: this.config.visConfig.sizeAggregation
        },
        _filterData: _objectSpread({
          filterRange: gpuFilter.filterRange
        }, gpuFilter.filterValueUpdateTriggers)
      };
      return _objectSpread(_objectSpread({}, this.getDefaultDeckLayerProps(opts)), {}, {
        coverage: visConfig.coverage,
        // color
        colorRange: this.getColorRange(visConfig.colorRange),
        colorScaleType: this.config.colorScale,
        upperPercentile: visConfig.percentile[1],
        lowerPercentile: visConfig.percentile[0],
        colorAggregation: visConfig.colorAggregation,
        // elevation
        extruded: visConfig.enable3d,
        elevationScale: visConfig.elevationScale * eleZoomFactor,
        elevationScaleType: this.config.sizeScale,
        elevationRange: visConfig.sizeRange,
        elevationLowerPercentile: visConfig.elevationPercentile[0],
        elevationUpperPercentile: visConfig.elevationPercentile[1],
        // updateTriggers
        updateTriggers: updateTriggers,
        // callbacks
        onSetColorDomain: layerCallbacks.onSetLayerDomain
      });
    }
  }]);
  return AggregationLayer;
}(_baseLayer["default"]);

exports["default"] = AggregationLayer;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9hZ2dyZWdhdGlvbi1sYXllci50cyJdLCJuYW1lcyI6WyJwb2ludFBvc0FjY2Vzc29yIiwibGF0IiwibG5nIiwiZGMiLCJkIiwidmFsdWVBdCIsImluZGV4IiwiZmllbGRJZHgiLCJwb2ludFBvc1Jlc29sdmVyIiwiZ2V0VmFsdWVBZ2dyRnVuYyIsImdldFBvaW50RGF0YSIsImZpZWxkIiwiYWdncmVnYXRpb24iLCJwb2ludHMiLCJtYXAiLCJwIiwidmFsdWVBY2Nlc3NvciIsImxlbmd0aCIsImdldEZpbHRlckRhdGFGdW5jIiwiZmlsdGVyUmFuZ2UiLCJnZXRGaWx0ZXJWYWx1ZSIsInB0IiwiZXZlcnkiLCJ2YWwiLCJpIiwiZ2V0TGF5ZXJDb2xvclJhbmdlIiwiY29sb3JSYW5nZSIsImNvbG9ycyIsImhleFRvUmdiIiwiYWdncmVnYXRlUmVxdWlyZWRDb2x1bW5zIiwiQWdncmVnYXRpb25MYXllciIsInByb3BzIiwiZ2V0UG9zaXRpb25BY2Nlc3NvciIsImRhdGFDb250YWluZXIiLCJjb25maWciLCJjb2x1bW5zIiwiZ2V0Q29sb3JSYW5nZSIsInNvdXJjZSIsImdwdUZpbHRlckdldEluZGV4IiwiZ3B1RmlsdGVyR2V0RGF0YSIsImRhdGEiLCJmaWVsZEluZGV4IiwiZGVmYXVsdFBvaW50Q29sdW1uUGFpcnMiLCJjb2xvciIsImNoYW5uZWxTY2FsZVR5cGUiLCJDSEFOTkVMX1NDQUxFUyIsImNvbG9yQWdnciIsImRlZmF1bHRNZWFzdXJlIiwiZG9tYWluIiwia2V5IiwicHJvcGVydHkiLCJyYW5nZSIsInNjYWxlIiwic2l6ZSIsInNpemVBZ2dyIiwiY29uZGl0aW9uIiwidmlzQ29uZmlnIiwiZW5hYmxlM2QiLCJjaGFubmVsIiwidmlzdWFsQ2hhbm5lbHMiLCJsYWJlbCIsIm1lYXN1cmUiLCJ1bmRlZmluZWQiLCJmaWVsZENvbmZpZyIsInZpc0NvbmZpZ1NldHRpbmdzIiwiZGlzcGxheU5hbWUiLCJuYW1lIiwib2JqZWN0IiwidmFsaWRhdGVWaXN1YWxDaGFubmVsIiwidmFsaWRhdGVGaWVsZFR5cGUiLCJ2YWxpZGF0ZUFnZ3JlZ2F0aW9uVHlwZSIsInZhbGlkYXRlU2NhbGUiLCJ2aXN1YWxDaGFubmVsIiwiYWdncmVnYXRpb25PcHRpb25zIiwiZ2V0QWdncmVnYXRpb25PcHRpb25zIiwidXBkYXRlTGF5ZXJDb25maWciLCJpbmNsdWRlcyIsInVwZGF0ZUxheWVyVmlzQ29uZmlnIiwiT2JqZWN0Iiwia2V5cyIsIkZJRUxEX09QVFMiLCJ0eXBlIiwiREVGQVVMVF9BR0dSRUdBVElPTiIsImFnZ3JlZ2F0aW9uVHlwZSIsImRhdGFzZXRzIiwibmV3RmlsdGVyIiwiZ2V0UG9zaXRpb24iLCJib3VuZHMiLCJnZXRQb2ludHNCb3VuZHMiLCJ1cGRhdGVNZXRhIiwiZmlsdGVyZWRJbmRleCIsInBvcyIsIk51bWJlciIsImlzRmluaXRlIiwicHVzaCIsIm9sZExheWVyRGF0YSIsImRhdGFJZCIsImdwdUZpbHRlciIsImFnZ3JlZ2F0ZVBvaW50cyIsImdldENvbG9yVmFsdWUiLCJjb2xvckZpZWxkIiwiY29sb3JBZ2dyZWdhdGlvbiIsImdldEVsZXZhdGlvblZhbHVlIiwic2l6ZUZpZWxkIiwic2l6ZUFnZ3JlZ2F0aW9uIiwiaGFzRmlsdGVyIiwidmFsdWVzIiwic29tZSIsImFyciIsInYiLCJmaWx0ZXJWYWx1ZUFjY2Vzc29yIiwiZmlsdGVyRGF0YSIsInVwZGF0ZURhdGEiLCJfZmlsdGVyRGF0YSIsIm9wdHMiLCJiYXNlUHJvcCIsImhpZ2hsaWdodENvbG9yIiwiSElHSExJR0hfQ09MT1JfM0QiLCJleHRlbnNpb25zIiwiYXV0b0hpZ2hsaWdodCIsIm1hcFN0YXRlIiwibGF5ZXJDYWxsYmFja3MiLCJlbGVab29tRmFjdG9yIiwiZ2V0RWxldmF0aW9uWm9vbUZhY3RvciIsInVwZGF0ZVRyaWdnZXJzIiwiZmlsdGVyVmFsdWVVcGRhdGVUcmlnZ2VycyIsImdldERlZmF1bHREZWNrTGF5ZXJQcm9wcyIsImNvdmVyYWdlIiwiY29sb3JTY2FsZVR5cGUiLCJjb2xvclNjYWxlIiwidXBwZXJQZXJjZW50aWxlIiwicGVyY2VudGlsZSIsImxvd2VyUGVyY2VudGlsZSIsImV4dHJ1ZGVkIiwiZWxldmF0aW9uU2NhbGUiLCJlbGV2YXRpb25TY2FsZVR5cGUiLCJzaXplU2NhbGUiLCJlbGV2YXRpb25SYW5nZSIsInNpemVSYW5nZSIsImVsZXZhdGlvbkxvd2VyUGVyY2VudGlsZSIsImVsZXZhdGlvblBlcmNlbnRpbGUiLCJlbGV2YXRpb25VcHBlclBlcmNlbnRpbGUiLCJvblNldENvbG9yRG9tYWluIiwib25TZXRMYXllckRvbWFpbiIsIkxheWVyIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFvQkE7O0FBQ0E7O0FBUUE7O0FBQ0E7Ozs7Ozs7Ozs7QUFtQk8sSUFBTUEsZ0JBQWdCLEdBQUcsU0FBbkJBLGdCQUFtQjtBQUFBLE1BQUVDLEdBQUYsUUFBRUEsR0FBRjtBQUFBLE1BQU9DLEdBQVAsUUFBT0EsR0FBUDtBQUFBLFNBQXlDLFVBQUFDLEVBQUU7QUFBQSxXQUFJLFVBQUFDLENBQUM7QUFBQSxhQUFJLENBQ2xGRCxFQUFFLENBQUNFLE9BQUgsQ0FBV0QsQ0FBQyxDQUFDRSxLQUFiLEVBQW9CSixHQUFHLENBQUNLLFFBQXhCLENBRGtGLEVBRWxGSixFQUFFLENBQUNFLE9BQUgsQ0FBV0QsQ0FBQyxDQUFDRSxLQUFiLEVBQW9CTCxHQUFHLENBQUNNLFFBQXhCLENBRmtGLENBQUo7QUFBQSxLQUFMO0FBQUEsR0FBM0M7QUFBQSxDQUF6Qjs7OztBQUtBLElBQU1DLGdCQUFnQixHQUFHLFNBQW5CQSxnQkFBbUI7QUFBQSxNQUFFUCxHQUFGLFNBQUVBLEdBQUY7QUFBQSxNQUFPQyxHQUFQLFNBQU9BLEdBQVA7QUFBQSxtQkFDM0JELEdBQUcsQ0FBQ00sUUFEdUIsY0FDWEwsR0FBRyxDQUFDSyxRQURPO0FBQUEsQ0FBekI7Ozs7QUFHQSxJQUFNRSxnQkFBZ0IsR0FBRyxTQUFuQkEsZ0JBQW1CLENBQUFDLFlBQVk7QUFBQSxTQUFJLFVBQUND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Z0JBQWdCLEVBQUU3QyxTQUFTLENBQUM2QyxnQkFUOUI7QUFXRTtBQUNBZ0MsUUFBQUEsUUFBUSxFQUFFN0UsU0FBUyxDQUFDQyxRQVp0QjtBQWFFNkUsUUFBQUEsY0FBYyxFQUFFOUUsU0FBUyxDQUFDOEUsY0FBVixHQUEyQlosYUFiN0M7QUFjRWEsUUFBQUEsa0JBQWtCLEVBQUUsS0FBS3JHLE1BQUwsQ0FBWXNHLFNBZGxDO0FBZUVDLFFBQUFBLGNBQWMsRUFBRWpGLFNBQVMsQ0FBQ2tGLFNBZjVCO0FBZ0JFQyxRQUFBQSx3QkFBd0IsRUFBRW5GLFNBQVMsQ0FBQ29GLG1CQUFWLENBQThCLENBQTlCLENBaEI1QjtBQWlCRUMsUUFBQUEsd0JBQXdCLEVBQUVyRixTQUFTLENBQUNvRixtQkFBVixDQUE4QixDQUE5QixDQWpCNUI7QUFtQkU7QUFDQWhCLFFBQUFBLGNBQWMsRUFBZEEsY0FwQkY7QUFzQkU7QUFDQWtCLFFBQUFBLGdCQUFnQixFQUFFckIsY0FBYyxDQUFDc0I7QUF2Qm5DO0FBeUJEOzs7RUEzVDJDQyxxQiIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAyMiBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5cbmltcG9ydCBtZW1vaXplIGZyb20gJ2xvZGFzaC5tZW1vaXplJztcbmltcG9ydCBMYXllciwge1xuICBMYXllckJhc2VDb25maWcsXG4gIExheWVyQ29sb3JDb25maWcsXG4gIExheWVyQ29sdW1uLFxuICBMYXllclNpemVDb25maWcsXG4gIFZpc3VhbENoYW5uZWxEZXNjcmlwdGlvbixcbiAgVmlzdWFsQ2hhbm5lbHNcbn0gZnJvbSAnLi9iYXNlLWxheWVyJztcbmltcG9ydCB7aGV4VG9SZ2IsIGFnZ3JlZ2F0ZX0gZnJvbSAnQGtlcGxlci5nbC91dGlscyc7XG5pbXBvcnQge1xuICBISUdITElHSF9DT0xPUl8zRCxcbiAgQ0hBTk5FTF9TQ0FMRVMsXG4gIEZJRUxEX09QVFMsXG4gIERFRkFVTFRfQUdHUkVHQVRJT04sXG4gIENvbG9yUmFuZ2Vcbn0gZnJvbSAnQGtlcGxlci5nbC9jb25zdGFudHMnO1xuaW1wb3J0IHtNZXJnZX0gZnJvbSAnQGtlcGxlci5nbC90eXBlcyc7XG5pbXBvcnQge0tlcGxlclRhYmxlLCBEYXRhc2V0c30gZnJvbSAnQGtlcGxlci5nbC90YWJsZSc7XG5cbnR5cGUgQWdncmVnYXRpb25MYXllckNvbHVtbnMgPSB7XG4gIGxhdDogTGF5ZXJDb2x1bW47XG4gIGxuZzogTGF5ZXJDb2x1bW47XG59O1xuXG5leHBvcnQgdHlwZSBBZ2dyZWdhdGlvbkxheWVyRGF0YSA9IHtcbiAgaW5kZXg6IG51bWJlcjtcbn07XG5cbmV4cG9ydCBjb25zdCBwb2ludFBvc0FjY2Vzc29yID0gKHtsYXQsIGxuZ306IEFnZ3JlZ2F0aW9uTGF5ZXJDb2x1bW5zKSA9PiBkYyA9PiBkID0+IFtcbiAgZGMudmFsdWVBdChkLmluZGV4LCBsbmcuZmllbGRJZHgpLFxuICBkYy52YWx1ZUF0KGQuaW5kZXgsIGxhdC5maWVsZElkeClcbl07XG5cbmV4cG9ydCBjb25zdCBwb2ludFBvc1Jlc29sdmVyID0gKHtsYXQsIGxuZ306IEFnZ3JlZ2F0aW9uTGF5ZXJDb2x1bW5zKSA9PlxuICBgJHtsYXQuZmllbGRJZHh9LSR7bG5nLmZpZWxkSWR4fWA7XG5cbmV4cG9ydCBjb25zdCBnZXRWYWx1ZUFnZ3JGdW5jID0gZ2V0UG9pbnREYXRhID0+IChmaWVsZCwgYWdncmVnYXRpb24pID0+IHBvaW50cyA9PlxuICBmaWVsZFxuICAgID8gYWdncmVnYXRlKFxuICAgICAgICBwb2ludHMubWFwKHAgPT4gZmllbGQudmFsdWVBY2Nlc3NvcihnZXRQb2ludERhdGEocCkpKSxcbiAgICAgICAgYWdncmVnYXRpb25cbiAgICAgIClcbiAgICA6IHBvaW50cy5sZW5ndGg7XG5cbmV4cG9ydCBjb25zdCBnZXRGaWx0ZXJEYXRhRnVuYyA9IChmaWx0ZXJSYW5nZSwgZ2V0RmlsdGVyVmFsdWUpID0+IHB0ID0+XG4gIGdldEZpbHRlclZhbHVlKHB0KS5ldmVyeSgodmFsLCBpKSA9PiB2YWwgPj0gZmlsdGVyUmFuZ2VbaV1bMF0gJiYgdmFsIDw9IGZpbHRlclJhbmdlW2ldWzFdKTtcblxuY29uc3QgZ2V0TGF5ZXJDb2xvclJhbmdlID0gKGNvbG9yUmFuZ2U6IENvbG9yUmFuZ2UpID0+IGNvbG9yUmFuZ2UuY29sb3JzLm1hcChoZXhUb1JnYik7XG5cbmV4cG9ydCBjb25zdCBhZ2dyZWdhdGVSZXF1aXJlZENvbHVtbnM6IFsnbGF0JywgJ2xuZyddID0gWydsYXQnLCAnbG5nJ107XG5cbmV4cG9ydCB0eXBlIEFnZ3JlZ2F0aW9uTGF5ZXJWaXN1YWxDaGFubmVsQ29uZmlnID0gTGF5ZXJDb2xvckNvbmZpZyAmIExheWVyU2l6ZUNvbmZpZztcbmV4cG9ydCB0eXBlIEFnZ3JlZ2F0aW9uTGF5ZXJDb25maWcgPSBNZXJnZTxMYXllckJhc2VDb25maWcsIHtjb2x1bW5zOiBBZ2dyZWdhdGlvbkxheWVyQ29sdW1uc30+ICZcbiAgQWdncmVnYXRpb25MYXllclZpc3VhbENoYW5uZWxDb25maWc7XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBZ2dyZWdhdGlvbkxheWVyIGV4dGVuZHMgTGF5ZXIge1xuICBnZXRDb2xvclJhbmdlOiBhbnk7XG4gIGRlY2xhcmUgY29uZmlnOiBBZ2dyZWdhdGlvbkxheWVyQ29uZmlnO1xuICBkZWNsYXJlIGdldFBvaW50RGF0YTogKGFueSkgPT4gYW55O1xuICBkZWNsYXJlIGdwdUZpbHRlckdldEluZGV4OiAoYW55KSA9PiBudW1iZXI7XG4gIGRlY2xhcmUgZ3B1RmlsdGVyR2V0RGF0YTogKGRhdGFDb250YWluZXIsIGRhdGEsIGZpZWxkSW5kZXgpID0+IGFueTtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcm9wcz86IHtcbiAgICAgIGlkPzogc3RyaW5nO1xuICAgIH0gJiBQYXJ0aWFsPExheWVyQmFzZUNvbmZpZz5cbiAgKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuXG4gICAgdGhpcy5nZXRQb3NpdGlvbkFjY2Vzc29yID0gZGF0YUNvbnRhaW5lciA9PlxuICAgICAgcG9pbnRQb3NBY2Nlc3Nvcih0aGlzLmNvbmZpZy5jb2x1bW5zKShkYXRhQ29udGFpbmVyKTtcbiAgICB0aGlzLmdldENvbG9yUmFuZ2UgPSBtZW1vaXplKGdldExheWVyQ29sb3JSYW5nZSk7XG5cbiAgICAvLyBBY2Nlc3MgZGF0YSBvZiBhIHBvaW50IGZyb20gYWdncmVnYXRlZCBiaW5zLCBkZXBlbmRzIG9uIGhvdyBCaW5Tb3J0ZXIgd29ya3NcbiAgICAvLyBEZWNrLmdsJ3MgQmluU29ydGVyIHB1dHMgZGF0YSBpbiBwb2ludC5zb3VyY2VcbiAgICB0aGlzLmdldFBvaW50RGF0YSA9IHB0ID0+IHB0LnNvdXJjZTtcblxuICAgIHRoaXMuZ3B1RmlsdGVyR2V0SW5kZXggPSBwdCA9PiB0aGlzLmdldFBvaW50RGF0YShwdCkuaW5kZXg7XG4gICAgdGhpcy5ncHVGaWx0ZXJHZXREYXRhID0gKGRhdGFDb250YWluZXIsIGRhdGEsIGZpZWxkSW5kZXgpID0+XG4gICAgICBkYXRhQ29udGFpbmVyLnZhbHVlQXQoZGF0YS5pbmRleCwgZmllbGRJbmRleCk7XG4gIH1cblxuICBnZXQgaXNBZ2dyZWdhdGVkKCk6IHRydWUge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgZ2V0IHJlcXVpcmVkTGF5ZXJDb2x1bW5zKCkge1xuICAgIHJldHVybiBhZ2dyZWdhdGVSZXF1aXJlZENvbHVtbnM7XG4gIH1cblxuICBnZXQgY29sdW1uUGFpcnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVmYXVsdFBvaW50Q29sdW1uUGFpcnM7XG4gIH1cblxuICBnZXQgbm9uZUxheWVyRGF0YUFmZmVjdGluZ1Byb3BzKCkge1xuICAgIHJldHVybiBbXG4gICAgICAuLi5zdXBlci5ub25lTGF5ZXJEYXRhQWZmZWN0aW5nUHJvcHMsXG4gICAgICAnZW5hYmxlM2QnLFxuICAgICAgJ2NvbG9yUmFuZ2UnLFxuICAgICAgJ2NvbG9yRG9tYWluJyxcbiAgICAgICdzaXplUmFuZ2UnLFxuICAgICAgJ3NpemVTY2FsZScsXG4gICAgICAnc2l6ZURvbWFpbicsXG4gICAgICAncGVyY2VudGlsZScsXG4gICAgICAnY292ZXJhZ2UnLFxuICAgICAgJ2VsZXZhdGlvblBlcmNlbnRpbGUnLFxuICAgICAgJ2VsZXZhdGlvblNjYWxlJyxcbiAgICAgICdlbmFibGVFbGV2YXRpb25ab29tRmFjdG9yJ1xuICAgIF07XG4gIH1cblxuICBnZXQgdmlzdWFsQ2hhbm5lbHMoKTogVmlzdWFsQ2hhbm5lbHMge1xuICAgIHJldHVybiB7XG4gICAgICBjb2xvcjoge1xuICAgICAgICBhZ2dyZWdhdGlvbjogJ2NvbG9yQWdncmVnYXRpb24nLFxuICAgICAgICBjaGFubmVsU2NhbGVUeXBlOiBDSEFOTkVMX1NDQUxFUy5jb2xvckFnZ3IsXG4gICAgICAgIGRlZmF1bHRNZWFzdXJlOiAncHJvcGVydHkucG9pbnRDb3VudCcsXG4gICAgICAgIGRvbWFpbjogJ2NvbG9yRG9tYWluJyxcbiAgICAgICAgZmllbGQ6ICdjb2xvckZpZWxkJyxcbiAgICAgICAga2V5OiAnY29sb3InLFxuICAgICAgICBwcm9wZXJ0eTogJ2NvbG9yJyxcbiAgICAgICAgcmFuZ2U6ICdjb2xvclJhbmdlJyxcbiAgICAgICAgc2NhbGU6ICdjb2xvclNjYWxlJ1xuICAgICAgfSxcbiAgICAgIHNpemU6IHtcbiAgICAgICAgYWdncmVnYXRpb246ICdzaXplQWdncmVnYXRpb24nLFxuICAgICAgICBjaGFubmVsU2NhbGVUeXBlOiBDSEFOTkVMX1NDQUxFUy5zaXplQWdncixcbiAgICAgICAgY29uZGl0aW9uOiBjb25maWcgPT4gY29uZmlnLnZpc0NvbmZpZy5lbmFibGUzZCxcbiAgICAgICAgZGVmYXVsdE1lYXN1cmU6ICdwcm9wZXJ0eS5wb2ludENvdW50JyxcbiAgICAgICAgZG9tYWluOiAnc2l6ZURvbWFpbicsXG4gICAgICAgIGZpZWxkOiAnc2l6ZUZpZWxkJyxcbiAgICAgICAga2V5OiAnc2l6ZScsXG4gICAgICAgIHByb3BlcnR5OiAnaGVpZ2h0JyxcbiAgICAgICAgcmFuZ2U6ICdzaXplUmFuZ2UnLFxuICAgICAgICBzY2FsZTogJ3NpemVTY2FsZSdcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZGVzY3JpcHRpb24gb2YgYSB2aXN1YWxDaGFubmVsIGNvbmZpZ1xuICAgKiBAcGFyYW0ga2V5XG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBnZXRWaXN1YWxDaGFubmVsRGVzY3JpcHRpb24oa2V5OiBzdHJpbmcpOiBWaXN1YWxDaGFubmVsRGVzY3JpcHRpb24ge1xuICAgIGNvbnN0IGNoYW5uZWwgPSB0aGlzLnZpc3VhbENoYW5uZWxzW2tleV07XG4gICAgaWYgKCFjaGFubmVsKSByZXR1cm4ge2xhYmVsOiAnJywgbWVhc3VyZTogdW5kZWZpbmVkfTtcbiAgICAvLyBlLmcuIGxhYmVsOiBDb2xvciwgbWVhc3VyZTogQXZlcmFnZSBvZiBFVEFcbiAgICBjb25zdCB7cmFuZ2UsIGZpZWxkLCBkZWZhdWx0TWVhc3VyZSwgYWdncmVnYXRpb259ID0gY2hhbm5lbDtcbiAgICBjb25zdCBmaWVsZENvbmZpZyA9IHRoaXMuY29uZmlnW2ZpZWxkXTtcbiAgICBjb25zdCBsYWJlbCA9IHRoaXMudmlzQ29uZmlnU2V0dGluZ3NbcmFuZ2VdPy5sYWJlbDtcblxuICAgIHJldHVybiB7XG4gICAgICBsYWJlbDogdHlwZW9mIGxhYmVsID09PSAnZnVuY3Rpb24nID8gbGFiZWwodGhpcy5jb25maWcpIDogbGFiZWwgfHwgJycsXG4gICAgICBtZWFzdXJlOlxuICAgICAgICBmaWVsZENvbmZpZyAmJiBhZ2dyZWdhdGlvblxuICAgICAgICAgID8gYCR7dGhpcy5jb25maWcudmlzQ29uZmlnW2FnZ3JlZ2F0aW9uXX0gb2YgJHtmaWVsZENvbmZpZy5kaXNwbGF5TmFtZSB8fFxuICAgICAgICAgICAgICBmaWVsZENvbmZpZy5uYW1lfWBcbiAgICAgICAgICA6IGRlZmF1bHRNZWFzdXJlXG4gICAgfTtcbiAgfVxuXG4gIGdldEhvdmVyRGF0YShvYmplY3QpIHtcbiAgICAvLyByZXR1cm4gYWdncmVnYXRlZCBvYmplY3RcbiAgICByZXR1cm4gb2JqZWN0O1xuICB9XG5cbiAgLyoqXG4gICAqIEFnZ3JlZ2F0aW9uIGxheWVyIGhhbmRsZXMgdmlzdWFsIGNoYW5uZWwgYWdncmVnYXRpb24gaW5zaWRlIGRlY2suZ2wgbGF5ZXJcbiAgICovXG4gIHVwZGF0ZUxheWVyVmlzdWFsQ2hhbm5lbCh7ZGF0YUNvbnRhaW5lcn0sIGNoYW5uZWwpIHtcbiAgICB0aGlzLnZhbGlkYXRlVmlzdWFsQ2hhbm5lbChjaGFubmVsKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZSBhZ2dyZWdhdGlvbiB0eXBlIG9uIHRvcCBvZiBiYXNpYyBsYXllciB2aXN1YWwgY2hhbm5lbCB2YWxpZGF0aW9uXG4gICAqIEBwYXJhbSBjaGFubmVsXG4gICAqL1xuICB2YWxpZGF0ZVZpc3VhbENoYW5uZWwoY2hhbm5lbCkge1xuICAgIC8vIGZpZWxkIHR5cGUgZGVjaWRlcyBhZ2dyZWdhdGlvbiB0eXBlIGRlY2lkZXMgc2NhbGUgdHlwZVxuICAgIHRoaXMudmFsaWRhdGVGaWVsZFR5cGUoY2hhbm5lbCk7XG4gICAgdGhpcy52YWxpZGF0ZUFnZ3JlZ2F0aW9uVHlwZShjaGFubmVsKTtcbiAgICB0aGlzLnZhbGlkYXRlU2NhbGUoY2hhbm5lbCk7XG4gIH1cblxuICAvKipcbiAgICogVmFsaWRhdGUgYWdncmVnYXRpb24gdHlwZSBiYXNlZCBvbiBzZWxlY3RlZCBmaWVsZFxuICAgKi9cbiAgdmFsaWRhdGVBZ2dyZWdhdGlvblR5cGUoY2hhbm5lbCkge1xuICAgIGNvbnN0IHZpc3VhbENoYW5uZWwgPSB0aGlzLnZpc3VhbENoYW5uZWxzW2NoYW5uZWxdO1xuICAgIGNvbnN0IHtmaWVsZCwgYWdncmVnYXRpb259ID0gdmlzdWFsQ2hhbm5lbDtcbiAgICBjb25zdCBhZ2dyZWdhdGlvbk9wdGlvbnMgPSB0aGlzLmdldEFnZ3JlZ2F0aW9uT3B0aW9ucyhjaGFubmVsKTtcblxuICAgIGlmICghYWdncmVnYXRpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIWFnZ3JlZ2F0aW9uT3B0aW9ucy5sZW5ndGgpIHtcbiAgICAgIC8vIGlmIGZpZWxkIGNhbm5vdCBiZSBhZ2dyZWdhdGVkLCBzZXQgZmllbGQgdG8gbnVsbFxuICAgICAgdGhpcy51cGRhdGVMYXllckNvbmZpZyh7W2ZpZWxkXTogbnVsbH0pO1xuICAgIH0gZWxzZSBpZiAoIWFnZ3JlZ2F0aW9uT3B0aW9ucy5pbmNsdWRlcyh0aGlzLmNvbmZpZy52aXNDb25maWdbYWdncmVnYXRpb25dKSkge1xuICAgICAgLy8gY3VycmVudCBhZ2dyZWdhdGlvbiB0eXBlIGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhpcyBmaWVsZFxuICAgICAgLy8gc2V0IGFnZ3JlZ2F0aW9uIHRvIHRoZSBmaXJzdCBzdXBwb3J0ZWQgb3B0aW9uXG4gICAgICB0aGlzLnVwZGF0ZUxheWVyVmlzQ29uZmlnKHtbYWdncmVnYXRpb25dOiBhZ2dyZWdhdGlvbk9wdGlvbnNbMF19KTtcbiAgICB9XG4gIH1cblxuICBnZXRBZ2dyZWdhdGlvbk9wdGlvbnMoY2hhbm5lbCkge1xuICAgIGNvbnN0IHZpc3VhbENoYW5uZWwgPSB0aGlzLnZpc3VhbENoYW5uZWxzW2NoYW5uZWxdO1xuICAgIGNvbnN0IHtmaWVsZCwgY2hhbm5lbFNjYWxlVHlwZX0gPSB2aXN1YWxDaGFubmVsO1xuXG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKFxuICAgICAgdGhpcy5jb25maWdbZmllbGRdXG4gICAgICAgID8gRklFTERfT1BUU1t0aGlzLmNvbmZpZ1tmaWVsZF0udHlwZV0uc2NhbGVbY2hhbm5lbFNjYWxlVHlwZV1cbiAgICAgICAgOiBERUZBVUxUX0FHR1JFR0FUSU9OW2NoYW5uZWxTY2FsZVR5cGVdXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgc2NhbGUgb3B0aW9ucyBiYXNlZCBvbiBjdXJyZW50IGZpZWxkIGFuZCBhZ2dyZWdhdGlvbiB0eXBlXG4gICAqIEBwYXJhbSBjaGFubmVsXG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBnZXRTY2FsZU9wdGlvbnMoY2hhbm5lbDogc3RyaW5nKTogc3RyaW5nW10ge1xuICAgIGNvbnN0IHZpc3VhbENoYW5uZWwgPSB0aGlzLnZpc3VhbENoYW5uZWxzW2NoYW5uZWxdO1xuICAgIGNvbnN0IHtmaWVsZCwgYWdncmVnYXRpb24sIGNoYW5uZWxTY2FsZVR5cGV9ID0gdmlzdWFsQ2hhbm5lbDtcbiAgICBjb25zdCBhZ2dyZWdhdGlvblR5cGUgPSBhZ2dyZWdhdGlvbiA/IHRoaXMuY29uZmlnLnZpc0NvbmZpZ1thZ2dyZWdhdGlvbl0gOiBudWxsO1xuXG4gICAgaWYgKCFhZ2dyZWdhdGlvblR5cGUpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5jb25maWdbZmllbGRdXG4gICAgICA/IC8vIHNjYWxlIG9wdGlvbnMgYmFzZWQgb24gYWdncmVnYXRpb25cbiAgICAgICAgRklFTERfT1BUU1t0aGlzLmNvbmZpZ1tmaWVsZF0udHlwZV0uc2NhbGVbY2hhbm5lbFNjYWxlVHlwZV1bYWdncmVnYXRpb25UeXBlXVxuICAgICAgOiAvLyBkZWZhdWx0IHNjYWxlIG9wdGlvbnMgZm9yIHBvaW50IGNvdW50XG4gICAgICAgIERFRkFVTFRfQUdHUkVHQVRJT05bY2hhbm5lbFNjYWxlVHlwZV1bYWdncmVnYXRpb25UeXBlXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZ2dyZWdhdGlvbiBsYXllciBoYW5kbGVzIHZpc3VhbCBjaGFubmVsIGFnZ3JlZ2F0aW9uIGluc2lkZSBkZWNrLmdsIGxheWVyXG4gICAqL1xuICB1cGRhdGVMYXllckRvbWFpbihkYXRhc2V0cywgbmV3RmlsdGVyKTogQWdncmVnYXRpb25MYXllciB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB1cGRhdGVMYXllck1ldGEoZGF0YUNvbnRhaW5lciwgZ2V0UG9zaXRpb24pIHtcbiAgICAvLyBnZXQgYm91bmRzIGZyb20gcG9pbnRzXG4gICAgY29uc3QgYm91bmRzID0gdGhpcy5nZXRQb2ludHNCb3VuZHMoZGF0YUNvbnRhaW5lciwgZ2V0UG9zaXRpb24pO1xuXG4gICAgdGhpcy51cGRhdGVNZXRhKHtib3VuZHN9KTtcbiAgfVxuXG4gIGNhbGN1bGF0ZURhdGFBdHRyaWJ1dGUoe2RhdGFDb250YWluZXIsIGZpbHRlcmVkSW5kZXh9OiBLZXBsZXJUYWJsZSwgZ2V0UG9zaXRpb24pIHtcbiAgICBjb25zdCBkYXRhOiBBZ2dyZWdhdGlvbkxheWVyRGF0YVtdID0gW107XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZpbHRlcmVkSW5kZXgubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGluZGV4ID0gZmlsdGVyZWRJbmRleFtpXTtcbiAgICAgIGNvbnN0IHBvcyA9IGdldFBvc2l0aW9uKHtpbmRleH0pO1xuXG4gICAgICAvLyBpZiBkb2Vzbid0IGhhdmUgcG9pbnQgbGF0IG9yIGxuZywgZG8gbm90IGFkZCB0aGUgcG9pbnRcbiAgICAgIC8vIGRlY2suZ2wgY2FuJ3QgaGFuZGxlIHBvc2l0aW9uID0gbnVsbFxuICAgICAgaWYgKHBvcy5ldmVyeShOdW1iZXIuaXNGaW5pdGUpKSB7XG4gICAgICAgIGRhdGEucHVzaCh7XG4gICAgICAgICAgaW5kZXhcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICBmb3JtYXRMYXllckRhdGEoZGF0YXNldHM6IERhdGFzZXRzLCBvbGRMYXllckRhdGEpIHtcbiAgICBpZiAodGhpcy5jb25maWcuZGF0YUlkID09PSBudWxsKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGNvbnN0IHtncHVGaWx0ZXIsIGRhdGFDb250YWluZXJ9ID0gZGF0YXNldHNbdGhpcy5jb25maWcuZGF0YUlkXTtcbiAgICBjb25zdCBnZXRQb3NpdGlvbiA9IHRoaXMuZ2V0UG9zaXRpb25BY2Nlc3NvcihkYXRhQ29udGFpbmVyKTtcblxuICAgIGNvbnN0IGFnZ3JlZ2F0ZVBvaW50cyA9IGdldFZhbHVlQWdnckZ1bmModGhpcy5nZXRQb2ludERhdGEpO1xuICAgIGNvbnN0IGdldENvbG9yVmFsdWUgPSBhZ2dyZWdhdGVQb2ludHMoXG4gICAgICB0aGlzLmNvbmZpZy5jb2xvckZpZWxkLFxuICAgICAgdGhpcy5jb25maWcudmlzQ29uZmlnLmNvbG9yQWdncmVnYXRpb25cbiAgICApO1xuXG4gICAgY29uc3QgZ2V0RWxldmF0aW9uVmFsdWUgPSBhZ2dyZWdhdGVQb2ludHMoXG4gICAgICB0aGlzLmNvbmZpZy5zaXplRmllbGQsXG4gICAgICB0aGlzLmNvbmZpZy52aXNDb25maWcuc2l6ZUFnZ3JlZ2F0aW9uXG4gICAgKTtcbiAgICBjb25zdCBoYXNGaWx0ZXIgPSBPYmplY3QudmFsdWVzKGdwdUZpbHRlci5maWx0ZXJSYW5nZSkuc29tZSgoYXJyOiBhbnkpID0+XG4gICAgICBhcnIuc29tZSh2ID0+IHYgIT09IDApXG4gICAgKTtcblxuICAgIGNvbnN0IGdldEZpbHRlclZhbHVlID0gZ3B1RmlsdGVyLmZpbHRlclZhbHVlQWNjZXNzb3IoZGF0YUNvbnRhaW5lcikoXG4gICAgICB0aGlzLmdwdUZpbHRlckdldEluZGV4LFxuICAgICAgdGhpcy5ncHVGaWx0ZXJHZXREYXRhXG4gICAgKTtcbiAgICBjb25zdCBmaWx0ZXJEYXRhID0gaGFzRmlsdGVyXG4gICAgICA/IGdldEZpbHRlckRhdGFGdW5jKGdwdUZpbHRlci5maWx0ZXJSYW5nZSwgZ2V0RmlsdGVyVmFsdWUpXG4gICAgICA6IHVuZGVmaW5lZDtcblxuICAgIGNvbnN0IHtkYXRhfSA9IHRoaXMudXBkYXRlRGF0YShkYXRhc2V0cywgb2xkTGF5ZXJEYXRhKTtcblxuICAgIHJldHVybiB7XG4gICAgICBkYXRhLFxuICAgICAgZ2V0UG9zaXRpb24sXG4gICAgICBfZmlsdGVyRGF0YTogZmlsdGVyRGF0YSxcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgIC4uLihnZXRDb2xvclZhbHVlID8ge2dldENvbG9yVmFsdWV9IDoge30pLFxuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgLi4uKGdldEVsZXZhdGlvblZhbHVlID8ge2dldEVsZXZhdGlvblZhbHVlfSA6IHt9KVxuICAgIH07XG4gIH1cblxuICBnZXREZWZhdWx0RGVja0xheWVyUHJvcHMob3B0cyk6IGFueSB7XG4gICAgY29uc3QgYmFzZVByb3AgPSBzdXBlci5nZXREZWZhdWx0RGVja0xheWVyUHJvcHMob3B0cyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmJhc2VQcm9wLFxuICAgICAgaGlnaGxpZ2h0Q29sb3I6IEhJR0hMSUdIX0NPTE9SXzNELFxuICAgICAgLy8gZ3B1IGRhdGEgZmlsdGVyaW5nIGlzIG5vdCBzdXBwb3J0ZWQgaW4gYWdncmVnYXRpb24gbGF5ZXJcbiAgICAgIGV4dGVuc2lvbnM6IFtdLFxuICAgICAgYXV0b0hpZ2hsaWdodDogdGhpcy5jb25maWcudmlzQ29uZmlnLmVuYWJsZTNkXG4gICAgfTtcbiAgfVxuXG4gIGdldERlZmF1bHRBZ2dyZWdhdGlvbkxheWVyUHJvcChvcHRzKSB7XG4gICAgY29uc3Qge2dwdUZpbHRlciwgbWFwU3RhdGUsIGxheWVyQ2FsbGJhY2tzID0ge319ID0gb3B0cztcbiAgICBjb25zdCB7dmlzQ29uZmlnfSA9IHRoaXMuY29uZmlnO1xuICAgIGNvbnN0IGVsZVpvb21GYWN0b3IgPSB0aGlzLmdldEVsZXZhdGlvblpvb21GYWN0b3IobWFwU3RhdGUpO1xuXG4gICAgY29uc3QgdXBkYXRlVHJpZ2dlcnMgPSB7XG4gICAgICBnZXRDb2xvclZhbHVlOiB7XG4gICAgICAgIGNvbG9yRmllbGQ6IHRoaXMuY29uZmlnLmNvbG9yRmllbGQsXG4gICAgICAgIGNvbG9yQWdncmVnYXRpb246IHRoaXMuY29uZmlnLnZpc0NvbmZpZy5jb2xvckFnZ3JlZ2F0aW9uXG4gICAgICB9LFxuICAgICAgZ2V0RWxldmF0aW9uVmFsdWU6IHtcbiAgICAgICAgc2l6ZUZpZWxkOiB0aGlzLmNvbmZpZy5zaXplRmllbGQsXG4gICAgICAgIHNpemVBZ2dyZWdhdGlvbjogdGhpcy5jb25maWcudmlzQ29uZmlnLnNpemVBZ2dyZWdhdGlvblxuICAgICAgfSxcbiAgICAgIF9maWx0ZXJEYXRhOiB7XG4gICAgICAgIGZpbHRlclJhbmdlOiBncHVGaWx0ZXIuZmlsdGVyUmFuZ2UsXG4gICAgICAgIC4uLmdwdUZpbHRlci5maWx0ZXJWYWx1ZVVwZGF0ZVRyaWdnZXJzXG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiB7XG4gICAgICAuLi50aGlzLmdldERlZmF1bHREZWNrTGF5ZXJQcm9wcyhvcHRzKSxcbiAgICAgIGNvdmVyYWdlOiB2aXNDb25maWcuY292ZXJhZ2UsXG5cbiAgICAgIC8vIGNvbG9yXG4gICAgICBjb2xvclJhbmdlOiB0aGlzLmdldENvbG9yUmFuZ2UodmlzQ29uZmlnLmNvbG9yUmFuZ2UpLFxuICAgICAgY29sb3JTY2FsZVR5cGU6IHRoaXMuY29uZmlnLmNvbG9yU2NhbGUsXG4gICAgICB1cHBlclBlcmNlbnRpbGU6IHZpc0NvbmZpZy5wZXJjZW50aWxlWzFdLFxuICAgICAgbG93ZXJQZXJjZW50aWxlOiB2aXNDb25maWcucGVyY2VudGlsZVswXSxcbiAgICAgIGNvbG9yQWdncmVnYXRpb246IHZpc0NvbmZpZy5jb2xvckFnZ3JlZ2F0aW9uLFxuXG4gICAgICAvLyBlbGV2YXRpb25cbiAgICAgIGV4dHJ1ZGVkOiB2aXNDb25maWcuZW5hYmxlM2QsXG4gICAgICBlbGV2YXRpb25TY2FsZTogdmlzQ29uZmlnLmVsZXZhdGlvblNjYWxlICogZWxlWm9vbUZhY3RvcixcbiAgICAgIGVsZXZhdGlvblNjYWxlVHlwZTogdGhpcy5jb25maWcuc2l6ZVNjYWxlLFxuICAgICAgZWxldmF0aW9uUmFuZ2U6IHZpc0NvbmZpZy5zaXplUmFuZ2UsXG4gICAgICBlbGV2YXRpb25Mb3dlclBlcmNlbnRpbGU6IHZpc0NvbmZpZy5lbGV2YXRpb25QZXJjZW50aWxlWzBdLFxuICAgICAgZWxldmF0aW9uVXBwZXJQZXJjZW50aWxlOiB2aXNDb25maWcuZWxldmF0aW9uUGVyY2VudGlsZVsxXSxcblxuICAgICAgLy8gdXBkYXRlVHJpZ2dlcnNcbiAgICAgIHVwZGF0ZVRyaWdnZXJzLFxuXG4gICAgICAvLyBjYWxsYmFja3NcbiAgICAgIG9uU2V0Q29sb3JEb21haW46IGxheWVyQ2FsbGJhY2tzLm9uU2V0TGF5ZXJEb21haW5cbiAgICB9O1xuICB9XG59XG4iXX0=