// Copyright (c) 2022 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = exports.colorMaker = exports.layerColors = exports.OVERLAY_TYPE_CONST = exports.LAYER_ID_LENGTH = void 0;

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _window = require("global/window");

var _keymirror = _interopRequireDefault(require("keymirror"));

var _extensions = require("@deck.gl/extensions");

var _core = require("@deck.gl/core");

var _layers = require("@deck.gl/layers");

var _defaultLayerIcon = _interopRequireDefault(require("./default-layer-icon"));

var _layerUpdate = require("./layer-update");

var _constants = require("@kepler.gl/constants");

var _utils = require("@kepler.gl/utils");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var _marked = /*#__PURE__*/_regenerator["default"].mark(generateColor);

/**
 * Approx. number of points to sample in a large data set
 */
var LAYER_ID_LENGTH = 6;
exports.LAYER_ID_LENGTH = LAYER_ID_LENGTH;
var MAX_SAMPLE_SIZE = 5000;
var defaultDomain = [0, 1];
var dataFilterExtension = new _extensions.DataFilterExtension({
  filterSize: _constants.MAX_GPU_FILTERS
});

var defaultDataAccessor = function defaultDataAccessor(dc) {
  return function (d) {
    return d;
  };
};

var defaultGetFieldValue = function defaultGetFieldValue(field, d) {
  return field.valueAccessor(d);
};

var OVERLAY_TYPE_CONST = (0, _keymirror["default"])({
  deckgl: null,
  mapboxgl: null
});
exports.OVERLAY_TYPE_CONST = OVERLAY_TYPE_CONST;
var layerColors = Object.values(_constants.DataVizColors).map(_utils.hexToRgb);
exports.layerColors = layerColors;

function generateColor() {
  var index;
  return _regenerator["default"].wrap(function generateColor$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          index = 0;

        case 1:
          if (!(index < layerColors.length + 1)) {
            _context.next = 7;
            break;
          }

          if (index === layerColors.length) {
            index = 0;
          }

          _context.next = 5;
          return layerColors[index++];

        case 5:
          _context.next = 1;
          break;

        case 7:
        case "end":
          return _context.stop();
      }
    }
  }, _marked);
}

var colorMaker = generateColor();
exports.colorMaker = colorMaker;

var Layer = /*#__PURE__*/function () {
  // TODO: define meta
  // TODO: define _oldDataUpdateTriggers
  function Layer() {
    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck2["default"])(this, Layer);
    (0, _defineProperty2["default"])(this, "id", void 0);
    (0, _defineProperty2["default"])(this, "meta", void 0);
    (0, _defineProperty2["default"])(this, "visConfigSettings", void 0);
    (0, _defineProperty2["default"])(this, "config", void 0);
    (0, _defineProperty2["default"])(this, "_oldDataUpdateTriggers", void 0);
    this.id = props.id || (0, _utils.generateHashId)(LAYER_ID_LENGTH); // meta

    this.meta = {}; // visConfigSettings

    this.visConfigSettings = {};
    this.config = this.getDefaultLayerConfig(_objectSpread({
      columns: this.getLayerColumns()
    }, props));
  }

  (0, _createClass2["default"])(Layer, [{
    key: "layerIcon",
    get: function get() {
      return _defaultLayerIcon["default"];
    }
  }, {
    key: "overlayType",
    get: function get() {
      return OVERLAY_TYPE_CONST.deckgl;
    }
  }, {
    key: "type",
    get: function get() {
      return null;
    }
  }, {
    key: "name",
    get: function get() {
      return this.type;
    }
  }, {
    key: "isAggregated",
    get: function get() {
      return false;
    }
  }, {
    key: "requiredLayerColumns",
    get: function get() {
      return [];
    }
  }, {
    key: "optionalColumns",
    get: function get() {
      return [];
    }
  }, {
    key: "noneLayerDataAffectingProps",
    get: function get() {
      return ['label', 'opacity', 'thickness', 'isVisible', 'hidden'];
    }
  }, {
    key: "visualChannels",
    get: function get() {
      return {
        color: {
          property: 'color',
          field: 'colorField',
          scale: 'colorScale',
          domain: 'colorDomain',
          range: 'colorRange',
          key: 'color',
          channelScaleType: _constants.CHANNEL_SCALES.color,
          nullValue: _constants.NO_VALUE_COLOR,
          defaultValue: function defaultValue(config) {
            return config.color;
          }
        },
        size: {
          property: 'size',
          field: 'sizeField',
          scale: 'sizeScale',
          domain: 'sizeDomain',
          range: 'sizeRange',
          key: 'size',
          channelScaleType: _constants.CHANNEL_SCALES.size,
          nullValue: 0,
          defaultValue: 1
        }
      };
    }
  }, {
    key: "columnValidators",
    get: function get() {
      return {};
    }
    /*
     * Column pairs maps layer column to a specific field pairs,
     * By default, it is set to null
     */

  }, {
    key: "columnPairs",
    get: function get() {
      return null;
    }
    /*
     * Default point column pairs, can be used for point based layers: point, icon etc.
     */

  }, {
    key: "defaultPointColumnPairs",
    get: function get() {
      return {
        lat: {
          pair: 'lng',
          fieldPairKey: 'lat'
        },
        lng: {
          pair: 'lat',
          fieldPairKey: 'lng'
        }
      };
    }
    /*
     * Default link column pairs, can be used for link based layers: arc, line etc
     */

  }, {
    key: "defaultLinkColumnPairs",
    get: function get() {
      return {
        lat0: {
          pair: 'lng0',
          fieldPairKey: 'lat'
        },
        lng0: {
          pair: 'lat0',
          fieldPairKey: 'lng'
        },
        lat1: {
          pair: 'lng1',
          fieldPairKey: 'lat'
        },
        lng1: {
          pair: 'lat1',
          fieldPairKey: 'lng'
        }
      };
    }
    /**
     * Return a React component for to render layer instructions in a modal
     * @returns {object} - an object
     * @example
     *  return {
     *    id: 'iconInfo',
     *    template: IconInfoModal,
     *    modalProps: {
     *      title: 'How to draw icons'
     *   };
     * }
     */

  }, {
    key: "layerInfoModal",
    get: function get() {
      return null;
    }
  }, {
    key: "supportedDatasetTypes",
    get: function get() {
      return null;
    }
    /*
     * Given a dataset, automatically find props to create layer based on it
     * and return the props and previous found layers.
     * By default, no layers will be found
     */

  }, {
    key: "getDefaultLayerConfig",
    value: function getDefaultLayerConfig() {
      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      return {
        dataId: props.dataId || null,
        label: props.label || _constants.DEFAULT_LAYER_LABEL,
        color: props.color || colorMaker.next().value,
        columns: props.columns || {},
        isVisible: props.isVisible || false,
        isConfigActive: props.isConfigActive || false,
        highlightColor: props.highlightColor || _constants.DEFAULT_HIGHLIGHT_COLOR,
        hidden: props.hidden || false,
        // TODO: refactor this into separate visual Channel config
        // color by field, domain is set by filters, field, scale type
        colorField: null,
        colorDomain: [0, 1],
        colorScale: _constants.SCALE_TYPES.quantile,
        // color by size, domain is set by filters, field, scale type
        sizeDomain: [0, 1],
        sizeScale: _constants.SCALE_TYPES.linear,
        sizeField: null,
        visConfig: {},
        textLabel: [_constants.DEFAULT_TEXT_LABEL],
        colorUI: {
          color: _constants.DEFAULT_COLOR_UI,
          colorRange: _constants.DEFAULT_COLOR_UI
        },
        animation: {
          enabled: false
        }
      };
    }
    /**
     * Get the description of a visualChannel config
     * @param key
     * @returns
     */

  }, {
    key: "getVisualChannelDescription",
    value: function getVisualChannelDescription(key) {
      // e.g. label: Color, measure: Vehicle Type
      var channel = this.visualChannels[key];
      if (!channel) return {
        label: '',
        measure: undefined
      };
      var rangeSettings = this.visConfigSettings[channel.range];
      var fieldSettings = this.config[channel.field];
      var label = rangeSettings === null || rangeSettings === void 0 ? void 0 : rangeSettings.label;
      return {
        label: typeof label === 'function' ? label(this.config) : label || '',
        measure: fieldSettings ? fieldSettings.displayName || fieldSettings.name : channel.defaultMeasure
      };
    }
    /**
     * Assign a field to layer column, return column config
     * @param key - Column Key
     * @param field - Selected field
     * @returns {{}} - Column config
     */

  }, {
    key: "assignColumn",
    value: function assignColumn(key, field) {
      // field value could be null for optional columns
      var update = field ? {
        value: field.name,
        fieldIdx: field.fieldIdx
      } : {
        value: null,
        fieldIdx: -1
      };
      return _objectSpread(_objectSpread({}, this.config.columns), {}, (0, _defineProperty2["default"])({}, key, _objectSpread(_objectSpread({}, this.config.columns[key]), update)));
    }
    /**
     * Assign a field pair to column config, return column config
     * @param key - Column Key
     * @param pair - field Pair
     * @returns {object} - Column config
     */

  }, {
    key: "assignColumnPairs",
    value: function assignColumnPairs(key, pair) {
      var _this$columnPairs, _this$columnPairs2, _this$columnPairs3, _objectSpread3;

      if (!this.columnPairs || !((_this$columnPairs = this.columnPairs) !== null && _this$columnPairs !== void 0 && _this$columnPairs[key])) {
        // should not end in this state
        return this.config.columns;
      }

      var _this$columnPairs$key = (_this$columnPairs2 = this.columnPairs) === null || _this$columnPairs2 === void 0 ? void 0 : _this$columnPairs2[key],
          partnerKey = _this$columnPairs$key.pair,
          fieldPairKey = _this$columnPairs$key.fieldPairKey;

      var _this$columnPairs$par = (_this$columnPairs3 = this.columnPairs) === null || _this$columnPairs3 === void 0 ? void 0 : _this$columnPairs3[partnerKey],
          partnerFieldPairKey = _this$columnPairs$par.fieldPairKey;

      return _objectSpread(_objectSpread({}, this.config.columns), {}, (_objectSpread3 = {}, (0, _defineProperty2["default"])(_objectSpread3, key, pair[fieldPairKey]), (0, _defineProperty2["default"])(_objectSpread3, partnerKey, pair[partnerFieldPairKey]), _objectSpread3));
    }
    /**
     * Calculate a radius zoom multiplier to render points, so they are visible in all zoom level
     * @param {object} mapState
     * @param {number} mapState.zoom - actual zoom
     * @param {number | void} mapState.zoomOffset - zoomOffset when render in the plot container for export image
     * @returns {number}
     */

  }, {
    key: "getZoomFactor",
    value: function getZoomFactor(_ref) {
      var zoom = _ref.zoom,
          _ref$zoomOffset = _ref.zoomOffset,
          zoomOffset = _ref$zoomOffset === void 0 ? 0 : _ref$zoomOffset;
      return Math.pow(2, Math.max(14 - zoom + zoomOffset, 0));
    }
    /**
     * Calculate a elevation zoom multiplier to render points, so they are visible in all zoom level
     * @param {object} mapState
     * @param {number} mapState.zoom - actual zoom
     * @param {number | void} mapState.zoomOffset - zoomOffset when render in the plot container for export image
     * @returns {number}
     */

  }, {
    key: "getElevationZoomFactor",
    value: function getElevationZoomFactor(_ref2) {
      var zoom = _ref2.zoom,
          _ref2$zoomOffset = _ref2.zoomOffset,
          zoomOffset = _ref2$zoomOffset === void 0 ? 0 : _ref2$zoomOffset;
      return this.config.visConfig.enableElevationZoomFactor ? Math.pow(2, Math.max(8 - zoom + zoomOffset, 0)) : 1;
    }
  }, {
    key: "formatLayerData",
    value: function formatLayerData(datasets, oldLayerData) {
      return {};
    }
  }, {
    key: "renderLayer",
    value: function renderLayer() {
      return [];
    }
  }, {
    key: "getHoverData",
    value: function getHoverData(object, dataContainer, fields) {
      if (!object) {
        return null;
      } // By default, each entry of layerData should have an index of a row in the original data container.
      // Each layer can implement its own getHoverData method


      return dataContainer.row(object.index);
    }
    /**
     * When change layer type, try to copy over layer configs as much as possible
     * @param configToCopy - config to copy over
     * @param visConfigSettings - visConfig settings of config to copy
     */

  }, {
    key: "assignConfigToLayer",
    value: function assignConfigToLayer(configToCopy, visConfigSettings) {
      var _this = this;

      // don't deep merge visualChannel field
      // don't deep merge color range, reversed: is not a key by default
      var shallowCopy = ['colorRange', 'strokeColorRange'].concat(Object.values(this.visualChannels).map(function (v) {
        return v.field;
      })); // don't copy over domain and animation

      var notToCopy = ['animation'].concat(Object.values(this.visualChannels).map(function (v) {
        return v.domain;
      })); // if range is for the same property group copy it, otherwise, not to copy

      Object.values(this.visualChannels).forEach(function (v) {
        if (configToCopy.visConfig[v.range] && _this.visConfigSettings[v.range] && visConfigSettings[v.range].group !== _this.visConfigSettings[v.range].group) {
          notToCopy.push(v.range);
        }
      }); // don't copy over visualChannel range

      var currentConfig = this.config;
      var copied = this.copyLayerConfig(currentConfig, configToCopy, {
        shallowCopy: shallowCopy,
        notToCopy: notToCopy
      });
      this.updateLayerConfig(copied); // validate visualChannel field type and scale types

      Object.keys(this.visualChannels).forEach(function (channel) {
        _this.validateVisualChannel(channel);
      });
    }
    /*
     * Recursively copy config over to an empty layer
     * when received saved config, or copy config over from a different layer type
     * make sure to only copy over value to existing keys
     * @param {object} currentConfig - existing config to be override
     * @param {object} configToCopy - new Config to copy over
     * @param {string[]} shallowCopy - array of properties to not to be deep copied
     * @param {string[]} notToCopy - array of properties not to copy
     * @returns {object} - copied config
     */

  }, {
    key: "copyLayerConfig",
    value: function copyLayerConfig(currentConfig, configToCopy) {
      var _this2 = this;

      var _ref3 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
          _ref3$shallowCopy = _ref3.shallowCopy,
          shallowCopy = _ref3$shallowCopy === void 0 ? [] : _ref3$shallowCopy,
          _ref3$notToCopy = _ref3.notToCopy,
          notToCopy = _ref3$notToCopy === void 0 ? [] : _ref3$notToCopy;

      var copied = {};
      Object.keys(currentConfig).forEach(function (key) {
        if ((0, _utils.isPlainObject)(currentConfig[key]) && (0, _utils.isPlainObject)(configToCopy[key]) && !shallowCopy.includes(key) && !notToCopy.includes(key)) {
          // recursively assign object value
          copied[key] = _this2.copyLayerConfig(currentConfig[key], configToCopy[key], {
            shallowCopy: shallowCopy,
            notToCopy: notToCopy
          });
        } else if ((0, _utils.notNullorUndefined)(configToCopy[key]) && !notToCopy.includes(key)) {
          // copy
          copied[key] = configToCopy[key];
        } else {
          // keep existing
          copied[key] = currentConfig[key];
        }
      });
      return copied;
    }
  }, {
    key: "registerVisConfig",
    value: function registerVisConfig(layerVisConfigs) {
      var _this3 = this;

      Object.keys(layerVisConfigs).forEach(function (item) {
        var configItem = layerVisConfigs[item];

        if (typeof configItem === 'string' && _constants.LAYER_VIS_CONFIGS[configItem]) {
          // if assigned one of default LAYER_CONFIGS
          _this3.config.visConfig[item] = _constants.LAYER_VIS_CONFIGS[configItem].defaultValue;
          _this3.visConfigSettings[item] = _constants.LAYER_VIS_CONFIGS[configItem];
        } else if ((0, _typeof2["default"])(configItem) === 'object' && ['type', 'defaultValue'].every(function (p) {
          return configItem.hasOwnProperty(p);
        })) {
          // if provided customized visConfig, and has type && defaultValue
          // TODO: further check if customized visConfig is valid
          _this3.config.visConfig[item] = configItem.defaultValue;
          _this3.visConfigSettings[item] = configItem;
        }
      });
    }
  }, {
    key: "getLayerColumns",
    value: function getLayerColumns() {
      var columnValidators = this.columnValidators;
      var required = this.requiredLayerColumns.reduce(function (accu, key) {
        return _objectSpread(_objectSpread({}, accu), {}, (0, _defineProperty2["default"])({}, key, columnValidators[key] ? {
          value: null,
          fieldIdx: -1,
          validator: columnValidators[key]
        } : {
          value: null,
          fieldIdx: -1
        }));
      }, {});
      var optional = this.optionalColumns.reduce(function (accu, key) {
        return _objectSpread(_objectSpread({}, accu), {}, (0, _defineProperty2["default"])({}, key, {
          value: null,
          fieldIdx: -1,
          optional: true
        }));
      }, {});
      return _objectSpread(_objectSpread({}, required), optional);
    }
  }, {
    key: "updateLayerConfig",
    value: function updateLayerConfig(newConfig) {
      this.config = _objectSpread(_objectSpread({}, this.config), newConfig);
      return this;
    }
  }, {
    key: "updateLayerVisConfig",
    value: function updateLayerVisConfig(newVisConfig) {
      this.config.visConfig = _objectSpread(_objectSpread({}, this.config.visConfig), newVisConfig);
      return this;
    }
  }, {
    key: "updateLayerColorUI",
    value: function updateLayerColorUI(prop, newConfig) {
      var _this$config = this.config,
          previous = _this$config.colorUI,
          visConfig = _this$config.visConfig;

      if (!(0, _utils.isPlainObject)(newConfig) || typeof prop !== 'string') {
        return this;
      }

      var colorUIProp = Object.entries(newConfig).reduce(function (accu, _ref4) {
        var _ref5 = (0, _slicedToArray2["default"])(_ref4, 2),
            key = _ref5[0],
            value = _ref5[1];

        return _objectSpread(_objectSpread({}, accu), {}, (0, _defineProperty2["default"])({}, key, (0, _utils.isPlainObject)(accu[key]) && (0, _utils.isPlainObject)(value) ? _objectSpread(_objectSpread({}, accu[key]), value) : value));
      }, previous[prop] || _constants.DEFAULT_COLOR_UI);

      var colorUI = _objectSpread(_objectSpread({}, previous), {}, (0, _defineProperty2["default"])({}, prop, colorUIProp));

      this.updateLayerConfig({
        colorUI: colorUI
      }); // if colorUI[prop] is colorRange

      var isColorRange = visConfig[prop] && visConfig[prop].colors;

      if (isColorRange) {
        this.updateColorUIByColorRange(newConfig, prop);
        this.updateColorRangeByColorUI(newConfig, previous, prop);
        this.updateCustomPalette(newConfig, previous, prop);
      }

      return this;
    }
  }, {
    key: "updateCustomPalette",
    value: function updateCustomPalette(newConfig, previous, prop) {
      if (!newConfig.colorRangeConfig || !newConfig.colorRangeConfig.custom) {
        return;
      }

      var _this$config2 = this.config,
          colorUI = _this$config2.colorUI,
          visConfig = _this$config2.visConfig;
      if (!visConfig[prop]) return;
      var colors = visConfig[prop].colors;

      var customPalette = _objectSpread(_objectSpread({}, colorUI[prop].customPalette), {}, {
        name: 'Custom Palette',
        colors: (0, _toConsumableArray2["default"])(colors)
      });

      this.updateLayerConfig({
        colorUI: _objectSpread(_objectSpread({}, colorUI), {}, (0, _defineProperty2["default"])({}, prop, _objectSpread(_objectSpread({}, colorUI[prop]), {}, {
          customPalette: customPalette
        })))
      });
    }
    /**
     * if open dropdown and prop is color range
     * Automatically set colorRangeConfig's step and reversed
     * @param {*} newConfig
     * @param {*} prop
     */

  }, {
    key: "updateColorUIByColorRange",
    value: function updateColorUIByColorRange(newConfig, prop) {
      if (typeof newConfig.showDropdown !== 'number') return;
      var _this$config3 = this.config,
          colorUI = _this$config3.colorUI,
          visConfig = _this$config3.visConfig;
      this.updateLayerConfig({
        colorUI: _objectSpread(_objectSpread({}, colorUI), {}, (0, _defineProperty2["default"])({}, prop, _objectSpread(_objectSpread({}, colorUI[prop]), {}, {
          colorRangeConfig: _objectSpread(_objectSpread({}, colorUI[prop].colorRangeConfig), {}, {
            steps: visConfig[prop].colors.length,
            reversed: Boolean(visConfig[prop].reversed)
          })
        })))
      });
    }
  }, {
    key: "updateColorRangeByColorUI",
    value: function updateColorRangeByColorUI(newConfig, previous, prop) {
      // only update colorRange if changes in UI is made to 'reversed', 'steps' or steps
      var shouldUpdate = newConfig.colorRangeConfig && ['reversed', 'steps'].some(function (key) {
        return newConfig.colorRangeConfig.hasOwnProperty(key) && newConfig.colorRangeConfig[key] !== (previous[prop] || _constants.DEFAULT_COLOR_UI).colorRangeConfig[key];
      });
      if (!shouldUpdate) return;
      var _this$config4 = this.config,
          colorUI = _this$config4.colorUI,
          visConfig = _this$config4.visConfig;
      var _colorUI$prop$colorRa = colorUI[prop].colorRangeConfig,
          steps = _colorUI$prop$colorRa.steps,
          reversed = _colorUI$prop$colorRa.reversed;
      var colorRange = visConfig[prop]; // find based on step or reversed

      var update;

      if (newConfig.colorRangeConfig.hasOwnProperty('steps')) {
        var group = (0, _utils.getColorGroupByName)(colorRange);

        if (group) {
          var sameGroup = _constants.COLOR_RANGES.filter(function (cr) {
            return (0, _utils.getColorGroupByName)(cr) === group;
          });

          update = sameGroup.find(function (cr) {
            return cr.colors.length === steps;
          });

          if (update && colorRange.reversed) {
            update = (0, _utils.reverseColorRange)(true, update);
          }
        }
      }

      if (newConfig.colorRangeConfig.hasOwnProperty('reversed')) {
        update = (0, _utils.reverseColorRange)(reversed, update || colorRange);
      }

      if (update) {
        this.updateLayerVisConfig((0, _defineProperty2["default"])({}, prop, update));
      }
    }
    /**
     * Check whether layer has all columns
     * @returns yes or no
     */

  }, {
    key: "hasAllColumns",
    value: function hasAllColumns() {
      var columns = this.config.columns;
      return columns && Object.values(columns).every(function (v) {
        return Boolean(v.optional || v.value && v.fieldIdx > -1);
      });
    }
    /**
     * Check whether layer has data
     *
     * @param {Array | Object} layerData
     * @returns {boolean} yes or no
     */

  }, {
    key: "hasLayerData",
    value: function hasLayerData(layerData) {
      if (!layerData) {
        return false;
      }

      return Boolean(layerData.data && layerData.data.length);
    }
  }, {
    key: "isValidToSave",
    value: function isValidToSave() {
      return Boolean(this.type && this.hasAllColumns());
    }
  }, {
    key: "shouldRenderLayer",
    value: function shouldRenderLayer(data) {
      return Boolean(this.type) && this.hasAllColumns() && this.hasLayerData(data) && typeof this.renderLayer === 'function';
    }
  }, {
    key: "getColorScale",
    value: function getColorScale(colorScale, colorDomain, colorRange) {
      if (Array.isArray(colorRange.colorMap)) {
        var cMap = new Map();
        colorRange.colorMap.forEach(function (_ref6) {
          var _ref7 = (0, _slicedToArray2["default"])(_ref6, 2),
              k = _ref7[0],
              v = _ref7[1];

          cMap.set(k, typeof v === 'string' ? (0, _utils.hexToRgb)(v) : v);
        });

        var scale = _constants.SCALE_FUNC[_constants.SCALE_TYPES.ordinal]().domain(cMap.keys()).range(cMap.values()).unknown(cMap.get(_constants.UNKNOWN_COLOR_KEY) || _constants.NO_VALUE_COLOR);

        return scale;
      }

      return this.getVisChannelScale(colorScale, colorDomain, colorRange.colors.map(_utils.hexToRgb));
    }
    /**
     * Mapping from visual channels to deck.gl accesors
     * @param {Object} param Parameters
     * @param {Function} param.dataAccessor Access kepler.gl layer data from deck.gl layer
     * @param {import('utils/table-utils/data-container-interface').DataContainerInterface} param.dataContainer DataContainer to use use with dataAccessor
     * @return {Object} attributeAccessors - deck.gl layer attribute accessors
     */

  }, {
    key: "getAttributeAccessors",
    value: function getAttributeAccessors(_ref8) {
      var _this4 = this;

      var _ref8$dataAccessor = _ref8.dataAccessor,
          dataAccessor = _ref8$dataAccessor === void 0 ? defaultDataAccessor : _ref8$dataAccessor,
          dataContainer = _ref8.dataContainer;
      var attributeAccessors = {};
      Object.keys(this.visualChannels).forEach(function (channel) {
        var _this4$visualChannels = _this4.visualChannels[channel],
            field = _this4$visualChannels.field,
            fixed = _this4$visualChannels.fixed,
            scale = _this4$visualChannels.scale,
            domain = _this4$visualChannels.domain,
            range = _this4$visualChannels.range,
            accessor = _this4$visualChannels.accessor,
            defaultValue = _this4$visualChannels.defaultValue,
            getAttributeValue = _this4$visualChannels.getAttributeValue,
            nullValue = _this4$visualChannels.nullValue,
            channelScaleType = _this4$visualChannels.channelScaleType;

        if (accessor) {
          var shouldGetScale = _this4.config[field];

          if (shouldGetScale) {
            var isFixed = fixed && _this4.config.visConfig[fixed];
            var scaleFunction = channelScaleType === _constants.CHANNEL_SCALES.color ? _this4.getColorScale(_this4.config[scale], _this4.config[domain], _this4.config.visConfig[range]) : _this4.getVisChannelScale(_this4.config[scale], _this4.config[domain], _this4.config.visConfig[range], isFixed);

            attributeAccessors[accessor] = function (d) {
              return _this4.getEncodedChannelValue(scaleFunction, dataAccessor(dataContainer)(d), _this4.config[field], nullValue);
            };
          } else if (typeof getAttributeValue === 'function') {
            attributeAccessors[accessor] = getAttributeValue(_this4.config);
          } else {
            attributeAccessors[accessor] = typeof defaultValue === 'function' ? defaultValue(_this4.config) : defaultValue;
          }

          if (!attributeAccessors[accessor]) {
            _window.console.warn("Failed to provide accessor function for ".concat(accessor || channel));
          }
        }
      });
      return attributeAccessors;
    }
  }, {
    key: "getVisChannelScale",
    value: function getVisChannelScale(scale, domain, range, fixed) {
      return _constants.SCALE_FUNC[fixed ? 'linear' : scale]().domain(domain).range(fixed ? domain : range);
    }
    /**
     * Get longitude and latitude bounds of the data.
     * @param {import('utils/table-utils/data-container-interface').DataContainerInterface} dataContainer DataContainer to calculate bounds for.
     * @param {(d: {index: number}, dc: import('utils/table-utils/data-container-interface').DataContainerInterface) => number[]} getPosition Access kepler.gl layer data from deck.gl layer
     * @return {number[]|null} bounds of the data.
     */

  }, {
    key: "getPointsBounds",
    value: function getPointsBounds(dataContainer, getPosition) {
      // no need to loop through the entire dataset
      // get a sample of data to calculate bounds
      var sampleData = dataContainer.numRows() > MAX_SAMPLE_SIZE ? (0, _utils.getSampleContainerData)(dataContainer, MAX_SAMPLE_SIZE) : dataContainer;
      var points = sampleData.mapIndex(getPosition);
      var latBounds = (0, _utils.getLatLngBounds)(points, 1, [-90, 90]);
      var lngBounds = (0, _utils.getLatLngBounds)(points, 0, [-180, 180]);

      if (!latBounds || !lngBounds) {
        return null;
      }

      return [lngBounds[0], latBounds[0], lngBounds[1], latBounds[1]];
    }
  }, {
    key: "getChangedTriggers",
    value: function getChangedTriggers(dataUpdateTriggers) {
      var triggerChanged = (0, _layerUpdate.diffUpdateTriggers)(dataUpdateTriggers, this._oldDataUpdateTriggers);
      this._oldDataUpdateTriggers = dataUpdateTriggers;
      return triggerChanged;
    }
  }, {
    key: "getEncodedChannelValue",
    value: function getEncodedChannelValue(scale, data, field) {
      var nullValue = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : _constants.NO_VALUE_COLOR;
      var getValue = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : defaultGetFieldValue;
      // @ts-expect-error TODO: VisualChannelField better typing
      var type = field.type;
      var value = getValue(field, data);

      if (!(0, _utils.notNullorUndefined)(value)) {
        return nullValue;
      }

      var attributeValue;

      if (type === _constants.ALL_FIELD_TYPES.timestamp) {
        // shouldn't need to convert here
        // scale Function should take care of it
        attributeValue = scale(new Date(value));
      } else {
        attributeValue = scale(value);
      }

      if (!(0, _utils.notNullorUndefined)(attributeValue)) {
        attributeValue = nullValue;
      }

      return attributeValue;
    }
  }, {
    key: "updateMeta",
    value: function updateMeta(meta) {
      this.meta = _objectSpread(_objectSpread({}, this.meta), meta);
    }
  }, {
    key: "getDataUpdateTriggers",
    value: function getDataUpdateTriggers(_ref9) {
      var filteredIndex = _ref9.filteredIndex,
          id = _ref9.id,
          dataContainer = _ref9.dataContainer;
      var columns = this.config.columns;
      return _objectSpread({
        getData: {
          datasetId: id,
          dataContainer: dataContainer,
          columns: columns,
          filteredIndex: filteredIndex
        },
        getMeta: {
          datasetId: id,
          dataContainer: dataContainer,
          columns: columns
        }
      }, (this.config.textLabel || []).reduce(function (accu, tl, i) {
        return _objectSpread(_objectSpread({}, accu), {}, (0, _defineProperty2["default"])({}, "getLabelCharacterSet-".concat(i), tl.field ? tl.field.name : null));
      }, {}));
    }
  }, {
    key: "updateData",
    value: function updateData(datasets, oldLayerData) {
      if (!this.config.dataId) {
        return {};
      }

      var layerDataset = datasets[this.config.dataId];
      var dataContainer = layerDataset.dataContainer;
      var getPosition = this.getPositionAccessor(dataContainer);
      var dataUpdateTriggers = this.getDataUpdateTriggers(layerDataset);
      var triggerChanged = this.getChangedTriggers(dataUpdateTriggers);

      if (triggerChanged && triggerChanged.getMeta) {
        this.updateLayerMeta(dataContainer, getPosition);
      }

      var data = [];

      if (!(triggerChanged && triggerChanged.getData) && oldLayerData && oldLayerData.data) {
        // same data
        data = oldLayerData.data;
      } else {
        data = this.calculateDataAttribute(layerDataset, getPosition);
      }

      return {
        data: data,
        triggerChanged: triggerChanged
      };
    }
    /**
     * helper function to update one layer domain when state.data changed
     * if state.data change is due ot update filter, newFiler will be passed
     * called by updateAllLayerDomainData
     * @param datasets
     * @param newFilter
     * @returns layer
     */

  }, {
    key: "updateLayerDomain",
    value: function updateLayerDomain(datasets, newFilter) {
      var _this5 = this;

      var table = this.getDataset(datasets);

      if (!table) {
        return this;
      }

      Object.values(this.visualChannels).forEach(function (channel) {
        var scale = channel.scale;
        var scaleType = _this5.config[scale]; // ordinal domain is based on dataContainer, if only filter changed
        // no need to update ordinal domain

        if (!newFilter || scaleType !== _constants.SCALE_TYPES.ordinal) {
          var domain = channel.domain;

          var updatedDomain = _this5.calculateLayerDomain(table, channel);

          _this5.updateLayerConfig((0, _defineProperty2["default"])({}, domain, updatedDomain));
        }
      });
      return this;
    }
  }, {
    key: "getDataset",
    value: function getDataset(datasets) {
      return this.config.dataId ? datasets[this.config.dataId] : null;
    }
    /**
     * Validate visual channel field and scales based on supported field & scale type
     * @param channel
     */

  }, {
    key: "validateVisualChannel",
    value: function validateVisualChannel(channel) {
      this.validateFieldType(channel);
      this.validateScale(channel);
    }
    /**
     * Validate field type based on channelScaleType
     */

  }, {
    key: "validateFieldType",
    value: function validateFieldType(channel) {
      var visualChannel = this.visualChannels[channel];
      var field = visualChannel.field,
          channelScaleType = visualChannel.channelScaleType,
          supportedFieldTypes = visualChannel.supportedFieldTypes;

      if (this.config[field]) {
        // if field is selected, check if field type is supported
        var channelSupportedFieldTypes = supportedFieldTypes || _constants.CHANNEL_SCALE_SUPPORTED_FIELDS[channelScaleType];

        if (!channelSupportedFieldTypes.includes(this.config[field].type)) {
          // field type is not supported, set it back to null
          // set scale back to default
          this.updateLayerConfig((0, _defineProperty2["default"])({}, field, null));
        }
      }
    }
    /**
     * Validate scale type based on aggregation
     */

  }, {
    key: "validateScale",
    value: function validateScale(channel) {
      var visualChannel = this.visualChannels[channel];
      var scale = visualChannel.scale;

      if (!scale) {
        // visualChannel doesn't have scale
        return;
      }

      var scaleOptions = this.getScaleOptions(channel); // check if current selected scale is
      // supported, if not, change to default

      if (!scaleOptions.includes(this.config[scale])) {
        this.updateLayerConfig((0, _defineProperty2["default"])({}, scale, scaleOptions[0]));
      }
    }
    /**
     * Get scale options based on current field
     * @param {string} channel
     * @returns {string[]}
     */

  }, {
    key: "getScaleOptions",
    value: function getScaleOptions(channel) {
      var visualChannel = this.visualChannels[channel];
      var field = visualChannel.field,
          scale = visualChannel.scale,
          channelScaleType = visualChannel.channelScaleType;
      return this.config[field] ? _constants.FIELD_OPTS[this.config[field].type].scale[channelScaleType] : [this.getDefaultLayerConfig()[scale]];
    }
  }, {
    key: "updateLayerVisualChannel",
    value: function updateLayerVisualChannel(dataset, channel) {
      var visualChannel = this.visualChannels[channel];
      this.validateVisualChannel(channel); // calculate layer channel domain

      var updatedDomain = this.calculateLayerDomain(dataset, visualChannel);
      this.updateLayerConfig((0, _defineProperty2["default"])({}, visualChannel.domain, updatedDomain));
    }
  }, {
    key: "getVisualChannelUpdateTriggers",
    value: function getVisualChannelUpdateTriggers() {
      var _this6 = this;

      var updateTriggers = {};
      Object.values(this.visualChannels).forEach(function (visualChannel) {
        // field range scale domain
        var accessor = visualChannel.accessor,
            field = visualChannel.field,
            scale = visualChannel.scale,
            domain = visualChannel.domain,
            range = visualChannel.range,
            defaultValue = visualChannel.defaultValue,
            fixed = visualChannel.fixed;

        if (accessor) {
          var _objectSpread11;

          updateTriggers[accessor] = _objectSpread((_objectSpread11 = {}, (0, _defineProperty2["default"])(_objectSpread11, field, _this6.config[field]), (0, _defineProperty2["default"])(_objectSpread11, scale, _this6.config[scale]), (0, _defineProperty2["default"])(_objectSpread11, domain, _this6.config[domain]), (0, _defineProperty2["default"])(_objectSpread11, range, _this6.config.visConfig[range]), (0, _defineProperty2["default"])(_objectSpread11, "defaultValue", typeof defaultValue === 'function' ? defaultValue(_this6.config) : defaultValue), _objectSpread11), fixed ? (0, _defineProperty2["default"])({}, fixed, _this6.config.visConfig[fixed]) : {});
        }
      });
      return updateTriggers;
    }
  }, {
    key: "calculateLayerDomain",
    value: function calculateLayerDomain(dataset, visualChannel) {
      var scale = visualChannel.scale;
      var scaleType = this.config[scale];
      var field = this.config[visualChannel.field];

      if (!field) {
        // if colorField or sizeField were set back to null
        return defaultDomain;
      }

      return dataset.getColumnLayerDomain(field, scaleType) || defaultDomain;
    }
  }, {
    key: "hasHoveredObject",
    value: function hasHoveredObject(objectInfo) {
      return this.isLayerHovered(objectInfo) && objectInfo.object ? objectInfo.object : null;
    }
  }, {
    key: "isLayerHovered",
    value: function isLayerHovered(objectInfo) {
      var _objectInfo$layer, _objectInfo$layer$pro;

      return (objectInfo === null || objectInfo === void 0 ? void 0 : objectInfo.picked) && (objectInfo === null || objectInfo === void 0 ? void 0 : (_objectInfo$layer = objectInfo.layer) === null || _objectInfo$layer === void 0 ? void 0 : (_objectInfo$layer$pro = _objectInfo$layer.props) === null || _objectInfo$layer$pro === void 0 ? void 0 : _objectInfo$layer$pro.id) === this.id;
    }
  }, {
    key: "getRadiusScaleByZoom",
    value: function getRadiusScaleByZoom(mapState, fixedRadius) {
      var radiusChannel = Object.values(this.visualChannels).find(function (vc) {
        return vc.property === 'radius';
      });

      if (!radiusChannel) {
        return 1;
      }

      var field = radiusChannel.field;
      var fixed = fixedRadius === undefined ? this.config.visConfig.fixedRadius : fixedRadius;
      var radius = this.config.visConfig.radius;
      return fixed ? 1 : (this.config[field] ? 1 : radius) * this.getZoomFactor(mapState);
    }
  }, {
    key: "shouldCalculateLayerData",
    value: function shouldCalculateLayerData(props) {
      var _this7 = this;

      return props.some(function (p) {
        return !_this7.noneLayerDataAffectingProps.includes(p);
      });
    }
  }, {
    key: "getBrushingExtensionProps",
    value: function getBrushingExtensionProps(interactionConfig, brushingTarget) {
      var brush = interactionConfig.brush;
      return {
        // brushing
        autoHighlight: !brush.enabled,
        brushingRadius: brush.config.size * 1000,
        brushingTarget: brushingTarget || 'source',
        brushingEnabled: brush.enabled
      };
    }
  }, {
    key: "getDefaultDeckLayerProps",
    value: function getDefaultDeckLayerProps(_ref11) {
      var idx = _ref11.idx,
          gpuFilter = _ref11.gpuFilter,
          mapState = _ref11.mapState,
          visible = _ref11.visible;
      return {
        id: this.id,
        idx: idx,
        coordinateSystem: _core.COORDINATE_SYSTEM.LNGLAT,
        pickable: true,
        wrapLongitude: true,
        parameters: {
          depthTest: Boolean(mapState.dragRotate || this.config.visConfig.enable3d)
        },
        hidden: this.config.hidden,
        // visconfig
        opacity: this.config.visConfig.opacity,
        highlightColor: this.config.highlightColor,
        // data filtering
        extensions: [dataFilterExtension],
        filterRange: gpuFilter ? gpuFilter.filterRange : undefined,
        // layer should be visible and if splitMap, shown in to one of panel
        visible: this.config.isVisible && visible
      };
    }
  }, {
    key: "getDefaultHoverLayerProps",
    value: function getDefaultHoverLayerProps() {
      return {
        id: "".concat(this.id, "-hovered"),
        pickable: false,
        wrapLongitude: true,
        coordinateSystem: _core.COORDINATE_SYSTEM.LNGLAT
      };
    }
  }, {
    key: "renderTextLabelLayer",
    value: function renderTextLabelLayer(_ref12, renderOpts) {
      var _this8 = this;

      var getPosition = _ref12.getPosition,
          getPixelOffset = _ref12.getPixelOffset,
          updateTriggers = _ref12.updateTriggers,
          sharedProps = _ref12.sharedProps;
      var data = renderOpts.data,
          mapState = renderOpts.mapState;
      var textLabel = this.config.textLabel;
      return data.textLabels.reduce(function (accu, d, i) {
        if (d.getText) {
          var _textLabel$i$field, _textLabel$i$field2;

          accu.push(new _layers.TextLayer(_objectSpread(_objectSpread({}, sharedProps), {}, {
            id: "".concat(_this8.id, "-label-").concat((_textLabel$i$field = textLabel[i].field) === null || _textLabel$i$field === void 0 ? void 0 : _textLabel$i$field.name),
            data: data.data,
            getText: d.getText,
            getPosition: getPosition,
            characterSet: d.characterSet,
            getPixelOffset: getPixelOffset(textLabel[i]),
            getSize: _constants.PROJECTED_PIXEL_SIZE_MULTIPLIER,
            sizeScale: textLabel[i].size,
            getTextAnchor: textLabel[i].anchor,
            getAlignmentBaseline: textLabel[i].alignment,
            getColor: textLabel[i].color,
            parameters: {
              // text will always show on top of all layers
              depthTest: false
            },
            getFilterValue: data.getFilterValue,
            updateTriggers: _objectSpread(_objectSpread({}, updateTriggers), {}, {
              getText: (_textLabel$i$field2 = textLabel[i].field) === null || _textLabel$i$field2 === void 0 ? void 0 : _textLabel$i$field2.name,
              getPixelOffset: _objectSpread(_objectSpread({}, updateTriggers.getRadius), {}, {
                mapState: mapState,
                anchor: textLabel[i].anchor,
                alignment: textLabel[i].alignment
              }),
              getTextAnchor: textLabel[i].anchor,
              getAlignmentBaseline: textLabel[i].alignment,
              getColor: textLabel[i].color
            })
          })));
        }

        return accu;
      }, []);
    }
  }, {
    key: "calculateDataAttribute",
    value: function calculateDataAttribute(keplerTable, getPosition) {
      // implemented in subclasses
      return [];
    }
  }, {
    key: "updateLayerMeta",
    value: function updateLayerMeta(dataContainer, getPosition) {// implemented in subclasses
    }
  }, {
    key: "getPositionAccessor",
    value: function getPositionAccessor(dataContainer) {
      // implemented in subclasses
      return function () {
        return null;
      };
    }
  }], [{
    key: "findDefaultLayerProps",
    value: function findDefaultLayerProps(dataset, foundLayers) {
      return {
        props: [],
        foundLayers: foundLayers
      };
    }
    /**
     * Given a array of preset required column names
     * found field that has the same name to set as layer column
     *
     * @param {object} defaultFields
     * @param {object[]} allFields
     * @returns {object[] | null} all possible required layer column pairs
     */

  }, {
    key: "findDefaultColumnField",
    value: function findDefaultColumnField(defaultFields, allFields) {
      // find all matched fields for each required col
      var requiredColumns = Object.keys(defaultFields).reduce(function (prev, key) {
        var requiredFields = allFields.filter(function (f) {
          return f.name === defaultFields[key] || defaultFields[key].includes(f.name);
        });
        prev[key] = requiredFields.length ? requiredFields.map(function (f) {
          return {
            value: f.name,
            fieldIdx: f.fieldIdx
          };
        }) : null;
        return prev;
      }, {});

      if (!Object.values(requiredColumns).every(Boolean)) {
        // if any field missing, return null
        return null;
      }

      return this.getAllPossibleColumnParis(requiredColumns);
    }
  }, {
    key: "getAllPossibleColumnParis",
    value: function getAllPossibleColumnParis(requiredColumns) {
      // for multiple matched field for one required column, return multiple
      // combinations, e. g. if column a has 2 matched, column b has 3 matched
      // 6 possible column pairs will be returned
      var allKeys = Object.keys(requiredColumns);
      var pointers = allKeys.map(function (k, i) {
        return i === allKeys.length - 1 ? -1 : 0;
      });
      var countPerKey = allKeys.map(function (k) {
        return requiredColumns[k].length;
      }); // TODO: Better typings

      var pairs = [];
      /* eslint-disable no-loop-func */

      while (incrementPointers(pointers, countPerKey, pointers.length - 1)) {
        var newPair = pointers.reduce(function (prev, cuur, i) {
          prev[allKeys[i]] = requiredColumns[allKeys[i]][cuur];
          return prev;
        }, {});
        pairs.push(newPair);
      }
      /* eslint-enable no-loop-func */
      // recursively increment pointers


      function incrementPointers(pts, counts, index) {
        if (index === 0 && pts[0] === counts[0] - 1) {
          // nothing to increment
          return false;
        }

        if (pts[index] + 1 < counts[index]) {
          pts[index] = pts[index] + 1;
          return true;
        }

        pts[index] = 0;
        return incrementPointers(pts, counts, index - 1);
      }

      return pairs;
    }
  }, {
    key: "hexToRgb",
    value: function hexToRgb(c) {
      return (0, _utils.hexToRgb)(c);
    }
  }]);
  return Layer;
}();

var _default = Layer;
exports["default"] = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9iYXNlLWxheWVyLnRzIl0sIm5hbWVzIjpbImdlbmVyYXRlQ29sb3IiLCJMQVlFUl9JRF9MRU5HVEgiLCJNQVhfU0FNUExFX1NJWkUiLCJkZWZhdWx0RG9tYWluIiwiZGF0YUZpbHRlckV4dGVuc2lvbiIsIkRhdGFGaWx0ZXJFeHRlbnNpb24iLCJmaWx0ZXJTaXplIiwiTUFYX0dQVV9GSUxURVJTIiwiZGVmYXVsdERhdGFBY2Nlc3NvciIsImRjIiwiZCIsImRlZmF1bHRHZXRGaWVsZFZhbHVlIiwiZmllbGQiLCJ2YWx1ZUFjY2Vzc29yIiwiT1ZFUkxBWV9UWVBFX0NPTlNUIiwiZGVja2dsIiwibWFwYm94Z2wiLCJsYXllckNvbG9ycyIsIk9iamVjdCIsInZhbHVlcyIsIkRhdGFWaXpDb2xvcnMiLCJtYXAiLCJoZXhUb1JnYiIsImluZGV4IiwibGVuZ3RoIiwiY29sb3JNYWtlciIsIkxheWVyIiwicHJvcHMiLCJpZCIsIm1ldGEiLCJ2aXNDb25maWdTZXR0aW5ncyIsImNvbmZpZyIsImdldERlZmF1bHRMYXllckNvbmZpZyIsImNvbHVtbnMiLCJnZXRMYXllckNvbHVtbnMiLCJEZWZhdWx0TGF5ZXJJY29uIiwidHlwZSIsImNvbG9yIiwicHJvcGVydHkiLCJzY2FsZSIsImRvbWFpbiIsInJhbmdlIiwia2V5IiwiY2hhbm5lbFNjYWxlVHlwZSIsIkNIQU5ORUxfU0NBTEVTIiwibnVsbFZhbHVlIiwiTk9fVkFMVUVfQ09MT1IiLCJkZWZhdWx0VmFsdWUiLCJzaXplIiwibGF0IiwicGFpciIsImZpZWxkUGFpcktleSIsImxuZyIsImxhdDAiLCJsbmcwIiwibGF0MSIsImxuZzEiLCJkYXRhSWQiLCJsYWJlbCIsIkRFRkFVTFRfTEFZRVJfTEFCRUwiLCJuZXh0IiwidmFsdWUiLCJpc1Zpc2libGUiLCJpc0NvbmZpZ0FjdGl2ZSIsImhpZ2hsaWdodENvbG9yIiwiREVGQVVMVF9ISUdITElHSFRfQ09MT1IiLCJoaWRkZW4iLCJjb2xvckZpZWxkIiwiY29sb3JEb21haW4iLCJjb2xvclNjYWxlIiwiU0NBTEVfVFlQRVMiLCJxdWFudGlsZSIsInNpemVEb21haW4iLCJzaXplU2NhbGUiLCJsaW5lYXIiLCJzaXplRmllbGQiLCJ2aXNDb25maWciLCJ0ZXh0TGFiZWwiLCJERUZBVUxUX1RFWFRfTEFCRUwiLCJjb2xvclVJIiwiREVGQVVMVF9DT0xPUl9VSSIsImNvbG9yUmFuZ2UiLCJhbmltYXRpb24iLCJlbmFibGVkIiwiY2hhbm5lbCIsInZpc3VhbENoYW5uZWxzIiwibWVhc3VyZSIsInVuZGVmaW5lZCIsInJhbmdlU2V0dGluZ3MiLCJmaWVsZFNldHRpbmdzIiwiZGlzcGxheU5hbWUiLCJuYW1lIiwiZGVmYXVsdE1lYXN1cmUiLCJ1cGRhdGUiLCJmaWVsZElkeCIsImNvbHVtblBhaXJzIiwicGFydG5lcktleSIsInBhcnRuZXJGaWVsZFBhaXJLZXkiLCJ6b29tIiwiem9vbU9mZnNldCIsIk1hdGgiLCJwb3ciLCJtYXgiLCJlbmFibGVFbGV2YXRpb25ab29tRmFjdG9yIiwiZGF0YXNldHMiLCJvbGRMYXllckRhdGEiLCJvYmplY3QiLCJkYXRhQ29udGFpbmVyIiwiZmllbGRzIiwicm93IiwiY29uZmlnVG9Db3B5Iiwic2hhbGxvd0NvcHkiLCJjb25jYXQiLCJ2Iiwibm90VG9Db3B5IiwiZm9yRWFjaCIsImdyb3VwIiwicHVzaCIsImN1cnJlbnRDb25maWciLCJjb3BpZWQiLCJjb3B5TGF5ZXJDb25maWciLCJ1cGRhdGVMYXllckNvbmZpZyIsImtleXMiLCJ2YWxpZGF0ZVZpc3VhbENoYW5uZWwiLCJpbmNsdWRlcyIsImxheWVyVmlzQ29uZmlncyIsIml0ZW0iLCJjb25maWdJdGVtIiwiTEFZRVJfVklTX0NPTkZJR1MiLCJldmVyeSIsInAiLCJoYXNPd25Qcm9wZXJ0eSIsImNvbHVtblZhbGlkYXRvcnMiLCJyZXF1aXJlZCIsInJlcXVpcmVkTGF5ZXJDb2x1bW5zIiwicmVkdWNlIiwiYWNjdSIsInZhbGlkYXRvciIsIm9wdGlvbmFsIiwib3B0aW9uYWxDb2x1bW5zIiwibmV3Q29uZmlnIiwibmV3VmlzQ29uZmlnIiwicHJvcCIsInByZXZpb3VzIiwiY29sb3JVSVByb3AiLCJlbnRyaWVzIiwiaXNDb2xvclJhbmdlIiwiY29sb3JzIiwidXBkYXRlQ29sb3JVSUJ5Q29sb3JSYW5nZSIsInVwZGF0ZUNvbG9yUmFuZ2VCeUNvbG9yVUkiLCJ1cGRhdGVDdXN0b21QYWxldHRlIiwiY29sb3JSYW5nZUNvbmZpZyIsImN1c3RvbSIsImN1c3RvbVBhbGV0dGUiLCJzaG93RHJvcGRvd24iLCJzdGVwcyIsInJldmVyc2VkIiwiQm9vbGVhbiIsInNob3VsZFVwZGF0ZSIsInNvbWUiLCJzYW1lR3JvdXAiLCJDT0xPUl9SQU5HRVMiLCJmaWx0ZXIiLCJjciIsImZpbmQiLCJ1cGRhdGVMYXllclZpc0NvbmZpZyIsImxheWVyRGF0YSIsImRhdGEiLCJoYXNBbGxDb2x1bW5zIiwiaGFzTGF5ZXJEYXRhIiwicmVuZGVyTGF5ZXIiLCJBcnJheSIsImlzQXJyYXkiLCJjb2xvck1hcCIsImNNYXAiLCJNYXAiLCJrIiwic2V0IiwiU0NBTEVfRlVOQyIsIm9yZGluYWwiLCJ1bmtub3duIiwiZ2V0IiwiVU5LTk9XTl9DT0xPUl9LRVkiLCJnZXRWaXNDaGFubmVsU2NhbGUiLCJkYXRhQWNjZXNzb3IiLCJhdHRyaWJ1dGVBY2Nlc3NvcnMiLCJmaXhlZCIsImFjY2Vzc29yIiwiZ2V0QXR0cmlidXRlVmFsdWUiLCJzaG91bGRHZXRTY2FsZSIsImlzRml4ZWQiLCJzY2FsZUZ1bmN0aW9uIiwiZ2V0Q29sb3JTY2FsZSIsImdldEVuY29kZWRDaGFubmVsVmFsdWUiLCJDb25zb2xlIiwid2FybiIsImdldFBvc2l0aW9uIiwic2FtcGxlRGF0YSIsIm51bVJvd3MiLCJwb2ludHMiLCJtYXBJbmRleCIsImxhdEJvdW5kcyIsImxuZ0JvdW5kcyIsImRhdGFVcGRhdGVUcmlnZ2VycyIsInRyaWdnZXJDaGFuZ2VkIiwiX29sZERhdGFVcGRhdGVUcmlnZ2VycyIsImdldFZhbHVlIiwiYXR0cmlidXRlVmFsdWUiLCJBTExfRklFTERfVFlQRVMiLCJ0aW1lc3RhbXAiLCJEYXRlIiwiZmlsdGVyZWRJbmRleCIsImdldERhdGEiLCJkYXRhc2V0SWQiLCJnZXRNZXRhIiwidGwiLCJpIiwibGF5ZXJEYXRhc2V0IiwiZ2V0UG9zaXRpb25BY2Nlc3NvciIsImdldERhdGFVcGRhdGVUcmlnZ2VycyIsImdldENoYW5nZWRUcmlnZ2VycyIsInVwZGF0ZUxheWVyTWV0YSIsImNhbGN1bGF0ZURhdGFBdHRyaWJ1dGUiLCJuZXdGaWx0ZXIiLCJ0YWJsZSIsImdldERhdGFzZXQiLCJzY2FsZVR5cGUiLCJ1cGRhdGVkRG9tYWluIiwiY2FsY3VsYXRlTGF5ZXJEb21haW4iLCJ2YWxpZGF0ZUZpZWxkVHlwZSIsInZhbGlkYXRlU2NhbGUiLCJ2aXN1YWxDaGFubmVsIiwic3VwcG9ydGVkRmllbGRUeXBlcyIsImNoYW5uZWxTdXBwb3J0ZWRGaWVsZFR5cGVzIiwiQ0hBTk5FTF9TQ0FMRV9TVVBQT1JURURfRklFTERTIiwic2NhbGVPcHRpb25zIiwiZ2V0U2NhbGVPcHRpb25zIiwiRklFTERfT1BUUyIsImRhdGFzZXQiLCJ1cGRhdGVUcmlnZ2VycyIsImdldENvbHVtbkxheWVyRG9tYWluIiwib2JqZWN0SW5mbyIsImlzTGF5ZXJIb3ZlcmVkIiwicGlja2VkIiwibGF5ZXIiLCJtYXBTdGF0ZSIsImZpeGVkUmFkaXVzIiwicmFkaXVzQ2hhbm5lbCIsInZjIiwicmFkaXVzIiwiZ2V0Wm9vbUZhY3RvciIsIm5vbmVMYXllckRhdGFBZmZlY3RpbmdQcm9wcyIsImludGVyYWN0aW9uQ29uZmlnIiwiYnJ1c2hpbmdUYXJnZXQiLCJicnVzaCIsImF1dG9IaWdobGlnaHQiLCJicnVzaGluZ1JhZGl1cyIsImJydXNoaW5nRW5hYmxlZCIsImlkeCIsImdwdUZpbHRlciIsInZpc2libGUiLCJjb29yZGluYXRlU3lzdGVtIiwiQ09PUkRJTkFURV9TWVNURU0iLCJMTkdMQVQiLCJwaWNrYWJsZSIsIndyYXBMb25naXR1ZGUiLCJwYXJhbWV0ZXJzIiwiZGVwdGhUZXN0IiwiZHJhZ1JvdGF0ZSIsImVuYWJsZTNkIiwib3BhY2l0eSIsImV4dGVuc2lvbnMiLCJmaWx0ZXJSYW5nZSIsInJlbmRlck9wdHMiLCJnZXRQaXhlbE9mZnNldCIsInNoYXJlZFByb3BzIiwidGV4dExhYmVscyIsImdldFRleHQiLCJUZXh0TGF5ZXIiLCJjaGFyYWN0ZXJTZXQiLCJnZXRTaXplIiwiUFJPSkVDVEVEX1BJWEVMX1NJWkVfTVVMVElQTElFUiIsImdldFRleHRBbmNob3IiLCJhbmNob3IiLCJnZXRBbGlnbm1lbnRCYXNlbGluZSIsImFsaWdubWVudCIsImdldENvbG9yIiwiZ2V0RmlsdGVyVmFsdWUiLCJnZXRSYWRpdXMiLCJrZXBsZXJUYWJsZSIsImZvdW5kTGF5ZXJzIiwiZGVmYXVsdEZpZWxkcyIsImFsbEZpZWxkcyIsInJlcXVpcmVkQ29sdW1ucyIsInByZXYiLCJyZXF1aXJlZEZpZWxkcyIsImYiLCJnZXRBbGxQb3NzaWJsZUNvbHVtblBhcmlzIiwiYWxsS2V5cyIsInBvaW50ZXJzIiwiY291bnRQZXJLZXkiLCJwYWlycyIsImluY3JlbWVudFBvaW50ZXJzIiwibmV3UGFpciIsImN1dXIiLCJwdHMiLCJjb3VudHMiLCJjIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXFCQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFFQTs7QUFDQTs7QUFFQTs7QUFxQkE7Ozs7Ozt3REE4SlVBLGE7O0FBbEJWO0FBQ0E7QUFDQTtBQUNPLElBQU1DLGVBQWUsR0FBRyxDQUF4Qjs7QUFFUCxJQUFNQyxlQUFlLEdBQUcsSUFBeEI7QUFDQSxJQUFNQyxhQUErQixHQUFHLENBQUMsQ0FBRCxFQUFJLENBQUosQ0FBeEM7QUFDQSxJQUFNQyxtQkFBbUIsR0FBRyxJQUFJQywrQkFBSixDQUF3QjtBQUFDQyxFQUFBQSxVQUFVLEVBQUVDO0FBQWIsQ0FBeEIsQ0FBNUI7O0FBRUEsSUFBTUMsbUJBQW1CLEdBQUcsU0FBdEJBLG1CQUFzQixDQUFBQyxFQUFFO0FBQUEsU0FB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QUFFQTs7O0FBQ0EsZUFBU0QsaUJBQVQsQ0FBMkJHLEdBQTNCLEVBQWdDQyxNQUFoQyxFQUF3QzNSLEtBQXhDLEVBQStDO0FBQzdDLFlBQUlBLEtBQUssS0FBSyxDQUFWLElBQWUwUixHQUFHLENBQUMsQ0FBRCxDQUFILEtBQVdDLE1BQU0sQ0FBQyxDQUFELENBQU4sR0FBWSxDQUExQyxFQUE2QztBQUMzQztBQUNBLGlCQUFPLEtBQVA7QUFDRDs7QUFFRCxZQUFJRCxHQUFHLENBQUMxUixLQUFELENBQUgsR0FBYSxDQUFiLEdBQWlCMlIsTUFBTSxDQUFDM1IsS0FBRCxDQUEzQixFQUFvQztBQUNsQzBSLFVBQUFBLEdBQUcsQ0FBQzFSLEtBQUQsQ0FBSCxHQUFhMFIsR0FBRyxDQUFDMVIsS0FBRCxDQUFILEdBQWEsQ0FBMUI7QUFDQSxpQkFBTyxJQUFQO0FBQ0Q7O0FBRUQwUixRQUFBQSxHQUFHLENBQUMxUixLQUFELENBQUgsR0FBYSxDQUFiO0FBQ0EsZUFBT3VSLGlCQUFpQixDQUFDRyxHQUFELEVBQU1DLE1BQU4sRUFBYzNSLEtBQUssR0FBRyxDQUF0QixDQUF4QjtBQUNEOztBQUVELGFBQU9zUixLQUFQO0FBQ0Q7OztXQUVELGtCQUFnQk0sQ0FBaEIsRUFBbUI7QUFDakIsYUFBTyxxQkFBU0EsQ0FBVCxDQUFQO0FBQ0Q7Ozs7O2VBODVCWXpSLEsiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMjIgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHtjb25zb2xlIGFzIENvbnNvbGV9IGZyb20gJ2dsb2JhbC93aW5kb3cnO1xuaW1wb3J0IGtleW1pcnJvciBmcm9tICdrZXltaXJyb3InO1xuaW1wb3J0IHtEYXRhRmlsdGVyRXh0ZW5zaW9ufSBmcm9tICdAZGVjay5nbC9leHRlbnNpb25zJztcbmltcG9ydCB7Q09PUkRJTkFURV9TWVNURU19IGZyb20gJ0BkZWNrLmdsL2NvcmUnO1xuaW1wb3J0IHtUZXh0TGF5ZXJ9IGZyb20gJ0BkZWNrLmdsL2xheWVycyc7XG5cbmltcG9ydCBEZWZhdWx0TGF5ZXJJY29uIGZyb20gJy4vZGVmYXVsdC1sYXllci1pY29uJztcbmltcG9ydCB7ZGlmZlVwZGF0ZVRyaWdnZXJzfSBmcm9tICcuL2xheWVyLXVwZGF0ZSc7XG5cbmltcG9ydCB7XG4gIEFMTF9GSUVMRF9UWVBFUyxcbiAgTk9fVkFMVUVfQ09MT1IsXG4gIFNDQUxFX1RZUEVTLFxuICBDSEFOTkVMX1NDQUxFUyxcbiAgRklFTERfT1BUUyxcbiAgU0NBTEVfRlVOQyxcbiAgQ0hBTk5FTF9TQ0FMRV9TVVBQT1JURURfRklFTERTLFxuICBNQVhfR1BVX0ZJTFRFUlMsXG4gIENvbG9yUmFuZ2UsXG4gIENPTE9SX1JBTkdFUyxcbiAgRGF0YVZpekNvbG9ycyxcbiAgTEFZRVJfVklTX0NPTkZJR1MsXG4gIERFRkFVTFRfVEVYVF9MQUJFTCxcbiAgREVGQVVMVF9DT0xPUl9VSSxcbiAgVU5LTk9XTl9DT0xPUl9LRVksXG4gIERFRkFVTFRfSElHSExJR0hUX0NPTE9SLFxuICBERUZBVUxUX0xBWUVSX0xBQkVMLFxuICBQUk9KRUNURURfUElYRUxfU0laRV9NVUxUSVBMSUVSXG59IGZyb20gJ0BrZXBsZXIuZ2wvY29uc3RhbnRzJztcblxuaW1wb3J0IHtcbiAgZ2VuZXJhdGVIYXNoSWQsXG4gIGdldENvbG9yR3JvdXBCeU5hbWUsXG4gIHJldmVyc2VDb2xvclJhbmdlLFxuICBoZXhUb1JnYixcbiAgZ2V0TGF0TG5nQm91bmRzLFxuICBpc1BsYWluT2JqZWN0LFxuICBub3ROdWxsb3JVbmRlZmluZWQsXG4gIERhdGFDb250YWluZXJJbnRlcmZhY2UsXG4gIGdldFNhbXBsZUNvbnRhaW5lckRhdGFcbn0gZnJvbSAnQGtlcGxlci5nbC91dGlscyc7XG5cbmltcG9ydCB7XG4gIFJHQkNvbG9yLFxuICBSR0JBQ29sb3IsXG4gIFZhbHVlT2YsXG4gIE5lc3RlZFBhcnRpYWwsXG4gIExheWVyVGV4dExhYmVsLFxuICBDb2xvclVJLFxuICBMYXllclZpc0NvbmZpZyxcbiAgTGF5ZXJWaXNDb25maWdTZXR0aW5ncyxcbiAgRmllbGQsXG4gIE1hcFN0YXRlLFxuICBGaWx0ZXJcbn0gZnJvbSAnQGtlcGxlci5nbC90eXBlcyc7XG5pbXBvcnQge0tlcGxlclRhYmxlLCBEYXRhc2V0cywgR3B1RmlsdGVyfSBmcm9tICdAa2VwbGVyLmdsL3RhYmxlJztcblxuZXhwb3J0IHR5cGUgTGF5ZXJDb2x1bW4gPSB7dmFsdWU6IHN0cmluZyB8IG51bGw7IGZpZWxkSWR4OiBudW1iZXI7IG9wdGlvbmFsPzogYm9vbGVhbn07XG5cbmV4cG9ydCB0eXBlIExheWVyQ29sdW1ucyA9IHtcbiAgW2tleTogc3RyaW5nXTogTGF5ZXJDb2x1bW47XG59O1xuZXhwb3J0IHR5cGUgVmlzdWFsQ2hhbm5lbERvbWFpbiA9IG51bWJlcltdIHwgc3RyaW5nW107XG5leHBvcnQgdHlwZSBWaXN1YWxDaGFubmVsRmllbGQgPSBGaWVsZCB8IG51bGw7XG5leHBvcnQgdHlwZSBWaXN1YWxDaGFubmVsU2NhbGUgPSBrZXlvZiB0eXBlb2YgU0NBTEVfVFlQRVM7XG5cbmV4cG9ydCB0eXBlIExheWVyQmFzZUNvbmZpZyA9IHtcbiAgZGF0YUlkOiBzdHJpbmcgfCBudWxsO1xuICBsYWJlbDogc3RyaW5nO1xuICBjb2xvcjogUkdCQ29sb3I7XG5cbiAgY29sdW1uczogTGF5ZXJDb2x1bW5zO1xuICBpc1Zpc2libGU6IGJvb2xlYW47XG4gIGlzQ29uZmlnQWN0aXZlOiBib29sZWFuO1xuICBoaWdobGlnaHRDb2xvcjogUkdCQ29sb3IgfCBSR0JBQ29sb3I7XG4gIGhpZGRlbjogYm9vbGVhbjtcblxuICB2aXNDb25maWc6IExheWVyVmlzQ29uZmlnO1xuICB0ZXh0TGFiZWw6IExheWVyVGV4dExhYmVsW107XG5cbiAgY29sb3JVSToge1xuICAgIGNvbG9yOiBDb2xvclVJO1xuICAgIGNvbG9yUmFuZ2U6IENvbG9yVUk7XG4gIH07XG4gIGFuaW1hdGlvbjoge1xuICAgIGVuYWJsZWQ6IGJvb2xlYW47XG4gICAgZG9tYWluPzogbnVsbDtcbiAgfTtcbn07XG5cbmV4cG9ydCB0eXBlIExheWVyQ29sb3JDb25maWcgPSB7XG4gIGNvbG9yRmllbGQ6IFZpc3VhbENoYW5uZWxGaWVsZDtcbiAgY29sb3JEb21haW46IFZpc3VhbENoYW5uZWxEb21haW47XG4gIGNvbG9yU2NhbGU6IFZpc3VhbENoYW5uZWxTY2FsZTtcbn07XG5leHBvcnQgdHlwZSBMYXllclNpemVDb25maWcgPSB7XG4gIC8vIGNvbG9yIGJ5IHNpemUsIGRvbWFpbiBpcyBzZXQgYnkgZmlsdGVycywgZmllbGQsIHNjYWxlIHR5cGVcbiAgc2l6ZURvbWFpbjogVmlzdWFsQ2hhbm5lbERvbWFpbjtcbiAgc2l6ZVNjYWxlOiBWaXN1YWxDaGFubmVsU2NhbGU7XG4gIHNpemVGaWVsZDogVmlzdWFsQ2hhbm5lbEZpZWxkO1xufTtcbmV4cG9ydCB0eXBlIExheWVySGVpZ2h0Q29uZmlnID0ge1xuICBoZWlnaHRGaWVsZDogVmlzdWFsQ2hhbm5lbEZpZWxkO1xuICBoZWlnaHREb21haW46IFZpc3VhbENoYW5uZWxEb21haW47XG4gIGhlaWdodFNjYWxlOiBWaXN1YWxDaGFubmVsU2NhbGU7XG59O1xuZXhwb3J0IHR5cGUgTGF5ZXJTdHJva2VDb2xvckNvbmZpZyA9IHtcbiAgc3Ryb2tlQ29sb3JGaWVsZDogVmlzdWFsQ2hhbm5lbEZpZWxkO1xuICBzdHJva2VDb2xvckRvbWFpbjogVmlzdWFsQ2hhbm5lbERvbWFpbjtcbiAgc3Ryb2tlQ29sb3JTY2FsZTogVmlzdWFsQ2hhbm5lbFNjYWxlO1xufTtcbmV4cG9ydCB0eXBlIExheWVyQ292ZXJhZ2VDb25maWcgPSB7XG4gIGNvdmVyYWdlRmllbGQ6IFZpc3VhbENoYW5uZWxGaWVsZDtcbiAgY292ZXJhZ2VEb21haW46IFZpc3VhbENoYW5uZWxEb21haW47XG4gIGNvdmVyYWdlU2NhbGU6IFZpc3VhbENoYW5uZWxTY2FsZTtcbn07XG5leHBvcnQgdHlwZSBMYXllclJhZGl1c0NvbmZpZyA9IHtcbiAgcmFkaXVzRmllbGQ6IFZpc3VhbENoYW5uZWxGaWVsZDtcbiAgcmFkaXVzRG9tYWluOiBWaXN1YWxDaGFubmVsRG9tYWluO1xuICByYWRpdXNTY2FsZTogVmlzdWFsQ2hhbm5lbFNjYWxlO1xufTtcbmV4cG9ydCB0eXBlIExheWVyV2VpZ2h0Q29uZmlnID0ge1xuICB3ZWlnaHRGaWVsZDogVmlzdWFsQ2hhbm5lbEZpZWxkO1xufTtcblxuZXhwb3J0IHR5cGUgVmlzdWFsQ2hhbm5lbHMgPSB7W2tleTogc3RyaW5nXTogVmlzdWFsQ2hhbm5lbH07XG5cbmV4cG9ydCB0eXBlIFZpc3VhbENoYW5uZWxBZ2dyZWdhdGlvbiA9ICdjb2xvckFnZ3JlZ2F0aW9uJyB8ICdzaXplQWdncmVnYXRpb24nO1xuXG5leHBvcnQgdHlwZSBWaXN1YWxDaGFubmVsID0ge1xuICBwcm9wZXJ0eTogc3RyaW5nO1xuICBmaWVsZDogc3RyaW5nO1xuICBzY2FsZTogc3RyaW5nO1xuICBkb21haW46IHN0cmluZztcbiAgcmFuZ2U6IHN0cmluZztcbiAga2V5OiBzdHJpbmc7XG4gIGNoYW5uZWxTY2FsZVR5cGU6IHN0cmluZztcbiAgbnVsbFZhbHVlPzogYW55O1xuICBkZWZhdWx0TWVhc3VyZT86IGFueTtcbiAgYWNjZXNzb3I/OiBzdHJpbmc7XG4gIGNvbmRpdGlvbj86IChjb25maWc6IGFueSkgPT4gYm9vbGVhbjtcbiAgZ2V0QXR0cmlidXRlVmFsdWU/OiAoY29uZmlnOiBhbnkpID0+IChkOiBhbnkpID0+IGFueTtcblxuICAvLyBUT0RPOiBkZWZpbmUgZGVmYXVsdFZhbHVlXG4gIGRlZmF1bHRWYWx1ZT86IGFueTtcbiAgLy8gVE9ETzogZGVmaW5lIGZpeGVkXG4gIGZpeGVkPzogYW55O1xuXG4gIHN1cHBvcnRlZEZpZWxkVHlwZXM/OiBBcnJheTxrZXlvZiB0eXBlb2YgQUxMX0ZJRUxEX1RZUEVTPjtcblxuICBhZ2dyZWdhdGlvbj86IFZpc3VhbENoYW5uZWxBZ2dyZWdhdGlvbjtcbn07XG5cbmV4cG9ydCB0eXBlIFZpc3VhbENoYW5uZWxEZXNjcmlwdGlvbiA9IHtcbiAgbGFiZWw6IHN0cmluZztcbiAgbWVhc3VyZTogc3RyaW5nIHwgdW5kZWZpbmVkO1xufTtcblxuZXhwb3J0IHR5cGUgQ29sdW1uUGFpcnMgPSB7W2tleTogc3RyaW5nXToge3BhaXI6IHN0cmluZzsgZmllbGRQYWlyS2V5OiBzdHJpbmd9fTtcblxudHlwZSBDb2x1bW5WYWxpZGF0b3IgPSAoY29sdW1uOiBMYXllckNvbHVtbiwgY29sdW1uczogTGF5ZXJDb2x1bW5zLCBhbGxGaWVsZHM6IEZpZWxkW10pID0+IGJvb2xlYW47XG5cbmV4cG9ydCB0eXBlIFVwZGF0ZVRyaWdnZXJzID0ge1xuICBba2V5OiBzdHJpbmddOiBVcGRhdGVUcmlnZ2VyO1xufTtcbmV4cG9ydCB0eXBlIFVwZGF0ZVRyaWdnZXIgPSB7XG4gIFtrZXk6IHN0cmluZ106IHt9O1xufTtcbmV4cG9ydCB0eXBlIExheWVyQm91bmRzID0gW251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl07XG5leHBvcnQgdHlwZSBGaW5kRGVmYXVsdExheWVyUHJvcHNSZXR1cm5WYWx1ZSA9IHtwcm9wczogYW55W107IGZvdW5kTGF5ZXJzPzogYW55W119O1xuLyoqXG4gKiBBcHByb3guIG51bWJlciBvZiBwb2ludHMgdG8gc2FtcGxlIGluIGEgbGFyZ2UgZGF0YSBzZXRcbiAqL1xuZXhwb3J0IGNvbnN0IExBWUVSX0lEX0xFTkdUSCA9IDY7XG5cbmNvbnN0IE1BWF9TQU1QTEVfU0laRSA9IDUwMDA7XG5jb25zdCBkZWZhdWx0RG9tYWluOiBbbnVtYmVyLCBudW1iZXJdID0gWzAsIDFdO1xuY29uc3QgZGF0YUZpbHRlckV4dGVuc2lvbiA9IG5ldyBEYXRhRmlsdGVyRXh0ZW5zaW9uKHtmaWx0ZXJTaXplOiBNQVhfR1BVX0ZJTFRFUlN9KTtcblxuY29uc3QgZGVmYXVsdERhdGFBY2Nlc3NvciA9IGRjID0+IGQgPT4gZDtcbmNvbnN0IGRlZmF1bHRHZXRGaWVsZFZhbHVlID0gKGZpZWxkLCBkKSA9PiBmaWVsZC52YWx1ZUFjY2Vzc29yKGQpO1xuXG5leHBvcnQgY29uc3QgT1ZFUkxBWV9UWVBFX0NPTlNUID0ga2V5bWlycm9yKHtcbiAgZGVja2dsOiBudWxsLFxuICBtYXBib3hnbDogbnVsbFxufSk7XG5cbmV4cG9ydCBjb25zdCBsYXllckNvbG9ycyA9IE9iamVjdC52YWx1ZXMoRGF0YVZpekNvbG9ycykubWFwKGhleFRvUmdiKTtcbmZ1bmN0aW9uKiBnZW5lcmF0ZUNvbG9yKCk6IEdlbmVyYXRvcjxSR0JDb2xvcj4ge1xuICBsZXQgaW5kZXggPSAwO1xuICB3aGlsZSAoaW5kZXggPCBsYXllckNvbG9ycy5sZW5ndGggKyAxKSB7XG4gICAgaWYgKGluZGV4ID09PSBsYXllckNvbG9ycy5sZW5ndGgpIHtcbiAgICAgIGluZGV4ID0gMDtcbiAgICB9XG4gICAgeWllbGQgbGF5ZXJDb2xvcnNbaW5kZXgrK107XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGNvbG9yTWFrZXIgPSBnZW5lcmF0ZUNvbG9yKCk7XG5cbmNsYXNzIExheWVyIHtcbiAgaWQ6IHN0cmluZztcbiAgLy8gVE9ETzogZGVmaW5lIG1ldGFcbiAgbWV0YToge307XG4gIHZpc0NvbmZpZ1NldHRpbmdzOiB7XG4gICAgW2tleTogc3RyaW5nXTogVmFsdWVPZjxMYXllclZpc0NvbmZpZ1NldHRpbmdzPjtcbiAgfTtcbiAgY29uZmlnOiBMYXllckJhc2VDb25maWc7XG4gIC8vIFRPRE86IGRlZmluZSBfb2xkRGF0YVVwZGF0ZVRyaWdnZXJzXG4gIF9vbGREYXRhVXBkYXRlVHJpZ2dlcnM6IGFueTtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcm9wczoge1xuICAgICAgaWQ/OiBzdHJpbmc7XG4gICAgfSAmIFBhcnRpYWw8TGF5ZXJCYXNlQ29uZmlnPiA9IHt9XG4gICkge1xuICAgIHRoaXMuaWQgPSBwcm9wcy5pZCB8fCBnZW5lcmF0ZUhhc2hJZChMQVlFUl9JRF9MRU5HVEgpO1xuXG4gICAgLy8gbWV0YVxuICAgIHRoaXMubWV0YSA9IHt9O1xuXG4gICAgLy8gdmlzQ29uZmlnU2V0dGluZ3NcbiAgICB0aGlzLnZpc0NvbmZpZ1NldHRpbmdzID0ge307XG5cbiAgICB0aGlzLmNvbmZpZyA9IHRoaXMuZ2V0RGVmYXVsdExheWVyQ29uZmlnKHtcbiAgICAgIGNvbHVtbnM6IHRoaXMuZ2V0TGF5ZXJDb2x1bW5zKCksXG4gICAgICAuLi5wcm9wc1xuICAgIH0pO1xuICB9XG5cbiAgZ2V0IGxheWVySWNvbigpOiBSZWFjdC5FbGVtZW50VHlwZSB7XG4gICAgcmV0dXJuIERlZmF1bHRMYXllckljb247XG4gIH1cblxuICBnZXQgb3ZlcmxheVR5cGUoKToga2V5b2YgdHlwZW9mIE9WRVJMQVlfVFlQRV9DT05TVCB7XG4gICAgcmV0dXJuIE9WRVJMQVlfVFlQRV9DT05TVC5kZWNrZ2w7XG4gIH1cblxuICBnZXQgdHlwZSgpOiBzdHJpbmcgfCBudWxsIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGdldCBuYW1lKCkge1xuICAgIHJldHVybiB0aGlzLnR5cGU7XG4gIH1cblxuICBnZXQgaXNBZ2dyZWdhdGVkKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGdldCByZXF1aXJlZExheWVyQ29sdW1ucygpOiBzdHJpbmdbXSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgZ2V0IG9wdGlvbmFsQ29sdW1ucygpOiBzdHJpbmdbXSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgZ2V0IG5vbmVMYXllckRhdGFBZmZlY3RpbmdQcm9wcygpIHtcbiAgICByZXR1cm4gWydsYWJlbCcsICdvcGFjaXR5JywgJ3RoaWNrbmVzcycsICdpc1Zpc2libGUnLCAnaGlkZGVuJ107XG4gIH1cblxuICBnZXQgdmlzdWFsQ2hhbm5lbHMoKTogVmlzdWFsQ2hhbm5lbHMge1xuICAgIHJldHVybiB7XG4gICAgICBjb2xvcjoge1xuICAgICAgICBwcm9wZXJ0eTogJ2NvbG9yJyxcbiAgICAgICAgZmllbGQ6ICdjb2xvckZpZWxkJyxcbiAgICAgICAgc2NhbGU6ICdjb2xvclNjYWxlJyxcbiAgICAgICAgZG9tYWluOiAnY29sb3JEb21haW4nLFxuICAgICAgICByYW5nZTogJ2NvbG9yUmFuZ2UnLFxuICAgICAgICBrZXk6ICdjb2xvcicsXG4gICAgICAgIGNoYW5uZWxTY2FsZVR5cGU6IENIQU5ORUxfU0NBTEVTLmNvbG9yLFxuICAgICAgICBudWxsVmFsdWU6IE5PX1ZBTFVFX0NPTE9SLFxuICAgICAgICBkZWZhdWx0VmFsdWU6IGNvbmZpZyA9PiBjb25maWcuY29sb3JcbiAgICAgIH0sXG4gICAgICBzaXplOiB7XG4gICAgICAgIHByb3BlcnR5OiAnc2l6ZScsXG4gICAgICAgIGZpZWxkOiAnc2l6ZUZpZWxkJyxcbiAgICAgICAgc2NhbGU6ICdzaXplU2NhbGUnLFxuICAgICAgICBkb21haW46ICdzaXplRG9tYWluJyxcbiAgICAgICAgcmFuZ2U6ICdzaXplUmFuZ2UnLFxuICAgICAgICBrZXk6ICdzaXplJyxcbiAgICAgICAgY2hhbm5lbFNjYWxlVHlwZTogQ0hBTk5FTF9TQ0FMRVMuc2l6ZSxcbiAgICAgICAgbnVsbFZhbHVlOiAwLFxuICAgICAgICBkZWZhdWx0VmFsdWU6IDFcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgZ2V0IGNvbHVtblZhbGlkYXRvcnMoKToge1trZXk6IHN0cmluZ106IENvbHVtblZhbGlkYXRvcn0ge1xuICAgIHJldHVybiB7fTtcbiAgfVxuICAvKlxuICAgKiBDb2x1bW4gcGFpcnMgbWFwcyBsYXllciBjb2x1bW4gdG8gYSBzcGVjaWZpYyBmaWVsZCBwYWlycyxcbiAgICogQnkgZGVmYXVsdCwgaXQgaXMgc2V0IHRvIG51bGxcbiAgICovXG4gIGdldCBjb2x1bW5QYWlycygpOiBDb2x1bW5QYWlycyB8IG51bGwge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLypcbiAgICogRGVmYXVsdCBwb2ludCBjb2x1bW4gcGFpcnMsIGNhbiBiZSB1c2VkIGZvciBwb2ludCBiYXNlZCBsYXllcnM6IHBvaW50LCBpY29uIGV0Yy5cbiAgICovXG4gIGdldCBkZWZhdWx0UG9pbnRDb2x1bW5QYWlycygpOiBDb2x1bW5QYWlycyB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxhdDoge3BhaXI6ICdsbmcnLCBmaWVsZFBhaXJLZXk6ICdsYXQnfSxcbiAgICAgIGxuZzoge3BhaXI6ICdsYXQnLCBmaWVsZFBhaXJLZXk6ICdsbmcnfVxuICAgIH07XG4gIH1cblxuICAvKlxuICAgKiBEZWZhdWx0IGxpbmsgY29sdW1uIHBhaXJzLCBjYW4gYmUgdXNlZCBmb3IgbGluayBiYXNlZCBsYXllcnM6IGFyYywgbGluZSBldGNcbiAgICovXG4gIGdldCBkZWZhdWx0TGlua0NvbHVtblBhaXJzKCk6IENvbHVtblBhaXJzIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGF0MDoge3BhaXI6ICdsbmcwJywgZmllbGRQYWlyS2V5OiAnbGF0J30sXG4gICAgICBsbmcwOiB7cGFpcjogJ2xhdDAnLCBmaWVsZFBhaXJLZXk6ICdsbmcnfSxcbiAgICAgIGxhdDE6IHtwYWlyOiAnbG5nMScsIGZpZWxkUGFpcktleTogJ2xhdCd9LFxuICAgICAgbG5nMToge3BhaXI6ICdsYXQxJywgZmllbGRQYWlyS2V5OiAnbG5nJ31cbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhIFJlYWN0IGNvbXBvbmVudCBmb3IgdG8gcmVuZGVyIGxheWVyIGluc3RydWN0aW9ucyBpbiBhIG1vZGFsXG4gICAqIEByZXR1cm5zIHtvYmplY3R9IC0gYW4gb2JqZWN0XG4gICAqIEBleGFtcGxlXG4gICAqICByZXR1cm4ge1xuICAgKiAgICBpZDogJ2ljb25JbmZvJyxcbiAgICogICAgdGVtcGxhdGU6IEljb25JbmZvTW9kYWwsXG4gICAqICAgIG1vZGFsUHJvcHM6IHtcbiAgICogICAgICB0aXRsZTogJ0hvdyB0byBkcmF3IGljb25zJ1xuICAgKiAgIH07XG4gICAqIH1cbiAgICovXG4gIGdldCBsYXllckluZm9Nb2RhbCgpOiBhbnkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZ2V0IHN1cHBvcnRlZERhdGFzZXRUeXBlcygpOiBzdHJpbmdbXSB8IG51bGwge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIC8qXG4gICAqIEdpdmVuIGEgZGF0YXNldCwgYXV0b21hdGljYWxseSBmaW5kIHByb3BzIHRvIGNyZWF0ZSBsYXllciBiYXNlZCBvbiBpdFxuICAgKiBhbmQgcmV0dXJuIHRoZSBwcm9wcyBhbmQgcHJldmlvdXMgZm91bmQgbGF5ZXJzLlxuICAgKiBCeSBkZWZhdWx0LCBubyBsYXllcnMgd2lsbCBiZSBmb3VuZFxuICAgKi9cbiAgc3RhdGljIGZpbmREZWZhdWx0TGF5ZXJQcm9wcyhcbiAgICBkYXRhc2V0OiBLZXBsZXJUYWJsZSxcbiAgICBmb3VuZExheWVycz86IGFueVtdXG4gICk6IEZpbmREZWZhdWx0TGF5ZXJQcm9wc1JldHVyblZhbHVlIHtcbiAgICByZXR1cm4ge3Byb3BzOiBbXSwgZm91bmRMYXllcnN9O1xuICB9XG5cbiAgLyoqXG4gICAqIEdpdmVuIGEgYXJyYXkgb2YgcHJlc2V0IHJlcXVpcmVkIGNvbHVtbiBuYW1lc1xuICAgKiBmb3VuZCBmaWVsZCB0aGF0IGhhcyB0aGUgc2FtZSBuYW1lIHRvIHNldCBhcyBsYXllciBjb2x1bW5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGRlZmF1bHRGaWVsZHNcbiAgICogQHBhcmFtIHtvYmplY3RbXX0gYWxsRmllbGRzXG4gICAqIEByZXR1cm5zIHtvYmplY3RbXSB8IG51bGx9IGFsbCBwb3NzaWJsZSByZXF1aXJlZCBsYXllciBjb2x1bW4gcGFpcnNcbiAgICovXG4gIHN0YXRpYyBmaW5kRGVmYXVsdENvbHVtbkZpZWxkKGRlZmF1bHRGaWVsZHMsIGFsbEZpZWxkcykge1xuICAgIC8vIGZpbmQgYWxsIG1hdGNoZWQgZmllbGRzIGZvciBlYWNoIHJlcXVpcmVkIGNvbFxuICAgIGNvbnN0IHJlcXVpcmVkQ29sdW1ucyA9IE9iamVjdC5rZXlzKGRlZmF1bHRGaWVsZHMpLnJlZHVjZSgocHJldiwga2V5KSA9PiB7XG4gICAgICBjb25zdCByZXF1aXJlZEZpZWxkcyA9IGFsbEZpZWxkcy5maWx0ZXIoXG4gICAgICAgIGYgPT4gZi5uYW1lID09PSBkZWZhdWx0RmllbGRzW2tleV0gfHwgZGVmYXVsdEZpZWxkc1trZXldLmluY2x1ZGVzKGYubmFtZSlcbiAgICAgICk7XG5cbiAgICAgIHByZXZba2V5XSA9IHJlcXVpcmVkRmllbGRzLmxlbmd0aFxuICAgICAgICA/IHJlcXVpcmVkRmllbGRzLm1hcChmID0+ICh7XG4gICAgICAgICAgICB2YWx1ZTogZi5uYW1lLFxuICAgICAgICAgICAgZmllbGRJZHg6IGYuZmllbGRJZHhcbiAgICAgICAgICB9KSlcbiAgICAgICAgOiBudWxsO1xuICAgICAgcmV0dXJuIHByZXY7XG4gICAgfSwge30pO1xuXG4gICAgaWYgKCFPYmplY3QudmFsdWVzKHJlcXVpcmVkQ29sdW1ucykuZXZlcnkoQm9vbGVhbikpIHtcbiAgICAgIC8vIGlmIGFueSBmaWVsZCBtaXNzaW5nLCByZXR1cm4gbnVsbFxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZ2V0QWxsUG9zc2libGVDb2x1bW5QYXJpcyhyZXF1aXJlZENvbHVtbnMpO1xuICB9XG5cbiAgc3RhdGljIGdldEFsbFBvc3NpYmxlQ29sdW1uUGFyaXMocmVxdWlyZWRDb2x1bW5zKSB7XG4gICAgLy8gZm9yIG11bHRpcGxlIG1hdGNoZWQgZmllbGQgZm9yIG9uZSByZXF1aXJlZCBjb2x1bW4sIHJldHVybiBtdWx0aXBsZVxuICAgIC8vIGNvbWJpbmF0aW9ucywgZS4gZy4gaWYgY29sdW1uIGEgaGFzIDIgbWF0Y2hlZCwgY29sdW1uIGIgaGFzIDMgbWF0Y2hlZFxuICAgIC8vIDYgcG9zc2libGUgY29sdW1uIHBhaXJzIHdpbGwgYmUgcmV0dXJuZWRcbiAgICBjb25zdCBhbGxLZXlzID0gT2JqZWN0LmtleXMocmVxdWlyZWRDb2x1bW5zKTtcbiAgICBjb25zdCBwb2ludGVycyA9IGFsbEtleXMubWFwKChrLCBpKSA9PiAoaSA9PT0gYWxsS2V5cy5sZW5ndGggLSAxID8gLTEgOiAwKSk7XG4gICAgY29uc3QgY291bnRQZXJLZXkgPSBhbGxLZXlzLm1hcChrID0+IHJlcXVpcmVkQ29sdW1uc1trXS5sZW5ndGgpO1xuICAgIC8vIFRPRE86IEJldHRlciB0eXBpbmdzXG4gICAgY29uc3QgcGFpcnM6IGFueVtdID0gW107XG5cbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1sb29wLWZ1bmMgKi9cbiAgICB3aGlsZSAoaW5jcmVtZW50UG9pbnRlcnMocG9pbnRlcnMsIGNvdW50UGVyS2V5LCBwb2ludGVycy5sZW5ndGggLSAxKSkge1xuICAgICAgY29uc3QgbmV3UGFpciA9IHBvaW50ZXJzLnJlZHVjZSgocHJldiwgY3V1ciwgaSkgPT4ge1xuICAgICAgICBwcmV2W2FsbEtleXNbaV1dID0gcmVxdWlyZWRDb2x1bW5zW2FsbEtleXNbaV1dW2N1dXJdO1xuICAgICAgICByZXR1cm4gcHJldjtcbiAgICAgIH0sIHt9KTtcblxuICAgICAgcGFpcnMucHVzaChuZXdQYWlyKTtcbiAgICB9XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby1sb29wLWZ1bmMgKi9cblxuICAgIC8vIHJlY3Vyc2l2ZWx5IGluY3JlbWVudCBwb2ludGVyc1xuICAgIGZ1bmN0aW9uIGluY3JlbWVudFBvaW50ZXJzKHB0cywgY291bnRzLCBpbmRleCkge1xuICAgICAgaWYgKGluZGV4ID09PSAwICYmIHB0c1swXSA9PT0gY291bnRzWzBdIC0gMSkge1xuICAgICAgICAvLyBub3RoaW5nIHRvIGluY3JlbWVudFxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmIChwdHNbaW5kZXhdICsgMSA8IGNvdW50c1tpbmRleF0pIHtcbiAgICAgICAgcHRzW2luZGV4XSA9IHB0c1tpbmRleF0gKyAxO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcHRzW2luZGV4XSA9IDA7XG4gICAgICByZXR1cm4gaW5jcmVtZW50UG9pbnRlcnMocHRzLCBjb3VudHMsIGluZGV4IC0gMSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhaXJzO1xuICB9XG5cbiAgc3RhdGljIGhleFRvUmdiKGMpIHtcbiAgICByZXR1cm4gaGV4VG9SZ2IoYyk7XG4gIH1cblxuICBnZXREZWZhdWx0TGF5ZXJDb25maWcoXG4gICAgcHJvcHM6IFBhcnRpYWw8TGF5ZXJCYXNlQ29uZmlnPiA9IHt9XG4gICk6IExheWVyQmFzZUNvbmZpZyAmIFBhcnRpYWw8TGF5ZXJDb2xvckNvbmZpZyAmIExheWVyU2l6ZUNvbmZpZz4ge1xuICAgIHJldHVybiB7XG4gICAgICBkYXRhSWQ6IHByb3BzLmRhdGFJZCB8fCBudWxsLFxuICAgICAgbGFiZWw6IHByb3BzLmxhYmVsIHx8IERFRkFVTFRfTEFZRVJfTEFCRUwsXG4gICAgICBjb2xvcjogcHJvcHMuY29sb3IgfHwgY29sb3JNYWtlci5uZXh0KCkudmFsdWUsXG4gICAgICBjb2x1bW5zOiBwcm9wcy5jb2x1bW5zIHx8IHt9LFxuICAgICAgaXNWaXNpYmxlOiBwcm9wcy5pc1Zpc2libGUgfHwgZmFsc2UsXG4gICAgICBpc0NvbmZpZ0FjdGl2ZTogcHJvcHMuaXNDb25maWdBY3RpdmUgfHwgZmFsc2UsXG4gICAgICBoaWdobGlnaHRDb2xvcjogcHJvcHMuaGlnaGxpZ2h0Q29sb3IgfHwgREVGQVVMVF9ISUdITElHSFRfQ09MT1IsXG4gICAgICBoaWRkZW46IHByb3BzLmhpZGRlbiB8fCBmYWxzZSxcblxuICAgICAgLy8gVE9ETzogcmVmYWN0b3IgdGhpcyBpbnRvIHNlcGFyYXRlIHZpc3VhbCBDaGFubmVsIGNvbmZpZ1xuICAgICAgLy8gY29sb3IgYnkgZmllbGQsIGRvbWFpbiBpcyBzZXQgYnkgZmlsdGVycywgZmllbGQsIHNjYWxlIHR5cGVcbiAgICAgIGNvbG9yRmllbGQ6IG51bGwsXG4gICAgICBjb2xvckRvbWFpbjogWzAsIDFdLFxuICAgICAgY29sb3JTY2FsZTogU0NBTEVfVFlQRVMucXVhbnRpbGUsXG5cbiAgICAgIC8vIGNvbG9yIGJ5IHNpemUsIGRvbWFpbiBpcyBzZXQgYnkgZmlsdGVycywgZmllbGQsIHNjYWxlIHR5cGVcbiAgICAgIHNpemVEb21haW46IFswLCAxXSxcbiAgICAgIHNpemVTY2FsZTogU0NBTEVfVFlQRVMubGluZWFyLFxuICAgICAgc2l6ZUZpZWxkOiBudWxsLFxuXG4gICAgICB2aXNDb25maWc6IHt9LFxuXG4gICAgICB0ZXh0TGFiZWw6IFtERUZBVUxUX1RFWFRfTEFCRUxdLFxuXG4gICAgICBjb2xvclVJOiB7XG4gICAgICAgIGNvbG9yOiBERUZBVUxUX0NPTE9SX1VJLFxuICAgICAgICBjb2xvclJhbmdlOiBERUZBVUxUX0NPTE9SX1VJXG4gICAgICB9LFxuICAgICAgYW5pbWF0aW9uOiB7ZW5hYmxlZDogZmFsc2V9XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGRlc2NyaXB0aW9uIG9mIGEgdmlzdWFsQ2hhbm5lbCBjb25maWdcbiAgICogQHBhcmFtIGtleVxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgZ2V0VmlzdWFsQ2hhbm5lbERlc2NyaXB0aW9uKGtleTogc3RyaW5nKTogVmlzdWFsQ2hhbm5lbERlc2NyaXB0aW9uIHtcbiAgICAvLyBlLmcuIGxhYmVsOiBDb2xvciwgbWVhc3VyZTogVmVoaWNsZSBUeXBlXG4gICAgY29uc3QgY2hhbm5lbCA9IHRoaXMudmlzdWFsQ2hhbm5lbHNba2V5XTtcbiAgICBpZiAoIWNoYW5uZWwpIHJldHVybiB7bGFiZWw6ICcnLCBtZWFzdXJlOiB1bmRlZmluZWR9O1xuICAgIGNvbnN0IHJhbmdlU2V0dGluZ3MgPSB0aGlzLnZpc0NvbmZpZ1NldHRpbmdzW2NoYW5uZWwucmFuZ2VdO1xuICAgIGNvbnN0IGZpZWxkU2V0dGluZ3MgPSB0aGlzLmNvbmZpZ1tjaGFubmVsLmZpZWxkXTtcbiAgICBjb25zdCBsYWJlbCA9IHJhbmdlU2V0dGluZ3M/LmxhYmVsO1xuICAgIHJldHVybiB7XG4gICAgICBsYWJlbDogdHlwZW9mIGxhYmVsID09PSAnZnVuY3Rpb24nID8gbGFiZWwodGhpcy5jb25maWcpIDogbGFiZWwgfHwgJycsXG4gICAgICBtZWFzdXJlOiBmaWVsZFNldHRpbmdzXG4gICAgICAgID8gZmllbGRTZXR0aW5ncy5kaXNwbGF5TmFtZSB8fCBmaWVsZFNldHRpbmdzLm5hbWVcbiAgICAgICAgOiBjaGFubmVsLmRlZmF1bHRNZWFzdXJlXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBc3NpZ24gYSBmaWVsZCB0byBsYXllciBjb2x1bW4sIHJldHVybiBjb2x1bW4gY29uZmlnXG4gICAqIEBwYXJhbSBrZXkgLSBDb2x1bW4gS2V5XG4gICAqIEBwYXJhbSBmaWVsZCAtIFNlbGVjdGVkIGZpZWxkXG4gICAqIEByZXR1cm5zIHt7fX0gLSBDb2x1bW4gY29uZmlnXG4gICAqL1xuICBhc3NpZ25Db2x1bW4oa2V5OiBzdHJpbmcsIGZpZWxkOiBGaWVsZCk6IExheWVyQ29sdW1ucyB7XG4gICAgLy8gZmllbGQgdmFsdWUgY291bGQgYmUgbnVsbCBmb3Igb3B0aW9uYWwgY29sdW1uc1xuICAgIGNvbnN0IHVwZGF0ZSA9IGZpZWxkXG4gICAgICA/IHtcbiAgICAgICAgICB2YWx1ZTogZmllbGQubmFtZSxcbiAgICAgICAgICBmaWVsZElkeDogZmllbGQuZmllbGRJZHhcbiAgICAgICAgfVxuICAgICAgOiB7dmFsdWU6IG51bGwsIGZpZWxkSWR4OiAtMX07XG5cbiAgICByZXR1cm4ge1xuICAgICAgLi4udGhpcy5jb25maWcuY29sdW1ucyxcbiAgICAgIFtrZXldOiB7XG4gICAgICAgIC4uLnRoaXMuY29uZmlnLmNvbHVtbnNba2V5XSxcbiAgICAgICAgLi4udXBkYXRlXG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBc3NpZ24gYSBmaWVsZCBwYWlyIHRvIGNvbHVtbiBjb25maWcsIHJldHVybiBjb2x1bW4gY29uZmlnXG4gICAqIEBwYXJhbSBrZXkgLSBDb2x1bW4gS2V5XG4gICAqIEBwYXJhbSBwYWlyIC0gZmllbGQgUGFpclxuICAgKiBAcmV0dXJucyB7b2JqZWN0fSAtIENvbHVtbiBjb25maWdcbiAgICovXG4gIGFzc2lnbkNvbHVtblBhaXJzKGtleSwgcGFpcikge1xuICAgIGlmICghdGhpcy5jb2x1bW5QYWlycyB8fCAhdGhpcy5jb2x1bW5QYWlycz8uW2tleV0pIHtcbiAgICAgIC8vIHNob3VsZCBub3QgZW5kIGluIHRoaXMgc3RhdGVcbiAgICAgIHJldHVybiB0aGlzLmNvbmZpZy5jb2x1bW5zO1xuICAgIH1cblxuICAgIGNvbnN0IHtwYWlyOiBwYXJ0bmVyS2V5LCBmaWVsZFBhaXJLZXl9ID0gdGhpcy5jb2x1bW5QYWlycz8uW2tleV07XG4gICAgY29uc3Qge2ZpZWxkUGFpcktleTogcGFydG5lckZpZWxkUGFpcktleX0gPSB0aGlzLmNvbHVtblBhaXJzPy5bcGFydG5lcktleV07XG5cbiAgICByZXR1cm4ge1xuICAgICAgLi4udGhpcy5jb25maWcuY29sdW1ucyxcbiAgICAgIFtrZXldOiBwYWlyW2ZpZWxkUGFpcktleV0sXG4gICAgICBbcGFydG5lcktleV06IHBhaXJbcGFydG5lckZpZWxkUGFpcktleV1cbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSBhIHJhZGl1cyB6b29tIG11bHRpcGxpZXIgdG8gcmVuZGVyIHBvaW50cywgc28gdGhleSBhcmUgdmlzaWJsZSBpbiBhbGwgem9vbSBsZXZlbFxuICAgKiBAcGFyYW0ge29iamVjdH0gbWFwU3RhdGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IG1hcFN0YXRlLnpvb20gLSBhY3R1YWwgem9vbVxuICAgKiBAcGFyYW0ge251bWJlciB8IHZvaWR9IG1hcFN0YXRlLnpvb21PZmZzZXQgLSB6b29tT2Zmc2V0IHdoZW4gcmVuZGVyIGluIHRoZSBwbG90IGNvbnRhaW5lciBmb3IgZXhwb3J0IGltYWdlXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAqL1xuICBnZXRab29tRmFjdG9yKHt6b29tLCB6b29tT2Zmc2V0ID0gMH0pIHtcbiAgICByZXR1cm4gTWF0aC5wb3coMiwgTWF0aC5tYXgoMTQgLSB6b29tICsgem9vbU9mZnNldCwgMCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSBhIGVsZXZhdGlvbiB6b29tIG11bHRpcGxpZXIgdG8gcmVuZGVyIHBvaW50cywgc28gdGhleSBhcmUgdmlzaWJsZSBpbiBhbGwgem9vbSBsZXZlbFxuICAgKiBAcGFyYW0ge29iamVjdH0gbWFwU3RhdGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IG1hcFN0YXRlLnpvb20gLSBhY3R1YWwgem9vbVxuICAgKiBAcGFyYW0ge251bWJlciB8IHZvaWR9IG1hcFN0YXRlLnpvb21PZmZzZXQgLSB6b29tT2Zmc2V0IHdoZW4gcmVuZGVyIGluIHRoZSBwbG90IGNvbnRhaW5lciBmb3IgZXhwb3J0IGltYWdlXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAqL1xuICBnZXRFbGV2YXRpb25ab29tRmFjdG9yKHt6b29tLCB6b29tT2Zmc2V0ID0gMH06IHt6b29tOiBudW1iZXI7IHpvb21PZmZzZXQ/OiBudW1iZXJ9KSB7XG4gICAgcmV0dXJuIHRoaXMuY29uZmlnLnZpc0NvbmZpZy5lbmFibGVFbGV2YXRpb25ab29tRmFjdG9yXG4gICAgICA/IE1hdGgucG93KDIsIE1hdGgubWF4KDggLSB6b29tICsgem9vbU9mZnNldCwgMCkpXG4gICAgICA6IDE7XG4gIH1cblxuICBmb3JtYXRMYXllckRhdGEoZGF0YXNldHM6IERhdGFzZXRzLCBvbGRMYXllckRhdGE/OiBhbnkpIHtcbiAgICByZXR1cm4ge307XG4gIH1cblxuICByZW5kZXJMYXllciguLi5hcmdzOiBhbnlbXSk6IGFueVtdIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICBnZXRIb3ZlckRhdGEob2JqZWN0LCBkYXRhQ29udGFpbmVyOiBEYXRhQ29udGFpbmVySW50ZXJmYWNlLCBmaWVsZHM6IEZpZWxkW10pIHtcbiAgICBpZiAoIW9iamVjdCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gQnkgZGVmYXVsdCwgZWFjaCBlbnRyeSBvZiBsYXllckRhdGEgc2hvdWxkIGhhdmUgYW4gaW5kZXggb2YgYSByb3cgaW4gdGhlIG9yaWdpbmFsIGRhdGEgY29udGFpbmVyLlxuICAgIC8vIEVhY2ggbGF5ZXIgY2FuIGltcGxlbWVudCBpdHMgb3duIGdldEhvdmVyRGF0YSBtZXRob2RcbiAgICByZXR1cm4gZGF0YUNvbnRhaW5lci5yb3cob2JqZWN0LmluZGV4KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXaGVuIGNoYW5nZSBsYXllciB0eXBlLCB0cnkgdG8gY29weSBvdmVyIGxheWVyIGNvbmZpZ3MgYXMgbXVjaCBhcyBwb3NzaWJsZVxuICAgKiBAcGFyYW0gY29uZmlnVG9Db3B5IC0gY29uZmlnIHRvIGNvcHkgb3ZlclxuICAgKiBAcGFyYW0gdmlzQ29uZmlnU2V0dGluZ3MgLSB2aXNDb25maWcgc2V0dGluZ3Mgb2YgY29uZmlnIHRvIGNvcHlcbiAgICovXG4gIGFzc2lnbkNvbmZpZ1RvTGF5ZXIoY29uZmlnVG9Db3B5LCB2aXNDb25maWdTZXR0aW5ncykge1xuICAgIC8vIGRvbid0IGRlZXAgbWVyZ2UgdmlzdWFsQ2hhbm5lbCBmaWVsZFxuICAgIC8vIGRvbid0IGRlZXAgbWVyZ2UgY29sb3IgcmFuZ2UsIHJldmVyc2VkOiBpcyBub3QgYSBrZXkgYnkgZGVmYXVsdFxuICAgIGNvbnN0IHNoYWxsb3dDb3B5ID0gWydjb2xvclJhbmdlJywgJ3N0cm9rZUNvbG9yUmFuZ2UnXS5jb25jYXQoXG4gICAgICBPYmplY3QudmFsdWVzKHRoaXMudmlzdWFsQ2hhbm5lbHMpLm1hcCh2ID0+IHYuZmllbGQpXG4gICAgKTtcblxuICAgIC8vIGRvbid0IGNvcHkgb3ZlciBkb21haW4gYW5kIGFuaW1hdGlvblxuICAgIGNvbnN0IG5vdFRvQ29weSA9IFsnYW5pbWF0aW9uJ10uY29uY2F0KE9iamVjdC52YWx1ZXModGhpcy52aXN1YWxDaGFubmVscykubWFwKHYgPT4gdi5kb21haW4pKTtcbiAgICAvLyBpZiByYW5nZSBpcyBmb3IgdGhlIHNhbWUgcHJvcGVydHkgZ3JvdXAgY29weSBpdCwgb3RoZXJ3aXNlLCBub3QgdG8gY29weVxuICAgIE9iamVjdC52YWx1ZXModGhpcy52aXN1YWxDaGFubmVscykuZm9yRWFjaCh2ID0+IHtcbiAgICAgIGlmIChcbiAgICAgICAgY29uZmlnVG9Db3B5LnZpc0NvbmZpZ1t2LnJhbmdlXSAmJlxuICAgICAgICB0aGlzLnZpc0NvbmZpZ1NldHRpbmdzW3YucmFuZ2VdICYmXG4gICAgICAgIHZpc0NvbmZpZ1NldHRpbmdzW3YucmFuZ2VdLmdyb3VwICE9PSB0aGlzLnZpc0NvbmZpZ1NldHRpbmdzW3YucmFuZ2VdLmdyb3VwXG4gICAgICApIHtcbiAgICAgICAgbm90VG9Db3B5LnB1c2godi5yYW5nZSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBkb24ndCBjb3B5IG92ZXIgdmlzdWFsQ2hhbm5lbCByYW5nZVxuICAgIGNvbnN0IGN1cnJlbnRDb25maWcgPSB0aGlzLmNvbmZpZztcbiAgICBjb25zdCBjb3BpZWQgPSB0aGlzLmNvcHlMYXllckNvbmZpZyhjdXJyZW50Q29uZmlnLCBjb25maWdUb0NvcHksIHtcbiAgICAgIHNoYWxsb3dDb3B5LFxuICAgICAgbm90VG9Db3B5XG4gICAgfSk7XG5cbiAgICB0aGlzLnVwZGF0ZUxheWVyQ29uZmlnKGNvcGllZCk7XG4gICAgLy8gdmFsaWRhdGUgdmlzdWFsQ2hhbm5lbCBmaWVsZCB0eXBlIGFuZCBzY2FsZSB0eXBlc1xuICAgIE9iamVjdC5rZXlzKHRoaXMudmlzdWFsQ2hhbm5lbHMpLmZvckVhY2goY2hhbm5lbCA9PiB7XG4gICAgICB0aGlzLnZhbGlkYXRlVmlzdWFsQ2hhbm5lbChjaGFubmVsKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qXG4gICAqIFJlY3Vyc2l2ZWx5IGNvcHkgY29uZmlnIG92ZXIgdG8gYW4gZW1wdHkgbGF5ZXJcbiAgICogd2hlbiByZWNlaXZlZCBzYXZlZCBjb25maWcsIG9yIGNvcHkgY29uZmlnIG92ZXIgZnJvbSBhIGRpZmZlcmVudCBsYXllciB0eXBlXG4gICAqIG1ha2Ugc3VyZSB0byBvbmx5IGNvcHkgb3ZlciB2YWx1ZSB0byBleGlzdGluZyBrZXlzXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjdXJyZW50Q29uZmlnIC0gZXhpc3RpbmcgY29uZmlnIHRvIGJlIG92ZXJyaWRlXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb25maWdUb0NvcHkgLSBuZXcgQ29uZmlnIHRvIGNvcHkgb3ZlclxuICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBzaGFsbG93Q29weSAtIGFycmF5IG9mIHByb3BlcnRpZXMgdG8gbm90IHRvIGJlIGRlZXAgY29waWVkXG4gICAqIEBwYXJhbSB7c3RyaW5nW119IG5vdFRvQ29weSAtIGFycmF5IG9mIHByb3BlcnRpZXMgbm90IHRvIGNvcHlcbiAgICogQHJldHVybnMge29iamVjdH0gLSBjb3BpZWQgY29uZmlnXG4gICAqL1xuICBjb3B5TGF5ZXJDb25maWcoXG4gICAgY3VycmVudENvbmZpZyxcbiAgICBjb25maWdUb0NvcHksXG4gICAge3NoYWxsb3dDb3B5ID0gW10sIG5vdFRvQ29weSA9IFtdfToge3NoYWxsb3dDb3B5Pzogc3RyaW5nW107IG5vdFRvQ29weT86IHN0cmluZ1tdfSA9IHt9XG4gICkge1xuICAgIGNvbnN0IGNvcGllZCA9IHt9O1xuICAgIE9iamVjdC5rZXlzKGN1cnJlbnRDb25maWcpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIGlmIChcbiAgICAgICAgaXNQbGFpbk9iamVjdChjdXJyZW50Q29uZmlnW2tleV0pICYmXG4gICAgICAgIGlzUGxhaW5PYmplY3QoY29uZmlnVG9Db3B5W2tleV0pICYmXG4gICAgICAgICFzaGFsbG93Q29weS5pbmNsdWRlcyhrZXkpICYmXG4gICAgICAgICFub3RUb0NvcHkuaW5jbHVkZXMoa2V5KVxuICAgICAgKSB7XG4gICAgICAgIC8vIHJlY3Vyc2l2ZWx5IGFzc2lnbiBvYmplY3QgdmFsdWVcbiAgICAgICAgY29waWVkW2tleV0gPSB0aGlzLmNvcHlMYXllckNvbmZpZyhjdXJyZW50Q29uZmlnW2tleV0sIGNvbmZpZ1RvQ29weVtrZXldLCB7XG4gICAgICAgICAgc2hhbGxvd0NvcHksXG4gICAgICAgICAgbm90VG9Db3B5XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChub3ROdWxsb3JVbmRlZmluZWQoY29uZmlnVG9Db3B5W2tleV0pICYmICFub3RUb0NvcHkuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAvLyBjb3B5XG4gICAgICAgIGNvcGllZFtrZXldID0gY29uZmlnVG9Db3B5W2tleV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBrZWVwIGV4aXN0aW5nXG4gICAgICAgIGNvcGllZFtrZXldID0gY3VycmVudENvbmZpZ1trZXldO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGNvcGllZDtcbiAgfVxuXG4gIHJlZ2lzdGVyVmlzQ29uZmlnKGxheWVyVmlzQ29uZmlnczoge1xuICAgIFtrZXk6IHN0cmluZ106IGtleW9mIExheWVyVmlzQ29uZmlnU2V0dGluZ3MgfCBWYWx1ZU9mPExheWVyVmlzQ29uZmlnU2V0dGluZ3M+O1xuICB9KSB7XG4gICAgT2JqZWN0LmtleXMobGF5ZXJWaXNDb25maWdzKS5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgY29uc3QgY29uZmlnSXRlbSA9IGxheWVyVmlzQ29uZmlnc1tpdGVtXTtcbiAgICAgIGlmICh0eXBlb2YgY29uZmlnSXRlbSA9PT0gJ3N0cmluZycgJiYgTEFZRVJfVklTX0NPTkZJR1NbY29uZmlnSXRlbV0pIHtcbiAgICAgICAgLy8gaWYgYXNzaWduZWQgb25lIG9mIGRlZmF1bHQgTEFZRVJfQ09ORklHU1xuICAgICAgICB0aGlzLmNvbmZpZy52aXNDb25maWdbaXRlbV0gPSBMQVlFUl9WSVNfQ09ORklHU1tjb25maWdJdGVtXS5kZWZhdWx0VmFsdWU7XG4gICAgICAgIHRoaXMudmlzQ29uZmlnU2V0dGluZ3NbaXRlbV0gPSBMQVlFUl9WSVNfQ09ORklHU1tjb25maWdJdGVtXTtcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIHR5cGVvZiBjb25maWdJdGVtID09PSAnb2JqZWN0JyAmJlxuICAgICAgICBbJ3R5cGUnLCAnZGVmYXVsdFZhbHVlJ10uZXZlcnkocCA9PiBjb25maWdJdGVtLmhhc093blByb3BlcnR5KHApKVxuICAgICAgKSB7XG4gICAgICAgIC8vIGlmIHByb3ZpZGVkIGN1c3RvbWl6ZWQgdmlzQ29uZmlnLCBhbmQgaGFzIHR5cGUgJiYgZGVmYXVsdFZhbHVlXG4gICAgICAgIC8vIFRPRE86IGZ1cnRoZXIgY2hlY2sgaWYgY3VzdG9taXplZCB2aXNDb25maWcgaXMgdmFsaWRcbiAgICAgICAgdGhpcy5jb25maWcudmlzQ29uZmlnW2l0ZW1dID0gY29uZmlnSXRlbS5kZWZhdWx0VmFsdWU7XG4gICAgICAgIHRoaXMudmlzQ29uZmlnU2V0dGluZ3NbaXRlbV0gPSBjb25maWdJdGVtO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZ2V0TGF5ZXJDb2x1bW5zKCkge1xuICAgIGNvbnN0IGNvbHVtblZhbGlkYXRvcnMgPSB0aGlzLmNvbHVtblZhbGlkYXRvcnM7XG4gICAgY29uc3QgcmVxdWlyZWQgPSB0aGlzLnJlcXVpcmVkTGF5ZXJDb2x1bW5zLnJlZHVjZShcbiAgICAgIChhY2N1LCBrZXkpID0+ICh7XG4gICAgICAgIC4uLmFjY3UsXG4gICAgICAgIFtrZXldOiBjb2x1bW5WYWxpZGF0b3JzW2tleV1cbiAgICAgICAgICA/IHt2YWx1ZTogbnVsbCwgZmllbGRJZHg6IC0xLCB2YWxpZGF0b3I6IGNvbHVtblZhbGlkYXRvcnNba2V5XX1cbiAgICAgICAgICA6IHt2YWx1ZTogbnVsbCwgZmllbGRJZHg6IC0xfVxuICAgICAgfSksXG4gICAgICB7fVxuICAgICk7XG4gICAgY29uc3Qgb3B0aW9uYWwgPSB0aGlzLm9wdGlvbmFsQ29sdW1ucy5yZWR1Y2UoXG4gICAgICAoYWNjdSwga2V5KSA9PiAoe1xuICAgICAgICAuLi5hY2N1LFxuICAgICAgICBba2V5XToge3ZhbHVlOiBudWxsLCBmaWVsZElkeDogLTEsIG9wdGlvbmFsOiB0cnVlfVxuICAgICAgfSksXG4gICAgICB7fVxuICAgICk7XG5cbiAgICByZXR1cm4gey4uLnJlcXVpcmVkLCAuLi5vcHRpb25hbH07XG4gIH1cblxuICB1cGRhdGVMYXllckNvbmZpZzxMYXllckNvbmZpZyBleHRlbmRzIExheWVyQmFzZUNvbmZpZyA9IExheWVyQmFzZUNvbmZpZz4oXG4gICAgbmV3Q29uZmlnOiBQYXJ0aWFsPExheWVyQ29uZmlnPlxuICApOiBMYXllciB7XG4gICAgdGhpcy5jb25maWcgPSB7Li4udGhpcy5jb25maWcsIC4uLm5ld0NvbmZpZ307XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB1cGRhdGVMYXllclZpc0NvbmZpZyhuZXdWaXNDb25maWcpIHtcbiAgICB0aGlzLmNvbmZpZy52aXNDb25maWcgPSB7Li4udGhpcy5jb25maWcudmlzQ29uZmlnLCAuLi5uZXdWaXNDb25maWd9O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdXBkYXRlTGF5ZXJDb2xvclVJKHByb3A6IHN0cmluZywgbmV3Q29uZmlnOiBOZXN0ZWRQYXJ0aWFsPENvbG9yVUk+KTogTGF5ZXIge1xuICAgIGNvbnN0IHtjb2xvclVJOiBwcmV2aW91cywgdmlzQ29uZmlnfSA9IHRoaXMuY29uZmlnO1xuXG4gICAgaWYgKCFpc1BsYWluT2JqZWN0KG5ld0NvbmZpZykgfHwgdHlwZW9mIHByb3AgIT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBjb25zdCBjb2xvclVJUHJvcCA9IE9iamVjdC5lbnRyaWVzKG5ld0NvbmZpZykucmVkdWNlKChhY2N1LCBba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLmFjY3UsXG4gICAgICAgIFtrZXldOiBpc1BsYWluT2JqZWN0KGFjY3Vba2V5XSkgJiYgaXNQbGFpbk9iamVjdCh2YWx1ZSkgPyB7Li4uYWNjdVtrZXldLCAuLi52YWx1ZX0gOiB2YWx1ZVxuICAgICAgfTtcbiAgICB9LCBwcmV2aW91c1twcm9wXSB8fCBERUZBVUxUX0NPTE9SX1VJKTtcblxuICAgIGNvbnN0IGNvbG9yVUkgPSB7XG4gICAgICAuLi5wcmV2aW91cyxcbiAgICAgIFtwcm9wXTogY29sb3JVSVByb3BcbiAgICB9O1xuXG4gICAgdGhpcy51cGRhdGVMYXllckNvbmZpZyh7Y29sb3JVSX0pO1xuICAgIC8vIGlmIGNvbG9yVUlbcHJvcF0gaXMgY29sb3JSYW5nZVxuICAgIGNvbnN0IGlzQ29sb3JSYW5nZSA9IHZpc0NvbmZpZ1twcm9wXSAmJiB2aXNDb25maWdbcHJvcF0uY29sb3JzO1xuXG4gICAgaWYgKGlzQ29sb3JSYW5nZSkge1xuICAgICAgdGhpcy51cGRhdGVDb2xvclVJQnlDb2xvclJhbmdlKG5ld0NvbmZpZywgcHJvcCk7XG4gICAgICB0aGlzLnVwZGF0ZUNvbG9yUmFuZ2VCeUNvbG9yVUkobmV3Q29uZmlnLCBwcmV2aW91cywgcHJvcCk7XG4gICAgICB0aGlzLnVwZGF0ZUN1c3RvbVBhbGV0dGUobmV3Q29uZmlnLCBwcmV2aW91cywgcHJvcCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB1cGRhdGVDdXN0b21QYWxldHRlKG5ld0NvbmZpZywgcHJldmlvdXMsIHByb3ApIHtcbiAgICBpZiAoIW5ld0NvbmZpZy5jb2xvclJhbmdlQ29uZmlnIHx8ICFuZXdDb25maWcuY29sb3JSYW5nZUNvbmZpZy5jdXN0b20pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCB7Y29sb3JVSSwgdmlzQ29uZmlnfSA9IHRoaXMuY29uZmlnO1xuXG4gICAgaWYgKCF2aXNDb25maWdbcHJvcF0pIHJldHVybjtcbiAgICBjb25zdCB7Y29sb3JzfSA9IHZpc0NvbmZpZ1twcm9wXTtcbiAgICBjb25zdCBjdXN0b21QYWxldHRlID0ge1xuICAgICAgLi4uY29sb3JVSVtwcm9wXS5jdXN0b21QYWxldHRlLFxuICAgICAgbmFtZTogJ0N1c3RvbSBQYWxldHRlJyxcbiAgICAgIGNvbG9yczogWy4uLmNvbG9yc11cbiAgICB9O1xuICAgIHRoaXMudXBkYXRlTGF5ZXJDb25maWcoe1xuICAgICAgY29sb3JVSToge1xuICAgICAgICAuLi5jb2xvclVJLFxuICAgICAgICBbcHJvcF06IHtcbiAgICAgICAgICAuLi5jb2xvclVJW3Byb3BdLFxuICAgICAgICAgIGN1c3RvbVBhbGV0dGVcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBpZiBvcGVuIGRyb3Bkb3duIGFuZCBwcm9wIGlzIGNvbG9yIHJhbmdlXG4gICAqIEF1dG9tYXRpY2FsbHkgc2V0IGNvbG9yUmFuZ2VDb25maWcncyBzdGVwIGFuZCByZXZlcnNlZFxuICAgKiBAcGFyYW0geyp9IG5ld0NvbmZpZ1xuICAgKiBAcGFyYW0geyp9IHByb3BcbiAgICovXG4gIHVwZGF0ZUNvbG9yVUlCeUNvbG9yUmFuZ2UobmV3Q29uZmlnLCBwcm9wKSB7XG4gICAgaWYgKHR5cGVvZiBuZXdDb25maWcuc2hvd0Ryb3Bkb3duICE9PSAnbnVtYmVyJykgcmV0dXJuO1xuXG4gICAgY29uc3Qge2NvbG9yVUksIHZpc0NvbmZpZ30gPSB0aGlzLmNvbmZpZztcbiAgICB0aGlzLnVwZGF0ZUxheWVyQ29uZmlnKHtcbiAgICAgIGNvbG9yVUk6IHtcbiAgICAgICAgLi4uY29sb3JVSSxcbiAgICAgICAgW3Byb3BdOiB7XG4gICAgICAgICAgLi4uY29sb3JVSVtwcm9wXSxcbiAgICAgICAgICBjb2xvclJhbmdlQ29uZmlnOiB7XG4gICAgICAgICAgICAuLi5jb2xvclVJW3Byb3BdLmNvbG9yUmFuZ2VDb25maWcsXG4gICAgICAgICAgICBzdGVwczogdmlzQ29uZmlnW3Byb3BdLmNvbG9ycy5sZW5ndGgsXG4gICAgICAgICAgICByZXZlcnNlZDogQm9vbGVhbih2aXNDb25maWdbcHJvcF0ucmV2ZXJzZWQpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICB1cGRhdGVDb2xvclJhbmdlQnlDb2xvclVJKG5ld0NvbmZpZywgcHJldmlvdXMsIHByb3ApIHtcbiAgICAvLyBvbmx5IHVwZGF0ZSBjb2xvclJhbmdlIGlmIGNoYW5nZXMgaW4gVUkgaXMgbWFkZSB0byAncmV2ZXJzZWQnLCAnc3RlcHMnIG9yIHN0ZXBzXG4gICAgY29uc3Qgc2hvdWxkVXBkYXRlID1cbiAgICAgIG5ld0NvbmZpZy5jb2xvclJhbmdlQ29uZmlnICYmXG4gICAgICBbJ3JldmVyc2VkJywgJ3N0ZXBzJ10uc29tZShcbiAgICAgICAga2V5ID0+XG4gICAgICAgICAgbmV3Q29uZmlnLmNvbG9yUmFuZ2VDb25maWcuaGFzT3duUHJvcGVydHkoa2V5KSAmJlxuICAgICAgICAgIG5ld0NvbmZpZy5jb2xvclJhbmdlQ29uZmlnW2tleV0gIT09XG4gICAgICAgICAgICAocHJldmlvdXNbcHJvcF0gfHwgREVGQVVMVF9DT0xPUl9VSSkuY29sb3JSYW5nZUNvbmZpZ1trZXldXG4gICAgICApO1xuICAgIGlmICghc2hvdWxkVXBkYXRlKSByZXR1cm47XG5cbiAgICBjb25zdCB7Y29sb3JVSSwgdmlzQ29uZmlnfSA9IHRoaXMuY29uZmlnO1xuICAgIGNvbnN0IHtzdGVwcywgcmV2ZXJzZWR9ID0gY29sb3JVSVtwcm9wXS5jb2xvclJhbmdlQ29uZmlnO1xuICAgIGNvbnN0IGNvbG9yUmFuZ2UgPSB2aXNDb25maWdbcHJvcF07XG4gICAgLy8gZmluZCBiYXNlZCBvbiBzdGVwIG9yIHJldmVyc2VkXG4gICAgbGV0IHVwZGF0ZTtcbiAgICBpZiAobmV3Q29uZmlnLmNvbG9yUmFuZ2VDb25maWcuaGFzT3duUHJvcGVydHkoJ3N0ZXBzJykpIHtcbiAgICAgIGNvbnN0IGdyb3VwID0gZ2V0Q29sb3JHcm91cEJ5TmFtZShjb2xvclJhbmdlKTtcblxuICAgICAgaWYgKGdyb3VwKSB7XG4gICAgICAgIGNvbnN0IHNhbWVHcm91cCA9IENPTE9SX1JBTkdFUy5maWx0ZXIoY3IgPT4gZ2V0Q29sb3JHcm91cEJ5TmFtZShjcikgPT09IGdyb3VwKTtcblxuICAgICAgICB1cGRhdGUgPSBzYW1lR3JvdXAuZmluZChjciA9PiBjci5jb2xvcnMubGVuZ3RoID09PSBzdGVwcyk7XG5cbiAgICAgICAgaWYgKHVwZGF0ZSAmJiBjb2xvclJhbmdlLnJldmVyc2VkKSB7XG4gICAgICAgICAgdXBkYXRlID0gcmV2ZXJzZUNvbG9yUmFuZ2UodHJ1ZSwgdXBkYXRlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChuZXdDb25maWcuY29sb3JSYW5nZUNvbmZpZy5oYXNPd25Qcm9wZXJ0eSgncmV2ZXJzZWQnKSkge1xuICAgICAgdXBkYXRlID0gcmV2ZXJzZUNvbG9yUmFuZ2UocmV2ZXJzZWQsIHVwZGF0ZSB8fCBjb2xvclJhbmdlKTtcbiAgICB9XG5cbiAgICBpZiAodXBkYXRlKSB7XG4gICAgICB0aGlzLnVwZGF0ZUxheWVyVmlzQ29uZmlnKHtbcHJvcF06IHVwZGF0ZX0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayB3aGV0aGVyIGxheWVyIGhhcyBhbGwgY29sdW1uc1xuICAgKiBAcmV0dXJucyB5ZXMgb3Igbm9cbiAgICovXG4gIGhhc0FsbENvbHVtbnMoKTogYm9vbGVhbiB7XG4gICAgY29uc3Qge2NvbHVtbnN9ID0gdGhpcy5jb25maWc7XG4gICAgcmV0dXJuIChcbiAgICAgIGNvbHVtbnMgJiZcbiAgICAgIE9iamVjdC52YWx1ZXMoY29sdW1ucykuZXZlcnkodiA9PiB7XG4gICAgICAgIHJldHVybiBCb29sZWFuKHYub3B0aW9uYWwgfHwgKHYudmFsdWUgJiYgdi5maWVsZElkeCA+IC0xKSk7XG4gICAgICB9KVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgd2hldGhlciBsYXllciBoYXMgZGF0YVxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5IHwgT2JqZWN0fSBsYXllckRhdGFcbiAgICogQHJldHVybnMge2Jvb2xlYW59IHllcyBvciBub1xuICAgKi9cbiAgaGFzTGF5ZXJEYXRhKGxheWVyRGF0YSkge1xuICAgIGlmICghbGF5ZXJEYXRhKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBCb29sZWFuKGxheWVyRGF0YS5kYXRhICYmIGxheWVyRGF0YS5kYXRhLmxlbmd0aCk7XG4gIH1cblxuICBpc1ZhbGlkVG9TYXZlKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBCb29sZWFuKHRoaXMudHlwZSAmJiB0aGlzLmhhc0FsbENvbHVtbnMoKSk7XG4gIH1cblxuICBzaG91bGRSZW5kZXJMYXllcihkYXRhKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIChcbiAgICAgIEJvb2xlYW4odGhpcy50eXBlKSAmJlxuICAgICAgdGhpcy5oYXNBbGxDb2x1bW5zKCkgJiZcbiAgICAgIHRoaXMuaGFzTGF5ZXJEYXRhKGRhdGEpICYmXG4gICAgICB0eXBlb2YgdGhpcy5yZW5kZXJMYXllciA9PT0gJ2Z1bmN0aW9uJ1xuICAgICk7XG4gIH1cblxuICBnZXRDb2xvclNjYWxlKGNvbG9yU2NhbGU6IHN0cmluZywgY29sb3JEb21haW46IFZpc3VhbENoYW5uZWxEb21haW4sIGNvbG9yUmFuZ2U6IENvbG9yUmFuZ2UpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjb2xvclJhbmdlLmNvbG9yTWFwKSkge1xuICAgICAgY29uc3QgY01hcCA9IG5ldyBNYXAoKTtcbiAgICAgIGNvbG9yUmFuZ2UuY29sb3JNYXAuZm9yRWFjaCgoW2ssIHZdKSA9PiB7XG4gICAgICAgIGNNYXAuc2V0KGssIHR5cGVvZiB2ID09PSAnc3RyaW5nJyA/IGhleFRvUmdiKHYpIDogdik7XG4gICAgICB9KTtcblxuICAgICAgY29uc3Qgc2NhbGUgPSBTQ0FMRV9GVU5DW1NDQUxFX1RZUEVTLm9yZGluYWxdKClcbiAgICAgICAgLmRvbWFpbihjTWFwLmtleXMoKSlcbiAgICAgICAgLnJhbmdlKGNNYXAudmFsdWVzKCkpXG4gICAgICAgIC51bmtub3duKGNNYXAuZ2V0KFVOS05PV05fQ09MT1JfS0VZKSB8fCBOT19WQUxVRV9DT0xPUik7XG4gICAgICByZXR1cm4gc2NhbGU7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdldFZpc0NoYW5uZWxTY2FsZShjb2xvclNjYWxlLCBjb2xvckRvbWFpbiwgY29sb3JSYW5nZS5jb2xvcnMubWFwKGhleFRvUmdiKSk7XG4gIH1cblxuICAvKipcbiAgICogTWFwcGluZyBmcm9tIHZpc3VhbCBjaGFubmVscyB0byBkZWNrLmdsIGFjY2Vzb3JzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbSBQYXJhbWV0ZXJzXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHBhcmFtLmRhdGFBY2Nlc3NvciBBY2Nlc3Mga2VwbGVyLmdsIGxheWVyIGRhdGEgZnJvbSBkZWNrLmdsIGxheWVyXG4gICAqIEBwYXJhbSB7aW1wb3J0KCd1dGlscy90YWJsZS11dGlscy9kYXRhLWNvbnRhaW5lci1pbnRlcmZhY2UnKS5EYXRhQ29udGFpbmVySW50ZXJmYWNlfSBwYXJhbS5kYXRhQ29udGFpbmVyIERhdGFDb250YWluZXIgdG8gdXNlIHVzZSB3aXRoIGRhdGFBY2Nlc3NvclxuICAgKiBAcmV0dXJuIHtPYmplY3R9IGF0dHJpYnV0ZUFjY2Vzc29ycyAtIGRlY2suZ2wgbGF5ZXIgYXR0cmlidXRlIGFjY2Vzc29yc1xuICAgKi9cbiAgZ2V0QXR0cmlidXRlQWNjZXNzb3JzKHtcbiAgICBkYXRhQWNjZXNzb3IgPSBkZWZhdWx0RGF0YUFjY2Vzc29yLFxuICAgIGRhdGFDb250YWluZXJcbiAgfToge1xuICAgIGRhdGFBY2Nlc3Nvcj86IHR5cGVvZiBkZWZhdWx0RGF0YUFjY2Vzc29yO1xuICAgIGRhdGFDb250YWluZXI6IERhdGFDb250YWluZXJJbnRlcmZhY2U7XG4gIH0pIHtcbiAgICBjb25zdCBhdHRyaWJ1dGVBY2Nlc3NvcnM6IHtba2V5OiBzdHJpbmddOiBhbnl9ID0ge307XG5cbiAgICBPYmplY3Qua2V5cyh0aGlzLnZpc3VhbENoYW5uZWxzKS5mb3JFYWNoKGNoYW5uZWwgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBmaWVsZCxcbiAgICAgICAgZml4ZWQsXG4gICAgICAgIHNjYWxlLFxuICAgICAgICBkb21haW4sXG4gICAgICAgIHJhbmdlLFxuICAgICAgICBhY2Nlc3NvcixcbiAgICAgICAgZGVmYXVsdFZhbHVlLFxuICAgICAgICBnZXRBdHRyaWJ1dGVWYWx1ZSxcbiAgICAgICAgbnVsbFZhbHVlLFxuICAgICAgICBjaGFubmVsU2NhbGVUeXBlXG4gICAgICB9ID0gdGhpcy52aXN1YWxDaGFubmVsc1tjaGFubmVsXTtcblxuICAgICAgaWYgKGFjY2Vzc29yKSB7XG4gICAgICAgIGNvbnN0IHNob3VsZEdldFNjYWxlID0gdGhpcy5jb25maWdbZmllbGRdO1xuXG4gICAgICAgIGlmIChzaG91bGRHZXRTY2FsZSkge1xuICAgICAgICAgIGNvbnN0IGlzRml4ZWQgPSBmaXhlZCAmJiB0aGlzLmNvbmZpZy52aXNDb25maWdbZml4ZWRdO1xuXG4gICAgICAgICAgY29uc3Qgc2NhbGVGdW5jdGlvbiA9XG4gICAgICAgICAgICBjaGFubmVsU2NhbGVUeXBlID09PSBDSEFOTkVMX1NDQUxFUy5jb2xvclxuICAgICAgICAgICAgICA/IHRoaXMuZ2V0Q29sb3JTY2FsZShcbiAgICAgICAgICAgICAgICAgIHRoaXMuY29uZmlnW3NjYWxlXSxcbiAgICAgICAgICAgICAgICAgIHRoaXMuY29uZmlnW2RvbWFpbl0sXG4gICAgICAgICAgICAgICAgICB0aGlzLmNvbmZpZy52aXNDb25maWdbcmFuZ2VdXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICA6IHRoaXMuZ2V0VmlzQ2hhbm5lbFNjYWxlKFxuICAgICAgICAgICAgICAgICAgdGhpcy5jb25maWdbc2NhbGVdLFxuICAgICAgICAgICAgICAgICAgdGhpcy5jb25maWdbZG9tYWluXSxcbiAgICAgICAgICAgICAgICAgIHRoaXMuY29uZmlnLnZpc0NvbmZpZ1tyYW5nZV0sXG4gICAgICAgICAgICAgICAgICBpc0ZpeGVkXG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgIGF0dHJpYnV0ZUFjY2Vzc29yc1thY2Nlc3Nvcl0gPSBkID0+XG4gICAgICAgICAgICB0aGlzLmdldEVuY29kZWRDaGFubmVsVmFsdWUoXG4gICAgICAgICAgICAgIHNjYWxlRnVuY3Rpb24sXG4gICAgICAgICAgICAgIGRhdGFBY2Nlc3NvcihkYXRhQ29udGFpbmVyKShkKSxcbiAgICAgICAgICAgICAgdGhpcy5jb25maWdbZmllbGRdLFxuICAgICAgICAgICAgICBudWxsVmFsdWVcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGdldEF0dHJpYnV0ZVZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgYXR0cmlidXRlQWNjZXNzb3JzW2FjY2Vzc29yXSA9IGdldEF0dHJpYnV0ZVZhbHVlKHRoaXMuY29uZmlnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhdHRyaWJ1dGVBY2Nlc3NvcnNbYWNjZXNzb3JdID1cbiAgICAgICAgICAgIHR5cGVvZiBkZWZhdWx0VmFsdWUgPT09ICdmdW5jdGlvbicgPyBkZWZhdWx0VmFsdWUodGhpcy5jb25maWcpIDogZGVmYXVsdFZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFhdHRyaWJ1dGVBY2Nlc3NvcnNbYWNjZXNzb3JdKSB7XG4gICAgICAgICAgQ29uc29sZS53YXJuKGBGYWlsZWQgdG8gcHJvdmlkZSBhY2Nlc3NvciBmdW5jdGlvbiBmb3IgJHthY2Nlc3NvciB8fCBjaGFubmVsfWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gYXR0cmlidXRlQWNjZXNzb3JzO1xuICB9XG5cbiAgZ2V0VmlzQ2hhbm5lbFNjYWxlKFxuICAgIHNjYWxlOiBzdHJpbmcsXG4gICAgZG9tYWluOiBWaXN1YWxDaGFubmVsRG9tYWluLFxuICAgIHJhbmdlOiBhbnksXG4gICAgZml4ZWQ/OiBib29sZWFuXG4gICk6ICgpID0+IGFueSB8IG51bGwge1xuICAgIHJldHVybiBTQ0FMRV9GVU5DW2ZpeGVkID8gJ2xpbmVhcicgOiBzY2FsZV0oKVxuICAgICAgLmRvbWFpbihkb21haW4pXG4gICAgICAucmFuZ2UoZml4ZWQgPyBkb21haW4gOiByYW5nZSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGxvbmdpdHVkZSBhbmQgbGF0aXR1ZGUgYm91bmRzIG9mIHRoZSBkYXRhLlxuICAgKiBAcGFyYW0ge2ltcG9ydCgndXRpbHMvdGFibGUtdXRpbHMvZGF0YS1jb250YWluZXItaW50ZXJmYWNlJykuRGF0YUNvbnRhaW5lckludGVyZmFjZX0gZGF0YUNvbnRhaW5lciBEYXRhQ29udGFpbmVyIHRvIGNhbGN1bGF0ZSBib3VuZHMgZm9yLlxuICAgKiBAcGFyYW0geyhkOiB7aW5kZXg6IG51bWJlcn0sIGRjOiBpbXBvcnQoJ3V0aWxzL3RhYmxlLXV0aWxzL2RhdGEtY29udGFpbmVyLWludGVyZmFjZScpLkRhdGFDb250YWluZXJJbnRlcmZhY2UpID0+IG51bWJlcltdfSBnZXRQb3NpdGlvbiBBY2Nlc3Mga2VwbGVyLmdsIGxheWVyIGRhdGEgZnJvbSBkZWNrLmdsIGxheWVyXG4gICAqIEByZXR1cm4ge251bWJlcltdfG51bGx9IGJvdW5kcyBvZiB0aGUgZGF0YS5cbiAgICovXG4gIGdldFBvaW50c0JvdW5kcyhkYXRhQ29udGFpbmVyLCBnZXRQb3NpdGlvbikge1xuICAgIC8vIG5vIG5lZWQgdG8gbG9vcCB0aHJvdWdoIHRoZSBlbnRpcmUgZGF0YXNldFxuICAgIC8vIGdldCBhIHNhbXBsZSBvZiBkYXRhIHRvIGNhbGN1bGF0ZSBib3VuZHNcbiAgICBjb25zdCBzYW1wbGVEYXRhID1cbiAgICAgIGRhdGFDb250YWluZXIubnVtUm93cygpID4gTUFYX1NBTVBMRV9TSVpFXG4gICAgICAgID8gZ2V0U2FtcGxlQ29udGFpbmVyRGF0YShkYXRhQ29udGFpbmVyLCBNQVhfU0FNUExFX1NJWkUpXG4gICAgICAgIDogZGF0YUNvbnRhaW5lcjtcblxuICAgIGNvbnN0IHBvaW50cyA9IHNhbXBsZURhdGEubWFwSW5kZXgoZ2V0UG9zaXRpb24pO1xuXG4gICAgY29uc3QgbGF0Qm91bmRzID0gZ2V0TGF0TG5nQm91bmRzKHBvaW50cywgMSwgWy05MCwgOTBdKTtcbiAgICBjb25zdCBsbmdCb3VuZHMgPSBnZXRMYXRMbmdCb3VuZHMocG9pbnRzLCAwLCBbLTE4MCwgMTgwXSk7XG5cbiAgICBpZiAoIWxhdEJvdW5kcyB8fCAhbG5nQm91bmRzKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gW2xuZ0JvdW5kc1swXSwgbGF0Qm91bmRzWzBdLCBsbmdCb3VuZHNbMV0sIGxhdEJvdW5kc1sxXV07XG4gIH1cblxuICBnZXRDaGFuZ2VkVHJpZ2dlcnMoZGF0YVVwZGF0ZVRyaWdnZXJzKSB7XG4gICAgY29uc3QgdHJpZ2dlckNoYW5nZWQgPSBkaWZmVXBkYXRlVHJpZ2dlcnMoZGF0YVVwZGF0ZVRyaWdnZXJzLCB0aGlzLl9vbGREYXRhVXBkYXRlVHJpZ2dlcnMpO1xuICAgIHRoaXMuX29sZERhdGFVcGRhdGVUcmlnZ2VycyA9IGRhdGFVcGRhdGVUcmlnZ2VycztcblxuICAgIHJldHVybiB0cmlnZ2VyQ2hhbmdlZDtcbiAgfVxuXG4gIGdldEVuY29kZWRDaGFubmVsVmFsdWUoXG4gICAgc2NhbGU6ICh2YWx1ZSkgPT4gYW55LFxuICAgIGRhdGE6IGFueVtdLFxuICAgIGZpZWxkOiBWaXN1YWxDaGFubmVsRmllbGQsXG4gICAgbnVsbFZhbHVlID0gTk9fVkFMVUVfQ09MT1IsXG4gICAgZ2V0VmFsdWUgPSBkZWZhdWx0R2V0RmllbGRWYWx1ZVxuICApIHtcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIFRPRE86IFZpc3VhbENoYW5uZWxGaWVsZCBiZXR0ZXIgdHlwaW5nXG4gICAgY29uc3Qge3R5cGV9ID0gZmllbGQ7XG4gICAgY29uc3QgdmFsdWUgPSBnZXRWYWx1ZShmaWVsZCwgZGF0YSk7XG5cbiAgICBpZiAoIW5vdE51bGxvclVuZGVmaW5lZCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBudWxsVmFsdWU7XG4gICAgfVxuXG4gICAgbGV0IGF0dHJpYnV0ZVZhbHVlO1xuICAgIGlmICh0eXBlID09PSBBTExfRklFTERfVFlQRVMudGltZXN0YW1wKSB7XG4gICAgICAvLyBzaG91bGRuJ3QgbmVlZCB0byBjb252ZXJ0IGhlcmVcbiAgICAgIC8vIHNjYWxlIEZ1bmN0aW9uIHNob3VsZCB0YWtlIGNhcmUgb2YgaXRcbiAgICAgIGF0dHJpYnV0ZVZhbHVlID0gc2NhbGUobmV3IERhdGUodmFsdWUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXR0cmlidXRlVmFsdWUgPSBzY2FsZSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgaWYgKCFub3ROdWxsb3JVbmRlZmluZWQoYXR0cmlidXRlVmFsdWUpKSB7XG4gICAgICBhdHRyaWJ1dGVWYWx1ZSA9IG51bGxWYWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXR0cmlidXRlVmFsdWU7XG4gIH1cblxuICB1cGRhdGVNZXRhKG1ldGEpIHtcbiAgICB0aGlzLm1ldGEgPSB7Li4udGhpcy5tZXRhLCAuLi5tZXRhfTtcbiAgfVxuXG4gIGdldERhdGFVcGRhdGVUcmlnZ2Vycyh7ZmlsdGVyZWRJbmRleCwgaWQsIGRhdGFDb250YWluZXJ9OiBLZXBsZXJUYWJsZSk6IGFueSB7XG4gICAgY29uc3Qge2NvbHVtbnN9ID0gdGhpcy5jb25maWc7XG5cbiAgICByZXR1cm4ge1xuICAgICAgZ2V0RGF0YToge2RhdGFzZXRJZDogaWQsIGRhdGFDb250YWluZXIsIGNvbHVtbnMsIGZpbHRlcmVkSW5kZXh9LFxuICAgICAgZ2V0TWV0YToge2RhdGFzZXRJZDogaWQsIGRhdGFDb250YWluZXIsIGNvbHVtbnN9LFxuICAgICAgLi4uKHRoaXMuY29uZmlnLnRleHRMYWJlbCB8fCBbXSkucmVkdWNlKFxuICAgICAgICAoYWNjdSwgdGwsIGkpID0+ICh7XG4gICAgICAgICAgLi4uYWNjdSxcbiAgICAgICAgICBbYGdldExhYmVsQ2hhcmFjdGVyU2V0LSR7aX1gXTogdGwuZmllbGQgPyB0bC5maWVsZC5uYW1lIDogbnVsbFxuICAgICAgICB9KSxcbiAgICAgICAge31cbiAgICAgIClcbiAgICB9O1xuICB9XG5cbiAgdXBkYXRlRGF0YShkYXRhc2V0cywgb2xkTGF5ZXJEYXRhKSB7XG4gICAgaWYgKCF0aGlzLmNvbmZpZy5kYXRhSWQpIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgY29uc3QgbGF5ZXJEYXRhc2V0ID0gZGF0YXNldHNbdGhpcy5jb25maWcuZGF0YUlkXTtcbiAgICBjb25zdCB7ZGF0YUNvbnRhaW5lcn0gPSBsYXllckRhdGFzZXQ7XG5cbiAgICBjb25zdCBnZXRQb3NpdGlvbiA9IHRoaXMuZ2V0UG9zaXRpb25BY2Nlc3NvcihkYXRhQ29udGFpbmVyKTtcbiAgICBjb25zdCBkYXRhVXBkYXRlVHJpZ2dlcnMgPSB0aGlzLmdldERhdGFVcGRhdGVUcmlnZ2VycyhsYXllckRhdGFzZXQpO1xuICAgIGNvbnN0IHRyaWdnZXJDaGFuZ2VkID0gdGhpcy5nZXRDaGFuZ2VkVHJpZ2dlcnMoZGF0YVVwZGF0ZVRyaWdnZXJzKTtcblxuICAgIGlmICh0cmlnZ2VyQ2hhbmdlZCAmJiB0cmlnZ2VyQ2hhbmdlZC5nZXRNZXRhKSB7XG4gICAgICB0aGlzLnVwZGF0ZUxheWVyTWV0YShkYXRhQ29udGFpbmVyLCBnZXRQb3NpdGlvbik7XG4gICAgfVxuXG4gICAgbGV0IGRhdGEgPSBbXTtcblxuICAgIGlmICghKHRyaWdnZXJDaGFuZ2VkICYmIHRyaWdnZXJDaGFuZ2VkLmdldERhdGEpICYmIG9sZExheWVyRGF0YSAmJiBvbGRMYXllckRhdGEuZGF0YSkge1xuICAgICAgLy8gc2FtZSBkYXRhXG4gICAgICBkYXRhID0gb2xkTGF5ZXJEYXRhLmRhdGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRhdGEgPSB0aGlzLmNhbGN1bGF0ZURhdGFBdHRyaWJ1dGUobGF5ZXJEYXRhc2V0LCBnZXRQb3NpdGlvbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtkYXRhLCB0cmlnZ2VyQ2hhbmdlZH07XG4gIH1cblxuICAvKipcbiAgICogaGVscGVyIGZ1bmN0aW9uIHRvIHVwZGF0ZSBvbmUgbGF5ZXIgZG9tYWluIHdoZW4gc3RhdGUuZGF0YSBjaGFuZ2VkXG4gICAqIGlmIHN0YXRlLmRhdGEgY2hhbmdlIGlzIGR1ZSBvdCB1cGRhdGUgZmlsdGVyLCBuZXdGaWxlciB3aWxsIGJlIHBhc3NlZFxuICAgKiBjYWxsZWQgYnkgdXBkYXRlQWxsTGF5ZXJEb21haW5EYXRhXG4gICAqIEBwYXJhbSBkYXRhc2V0c1xuICAgKiBAcGFyYW0gbmV3RmlsdGVyXG4gICAqIEByZXR1cm5zIGxheWVyXG4gICAqL1xuICB1cGRhdGVMYXllckRvbWFpbihkYXRhc2V0czogRGF0YXNldHMsIG5ld0ZpbHRlcj86IEZpbHRlcik6IExheWVyIHtcbiAgICBjb25zdCB0YWJsZSA9IHRoaXMuZ2V0RGF0YXNldChkYXRhc2V0cyk7XG4gICAgaWYgKCF0YWJsZSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIE9iamVjdC52YWx1ZXModGhpcy52aXN1YWxDaGFubmVscykuZm9yRWFjaChjaGFubmVsID0+IHtcbiAgICAgIGNvbnN0IHtzY2FsZX0gPSBjaGFubmVsO1xuICAgICAgY29uc3Qgc2NhbGVUeXBlID0gdGhpcy5jb25maWdbc2NhbGVdO1xuICAgICAgLy8gb3JkaW5hbCBkb21haW4gaXMgYmFzZWQgb24gZGF0YUNvbnRhaW5lciwgaWYgb25seSBmaWx0ZXIgY2hhbmdlZFxuICAgICAgLy8gbm8gbmVlZCB0byB1cGRhdGUgb3JkaW5hbCBkb21haW5cbiAgICAgIGlmICghbmV3RmlsdGVyIHx8IHNjYWxlVHlwZSAhPT0gU0NBTEVfVFlQRVMub3JkaW5hbCkge1xuICAgICAgICBjb25zdCB7ZG9tYWlufSA9IGNoYW5uZWw7XG4gICAgICAgIGNvbnN0IHVwZGF0ZWREb21haW4gPSB0aGlzLmNhbGN1bGF0ZUxheWVyRG9tYWluKHRhYmxlLCBjaGFubmVsKTtcbiAgICAgICAgdGhpcy51cGRhdGVMYXllckNvbmZpZyh7W2RvbWFpbl06IHVwZGF0ZWREb21haW59KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZ2V0RGF0YXNldChkYXRhc2V0cykge1xuICAgIHJldHVybiB0aGlzLmNvbmZpZy5kYXRhSWQgPyBkYXRhc2V0c1t0aGlzLmNvbmZpZy5kYXRhSWRdIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZSB2aXN1YWwgY2hhbm5lbCBmaWVsZCBhbmQgc2NhbGVzIGJhc2VkIG9uIHN1cHBvcnRlZCBmaWVsZCAmIHNjYWxlIHR5cGVcbiAgICogQHBhcmFtIGNoYW5uZWxcbiAgICovXG4gIHZhbGlkYXRlVmlzdWFsQ2hhbm5lbChjaGFubmVsOiBzdHJpbmcpIHtcbiAgICB0aGlzLnZhbGlkYXRlRmllbGRUeXBlKGNoYW5uZWwpO1xuICAgIHRoaXMudmFsaWRhdGVTY2FsZShjaGFubmVsKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZSBmaWVsZCB0eXBlIGJhc2VkIG9uIGNoYW5uZWxTY2FsZVR5cGVcbiAgICovXG4gIHZhbGlkYXRlRmllbGRUeXBlKGNoYW5uZWw6IHN0cmluZykge1xuICAgIGNvbnN0IHZpc3VhbENoYW5uZWwgPSB0aGlzLnZpc3VhbENoYW5uZWxzW2NoYW5uZWxdO1xuICAgIGNvbnN0IHtmaWVsZCwgY2hhbm5lbFNjYWxlVHlwZSwgc3VwcG9ydGVkRmllbGRUeXBlc30gPSB2aXN1YWxDaGFubmVsO1xuXG4gICAgaWYgKHRoaXMuY29uZmlnW2ZpZWxkXSkge1xuICAgICAgLy8gaWYgZmllbGQgaXMgc2VsZWN0ZWQsIGNoZWNrIGlmIGZpZWxkIHR5cGUgaXMgc3VwcG9ydGVkXG4gICAgICBjb25zdCBjaGFubmVsU3VwcG9ydGVkRmllbGRUeXBlcyA9XG4gICAgICAgIHN1cHBvcnRlZEZpZWxkVHlwZXMgfHwgQ0hBTk5FTF9TQ0FMRV9TVVBQT1JURURfRklFTERTW2NoYW5uZWxTY2FsZVR5cGVdO1xuXG4gICAgICBpZiAoIWNoYW5uZWxTdXBwb3J0ZWRGaWVsZFR5cGVzLmluY2x1ZGVzKHRoaXMuY29uZmlnW2ZpZWxkXS50eXBlKSkge1xuICAgICAgICAvLyBmaWVsZCB0eXBlIGlzIG5vdCBzdXBwb3J0ZWQsIHNldCBpdCBiYWNrIHRvIG51bGxcbiAgICAgICAgLy8gc2V0IHNjYWxlIGJhY2sgdG8gZGVmYXVsdFxuICAgICAgICB0aGlzLnVwZGF0ZUxheWVyQ29uZmlnKHtbZmllbGRdOiBudWxsfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFZhbGlkYXRlIHNjYWxlIHR5cGUgYmFzZWQgb24gYWdncmVnYXRpb25cbiAgICovXG4gIHZhbGlkYXRlU2NhbGUoY2hhbm5lbCkge1xuICAgIGNvbnN0IHZpc3VhbENoYW5uZWwgPSB0aGlzLnZpc3VhbENoYW5uZWxzW2NoYW5uZWxdO1xuICAgIGNvbnN0IHtzY2FsZX0gPSB2aXN1YWxDaGFubmVsO1xuICAgIGlmICghc2NhbGUpIHtcbiAgICAgIC8vIHZpc3VhbENoYW5uZWwgZG9lc24ndCBoYXZlIHNjYWxlXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHNjYWxlT3B0aW9ucyA9IHRoaXMuZ2V0U2NhbGVPcHRpb25zKGNoYW5uZWwpO1xuICAgIC8vIGNoZWNrIGlmIGN1cnJlbnQgc2VsZWN0ZWQgc2NhbGUgaXNcbiAgICAvLyBzdXBwb3J0ZWQsIGlmIG5vdCwgY2hhbmdlIHRvIGRlZmF1bHRcbiAgICBpZiAoIXNjYWxlT3B0aW9ucy5pbmNsdWRlcyh0aGlzLmNvbmZpZ1tzY2FsZV0pKSB7XG4gICAgICB0aGlzLnVwZGF0ZUxheWVyQ29uZmlnKHtbc2NhbGVdOiBzY2FsZU9wdGlvbnNbMF19KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IHNjYWxlIG9wdGlvbnMgYmFzZWQgb24gY3VycmVudCBmaWVsZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhbm5lbFxuICAgKiBAcmV0dXJucyB7c3RyaW5nW119XG4gICAqL1xuICBnZXRTY2FsZU9wdGlvbnMoY2hhbm5lbCkge1xuICAgIGNvbnN0IHZpc3VhbENoYW5uZWwgPSB0aGlzLnZpc3VhbENoYW5uZWxzW2NoYW5uZWxdO1xuICAgIGNvbnN0IHtmaWVsZCwgc2NhbGUsIGNoYW5uZWxTY2FsZVR5cGV9ID0gdmlzdWFsQ2hhbm5lbDtcblxuICAgIHJldHVybiB0aGlzLmNvbmZpZ1tmaWVsZF1cbiAgICAgID8gRklFTERfT1BUU1t0aGlzLmNvbmZpZ1tmaWVsZF0udHlwZV0uc2NhbGVbY2hhbm5lbFNjYWxlVHlwZV1cbiAgICAgIDogW3RoaXMuZ2V0RGVmYXVsdExheWVyQ29uZmlnKClbc2NhbGVdXTtcbiAgfVxuXG4gIHVwZGF0ZUxheWVyVmlzdWFsQ2hhbm5lbChkYXRhc2V0OiBLZXBsZXJUYWJsZSwgY2hhbm5lbDogc3RyaW5nKSB7XG4gICAgY29uc3QgdmlzdWFsQ2hhbm5lbCA9IHRoaXMudmlzdWFsQ2hhbm5lbHNbY2hhbm5lbF07XG4gICAgdGhpcy52YWxpZGF0ZVZpc3VhbENoYW5uZWwoY2hhbm5lbCk7XG4gICAgLy8gY2FsY3VsYXRlIGxheWVyIGNoYW5uZWwgZG9tYWluXG4gICAgY29uc3QgdXBkYXRlZERvbWFpbiA9IHRoaXMuY2FsY3VsYXRlTGF5ZXJEb21haW4oZGF0YXNldCwgdmlzdWFsQ2hhbm5lbCk7XG4gICAgdGhpcy51cGRhdGVMYXllckNvbmZpZyh7W3Zpc3VhbENoYW5uZWwuZG9tYWluXTogdXBkYXRlZERvbWFpbn0pO1xuICB9XG5cbiAgZ2V0VmlzdWFsQ2hhbm5lbFVwZGF0ZVRyaWdnZXJzKCk6IFVwZGF0ZVRyaWdnZXJzIHtcbiAgICBjb25zdCB1cGRhdGVUcmlnZ2VyczogVXBkYXRlVHJpZ2dlcnMgPSB7fTtcbiAgICBPYmplY3QudmFsdWVzKHRoaXMudmlzdWFsQ2hhbm5lbHMpLmZvckVhY2godmlzdWFsQ2hhbm5lbCA9PiB7XG4gICAgICAvLyBmaWVsZCByYW5nZSBzY2FsZSBkb21haW5cbiAgICAgIGNvbnN0IHthY2Nlc3NvciwgZmllbGQsIHNjYWxlLCBkb21haW4sIHJhbmdlLCBkZWZhdWx0VmFsdWUsIGZpeGVkfSA9IHZpc3VhbENoYW5uZWw7XG5cbiAgICAgIGlmIChhY2Nlc3Nvcikge1xuICAgICAgICB1cGRhdGVUcmlnZ2Vyc1thY2Nlc3Nvcl0gPSB7XG4gICAgICAgICAgW2ZpZWxkXTogdGhpcy5jb25maWdbZmllbGRdLFxuICAgICAgICAgIFtzY2FsZV06IHRoaXMuY29uZmlnW3NjYWxlXSxcbiAgICAgICAgICBbZG9tYWluXTogdGhpcy5jb25maWdbZG9tYWluXSxcbiAgICAgICAgICBbcmFuZ2VdOiB0aGlzLmNvbmZpZy52aXNDb25maWdbcmFuZ2VdLFxuICAgICAgICAgIGRlZmF1bHRWYWx1ZTpcbiAgICAgICAgICAgIHR5cGVvZiBkZWZhdWx0VmFsdWUgPT09ICdmdW5jdGlvbicgPyBkZWZhdWx0VmFsdWUodGhpcy5jb25maWcpIDogZGVmYXVsdFZhbHVlLFxuICAgICAgICAgIC4uLihmaXhlZCA/IHtbZml4ZWRdOiB0aGlzLmNvbmZpZy52aXNDb25maWdbZml4ZWRdfSA6IHt9KVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB1cGRhdGVUcmlnZ2VycztcbiAgfVxuXG4gIGNhbGN1bGF0ZUxheWVyRG9tYWluKGRhdGFzZXQsIHZpc3VhbENoYW5uZWwpIHtcbiAgICBjb25zdCB7c2NhbGV9ID0gdmlzdWFsQ2hhbm5lbDtcbiAgICBjb25zdCBzY2FsZVR5cGUgPSB0aGlzLmNvbmZpZ1tzY2FsZV07XG5cbiAgICBjb25zdCBmaWVsZCA9IHRoaXMuY29uZmlnW3Zpc3VhbENoYW5uZWwuZmllbGRdO1xuICAgIGlmICghZmllbGQpIHtcbiAgICAgIC8vIGlmIGNvbG9yRmllbGQgb3Igc2l6ZUZpZWxkIHdlcmUgc2V0IGJhY2sgdG8gbnVsbFxuICAgICAgcmV0dXJuIGRlZmF1bHREb21haW47XG4gICAgfVxuXG4gICAgcmV0dXJuIGRhdGFzZXQuZ2V0Q29sdW1uTGF5ZXJEb21haW4oZmllbGQsIHNjYWxlVHlwZSkgfHwgZGVmYXVsdERvbWFpbjtcbiAgfVxuXG4gIGhhc0hvdmVyZWRPYmplY3Qob2JqZWN0SW5mbykge1xuICAgIHJldHVybiB0aGlzLmlzTGF5ZXJIb3ZlcmVkKG9iamVjdEluZm8pICYmIG9iamVjdEluZm8ub2JqZWN0ID8gb2JqZWN0SW5mby5vYmplY3QgOiBudWxsO1xuICB9XG5cbiAgaXNMYXllckhvdmVyZWQob2JqZWN0SW5mbyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBvYmplY3RJbmZvPy5waWNrZWQgJiYgb2JqZWN0SW5mbz8ubGF5ZXI/LnByb3BzPy5pZCA9PT0gdGhpcy5pZDtcbiAgfVxuXG4gIGdldFJhZGl1c1NjYWxlQnlab29tKG1hcFN0YXRlOiBNYXBTdGF0ZSwgZml4ZWRSYWRpdXM/OiBib29sZWFuKSB7XG4gICAgY29uc3QgcmFkaXVzQ2hhbm5lbCA9IE9iamVjdC52YWx1ZXModGhpcy52aXN1YWxDaGFubmVscykuZmluZCh2YyA9PiB2Yy5wcm9wZXJ0eSA9PT0gJ3JhZGl1cycpO1xuXG4gICAgaWYgKCFyYWRpdXNDaGFubmVsKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG5cbiAgICBjb25zdCBmaWVsZCA9IHJhZGl1c0NoYW5uZWwuZmllbGQ7XG4gICAgY29uc3QgZml4ZWQgPSBmaXhlZFJhZGl1cyA9PT0gdW5kZWZpbmVkID8gdGhpcy5jb25maWcudmlzQ29uZmlnLmZpeGVkUmFkaXVzIDogZml4ZWRSYWRpdXM7XG4gICAgY29uc3Qge3JhZGl1c30gPSB0aGlzLmNvbmZpZy52aXNDb25maWc7XG5cbiAgICByZXR1cm4gZml4ZWQgPyAxIDogKHRoaXMuY29uZmlnW2ZpZWxkXSA/IDEgOiByYWRpdXMpICogdGhpcy5nZXRab29tRmFjdG9yKG1hcFN0YXRlKTtcbiAgfVxuXG4gIHNob3VsZENhbGN1bGF0ZUxheWVyRGF0YShwcm9wczogc3RyaW5nW10pIHtcbiAgICByZXR1cm4gcHJvcHMuc29tZShwID0+ICF0aGlzLm5vbmVMYXllckRhdGFBZmZlY3RpbmdQcm9wcy5pbmNsdWRlcyhwKSk7XG4gIH1cblxuICBnZXRCcnVzaGluZ0V4dGVuc2lvblByb3BzKGludGVyYWN0aW9uQ29uZmlnLCBicnVzaGluZ1RhcmdldD8pIHtcbiAgICBjb25zdCB7YnJ1c2h9ID0gaW50ZXJhY3Rpb25Db25maWc7XG5cbiAgICByZXR1cm4ge1xuICAgICAgLy8gYnJ1c2hpbmdcbiAgICAgIGF1dG9IaWdobGlnaHQ6ICFicnVzaC5lbmFibGVkLFxuICAgICAgYnJ1c2hpbmdSYWRpdXM6IGJydXNoLmNvbmZpZy5zaXplICogMTAwMCxcbiAgICAgIGJydXNoaW5nVGFyZ2V0OiBicnVzaGluZ1RhcmdldCB8fCAnc291cmNlJyxcbiAgICAgIGJydXNoaW5nRW5hYmxlZDogYnJ1c2guZW5hYmxlZFxuICAgIH07XG4gIH1cblxuICBnZXREZWZhdWx0RGVja0xheWVyUHJvcHMoe1xuICAgIGlkeCxcbiAgICBncHVGaWx0ZXIsXG4gICAgbWFwU3RhdGUsXG4gICAgdmlzaWJsZVxuICB9OiB7XG4gICAgaWR4OiBudW1iZXI7XG4gICAgZ3B1RmlsdGVyOiBHcHVGaWx0ZXI7XG4gICAgbWFwU3RhdGU6IE1hcFN0YXRlO1xuICAgIHZpc2libGU6IGJvb2xlYW47XG4gIH0pIHtcbiAgICByZXR1cm4ge1xuICAgICAgaWQ6IHRoaXMuaWQsXG4gICAgICBpZHgsXG4gICAgICBjb29yZGluYXRlU3lzdGVtOiBDT09SRElOQVRFX1NZU1RFTS5MTkdMQVQsXG4gICAgICBwaWNrYWJsZTogdHJ1ZSxcbiAgICAgIHdyYXBMb25naXR1ZGU6IHRydWUsXG4gICAgICBwYXJhbWV0ZXJzOiB7ZGVwdGhUZXN0OiBCb29sZWFuKG1hcFN0YXRlLmRyYWdSb3RhdGUgfHwgdGhpcy5jb25maWcudmlzQ29uZmlnLmVuYWJsZTNkKX0sXG4gICAgICBoaWRkZW46IHRoaXMuY29uZmlnLmhpZGRlbixcbiAgICAgIC8vIHZpc2NvbmZpZ1xuICAgICAgb3BhY2l0eTogdGhpcy5jb25maWcudmlzQ29uZmlnLm9wYWNpdHksXG4gICAgICBoaWdobGlnaHRDb2xvcjogdGhpcy5jb25maWcuaGlnaGxpZ2h0Q29sb3IsXG4gICAgICAvLyBkYXRhIGZpbHRlcmluZ1xuICAgICAgZXh0ZW5zaW9uczogW2RhdGFGaWx0ZXJFeHRlbnNpb25dLFxuICAgICAgZmlsdGVyUmFuZ2U6IGdwdUZpbHRlciA/IGdwdUZpbHRlci5maWx0ZXJSYW5nZSA6IHVuZGVmaW5lZCxcblxuICAgICAgLy8gbGF5ZXIgc2hvdWxkIGJlIHZpc2libGUgYW5kIGlmIHNwbGl0TWFwLCBzaG93biBpbiB0byBvbmUgb2YgcGFuZWxcbiAgICAgIHZpc2libGU6IHRoaXMuY29uZmlnLmlzVmlzaWJsZSAmJiB2aXNpYmxlXG4gICAgfTtcbiAgfVxuXG4gIGdldERlZmF1bHRIb3ZlckxheWVyUHJvcHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlkOiBgJHt0aGlzLmlkfS1ob3ZlcmVkYCxcbiAgICAgIHBpY2thYmxlOiBmYWxzZSxcbiAgICAgIHdyYXBMb25naXR1ZGU6IHRydWUsXG4gICAgICBjb29yZGluYXRlU3lzdGVtOiBDT09SRElOQVRFX1NZU1RFTS5MTkdMQVRcbiAgICB9O1xuICB9XG5cbiAgcmVuZGVyVGV4dExhYmVsTGF5ZXIoe2dldFBvc2l0aW9uLCBnZXRQaXhlbE9mZnNldCwgdXBkYXRlVHJpZ2dlcnMsIHNoYXJlZFByb3BzfSwgcmVuZGVyT3B0cykge1xuICAgIGNvbnN0IHtkYXRhLCBtYXBTdGF0ZX0gPSByZW5kZXJPcHRzO1xuICAgIGNvbnN0IHt0ZXh0TGFiZWx9ID0gdGhpcy5jb25maWc7XG5cbiAgICByZXR1cm4gZGF0YS50ZXh0TGFiZWxzLnJlZHVjZSgoYWNjdSwgZCwgaSkgPT4ge1xuICAgICAgaWYgKGQuZ2V0VGV4dCkge1xuICAgICAgICBhY2N1LnB1c2goXG4gICAgICAgICAgbmV3IFRleHRMYXllcih7XG4gICAgICAgICAgICAuLi5zaGFyZWRQcm9wcyxcbiAgICAgICAgICAgIGlkOiBgJHt0aGlzLmlkfS1sYWJlbC0ke3RleHRMYWJlbFtpXS5maWVsZD8ubmFtZX1gLFxuICAgICAgICAgICAgZGF0YTogZGF0YS5kYXRhLFxuICAgICAgICAgICAgZ2V0VGV4dDogZC5nZXRUZXh0LFxuICAgICAgICAgICAgZ2V0UG9zaXRpb24sXG4gICAgICAgICAgICBjaGFyYWN0ZXJTZXQ6IGQuY2hhcmFjdGVyU2V0LFxuICAgICAgICAgICAgZ2V0UGl4ZWxPZmZzZXQ6IGdldFBpeGVsT2Zmc2V0KHRleHRMYWJlbFtpXSksXG4gICAgICAgICAgICBnZXRTaXplOiBQUk9KRUNURURfUElYRUxfU0laRV9NVUxUSVBMSUVSLFxuICAgICAgICAgICAgc2l6ZVNjYWxlOiB0ZXh0TGFiZWxbaV0uc2l6ZSxcbiAgICAgICAgICAgIGdldFRleHRBbmNob3I6IHRleHRMYWJlbFtpXS5hbmNob3IsXG4gICAgICAgICAgICBnZXRBbGlnbm1lbnRCYXNlbGluZTogdGV4dExhYmVsW2ldLmFsaWdubWVudCxcbiAgICAgICAgICAgIGdldENvbG9yOiB0ZXh0TGFiZWxbaV0uY29sb3IsXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiB7XG4gICAgICAgICAgICAgIC8vIHRleHQgd2lsbCBhbHdheXMgc2hvdyBvbiB0b3Agb2YgYWxsIGxheWVyc1xuICAgICAgICAgICAgICBkZXB0aFRlc3Q6IGZhbHNlXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBnZXRGaWx0ZXJWYWx1ZTogZGF0YS5nZXRGaWx0ZXJWYWx1ZSxcbiAgICAgICAgICAgIHVwZGF0ZVRyaWdnZXJzOiB7XG4gICAgICAgICAgICAgIC4uLnVwZGF0ZVRyaWdnZXJzLFxuICAgICAgICAgICAgICBnZXRUZXh0OiB0ZXh0TGFiZWxbaV0uZmllbGQ/Lm5hbWUsXG4gICAgICAgICAgICAgIGdldFBpeGVsT2Zmc2V0OiB7XG4gICAgICAgICAgICAgICAgLi4udXBkYXRlVHJpZ2dlcnMuZ2V0UmFkaXVzLFxuICAgICAgICAgICAgICAgIG1hcFN0YXRlLFxuICAgICAgICAgICAgICAgIGFuY2hvcjogdGV4dExhYmVsW2ldLmFuY2hvcixcbiAgICAgICAgICAgICAgICBhbGlnbm1lbnQ6IHRleHRMYWJlbFtpXS5hbGlnbm1lbnRcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgZ2V0VGV4dEFuY2hvcjogdGV4dExhYmVsW2ldLmFuY2hvcixcbiAgICAgICAgICAgICAgZ2V0QWxpZ25tZW50QmFzZWxpbmU6IHRleHRMYWJlbFtpXS5hbGlnbm1lbnQsXG4gICAgICAgICAgICAgIGdldENvbG9yOiB0ZXh0TGFiZWxbaV0uY29sb3JcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFjY3U7XG4gICAgfSwgW10pO1xuICB9XG5cbiAgY2FsY3VsYXRlRGF0YUF0dHJpYnV0ZShrZXBsZXJUYWJsZTogS2VwbGVyVGFibGUsIGdldFBvc2l0aW9uKTogYW55IHtcbiAgICAvLyBpbXBsZW1lbnRlZCBpbiBzdWJjbGFzc2VzXG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgdXBkYXRlTGF5ZXJNZXRhKGRhdGFDb250YWluZXI6IERhdGFDb250YWluZXJJbnRlcmZhY2UsIGdldFBvc2l0aW9uKSB7XG4gICAgLy8gaW1wbGVtZW50ZWQgaW4gc3ViY2xhc3Nlc1xuICB9XG5cbiAgZ2V0UG9zaXRpb25BY2Nlc3NvcihkYXRhQ29udGFpbmVyPzogRGF0YUNvbnRhaW5lckludGVyZmFjZSk6ICguLi5hcmdzOiBhbnlbXSkgPT4gYW55IHtcbiAgICAvLyBpbXBsZW1lbnRlZCBpbiBzdWJjbGFzc2VzXG4gICAgcmV0dXJuICgpID0+IG51bGw7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTGF5ZXI7XG4iXX0=