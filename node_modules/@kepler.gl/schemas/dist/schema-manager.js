// Copyright (c) 2022 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = exports.KeplerGLSchema = exports.reducerSchema = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _window = require("global/window");

var _datasetSchema = _interopRequireDefault(require("./dataset-schema"));

var _mapStyleSchema = _interopRequireDefault(require("./map-style-schema"));

var _mapStateSchema = _interopRequireDefault(require("./map-state-schema"));

var _visStateSchema = require("./vis-state-schema");

var _versions = require("./versions");

var _utils = require("@kepler.gl/utils");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var reducerSchema = {
  visState: _visStateSchema.visStateSchema,
  mapState: _mapStateSchema["default"],
  mapStyle: _mapStyleSchema["default"]
};
exports.reducerSchema = reducerSchema;

var KeplerGLSchema = /*#__PURE__*/function () {
  function KeplerGLSchema() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$reducers = _ref.reducers,
        reducers = _ref$reducers === void 0 ? reducerSchema : _ref$reducers,
        _ref$datasets = _ref.datasets,
        datasets = _ref$datasets === void 0 ? _datasetSchema["default"] : _ref$datasets,
        _ref$validVersions = _ref.validVersions,
        validVersions = _ref$validVersions === void 0 ? _versions.VERSIONS : _ref$validVersions,
        _ref$version = _ref.version,
        version = _ref$version === void 0 ? _versions.CURRENT_VERSION : _ref$version;

    (0, _classCallCheck2["default"])(this, KeplerGLSchema);
    (0, _defineProperty2["default"])(this, "_validVersions", void 0);
    (0, _defineProperty2["default"])(this, "_version", void 0);
    (0, _defineProperty2["default"])(this, "_reducerSchemas", void 0);
    (0, _defineProperty2["default"])(this, "_datasetSchema", void 0);
    (0, _defineProperty2["default"])(this, "_datasetLastSaved", void 0);
    (0, _defineProperty2["default"])(this, "_savedDataset", void 0);
    this._validVersions = validVersions;
    this._version = version;
    this._reducerSchemas = reducers;
    this._datasetSchema = datasets;
    this._datasetLastSaved = null;
    this._savedDataset = null;
  }
  /**
   * stateToSave = {
   *   datasets: [
   *     {
   *       version: 'v0',
   *       data: {id, label, color, allData, fields}
   *     },
   *     {
   *       version: 'v0',
   *       data: {id, label, color, allData, fields}
   *     }
   *   ],
   *   config: {
   *     version: 'v0',
   *     config: {}
   *   },
   *   info: {
   *     app: 'kepler.gl',
   *     create_at: 'Mon May 28 2018 21:04:46 GMT-0700 (PDT)'
   *   }
   * }
   *
   * Get config and data of current map to save
   * @param state
   * @returns app state to save
   */


  (0, _createClass2["default"])(KeplerGLSchema, [{
    key: "save",
    value: function save(state) {
      return {
        datasets: this.getDatasetToSave(state),
        config: this.getConfigToSave(state),
        info: _objectSpread({
          app: 'kepler.gl',
          created_at: new Date().toString()
        }, this.getMapInfo(state))
      };
    }
  }, {
    key: "getMapInfo",
    value: function getMapInfo(state) {
      return state.visState.mapInfo;
    }
    /**
     *  Load saved map, argument can be (datasets, config) or ({datasets, config})
     * @param savedDatasets
     * @param savedConfig
     */

  }, {
    key: "load",
    value: function load(savedDatasets, savedConfig) {
      // if pass dataset and config in as a single object
      if (arguments.length === 1 && (0, _utils.isPlainObject)(arguments[0]) && (Array.isArray(arguments[0].datasets) || (0, _utils.isPlainObject)(arguments[0].config))) {
        return this.load(arguments[0].datasets, arguments[0].config);
      }

      return _objectSpread(_objectSpread({}, Array.isArray(savedDatasets) ? {
        datasets: this.parseSavedData(savedDatasets)
      } : {}), savedConfig ? {
        config: this.parseSavedConfig(savedConfig)
      } : {});
    }
    /**
     * Get data to save
     * @param state - app state
     * @returns - dataset to save
     */

  }, {
    key: "getDatasetToSave",
    value: function getDatasetToSave(state) {
      var _this = this;

      var dataChangedSinceLastSave = this.hasDataChanged(state);

      if (!dataChangedSinceLastSave) {
        // @ts-expect-error
        return this._savedDataset;
      }

      var visState = state.visState;
      var datasets = Object.values(visState.datasets).map(function (ds) {
        return {
          version: _this._version,
          data: _this._datasetSchema[_this._version].save(ds)
        };
      }); // keep a copy of formatted datasets to save

      this._datasetLastSaved = visState.datasets;
      this._savedDataset = datasets;
      return datasets;
    }
    /**
     * Get App config to save
     * @param {Object} state - app state
     * @returns {{version: String, config: Object}} - config to save
     */

  }, {
    key: "getConfigToSave",
    value: function getConfigToSave(state) {
      var _this2 = this;

      var config = Object.keys(this._reducerSchemas).reduce(function (accu, key) {
        return _objectSpread(_objectSpread({}, accu), state[key] ? _this2._reducerSchemas[key][_this2._version].save(state[key]) : {});
      }, {});
      return {
        version: this._version,
        // @ts-expect-error
        config: config
      };
    }
    /**
     * Parse saved data
     * @param datasets
     * @returns - dataset to pass to addDataToMap
     */

  }, {
    key: "parseSavedData",
    value: function parseSavedData(datasets) {
      var _this3 = this;

      return datasets.reduce(function (accu, ds) {
        var validVersion = _this3.validateVersion(ds.version);

        if (!validVersion) {
          return accu;
        }

        accu.push(_this3._datasetSchema[validVersion].load(ds.data));
        return accu;
      }, []);
    }
    /**
     * Parse saved App config
     */

  }, {
    key: "parseSavedConfig",
    value: function parseSavedConfig(_ref2) {
      var _this4 = this;

      var version = _ref2.version,
          config = _ref2.config;
      var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var validVersion = this.validateVersion(version);

      if (!validVersion) {
        return null;
      } // @ts-expect-error


      return Object.keys(config).reduce(function (accu, key) {
        return _objectSpread(_objectSpread({}, accu), key in _this4._reducerSchemas ? _this4._reducerSchemas[key][validVersion].load(config[key]) : {});
      }, {});
    }
    /**
     * Validate version
     * @param version
     * @returns validVersion
     */

  }, {
    key: "validateVersion",
    value: function validateVersion(version) {
      if (!version) {
        _window.console.error('There is no version number associated with this saved map');

        return null;
      }

      if (!this._validVersions[version]) {
        _window.console.error("".concat(version, " is not a valid version"));

        return null;
      }

      return version;
    }
    /**
     * Check if data has changed since last save
     * @param state
     * @returns - whether data has changed or not
     */

  }, {
    key: "hasDataChanged",
    value: function hasDataChanged(state) {
      return true; // return this._datasetLastSaved !== state.visState.datasets;
    }
  }]);
  return KeplerGLSchema;
}();

exports.KeplerGLSchema = KeplerGLSchema;
var KeplerGLSchemaManager = new KeplerGLSchema();
var _default = KeplerGLSchemaManager;
exports["default"] = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9zY2hlbWEtbWFuYWdlci50cyJdLCJuYW1lcyI6WyJyZWR1Y2VyU2NoZW1hIiwidmlzU3RhdGUiLCJ2aXNTdGF0ZVNjaGVtYSIsIm1hcFN0YXRlIiwibWFwU3RhdGVTY2hlbWEiLCJtYXBTdHlsZSIsIm1hcFN0eWxlU2NoZW1hIiwiS2VwbGVyR0xTY2hlbWEiLCJyZWR1Y2VycyIsImRhdGFzZXRzIiwiZGF0YXNldFNjaGVtYSIsInZhbGlkVmVyc2lvbnMiLCJWRVJTSU9OUyIsInZlcnNpb24iLCJDVVJSRU5UX1ZFUlNJT04iLCJfdmFsaWRWZXJzaW9ucyIsIl92ZXJzaW9uIiwiX3JlZHVjZXJTY2hlbWFzIiwiX2RhdGFzZXRTY2hlbWEiLCJfZGF0YXNldExhc3RTYXZlZCIsIl9zYXZlZERhdGFzZXQiLCJzdGF0ZSIsImdldERhdGFzZXRUb1NhdmUiLCJjb25maWciLCJnZXRDb25maWdUb1NhdmUiLCJpbmZvIiwiYXBwIiwiY3JlYXRlZF9hdCIsIkRhdGUiLCJ0b1N0cmluZyIsImdldE1hcEluZm8iLCJtYXBJbmZvIiwic2F2ZWREYXRhc2V0cyIsInNhdmVkQ29uZmlnIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwiQXJyYXkiLCJpc0FycmF5IiwibG9hZCIsInBhcnNlU2F2ZWREYXRhIiwicGFyc2VTYXZlZENvbmZpZyIsImRhdGFDaGFuZ2VkU2luY2VMYXN0U2F2ZSIsImhhc0RhdGFDaGFuZ2VkIiwiT2JqZWN0IiwidmFsdWVzIiwibWFwIiwiZHMiLCJkYXRhIiwic2F2ZSIsImtleXMiLCJyZWR1Y2UiLCJhY2N1Iiwia2V5IiwidmFsaWRWZXJzaW9uIiwidmFsaWRhdGVWZXJzaW9uIiwicHVzaCIsIkNvbnNvbGUiLCJlcnJvciIsIktlcGxlckdMU2NoZW1hTWFuYWdlciJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBb0JBOztBQUdBOztBQUNBOztBQUNBOztBQUVBOztBQUVBOztBQUNBOzs7Ozs7QUFvRU8sSUFBTUEsYUFFWixHQUFHO0FB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QUNBLE9BQUwsRUFBYztBQUNaMkMsd0JBQVFDLEtBQVIsQ0FBYywyREFBZDs7QUFDQSxlQUFPLElBQVA7QUFDRDs7QUFFRCxVQUFJLENBQUMsS0FBSzFDLGNBQUwsQ0FBb0JGLE9BQXBCLENBQUwsRUFBbUM7QUFDakMyQyx3QkFBUUMsS0FBUixXQUFpQjVDLE9BQWpCOztBQUNBLGVBQU8sSUFBUDtBQUNEOztBQUVELGFBQU9BLE9BQVA7QUFDRDtBQUVEO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7Ozs7V0FDRSx3QkFBZVEsS0FBZixFQUFvQztBQUNsQyxhQUFPLElBQVAsQ0FEa0MsQ0FFbEM7QUFDRDs7Ozs7O0FBR0gsSUFBTXFDLHFCQUFxQixHQUFHLElBQUluRCxjQUFKLEVBQTlCO2VBRWVtRCxxQiIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAyMiBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5cbmltcG9ydCB7Y29uc29sZSBhcyBDb25zb2xlfSBmcm9tICdnbG9iYWwvd2luZG93JztcblxuaW1wb3J0IHtEYXRhc2V0c30gZnJvbSAnQGtlcGxlci5nbC90YWJsZSc7XG5pbXBvcnQgZGF0YXNldFNjaGVtYSBmcm9tICcuL2RhdGFzZXQtc2NoZW1hJztcbmltcG9ydCBtYXBTdHlsZVNjaGVtYSBmcm9tICcuL21hcC1zdHlsZS1zY2hlbWEnO1xuaW1wb3J0IG1hcFN0YXRlU2NoZW1hIGZyb20gJy4vbWFwLXN0YXRlLXNjaGVtYSc7XG5pbXBvcnQge1NhdmVkRGF0YXNldFYxLCBQYXJzZWREYXRhc2V0fSBmcm9tICcuL2RhdGFzZXQtc2NoZW1hJztcbmltcG9ydCB7dmlzU3RhdGVTY2hlbWF9IGZyb20gJy4vdmlzLXN0YXRlLXNjaGVtYSc7XG5cbmltcG9ydCB7Q1VSUkVOVF9WRVJTSU9OLCBWRVJTSU9OU30gZnJvbSAnLi92ZXJzaW9ucyc7XG5pbXBvcnQge2lzUGxhaW5PYmplY3R9IGZyb20gJ0BrZXBsZXIuZ2wvdXRpbHMnO1xuXG5pbXBvcnQge01hcEluZm8sIFBhcnNlZFZpc1N0YXRlLCBSR0JDb2xvciwgU2F2ZWRWaXNTdGF0ZX0gZnJvbSAnQGtlcGxlci5nbC90eXBlcyc7XG5cbmV4cG9ydCB0eXBlIFNhdmVkTWFwU3RhdGUgPSB7XG4gIGJlYXJpbmc6IG51bWJlcjtcbiAgZHJhZ1JvdGF0ZTogYm9vbGVhbjtcbiAgbGF0aXR1ZGU6IG51bWJlcjtcbiAgbG9uZ2l0dWRlOiBudW1iZXI7XG4gIHBpdGNoOiBudW1iZXI7XG4gIHpvb206IG51bWJlcjtcbiAgaXNTcGxpdDogYm9vbGVhbjtcbn07XG5cbmV4cG9ydCB0eXBlIFNhdmVkTGF5ZXJHcm91cHMgPSB7XG4gIFtrZXk6IHN0cmluZ106IGJvb2xlYW47XG59O1xuXG5leHBvcnQgdHlwZSBTYXZlZEN1c3RvbU1hcFN0eWxlID0ge1xuICBba2V5OiBzdHJpbmddOiB7XG4gICAgYWNjZXNzVG9rZW46IHN0cmluZztcbiAgICBjdXN0b206IGJvb2xlYW47XG4gICAgaWNvbjogc3RyaW5nO1xuICAgIGlkOiBzdHJpbmc7XG4gICAgbGFiZWw6IHN0cmluZztcbiAgICB1cmw6IHN0cmluZztcbiAgfTtcbn07XG5cbmV4cG9ydCB0eXBlIFNhdmVkTWFwU3R5bGUgPSB7XG4gIHN0eWxlVHlwZTogc3RyaW5nO1xuICB0b3BMYXllckdyb3VwczogU2F2ZWRMYXllckdyb3VwcztcbiAgdmlzaWJsZUxheWVyR3JvdXBzOiBTYXZlZExheWVyR3JvdXBzO1xuICB0aHJlZURCdWlsZGluZ0NvbG9yOiBSR0JDb2xvcjtcbiAgbWFwU3R5bGVzOiBTYXZlZEN1c3RvbU1hcFN0eWxlO1xufTtcblxuLyoqIFNjaGVtYSBmb3IgdjEgc2F2ZWQgY29uZmlndXJhdGlvbiAqL1xuZXhwb3J0IHR5cGUgU2F2ZWRDb25maWdWMSA9IHtcbiAgdmVyc2lvbjogJ3YxJztcbiAgY29uZmlnOiB7XG4gICAgdmlzU3RhdGU6IFNhdmVkVmlzU3RhdGU7XG4gICAgbWFwU3RhdGU6IFNhdmVkTWFwU3RhdGU7XG4gICAgbWFwU3R5bGU6IFNhdmVkTWFwU3R5bGU7XG4gIH07XG59O1xuXG4vKiogU2NoZW1hIGZvciBhIHBhcnNlZCBjb25maWd1cmF0aW9uIChcIm5vcm1hbGl6ZWRcIiBhY3Jvc3MgdmVyc2lvbnMpICovXG5leHBvcnQgdHlwZSBQYXJzZWRDb25maWcgPSB7XG4gIHZlcnNpb246IHN0cmluZztcbiAgdmlzU3RhdGU/OiBQYXJzZWRWaXNTdGF0ZTtcbiAgbWFwU3RhdGU/OiBQYXJ0aWFsPFNhdmVkTWFwU3RhdGU+O1xuICBtYXBTdHlsZT86IFBhcnRpYWw8U2F2ZWRNYXBTdHlsZT47XG59O1xuXG5leHBvcnQgdHlwZSBTYXZlZE1hcCA9IHtcbiAgZGF0YXNldHM6IFNhdmVkRGF0YXNldFYxW107XG4gIGNvbmZpZzogU2F2ZWRDb25maWdWMTtcbiAgaW5mbzoge1xuICAgIGFwcDogc3RyaW5nO1xuICAgIGNyZWF0ZWRfYXQ6IHN0cmluZztcbiAgICB0aXRsZTogc3RyaW5nO1xuICAgIGRlc2NyaXB0aW9uOiBzdHJpbmc7XG4gIH07XG59O1xuXG5leHBvcnQgdHlwZSBMb2FkZWRNYXAgPSB7ZGF0YXNldHM/OiBQYXJzZWREYXRhc2V0W10gfCBudWxsOyBjb25maWc/OiBQYXJzZWRDb25maWcgfCBudWxsfTtcblxuZXhwb3J0IGNvbnN0IHJlZHVjZXJTY2hlbWE6IHtcbiAgW2tleTogc3RyaW5nXTogdHlwZW9mIG1hcFN0YXRlU2NoZW1hIHwgdHlwZW9mIHZpc1N0YXRlU2NoZW1hIHwgdHlwZW9mIG1hcFN0eWxlU2NoZW1hO1xufSA9IHtcbiAgdmlzU3RhdGU6IHZpc1N0YXRlU2NoZW1hLFxuICBtYXBTdGF0ZTogbWFwU3RhdGVTY2hlbWEsXG4gIG1hcFN0eWxlOiBtYXBTdHlsZVNjaGVtYVxufTtcblxuZXhwb3J0IGNsYXNzIEtlcGxlckdMU2NoZW1hIHtcbiAgX3ZhbGlkVmVyc2lvbnM6IHR5cGVvZiBWRVJTSU9OUztcbiAgX3ZlcnNpb246ICd2MSc7XG4gIF9yZWR1Y2VyU2NoZW1hczogdHlwZW9mIHJlZHVjZXJTY2hlbWE7XG4gIF9kYXRhc2V0U2NoZW1hOiB0eXBlb2YgZGF0YXNldFNjaGVtYTtcbiAgX2RhdGFzZXRMYXN0U2F2ZWQ6IFNhdmVkRGF0YXNldFYxW10gfCBudWxsO1xuICBfc2F2ZWREYXRhc2V0OiBTYXZlZERhdGFzZXRWMVtdIHwgbnVsbDtcblxuICBjb25zdHJ1Y3Rvcih7XG4gICAgcmVkdWNlcnMgPSByZWR1Y2VyU2NoZW1hLFxuICAgIGRhdGFzZXRzID0gZGF0YXNldFNjaGVtYSxcbiAgICB2YWxpZFZlcnNpb25zID0gVkVSU0lPTlMsXG4gICAgdmVyc2lvbiA9IENVUlJFTlRfVkVSU0lPTlxuICB9OiB7XG4gICAgcmVkdWNlcnM/OiB0eXBlb2YgcmVkdWNlclNjaGVtYTtcbiAgICBkYXRhc2V0cz86IHR5cGVvZiBkYXRhc2V0U2NoZW1hO1xuICAgIHZhbGlkVmVyc2lvbnM/OiB0eXBlb2YgVkVSU0lPTlM7XG4gICAgdmVyc2lvbj86ICd2MSc7XG4gIH0gPSB7fSkge1xuICAgIHRoaXMuX3ZhbGlkVmVyc2lvbnMgPSB2YWxpZFZlcnNpb25zO1xuICAgIHRoaXMuX3ZlcnNpb24gPSB2ZXJzaW9uO1xuICAgIHRoaXMuX3JlZHVjZXJTY2hlbWFzID0gcmVkdWNlcnM7XG4gICAgdGhpcy5fZGF0YXNldFNjaGVtYSA9IGRhdGFzZXRzO1xuXG4gICAgdGhpcy5fZGF0YXNldExhc3RTYXZlZCA9IG51bGw7XG4gICAgdGhpcy5fc2F2ZWREYXRhc2V0ID0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBzdGF0ZVRvU2F2ZSA9IHtcbiAgICogICBkYXRhc2V0czogW1xuICAgKiAgICAge1xuICAgKiAgICAgICB2ZXJzaW9uOiAndjAnLFxuICAgKiAgICAgICBkYXRhOiB7aWQsIGxhYmVsLCBjb2xvciwgYWxsRGF0YSwgZmllbGRzfVxuICAgKiAgICAgfSxcbiAgICogICAgIHtcbiAgICogICAgICAgdmVyc2lvbjogJ3YwJyxcbiAgICogICAgICAgZGF0YToge2lkLCBsYWJlbCwgY29sb3IsIGFsbERhdGEsIGZpZWxkc31cbiAgICogICAgIH1cbiAgICogICBdLFxuICAgKiAgIGNvbmZpZzoge1xuICAgKiAgICAgdmVyc2lvbjogJ3YwJyxcbiAgICogICAgIGNvbmZpZzoge31cbiAgICogICB9LFxuICAgKiAgIGluZm86IHtcbiAgICogICAgIGFwcDogJ2tlcGxlci5nbCcsXG4gICAqICAgICBjcmVhdGVfYXQ6ICdNb24gTWF5IDI4IDIwMTggMjE6MDQ6NDYgR01ULTA3MDAgKFBEVCknXG4gICAqICAgfVxuICAgKiB9XG4gICAqXG4gICAqIEdldCBjb25maWcgYW5kIGRhdGEgb2YgY3VycmVudCBtYXAgdG8gc2F2ZVxuICAgKiBAcGFyYW0gc3RhdGVcbiAgICogQHJldHVybnMgYXBwIHN0YXRlIHRvIHNhdmVcbiAgICovXG4gIHNhdmUoc3RhdGU6IGFueSk6IFNhdmVkTWFwIHtcbiAgICByZXR1cm4ge1xuICAgICAgZGF0YXNldHM6IHRoaXMuZ2V0RGF0YXNldFRvU2F2ZShzdGF0ZSksXG4gICAgICBjb25maWc6IHRoaXMuZ2V0Q29uZmlnVG9TYXZlKHN0YXRlKSxcbiAgICAgIGluZm86IHtcbiAgICAgICAgYXBwOiAna2VwbGVyLmdsJyxcbiAgICAgICAgY3JlYXRlZF9hdDogbmV3IERhdGUoKS50b1N0cmluZygpLFxuICAgICAgICAuLi50aGlzLmdldE1hcEluZm8oc3RhdGUpXG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIGdldE1hcEluZm8oc3RhdGU6IGFueSk6IE1hcEluZm8ge1xuICAgIHJldHVybiBzdGF0ZS52aXNTdGF0ZS5tYXBJbmZvO1xuICB9XG4gIC8qKlxuICAgKiAgTG9hZCBzYXZlZCBtYXAsIGFyZ3VtZW50IGNhbiBiZSAoZGF0YXNldHMsIGNvbmZpZykgb3IgKHtkYXRhc2V0cywgY29uZmlnfSlcbiAgICogQHBhcmFtIHNhdmVkRGF0YXNldHNcbiAgICogQHBhcmFtIHNhdmVkQ29uZmlnXG4gICAqL1xuICBsb2FkKFxuICAgIHNhdmVkRGF0YXNldHM6IFNhdmVkTWFwIHwgU2F2ZWRNYXBbJ2RhdGFzZXRzJ10gfCBhbnksXG4gICAgc2F2ZWRDb25maWc6IFNhdmVkTWFwWydjb25maWcnXSB8IGFueVxuICApOiBMb2FkZWRNYXAge1xuICAgIC8vIGlmIHBhc3MgZGF0YXNldCBhbmQgY29uZmlnIGluIGFzIGEgc2luZ2xlIG9iamVjdFxuICAgIGlmIChcbiAgICAgIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiZcbiAgICAgIGlzUGxhaW5PYmplY3QoYXJndW1lbnRzWzBdKSAmJlxuICAgICAgKEFycmF5LmlzQXJyYXkoYXJndW1lbnRzWzBdLmRhdGFzZXRzKSB8fCBpc1BsYWluT2JqZWN0KGFyZ3VtZW50c1swXS5jb25maWcpKVxuICAgICkge1xuICAgICAgcmV0dXJuIHRoaXMubG9hZChhcmd1bWVudHNbMF0uZGF0YXNldHMsIGFyZ3VtZW50c1swXS5jb25maWcpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAuLi4oQXJyYXkuaXNBcnJheShzYXZlZERhdGFzZXRzKSA/IHtkYXRhc2V0czogdGhpcy5wYXJzZVNhdmVkRGF0YShzYXZlZERhdGFzZXRzKX0gOiB7fSksXG4gICAgICAuLi4oc2F2ZWRDb25maWcgPyB7Y29uZmlnOiB0aGlzLnBhcnNlU2F2ZWRDb25maWcoc2F2ZWRDb25maWcpfSA6IHt9KVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogR2V0IGRhdGEgdG8gc2F2ZVxuICAgKiBAcGFyYW0gc3RhdGUgLSBhcHAgc3RhdGVcbiAgICogQHJldHVybnMgLSBkYXRhc2V0IHRvIHNhdmVcbiAgICovXG4gIGdldERhdGFzZXRUb1NhdmUoc3RhdGU6IGFueSk6IFNhdmVkRGF0YXNldFYxW10ge1xuICAgIGNvbnN0IGRhdGFDaGFuZ2VkU2luY2VMYXN0U2F2ZSA9IHRoaXMuaGFzRGF0YUNoYW5nZWQoc3RhdGUpO1xuICAgIGlmICghZGF0YUNoYW5nZWRTaW5jZUxhc3RTYXZlKSB7XG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICByZXR1cm4gdGhpcy5fc2F2ZWREYXRhc2V0O1xuICAgIH1cblxuICAgIGNvbnN0IHt2aXNTdGF0ZX0gPSBzdGF0ZTtcblxuICAgIGNvbnN0IGRhdGFzZXRzID0gT2JqZWN0LnZhbHVlcyh2aXNTdGF0ZS5kYXRhc2V0cyBhcyBEYXRhc2V0cykubWFwKGRzID0+ICh7XG4gICAgICB2ZXJzaW9uOiB0aGlzLl92ZXJzaW9uLFxuICAgICAgZGF0YTogdGhpcy5fZGF0YXNldFNjaGVtYVt0aGlzLl92ZXJzaW9uXS5zYXZlKGRzKVxuICAgIH0pKTtcblxuICAgIC8vIGtlZXAgYSBjb3B5IG9mIGZvcm1hdHRlZCBkYXRhc2V0cyB0byBzYXZlXG4gICAgdGhpcy5fZGF0YXNldExhc3RTYXZlZCA9IHZpc1N0YXRlLmRhdGFzZXRzO1xuICAgIHRoaXMuX3NhdmVkRGF0YXNldCA9IGRhdGFzZXRzO1xuXG4gICAgcmV0dXJuIGRhdGFzZXRzO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBBcHAgY29uZmlnIHRvIHNhdmVcbiAgICogQHBhcmFtIHtPYmplY3R9IHN0YXRlIC0gYXBwIHN0YXRlXG4gICAqIEByZXR1cm5zIHt7dmVyc2lvbjogU3RyaW5nLCBjb25maWc6IE9iamVjdH19IC0gY29uZmlnIHRvIHNhdmVcbiAgICovXG4gIGdldENvbmZpZ1RvU2F2ZShzdGF0ZTogYW55KTogU2F2ZWRDb25maWdWMSB7XG4gICAgY29uc3QgY29uZmlnID0gT2JqZWN0LmtleXModGhpcy5fcmVkdWNlclNjaGVtYXMpLnJlZHVjZShcbiAgICAgIChhY2N1LCBrZXkpID0+ICh7XG4gICAgICAgIC4uLmFjY3UsXG4gICAgICAgIC4uLihzdGF0ZVtrZXldID8gdGhpcy5fcmVkdWNlclNjaGVtYXNba2V5XVt0aGlzLl92ZXJzaW9uXS5zYXZlKHN0YXRlW2tleV0pIDoge30pXG4gICAgICB9KSxcbiAgICAgIHt9XG4gICAgKTtcblxuICAgIHJldHVybiB7XG4gICAgICB2ZXJzaW9uOiB0aGlzLl92ZXJzaW9uLFxuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgY29uZmlnXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZSBzYXZlZCBkYXRhXG4gICAqIEBwYXJhbSBkYXRhc2V0c1xuICAgKiBAcmV0dXJucyAtIGRhdGFzZXQgdG8gcGFzcyB0byBhZGREYXRhVG9NYXBcbiAgICovXG4gIHBhcnNlU2F2ZWREYXRhKGRhdGFzZXRzOiBhbnkpOiBQYXJzZWREYXRhc2V0W10gfCBudWxsIHtcbiAgICByZXR1cm4gZGF0YXNldHMucmVkdWNlKChhY2N1LCBkcykgPT4ge1xuICAgICAgY29uc3QgdmFsaWRWZXJzaW9uID0gdGhpcy52YWxpZGF0ZVZlcnNpb24oZHMudmVyc2lvbik7XG4gICAgICBpZiAoIXZhbGlkVmVyc2lvbikge1xuICAgICAgICByZXR1cm4gYWNjdTtcbiAgICAgIH1cbiAgICAgIGFjY3UucHVzaCh0aGlzLl9kYXRhc2V0U2NoZW1hW3ZhbGlkVmVyc2lvbl0ubG9hZChkcy5kYXRhKSk7XG4gICAgICByZXR1cm4gYWNjdTtcbiAgICB9LCBbXSk7XG4gIH1cblxuICAvKipcbiAgICogUGFyc2Ugc2F2ZWQgQXBwIGNvbmZpZ1xuICAgKi9cbiAgcGFyc2VTYXZlZENvbmZpZyh7dmVyc2lvbiwgY29uZmlnfSwgc3RhdGUgPSB7fSk6IFBhcnNlZENvbmZpZyB8IG51bGwge1xuICAgIGNvbnN0IHZhbGlkVmVyc2lvbiA9IHRoaXMudmFsaWRhdGVWZXJzaW9uKHZlcnNpb24pO1xuICAgIGlmICghdmFsaWRWZXJzaW9uKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKGNvbmZpZykucmVkdWNlKFxuICAgICAgKGFjY3UsIGtleSkgPT4gKHtcbiAgICAgICAgLi4uYWNjdSxcbiAgICAgICAgLi4uKGtleSBpbiB0aGlzLl9yZWR1Y2VyU2NoZW1hc1xuICAgICAgICAgID8gdGhpcy5fcmVkdWNlclNjaGVtYXNba2V5XVt2YWxpZFZlcnNpb25dLmxvYWQoY29uZmlnW2tleV0pXG4gICAgICAgICAgOiB7fSlcbiAgICAgIH0pLFxuICAgICAge31cbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFZhbGlkYXRlIHZlcnNpb25cbiAgICogQHBhcmFtIHZlcnNpb25cbiAgICogQHJldHVybnMgdmFsaWRWZXJzaW9uXG4gICAqL1xuICB2YWxpZGF0ZVZlcnNpb24odmVyc2lvbjogYW55KTogc3RyaW5nIHwgbnVsbCB7XG4gICAgaWYgKCF2ZXJzaW9uKSB7XG4gICAgICBDb25zb2xlLmVycm9yKCdUaGVyZSBpcyBubyB2ZXJzaW9uIG51bWJlciBhc3NvY2lhdGVkIHdpdGggdGhpcyBzYXZlZCBtYXAnKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5fdmFsaWRWZXJzaW9uc1t2ZXJzaW9uXSkge1xuICAgICAgQ29uc29sZS5lcnJvcihgJHt2ZXJzaW9ufSBpcyBub3QgYSB2YWxpZCB2ZXJzaW9uYCk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gdmVyc2lvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBkYXRhIGhhcyBjaGFuZ2VkIHNpbmNlIGxhc3Qgc2F2ZVxuICAgKiBAcGFyYW0gc3RhdGVcbiAgICogQHJldHVybnMgLSB3aGV0aGVyIGRhdGEgaGFzIGNoYW5nZWQgb3Igbm90XG4gICAqL1xuICBoYXNEYXRhQ2hhbmdlZChzdGF0ZTogYW55KTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRydWU7XG4gICAgLy8gcmV0dXJuIHRoaXMuX2RhdGFzZXRMYXN0U2F2ZWQgIT09IHN0YXRlLnZpc1N0YXRlLmRhdGFzZXRzO1xuICB9XG59XG5cbmNvbnN0IEtlcGxlckdMU2NoZW1hTWFuYWdlciA9IG5ldyBLZXBsZXJHTFNjaGVtYSgpO1xuXG5leHBvcnQgZGVmYXVsdCBLZXBsZXJHTFNjaGVtYU1hbmFnZXI7XG4iXX0=