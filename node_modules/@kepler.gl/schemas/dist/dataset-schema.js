// Copyright (c) 2022 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = exports.datasetSchema = exports.DatasetSchema = exports.propertiesV1 = exports.propertiesV0 = exports.FieldSchema = exports.fieldPropertiesV1 = exports.fieldPropertiesV0 = void 0;

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _lodash = _interopRequireDefault(require("lodash.pick"));

var _window = require("global/window");

var _versions = require("./versions");

var _schema = _interopRequireDefault(require("./schema"));

var _utils = require("@kepler.gl/utils");

var _datasetSchema;

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

// version v0
var fieldPropertiesV0 = {
  name: null,
  type: null
};
exports.fieldPropertiesV0 = fieldPropertiesV0;
var fieldPropertiesV1 = {
  name: null,
  type: null,
  format: null,
  analyzerType: null,
  metadata: null
};
exports.fieldPropertiesV1 = fieldPropertiesV1;

var FieldSchema = /*#__PURE__*/function (_Schema) {
  (0, _inherits2["default"])(FieldSchema, _Schema);

  var _super = _createSuper(FieldSchema);

  function FieldSchema() {
    (0, _classCallCheck2["default"])(this, FieldSchema);
    return _super.apply(this, arguments);
  }

  (0, _createClass2["default"])(FieldSchema, [{
    key: "save",
    value: function save(fields) {
      var _this = this;

      return (0, _defineProperty2["default"])({}, this.key, fields.map(function (f) {
        return _this.savePropertiesOrApplySchema(f)[_this.key];
      }));
    }
  }, {
    key: "load",
    value: function load(fields) {
      return (0, _defineProperty2["default"])({}, this.key, fields);
    }
  }]);
  return FieldSchema;
}(_schema["default"]);

exports.FieldSchema = FieldSchema;
var propertiesV0 = {
  id: null,
  label: null,
  color: null,
  allData: null,
  fields: new FieldSchema({
    key: 'fields',
    version: _versions.VERSIONS.v0,
    properties: fieldPropertiesV0
  })
};
exports.propertiesV0 = propertiesV0;

var propertiesV1 = _objectSpread(_objectSpread({}, propertiesV0), {}, {
  fields: new FieldSchema({
    key: 'fields',
    version: _versions.VERSIONS.v1,
    properties: fieldPropertiesV1
  })
});

exports.propertiesV1 = propertiesV1;

var DatasetSchema = /*#__PURE__*/function (_Schema2) {
  (0, _inherits2["default"])(DatasetSchema, _Schema2);

  var _super2 = _createSuper(DatasetSchema);

  function DatasetSchema() {
    var _this2;

    (0, _classCallCheck2["default"])(this, DatasetSchema);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this2 = _super2.call.apply(_super2, [this].concat(args));
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this2), "key", 'dataset');
    return _this2;
  }

  (0, _createClass2["default"])(DatasetSchema, [{
    key: "save",
    value: function save(dataset) {
      var datasetFlattened = dataset.dataContainer ? _objectSpread(_objectSpread({}, dataset), {}, {
        allData: dataset.dataContainer.flattenData()
      }) : dataset;
      return this.savePropertiesOrApplySchema(datasetFlattened)[this.key];
    }
  }, {
    key: "load",
    value: function load(dataset) {
      var fields = dataset.fields,
          allData = dataset.allData;
      var updatedFields = fields; // recalculate field type
      // because we have updated type-analyzer
      // we need to add format to each field

      var needCalculateMeta = fields[0] && (!fields[0].hasOwnProperty('format') || !fields[0].hasOwnProperty('analyzerType'));

      if (needCalculateMeta) {
        var fieldOrder = fields.map(function (f) {
          return f.name;
        });
        var sampleData = (0, _utils.getSampleForTypeAnalyze)({
          fields: fieldOrder,
          rows: allData
        });
        var meta = (0, _utils.getFieldsFromData)(sampleData, fieldOrder);
        updatedFields = meta.map(function (f, i) {
          return _objectSpread(_objectSpread({}, (0, _lodash["default"])(meta[i], ['name', 'type', 'format'])), {}, {
            analyzerType: meta[i].analyzerType
          });
        });
        updatedFields.forEach(function (f, i) {
          if (fields[i].type !== f.type) {
            // if newly detected field type is different from saved type
            // we log it but won't update it, cause we don't want to break people's map
            _window.console.warn("detect ".concat(f.name, " type is now ").concat(f.type, " instead of ").concat(fields[i].type));
          }
        });
      } // get format of all fields


      return {
        data: {
          fields: updatedFields,
          rows: dataset.allData
        },
        info: (0, _lodash["default"])(dataset, ['id', 'label', 'color'])
      };
    }
  }]);
  return DatasetSchema;
}(_schema["default"]);

exports.DatasetSchema = DatasetSchema;
var datasetSchema = (_datasetSchema = {}, (0, _defineProperty2["default"])(_datasetSchema, _versions.VERSIONS.v0, new DatasetSchema({
  key: 'dataset',
  version: _versions.VERSIONS.v0,
  properties: propertiesV0
})), (0, _defineProperty2["default"])(_datasetSchema, _versions.VERSIONS.v1, new DatasetSchema({
  key: 'dataset',
  version: _versions.VERSIONS.v1,
  properties: propertiesV1
})), _datasetSchema);
exports.datasetSchema = datasetSchema;
var _default = datasetSchema;
exports["default"] = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9kYXRhc2V0LXNjaGVtYS50cyJdLCJuYW1lcyI6WyJmaWVsZFByb3BlcnRpZXNWMCIsIm5hbWUiLCJ0eXBlIiwiZmllbGRQcm9wZXJ0aWVzVjEiLCJmb3JtYXQiLCJhbmFseXplclR5cGUiLCJtZXRhZGF0YSIsIkZpZWxkU2NoZW1hIiwiZmllbGRzIiwia2V5IiwibWFwIiwiZiIsInNhdmVQcm9wZXJ0aWVzT3JBcHBseVNjaGVtYSIsIlNjaGVtYSIsInByb3BlcnRpZXNWMCIsImlkIiwibGFiZWwiLCJjb2xvciIsImFsbERhdGEiLCJ2ZXJzaW9uIiwiVkVSU0lPTlMiLCJ2MCIsInByb3BlcnRpZXMiLCJwcm9wZXJ0aWVzVjEiLCJ2MSIsIkRhdGFzZXRTY2hlbWEiLCJkYXRhc2V0IiwiZGF0YXNldEZsYXR0ZW5lZCIsImRhdGFDb250YWluZXIiLCJmbGF0dGVuRGF0YSIsInVwZGF0ZWRGaWVsZHMiLCJuZWVkQ2FsY3VsYXRlTWV0YSIsImhhc093blByb3BlcnR5IiwiZmllbGRPcmRlciIsInNhbXBsZURhdGEiLCJyb3dzIiwibWV0YSIsImkiLCJmb3JFYWNoIiwiZ2xvYmFsQ29uc29sZSIsIndhcm4iLCJkYXRhIiwiaW5mbyIsImRhdGFzZXRTY2hlbWEiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBb0JBOztBQUNBOztBQUlBOztBQUNBOztBQUNBOzs7Ozs7Ozs7Ozs7QUF1Q0E7QUFDTyxJQUFNQSxpQkFBaUIsR0FBRztBQUMvQkMsRUFBQUEsSUFBSSxFQUFFLElBRHlCO0FBRS9CQyxFQUFBQSxJQUFJLEVBQUU7QUFGeUIsQ0FBMUI7O0FBS0EsSUFBTUMsaUJBQWlCLEdBQUc7QUFDL0JGLEVBQUFBLElBQUksRUFBRSxJQUR5QjtBQUUvQkMsRUFBQUEsSUFBSSxFQUFFLElBRnlCO0FBRy9CRSxFQUFBQSxNQUFNLEVBQUUsSUFIdUI7QUFJL0JDLEVBQUFBLFlBQVksRUFBRSxJQUppQjtBQUsvQkMsRUFBQUEsUUFBUSxFQUFFO0FBTHFCLENBQTFCOzs7SUFRTUMsVzs7Ozs7Ozs7Ozs7O1dBQ1gsY0FBS0MsTUFBTCxFQUFhO0FBQUE7O0FBQ1gsa0RBQ0csS0FBS0MsR0FEUixFQUNjRCxNQUFNLENBQUNFLEdBQVAsQ0FBVyxVQUFBQyxDQUFDO0FBQUEsZUFBSSxLQUFJLENBQUNDLDJCQUFMLENBQWlDRCxDQUFqQyxFQUFvQyxLQUFJLENBQUNGLEdBQXpDLENBQUo7QUFBQSxPQUFaLENBRGQ7QUFHRDs7O1dBQ0QsY0FBS0QsTUFBTCxFQUFhO0FBQ1gsa0RBQVMsS0FBS0MsR0FBZCxFQUFvQkQsTUFBcEI7QUFDRDs7O0VBUjhCSyxrQjs7O0FBVzFCLElBQU1DLFlBQVksR0FBRztBQUMxQkMsRUFBQUEsRUFBRSxFQUFFLElBRHNCO0FBRTFCQyxFQUFBQSxLQUFLLEVBQUUsSUFGbUI7QUFHMUJDLEVBQUFBLEtBQUssRUFBRSxJQUhtQjtBQUkxQkMsRUFBQUEsT0FBTyxFQUFFLElBSmlCO0FBSzFCVixFQUFBQSxNQUFNLEVBQUUsSUFBSUQsV0FBSixDQUFnQjtBQUN0QkUsSUFBQUEsR0FBRyxFQUFFLFFBRGlCO0FBRXRCVSxJQUFBQSxPQUFPLEVBQUVDLG1CQUFTQyxFQUZJO0FBR3RCQyxJQUFBQSxVQUFVLEVBQUV0QjtBQUhVLEdBQWhCO0FBTGtCLENBQXJCOzs7QUFZQSxJQUFNdUIsWUFBWSxtQ0FDcEJULFlBRG9CO0FBRXZCTixFQUFBQSxNQUFNLEVBQUUsSUFBSUQsV0FBSixDQUFnQjtBQUN0QkUsSUFBQUEsR0FBRyxFQUFFLFFBRGlCO0FBRXRCVSxJQUFBQSxPQUFPLEVBQUVDLG1CQUFTSSxFQUZJO0FBR3RCRixJQUFBQSxVQUFVLEVBQUVuQjtBQUhVLEdBQWhCO0FBRmUsRUFBbEI7Ozs7SUFTTXNCLGE7Ozs7Ozs7Ozs7Ozs7Ozs2RkFDTCxTOzs7Ozs7V0FFTixjQUFLQyxPQUFMLEVBQW1EO0FBQ2pELFVBQU1DLGdCQUFnQixHQUFHRCxPQUFPLENBQUNFLGFBQVIsbUNBRWhCRixPQUZnQjtBQUduQlIsUUFBQUEsT0FBTyxFQUFFUSxPQUFPLENBQUNFLGFBQVIsQ0FBc0JDLFdBQXRCO0FBSFUsV0FLckJILE9BTEo7QUFPQSxhQUFPLEtBQUtkLDJCQUFMLENBQWlDZSxnQkFBakMsRUFBbUQsS0FBS2xCLEdBQXhELENBQVA7QUFDRDs7O1dBQ0QsY0FBS2lCLE9BQUwsRUFBb0Q7QUFBQSxVQUMzQ2xCLE1BRDJDLEdBQ3hCa0IsT0FEd0IsQ0FDM0NsQixNQUQyQztBQUFBLFVBQ25DVSxPQURtQyxHQUN4QlEsT0FEd0IsQ0FDbkNSLE9BRG1DO0FBRWxELFVBQUlZLGFBQWEsR0FBR3RCLE1BQXBCLENBRmtELENBSWxEO0FBQ0E7QUFDQTs7QUFDQSxVQUFNdUIsaUJBQWlCLEdBQ3JCdkIsTUFBTSxDQUFDLENBQUQsQ0FBTixLQUNDLENBQUNBLE1BQU0sQ0FBQyxDQUFELENBQU4sQ0FBVXdCLGNBQVYsQ0FBeUIsUUFBekIsQ0FBRCxJQUF1QyxDQUFDeEIsTUFBTSxDQUFDLENBQUQsQ0FBTixDQUFVd0IsY0FBVixDQUF5QixjQUF6QixDQUR6QyxDQURGOztBQUlBLFVBQUlELGlCQUFKLEVBQXVCO0FBQ3JCLFlBQU1FLFVBQVUsR0FBR3pCLE1BQU0sQ0FBQ0UsR0FBUCxDQUFXLFVBQUFDLENBQUM7QUFBQSxpQkFBSUEsQ0FBQyxDQUFDVixJQUFOO0FBQUEsU0FBWixDQUFuQjtBQUVBLFlBQU1pQyxVQUFVLEdBQUcsb0NBQXdCO0FBQ3pDMUIsVUFBQUEsTUFBTSxFQUFFeUIsVUFEaUM7QUFFekNFLFVBQUFBLElBQUksRUFBRWpCO0FBRm1DLFNBQXhCLENBQW5CO0FBSUEsWUFBTWtCLElBQUksR0FBRyw4QkFBa0JGLFVBQWxCLEVBQThCRCxVQUE5QixDQUFiO0FBRUFILFFBQUFBLGFBQWEsR0FBR00sSUFBSSxDQUFDMUIsR0FBTCxDQUFTLFVBQUNDLENBQUQsRUFBSTBCLENBQUo7QUFBQSxpREFDcEIsd0JBQUtELElBQUksQ0FBQ0MsQ0FBRCxDQUFULEVBQWMsQ0FBQyxNQUFELEVBQVMsTUFBVCxFQUFpQixRQUFqQixDQUFkLENBRG9CO0FBRXZCaEMsWUFBQUEsWUFBWSxFQUFFK0IsSUFBSSxDQUFDQyxDQUFELENBQUosQ0FBUWhDO0FBRkM7QUFBQSxTQUFULENBQWhCO0FBS0F5QixRQUFBQSxhQUFhLENBQUNRLE9BQWQsQ0FBc0IsVUFBQzNCLENBQUQsRUFBSTBCLENBQUosRUFBVTtBQUM5QixjQUFJN0IsTUFBTSxDQUFDNkIsQ0FBRCxDQUFOLENBQVVuQyxJQUFWLEtBQW1CUyxDQUFDLENBQUNULElBQXpCLEVBQStCO0FBQzdCO0FBQ0E7QUFDQXFDLDRCQUFjQyxJQUFkLGtCQUE2QjdCLENBQUMsQ0FBQ1YsSUFBL0IsMEJBQW1EVSxDQUFDLENBQUNULElBQXJELHlCQUF3RU0sTUFBTSxDQUFDNkIsQ0FBRCxDQUFOLENBQVVuQyxJQUFsRjtBQUNEO0FBQ0YsU0FORDtBQU9ELE9BaENpRCxDQWtDbEQ7OztBQUNBLGFBQU87QUFDTHVDLFFBQUFBLElBQUksRUFBRTtBQUFDakMsVUFBQUEsTUFBTSxFQUFFc0IsYUFBVDtBQUF3QkssVUFBQUEsSUFBSSxFQUFFVCxPQUFPLENBQUNSO0FBQXRDLFNBREQ7QUFFTHdCLFFBQUFBLElBQUksRUFBRSx3QkFBS2hCLE9BQUwsRUFBYyxDQUFDLElBQUQsRUFBTyxPQUFQLEVBQWdCLE9BQWhCLENBQWQ7QUFGRCxPQUFQO0FBSUQ7OztFQXBEZ0NiLGtCOzs7QUF1RDVCLElBQU04QixhQUFhLDBFQUN2QnZCLG1CQUFTQyxFQURjLEVBQ1QsSUFBSUksYUFBSixDQUFrQjtBQUMvQmhCLEVBQUFBLEdBQUcsRUFBRSxTQUQwQjtBQUUvQlUsRUFBQUEsT0FBTyxFQUFFQyxtQkFBU0MsRUFGYTtBQUcvQkMsRUFBQUEsVUFBVSxFQUFFUjtBQUhtQixDQUFsQixDQURTLG9EQU12Qk0sbUJBQVNJLEVBTmMsRUFNVCxJQUFJQyxhQUFKLENBQWtCO0FBQy9CaEIsRUFBQUEsR0FBRyxFQUFFLFNBRDBCO0FBRS9CVSxFQUFBQSxPQUFPLEVBQUVDLG1CQUFTSSxFQUZhO0FBRy9CRixFQUFBQSxVQUFVLEVBQUVDO0FBSG1CLENBQWxCLENBTlMsa0JBQW5COztlQWFRb0IsYSIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAyMiBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5cbmltcG9ydCBwaWNrIGZyb20gJ2xvZGFzaC5waWNrJztcbmltcG9ydCB7Y29uc29sZSBhcyBnbG9iYWxDb25zb2xlfSBmcm9tICdnbG9iYWwvd2luZG93JztcblxuaW1wb3J0IHtQcm90b0RhdGFzZXQsIFJHQkNvbG9yfSBmcm9tICdAa2VwbGVyLmdsL3R5cGVzJztcbmltcG9ydCB7S2VwbGVyVGFibGV9IGZyb20gJ0BrZXBsZXIuZ2wvdGFibGUnO1xuaW1wb3J0IHtWRVJTSU9OU30gZnJvbSAnLi92ZXJzaW9ucyc7XG5pbXBvcnQgU2NoZW1hIGZyb20gJy4vc2NoZW1hJztcbmltcG9ydCB7Z2V0RmllbGRzRnJvbURhdGEsIGdldFNhbXBsZUZvclR5cGVBbmFseXplfSBmcm9tICdAa2VwbGVyLmdsL3V0aWxzJztcblxuZXhwb3J0IHR5cGUgU2F2ZWRGaWVsZCA9IHtcbiAgbmFtZTogc3RyaW5nO1xuICB0eXBlOiBzdHJpbmc7XG4gIGZvcm1hdD86IHN0cmluZztcbiAgYW5hbHl6ZXJUeXBlPzogc3RyaW5nO1xufTtcblxuZXhwb3J0IHR5cGUgUGFyc2VkRmllbGQgPSB7XG4gIG5hbWU6IHN0cmluZztcbiAgdHlwZTogc3RyaW5nO1xuICBmb3JtYXQ6IHN0cmluZztcbiAgYW5hbHl6ZXJUeXBlOiBzdHJpbmc7XG59O1xuXG5leHBvcnQgdHlwZSBTYXZlZERhdGFzZXRWMSA9IHtcbiAgdmVyc2lvbjogJ3YxJztcbiAgZGF0YToge1xuICAgIGlkOiBzdHJpbmc7XG4gICAgbGFiZWw6IHN0cmluZztcbiAgICBjb2xvcjogUkdCQ29sb3I7XG4gICAgYWxsRGF0YTogYW55W11bXTtcbiAgICBmaWVsZHM6IFNhdmVkRmllbGRbXTtcbiAgfTtcbn07XG5cbmV4cG9ydCB0eXBlIFBhcnNlZERhdGFzZXQgPSB7XG4gIGRhdGE6IHtcbiAgICBmaWVsZHM6IFBhcnNlZEZpZWxkW107XG4gICAgcm93czogYW55W11bXTtcbiAgfTtcbiAgaW5mbzoge1xuICAgIGlkPzogc3RyaW5nO1xuICAgIGxhYmVsPzogc3RyaW5nO1xuICAgIGNvbG9yPzogUkdCQ29sb3I7XG4gIH07XG59O1xuXG4vLyB2ZXJzaW9uIHYwXG5leHBvcnQgY29uc3QgZmllbGRQcm9wZXJ0aWVzVjAgPSB7XG4gIG5hbWU6IG51bGwsXG4gIHR5cGU6IG51bGxcbn07XG5cbmV4cG9ydCBjb25zdCBmaWVsZFByb3BlcnRpZXNWMSA9IHtcbiAgbmFtZTogbnVsbCxcbiAgdHlwZTogbnVsbCxcbiAgZm9ybWF0OiBudWxsLFxuICBhbmFseXplclR5cGU6IG51bGwsXG4gIG1ldGFkYXRhOiBudWxsXG59O1xuXG5leHBvcnQgY2xhc3MgRmllbGRTY2hlbWEgZXh0ZW5kcyBTY2hlbWEge1xuICBzYXZlKGZpZWxkcykge1xuICAgIHJldHVybiB7XG4gICAgICBbdGhpcy5rZXldOiBmaWVsZHMubWFwKGYgPT4gdGhpcy5zYXZlUHJvcGVydGllc09yQXBwbHlTY2hlbWEoZilbdGhpcy5rZXldKVxuICAgIH07XG4gIH1cbiAgbG9hZChmaWVsZHMpIHtcbiAgICByZXR1cm4ge1t0aGlzLmtleV06IGZpZWxkc307XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHByb3BlcnRpZXNWMCA9IHtcbiAgaWQ6IG51bGwsXG4gIGxhYmVsOiBudWxsLFxuICBjb2xvcjogbnVsbCxcbiAgYWxsRGF0YTogbnVsbCxcbiAgZmllbGRzOiBuZXcgRmllbGRTY2hlbWEoe1xuICAgIGtleTogJ2ZpZWxkcycsXG4gICAgdmVyc2lvbjogVkVSU0lPTlMudjAsXG4gICAgcHJvcGVydGllczogZmllbGRQcm9wZXJ0aWVzVjBcbiAgfSlcbn07XG5cbmV4cG9ydCBjb25zdCBwcm9wZXJ0aWVzVjEgPSB7XG4gIC4uLnByb3BlcnRpZXNWMCxcbiAgZmllbGRzOiBuZXcgRmllbGRTY2hlbWEoe1xuICAgIGtleTogJ2ZpZWxkcycsXG4gICAgdmVyc2lvbjogVkVSU0lPTlMudjEsXG4gICAgcHJvcGVydGllczogZmllbGRQcm9wZXJ0aWVzVjFcbiAgfSlcbn07XG5cbmV4cG9ydCBjbGFzcyBEYXRhc2V0U2NoZW1hIGV4dGVuZHMgU2NoZW1hIHtcbiAga2V5ID0gJ2RhdGFzZXQnO1xuXG4gIHNhdmUoZGF0YXNldDogS2VwbGVyVGFibGUpOiBTYXZlZERhdGFzZXRWMVsnZGF0YSddIHtcbiAgICBjb25zdCBkYXRhc2V0RmxhdHRlbmVkID0gZGF0YXNldC5kYXRhQ29udGFpbmVyXG4gICAgICA/IHtcbiAgICAgICAgICAuLi5kYXRhc2V0LFxuICAgICAgICAgIGFsbERhdGE6IGRhdGFzZXQuZGF0YUNvbnRhaW5lci5mbGF0dGVuRGF0YSgpXG4gICAgICAgIH1cbiAgICAgIDogZGF0YXNldDtcblxuICAgIHJldHVybiB0aGlzLnNhdmVQcm9wZXJ0aWVzT3JBcHBseVNjaGVtYShkYXRhc2V0RmxhdHRlbmVkKVt0aGlzLmtleV07XG4gIH1cbiAgbG9hZChkYXRhc2V0OiBTYXZlZERhdGFzZXRWMVsnZGF0YSddKTogUHJvdG9EYXRhc2V0IHtcbiAgICBjb25zdCB7ZmllbGRzLCBhbGxEYXRhfSA9IGRhdGFzZXQ7XG4gICAgbGV0IHVwZGF0ZWRGaWVsZHMgPSBmaWVsZHM7XG5cbiAgICAvLyByZWNhbGN1bGF0ZSBmaWVsZCB0eXBlXG4gICAgLy8gYmVjYXVzZSB3ZSBoYXZlIHVwZGF0ZWQgdHlwZS1hbmFseXplclxuICAgIC8vIHdlIG5lZWQgdG8gYWRkIGZvcm1hdCB0byBlYWNoIGZpZWxkXG4gICAgY29uc3QgbmVlZENhbGN1bGF0ZU1ldGEgPVxuICAgICAgZmllbGRzWzBdICYmXG4gICAgICAoIWZpZWxkc1swXS5oYXNPd25Qcm9wZXJ0eSgnZm9ybWF0JykgfHwgIWZpZWxkc1swXS5oYXNPd25Qcm9wZXJ0eSgnYW5hbHl6ZXJUeXBlJykpO1xuXG4gICAgaWYgKG5lZWRDYWxjdWxhdGVNZXRhKSB7XG4gICAgICBjb25zdCBmaWVsZE9yZGVyID0gZmllbGRzLm1hcChmID0+IGYubmFtZSk7XG5cbiAgICAgIGNvbnN0IHNhbXBsZURhdGEgPSBnZXRTYW1wbGVGb3JUeXBlQW5hbHl6ZSh7XG4gICAgICAgIGZpZWxkczogZmllbGRPcmRlcixcbiAgICAgICAgcm93czogYWxsRGF0YVxuICAgICAgfSk7XG4gICAgICBjb25zdCBtZXRhID0gZ2V0RmllbGRzRnJvbURhdGEoc2FtcGxlRGF0YSwgZmllbGRPcmRlcik7XG5cbiAgICAgIHVwZGF0ZWRGaWVsZHMgPSBtZXRhLm1hcCgoZiwgaSkgPT4gKHtcbiAgICAgICAgLi4ucGljayhtZXRhW2ldLCBbJ25hbWUnLCAndHlwZScsICdmb3JtYXQnXSksXG4gICAgICAgIGFuYWx5emVyVHlwZTogbWV0YVtpXS5hbmFseXplclR5cGVcbiAgICAgIH0pKTtcblxuICAgICAgdXBkYXRlZEZpZWxkcy5mb3JFYWNoKChmLCBpKSA9PiB7XG4gICAgICAgIGlmIChmaWVsZHNbaV0udHlwZSAhPT0gZi50eXBlKSB7XG4gICAgICAgICAgLy8gaWYgbmV3bHkgZGV0ZWN0ZWQgZmllbGQgdHlwZSBpcyBkaWZmZXJlbnQgZnJvbSBzYXZlZCB0eXBlXG4gICAgICAgICAgLy8gd2UgbG9nIGl0IGJ1dCB3b24ndCB1cGRhdGUgaXQsIGNhdXNlIHdlIGRvbid0IHdhbnQgdG8gYnJlYWsgcGVvcGxlJ3MgbWFwXG4gICAgICAgICAgZ2xvYmFsQ29uc29sZS53YXJuKGBkZXRlY3QgJHtmLm5hbWV9IHR5cGUgaXMgbm93ICR7Zi50eXBlfSBpbnN0ZWFkIG9mICR7ZmllbGRzW2ldLnR5cGV9YCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIGdldCBmb3JtYXQgb2YgYWxsIGZpZWxkc1xuICAgIHJldHVybiB7XG4gICAgICBkYXRhOiB7ZmllbGRzOiB1cGRhdGVkRmllbGRzLCByb3dzOiBkYXRhc2V0LmFsbERhdGF9LFxuICAgICAgaW5mbzogcGljayhkYXRhc2V0LCBbJ2lkJywgJ2xhYmVsJywgJ2NvbG9yJ10pXG4gICAgfTtcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgZGF0YXNldFNjaGVtYSA9IHtcbiAgW1ZFUlNJT05TLnYwXTogbmV3IERhdGFzZXRTY2hlbWEoe1xuICAgIGtleTogJ2RhdGFzZXQnLFxuICAgIHZlcnNpb246IFZFUlNJT05TLnYwLFxuICAgIHByb3BlcnRpZXM6IHByb3BlcnRpZXNWMFxuICB9KSxcbiAgW1ZFUlNJT05TLnYxXTogbmV3IERhdGFzZXRTY2hlbWEoe1xuICAgIGtleTogJ2RhdGFzZXQnLFxuICAgIHZlcnNpb246IFZFUlNJT05TLnYxLFxuICAgIHByb3BlcnRpZXM6IHByb3BlcnRpZXNWMVxuICB9KVxufTtcblxuZXhwb3J0IGRlZmF1bHQgZGF0YXNldFNjaGVtYTtcbiJdfQ==