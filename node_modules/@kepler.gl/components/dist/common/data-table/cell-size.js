// Copyright (c) 2022 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.renderedSize = renderedSize;
exports.adjustCellsToContainer = adjustCellsToContainer;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _document = _interopRequireDefault(require("global/document"));

var _utils = require("@kepler.gl/utils");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var MIN_GHOST_CELL_SIZE = 200;
var MIN_CELL_SIZE = 45;

/**
 * Measure rows and column content to determine min width for each column
 * @param {RenderSizeParam} param0
 */
function renderedSize(_ref) {
  var _ref$text = _ref.text,
      dataContainer = _ref$text.dataContainer,
      column = _ref$text.column,
      _ref$type = _ref.type,
      type = _ref$type === void 0 ? 'string' : _ref$type,
      colIdx = _ref.colIdx,
      _ref$numRowsToCalcula = _ref.numRowsToCalculate,
      numRowsToCalculate = _ref$numRowsToCalcula === void 0 ? 10 : _ref$numRowsToCalcula,
      _ref$fontSize = _ref.fontSize,
      fontSize = _ref$fontSize === void 0 ? 12 : _ref$fontSize,
      _ref$font = _ref.font,
      font = _ref$font === void 0 ? 'Lato' : _ref$font,
      _ref$cellPadding = _ref.cellPadding,
      cellPadding = _ref$cellPadding === void 0 ? 40 : _ref$cellPadding,
      _ref$maxCellSize = _ref.maxCellSize,
      maxCellSize = _ref$maxCellSize === void 0 ? 500 : _ref$maxCellSize,
      _ref$maxHeaderSize = _ref.maxHeaderSize,
      maxHeaderSize = _ref$maxHeaderSize === void 0 ? 500 : _ref$maxHeaderSize,
      _ref$minCellSize = _ref.minCellSize,
      minCellSize = _ref$minCellSize === void 0 ? MIN_CELL_SIZE : _ref$minCellSize,
      _ref$optionsButton = _ref.optionsButton,
      optionsButton = _ref$optionsButton === void 0 ? 30 : _ref$optionsButton;

  if (!_document["default"]) {
    return {
      row: 0,
      header: 0
    };
  }

  var textCanvas = _document["default"].createElement('canvas');

  _document["default"].body.appendChild(textCanvas);

  var context = textCanvas.getContext('2d');
  context.font = [fontSize, font].join('px ');
  var rowsToSample = (0, _toConsumableArray2["default"])(Array(numRowsToCalculate)).map(function () {
    return Math.floor(Math.random() * (dataContainer.numRows() - 1));
  }); // If we have less than 10 rows, lets measure all of them

  if (dataContainer.numRows() <= numRowsToCalculate) {
    rowsToSample = Array.from(Array(dataContainer.numRows()).keys());
  }

  var rowWidth = Math.max.apply(Math, (0, _toConsumableArray2["default"])(rowsToSample.map(function (rowIdx) {
    return Math.ceil(context.measureText((0, _utils.parseFieldValue)(dataContainer.valueAt(rowIdx, colIdx), type)).width) + cellPadding;
  }))); // header cell only has left padding

  var headerWidth = Math.ceil(context.measureText(column).width) + cellPadding / 2 + optionsButton;
  var minRowWidth = minCellSize + cellPadding;
  var minHeaderWidth = minCellSize + cellPadding / 2 + optionsButton;
  var clampedRowWidth = clamp(minRowWidth, maxCellSize, rowWidth);
  var clampedHeaderWidth = clamp(minHeaderWidth, maxHeaderSize, headerWidth); // cleanup

  textCanvas.parentElement.removeChild(textCanvas);
  return {
    row: clampedRowWidth,
    header: clampedHeaderWidth
  };
}

function clamp(min, max, value) {
  return Math.max(Math.min(max, value), min);
}

function getColumnOrder() {
  var pinnedColumns = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var unpinnedColumns = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  return [].concat((0, _toConsumableArray2["default"])(pinnedColumns), (0, _toConsumableArray2["default"])(unpinnedColumns));
}

function getMinCellSize(cellSizeCache) {
  return Object.keys(cellSizeCache).reduce(function (accu, col) {
    return _objectSpread(_objectSpread({}, accu), {}, (0, _defineProperty2["default"])({}, col, cellSizeCache[col].row));
  }, {});
}

function getSizeSum(sizeCache, key) {
  return Object.keys(sizeCache).reduce(function (acc, val) {
    return acc + (key ? sizeCache[val][key] : sizeCache[val]);
  }, 0);
}
/**
 * Expand cell to fit both row and header, if there is still room left,
 * expand last cell to fit the entire width of the container
 * @param {CellSizeCache} cellSizeCache
 * @param {string[]} columnOrder
 * @param {number} containerWidth
 * @param {number} roomToFill
 */


function expandCellSize(cellSizeCache, columnOrder, containerWidth, roomToFill) {
  var remaining = roomToFill;
  var expandedCellSize = columnOrder.reduce(function (accu, col) {
    var size = cellSizeCache[col].row;

    if (cellSizeCache[col].row < cellSizeCache[col].header && remaining > 0) {
      // if we are cutting off the header, expand to fit it
      size = cellSizeCache[col].header - cellSizeCache[col].row < remaining ? cellSizeCache[col].header : cellSizeCache[col].row + remaining;
      remaining -= size - cellSizeCache[col].row;
    }

    return _objectSpread(_objectSpread({}, accu), {}, (0, _defineProperty2["default"])({}, col, size));
  }, {});
  var ghost = null;

  if (remaining > 0 && remaining < MIN_GHOST_CELL_SIZE) {
    // expand last cell
    var lastCell = columnOrder[columnOrder.length - 1];
    expandedCellSize[lastCell] += remaining;
  } else if (remaining >= MIN_GHOST_CELL_SIZE) {
    // if too much left add a ghost cell
    ghost = remaining;
  }

  return {
    cellSizeCache: expandedCellSize,
    ghost: ghost
  };
}
/**
 * Adjust cell size based on container width
 * @param {number} containerWidth
 * @param {CellSizeCache} cellSizeCache
 * @param {string[]} pinnedColumns
 * @param {string[]} unpinnedColumns
 */


function adjustCellsToContainer(containerWidth, cellSizeCache, pinnedColumns, unpinnedColumns) {
  var minRowSum = getSizeSum(cellSizeCache, 'row');

  if (minRowSum >= containerWidth) {
    // we apply the min Width to all cells
    return {
      cellSizeCache: getMinCellSize(cellSizeCache)
    };
  } // if we have some room to expand


  var columnOrder = getColumnOrder(pinnedColumns, unpinnedColumns);
  return expandCellSize(cellSizeCache, columnOrder, containerWidth, containerWidth - minRowSum);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb21tb24vZGF0YS10YWJsZS9jZWxsLXNpemUudHMiXSwibmFtZXMiOlsiTUlOX0dIT1NUX0NFTExfU0laRSIsIk1JTl9DRUxMX1NJWkUiLCJyZW5kZXJlZFNpemUiLCJ0ZXh0IiwiZGF0YUNvbnRhaW5lciIsImNvbHVtbiIsInR5cGUiLCJjb2xJZHgiLCJudW1Sb3dzVG9DYWxjdWxhdGUiLCJmb250U2l6ZSIsImZvbnQiLCJjZWxsUGFkZGluZyIsIm1heENlbGxTaXplIiwibWF4SGVhZGVyU2l6ZSIsIm1pbkNlbGxTaXplIiwib3B0aW9uc0J1dHRvbiIsImRvY3VtZW50Iiwicm93IiwiaGVhZGVyIiwidGV4dENhbnZhcyIsImNyZWF0ZUVsZW1lbnQiLCJib2R5IiwiYXBwZW5kQ2hpbGQiLCJjb250ZXh0IiwiZ2V0Q29udGV4dCIsImpvaW4iLCJyb3dzVG9TYW1wbGUiLCJBcnJheSIsIm1hcCIsIk1hdGgiLCJmbG9vciIsInJhbmRvbSIsIm51bVJvd3MiLCJmcm9tIiwia2V5cyIsInJvd1dpZHRoIiwibWF4Iiwicm93SWR4IiwiY2VpbCIsIm1lYXN1cmVUZXh0IiwidmFsdWVBdCIsIndpZHRoIiwiaGVhZGVyV2lkdGgiLCJtaW5Sb3dXaWR0aCIsIm1pbkhlYWRlcldpZHRoIiwiY2xhbXBlZFJvd1dpZHRoIiwiY2xhbXAiLCJjbGFtcGVkSGVhZGVyV2lkdGgiLCJwYXJlbnRFbGVtZW50IiwicmVtb3ZlQ2hpbGQiLCJtaW4iLCJ2YWx1ZSIsImdldENvbHVtbk9yZGVyIiwicGlubmVkQ29sdW1ucyIsInVucGlubmVkQ29sdW1ucyIsImdldE1pbkNlbGxTaXplIiwiY2VsbFNpemVDYWNoZSIsIk9iamVjdCIsInJlZHVjZSIsImFjY3UiLCJjb2wiLCJnZXRTaXplU3VtIiwic2l6ZUNhY2hlIiwia2V5IiwiYWNjIiwidmFsIiwiZXhwYW5kQ2VsbFNpemUiLCJjb2x1bW5PcmRlciIsImNvbnRhaW5lcldpZHRoIiwicm9vbVRvRmlsbCIsInJlbWFpbmluZyIsImV4cGFuZGVkQ2VsbFNpemUiLCJzaXplIiwiZ2hvc3QiLCJsYXN0Q2VsbCIsImxlbmd0aCIsImFkanVzdENlbGxzVG9Db250YWluZXIiLCJtaW5Sb3dTdW0iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBb0JBOztBQUNBOzs7Ozs7QUFFQSxJQUFNQSxtQkFBMkIsR0FBRyxHQUFwQztBQUNBLElBQU1DLGFBQWEsR0FBRyxFQUF0Qjs7QUF1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDTyxTQUFTQyxZQUFULE9BWTRDO0FBQUEsdUJBWGpEQyxJQVdpRDtBQUFBLE1BWDFDQyxhQVcwQyxhQVgxQ0EsYUFXMEM7QUFBQSxNQVgzQkMsTUFXMkIsYUFYM0JBLE1BVzJCO0FBQUEsdUJBVmpEQyxJQVVpRDtBQUFBLE1BVmpEQSxJQVVpRCwwQkFWMUMsUUFVMEM7QUFBQSxNQVRqREMsTUFTaUQsUUFUakRBLE1BU2lEO0FBQUEsbUNBUmpEQyxrQkFRaUQ7QUFBQSxNQVJqREEsa0JBUWlELHNDQVI1QixFQVE0QjtBQUFBLDJCQVBqREMsUUFPaUQ7QUFBQSxNQVBqREEsUUFPaUQsOEJBUHRDLEVBT3NDO0FBQUEsdUJBTmpEQyxJQU1pRDtBQUFBLE1BTmpEQSxJQU1pRCwwQkFOMUMsTUFNMEM7QUFBQSw4QkFMakRDLFdBS2lEO0FBQUEsTUFMakRBLFdBS2lELGlDQUxuQyxFQUttQztBQUFBLDhCQUpqREMsV0FJaUQ7QUFBQSxNQUpqREEsV0FJaUQsaUNBSm5DLEdBSW1DO0FBQUEsZ0NBSGpEQyxhQUdpRDtBQUFBLE1BSGpEQSxhQUdpRCxtQ0FIakMsR0FHaUM7QUFBQSw4QkFGakRDLFdBRWlEO0FBQUEsTUFGakRBLFdBRWlELGlDQUZuQ2IsYUFFbUM7QUFBQSxnQ0FEakRjLGFBQ2lEO0FBQUEsTUFEakRBLGFBQ2lELG1DQURqQyxFQUNpQzs7QUFDakQsTUFBSSxDQUFDQyxvQkFBTCxFQUFlO0FBQ2IsV0FBTztBQUNMQyxNQUFBQSxHQUFHLEVBQUUsQ0FEQTtBQUVMQyxNQUFBQSxNQUFNLEVBQUU7QUFG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OztBQUNBLE1BQU1XLFdBQVcsR0FBR2YsY0FBYyxDQUFDQyxhQUFELEVBQWdCQyxlQUFoQixDQUFsQztBQUNBLFNBQU9ZLGNBQWMsQ0FBQ1YsYUFBRCxFQUFnQlcsV0FBaEIsRUFBNkJDLGNBQTdCLEVBQTZDQSxjQUFjLEdBQUdTLFNBQTlELENBQXJCO0FBQ0QiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMjIgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5pbXBvcnQgZG9jdW1lbnQgZnJvbSAnZ2xvYmFsL2RvY3VtZW50JztcbmltcG9ydCB7RGF0YUNvbnRhaW5lckludGVyZmFjZSwgcGFyc2VGaWVsZFZhbHVlfSBmcm9tICdAa2VwbGVyLmdsL3V0aWxzJztcblxuY29uc3QgTUlOX0dIT1NUX0NFTExfU0laRTogbnVtYmVyID0gMjAwO1xuY29uc3QgTUlOX0NFTExfU0laRSA9IDQ1O1xuXG50eXBlIFJlbmRlclNpemVQYXJhbSA9IHtcbiAgdGV4dDoge2RhdGFDb250YWluZXI6IERhdGFDb250YWluZXJJbnRlcmZhY2U7IGNvbHVtbjogc3RyaW5nfTtcbiAgdHlwZT86IHN0cmluZztcbiAgY29sSWR4OiBudW1iZXI7XG4gIG51bVJvd3NUb0NhbGN1bGF0ZT86IG51bWJlcjtcbiAgZm9udFNpemU/OiBudW1iZXI7XG4gIGZvbnQ/OiBzdHJpbmc7XG4gIGNlbGxQYWRkaW5nPzogbnVtYmVyO1xuICBtYXhDZWxsU2l6ZT86IG51bWJlcjtcbiAgbWF4SGVhZGVyU2l6ZT86IG51bWJlcjtcbiAgbWluQ2VsbFNpemU/OiBudW1iZXI7XG4gIG9wdGlvbnNCdXR0b24/OiBudW1iZXI7XG59O1xuXG5leHBvcnQgdHlwZSBDZWxsU2l6ZUNhY2hlID0ge1xuICBba2V5OiBzdHJpbmddOiB7XG4gICAgcm93OiBudW1iZXI7XG4gICAgaGVhZGVyOiBudW1iZXI7XG4gIH07XG59O1xuXG4vKipcbiAqIE1lYXN1cmUgcm93cyBhbmQgY29sdW1uIGNvbnRlbnQgdG8gZGV0ZXJtaW5lIG1pbiB3aWR0aCBmb3IgZWFjaCBjb2x1bW5cbiAqIEBwYXJhbSB7UmVuZGVyU2l6ZVBhcmFtfSBwYXJhbTBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbmRlcmVkU2l6ZSh7XG4gIHRleHQ6IHtkYXRhQ29udGFpbmVyLCBjb2x1bW59LFxuICB0eXBlID0gJ3N0cmluZycsXG4gIGNvbElkeCxcbiAgbnVtUm93c1RvQ2FsY3VsYXRlID0gMTAsXG4gIGZvbnRTaXplID0gMTIsXG4gIGZvbnQgPSAnTGF0bycsXG4gIGNlbGxQYWRkaW5nID0gNDAsXG4gIG1heENlbGxTaXplID0gNTAwLFxuICBtYXhIZWFkZXJTaXplID0gNTAwLFxuICBtaW5DZWxsU2l6ZSA9IE1JTl9DRUxMX1NJWkUsXG4gIG9wdGlvbnNCdXR0b24gPSAzMFxufTogUmVuZGVyU2l6ZVBhcmFtKToge3JvdzogbnVtYmVyOyBoZWFkZXI6IG51bWJlcn0ge1xuICBpZiAoIWRvY3VtZW50KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJvdzogMCxcbiAgICAgIGhlYWRlcjogMFxuICAgIH07XG4gIH1cbiAgY29uc3QgdGV4dENhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRleHRDYW52YXMpO1xuICBjb25zdCBjb250ZXh0ID0gdGV4dENhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICBjb250ZXh0LmZvbnQgPSBbZm9udFNpemUsIGZvbnRdLmpvaW4oJ3B4ICcpO1xuXG4gIGxldCByb3dzVG9TYW1wbGUgPSBbLi4uQXJyYXkobnVtUm93c1RvQ2FsY3VsYXRlKV0ubWFwKCgpID0+XG4gICAgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKGRhdGFDb250YWluZXIubnVtUm93cygpIC0gMSkpXG4gICk7XG5cbiAgLy8gSWYgd2UgaGF2ZSBsZXNzIHRoYW4gMTAgcm93cywgbGV0cyBtZWFzdXJlIGFsbCBvZiB0aGVtXG4gIGlmIChkYXRhQ29udGFpbmVyLm51bVJvd3MoKSA8PSBudW1Sb3dzVG9DYWxjdWxhdGUpIHtcbiAgICByb3dzVG9TYW1wbGUgPSBBcnJheS5mcm9tKEFycmF5KGRhdGFDb250YWluZXIubnVtUm93cygpKS5rZXlzKCkpO1xuICB9XG4gIGNvbnN0IHJvd1dpZHRoID0gTWF0aC5tYXgoXG4gICAgLi4ucm93c1RvU2FtcGxlLm1hcChcbiAgICAgIHJvd0lkeCA9PlxuICAgICAgICBNYXRoLmNlaWwoXG4gICAgICAgICAgY29udGV4dC5tZWFzdXJlVGV4dChwYXJzZUZpZWxkVmFsdWUoZGF0YUNvbnRhaW5lci52YWx1ZUF0KHJvd0lkeCwgY29sSWR4KSwgdHlwZSkpLndpZHRoXG4gICAgICAgICkgKyBjZWxsUGFkZGluZ1xuICAgIClcbiAgKTtcbiAgLy8gaGVhZGVyIGNlbGwgb25seSBoYXMgbGVmdCBwYWRkaW5nXG4gIGNvbnN0IGhlYWRlcldpZHRoID1cbiAgICBNYXRoLmNlaWwoY29udGV4dC5tZWFzdXJlVGV4dChjb2x1bW4pLndpZHRoKSArIGNlbGxQYWRkaW5nIC8gMiArIG9wdGlvbnNCdXR0b247XG5cbiAgY29uc3QgbWluUm93V2lkdGggPSBtaW5DZWxsU2l6ZSArIGNlbGxQYWRkaW5nO1xuICBjb25zdCBtaW5IZWFkZXJXaWR0aCA9IG1pbkNlbGxTaXplICsgY2VsbFBhZGRpbmcgLyAyICsgb3B0aW9uc0J1dHRvbjtcblxuICBjb25zdCBjbGFtcGVkUm93V2lkdGggPSBjbGFtcChtaW5Sb3dXaWR0aCwgbWF4Q2VsbFNpemUsIHJvd1dpZHRoKTtcbiAgY29uc3QgY2xhbXBlZEhlYWRlcldpZHRoID0gY2xhbXAobWluSGVhZGVyV2lkdGgsIG1heEhlYWRlclNpemUsIGhlYWRlcldpZHRoKTtcblxuICAvLyBjbGVhbnVwXG4gIHRleHRDYW52YXMucGFyZW50RWxlbWVudC5yZW1vdmVDaGlsZCh0ZXh0Q2FudmFzKTtcblxuICByZXR1cm4ge1xuICAgIHJvdzogY2xhbXBlZFJvd1dpZHRoLFxuICAgIGhlYWRlcjogY2xhbXBlZEhlYWRlcldpZHRoXG4gIH07XG59XG5cbmZ1bmN0aW9uIGNsYW1wKG1pbiwgbWF4LCB2YWx1ZSkge1xuICByZXR1cm4gTWF0aC5tYXgoTWF0aC5taW4obWF4LCB2YWx1ZSksIG1pbik7XG59XG5cbmZ1bmN0aW9uIGdldENvbHVtbk9yZGVyKHBpbm5lZENvbHVtbnM6IHN0cmluZ1tdID0gW10sIHVucGlubmVkQ29sdW1uczogc3RyaW5nW10gPSBbXSkge1xuICByZXR1cm4gWy4uLnBpbm5lZENvbHVtbnMsIC4uLnVucGlubmVkQ29sdW1uc107XG59XG5cbmZ1bmN0aW9uIGdldE1pbkNlbGxTaXplKGNlbGxTaXplQ2FjaGU6IENlbGxTaXplQ2FjaGUpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKGNlbGxTaXplQ2FjaGUpLnJlZHVjZShcbiAgICAoYWNjdSwgY29sKSA9PiAoe1xuICAgICAgLi4uYWNjdSxcbiAgICAgIFtjb2xdOiBjZWxsU2l6ZUNhY2hlW2NvbF0ucm93XG4gICAgfSksXG4gICAge31cbiAgKTtcbn1cblxuZnVuY3Rpb24gZ2V0U2l6ZVN1bShzaXplQ2FjaGUsIGtleSkge1xuICByZXR1cm4gT2JqZWN0LmtleXMoc2l6ZUNhY2hlKS5yZWR1Y2UoXG4gICAgKGFjYywgdmFsKSA9PiBhY2MgKyAoa2V5ID8gc2l6ZUNhY2hlW3ZhbF1ba2V5XSA6IHNpemVDYWNoZVt2YWxdKSxcbiAgICAwXG4gICk7XG59XG5cbi8qKlxuICogRXhwYW5kIGNlbGwgdG8gZml0IGJvdGggcm93IGFuZCBoZWFkZXIsIGlmIHRoZXJlIGlzIHN0aWxsIHJvb20gbGVmdCxcbiAqIGV4cGFuZCBsYXN0IGNlbGwgdG8gZml0IHRoZSBlbnRpcmUgd2lkdGggb2YgdGhlIGNvbnRhaW5lclxuICogQHBhcmFtIHtDZWxsU2l6ZUNhY2hlfSBjZWxsU2l6ZUNhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBjb2x1bW5PcmRlclxuICogQHBhcmFtIHtudW1iZXJ9IGNvbnRhaW5lcldpZHRoXG4gKiBAcGFyYW0ge251bWJlcn0gcm9vbVRvRmlsbFxuICovXG5mdW5jdGlvbiBleHBhbmRDZWxsU2l6ZShcbiAgY2VsbFNpemVDYWNoZTogQ2VsbFNpemVDYWNoZSxcbiAgY29sdW1uT3JkZXI6IHN0cmluZ1tdLFxuICBjb250YWluZXJXaWR0aDogbnVtYmVyLFxuICByb29tVG9GaWxsOiBudW1iZXJcbik6IHtcbiAgY2VsbFNpemVDYWNoZTogQ2VsbFNpemVDYWNoZTtcbiAgZ2hvc3Q6IG51bWJlciB8IG51bGw7XG59IHtcbiAgbGV0IHJlbWFpbmluZyA9IHJvb21Ub0ZpbGw7XG5cbiAgY29uc3QgZXhwYW5kZWRDZWxsU2l6ZSA9IGNvbHVtbk9yZGVyLnJlZHVjZSgoYWNjdSwgY29sKSA9PiB7XG4gICAgbGV0IHNpemUgPSBjZWxsU2l6ZUNhY2hlW2NvbF0ucm93O1xuICAgIGlmIChjZWxsU2l6ZUNhY2hlW2NvbF0ucm93IDwgY2VsbFNpemVDYWNoZVtjb2xdLmhlYWRlciAmJiByZW1haW5pbmcgPiAwKSB7XG4gICAgICAvLyBpZiB3ZSBhcmUgY3V0dGluZyBvZmYgdGhlIGhlYWRlciwgZXhwYW5kIHRvIGZpdCBpdFxuICAgICAgc2l6ZSA9XG4gICAgICAgIGNlbGxTaXplQ2FjaGVbY29sXS5oZWFkZXIgLSBjZWxsU2l6ZUNhY2hlW2NvbF0ucm93IDwgcmVtYWluaW5nXG4gICAgICAgICAgPyBjZWxsU2l6ZUNhY2hlW2NvbF0uaGVhZGVyXG4gICAgICAgICAgOiBjZWxsU2l6ZUNhY2hlW2NvbF0ucm93ICsgcmVtYWluaW5nO1xuICAgICAgcmVtYWluaW5nIC09IHNpemUgLSBjZWxsU2l6ZUNhY2hlW2NvbF0ucm93O1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAuLi5hY2N1LFxuICAgICAgW2NvbF06IHNpemVcbiAgICB9O1xuICB9LCB7fSk7XG5cbiAgbGV0IGdob3N0OiBudW1iZXIgfCBudWxsID0gbnVsbDtcbiAgaWYgKHJlbWFpbmluZyA+IDAgJiYgcmVtYWluaW5nIDwgTUlOX0dIT1NUX0NFTExfU0laRSkge1xuICAgIC8vIGV4cGFuZCBsYXN0IGNlbGxcbiAgICBjb25zdCBsYXN0Q2VsbCA9IGNvbHVtbk9yZGVyW2NvbHVtbk9yZGVyLmxlbmd0aCAtIDFdO1xuICAgIGV4cGFuZGVkQ2VsbFNpemVbbGFzdENlbGxdICs9IHJlbWFpbmluZztcbiAgfSBlbHNlIGlmIChyZW1haW5pbmcgPj0gTUlOX0dIT1NUX0NFTExfU0laRSkge1xuICAgIC8vIGlmIHRvbyBtdWNoIGxlZnQgYWRkIGEgZ2hvc3QgY2VsbFxuICAgIGdob3N0ID0gcmVtYWluaW5nO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBjZWxsU2l6ZUNhY2hlOiBleHBhbmRlZENlbGxTaXplLFxuICAgIGdob3N0XG4gIH07XG59XG5cbi8qKlxuICogQWRqdXN0IGNlbGwgc2l6ZSBiYXNlZCBvbiBjb250YWluZXIgd2lkdGhcbiAqIEBwYXJhbSB7bnVtYmVyfSBjb250YWluZXJXaWR0aFxuICogQHBhcmFtIHtDZWxsU2l6ZUNhY2hlfSBjZWxsU2l6ZUNhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBwaW5uZWRDb2x1bW5zXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSB1bnBpbm5lZENvbHVtbnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkanVzdENlbGxzVG9Db250YWluZXIoXG4gIGNvbnRhaW5lcldpZHRoOiBudW1iZXIsXG4gIGNlbGxTaXplQ2FjaGU6IENlbGxTaXplQ2FjaGUsXG4gIHBpbm5lZENvbHVtbnM6IHN0cmluZ1tdLFxuICB1bnBpbm5lZENvbHVtbnM6IHN0cmluZ1tdXG4pOiB7XG4gIGNlbGxTaXplQ2FjaGU6IENlbGxTaXplQ2FjaGU7XG4gIGdob3N0PzogbnVtYmVyIHwgbnVsbDtcbn0ge1xuICBjb25zdCBtaW5Sb3dTdW0gPSBnZXRTaXplU3VtKGNlbGxTaXplQ2FjaGUsICdyb3cnKTtcbiAgaWYgKG1pblJvd1N1bSA+PSBjb250YWluZXJXaWR0aCkge1xuICAgIC8vIHdlIGFwcGx5IHRoZSBtaW4gV2lkdGggdG8gYWxsIGNlbGxzXG4gICAgcmV0dXJuIHtjZWxsU2l6ZUNhY2hlOiBnZXRNaW5DZWxsU2l6ZShjZWxsU2l6ZUNhY2hlKX07XG4gIH1cblxuICAvLyBpZiB3ZSBoYXZlIHNvbWUgcm9vbSB0byBleHBhbmRcbiAgY29uc3QgY29sdW1uT3JkZXIgPSBnZXRDb2x1bW5PcmRlcihwaW5uZWRDb2x1bW5zLCB1bnBpbm5lZENvbHVtbnMpO1xuICByZXR1cm4gZXhwYW5kQ2VsbFNpemUoY2VsbFNpemVDYWNoZSwgY29sdW1uT3JkZXIsIGNvbnRhaW5lcldpZHRoLCBjb250YWluZXJXaWR0aCAtIG1pblJvd1N1bSk7XG59XG4iXX0=