// Copyright (c) 2022 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _react = require("react");

var _d3Array = require("d3-array");

var _window = require("global/window");

var _console = _interopRequireDefault(require("global/console"));

var _constants = require("@kepler.gl/constants");

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var AnimationControllerType = /*#__PURE__*/function (_Component) {
  (0, _inherits2["default"])(AnimationControllerType, _Component);

  var _super = _createSuper(AnimationControllerType);

  function AnimationControllerType() {
    (0, _classCallCheck2["default"])(this, AnimationControllerType);
    return _super.apply(this, arguments);
  }

  return AnimationControllerType;
}(_react.Component);

function AnimationControllerFactory() {
  /**
   * 4 Animation Window Types
   * 1. free
   *  |->  |->
   * Current time is a fixed range, animate a moving window that calls next animation frames continuously
   * The increment id based on domain / BASE_SPEED * SPEED
   *
   * 2. incremental
   * |    |->
   * Same as free, current time is a growing range, only the max value of range increment during animation.
   * The increment is also based on domain / BASE_SPEED * SPEED
   *
   * 3. point
   * o -> o
   * Current time is a point, animate a moving point calls next animation frame continuously
   * The increment is based on domain / BASE_SPEED * SPEED
   *
   * 4. interval
   * o ~> o
   * Current time is a point. An array of sorted time steps are provided,
   * animate a moving point jumps to the next step
   */
  var AnimationController = /*#__PURE__*/function (_Component2) {
    (0, _inherits2["default"])(AnimationController, _Component2);

    var _super2 = _createSuper(AnimationController);

    function AnimationController() {
      var _this;

      (0, _classCallCheck2["default"])(this, AnimationController);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _super2.call.apply(_super2, [this].concat(args));
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "state", {
        isAnimating: false
      });
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_timer", null);
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_startTime", 0);
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_animate", function (delay) {
        _this._startTime = new Date().getTime();

        var loop = function loop() {
          var current = new Date().getTime();
          var delta = current - _this._startTime;

          if (delta >= delay) {
            _this._nextFrame();

            _this._startTime = new Date().getTime();
          } else {
            _this._timer = (0, _window.requestAnimationFrame)(loop);
          }
        };

        _this._timer = (0, _window.requestAnimationFrame)(loop);
      });
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_resetAnimationByDomain", function () {
        var _this$props = _this.props,
            domain = _this$props.domain,
            value = _this$props.value,
            animationWindow = _this$props.animationWindow;

        if (!domain) {
          return;
        }

        if (Array.isArray(value)) {
          if (animationWindow === _constants.ANIMATION_WINDOW.incremental) {
            _this.props.updateAnimation([value[0], value[0] + 1]);
          } else {
            _this.props.updateAnimation([domain[0], domain[0] + value[1] - value[0]]);
          }
        } else {
          _this.props.updateAnimation(domain[0]);
        }
      });
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_resetAnimtionByTimeStep", function () {
        var _this$props$steps = _this.props.steps,
            steps = _this$props$steps === void 0 ? null : _this$props$steps;
        if (!steps) return; // go to the first steps

        _this.props.updateAnimation([steps[0], 0]);
      });
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_resetAnimation", function () {
        if (_this.props.animationWindow === _constants.ANIMATION_WINDOW.interval) {
          _this._resetAnimtionByTimeStep();
        } else {
          _this._resetAnimationByDomain();
        }
      });
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_startAnimation", function () {
        var _this$props$speed = _this.props.speed,
            speed = _this$props$speed === void 0 ? 1 : _this$props$speed;

        _this._clearTimer();

        if (speed > 0) {
          if (_this.props.animationWindow === _constants.ANIMATION_WINDOW.interval) {
            // animate by interval
            // 30*600
            var steps = _this.props.steps;

            if (!Array.isArray(steps) || !steps.length) {
              _console["default"].warn('animation steps should be an array');

              return;
            } // when speed = 1, animation should loop through 600 frames at 60 FPS
            // calculate delay based on # steps


            var delay = _constants.BASE_SPEED * (1000 / _constants.FPS) / steps.length / (speed || 1);

            _this._animate(delay);
          } else {
            _this._timer = (0, _window.requestAnimationFrame)(_this._nextFrame);
          }
        }

        _this.setState({
          isAnimating: true
        });
      });
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_clearTimer", function () {
        if (_this._timer) {
          (0, _window.cancelAnimationFrame)(_this._timer);
          _this._timer = null;
        }
      });
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_pauseAnimation", function () {
        _this._clearTimer();

        _this.setState({
          isAnimating: false
        });
      });
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_nextFrame", function () {
        _this._timer = null;
        var nextValue = _this.props.animationWindow === _constants.ANIMATION_WINDOW.interval ? _this._nextFrameByTimeStep() : _this._nextFrameByDomain();

        _this.props.updateAnimation(nextValue);
      });
      return _this;
    }

    (0, _createClass2["default"])(AnimationController, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        this._startOrPauseAnimation();
      }
    }, {
      key: "componentDidUpdate",
      value: function componentDidUpdate() {
        this._startOrPauseAnimation();
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        if (this._timer) {
          (0, _window.cancelAnimationFrame)(this._timer);
        }
      }
    }, {
      key: "_startOrPauseAnimation",
      value: function _startOrPauseAnimation() {
        var _this$props2 = this.props,
            isAnimating = _this$props2.isAnimating,
            _this$props2$speed = _this$props2.speed,
            speed = _this$props2$speed === void 0 ? 1 : _this$props2$speed;

        if (!this._timer && isAnimating && speed > 0) {
          this._startAnimation();
        } else if (this._timer && !isAnimating) {
          this._pauseAnimation();
        }
      }
    }, {
      key: "_nextFrameByDomain",
      value: function _nextFrameByDomain() {
        var _this$props3 = this.props,
            domain = _this$props3.domain,
            value = _this$props3.value,
            _this$props3$speed = _this$props3.speed,
            speed = _this$props3$speed === void 0 ? 1 : _this$props3$speed,
            _this$props3$baseSpee = _this$props3.baseSpeed,
            baseSpeed = _this$props3$baseSpee === void 0 ? 600 : _this$props3$baseSpee,
            animationWindow = _this$props3.animationWindow;

        if (!domain) {
          return;
        }

        var delta = (domain[1] - domain[0]) / baseSpeed * speed; // loop when reaches the end
        // current time is a range

        if (Array.isArray(value)) {
          var value0;
          var value1;
          var readEnd = value[1] + delta > domain[1];

          if (animationWindow === _constants.ANIMATION_WINDOW.incremental) {
            value0 = value[0];
            value1 = readEnd ? value[0] + 1 : value[1] + delta;
          } else {
            value0 = readEnd ? domain[0] : value[0] + delta;
            value1 = value0 + value[1] - value[0];
          }

          return [value0, value1];
        } // current time is a point


        return Number(value) + delta > domain[1] ? domain[0] : Number(value) + delta;
      }
    }, {
      key: "_nextFrameByTimeStep",
      value: function _nextFrameByTimeStep() {
        var _this$props4 = this.props,
            _this$props4$steps = _this$props4.steps,
            steps = _this$props4$steps === void 0 ? null : _this$props4$steps,
            value = _this$props4.value;
        if (!steps) return;
        var val = Array.isArray(value) ? value[0] : Number(value);
        var index = (0, _d3Array.bisectLeft)(steps, val);
        var nextIdx = index >= steps.length - 1 ? 0 : index + 1;
        return [steps[nextIdx], nextIdx];
      }
    }, {
      key: "render",
      value: function render() {
        var isAnimating = this.state.isAnimating;
        var children = this.props.children;
        return typeof children === 'function' ? children(isAnimating, this._startAnimation, this._pauseAnimation, this._resetAnimation) : null;
      }
    }]);
    return AnimationController;
  }(_react.Component);

  (0, _defineProperty2["default"])(AnimationController, "defaultProps", {
    baseSpeed: _constants.BASE_SPEED,
    speed: 1,
    steps: null,
    animationWindow: _constants.ANIMATION_WINDOW.free
  });
  return AnimationController;
}

var _default = AnimationControllerFactory;
exports["default"] = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb21tb24vYW5pbWF0aW9uLWNvbnRyb2wvYW5pbWF0aW9uLWNvbnRyb2xsZXIudHMiXSwibmFtZXMiOlsiQW5pbWF0aW9uQ29udHJvbGxlclR5cGUiLCJDb21wb25lbnQiLCJBbmltYXRpb25Db250cm9sbGVyRmFjdG9yeSIsIkFuaW1hdGlvbkNvbnRyb2xsZXIiLCJpc0FuaW1hdGluZyIsImRlbGF5IiwiX3N0YXJ0VGltZSIsIkRhdGUiLCJnZXRUaW1lIiwibG9vcCIsImN1cnJlbnQiLCJkZWx0YSIsIl9uZXh0RnJhbWUiLCJfdGltZXIiLCJwcm9wcyIsImRvbWFpbiIsInZhbHVlIiwiYW5pbWF0aW9uV2luZG93IiwiQXJyYXkiLCJpc0FycmF5IiwiQU5JTUFUSU9OX1dJTkRPVyIsImluY3JlbWVudGFsIiwidXBkYXRlQW5pbWF0aW9uIiwic3RlcHMiLCJpbnRlcnZhbCIsIl9yZXNldEFuaW10aW9uQnlUaW1lU3RlcCIsIl9yZXNldEFuaW1hdGlvbkJ5RG9tYWluIiwic3BlZWQiLCJfY2xlYXJUaW1lciIsImxlbmd0aCIsIkNvbnNvbGUiLCJ3YXJuIiwiQkFTRV9TUEVFRCIsIkZQUyIsIl9hbmltYXRlIiwic2V0U3RhdGUiLCJuZXh0VmFsdWUiLCJfbmV4dEZyYW1lQnlUaW1lU3RlcCIsIl9uZXh0RnJhbWVCeURvbWFpbiIsIl9zdGFydE9yUGF1c2VBbmltYXRpb24iLCJfc3RhcnRBbmltYXRpb24iLCJfcGF1c2VBbmltYXRpb24iLCJiYXNlU3BlZWQiLCJ2YWx1ZTAiLCJ2YWx1ZTEiLCJyZWFkRW5kIiwiTnVtYmVyIiwidmFsIiwiaW5kZXgiLCJuZXh0SWR4Iiwic3RhdGUiLCJjaGlsZHJlbiIsIl9yZXNldEFuaW1hdGlvbiIsImZyZWUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBb0JBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOzs7Ozs7SUFhTUEsdUI7Ozs7Ozs7Ozs7O0VBQTZEQyxnQjs7QUFJbkUs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bEQsbUJBQVA7QUFDRDs7ZUFFY0QsMEIiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMjIgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5pbXBvcnQge0NvbXBvbmVudH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHtiaXNlY3RMZWZ0fSBmcm9tICdkMy1hcnJheSc7XG5pbXBvcnQge3JlcXVlc3RBbmltYXRpb25GcmFtZSwgY2FuY2VsQW5pbWF0aW9uRnJhbWV9IGZyb20gJ2dsb2JhbC93aW5kb3cnO1xuaW1wb3J0IENvbnNvbGUgZnJvbSAnZ2xvYmFsL2NvbnNvbGUnO1xuaW1wb3J0IHtCQVNFX1NQRUVELCBGUFMsIEFOSU1BVElPTl9XSU5ET1d9IGZyb20gJ0BrZXBsZXIuZ2wvY29uc3RhbnRzJztcblxuaW50ZXJmYWNlIEFuaW1hdGlvbkNvbnRyb2xsZXJQcm9wczxUIGV4dGVuZHMgbnVtYmVyIHwgbnVtYmVyW10+IHtcbiAgaXNBbmltYXRpbmc/OiBib29sZWFuO1xuICBzcGVlZD86IG51bWJlcjtcbiAgdXBkYXRlQW5pbWF0aW9uOiAoeDogVCkgPT4gdm9pZDtcbiAgYW5pbWF0aW9uV2luZG93Pzogc3RyaW5nO1xuICBzdGVwcz86IG51bWJlcltdIHwgbnVsbDtcbiAgZG9tYWluOiBudW1iZXJbXSB8IG51bGw7XG4gIHZhbHVlOiBUO1xuICBiYXNlU3BlZWQ/OiBudW1iZXI7XG59XG5cbmNsYXNzIEFuaW1hdGlvbkNvbnRyb2xsZXJUeXBlPFQgZXh0ZW5kcyBudW1iZXIgfCBudW1iZXJbXT4gZXh0ZW5kcyBDb21wb25lbnQ8XG4gIEFuaW1hdGlvbkNvbnRyb2xsZXJQcm9wczxUPlxuPiB7fVxuXG5mdW5jdGlvbiBBbmltYXRpb25Db250cm9sbGVyRmFjdG9yeSgpOiB0eXBlb2YgQW5pbWF0aW9uQ29udHJvbGxlclR5cGUge1xuICAvKipcbiAgICogNCBBbmltYXRpb24gV2luZG93IFR5cGVzXG4gICAqIDEuIGZyZWVcbiAgICogIHwtPiAgfC0+XG4gICAqIEN1cnJlbnQgdGltZSBpcyBhIGZpeGVkIHJhbmdlLCBhbmltYXRlIGEgbW92aW5nIHdpbmRvdyB0aGF0IGNhbGxzIG5leHQgYW5pbWF0aW9uIGZyYW1lcyBjb250aW51b3VzbHlcbiAgICogVGhlIGluY3JlbWVudCBpZCBiYXNlZCBvbiBkb21haW4gLyBCQVNFX1NQRUVEICogU1BFRURcbiAgICpcbiAgICogMi4gaW5jcmVtZW50YWxcbiAgICogfCAgICB8LT5cbiAgICogU2FtZSBhcyBmcmVlLCBjdXJyZW50IHRpbWUgaXMgYSBncm93aW5nIHJhbmdlLCBvbmx5IHRoZSBtYXggdmFsdWUgb2YgcmFuZ2UgaW5jcmVtZW50IGR1cmluZyBhbmltYXRpb24uXG4gICAqIFRoZSBpbmNyZW1lbnQgaXMgYWxzbyBiYXNlZCBvbiBkb21haW4gLyBCQVNFX1NQRUVEICogU1BFRURcbiAgICpcbiAgICogMy4gcG9pbnRcbiAgICogbyAtPiBvXG4gICAqIEN1cnJlbnQgdGltZSBpcyBhIHBvaW50LCBhbmltYXRlIGEgbW92aW5nIHBvaW50IGNhbGxzIG5leHQgYW5pbWF0aW9uIGZyYW1lIGNvbnRpbnVvdXNseVxuICAgKiBUaGUgaW5jcmVtZW50IGlzIGJhc2VkIG9uIGRvbWFpbiAvIEJBU0VfU1BFRUQgKiBTUEVFRFxuICAgKlxuICAgKiA0LiBpbnRlcnZhbFxuICAgKiBvIH4+IG9cbiAgICogQ3VycmVudCB0aW1lIGlzIGEgcG9pbnQuIEFuIGFycmF5IG9mIHNvcnRlZCB0aW1lIHN0ZXBzIGFyZSBwcm92aWRlZCxcbiAgICogYW5pbWF0ZSBhIG1vdmluZyBwb2ludCBqdW1wcyB0byB0aGUgbmV4dCBzdGVwXG4gICAqL1xuICBjbGFzcyBBbmltYXRpb25Db250cm9sbGVyPFQgZXh0ZW5kcyBudW1iZXIgfCBudW1iZXJbXT4gZXh0ZW5kcyBDb21wb25lbnQ8XG4gICAgQW5pbWF0aW9uQ29udHJvbGxlclByb3BzPFQ+XG4gID4ge1xuICAgIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgICBiYXNlU3BlZWQ6IEJBU0VfU1BFRUQsXG4gICAgICBzcGVlZDogMSxcbiAgICAgIHN0ZXBzOiBudWxsLFxuICAgICAgYW5pbWF0aW9uV2luZG93OiBBTklNQVRJT05fV0lORE9XLmZyZWVcbiAgICB9O1xuXG4gICAgc3RhdGUgPSB7XG4gICAgICBpc0FuaW1hdGluZzogZmFsc2VcbiAgICB9O1xuXG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICB0aGlzLl9zdGFydE9yUGF1c2VBbmltYXRpb24oKTtcbiAgICB9XG5cbiAgICBjb21wb25lbnREaWRVcGRhdGUoKSB7XG4gICAgICB0aGlzLl9zdGFydE9yUGF1c2VBbmltYXRpb24oKTtcbiAgICB9XG5cbiAgICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgIGlmICh0aGlzLl90aW1lcikge1xuICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLl90aW1lcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgX3RpbWVyID0gbnVsbDtcbiAgICBfc3RhcnRUaW1lOiBudW1iZXIgPSAwO1xuXG4gICAgX3N0YXJ0T3JQYXVzZUFuaW1hdGlvbigpIHtcbiAgICAgIGNvbnN0IHtpc0FuaW1hdGluZywgc3BlZWQgPSAxfSA9IHRoaXMucHJvcHM7XG4gICAgICBpZiAoIXRoaXMuX3RpbWVyICYmIGlzQW5pbWF0aW5nICYmIHNwZWVkID4gMCkge1xuICAgICAgICB0aGlzLl9zdGFydEFuaW1hdGlvbigpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl90aW1lciAmJiAhaXNBbmltYXRpbmcpIHtcbiAgICAgICAgdGhpcy5fcGF1c2VBbmltYXRpb24oKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfYW5pbWF0ZSA9IGRlbGF5ID0+IHtcbiAgICAgIHRoaXMuX3N0YXJ0VGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuXG4gICAgICBjb25zdCBsb29wID0gKCkgPT4ge1xuICAgICAgICBjb25zdCBjdXJyZW50ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgIGNvbnN0IGRlbHRhID0gY3VycmVudCAtIHRoaXMuX3N0YXJ0VGltZTtcblxuICAgICAgICBpZiAoZGVsdGEgPj0gZGVsYXkpIHtcbiAgICAgICAgICB0aGlzLl9uZXh0RnJhbWUoKTtcbiAgICAgICAgICB0aGlzLl9zdGFydFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl90aW1lciA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShsb29wKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgdGhpcy5fdGltZXIgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUobG9vcCk7XG4gICAgfTtcblxuICAgIF9yZXNldEFuaW1hdGlvbkJ5RG9tYWluID0gKCkgPT4ge1xuICAgICAgY29uc3Qge2RvbWFpbiwgdmFsdWUsIGFuaW1hdGlvbldpbmRvd30gPSB0aGlzLnByb3BzO1xuICAgICAgaWYgKCFkb21haW4pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIGlmIChhbmltYXRpb25XaW5kb3cgPT09IEFOSU1BVElPTl9XSU5ET1cuaW5jcmVtZW50YWwpIHtcbiAgICAgICAgICB0aGlzLnByb3BzLnVwZGF0ZUFuaW1hdGlvbihbdmFsdWVbMF0sIHZhbHVlWzBdICsgMV0gYXMgVCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5wcm9wcy51cGRhdGVBbmltYXRpb24oW2RvbWFpblswXSwgZG9tYWluWzBdICsgdmFsdWVbMV0gLSB2YWx1ZVswXV0gYXMgVCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucHJvcHMudXBkYXRlQW5pbWF0aW9uKGRvbWFpblswXSBhcyBUKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3Jlc2V0QW5pbXRpb25CeVRpbWVTdGVwID0gKCkgPT4ge1xuICAgICAgY29uc3Qge3N0ZXBzID0gbnVsbH0gPSB0aGlzLnByb3BzO1xuICAgICAgaWYgKCFzdGVwcykgcmV0dXJuO1xuICAgICAgLy8gZ28gdG8gdGhlIGZpcnN0IHN0ZXBzXG4gICAgICB0aGlzLnByb3BzLnVwZGF0ZUFuaW1hdGlvbihbc3RlcHNbMF0sIDBdIGFzIFQpO1xuICAgIH07XG5cbiAgICBfcmVzZXRBbmltYXRpb24gPSAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5wcm9wcy5hbmltYXRpb25XaW5kb3cgPT09IEFOSU1BVElPTl9XSU5ET1cuaW50ZXJ2YWwpIHtcbiAgICAgICAgdGhpcy5fcmVzZXRBbmltdGlvbkJ5VGltZVN0ZXAoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3Jlc2V0QW5pbWF0aW9uQnlEb21haW4oKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3N0YXJ0QW5pbWF0aW9uID0gKCkgPT4ge1xuICAgICAgY29uc3Qge3NwZWVkID0gMX0gPSB0aGlzLnByb3BzO1xuICAgICAgdGhpcy5fY2xlYXJUaW1lcigpO1xuICAgICAgaWYgKHNwZWVkID4gMCkge1xuICAgICAgICBpZiAodGhpcy5wcm9wcy5hbmltYXRpb25XaW5kb3cgPT09IEFOSU1BVElPTl9XSU5ET1cuaW50ZXJ2YWwpIHtcbiAgICAgICAgICAvLyBhbmltYXRlIGJ5IGludGVydmFsXG4gICAgICAgICAgLy8gMzAqNjAwXG4gICAgICAgICAgY29uc3Qge3N0ZXBzfSA9IHRoaXMucHJvcHM7XG4gICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHN0ZXBzKSB8fCAhc3RlcHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBDb25zb2xlLndhcm4oJ2FuaW1hdGlvbiBzdGVwcyBzaG91bGQgYmUgYW4gYXJyYXknKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gd2hlbiBzcGVlZCA9IDEsIGFuaW1hdGlvbiBzaG91bGQgbG9vcCB0aHJvdWdoIDYwMCBmcmFtZXMgYXQgNjAgRlBTXG4gICAgICAgICAgLy8gY2FsY3VsYXRlIGRlbGF5IGJhc2VkIG9uICMgc3RlcHNcbiAgICAgICAgICBjb25zdCBkZWxheSA9IChCQVNFX1NQRUVEICogKDEwMDAgLyBGUFMpKSAvIHN0ZXBzLmxlbmd0aCAvIChzcGVlZCB8fCAxKTtcbiAgICAgICAgICB0aGlzLl9hbmltYXRlKGRlbGF5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl90aW1lciA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLl9uZXh0RnJhbWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLnNldFN0YXRlKHtpc0FuaW1hdGluZzogdHJ1ZX0pO1xuICAgIH07XG5cbiAgICBfY2xlYXJUaW1lciA9ICgpID0+IHtcbiAgICAgIGlmICh0aGlzLl90aW1lcikge1xuICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLl90aW1lcik7XG4gICAgICAgIHRoaXMuX3RpbWVyID0gbnVsbDtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3BhdXNlQW5pbWF0aW9uID0gKCkgPT4ge1xuICAgICAgdGhpcy5fY2xlYXJUaW1lcigpO1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7aXNBbmltYXRpbmc6IGZhbHNlfSk7XG4gICAgfTtcblxuICAgIF9uZXh0RnJhbWUgPSAoKSA9PiB7XG4gICAgICB0aGlzLl90aW1lciA9IG51bGw7XG4gICAgICBjb25zdCBuZXh0VmFsdWUgPVxuICAgICAgICB0aGlzLnByb3BzLmFuaW1hdGlvbldpbmRvdyA9PT0gQU5JTUFUSU9OX1dJTkRPVy5pbnRlcnZhbFxuICAgICAgICAgID8gdGhpcy5fbmV4dEZyYW1lQnlUaW1lU3RlcCgpXG4gICAgICAgICAgOiB0aGlzLl9uZXh0RnJhbWVCeURvbWFpbigpO1xuXG4gICAgICB0aGlzLnByb3BzLnVwZGF0ZUFuaW1hdGlvbihuZXh0VmFsdWUgYXMgVCk7XG4gICAgfTtcblxuICAgIF9uZXh0RnJhbWVCeURvbWFpbigpIHtcbiAgICAgIGNvbnN0IHtkb21haW4sIHZhbHVlLCBzcGVlZCA9IDEsIGJhc2VTcGVlZCA9IDYwMCwgYW5pbWF0aW9uV2luZG93fSA9IHRoaXMucHJvcHM7XG4gICAgICBpZiAoIWRvbWFpbikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBkZWx0YSA9ICgoZG9tYWluWzFdIC0gZG9tYWluWzBdKSAvIGJhc2VTcGVlZCkgKiBzcGVlZDtcblxuICAgICAgLy8gbG9vcCB3aGVuIHJlYWNoZXMgdGhlIGVuZFxuICAgICAgLy8gY3VycmVudCB0aW1lIGlzIGEgcmFuZ2VcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICBsZXQgdmFsdWUwOiBudW1iZXI7XG4gICAgICAgIGxldCB2YWx1ZTE6IG51bWJlcjtcbiAgICAgICAgY29uc3QgcmVhZEVuZCA9IHZhbHVlWzFdICsgZGVsdGEgPiBkb21haW5bMV07XG4gICAgICAgIGlmIChhbmltYXRpb25XaW5kb3cgPT09IEFOSU1BVElPTl9XSU5ET1cuaW5jcmVtZW50YWwpIHtcbiAgICAgICAgICB2YWx1ZTAgPSB2YWx1ZVswXTtcbiAgICAgICAgICB2YWx1ZTEgPSByZWFkRW5kID8gdmFsdWVbMF0gKyAxIDogdmFsdWVbMV0gKyBkZWx0YTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZTAgPSByZWFkRW5kID8gZG9tYWluWzBdIDogdmFsdWVbMF0gKyBkZWx0YTtcbiAgICAgICAgICB2YWx1ZTEgPSB2YWx1ZTAgKyB2YWx1ZVsxXSAtIHZhbHVlWzBdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbdmFsdWUwLCB2YWx1ZTFdO1xuICAgICAgfVxuXG4gICAgICAvLyBjdXJyZW50IHRpbWUgaXMgYSBwb2ludFxuICAgICAgcmV0dXJuIE51bWJlcih2YWx1ZSkgKyBkZWx0YSA+IGRvbWFpblsxXSA/IGRvbWFpblswXSA6IE51bWJlcih2YWx1ZSkgKyBkZWx0YTtcbiAgICB9XG5cbiAgICBfbmV4dEZyYW1lQnlUaW1lU3RlcCgpIHtcbiAgICAgIGNvbnN0IHtzdGVwcyA9IG51bGwsIHZhbHVlfSA9IHRoaXMucHJvcHM7XG4gICAgICBpZiAoIXN0ZXBzKSByZXR1cm47XG4gICAgICBjb25zdCB2YWwgPSBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlWzBdIDogTnVtYmVyKHZhbHVlKTtcbiAgICAgIGNvbnN0IGluZGV4ID0gYmlzZWN0TGVmdChzdGVwcywgdmFsKTtcbiAgICAgIGNvbnN0IG5leHRJZHggPSBpbmRleCA+PSBzdGVwcy5sZW5ndGggLSAxID8gMCA6IGluZGV4ICsgMTtcblxuICAgICAgcmV0dXJuIFtzdGVwc1tuZXh0SWR4XSwgbmV4dElkeF07XG4gICAgfVxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgY29uc3Qge2lzQW5pbWF0aW5nfSA9IHRoaXMuc3RhdGU7XG4gICAgICBjb25zdCB7Y2hpbGRyZW59ID0gdGhpcy5wcm9wcztcblxuICAgICAgcmV0dXJuIHR5cGVvZiBjaGlsZHJlbiA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IGNoaWxkcmVuKGlzQW5pbWF0aW5nLCB0aGlzLl9zdGFydEFuaW1hdGlvbiwgdGhpcy5fcGF1c2VBbmltYXRpb24sIHRoaXMuX3Jlc2V0QW5pbWF0aW9uKVxuICAgICAgICA6IG51bGw7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIEFuaW1hdGlvbkNvbnRyb2xsZXI7XG59XG5cbmV4cG9ydCBkZWZhdWx0IEFuaW1hdGlvbkNvbnRyb2xsZXJGYWN0b3J5O1xuIl19