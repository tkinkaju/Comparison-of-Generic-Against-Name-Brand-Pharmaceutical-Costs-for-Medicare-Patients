// Copyright (c) 2022 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = MapContainerFactory;
exports.Attribution = void 0;

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _react = _interopRequireWildcard(require("react"));

var _reactMapGl = _interopRequireDefault(require("react-map-gl"));

var _react2 = _interopRequireDefault(require("@deck.gl/react"));

var _reselect = require("reselect");

var _viewportMercatorProject = _interopRequireDefault(require("viewport-mercator-project"));

var _mapPopover = _interopRequireDefault(require("./map/map-popover"));

var _mapControl = _interopRequireDefault(require("./map/map-control"));

var _styledComponents = require("./common/styled-components");

var _editor = _interopRequireDefault(require("./editor/editor"));

var _layers = require("@kepler.gl/layers");

var _utils = require("@kepler.gl/utils");

var _styles = require("@kepler.gl/styles");

var _constants = require("@kepler.gl/constants");

var _errorBoundary = _interopRequireDefault(require("./common/error-boundary"));

var _localization = require("@kepler.gl/localization");

var _core = require("@deck.gl/core");

var _reducers = require("@kepler.gl/reducers");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

/** @type {{[key: string]: React.CSSProperties}} */
var MAP_STYLE = {
  container: {
    display: 'inline-block',
    position: 'relative',
    width: '100%',
    height: '100%'
  },
  top: {
    position: 'absolute',
    top: '0px',
    pointerEvents: 'none',
    width: '100%',
    height: '100%'
  }
};
var LOCALE_CODES_ARRAY = Object.keys(_localization.LOCALE_CODES);
var MAPBOXGL_STYLE_UPDATE = 'style.load';
var MAPBOXGL_RENDER = 'render';

var nop = function nop() {};

var MapboxLogo = function MapboxLogo() {
  return /*#__PURE__*/_react["default"].createElement("div", {
    className: "attrition-logo"
  }, "Basemap by:", /*#__PURE__*/_react["default"].createElement("a", {
    className: "mapboxgl-ctrl-logo",
    target: "_blank",
    rel: "noopener noreferrer",
    href: "https://www.mapbox.com/",
    "aria-label": "Mapbox logo"
  }));
};

var Attribution = function Attribution(_ref) {
  var _ref$showMapboxLogo = _ref.showMapboxLogo,
      showMapboxLogo = _ref$showMapboxLogo === void 0 ? true : _ref$showMapboxLogo;
  var isPalm = (0, _utils.hasMobileWidth)(_styles.breakPointValues);
  var memoizedComponents = (0, _react.useMemo)(function () {
    if (!showMapboxLogo) {
      return /*#__PURE__*/_react["default"].createElement(_styledComponents.StyledAttrbution, null, /*#__PURE__*/_react["default"].createElement("a", {
        href: "http://www.openstreetmap.org/copyright",
        target: "_blank",
        rel: "noopener noreferrer"
      }, "\xA9 OpenStreetMap"));
    }

    return /*#__PURE__*/_react["default"].createElement(_styledComponents.StyledAttrbution, null, isPalm ? /*#__PURE__*/_react["default"].createElement(MapboxLogo, null) : null, /*#__PURE__*/_react["default"].createElement("div", {
      className: "attrition-link"
    }, /*#__PURE__*/_react["default"].createElement("a", {
      href: "https://kepler.gl/policy/",
      target: "_blank",
      rel: "noopener noreferrer"
    }, "\xA9 kepler.gl |", ' '), /*#__PURE__*/_react["default"].createElement("a", {
      href: "https://www.mapbox.com/about/maps/",
      target: "_blank",
      rel: "noopener noreferrer"
    }, "\xA9 Mapbox |", ' '), /*#__PURE__*/_react["default"].createElement("a", {
      href: "http://www.openstreetmap.org/copyright",
      target: "_blank",
      rel: "noopener noreferrer"
    }, "\xA9 OpenStreetMap |", ' '), /*#__PURE__*/_react["default"].createElement("a", {
      href: "https://www.mapbox.com/map-feedback/",
      target: "_blank",
      rel: "noopener noreferrer"
    }, /*#__PURE__*/_react["default"].createElement("strong", null, "Improve this map "), !isPalm ? /*#__PURE__*/_react["default"].createElement("strong", null, " | ") : null), !isPalm ? /*#__PURE__*/_react["default"].createElement(MapboxLogo, null) : null));
  }, [showMapboxLogo, isPalm]);
  return memoizedComponents;
};

exports.Attribution = Attribution;
MapContainerFactory.deps = [_mapPopover["default"], _mapControl["default"], _editor["default"]];

function MapContainerFactory(MapPopover, MapControl, Editor) {
  var MapContainer = /*#__PURE__*/function (_Component) {
    (0, _inherits2["default"])(MapContainer, _Component);

    var _super = _createSuper(MapContainer);

    function MapContainer(_props) {
      var _this;

      (0, _classCallCheck2["default"])(this, MapContainer);
      _this = _super.call(this, _props);
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "displayName", 'MapContainer');
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "state", {
        // Determines whether attribution should be visible based the result of loading the map style
        showMapboxAttribution: true
      });
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_deck", null);
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_map", null);
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_ref", /*#__PURE__*/(0, _react.createRef)());
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_deckGLErrorsElapsed", {});
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "previousLayers", {// [layers.id]: mapboxLayerConfig
      });
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_handleResize", function (dimensions) {
        var primary = _this.props.primary;

        if (primary) {
          var mapStateActions = _this.props.mapStateActions;

          if (dimensions && dimensions.width > 0 && dimensions.height > 0) {
            mapStateActions.updateMap(dimensions);
          }
        }
      });
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "layersSelector", function (props) {
        return props.visState.layers;
      });
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "layerDataSelector", function (props) {
        return props.visState.layerData;
      });
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "splitMapSelector", function (props) {
        return props.visState.splitMaps;
      });
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "splitMapIndexSelector", function (props) {
        return props.index;
      });
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "mapLayersSelector", (0, _reselect.createSelector)(_this.splitMapSelector, _this.splitMapIndexSelector, _utils.getMapLayersFromSplitMaps));
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "layerOrderSelector", function (props) {
        return props.visState.layerOrder;
      });
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "layersToRenderSelector", (0, _reselect.createSelector)(_this.layersSelector, _this.layerDataSelector, _this.mapLayersSelector, _reducers.prepareLayersToRender));
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "layersForDeckSelector", (0, _reselect.createSelector)(_this.layersSelector, _this.layerDataSelector, _reducers.prepareLayersForDeck));
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "filtersSelector", function (props) {
        return props.visState.filters;
      });
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "polygonFilters", (0, _reselect.createSelector)(_this.filtersSelector, function (filters) {
        return filters.filter(function (f) {
          return f.type === _constants.FILTER_TYPES.polygon;
        });
      }));
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "mapboxLayersSelector", (0, _reselect.createSelector)(_this.layersSelector, _this.layerDataSelector, _this.layerOrderSelector, _this.layersToRenderSelector, _layers.generateMapboxLayers));
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_onCloseMapPopover", function () {
        _this.props.visStateActions.onLayerClick(null);
      });
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_onLayerSetDomain", function (idx, colorDomain) {
        _this.props.visStateActions.layerConfigChange(_this.props.visState.layers[idx], {
          colorDomain: colorDomain
        });
      });
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_handleMapToggleLayer", function (layerId) {
        var _this$props = _this.props,
            _this$props$index = _this$props.index,
            mapIndex = _this$props$index === void 0 ? 0 : _this$props$index,
            visStateActions = _this$props.visStateActions;
        visStateActions.toggleLayerForMap(mapIndex, layerId);
      });
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_onMapboxStyleUpdate", function (update) {
        // force refresh mapboxgl layers
        _this.previousLayers = {};

        _this._updateMapboxLayers();

        if (update && update.style) {
          // No attributions are needed if the style doesn't reference Mapbox sources
          _this.setState({
            showMapboxAttribution: (0, _utils.isStyleUsingMapboxTiles)(update.style)
          });
        }

        if (typeof _this.props.onMapStyleLoaded === 'function') {
          _this.props.onMapStyleLoaded(_this._map);
        }
      });
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_setMapboxMap", function (mapbox) {
        if (!_this._map && mapbox) {
          _this._map = mapbox.getMap(); // i noticed in certain context we don't access the actual map element

          if (!_this._map) {
            return;
          } // bind mapboxgl event listener


          _this._map.on(MAPBOXGL_STYLE_UPDATE, _this._onMapboxStyleUpdate);

          _this._map.on(MAPBOXGL_RENDER, function () {
            if (typeof _this.props.onMapRender === 'function') {
              _this.props.onMapRender(_this._map);
            }
          });
        }

        if (_this.props.getMapboxRef) {
          // The parent component can gain access to our MapboxGlMap by
          // providing this callback. Note that 'mapbox' will be null when the
          // ref is unset (e.g. when a split map is closed).
          _this.props.getMapboxRef(mapbox, _this.props.index);
        }
      });
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_onBeforeRender", function (_ref2) {
        var gl = _ref2.gl;
        (0, _utils.setLayerBlending)(gl, _this.props.visState.layerBlending);
      });
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_onDeckError", function (error, layer) {
        var errorMessage = "An error in deck.gl: ".concat(error.message, " in ").concat(layer.id);
        var notificationId = "".concat(layer.id, "-").concat(error.message); // Throttle error notifications, as React doesn't like too many state changes from here.

        var lastShown = _this._deckGLErrorsElapsed[notificationId];

        if (!lastShown || lastShown < Date.now() - _constants.THROTTLE_NOTIFICATION_TIME) {
          _this._deckGLErrorsElapsed[notificationId] = Date.now(); // Create new error notification or update existing one with same id.
          // Update is required to preserve the order of notifications as they probably are going to "jump" based on order of errors.

          var uiStateActions = _this.props.uiStateActions;
          uiStateActions.addNotification((0, _utils.errorNotification)({
            message: errorMessage,
            id: notificationId
          }));
        }
      });
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_onViewportChange", function (viewState) {
        (0, _utils.onViewPortChange)(viewState, _this.props.mapStateActions.updateMap, _this.props.onViewStateChange, _this.props.primary);
      });
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_toggleMapControl", function (panelId) {
        var _this$props2 = _this.props,
            index = _this$props2.index,
            uiStateActions = _this$props2.uiStateActions;
        uiStateActions.toggleMapControl(panelId, Number(index));
      });
      return _this;
    }

    (0, _createClass2["default"])(MapContainer, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        if (!this._ref.current) {
          return;
        }

        (0, _utils.observeDimensions)(this._ref.current, this._handleResize);
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        // unbind mapboxgl event listener
        if (this._map) {
          var _this$_map, _this$_map2;

          (_this$_map = this._map) === null || _this$_map === void 0 ? void 0 : _this$_map.off(MAPBOXGL_STYLE_UPDATE, nop);
          (_this$_map2 = this._map) === null || _this$_map2 === void 0 ? void 0 : _this$_map2.off(MAPBOXGL_RENDER, nop);
        }

        if (!this._ref.current) {
          return;
        }

        (0, _utils.unobserveDimensions)(this._ref.current);
      }
    }, {
      key: "_onDeckInitialized",
      value: function _onDeckInitialized(gl) {
        if (this.props.onDeckInitialized) {
          this.props.onDeckInitialized(this._deck, gl);
        }
      }
    }, {
      key: "_renderMapPopover",
      value:
      /* component render functions */

      /* eslint-disable complexity */
      function _renderMapPopover() {
        // TODO: move this into reducer so it can be tested
        var _this$props3 = this.props,
            mapState = _this$props3.mapState,
            _this$props3$visState = _this$props3.visState,
            hoverInfo = _this$props3$visState.hoverInfo,
            clicked = _this$props3$visState.clicked,
            datasets = _this$props3$visState.datasets,
            interactionConfig = _this$props3$visState.interactionConfig,
            layers = _this$props3$visState.layers,
            _this$props3$visState2 = _this$props3$visState.mousePos,
            mousePosition = _this$props3$visState2.mousePosition,
            coordinate = _this$props3$visState2.coordinate,
            pinned = _this$props3$visState2.pinned;
        var layersToRender = this.layersToRenderSelector(this.props);

        if (!mousePosition || !interactionConfig.tooltip) {
          return null;
        }

        var layerHoverProp = (0, _reducers.getLayerHoverProp)({
          interactionConfig: interactionConfig,
          hoverInfo: hoverInfo,
          layers: layers,
          layersToRender: layersToRender,
          datasets: datasets
        });
        var compareMode = interactionConfig.tooltip.config ? interactionConfig.tooltip.config.compareMode : false;
        var pinnedPosition = {};
        var layerPinnedProp = null;

        if (pinned || clicked) {
          // project lnglat to screen so that tooltip follows the object on zoom
          var _viewport = new _viewportMercatorProject["default"](mapState);

          var lngLat = clicked ? clicked.coordinate : pinned.coordinate;
          pinnedPosition = this._getHoverXY(_viewport, lngLat);
          layerPinnedProp = (0, _reducers.getLayerHoverProp)({
            interactionConfig: interactionConfig,
            hoverInfo: clicked,
            layers: layers,
            layersToRender: layersToRender,
            datasets: datasets
          });

          if (layerHoverProp && layerPinnedProp) {
            layerHoverProp.primaryData = layerPinnedProp.data;
            layerHoverProp.compareType = interactionConfig.tooltip.config.compareType;
          }
        }

        var commonProp = {
          onClose: this._onCloseMapPopover,
          zoom: mapState.zoom,
          container: this._deck ? this._deck.canvas : undefined
        };
        return /*#__PURE__*/_react["default"].createElement(_errorBoundary["default"], null, layerPinnedProp && /*#__PURE__*/_react["default"].createElement(MapPopover, (0, _extends2["default"])({}, pinnedPosition, commonProp, {
          layerHoverProp: layerPinnedProp,
          coordinate: interactionConfig.coordinate.enabled && (pinned || {}).coordinate,
          frozen: true,
          isBase: compareMode
        })), layerHoverProp && (!layerPinnedProp || compareMode) && /*#__PURE__*/_react["default"].createElement(MapPopover, (0, _extends2["default"])({
          x: mousePosition[0],
          y: mousePosition[1]
        }, commonProp, {
          layerHoverProp: layerHoverProp,
          frozen: false,
          coordinate: interactionConfig.coordinate.enabled && coordinate
        })));
      }
      /* eslint-enable complexity */

    }, {
      key: "_getHoverXY",
      value: function _getHoverXY(viewport, lngLat) {
        var screenCoord = !viewport || !lngLat ? null : viewport.project(lngLat);
        return screenCoord && {
          x: screenCoord[0],
          y: screenCoord[1]
        };
      }
    }, {
      key: "_renderDeckOverlay",
      value: function _renderDeckOverlay(layersForDeck) {
        var _this2 = this;

        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
          primaryMap: false
        };
        var _this$props4 = this.props,
            mapState = _this$props4.mapState,
            mapStyle = _this$props4.mapStyle,
            visState = _this$props4.visState,
            visStateActions = _this$props4.visStateActions,
            mapboxApiAccessToken = _this$props4.mapboxApiAccessToken,
            mapboxApiUrl = _this$props4.mapboxApiUrl,
            deckGlProps = _this$props4.deckGlProps,
            index = _this$props4.index;
        var deckGlLayers = (0, _reducers.computeDeckLayers)({
          visState: visState,
          mapState: mapState,
          mapStyle: mapStyle
        }, {
          mapIndex: index,
          primaryMap: options.primaryMap,
          mapboxApiAccessToken: mapboxApiAccessToken,
          mapboxApiUrl: mapboxApiUrl,
          layersForDeck: layersForDeck
        }, this._onLayerSetDomain, deckGlProps);
        var views = deckGlProps !== null && deckGlProps !== void 0 && deckGlProps.views ? deckGlProps === null || deckGlProps === void 0 ? void 0 : deckGlProps.views() : new _core.MapView({
          legacyMeterSizes: true
        });
        return /*#__PURE__*/_react["default"].createElement(_react2["default"], (0, _extends2["default"])({
          id: "default-deckgl-overlay"
        }, deckGlProps, {
          views: views,
          layers: deckGlLayers,
          controller: true,
          viewState: mapState,
          onBeforeRender: this._onBeforeRender,
          onHover: visStateActions.onLayerHover,
          onClick: visStateActions.onLayerClick,
          onError: this._onDeckError,
          ref: function ref(comp) {
            if (comp && comp.deck && !_this2._deck) {
              _this2._deck = comp.deck;
            }
          },
          onWebGLInitialized: function onWebGLInitialized(gl) {
            return _this2._onDeckInitialized(gl);
          }
        }));
      }
    }, {
      key: "_updateMapboxLayers",
      value: function _updateMapboxLayers() {
        var mapboxLayers = this.mapboxLayersSelector(this.props);

        if (!Object.keys(mapboxLayers).length && !Object.keys(this.previousLayers).length) {
          return;
        }

        (0, _layers.updateMapboxLayers)(this._map, mapboxLayers, this.previousLayers);
        this.previousLayers = mapboxLayers;
      }
    }, {
      key: "_renderMapboxOverlays",
      value: function _renderMapboxOverlays() {
        if (this._map && this._map.isStyleLoaded()) {
          this._updateMapboxLayers();
        }
      }
    }, {
      key: "_renderDrawEditor",
      value: function _renderDrawEditor() {
        var _this$props5 = this.props,
            visState = _this$props5.visState,
            mapControls = _this$props5.mapControls,
            visStateActions = _this$props5.visStateActions,
            index = _this$props5.index;
        var layers = visState.layers,
            datasets = visState.datasets,
            editor = visState.editor;
        var isEdit = mapControls.mapDraw ? mapControls.mapDraw.active : false;
        var layersToRender = this.layersToRenderSelector(this.props);
        return /*#__PURE__*/_react["default"].createElement(Editor, {
          index: index,
          datasets: datasets,
          editor: editor,
          filters: this.polygonFilters(this.props),
          isEnabled: isEdit,
          layers: layers,
          layersToRender: layersToRender,
          onDeleteFeature: visStateActions.deleteFeature,
          onSelect: visStateActions.setSelectedFeature,
          onUpdate: visStateActions.setFeatures,
          onTogglePolygonFilter: visStateActions.setPolygonFilterLayer,
          style: {
            pointerEvents: isEdit ? 'all' : 'none',
            position: 'absolute',
            display: editor.visible ? 'block' : 'none'
          }
        });
      }
    }, {
      key: "_renderMap",
      value:
      /* eslint-disable complexity */
      function _renderMap() {
        var _mapStyle$mapStyles;

        var _this$props6 = this.props,
            visState = _this$props6.visState,
            mapState = _this$props6.mapState,
            mapStyle = _this$props6.mapStyle,
            mapStateActions = _this$props6.mapStateActions,
            _this$props6$MapCompo = _this$props6.MapComponent,
            MapComponent = _this$props6$MapCompo === void 0 ? _reactMapGl["default"] : _this$props6$MapCompo,
            mapboxApiAccessToken = _this$props6.mapboxApiAccessToken,
            mapboxApiUrl = _this$props6.mapboxApiUrl,
            mapControls = _this$props6.mapControls,
            isExport = _this$props6.isExport,
            locale = _this$props6.locale,
            uiStateActions = _this$props6.uiStateActions,
            visStateActions = _this$props6.visStateActions,
            index = _this$props6.index,
            primary = _this$props6.primary,
            bottomMapContainerProps = _this$props6.bottomMapContainerProps,
            topMapContainerProps = _this$props6.topMapContainerProps;
        var layers = visState.layers,
            datasets = visState.datasets,
            editor = visState.editor,
            interactionConfig = visState.interactionConfig,
            hoverInfo = visState.hoverInfo;
        var layersToRender = this.layersToRenderSelector(this.props);
        var layersForDeck = this.layersForDeckSelector(this.props); // Current style can be a custom style, from which we pull the mapbox API acccess token

        var currentStyle = (_mapStyle$mapStyles = mapStyle.mapStyles) === null || _mapStyle$mapStyles === void 0 ? void 0 : _mapStyle$mapStyles[mapStyle.styleType];

        var mapProps = _objectSpread(_objectSpread({}, mapState), {}, {
          width: '100%',
          height: '100%',
          preserveDrawingBuffer: true,
          mapboxApiAccessToken: (currentStyle === null || currentStyle === void 0 ? void 0 : currentStyle.accessToken) || mapboxApiAccessToken,
          mapboxApiUrl: mapboxApiUrl,
          onViewportChange: this._onViewportChange,
          transformRequest: _utils.transformRequest
        });

        var hasGeocoderLayer = Boolean(layers.find(function (l) {
          return l.id === _constants.GEOCODER_LAYER_ID;
        }));
        var isSplit = Boolean(mapState.isSplit);
        return /*#__PURE__*/_react["default"].createElement(_react["default"].Fragment, null, /*#__PURE__*/_react["default"].createElement(MapControl, {
          datasets: datasets,
          availableLocales: LOCALE_CODES_ARRAY,
          dragRotate: mapState.dragRotate,
          isSplit: isSplit,
          primary: primary,
          isExport: isExport,
          layers: layers,
          layersToRender: layersToRender,
          mapIndex: index,
          mapControls: mapControls,
          readOnly: this.props.readOnly,
          scale: mapState.scale || 1,
          top: interactionConfig.geocoder && interactionConfig.geocoder.enabled ? 52 : 0,
          editor: editor,
          locale: locale,
          onTogglePerspective: mapStateActions.togglePerspective,
          onToggleSplitMap: mapStateActions.toggleSplitMap,
          onMapToggleLayer: this._handleMapToggleLayer,
          onToggleMapControl: this._toggleMapControl,
          onSetEditorMode: visStateActions.setEditorMode,
          onSetLocale: uiStateActions.setLocale,
          onToggleEditorVisibility: visStateActions.toggleEditorVisibility,
          mapHeight: mapState.height
        }), /*#__PURE__*/_react["default"].createElement(MapComponent, (0, _extends2["default"])({
          key: "bottom"
        }, mapProps, {
          mapStyle: mapStyle.bottomMapStyle
        }, bottomMapContainerProps, {
          ref: this._setMapboxMap,
          getCursor: hoverInfo ? function () {
            return 'pointer';
          } : undefined,
          onMouseMove: this.props.visStateActions.onMouseMove
        }), this._renderDeckOverlay(layersForDeck, {
          primaryMap: true
        }), this._renderMapboxOverlays(), this._renderDrawEditor()), mapStyle.topMapStyle || hasGeocoderLayer ? /*#__PURE__*/_react["default"].createElement("div", {
          style: MAP_STYLE.top
        }, /*#__PURE__*/_react["default"].createElement(MapComponent, (0, _extends2["default"])({
          key: "top"
        }, mapProps, {
          mapStyle: mapStyle.topMapStyle
        }, topMapContainerProps), this._renderDeckOverlay((0, _defineProperty2["default"])({}, _constants.GEOCODER_LAYER_ID, hasGeocoderLayer)))) : null, this._renderMapPopover(), !isSplit || index === 1 ? /*#__PURE__*/_react["default"].createElement(Attribution, {
          showMapboxLogo: this.state.showMapboxAttribution
        }) : null);
      }
    }, {
      key: "render",
      value: function render() {
        var mapStyle = this.props.mapStyle;
        return /*#__PURE__*/_react["default"].createElement(_styledComponents.StyledMapContainer, {
          ref: this._ref,
          style: MAP_STYLE.container
        }, mapStyle.bottomMapStyle && this._renderMap());
      }
    }]);
    return MapContainer;
  }(_react.Component);

  (0, _defineProperty2["default"])(MapContainer, "defaultProps", {
    MapComponent: _reactMapGl["default"],
    deckGlProps: {},
    index: 0,
    primary: true
  });
  return MapContainer;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9tYXAtY29udGFpbmVyLnRzeCJdLCJuYW1lcyI6WyJNQVBfU1RZTEUiLCJjb250YWluZXIiLCJkaXNwbGF5IiwicG9zaXRpb24iLCJ3aWR0aCIsImhlaWdodCIsInRvcCIsInBvaW50ZXJFdmVudHMiLCJMT0NBTEVfQ09ERVNfQVJSQVkiLCJPYmplY3QiLCJrZXlzIiwiTE9DQUxFX0NPREVTIiwiTUFQQk9YR0xfU1RZTEVfVVBEQVRFIiwiTUFQQk9YR0xfUkVOREVSIiwibm9wIiwiTWFwYm94TG9nbyIsIkF0dHJpYnV0aW9uIiwic2hvd01hcGJveExvZ28iLCJpc1BhbG0iLCJicmVha1BvaW50VmFsdWVzIiwibWVtb2l6ZWRDb21wb25lbnRzIiwiTWFwQ29udGFpbmVyRmFjdG9yeSIsImRlcHMiLCJNYXBQb3BvdmVyRmFjdG9yeSIsIk1hcENvbnRyb2xGYWN0b3J5IiwiRWRpdG9yRmFjdG9yeSIsIk1hcFBvcG92ZXIiLCJNYXBDb250cm9sIiwiRWRpdG9yIiwiTWFwQ29udGFpbmVyIiwicHJvcHMiLCJzaG93TWFwYm94QXR0cmlidXRpb24iLCJkaW1lbnNpb25zIiwicHJpbWFyeSIsIm1hcFN0YXRlQWN0aW9ucyIsInVwZGF0ZU1hcCIsInZpc1N0YXRlIiwibGF5ZXJzIiwibGF5ZXJEYXRhIiwic3BsaXRNYXBzIiwiaW5kZXgiLCJzcGxpdE1hcFNlbGVjdG9yIiwic3BsaXRNYXBJbmRleFNlbGVjdG9yIiwiZ2V0TWFwTGF5ZXJzRnJvbVNwbGl0TWFwcyIsImxheWVyT3JkZXIiLCJsYXllcnNTZWxlY3RvciIsImxheWVyRGF0YVNlbGVjdG9yIiwibWFwTGF5ZXJzU2VsZWN0b3IiLCJwcmVwYXJlTGF5ZXJzVG9SZW5kZXIiLCJwcmVwYXJlTGF5ZXJzRm9yRGVjayIsImZpbHRlcnMiLCJmaWx0ZXJzU2VsZWN0b3IiLCJmaWx0ZXIiLCJmIiwidHlwZSIsIkZJTFRFUl9UWVBFUyIsInBvbHlnb24iLCJsYXllck9yZGVyU2VsZWN0b3IiLCJsYXllcnNUb1JlbmRlclNlbGVjdG9yIiwiZ2VuZXJhdGVNYXBib3hMYXllcnMiLCJ2aXNTdGF0ZUFjdGlvbnMiLCJvbkxheWVyQ2xpY2siLCJpZHgiLCJjb2xvckRvbWFpbiIsImxheWVyQ29uZmlnQ2hhbmdlIiwibGF5ZXJJZCIsIm1hcEluZGV4IiwidG9nZ2xlTGF5ZXJGb3JNYXAiLCJ1cGRhdGUiLCJwcmV2aW91c0xheWVycyIsIl91cGRhdGVNYXBib3hMYXllcnMiLCJzdHlsZSIsInNldFN0YXRlIiwib25NYXBTdHlsZUxvYWRlZCIsIl9tYXAiLCJtYXBib3giLCJnZXRNYXAiLCJvbiIsIl9vbk1hcGJveFN0eWxlVXBkYXRlIiwib25NYXBSZW5kZXIiLCJnZXRNYXBib3hSZWYiLCJnbCIsImxheWVyQmxlbmRpbmciLCJlcnJvciIsImxheWVyIiwiZXJyb3JNZXNzYWdlIiwibWVzc2FnZSIsImlkIiwibm90aWZpY2F0aW9uSWQiLCJsYXN0U2hvd24iLCJfZGVja0dMRXJyb3JzRWxhcHNlZCIsIkRhdGUiLCJub3ciLCJUSFJPVFRMRV9OT1RJRklDQVRJT05fVElNRSIsInVpU3RhdGVBY3Rpb25zIiwiYWRkTm90aWZpY2F0aW9uIiwidmlld1N0YXRlIiwib25WaWV3U3RhdGVDaGFuZ2UiLCJwYW5lbElkIiwidG9nZ2xlTWFwQ29udHJvbCIsIk51bWJlciIsIl9yZWYiLCJjdXJyZW50IiwiX2hhbmRsZVJlc2l6ZSIsIm9mZiIsIm9uRGVja0luaXRpYWxpemVkIiwiX2RlY2siLCJtYXBTdGF0ZSIsImhvdmVySW5mbyIsImNsaWNrZWQiLCJkYXRhc2V0cyIsImludGVyYWN0aW9uQ29uZmlnIiwibW91c2VQb3MiLCJtb3VzZVBvc2l0aW9uIiwiY29vcmRpbmF0ZSIsInBpbm5lZCIsImxheWVyc1RvUmVuZGVyIiwidG9vbHRpcCIsImxheWVySG92ZXJQcm9wIiwiY29tcGFyZU1vZGUiLCJjb25maWciLCJwaW5uZWRQb3NpdGlvbiIsImxheWVyUGlubmVkUHJvcCIsInZpZXdwb3J0IiwiV2ViTWVyY2F0b3JWaWV3cG9ydCIsImxuZ0xhdCIsIl9nZXRIb3ZlclhZIiwicHJpbWFyeURhdGEiLCJkYXRhIiwiY29tcGFyZVR5cGUiLCJjb21tb25Qcm9wIiwib25DbG9zZSIsIl9vbkNsb3NlTWFwUG9wb3ZlciIsInpvb20iLCJjYW52YXMiLCJ1bmRlZmluZWQiLCJlbmFibGVkIiwic2NyZWVuQ29vcmQiLCJwcm9qZWN0IiwieCIsInkiLCJsYXllcnNGb3JEZWNrIiwib3B0aW9ucyIsInByaW1hcnlNYXAiLCJtYXBTdHlsZSIsIm1hcGJveEFwaUFjY2Vzc1Rva2VuIiwibWFwYm94QXBpVXJsIiwiZGVja0dsUHJvcHMiLCJkZWNrR2xMYXllcnMiLCJfb25MYXllclNldERvbWFpbiIsInZpZXdzIiwiTWFwVmlldyIsImxlZ2FjeU1ldGVyU2l6ZXMiLCJfb25CZWZvcmVSZW5kZXIiLCJvbkxheWVySG92ZXIiLCJfb25EZWNrRXJyb3IiLCJjb21wIiwiZGVjayIsIl9vbkRlY2tJbml0aWFsaXplZCIsIm1hcGJveExheWVycyIsIm1hcGJveExheWVyc1NlbGVjdG9yIiwibGVuZ3RoIiwiaXNTdHlsZUxvYWRlZCIsIm1hcENvbnRyb2xzIiwiZWRpdG9yIiwiaXNFZGl0IiwibWFwRHJhdyIsImFjdGl2ZSIsInBvbHlnb25GaWx0ZXJzIiwiZGVsZXRlRmVhdHVyZSIsInNldFNlbGVjdGVkRmVhdHVyZSIsInNldEZlYXR1cmVzIiwic2V0UG9seWdvbkZpbHRlckxheWVyIiwidmlzaWJsZSIsIk1hcENvbXBvbmVudCIsIk1hcGJveEdMTWFwIiwiaXNFeHBvcnQiLCJsb2NhbGUiLCJib3R0b21NYXBDb250YWluZXJQcm9wcyIsInRvcE1hcENvbnRhaW5lclByb3BzIiwibGF5ZXJzRm9yRGVja1NlbGVjdG9yIiwiY3VycmVudFN0eWxlIiwibWFwU3R5bGVzIiwic3R5bGVUeXBlIiwibWFwUHJvcHMiLCJwcmVzZXJ2ZURyYXdpbmdCdWZmZXIiLCJhY2Nlc3NUb2tlbiIsIm9uVmlld3BvcnRDaGFuZ2UiLCJfb25WaWV3cG9ydENoYW5nZSIsInRyYW5zZm9ybVJlcXVlc3QiLCJoYXNHZW9jb2RlckxheWVyIiwiQm9vbGVhbiIsImZpbmQiLCJsIiwiR0VPQ09ERVJfTEFZRVJfSUQiLCJpc1NwbGl0IiwiZHJhZ1JvdGF0ZSIsInJlYWRPbmx5Iiwic2NhbGUiLCJnZW9jb2RlciIsInRvZ2dsZVBlcnNwZWN0aXZlIiwidG9nZ2xlU3BsaXRNYXAiLCJfaGFuZGxlTWFwVG9nZ2xlTGF5ZXIiLCJfdG9nZ2xlTWFwQ29udHJvbCIsInNldEVkaXRvck1vZGUiLCJzZXRMb2NhbGUiLCJ0b2dnbGVFZGl0b3JWaXNpYmlsaXR5IiwiYm90dG9tTWFwU3R5bGUiLCJfc2V0TWFwYm94TWFwIiwib25Nb3VzZU1vdmUiLCJfcmVuZGVyRGVja092ZXJsYXkiLCJfcmVuZGVyTWFwYm94T3ZlcmxheXMiLCJfcmVuZGVyRHJhd0VkaXRvciIsInRvcE1hcFN0eWxlIiwiX3JlbmRlck1hcFBvcG92ZXIiLCJzdGF0ZSIsIl9yZW5kZXJNYXAiLCJDb21wb25lbnQiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFxQkE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBTUE7O0FBQ0E7O0FBQ0E7O0FBRUE7O0FBR0E7O0FBT0E7O0FBV0E7O0FBR0E7O0FBTUE7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7Ozs7Ozs7QUFXQTtBQUNBLElBQU1BLFNBQStDLEdBQUc7QUFDdERDLEVBQUFBLFNBQVMsRUFBRTtBQUNUQyxJQUFBQSxPQUFPLEVBQUUsY0FEQTtBQUVUQyxJQUFBQSxRQUFRLEVBQUUsVUFGRDtBQUdUQyxJQUFBQSxLQUFLLEVBQUUsTUFIRTtBQUlUQyxJQUFBQSxNQUFNLEVBQUU7QUFKQyxHQUQyQztBQU90REMsRUFBQUEsR0FBRyxFQUFFO0FBQ0hILElBQUFBLFFBQVEsRUFBRSxVQURQO0FBRUhHLElBQUFBLEdBQUcsRUFBRSxLQUZGO0FBR0hDLElBQUFBLGFBQWEsRUFBRSxNQUhaO0FBSUhILElBQUFBLEtBQUssRUFBRSxNQUpKO0FBS0hDLElBQUFB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dGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMjIgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG4vLyBsaWJyYXJpZXNcbmltcG9ydCBSZWFjdCwge0NvbXBvbmVudCwgY3JlYXRlUmVmLCB1c2VNZW1vfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgTWFwYm94R0xNYXAsIHtNYXBSZWZ9IGZyb20gJ3JlYWN0LW1hcC1nbCc7XG5pbXBvcnQgRGVja0dMIGZyb20gJ0BkZWNrLmdsL3JlYWN0JztcbmltcG9ydCB7Y3JlYXRlU2VsZWN0b3IsIFNlbGVjdG9yfSBmcm9tICdyZXNlbGVjdCc7XG5pbXBvcnQgV2ViTWVyY2F0b3JWaWV3cG9ydCBmcm9tICd2aWV3cG9ydC1tZXJjYXRvci1wcm9qZWN0JztcbmltcG9ydCBtYXBib3hnbCBmcm9tICdtYXBib3gtZ2wnO1xuXG5pbXBvcnQge1Zpc1N0YXRlQWN0aW9ucywgTWFwU3RhdGVBY3Rpb25zLCBVSVN0YXRlQWN0aW9uc30gZnJvbSAnQGtlcGxlci5nbC9hY3Rpb25zJztcblxuLy8gY29tcG9uZW50c1xuaW1wb3J0IE1hcFBvcG92ZXJGYWN0b3J5IGZyb20gJy4vbWFwL21hcC1wb3BvdmVyJztcbmltcG9ydCBNYXBDb250cm9sRmFjdG9yeSBmcm9tICcuL21hcC9tYXAtY29udHJvbCc7XG5pbXBvcnQge1N0eWxlZE1hcENvbnRhaW5lciwgU3R5bGVkQXR0cmJ1dGlvbn0gZnJvbSAnLi9jb21tb24vc3R5bGVkLWNvbXBvbmVudHMnO1xuXG5pbXBvcnQgRWRpdG9yRmFjdG9yeSBmcm9tICcuL2VkaXRvci9lZGl0b3InO1xuXG4vLyB1dGlsc1xuaW1wb3J0IHtcbiAgZ2VuZXJhdGVNYXBib3hMYXllcnMsXG4gIHVwZGF0ZU1hcGJveExheWVycyxcbiAgTGF5ZXJCYXNlQ29uZmlnLFxuICBWaXN1YWxDaGFubmVsRG9tYWluXG59IGZyb20gJ0BrZXBsZXIuZ2wvbGF5ZXJzJztcbmltcG9ydCB7TWFwU3RhdGUsIE1hcENvbnRyb2xzLCBWaWV3cG9ydCwgU3BsaXRNYXAsIFNwbGl0TWFwTGF5ZXJzfSBmcm9tICdAa2VwbGVyLmdsL3R5cGVzJztcbmltcG9ydCB7XG4gIGVycm9yTm90aWZpY2F0aW9uLFxuICBzZXRMYXllckJsZW5kaW5nLFxuICBpc1N0eWxlVXNpbmdNYXBib3hUaWxlcyxcbiAgdHJhbnNmb3JtUmVxdWVzdCxcbiAgb2JzZXJ2ZURpbWVuc2lvbnMsXG4gIHVub2JzZXJ2ZURpbWVuc2lvbnMsXG4gIGhhc01vYmlsZVdpZHRoLFxuICBnZXRNYXBMYXllcnNGcm9tU3BsaXRNYXBzLFxuICBvblZpZXdQb3J0Q2hhbmdlXG59IGZyb20gJ0BrZXBsZXIuZ2wvdXRpbHMnO1xuaW1wb3J0IHticmVha1BvaW50VmFsdWVzfSBmcm9tICdAa2VwbGVyLmdsL3N0eWxlcyc7XG5cbi8vIGRlZmF1bHQtc2V0dGluZ3NcbmltcG9ydCB7XG4gIEZJTFRFUl9UWVBFUyxcbiAgR0VPQ09ERVJfTEFZRVJfSUQsXG4gIFRIUk9UVExFX05PVElGSUNBVElPTl9USU1FXG59IGZyb20gJ0BrZXBsZXIuZ2wvY29uc3RhbnRzJztcblxuaW1wb3J0IEVycm9yQm91bmRhcnkgZnJvbSAnLi9jb21tb24vZXJyb3ItYm91bmRhcnknO1xuaW1wb3J0IHtMT0NBTEVfQ09ERVN9IGZyb20gJ0BrZXBsZXIuZ2wvbG9jYWxpemF0aW9uJztcbmltcG9ydCB7TWFwVmlld30gZnJvbSAnQGRlY2suZ2wvY29yZSc7XG5pbXBvcnQge1xuICBNYXBTdHlsZSxcbiAgY29tcHV0ZURlY2tMYXllcnMsXG4gIGdldExheWVySG92ZXJQcm9wLFxuICBMYXllckhvdmVyUHJvcCxcbiAgcHJlcGFyZUxheWVyc0ZvckRlY2ssXG4gIHByZXBhcmVMYXllcnNUb1JlbmRlcixcbiAgTGF5ZXJzVG9SZW5kZXJcbn0gZnJvbSAnQGtlcGxlci5nbC9yZWR1Y2Vycyc7XG5pbXBvcnQge1Zpc1N0YXRlfSBmcm9tICdAa2VwbGVyLmdsL3NjaGVtYXMnO1xuXG4vKiogQHR5cGUge3tba2V5OiBzdHJpbmddOiBSZWFjdC5DU1NQcm9wZXJ0aWVzfX0gKi9cbmNvbnN0IE1BUF9TVFlMRToge1trZXk6IHN0cmluZ106IFJlYWN0LkNTU1Byb3BlcnRpZXN9ID0ge1xuICBjb250YWluZXI6IHtcbiAgICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJyxcbiAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICB3aWR0aDogJzEwMCUnLFxuICAgIGhlaWdodDogJzEwMCUnXG4gIH0sXG4gIHRvcDoge1xuICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgIHRvcDogJzBweCcsXG4gICAgcG9pbnRlckV2ZW50czogJ25vbmUnLFxuICAgIHdpZHRoOiAnMTAwJScsXG4gICAgaGVpZ2h0OiAnMTAwJSdcbiAgfVxufTtcblxuY29uc3QgTE9DQUxFX0NPREVTX0FSUkFZID0gT2JqZWN0LmtleXMoTE9DQUxFX0NPREVTKTtcblxuY29uc3QgTUFQQk9YR0xfU1RZTEVfVVBEQVRFID0gJ3N0eWxlLmxvYWQnO1xuY29uc3QgTUFQQk9YR0xfUkVOREVSID0gJ3JlbmRlcic7XG5jb25zdCBub3AgPSAoKSA9PiB7fTtcblxuY29uc3QgTWFwYm94TG9nbyA9ICgpID0+IChcbiAgPGRpdiBjbGFzc05hbWU9XCJhdHRyaXRpb24tbG9nb1wiPlxuICAgIEJhc2VtYXAgYnk6XG4gICAgPGFcbiAgICAgIGNsYXNzTmFtZT1cIm1hcGJveGdsLWN0cmwtbG9nb1wiXG4gICAgICB0YXJnZXQ9XCJfYmxhbmtcIlxuICAgICAgcmVsPVwibm9vcGVuZXIgbm9yZWZlcnJlclwiXG4gICAgICBocmVmPVwiaHR0cHM6Ly93d3cubWFwYm94LmNvbS9cIlxuICAgICAgYXJpYS1sYWJlbD1cIk1hcGJveCBsb2dvXCJcbiAgICAvPlxuICA8L2Rpdj5cbik7XG5cbmV4cG9ydCBjb25zdCBBdHRyaWJ1dGlvbiA9ICh7c2hvd01hcGJveExvZ28gPSB0cnVlfSkgPT4ge1xuICBjb25zdCBpc1BhbG0gPSBoYXNNb2JpbGVXaWR0aChicmVha1BvaW50VmFsdWVzKTtcblxuICBjb25zdCBtZW1vaXplZENvbXBvbmVudHMgPSB1c2VNZW1vKCgpID0+IHtcbiAgICBpZiAoIXNob3dNYXBib3hMb2dvKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICA8U3R5bGVkQXR0cmJ1dGlvbj5cbiAgICAgICAgICA8YVxuICAgICAgICAgICAgaHJlZj1cImh0dHA6Ly93d3cub3BlbnN0cmVldG1hcC5vcmcvY29weXJpZ2h0XCJcbiAgICAgICAgICAgIHRhcmdldD1cIl9ibGFua1wiXG4gICAgICAgICAgICByZWw9XCJub29wZW5lciBub3JlZmVycmVyXCJcbiAgICAgICAgICA+XG4gICAgICAgICAgICDCqSBPcGVuU3RyZWV0TWFwXG4gICAgICAgICAgPC9hPlxuICAgICAgICA8L1N0eWxlZEF0dHJidXRpb24+XG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICA8U3R5bGVkQXR0cmJ1dGlvbj5cbiAgICAgICAge2lzUGFsbSA/IDxNYXBib3hMb2dvIC8+IDogbnVsbH1cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJhdHRyaXRpb24tbGlua1wiPlxuICAgICAgICAgIDxhIGhyZWY9XCJodHRwczovL2tlcGxlci5nbC9wb2xpY3kvXCIgdGFyZ2V0PVwiX2JsYW5rXCIgcmVsPVwibm9vcGVuZXIgbm9yZWZlcnJlclwiPlxuICAgICAgICAgICAgwqkga2VwbGVyLmdsIHx7JyAnfVxuICAgICAgICAgIDwvYT5cbiAgICAgICAgICA8YSBocmVmPVwiaHR0cHM6Ly93d3cubWFwYm94LmNvbS9hYm91dC9tYXBzL1wiIHRhcmdldD1cIl9ibGFua1wiIHJlbD1cIm5vb3BlbmVyIG5vcmVmZXJyZXJcIj5cbiAgICAgICAgICAgIMKpIE1hcGJveCB8eycgJ31cbiAgICAgICAgICA8L2E+XG4gICAgICAgICAgPGFcbiAgICAgICAgICAgIGhyZWY9XCJodHRwOi8vd3d3Lm9wZW5zdHJlZXRtYXAub3JnL2NvcHlyaWdodFwiXG4gICAgICAgICAgICB0YXJnZXQ9XCJfYmxhbmtcIlxuICAgICAgICAgICAgcmVsPVwibm9vcGVuZXIgbm9yZWZlcnJlclwiXG4gICAgICAgICAgPlxuICAgICAgICAgICAgwqkgT3BlblN0cmVldE1hcCB8eycgJ31cbiAgICAgICAgICA8L2E+XG4gICAgICAgICAgPGEgaHJlZj1cImh0dHBzOi8vd3d3Lm1hcGJveC5jb20vbWFwLWZlZWRiYWNrL1wiIHRhcmdldD1cIl9ibGFua1wiIHJlbD1cIm5vb3BlbmVyIG5vcmVmZXJyZXJcIj5cbiAgICAgICAgICAgIDxzdHJvbmc+SW1wcm92ZSB0aGlzIG1hcCA8L3N0cm9uZz5cbiAgICAgICAgICAgIHshaXNQYWxtID8gPHN0cm9uZz4gfCA8L3N0cm9uZz4gOiBudWxsfVxuICAgICAgICAgIDwvYT5cbiAgICAgICAgICB7IWlzUGFsbSA/IDxNYXBib3hMb2dvIC8+IDogbnVsbH1cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L1N0eWxlZEF0dHJidXRpb24+XG4gICAgKTtcbiAgfSwgW3Nob3dNYXBib3hMb2dvLCBpc1BhbG1dKTtcblxuICByZXR1cm4gbWVtb2l6ZWRDb21wb25lbnRzO1xufTtcblxuTWFwQ29udGFpbmVyRmFjdG9yeS5kZXBzID0gW01hcFBvcG92ZXJGYWN0b3J5LCBNYXBDb250cm9sRmFjdG9yeSwgRWRpdG9yRmFjdG9yeV07XG5cbnR5cGUgTWFwYm94U3R5bGUgPSBzdHJpbmcgfCBvYmplY3QgfCB1bmRlZmluZWQ7XG50eXBlIFByb3BTZWxlY3RvcjxSPiA9IFNlbGVjdG9yPE1hcENvbnRhaW5lclByb3BzLCBSPjtcblxuaW50ZXJmYWNlIE1hcENvbnRhaW5lclByb3BzIHtcbiAgdmlzU3RhdGU6IFZpc1N0YXRlO1xuICBtYXBTdGF0ZTogTWFwU3RhdGU7XG4gIG1hcENvbnRyb2xzOiBNYXBDb250cm9scztcbiAgbWFwU3R5bGU6IHtib3R0b21NYXBTdHlsZT86IE1hcGJveFN0eWxlOyB0b3BNYXBTdHlsZT86IE1hcGJveFN0eWxlfSAmIE1hcFN0eWxlO1xuICBtYXBib3hBcGlBY2Nlc3NUb2tlbjogc3RyaW5nO1xuICBtYXBib3hBcGlVcmw6IHN0cmluZztcbiAgdmlzU3RhdGVBY3Rpb25zOiB0eXBlb2YgVmlzU3RhdGVBY3Rpb25zO1xuICBtYXBTdGF0ZUFjdGlvbnM6IHR5cGVvZiBNYXBTdGF0ZUFjdGlvbnM7XG4gIHVpU3RhdGVBY3Rpb25zOiB0eXBlb2YgVUlTdGF0ZUFjdGlvbnM7XG5cbiAgLy8gb3B0aW9uYWxcbiAgcHJpbWFyeT86IGJvb2xlYW47IC8vIHByaW1hcnkgb25lIHdpbGwgYmUgcmVwb3J0aW5nIGl0cyBzaXplIHRvIGFwcFN0YXRlXG4gIHJlYWRPbmx5PzogYm9vbGVhbjtcbiAgaXNFeHBvcnQ/OiBib29sZWFuO1xuICBvbk1hcFRvZ2dsZUxheWVyPzogRnVuY3Rpb247XG4gIG9uTWFwU3R5bGVMb2FkZWQ/OiBGdW5jdGlvbjtcbiAgb25NYXBSZW5kZXI/OiBGdW5jdGlvbjtcbiAgZ2V0TWFwYm94UmVmPzogKG1hcGJveD86IE1hcFJlZiB8IG51bGwsIGluZGV4PzogbnVtYmVyKSA9PiB2b2lkO1xuICBpbmRleD86IG51bWJlcjtcblxuICBsb2NhbGU/OiBhbnk7XG4gIGVkaXRvcj86IGFueTtcbiAgTWFwQ29tcG9uZW50PzogdHlwZW9mIE1hcGJveEdMTWFwO1xuICBkZWNrR2xQcm9wcz86IGFueTtcbiAgb25EZWNrSW5pdGlhbGl6ZWQ/OiAoYTogYW55LCBiOiBhbnkpID0+IHZvaWQ7XG4gIG9uVmlld1N0YXRlQ2hhbmdlPzogKHZpZXdwb3J0OiBWaWV3cG9ydCkgPT4gdm9pZDtcblxuICB0b3BNYXBDb250YWluZXJQcm9wczogYW55O1xuICBib3R0b21NYXBDb250YWluZXJQcm9wczogYW55O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBNYXBDb250YWluZXJGYWN0b3J5KFxuICBNYXBQb3BvdmVyLFxuICBNYXBDb250cm9sLFxuICBFZGl0b3Jcbik6IFJlYWN0LkNvbXBvbmVudFR5cGU8TWFwQ29udGFpbmVyUHJvcHM+IHtcbiAgY2xhc3MgTWFwQ29udGFpbmVyIGV4dGVuZHMgQ29tcG9uZW50PE1hcENvbnRhaW5lclByb3BzPiB7XG4gICAgZGlzcGxheU5hbWUgPSAnTWFwQ29udGFpbmVyJztcbiAgICBzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuICAgICAgTWFwQ29tcG9uZW50OiBNYXBib3hHTE1hcCxcbiAgICAgIGRlY2tHbFByb3BzOiB7fSxcbiAgICAgIGluZGV4OiAwLFxuICAgICAgcHJpbWFyeTogdHJ1ZVxuICAgIH07XG5cbiAgICBzdGF0ZSA9IHtcbiAgICAgIC8vIERldGVybWluZXMgd2hldGhlciBhdHRyaWJ1dGlvbiBzaG91bGQgYmUgdmlzaWJsZSBiYXNlZCB0aGUgcmVzdWx0IG9mIGxvYWRpbmcgdGhlIG1hcCBzdHlsZVxuICAgICAgc2hvd01hcGJveEF0dHJpYnV0aW9uOiB0cnVlXG4gICAgfTtcblxuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICBzdXBlcihwcm9wcyk7XG4gICAgfVxuXG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICBpZiAoIXRoaXMuX3JlZi5jdXJyZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIG9ic2VydmVEaW1lbnNpb25zKHRoaXMuX3JlZi5jdXJyZW50LCB0aGlzLl9oYW5kbGVSZXNpemUpO1xuICAgIH1cblxuICAgIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgLy8gdW5iaW5kIG1hcGJveGdsIGV2ZW50IGxpc3RlbmVyXG4gICAgICBpZiAodGhpcy5fbWFwKSB7XG4gICAgICAgIHRoaXMuX21hcD8ub2ZmKE1BUEJPWEdMX1NUWUxFX1VQREFURSwgbm9wKTtcbiAgICAgICAgdGhpcy5fbWFwPy5vZmYoTUFQQk9YR0xfUkVOREVSLCBub3ApO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLl9yZWYuY3VycmVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB1bm9ic2VydmVEaW1lbnNpb25zKHRoaXMuX3JlZi5jdXJyZW50KTtcbiAgICB9XG5cbiAgICBfZGVjazogYW55ID0gbnVsbDtcbiAgICBfbWFwOiBtYXBib3hnbC5NYXAgfCBudWxsID0gbnVsbDtcbiAgICBfcmVmID0gY3JlYXRlUmVmPEhUTUxEaXZFbGVtZW50PigpO1xuICAgIF9kZWNrR0xFcnJvcnNFbGFwc2VkOiB7W2lkOiBzdHJpbmddOiBudW1iZXJ9ID0ge307XG5cbiAgICBwcmV2aW91c0xheWVycyA9IHtcbiAgICAgIC8vIFtsYXllcnMuaWRdOiBtYXBib3hMYXllckNvbmZpZ1xuICAgIH07XG5cbiAgICBfaGFuZGxlUmVzaXplID0gZGltZW5zaW9ucyA9PiB7XG4gICAgICBjb25zdCB7cHJpbWFyeX0gPSB0aGlzLnByb3BzO1xuICAgICAgaWYgKHByaW1hcnkpIHtcbiAgICAgICAgY29uc3Qge21hcFN0YXRlQWN0aW9uc30gPSB0aGlzLnByb3BzO1xuICAgICAgICBpZiAoZGltZW5zaW9ucyAmJiBkaW1lbnNpb25zLndpZHRoID4gMCAmJiBkaW1lbnNpb25zLmhlaWdodCA+IDApIHtcbiAgICAgICAgICBtYXBTdGF0ZUFjdGlvbnMudXBkYXRlTWFwKGRpbWVuc2lvbnMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIGxheWVyc1NlbGVjdG9yOiBQcm9wU2VsZWN0b3I8VmlzU3RhdGVbJ2xheWVycyddPiA9IHByb3BzID0+IHByb3BzLnZpc1N0YXRlLmxheWVycztcbiAgICBsYXllckRhdGFTZWxlY3RvcjogUHJvcFNlbGVjdG9yPFZpc1N0YXRlWydsYXllcnMnXT4gPSBwcm9wcyA9PiBwcm9wcy52aXNTdGF0ZS5sYXllckRhdGE7XG4gICAgc3BsaXRNYXBTZWxlY3RvcjogUHJvcFNlbGVjdG9yPFNwbGl0TWFwW10+ID0gcHJvcHMgPT4gcHJvcHMudmlzU3RhdGUuc3BsaXRNYXBzO1xuICAgIHNwbGl0TWFwSW5kZXhTZWxlY3RvcjogUHJvcFNlbGVjdG9yPG51bWJlciB8IHVuZGVmaW5lZD4gPSBwcm9wcyA9PiBwcm9wcy5pbmRleDtcbiAgICBtYXBMYXllcnNTZWxlY3RvcjogUHJvcFNlbGVjdG9yPFNwbGl0TWFwTGF5ZXJzIHwgbnVsbCB8IHVuZGVmaW5lZD4gPSBjcmVhdGVTZWxlY3RvcihcbiAgICAgIHRoaXMuc3BsaXRNYXBTZWxlY3RvcixcbiAgICAgIHRoaXMuc3BsaXRNYXBJbmRleFNlbGVjdG9yLFxuICAgICAgZ2V0TWFwTGF5ZXJzRnJvbVNwbGl0TWFwc1xuICAgICk7XG4gICAgbGF5ZXJPcmRlclNlbGVjdG9yOiBQcm9wU2VsZWN0b3I8VmlzU3RhdGVbJ2xheWVyT3JkZXInXT4gPSBwcm9wcyA9PiBwcm9wcy52aXNTdGF0ZS5sYXllck9yZGVyO1xuICAgIGxheWVyc1RvUmVuZGVyU2VsZWN0b3I6IFByb3BTZWxlY3RvcjxMYXllcnNUb1JlbmRlcj4gPSBjcmVhdGVTZWxlY3RvcihcbiAgICAgIHRoaXMubGF5ZXJzU2VsZWN0b3IsXG4gICAgICB0aGlzLmxheWVyRGF0YVNlbGVjdG9yLFxuICAgICAgdGhpcy5tYXBMYXllcnNTZWxlY3RvcixcbiAgICAgIHByZXBhcmVMYXllcnNUb1JlbmRlclxuICAgICk7XG4gICAgbGF5ZXJzRm9yRGVja1NlbGVjdG9yID0gY3JlYXRlU2VsZWN0b3IoXG4gICAgICB0aGlzLmxheWVyc1NlbGVjdG9yLFxuICAgICAgdGhpcy5sYXllckRhdGFTZWxlY3RvcixcbiAgICAgIHByZXBhcmVMYXllcnNGb3JEZWNrXG4gICAgKTtcbiAgICBmaWx0ZXJzU2VsZWN0b3IgPSBwcm9wcyA9PiBwcm9wcy52aXNTdGF0ZS5maWx0ZXJzO1xuICAgIHBvbHlnb25GaWx0ZXJzID0gY3JlYXRlU2VsZWN0b3IodGhpcy5maWx0ZXJzU2VsZWN0b3IsIGZpbHRlcnMgPT5cbiAgICAgIGZpbHRlcnMuZmlsdGVyKGYgPT4gZi50eXBlID09PSBGSUxURVJfVFlQRVMucG9seWdvbilcbiAgICApO1xuXG4gICAgbWFwYm94TGF5ZXJzU2VsZWN0b3IgPSBjcmVhdGVTZWxlY3RvcihcbiAgICAgIHRoaXMubGF5ZXJzU2VsZWN0b3IsXG4gICAgICB0aGlzLmxheWVyRGF0YVNlbGVjdG9yLFxuICAgICAgdGhpcy5sYXllck9yZGVyU2VsZWN0b3IsXG4gICAgICB0aGlzLmxheWVyc1RvUmVuZGVyU2VsZWN0b3IsXG4gICAgICBnZW5lcmF0ZU1hcGJveExheWVyc1xuICAgICk7XG5cbiAgICAvKiBjb21wb25lbnQgcHJpdmF0ZSBmdW5jdGlvbnMgKi9cbiAgICBfb25DbG9zZU1hcFBvcG92ZXIgPSAoKSA9PiB7XG4gICAgICB0aGlzLnByb3BzLnZpc1N0YXRlQWN0aW9ucy5vbkxheWVyQ2xpY2sobnVsbCk7XG4gICAgfTtcblxuICAgIF9vbkxheWVyU2V0RG9tYWluID0gKGlkeDogbnVtYmVyLCBjb2xvckRvbWFpbjogVmlzdWFsQ2hhbm5lbERvbWFpbikgPT4ge1xuICAgICAgdGhpcy5wcm9wcy52aXNTdGF0ZUFjdGlvbnMubGF5ZXJDb25maWdDaGFuZ2UodGhpcy5wcm9wcy52aXNTdGF0ZS5sYXllcnNbaWR4XSwge1xuICAgICAgICBjb2xvckRvbWFpblxuICAgICAgfSBhcyBQYXJ0aWFsPExheWVyQmFzZUNvbmZpZz4pO1xuICAgIH07XG5cbiAgICBfaGFuZGxlTWFwVG9nZ2xlTGF5ZXIgPSBsYXllcklkID0+IHtcbiAgICAgIGNvbnN0IHtpbmRleDogbWFwSW5kZXggPSAwLCB2aXNTdGF0ZUFjdGlvbnN9ID0gdGhpcy5wcm9wcztcbiAgICAgIHZpc1N0YXRlQWN0aW9ucy50b2dnbGVMYXllckZvck1hcChtYXBJbmRleCwgbGF5ZXJJZCk7XG4gICAgfTtcblxuICAgIF9vbk1hcGJveFN0eWxlVXBkYXRlID0gdXBkYXRlID0+IHtcbiAgICAgIC8vIGZvcmNlIHJlZnJlc2ggbWFwYm94Z2wgbGF5ZXJzXG4gICAgICB0aGlzLnByZXZpb3VzTGF5ZXJzID0ge307XG4gICAgICB0aGlzLl91cGRhdGVNYXBib3hMYXllcnMoKTtcblxuICAgICAgaWYgKHVwZGF0ZSAmJiB1cGRhdGUuc3R5bGUpIHtcbiAgICAgICAgLy8gTm8gYXR0cmlidXRpb25zIGFyZSBuZWVkZWQgaWYgdGhlIHN0eWxlIGRvZXNuJ3QgcmVmZXJlbmNlIE1hcGJveCBzb3VyY2VzXG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe3Nob3dNYXBib3hBdHRyaWJ1dGlvbjogaXNTdHlsZVVzaW5nTWFwYm94VGlsZXModXBkYXRlLnN0eWxlKX0pO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHRoaXMucHJvcHMub25NYXBTdHlsZUxvYWRlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLnByb3BzLm9uTWFwU3R5bGVMb2FkZWQodGhpcy5fbWFwKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3NldE1hcGJveE1hcDogUmVhY3QuUmVmPE1hcFJlZj4gPSBtYXBib3ggPT4ge1xuICAgICAgaWYgKCF0aGlzLl9tYXAgJiYgbWFwYm94KSB7XG4gICAgICAgIHRoaXMuX21hcCA9IG1hcGJveC5nZXRNYXAoKTtcbiAgICAgICAgLy8gaSBub3RpY2VkIGluIGNlcnRhaW4gY29udGV4dCB3ZSBkb24ndCBhY2Nlc3MgdGhlIGFjdHVhbCBtYXAgZWxlbWVudFxuICAgICAgICBpZiAoIXRoaXMuX21hcCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBiaW5kIG1hcGJveGdsIGV2ZW50IGxpc3RlbmVyXG4gICAgICAgIHRoaXMuX21hcC5vbihNQVBCT1hHTF9TVFlMRV9VUERBVEUsIHRoaXMuX29uTWFwYm94U3R5bGVVcGRhdGUpO1xuXG4gICAgICAgIHRoaXMuX21hcC5vbihNQVBCT1hHTF9SRU5ERVIsICgpID0+IHtcbiAgICAgICAgICBpZiAodHlwZW9mIHRoaXMucHJvcHMub25NYXBSZW5kZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRoaXMucHJvcHMub25NYXBSZW5kZXIodGhpcy5fbWFwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5wcm9wcy5nZXRNYXBib3hSZWYpIHtcbiAgICAgICAgLy8gVGhlIHBhcmVudCBjb21wb25lbnQgY2FuIGdhaW4gYWNjZXNzIHRvIG91ciBNYXBib3hHbE1hcCBieVxuICAgICAgICAvLyBwcm92aWRpbmcgdGhpcyBjYWxsYmFjay4gTm90ZSB0aGF0ICdtYXBib3gnIHdpbGwgYmUgbnVsbCB3aGVuIHRoZVxuICAgICAgICAvLyByZWYgaXMgdW5zZXQgKGUuZy4gd2hlbiBhIHNwbGl0IG1hcCBpcyBjbG9zZWQpLlxuICAgICAgICB0aGlzLnByb3BzLmdldE1hcGJveFJlZihtYXBib3gsIHRoaXMucHJvcHMuaW5kZXgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfb25EZWNrSW5pdGlhbGl6ZWQoZ2wpIHtcbiAgICAgIGlmICh0aGlzLnByb3BzLm9uRGVja0luaXRpYWxpemVkKSB7XG4gICAgICAgIHRoaXMucHJvcHMub25EZWNrSW5pdGlhbGl6ZWQodGhpcy5fZGVjaywgZ2wpO1xuICAgICAgfVxuICAgIH1cblxuICAgIF9vbkJlZm9yZVJlbmRlciA9ICh7Z2x9KSA9PiB7XG4gICAgICBzZXRMYXllckJsZW5kaW5nKGdsLCB0aGlzLnByb3BzLnZpc1N0YXRlLmxheWVyQmxlbmRpbmcpO1xuICAgIH07XG5cbiAgICBfb25EZWNrRXJyb3IgPSAoZXJyb3IsIGxheWVyKSA9PiB7XG4gICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBgQW4gZXJyb3IgaW4gZGVjay5nbDogJHtlcnJvci5tZXNzYWdlfSBpbiAke2xheWVyLmlkfWA7XG4gICAgICBjb25zdCBub3RpZmljYXRpb25JZCA9IGAke2xheWVyLmlkfS0ke2Vycm9yLm1lc3NhZ2V9YDtcblxuICAgICAgLy8gVGhyb3R0bGUgZXJyb3Igbm90aWZpY2F0aW9ucywgYXMgUmVhY3QgZG9lc24ndCBsaWtlIHRvbyBtYW55IHN0YXRlIGNoYW5nZXMgZnJvbSBoZXJlLlxuICAgICAgY29uc3QgbGFzdFNob3duID0gdGhpcy5fZGVja0dMRXJyb3JzRWxhcHNlZFtub3RpZmljYXRpb25JZF07XG4gICAgICBpZiAoIWxhc3RTaG93biB8fCBsYXN0U2hvd24gPCBEYXRlLm5vdygpIC0gVEhST1RUTEVfTk9USUZJQ0FUSU9OX1RJTUUpIHtcbiAgICAgICAgdGhpcy5fZGVja0dMRXJyb3JzRWxhcHNlZFtub3RpZmljYXRpb25JZF0gPSBEYXRlLm5vdygpO1xuXG4gICAgICAgIC8vIENyZWF0ZSBuZXcgZXJyb3Igbm90aWZpY2F0aW9uIG9yIHVwZGF0ZSBleGlzdGluZyBvbmUgd2l0aCBzYW1lIGlkLlxuICAgICAgICAvLyBVcGRhdGUgaXMgcmVxdWlyZWQgdG8gcHJlc2VydmUgdGhlIG9yZGVyIG9mIG5vdGlmaWNhdGlvbnMgYXMgdGhleSBwcm9iYWJseSBhcmUgZ29pbmcgdG8gXCJqdW1wXCIgYmFzZWQgb24gb3JkZXIgb2YgZXJyb3JzLlxuICAgICAgICBjb25zdCB7dWlTdGF0ZUFjdGlvbnN9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgdWlTdGF0ZUFjdGlvbnMuYWRkTm90aWZpY2F0aW9uKFxuICAgICAgICAgIGVycm9yTm90aWZpY2F0aW9uKHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yTWVzc2FnZSxcbiAgICAgICAgICAgIGlkOiBub3RpZmljYXRpb25JZFxuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qIGNvbXBvbmVudCByZW5kZXIgZnVuY3Rpb25zICovXG5cbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBjb21wbGV4aXR5ICovXG4gICAgX3JlbmRlck1hcFBvcG92ZXIoKSB7XG4gICAgICAvLyBUT0RPOiBtb3ZlIHRoaXMgaW50byByZWR1Y2VyIHNvIGl0IGNhbiBiZSB0ZXN0ZWRcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbWFwU3RhdGUsXG4gICAgICAgIHZpc1N0YXRlOiB7XG4gICAgICAgICAgaG92ZXJJbmZvLFxuICAgICAgICAgIGNsaWNrZWQsXG4gICAgICAgICAgZGF0YXNldHMsXG4gICAgICAgICAgaW50ZXJhY3Rpb25Db25maWcsXG4gICAgICAgICAgbGF5ZXJzLFxuICAgICAgICAgIG1vdXNlUG9zOiB7bW91c2VQb3NpdGlvbiwgY29vcmRpbmF0ZSwgcGlubmVkfVxuICAgICAgICB9XG4gICAgICB9ID0gdGhpcy5wcm9wcztcbiAgICAgIGNvbnN0IGxheWVyc1RvUmVuZGVyID0gdGhpcy5sYXllcnNUb1JlbmRlclNlbGVjdG9yKHRoaXMucHJvcHMpO1xuXG4gICAgICBpZiAoIW1vdXNlUG9zaXRpb24gfHwgIWludGVyYWN0aW9uQ29uZmlnLnRvb2x0aXApIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGxheWVySG92ZXJQcm9wID0gZ2V0TGF5ZXJIb3ZlclByb3Aoe1xuICAgICAgICBpbnRlcmFjdGlvbkNvbmZpZyxcbiAgICAgICAgaG92ZXJJbmZvLFxuICAgICAgICBsYXllcnMsXG4gICAgICAgIGxheWVyc1RvUmVuZGVyLFxuICAgICAgICBkYXRhc2V0c1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IGNvbXBhcmVNb2RlID0gaW50ZXJhY3Rpb25Db25maWcudG9vbHRpcC5jb25maWdcbiAgICAgICAgPyBpbnRlcmFjdGlvbkNvbmZpZy50b29sdGlwLmNvbmZpZy5jb21wYXJlTW9kZVxuICAgICAgICA6IGZhbHNlO1xuXG4gICAgICBsZXQgcGlubmVkUG9zaXRpb24gPSB7fTtcbiAgICAgIGxldCBsYXllclBpbm5lZFByb3A6IExheWVySG92ZXJQcm9wIHwgbnVsbCA9IG51bGw7XG4gICAgICBpZiAocGlubmVkIHx8IGNsaWNrZWQpIHtcbiAgICAgICAgLy8gcHJvamVjdCBsbmdsYXQgdG8gc2NyZWVuIHNvIHRoYXQgdG9vbHRpcCBmb2xsb3dzIHRoZSBvYmplY3Qgb24gem9vbVxuICAgICAgICBjb25zdCB2aWV3cG9ydCA9IG5ldyBXZWJNZXJjYXRvclZpZXdwb3J0KG1hcFN0YXRlKTtcbiAgICAgICAgY29uc3QgbG5nTGF0ID0gY2xpY2tlZCA/IGNsaWNrZWQuY29vcmRpbmF0ZSA6IHBpbm5lZC5jb29yZGluYXRlO1xuICAgICAgICBwaW5uZWRQb3NpdGlvbiA9IHRoaXMuX2dldEhvdmVyWFkodmlld3BvcnQsIGxuZ0xhdCk7XG4gICAgICAgIGxheWVyUGlubmVkUHJvcCA9IGdldExheWVySG92ZXJQcm9wKHtcbiAgICAgICAgICBpbnRlcmFjdGlvbkNvbmZpZyxcbiAgICAgICAgICBob3ZlckluZm86IGNsaWNrZWQsXG4gICAgICAgICAgbGF5ZXJzLFxuICAgICAgICAgIGxheWVyc1RvUmVuZGVyLFxuICAgICAgICAgIGRhdGFzZXRzXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAobGF5ZXJIb3ZlclByb3AgJiYgbGF5ZXJQaW5uZWRQcm9wKSB7XG4gICAgICAgICAgbGF5ZXJIb3ZlclByb3AucHJpbWFyeURhdGEgPSBsYXllclBpbm5lZFByb3AuZGF0YTtcbiAgICAgICAgICBsYXllckhvdmVyUHJvcC5jb21wYXJlVHlwZSA9IGludGVyYWN0aW9uQ29uZmlnLnRvb2x0aXAuY29uZmlnLmNvbXBhcmVUeXBlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGNvbW1vblByb3AgPSB7XG4gICAgICAgIG9uQ2xvc2U6IHRoaXMuX29uQ2xvc2VNYXBQb3BvdmVyLFxuICAgICAgICB6b29tOiBtYXBTdGF0ZS56b29tLFxuICAgICAgICBjb250YWluZXI6IHRoaXMuX2RlY2sgPyB0aGlzLl9kZWNrLmNhbnZhcyA6IHVuZGVmaW5lZFxuICAgICAgfTtcblxuICAgICAgcmV0dXJuIChcbiAgICAgICAgPEVycm9yQm91bmRhcnk+XG4gICAgICAgICAge2xheWVyUGlubmVkUHJvcCAmJiAoXG4gICAgICAgICAgICA8TWFwUG9wb3ZlclxuICAgICAgICAgICAgICB7Li4ucGlubmVkUG9zaXRpb259XG4gICAgICAgICAgICAgIHsuLi5jb21tb25Qcm9wfVxuICAgICAgICAgICAgICBsYXllckhvdmVyUHJvcD17bGF5ZXJQaW5uZWRQcm9wfVxuICAgICAgICAgICAgICBjb29yZGluYXRlPXtpbnRlcmFjdGlvbkNvbmZpZy5jb29yZGluYXRlLmVuYWJsZWQgJiYgKHBpbm5lZCB8fCB7fSkuY29vcmRpbmF0ZX1cbiAgICAgICAgICAgICAgZnJvemVuPXt0cnVlfVxuICAgICAgICAgICAgICBpc0Jhc2U9e2NvbXBhcmVNb2RlfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICApfVxuICAgICAgICAgIHtsYXllckhvdmVyUHJvcCAmJiAoIWxheWVyUGlubmVkUHJvcCB8fCBjb21wYXJlTW9kZSkgJiYgKFxuICAgICAgICAgICAgPE1hcFBvcG92ZXJcbiAgICAgICAgICAgICAgeD17bW91c2VQb3NpdGlvblswXX1cbiAgICAgICAgICAgICAgeT17bW91c2VQb3NpdGlvblsxXX1cbiAgICAgICAgICAgICAgey4uLmNvbW1vblByb3B9XG4gICAgICAgICAgICAgIGxheWVySG92ZXJQcm9wPXtsYXllckhvdmVyUHJvcH1cbiAgICAgICAgICAgICAgZnJvemVuPXtmYWxzZX1cbiAgICAgICAgICAgICAgY29vcmRpbmF0ZT17aW50ZXJhY3Rpb25Db25maWcuY29vcmRpbmF0ZS5lbmFibGVkICYmIGNvb3JkaW5hdGV9XG4gICAgICAgICAgICAvPlxuICAgICAgICAgICl9XG4gICAgICAgIDwvRXJyb3JCb3VuZGFyeT5cbiAgICAgICk7XG4gICAgfVxuXG4gICAgLyogZXNsaW50LWVuYWJsZSBjb21wbGV4aXR5ICovXG5cbiAgICBfZ2V0SG92ZXJYWSh2aWV3cG9ydCwgbG5nTGF0KSB7XG4gICAgICBjb25zdCBzY3JlZW5Db29yZCA9ICF2aWV3cG9ydCB8fCAhbG5nTGF0ID8gbnVsbCA6IHZpZXdwb3J0LnByb2plY3QobG5nTGF0KTtcbiAgICAgIHJldHVybiBzY3JlZW5Db29yZCAmJiB7eDogc2NyZWVuQ29vcmRbMF0sIHk6IHNjcmVlbkNvb3JkWzFdfTtcbiAgICB9XG5cbiAgICBfcmVuZGVyRGVja092ZXJsYXkobGF5ZXJzRm9yRGVjaywgb3B0aW9ucyA9IHtwcmltYXJ5TWFwOiBmYWxzZX0pIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbWFwU3RhdGUsXG4gICAgICAgIG1hcFN0eWxlLFxuICAgICAgICB2aXNTdGF0ZSxcbiAgICAgICAgdmlzU3RhdGVBY3Rpb25zLFxuICAgICAgICBtYXBib3hBcGlBY2Nlc3NUb2tlbixcbiAgICAgICAgbWFwYm94QXBpVXJsLFxuICAgICAgICBkZWNrR2xQcm9wcyxcbiAgICAgICAgaW5kZXhcbiAgICAgIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgICBjb25zdCBkZWNrR2xMYXllcnMgPSBjb21wdXRlRGVja0xheWVycyhcbiAgICAgICAge1xuICAgICAgICAgIHZpc1N0YXRlLFxuICAgICAgICAgIG1hcFN0YXRlLFxuICAgICAgICAgIG1hcFN0eWxlXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBtYXBJbmRleDogaW5kZXgsXG4gICAgICAgICAgcHJpbWFyeU1hcDogb3B0aW9ucy5wcmltYXJ5TWFwLFxuICAgICAgICAgIG1hcGJveEFwaUFjY2Vzc1Rva2VuLFxuICAgICAgICAgIG1hcGJveEFwaVVybCxcbiAgICAgICAgICBsYXllcnNGb3JEZWNrXG4gICAgICAgIH0sXG4gICAgICAgIHRoaXMuX29uTGF5ZXJTZXREb21haW4sXG4gICAgICAgIGRlY2tHbFByb3BzXG4gICAgICApO1xuXG4gICAgICBjb25zdCB2aWV3cyA9IGRlY2tHbFByb3BzPy52aWV3c1xuICAgICAgICA/IGRlY2tHbFByb3BzPy52aWV3cygpXG4gICAgICAgIDogbmV3IE1hcFZpZXcoe2xlZ2FjeU1ldGVyU2l6ZXM6IHRydWV9KTtcblxuICAgICAgcmV0dXJuIChcbiAgICAgICAgPERlY2tHTFxuICAgICAgICAgIGlkPVwiZGVmYXVsdC1kZWNrZ2wtb3ZlcmxheVwiXG4gICAgICAgICAgey4uLmRlY2tHbFByb3BzfVxuICAgICAgICAgIHZpZXdzPXt2aWV3c31cbiAgICAgICAgICBsYXllcnM9e2RlY2tHbExheWVyc31cbiAgICAgICAgICBjb250cm9sbGVyPXt0cnVlfVxuICAgICAgICAgIHZpZXdTdGF0ZT17bWFwU3RhdGV9XG4gICAgICAgICAgb25CZWZvcmVSZW5kZXI9e3RoaXMuX29uQmVmb3JlUmVuZGVyfVxuICAgICAgICAgIG9uSG92ZXI9e3Zpc1N0YXRlQWN0aW9ucy5vbkxheWVySG92ZXJ9XG4gICAgICAgICAgb25DbGljaz17dmlzU3RhdGVBY3Rpb25zLm9uTGF5ZXJDbGlja31cbiAgICAgICAgICBvbkVycm9yPXt0aGlzLl9vbkRlY2tFcnJvcn1cbiAgICAgICAgICByZWY9e2NvbXAgPT4ge1xuICAgICAgICAgICAgaWYgKGNvbXAgJiYgY29tcC5kZWNrICYmICF0aGlzLl9kZWNrKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2RlY2sgPSBjb21wLmRlY2s7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfX1cbiAgICAgICAgICBvbldlYkdMSW5pdGlhbGl6ZWQ9e2dsID0+IHRoaXMuX29uRGVja0luaXRpYWxpemVkKGdsKX1cbiAgICAgICAgLz5cbiAgICAgICk7XG4gICAgfVxuXG4gICAgX3VwZGF0ZU1hcGJveExheWVycygpIHtcbiAgICAgIGNvbnN0IG1hcGJveExheWVycyA9IHRoaXMubWFwYm94TGF5ZXJzU2VsZWN0b3IodGhpcy5wcm9wcyk7XG4gICAgICBpZiAoIU9iamVjdC5rZXlzKG1hcGJveExheWVycykubGVuZ3RoICYmICFPYmplY3Qua2V5cyh0aGlzLnByZXZpb3VzTGF5ZXJzKS5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB1cGRhdGVNYXBib3hMYXllcnModGhpcy5fbWFwLCBtYXBib3hMYXllcnMsIHRoaXMucHJldmlvdXNMYXllcnMpO1xuXG4gICAgICB0aGlzLnByZXZpb3VzTGF5ZXJzID0gbWFwYm94TGF5ZXJzO1xuICAgIH1cblxuICAgIF9yZW5kZXJNYXBib3hPdmVybGF5cygpIHtcbiAgICAgIGlmICh0aGlzLl9tYXAgJiYgdGhpcy5fbWFwLmlzU3R5bGVMb2FkZWQoKSkge1xuICAgICAgICB0aGlzLl91cGRhdGVNYXBib3hMYXllcnMoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfcmVuZGVyRHJhd0VkaXRvcigpIHtcbiAgICAgIGNvbnN0IHt2aXNTdGF0ZSwgbWFwQ29udHJvbHMsIHZpc1N0YXRlQWN0aW9ucywgaW5kZXh9ID0gdGhpcy5wcm9wcztcbiAgICAgIGNvbnN0IHtsYXllcnMsIGRhdGFzZXRzLCBlZGl0b3J9ID0gdmlzU3RhdGU7XG4gICAgICBjb25zdCBpc0VkaXQgPSBtYXBDb250cm9scy5tYXBEcmF3ID8gbWFwQ29udHJvbHMubWFwRHJhdy5hY3RpdmUgOiBmYWxzZTtcbiAgICAgIGNvbnN0IGxheWVyc1RvUmVuZGVyID0gdGhpcy5sYXllcnNUb1JlbmRlclNlbGVjdG9yKHRoaXMucHJvcHMpO1xuXG4gICAgICByZXR1cm4gKFxuICAgICAgICA8RWRpdG9yXG4gICAgICAgICAgaW5kZXg9e2luZGV4fVxuICAgICAgICAgIGRhdGFzZXRzPXtkYXRhc2V0c31cbiAgICAgICAgICBlZGl0b3I9e2VkaXRvcn1cbiAgICAgICAgICBmaWx0ZXJzPXt0aGlzLnBvbHlnb25GaWx0ZXJzKHRoaXMucHJvcHMpfVxuICAgICAgICAgIGlzRW5hYmxlZD17aXNFZGl0fVxuICAgICAgICAgIGxheWVycz17bGF5ZXJzfVxuICAgICAgICAgIGxheWVyc1RvUmVuZGVyPXtsYXllcnNUb1JlbmRlcn1cbiAgICAgICAgICBvbkRlbGV0ZUZlYXR1cmU9e3Zpc1N0YXRlQWN0aW9ucy5kZWxldGVGZWF0dXJlfVxuICAgICAgICAgIG9uU2VsZWN0PXt2aXNTdGF0ZUFjdGlvbnMuc2V0U2VsZWN0ZWRGZWF0dXJlfVxuICAgICAgICAgIG9uVXBkYXRlPXt2aXNTdGF0ZUFjdGlvbnMuc2V0RmVhdHVyZXN9XG4gICAgICAgICAgb25Ub2dnbGVQb2x5Z29uRmlsdGVyPXt2aXNTdGF0ZUFjdGlvbnMuc2V0UG9seWdvbkZpbHRlckxheWVyfVxuICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICBwb2ludGVyRXZlbnRzOiBpc0VkaXQgPyAnYWxsJyA6ICdub25lJyxcbiAgICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICAgICAgZGlzcGxheTogZWRpdG9yLnZpc2libGUgPyAnYmxvY2snIDogJ25vbmUnXG4gICAgICAgICAgfX1cbiAgICAgICAgLz5cbiAgICAgICk7XG4gICAgfVxuXG4gICAgX29uVmlld3BvcnRDaGFuZ2UgPSB2aWV3U3RhdGUgPT4ge1xuICAgICAgb25WaWV3UG9ydENoYW5nZShcbiAgICAgICAgdmlld1N0YXRlLFxuICAgICAgICB0aGlzLnByb3BzLm1hcFN0YXRlQWN0aW9ucy51cGRhdGVNYXAsXG4gICAgICAgIHRoaXMucHJvcHMub25WaWV3U3RhdGVDaGFuZ2UsXG4gICAgICAgIHRoaXMucHJvcHMucHJpbWFyeVxuICAgICAgKTtcbiAgICB9O1xuXG4gICAgX3RvZ2dsZU1hcENvbnRyb2wgPSBwYW5lbElkID0+IHtcbiAgICAgIGNvbnN0IHtpbmRleCwgdWlTdGF0ZUFjdGlvbnN9ID0gdGhpcy5wcm9wcztcblxuICAgICAgdWlTdGF0ZUFjdGlvbnMudG9nZ2xlTWFwQ29udHJvbChwYW5lbElkLCBOdW1iZXIoaW5kZXgpKTtcbiAgICB9O1xuXG4gICAgLyogZXNsaW50LWRpc2FibGUgY29tcGxleGl0eSAqL1xuICAgIF9yZW5kZXJNYXAoKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHZpc1N0YXRlLFxuICAgICAgICBtYXBTdGF0ZSxcbiAgICAgICAgbWFwU3R5bGUsXG4gICAgICAgIG1hcFN0YXRlQWN0aW9ucyxcbiAgICAgICAgTWFwQ29tcG9uZW50ID0gTWFwYm94R0xNYXAsXG4gICAgICAgIG1hcGJveEFwaUFjY2Vzc1Rva2VuLFxuICAgICAgICBtYXBib3hBcGlVcmwsXG4gICAgICAgIG1hcENvbnRyb2xzLFxuICAgICAgICBpc0V4cG9ydCxcbiAgICAgICAgbG9jYWxlLFxuICAgICAgICB1aVN0YXRlQWN0aW9ucyxcbiAgICAgICAgdmlzU3RhdGVBY3Rpb25zLFxuICAgICAgICBpbmRleCxcbiAgICAgICAgcHJpbWFyeSxcbiAgICAgICAgYm90dG9tTWFwQ29udGFpbmVyUHJvcHMsXG4gICAgICAgIHRvcE1hcENvbnRhaW5lclByb3BzXG4gICAgICB9ID0gdGhpcy5wcm9wcztcblxuICAgICAgY29uc3Qge2xheWVycywgZGF0YXNldHMsIGVkaXRvciwgaW50ZXJhY3Rpb25Db25maWcsIGhvdmVySW5mb30gPSB2aXNTdGF0ZTtcblxuICAgICAgY29uc3QgbGF5ZXJzVG9SZW5kZXIgPSB0aGlzLmxheWVyc1RvUmVuZGVyU2VsZWN0b3IodGhpcy5wcm9wcyk7XG4gICAgICBjb25zdCBsYXllcnNGb3JEZWNrID0gdGhpcy5sYXllcnNGb3JEZWNrU2VsZWN0b3IodGhpcy5wcm9wcyk7XG5cbiAgICAgIC8vIEN1cnJlbnQgc3R5bGUgY2FuIGJlIGEgY3VzdG9tIHN0eWxlLCBmcm9tIHdoaWNoIHdlIHB1bGwgdGhlIG1hcGJveCBBUEkgYWNjY2VzcyB0b2tlblxuICAgICAgY29uc3QgY3VycmVudFN0eWxlID0gbWFwU3R5bGUubWFwU3R5bGVzPy5bbWFwU3R5bGUuc3R5bGVUeXBlXTtcbiAgICAgIGNvbnN0IG1hcFByb3BzID0ge1xuICAgICAgICAuLi5tYXBTdGF0ZSxcbiAgICAgICAgd2lkdGg6ICcxMDAlJyxcbiAgICAgICAgaGVpZ2h0OiAnMTAwJScsXG4gICAgICAgIHByZXNlcnZlRHJhd2luZ0J1ZmZlcjogdHJ1ZSxcbiAgICAgICAgbWFwYm94QXBpQWNjZXNzVG9rZW46IGN1cnJlbnRTdHlsZT8uYWNjZXNzVG9rZW4gfHwgbWFwYm94QXBpQWNjZXNzVG9rZW4sXG4gICAgICAgIG1hcGJveEFwaVVybCxcbiAgICAgICAgb25WaWV3cG9ydENoYW5nZTogdGhpcy5fb25WaWV3cG9ydENoYW5nZSxcbiAgICAgICAgdHJhbnNmb3JtUmVxdWVzdFxuICAgICAgfTtcblxuICAgICAgY29uc3QgaGFzR2VvY29kZXJMYXllciA9IEJvb2xlYW4obGF5ZXJzLmZpbmQobCA9PiBsLmlkID09PSBHRU9DT0RFUl9MQVlFUl9JRCkpO1xuICAgICAgY29uc3QgaXNTcGxpdCA9IEJvb2xlYW4obWFwU3RhdGUuaXNTcGxpdCk7XG5cbiAgICAgIHJldHVybiAoXG4gICAgICAgIDw+XG4gICAgICAgICAgPE1hcENvbnRyb2xcbiAgICAgICAgICAgIGRhdGFzZXRzPXtkYXRhc2V0c31cbiAgICAgICAgICAgIGF2YWlsYWJsZUxvY2FsZXM9e0xPQ0FMRV9DT0RFU19BUlJBWX1cbiAgICAgICAgICAgIGRyYWdSb3RhdGU9e21hcFN0YXRlLmRyYWdSb3RhdGV9XG4gICAgICAgICAgICBpc1NwbGl0PXtpc1NwbGl0fVxuICAgICAgICAgICAgcHJpbWFyeT17cHJpbWFyeX1cbiAgICAgICAgICAgIGlzRXhwb3J0PXtpc0V4cG9ydH1cbiAgICAgICAgICAgIGxheWVycz17bGF5ZXJzfVxuICAgICAgICAgICAgbGF5ZXJzVG9SZW5kZXI9e2xheWVyc1RvUmVuZGVyfVxuICAgICAgICAgICAgbWFwSW5kZXg9e2luZGV4fVxuICAgICAgICAgICAgbWFwQ29udHJvbHM9e21hcENvbnRyb2xzfVxuICAgICAgICAgICAgcmVhZE9ubHk9e3RoaXMucHJvcHMucmVhZE9ubHl9XG4gICAgICAgICAgICBzY2FsZT17bWFwU3RhdGUuc2NhbGUgfHwgMX1cbiAgICAgICAgICAgIHRvcD17aW50ZXJhY3Rpb25Db25maWcuZ2VvY29kZXIgJiYgaW50ZXJhY3Rpb25Db25maWcuZ2VvY29kZXIuZW5hYmxlZCA/IDUyIDogMH1cbiAgICAgICAgICAgIGVkaXRvcj17ZWRpdG9yfVxuICAgICAgICAgICAgbG9jYWxlPXtsb2NhbGV9XG4gICAgICAgICAgICBvblRvZ2dsZVBlcnNwZWN0aXZlPXttYXBTdGF0ZUFjdGlvbnMudG9nZ2xlUGVyc3BlY3RpdmV9XG4gICAgICAgICAgICBvblRvZ2dsZVNwbGl0TWFwPXttYXBTdGF0ZUFjdGlvbnMudG9nZ2xlU3BsaXRNYXB9XG4gICAgICAgICAgICBvbk1hcFRvZ2dsZUxheWVyPXt0aGlzLl9oYW5kbGVNYXBUb2dnbGVMYXllcn1cbiAgICAgICAgICAgIG9uVG9nZ2xlTWFwQ29udHJvbD17dGhpcy5fdG9nZ2xlTWFwQ29udHJvbH1cbiAgICAgICAgICAgIG9uU2V0RWRpdG9yTW9kZT17dmlzU3RhdGVBY3Rpb25zLnNldEVkaXRvck1vZGV9XG4gICAgICAgICAgICBvblNldExvY2FsZT17dWlTdGF0ZUFjdGlvbnMuc2V0TG9jYWxlfVxuICAgICAgICAgICAgb25Ub2dnbGVFZGl0b3JWaXNpYmlsaXR5PXt2aXNTdGF0ZUFjdGlvbnMudG9nZ2xlRWRpdG9yVmlzaWJpbGl0eX1cbiAgICAgICAgICAgIG1hcEhlaWdodD17bWFwU3RhdGUuaGVpZ2h0fVxuICAgICAgICAgIC8+XG4gICAgICAgICAgPE1hcENvbXBvbmVudFxuICAgICAgICAgICAga2V5PVwiYm90dG9tXCJcbiAgICAgICAgICAgIHsuLi5tYXBQcm9wc31cbiAgICAgICAgICAgIG1hcFN0eWxlPXttYXBTdHlsZS5ib3R0b21NYXBTdHlsZX1cbiAgICAgICAgICAgIHsuLi5ib3R0b21NYXBDb250YWluZXJQcm9wc31cbiAgICAgICAgICAgIHJlZj17dGhpcy5fc2V0TWFwYm94TWFwfVxuICAgICAgICAgICAgZ2V0Q3Vyc29yPXtob3ZlckluZm8gPyAoKSA9PiAncG9pbnRlcicgOiB1bmRlZmluZWR9XG4gICAgICAgICAgICBvbk1vdXNlTW92ZT17dGhpcy5wcm9wcy52aXNTdGF0ZUFjdGlvbnMub25Nb3VzZU1vdmV9XG4gICAgICAgICAgPlxuICAgICAgICAgICAge3RoaXMuX3JlbmRlckRlY2tPdmVybGF5KGxheWVyc0ZvckRlY2ssIHtwcmltYXJ5TWFwOiB0cnVlfSl9XG4gICAgICAgICAgICB7dGhpcy5fcmVuZGVyTWFwYm94T3ZlcmxheXMoKX1cbiAgICAgICAgICAgIHt0aGlzLl9yZW5kZXJEcmF3RWRpdG9yKCl9XG4gICAgICAgICAgPC9NYXBDb21wb25lbnQ+XG4gICAgICAgICAge21hcFN0eWxlLnRvcE1hcFN0eWxlIHx8IGhhc0dlb2NvZGVyTGF5ZXIgPyAoXG4gICAgICAgICAgICA8ZGl2IHN0eWxlPXtNQVBfU1RZTEUudG9wfT5cbiAgICAgICAgICAgICAgPE1hcENvbXBvbmVudFxuICAgICAgICAgICAgICAgIGtleT1cInRvcFwiXG4gICAgICAgICAgICAgICAgey4uLm1hcFByb3BzfVxuICAgICAgICAgICAgICAgIG1hcFN0eWxlPXttYXBTdHlsZS50b3BNYXBTdHlsZX1cbiAgICAgICAgICAgICAgICB7Li4udG9wTWFwQ29udGFpbmVyUHJvcHN9XG4gICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICB7dGhpcy5fcmVuZGVyRGVja092ZXJsYXkoe1tHRU9DT0RFUl9MQVlFUl9JRF06IGhhc0dlb2NvZGVyTGF5ZXJ9KX1cbiAgICAgICAgICAgICAgPC9NYXBDb21wb25lbnQ+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICApIDogbnVsbH1cbiAgICAgICAgICB7dGhpcy5fcmVuZGVyTWFwUG9wb3ZlcigpfVxuICAgICAgICAgIHshaXNTcGxpdCB8fCBpbmRleCA9PT0gMSA/IChcbiAgICAgICAgICAgIDxBdHRyaWJ1dGlvbiBzaG93TWFwYm94TG9nbz17dGhpcy5zdGF0ZS5zaG93TWFwYm94QXR0cmlidXRpb259IC8+XG4gICAgICAgICAgKSA6IG51bGx9XG4gICAgICAgIDwvPlxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZW5kZXIoKSB7XG4gICAgICBjb25zdCB7bWFwU3R5bGV9ID0gdGhpcy5wcm9wcztcbiAgICAgIHJldHVybiAoXG4gICAgICAgIDxTdHlsZWRNYXBDb250YWluZXIgcmVmPXt0aGlzLl9yZWZ9IHN0eWxlPXtNQVBfU1RZTEUuY29udGFpbmVyfT5cbiAgICAgICAgICB7bWFwU3R5bGUuYm90dG9tTWFwU3R5bGUgJiYgdGhpcy5fcmVuZGVyTWFwKCl9XG4gICAgICAgIDwvU3R5bGVkTWFwQ29udGFpbmVyPlxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gTWFwQ29udGFpbmVyO1xufVxuIl19