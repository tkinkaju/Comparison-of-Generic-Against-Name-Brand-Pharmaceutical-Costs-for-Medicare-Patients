// Copyright (c) 2022 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isGeoJson = isGeoJson;
exports.isFeature = isFeature;
exports.isFeatureCollection = isFeatureCollection;
exports.isRowObject = isRowObject;
exports.isKeplerGlMap = isKeplerGlMap;
exports.makeProgressIterator = makeProgressIterator;
exports.readBatch = readBatch;
exports.readFileInBatches = readFileInBatches;
exports.processFileData = processFileData;
exports.filesToDataPayload = filesToDataPayload;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _awaitAsyncGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/awaitAsyncGenerator"));

var _wrapAsyncGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/wrapAsyncGenerator"));

var _asyncIterator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncIterator"));

var _core = require("@loaders.gl/core");

var _json = require("@loaders.gl/json");

var _csv = require("@loaders.gl/csv");

var _dataProcessor = require("./data-processor");

var _utils = require("@kepler.gl/utils");

var _constants = require("@kepler.gl/constants");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var BATCH_TYPE = {
  METADATA: 'metadata',
  PARTIAL_RESULT: 'partial-result',
  FINAL_RESULT: 'final-result'
};
var CSV_LOADER_OPTIONS = {
  shape: 'object-row-table',
  dynamicTyping: false // not working for now

};
var JSON_LOADER_OPTIONS = {
  shape: 'object-row-table',
  // instruct loaders.gl on what json paths to stream
  jsonpaths: ['$', // JSON Row array
  '$.features', // GeoJSON
  '$.datasets' // KeplerGL JSON
  ]
};

function isGeoJson(json) {
  // json can be feature collection
  // or single feature
  return (0, _utils.isPlainObject)(json) && (isFeature(json) || isFeatureCollection(json));
}

function isFeature(json) {
  return (0, _utils.isPlainObject)(json) && json.type === 'Feature' && Boolean(json.geometry);
}

function isFeatureCollection(json) {
  return (0, _utils.isPlainObject)(json) && json.type === 'FeatureCollection' && Boolean(json.features);
}

function isRowObject(json) {
  return Array.isArray(json) && (0, _utils.isPlainObject)(json[0]);
}

function isKeplerGlMap(json) {
  return Boolean((0, _utils.isPlainObject)(json) && json.datasets && json.config && json.info && (0, _utils.isPlainObject)(json.info) && json.info.app === 'kepler.gl');
}

function makeProgressIterator(_x, _x2) {
  return _makeProgressIterator.apply(this, arguments);
} // eslint-disable-next-line complexity


function _makeProgressIterator() {
  _makeProgressIterator = (0, _wrapAsyncGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(asyncIterator, info) {
    var rowCount, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value, batch, rowCountInBatch, percent, progress;

    return _regenerator["default"].wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            rowCount = 0;
            _iteratorNormalCompletion = true;
            _didIteratorError = false;
            _context.prev = 3;
            _iterator = (0, _asyncIterator2["default"])(asyncIterator);

          case 5:
            _context.next = 7;
            return (0, _awaitAsyncGenerator2["default"])(_iterator.next());

          case 7:
            _step = _context.sent;
            _iteratorNormalCompletion = _step.done;
            _context.next = 11;
            return (0, _awaitAsyncGenerator2["default"])(_step.value);

          case 11:
            _value = _context.sent;

            if (_iteratorNormalCompletion) {
              _context.next = 23;
              break;
            }

            batch = _value;
            rowCountInBatch = batch.data && batch.data.length || 0;
            rowCount += rowCountInBatch;
            percent = Number.isFinite(batch.bytesUsed) ? batch.bytesUsed / info.size : null; // Update progress object

            progress = _objectSpread({
              rowCount: rowCount,
              rowCountInBatch: rowCountInBatch
            }, Number.isFinite(percent) ? {
              percent: percent
            } : {});
            _context.next = 20;
            return _objectSpread(_objectSpread({}, batch), {}, {
              progress: progress
            });

          case 20:
            _iteratorNormalCompletion = true;
            _context.next = 5;
            break;

          case 23:
            _context.next = 29;
            break;

          case 25:
            _context.prev = 25;
            _context.t0 = _context["catch"](3);
            _didIteratorError = true;
            _iteratorError = _context.t0;

          case 29:
            _context.prev = 29;
            _context.prev = 30;

            if (!(!_iteratorNormalCompletion && _iterator["return"] != null)) {
              _context.next = 34;
              break;
            }

            _context.next = 34;
            return (0, _awaitAsyncGenerator2["default"])(_iterator["return"]());

          case 34:
            _context.prev = 34;

            if (!_didIteratorError) {
              _context.next = 37;
              break;
            }

            throw _iteratorError;

          case 37:
            return _context.finish(34);

          case 38:
            return _context.finish(29);

          case 39:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[3, 25, 29, 39], [30,, 34, 38]]);
  }));
  return _makeProgressIterator.apply(this, arguments);
}

function readBatch(_x3, _x4) {
  return _readBatch.apply(this, arguments);
}

function _readBatch() {
  _readBatch = (0, _wrapAsyncGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee2(asyncIterator, fileName) {
    var result, batches, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, _value2, batch, streamingPath, i;

    return _regenerator["default"].wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            result = null;
            batches = [];
            _iteratorNormalCompletion2 = true;
            _didIteratorError2 = false;
            _context2.prev = 4;
            _iterator2 = (0, _asyncIterator2["default"])(asyncIterator);

          case 6:
            _context2.next = 8;
            return (0, _awaitAsyncGenerator2["default"])(_iterator2.next());

          case 8:
            _step2 = _context2.sent;
            _iteratorNormalCompletion2 = _step2.done;
            _context2.next = 12;
            return (0, _awaitAsyncGenerator2["default"])(_step2.value);

          case 12:
            _value2 = _context2.sent;

            if (_iteratorNormalCompletion2) {
              _context2.next = 21;
              break;
            }

            batch = _value2;

            // Last batch will have this special type and will provide all the root
            // properties of the parsed document.
            // Only json parse will have `FINAL_RESULT`
            if (batch.batchType === BATCH_TYPE.FINAL_RESULT) {
              if (batch.container) {
                result = _objectSpread({}, batch.container);
              } // Set the streamed data correctly is Batch json path is set
              // and the path streamed is not the top level object (jsonpath = '$')


              if (batch.jsonpath && batch.jsonpath.length > 1) {
                streamingPath = new _json._JSONPath(batch.jsonpath);
                streamingPath.setFieldAtPath(result, batches);
              } else if (batch.jsonpath && batch.jsonpath.length === 1) {
                // The streamed object is a ROW JSON-batch (jsonpath = '$')
                // row objects
                result = batches;
              }
            } else {
              for (i = 0; i < batch.data.length; i++) {
                batches.push(batch.data[i]);
              }
            }

            _context2.next = 18;
            return _objectSpread(_objectSpread(_objectSpread({}, batch), batch.schema ? {
              headers: Object.keys(batch.schema)
            } : {}), {}, {
              fileName: fileName,
              // if dataset is CSV, data is set to the raw batches
              data: result ? result : batches
            });

          case 18:
            _iteratorNormalCompletion2 = true;
            _context2.next = 6;
            break;

          case 21:
            _context2.next = 27;
            break;

          case 23:
            _context2.prev = 23;
            _context2.t0 = _context2["catch"](4);
            _didIteratorError2 = true;
            _iteratorError2 = _context2.t0;

          case 27:
            _context2.prev = 27;
            _context2.prev = 28;

            if (!(!_iteratorNormalCompletion2 && _iterator2["return"] != null)) {
              _context2.next = 32;
              break;
            }

            _context2.next = 32;
            return (0, _awaitAsyncGenerator2["default"])(_iterator2["return"]());

          case 32:
            _context2.prev = 32;

            if (!_didIteratorError2) {
              _context2.next = 35;
              break;
            }

            throw _iteratorError2;

          case 35:
            return _context2.finish(32);

          case 36:
            return _context2.finish(27);

          case 37:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, null, [[4, 23, 27, 37], [28,, 32, 36]]);
  }));
  return _readBatch.apply(this, arguments);
}

function readFileInBatches(_x5) {
  return _readFileInBatches.apply(this, arguments);
}

function _readFileInBatches() {
  _readFileInBatches = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee3(_ref) {
    var file, _ref$loaders, loaders, _ref$loadOptions, loadOptions, batchIterator, progressIterator;

    return _regenerator["default"].wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            file = _ref.file, _ref$loaders = _ref.loaders, loaders = _ref$loaders === void 0 ? [] : _ref$loaders, _ref$loadOptions = _ref.loadOptions, loadOptions = _ref$loadOptions === void 0 ? {} : _ref$loadOptions;
            loaders = [_json.JSONLoader, _csv.CSVLoader].concat((0, _toConsumableArray2["default"])(loaders));
            loadOptions = _objectSpread({
              csv: CSV_LOADER_OPTIONS,
              json: JSON_LOADER_OPTIONS,
              metadata: true
            }, loadOptions);
            _context3.next = 5;
            return (0, _core.parseInBatches)(file, loaders, loadOptions);

          case 5:
            batchIterator = _context3.sent;
            progressIterator = makeProgressIterator(batchIterator, {
              size: file.size
            });
            return _context3.abrupt("return", readBatch(progressIterator, file.name));

          case 8:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));
  return _readFileInBatches.apply(this, arguments);
}

function processFileData(_ref2) {
  var content = _ref2.content,
      fileCache = _ref2.fileCache;
  return new Promise(function (resolve, reject) {
    var data = content.data;
    var format;
    var processor;

    if (isKeplerGlMap(data)) {
      format = _constants.DATASET_FORMATS.keplergl;
      processor = _dataProcessor.processKeplerglJSON;
    } else if (isRowObject(data)) {
      format = _constants.DATASET_FORMATS.row;
      processor = _dataProcessor.processRowObject;
    } else if (isGeoJson(data)) {
      format = _constants.DATASET_FORMATS.geojson;
      processor = _dataProcessor.processGeojson;
    }

    if (format && processor) {
      var result = processor(data);
      resolve([].concat((0, _toConsumableArray2["default"])(fileCache), [{
        data: result,
        info: {
          label: content.fileName,
          format: format
        }
      }]));
    }

    reject('Unknown File Format');
  });
}

function filesToDataPayload(fileCache) {
  // seperate out files which could be a single datasets. or a keplergl map json
  var collection = fileCache.reduce(function (accu, file) {
    var data = file.data,
        info = file.info;

    if ((info === null || info === void 0 ? void 0 : info.format) === _constants.DATASET_FORMATS.keplergl) {
      // if file contains a single kepler map dataset & config
      accu.keplerMaps.push(_objectSpread(_objectSpread({}, data), {}, {
        options: {
          centerMap: !(data.config && data.config.mapState)
        }
      }));
    } else if (_constants.DATASET_FORMATS[info === null || info === void 0 ? void 0 : info.format]) {
      // if file contains only data
      var newDataset = {
        data: data,
        info: _objectSpread({
          id: (info === null || info === void 0 ? void 0 : info.id) || (0, _utils.generateHashId)(4)
        }, info || {})
      };
      accu.datasets.push(newDataset);
    }

    return accu;
  }, {
    datasets: [],
    keplerMaps: []
  }); // add kepler map first with config
  // add datasets later in one add data call

  return collection.keplerMaps.concat({
    datasets: collection.datasets
  });
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9maWxlLWhhbmRsZXIudHMiXSwibmFtZXMiOlsiQkFUQ0hfVFlQRSIsIk1FVEFEQVRBIiwiUEFSVElBTF9SRVNVTFQiLCJGSU5BTF9SRVNVTFQiLCJDU1ZfTE9BREVSX09QVElPTlMiLCJzaGFwZSIsImR5bmFtaWNUeXBpbmciLCJKU09OX0xPQURFUl9PUFRJT05TIiwianNvbnBhdGhzIiwiaXNHZW9Kc29uIiwianNvbiIsImlzRmVhdHVyZSIsImlzRmVhdHVyZUNvbGxlY3Rpb24iLCJ0eXBlIiwiQm9vbGVhbiIsImdlb21ldHJ5IiwiZmVhdHVyZXMiLCJpc1Jvd09iamVjdCIsIkFycmF5IiwiaXNBcnJheSIsImlzS2VwbGVyR2xNYXAiLCJkYXRhc2V0cyIsImNvbmZpZyIsImluZm8iLCJhcHAiLCJtYWtlUHJvZ3Jlc3NJdGVyYXRvciIsImFzeW5jSXRlcmF0b3IiLCJyb3dDb3VudCIsImJhdGNoIiwicm93Q291bnRJbkJhdGNoIiwiZGF0YSIsImxlbmd0aCIsInBlcmNlbnQiLCJOdW1iZXIiLCJpc0Zpbml0ZSIsImJ5dGVzVXNlZCIsInNpemUiLCJwcm9ncmVzcyIsInJlYWRCYXRjaCIsImZpbGVOYW1lIiwicmVzdWx0IiwiYmF0Y2hlcyIsImJhdGNoVHlwZSIsImNvbnRhaW5lciIsImpzb25wYXRoIiwic3RyZWFtaW5nUGF0aCIsIl9KU09OUGF0aCIsInNldEZpZWxkQXRQYXRoIiwiaSIsInB1c2giLCJzY2hlbWEiLCJoZWFkZXJzIiwiT2JqZWN0Iiwia2V5cyIsInJlYWRGaWxlSW5CYXRjaGVzIiwiZmlsZSIsImxvYWRlcnMiLCJsb2FkT3B0aW9ucyIsIkpTT05Mb2FkZXIiLCJDU1ZMb2FkZXIiLCJjc3YiLCJtZXRhZGF0YSIsImJhdGNoSXRlcmF0b3IiLCJwcm9ncmVzc0l0ZXJhdG9yIiwibmFtZSIsInByb2Nlc3NGaWxlRGF0YSIsImNvbnRlbnQiLCJmaWxlQ2FjaGUiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsImZvcm1hdCIsInByb2Nlc3NvciIsIkRBVEFTRVRfRk9STUFUUyIsImtlcGxlcmdsIiwicHJvY2Vzc0tlcGxlcmdsSlNPTiIsInJvdyIsInByb2Nlc3NSb3dPYmplY3QiLCJnZW9qc29uIiwicHJvY2Vzc0dlb2pzb24iLCJsYWJlbCIsImZpbGVzVG9EYXRhUGF5bG9hZCIsImNvbGxlY3Rpb24iLCJyZWR1Y2UiLCJhY2N1Iiwia2VwbGVyTWFwcyIsIm9wdGlvbnMiLCJjZW50ZXJNYXAiLCJtYXBTdGF0ZSIsIm5ld0RhdGFzZXQiLCJpZCIsImNvbmNhdCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFvQkE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7OztBQU1BLElBQU1BLFVBQVUsR0FBRztBQUNqQkMsRUFBQUEsUUFBUSxFQUFFLFVBRE87QUFFakJDLEVBQUFBLGNBQWMsRUFBRSxnQkFGQztBQUdqQkMsRUFBQUEsWUFBWSxFQUFFO0FBSEcsQ0FBbkI7QUFNQSxJQUFNQyxrQkFBa0IsR0FBRztBQUN6QkMsRUFBQUEsS0FBSyxFQUFFLGtCQURrQjtBQUV6QkMsRUFBQUEsYUFBYSxFQUFFLEtBRlUsQ0FFSjs7QUFGSSxDQUEzQjtBQUtBLElBQU1DLG1CQUFtQixHQUFHO0FBQzFCRixFQUFBQSxLQUFLLEVBQUUsa0JBRG1CO0FBRTFCO0FBQ0FHLEVBQUFBLFNBQVMsRUFBRSxDQUNULEdBRFMsRUFDSjtBQUNMLGNBRlMsRUFFSztBQUNkLGNBSFMsQ0FHSTtBQUhKO0FBSGUsQ0FBNUI7O0FBVU8sU0FBU0MsU0FBVCxDQUFtQkMsSUFBbkIsRUFBdUU7QUFDNUU7QUFDQTtBQUNBLFNBQU8sMEJBQWNBLElBQWQsTUFBd0JDLFNBQVMsQ0FBQ0QsSUFBRCxDQUFULElBQW1CRSxtQkFBbUIsQ0FBQ0YsSUFBRCxDQUE5RCxDQUFQO0FBQ0Q7O0FBRU0sU0FBU0MsU0FBVCxDQUFtQkQsSUFBbkIsRUFBbUQ7QUFDeEQsU0FBTywwQkFBY0EsSUFBZCxLQUF1QkEsSUFBSSxDQUFDRyxJ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LENBQVA7QUFDRCIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAyMiBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5cbmltcG9ydCB7cGFyc2VJbkJhdGNoZXN9IGZyb20gJ0Bsb2FkZXJzLmdsL2NvcmUnO1xuaW1wb3J0IHtKU09OTG9hZGVyLCBfSlNPTlBhdGh9IGZyb20gJ0Bsb2FkZXJzLmdsL2pzb24nO1xuaW1wb3J0IHtDU1ZMb2FkZXJ9IGZyb20gJ0Bsb2FkZXJzLmdsL2Nzdic7XG5pbXBvcnQge3Byb2Nlc3NHZW9qc29uLCBwcm9jZXNzS2VwbGVyZ2xKU09OLCBwcm9jZXNzUm93T2JqZWN0fSBmcm9tICcuL2RhdGEtcHJvY2Vzc29yJztcbmltcG9ydCB7Z2VuZXJhdGVIYXNoSWQsIGlzUGxhaW5PYmplY3R9IGZyb20gJ0BrZXBsZXIuZ2wvdXRpbHMnO1xuaW1wb3J0IHtEQVRBU0VUX0ZPUk1BVFN9IGZyb20gJ0BrZXBsZXIuZ2wvY29uc3RhbnRzJztcbmltcG9ydCB7TG9hZGVyfSBmcm9tICdAbG9hZGVycy5nbC9sb2FkZXItdXRpbHMnO1xuaW1wb3J0IHtGaWxlQ2FjaGVJdGVtLCBWYWxpZEtlcGxlckdsTWFwfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7RmVhdHVyZSwgQWRkRGF0YVRvTWFwUGF5bG9hZH0gZnJvbSAnQGtlcGxlci5nbC90eXBlcyc7XG5pbXBvcnQge0ZlYXR1cmVDb2xsZWN0aW9ufSBmcm9tICdAdHVyZi9oZWxwZXJzJztcblxuY29uc3QgQkFUQ0hfVFlQRSA9IHtcbiAgTUVUQURBVEE6ICdtZXRhZGF0YScsXG4gIFBBUlRJQUxfUkVTVUxUOiAncGFydGlhbC1yZXN1bHQnLFxuICBGSU5BTF9SRVNVTFQ6ICdmaW5hbC1yZXN1bHQnXG59O1xuXG5jb25zdCBDU1ZfTE9BREVSX09QVElPTlMgPSB7XG4gIHNoYXBlOiAnb2JqZWN0LXJvdy10YWJsZScsXG4gIGR5bmFtaWNUeXBpbmc6IGZhbHNlIC8vIG5vdCB3b3JraW5nIGZvciBub3dcbn07XG5cbmNvbnN0IEpTT05fTE9BREVSX09QVElPTlMgPSB7XG4gIHNoYXBlOiAnb2JqZWN0LXJvdy10YWJsZScsXG4gIC8vIGluc3RydWN0IGxvYWRlcnMuZ2wgb24gd2hhdCBqc29uIHBhdGhzIHRvIHN0cmVhbVxuICBqc29ucGF0aHM6IFtcbiAgICAnJCcsIC8vIEpTT04gUm93IGFycmF5XG4gICAgJyQuZmVhdHVyZXMnLCAvLyBHZW9KU09OXG4gICAgJyQuZGF0YXNldHMnIC8vIEtlcGxlckdMIEpTT05cbiAgXVxufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGlzR2VvSnNvbihqc29uOiB1bmtub3duKToganNvbiBpcyBGZWF0dXJlIHwgRmVhdHVyZUNvbGxlY3Rpb24ge1xuICAvLyBqc29uIGNhbiBiZSBmZWF0dXJlIGNvbGxlY3Rpb25cbiAgLy8gb3Igc2luZ2xlIGZlYXR1cmVcbiAgcmV0dXJuIGlzUGxhaW5PYmplY3QoanNvbikgJiYgKGlzRmVhdHVyZShqc29uKSB8fCBpc0ZlYXR1cmVDb2xsZWN0aW9uKGpzb24pKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzRmVhdHVyZShqc29uOiB1bmtub3duKToganNvbiBpcyBGZWF0dXJlIHtcbiAgcmV0dXJuIGlzUGxhaW5PYmplY3QoanNvbikgJiYganNvbi50eXBlID09PSAnRmVhdHVyZScgJiYgQm9vbGVhbihqc29uLmdlb21ldHJ5KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzRmVhdHVyZUNvbGxlY3Rpb24oanNvbjogdW5rbm93bik6IGpzb24gaXMgRmVhdHVyZUNvbGxlY3Rpb24ge1xuICByZXR1cm4gaXNQbGFpbk9iamVjdChqc29uKSAmJiBqc29uLnR5cGUgPT09ICdGZWF0dXJlQ29sbGVjdGlvbicgJiYgQm9vbGVhbihqc29uLmZlYXR1cmVzKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzUm93T2JqZWN0KGpzb246IGFueSk6IGJvb2xlYW4ge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShqc29uKSAmJiBpc1BsYWluT2JqZWN0KGpzb25bMF0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNLZXBsZXJHbE1hcChqc29uOiB1bmtub3duKToganNvbiBpcyBWYWxpZEtlcGxlckdsTWFwIHtcbiAgcmV0dXJuIEJvb2xlYW4oXG4gICAgaXNQbGFpbk9iamVjdChqc29uKSAmJlxuICAgICAganNvbi5kYXRhc2V0cyAmJlxuICAgICAganNvbi5jb25maWcgJiZcbiAgICAgIGpzb24uaW5mbyAmJlxuICAgICAgaXNQbGFpbk9iamVjdChqc29uLmluZm8pICYmXG4gICAgICBqc29uLmluZm8uYXBwID09PSAna2VwbGVyLmdsJ1xuICApO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24qIG1ha2VQcm9ncmVzc0l0ZXJhdG9yKFxuICBhc3luY0l0ZXJhdG9yOiBBc3luY0l0ZXJhYmxlPGFueT4sXG4gIGluZm86IHtzaXplOiBudW1iZXJ9XG4pOiBBc3luY0dlbmVyYXRvciB7XG4gIGxldCByb3dDb3VudCA9IDA7XG5cbiAgZm9yIGF3YWl0IChjb25zdCBiYXRjaCBvZiBhc3luY0l0ZXJhdG9yKSB7XG4gICAgY29uc3Qgcm93Q291bnRJbkJhdGNoID0gKGJhdGNoLmRhdGEgJiYgYmF0Y2guZGF0YS5sZW5ndGgpIHx8IDA7XG4gICAgcm93Q291bnQgKz0gcm93Q291bnRJbkJhdGNoO1xuICAgIGNvbnN0IHBlcmNlbnQgPSBOdW1iZXIuaXNGaW5pdGUoYmF0Y2guYnl0ZXNVc2VkKSA/IGJhdGNoLmJ5dGVzVXNlZCAvIGluZm8uc2l6ZSA6IG51bGw7XG5cbiAgICAvLyBVcGRhdGUgcHJvZ3Jlc3Mgb2JqZWN0XG4gICAgY29uc3QgcHJvZ3Jlc3MgPSB7XG4gICAgICByb3dDb3VudCxcbiAgICAgIHJvd0NvdW50SW5CYXRjaCxcbiAgICAgIC4uLihOdW1iZXIuaXNGaW5pdGUocGVyY2VudCkgPyB7cGVyY2VudH0gOiB7fSlcbiAgICB9O1xuXG4gICAgeWllbGQgey4uLmJhdGNoLCBwcm9ncmVzc307XG4gIH1cbn1cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiogcmVhZEJhdGNoKFxuICBhc3luY0l0ZXJhdG9yOiBBc3luY0l0ZXJhYmxlPGFueT4sXG4gIGZpbGVOYW1lOiBzdHJpbmdcbik6IEFzeW5jR2VuZXJhdG9yIHtcbiAgbGV0IHJlc3VsdCA9IG51bGw7XG4gIGNvbnN0IGJhdGNoZXMgPSA8YW55PltdO1xuXG4gIGZvciBhd2FpdCAoY29uc3QgYmF0Y2ggb2YgYXN5bmNJdGVyYXRvcikge1xuICAgIC8vIExhc3QgYmF0Y2ggd2lsbCBoYXZlIHRoaXMgc3BlY2lhbCB0eXBlIGFuZCB3aWxsIHByb3ZpZGUgYWxsIHRoZSByb290XG4gICAgLy8gcHJvcGVydGllcyBvZiB0aGUgcGFyc2VkIGRvY3VtZW50LlxuICAgIC8vIE9ubHkganNvbiBwYXJzZSB3aWxsIGhhdmUgYEZJTkFMX1JFU1VMVGBcbiAgICBpZiAoYmF0Y2guYmF0Y2hUeXBlID09PSBCQVRDSF9UWVBFLkZJTkFMX1JFU1VMVCkge1xuICAgICAgaWYgKGJhdGNoLmNvbnRhaW5lcikge1xuICAgICAgICByZXN1bHQgPSB7Li4uYmF0Y2guY29udGFpbmVyfTtcbiAgICAgIH1cbiAgICAgIC8vIFNldCB0aGUgc3RyZWFtZWQgZGF0YSBjb3JyZWN0bHkgaXMgQmF0Y2gganNvbiBwYXRoIGlzIHNldFxuICAgICAgLy8gYW5kIHRoZSBwYXRoIHN0cmVhbWVkIGlzIG5vdCB0aGUgdG9wIGxldmVsIG9iamVjdCAoanNvbnBhdGggPSAnJCcpXG4gICAgICBpZiAoYmF0Y2guanNvbnBhdGggJiYgYmF0Y2guanNvbnBhdGgubGVuZ3RoID4gMSkge1xuICAgICAgICBjb25zdCBzdHJlYW1pbmdQYXRoID0gbmV3IF9KU09OUGF0aChiYXRjaC5qc29ucGF0aCk7XG4gICAgICAgIHN0cmVhbWluZ1BhdGguc2V0RmllbGRBdFBhdGgocmVzdWx0LCBiYXRjaGVzKTtcbiAgICAgIH0gZWxzZSBpZiAoYmF0Y2guanNvbnBhdGggJiYgYmF0Y2guanNvbnBhdGgubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIC8vIFRoZSBzdHJlYW1lZCBvYmplY3QgaXMgYSBST1cgSlNPTi1iYXRjaCAoanNvbnBhdGggPSAnJCcpXG4gICAgICAgIC8vIHJvdyBvYmplY3RzXG4gICAgICAgIHJlc3VsdCA9IGJhdGNoZXM7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmF0Y2guZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICBiYXRjaGVzLnB1c2goYmF0Y2guZGF0YVtpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgeWllbGQge1xuICAgICAgLi4uYmF0Y2gsXG4gICAgICAuLi4oYmF0Y2guc2NoZW1hID8ge2hlYWRlcnM6IE9iamVjdC5rZXlzKGJhdGNoLnNjaGVtYSl9IDoge30pLFxuICAgICAgZmlsZU5hbWUsXG4gICAgICAvLyBpZiBkYXRhc2V0IGlzIENTViwgZGF0YSBpcyBzZXQgdG8gdGhlIHJhdyBiYXRjaGVzXG4gICAgICBkYXRhOiByZXN1bHQgPyByZXN1bHQgOiBiYXRjaGVzXG4gICAgfTtcbiAgfVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVhZEZpbGVJbkJhdGNoZXMoe1xuICBmaWxlLFxuICBsb2FkZXJzID0gW10sXG4gIGxvYWRPcHRpb25zID0ge31cbn06IHtcbiAgZmlsZTogRmlsZTtcbiAgZmlsZUNhY2hlOiBGaWxlQ2FjaGVJdGVtW107XG4gIGxvYWRlcnM6IExvYWRlcltdO1xuICBsb2FkT3B0aW9uczogYW55O1xufSk6IFByb21pc2U8QXN5bmNHZW5lcmF0b3I+IHtcbiAgbG9hZGVycyA9IFtKU09OTG9hZGVyLCBDU1ZMb2FkZXIsIC4uLmxvYWRlcnNdO1xuICBsb2FkT3B0aW9ucyA9IHtcbiAgICBjc3Y6IENTVl9MT0FERVJfT1BUSU9OUyxcbiAgICBqc29uOiBKU09OX0xPQURFUl9PUFRJT05TLFxuICAgIG1ldGFkYXRhOiB0cnVlLFxuICAgIC4uLmxvYWRPcHRpb25zXG4gIH07XG5cbiAgY29uc3QgYmF0Y2hJdGVyYXRvciA9IGF3YWl0IHBhcnNlSW5CYXRjaGVzKGZpbGUsIGxvYWRlcnMsIGxvYWRPcHRpb25zKTtcbiAgY29uc3QgcHJvZ3Jlc3NJdGVyYXRvciA9IG1ha2VQcm9ncmVzc0l0ZXJhdG9yKGJhdGNoSXRlcmF0b3IsIHtzaXplOiBmaWxlLnNpemV9KTtcblxuICByZXR1cm4gcmVhZEJhdGNoKHByb2dyZXNzSXRlcmF0b3IsIGZpbGUubmFtZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwcm9jZXNzRmlsZURhdGEoe1xuICBjb250ZW50LFxuICBmaWxlQ2FjaGVcbn06IHtcbiAgY29udGVudDoge2RhdGE6IHVua25vd247IGZpbGVOYW1lOiBzdHJpbmd9O1xuICBmaWxlQ2FjaGU6IEZpbGVDYWNoZUl0ZW1bXTtcbn0pOiBQcm9taXNlPEZpbGVDYWNoZUl0ZW1bXT4ge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IHtkYXRhfSA9IGNvbnRlbnQ7XG5cbiAgICBsZXQgZm9ybWF0OiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gICAgbGV0IHByb2Nlc3NvcjogRnVuY3Rpb24gfCB1bmRlZmluZWQ7XG4gICAgaWYgKGlzS2VwbGVyR2xNYXAoZGF0YSkpIHtcbiAgICAgIGZvcm1hdCA9IERBVEFTRVRfRk9STUFUUy5rZXBsZXJnbDtcbiAgICAgIHByb2Nlc3NvciA9IHByb2Nlc3NLZXBsZXJnbEpTT047XG4gICAgfSBlbHNlIGlmIChpc1Jvd09iamVjdChkYXRhKSkge1xuICAgICAgZm9ybWF0ID0gREFUQVNFVF9GT1JNQVRTLnJvdztcbiAgICAgIHByb2Nlc3NvciA9IHByb2Nlc3NSb3dPYmplY3Q7XG4gICAgfSBlbHNlIGlmIChpc0dlb0pzb24oZGF0YSkpIHtcbiAgICAgIGZvcm1hdCA9IERBVEFTRVRfRk9STUFUUy5nZW9qc29uO1xuICAgICAgcHJvY2Vzc29yID0gcHJvY2Vzc0dlb2pzb247XG4gICAgfVxuXG4gICAgaWYgKGZvcm1hdCAmJiBwcm9jZXNzb3IpIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHByb2Nlc3NvcihkYXRhKTtcblxuICAgICAgcmVzb2x2ZShbXG4gICAgICAgIC4uLmZpbGVDYWNoZSxcbiAgICAgICAge1xuICAgICAgICAgIGRhdGE6IHJlc3VsdCxcbiAgICAgICAgICBpbmZvOiB7XG4gICAgICAgICAgICBsYWJlbDogY29udGVudC5maWxlTmFtZSxcbiAgICAgICAgICAgIGZvcm1hdFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgXSk7XG4gICAgfVxuXG4gICAgcmVqZWN0KCdVbmtub3duIEZpbGUgRm9ybWF0Jyk7XG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZmlsZXNUb0RhdGFQYXlsb2FkKGZpbGVDYWNoZTogRmlsZUNhY2hlSXRlbVtdKTogQWRkRGF0YVRvTWFwUGF5bG9hZFtdIHtcbiAgLy8gc2VwZXJhdGUgb3V0IGZpbGVzIHdoaWNoIGNvdWxkIGJlIGEgc2luZ2xlIGRhdGFzZXRzLiBvciBhIGtlcGxlcmdsIG1hcCBqc29uXG4gIGNvbnN0IGNvbGxlY3Rpb24gPSBmaWxlQ2FjaGUucmVkdWNlPHtcbiAgICBkYXRhc2V0czogRmlsZUNhY2hlSXRlbVtdO1xuICAgIGtlcGxlck1hcHM6IEFkZERhdGFUb01hcFBheWxvYWRbXTtcbiAgfT4oXG4gICAgKGFjY3UsIGZpbGUpID0+IHtcbiAgICAgIGNvbnN0IHtkYXRhLCBpbmZvfSA9IGZpbGU7XG4gICAgICBpZiAoaW5mbz8uZm9ybWF0ID09PSBEQVRBU0VUX0ZPUk1BVFMua2VwbGVyZ2wpIHtcbiAgICAgICAgLy8gaWYgZmlsZSBjb250YWlucyBhIHNpbmdsZSBrZXBsZXIgbWFwIGRhdGFzZXQgJiBjb25maWdcbiAgICAgICAgYWNjdS5rZXBsZXJNYXBzLnB1c2goe1xuICAgICAgICAgIC4uLmRhdGEsXG4gICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgY2VudGVyTWFwOiAhKGRhdGEuY29uZmlnICYmIGRhdGEuY29uZmlnLm1hcFN0YXRlKVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKERBVEFTRVRfRk9STUFUU1tpbmZvPy5mb3JtYXRdKSB7XG4gICAgICAgIC8vIGlmIGZpbGUgY29udGFpbnMgb25seSBkYXRhXG4gICAgICAgIGNvbnN0IG5ld0RhdGFzZXQgPSB7XG4gICAgICAgICAgZGF0YSxcbiAgICAgICAgICBpbmZvOiB7XG4gICAgICAgICAgICBpZDogaW5mbz8uaWQgfHwgZ2VuZXJhdGVIYXNoSWQoNCksXG4gICAgICAgICAgICAuLi4oaW5mbyB8fCB7fSlcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGFjY3UuZGF0YXNldHMucHVzaChuZXdEYXRhc2V0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhY2N1O1xuICAgIH0sXG4gICAge2RhdGFzZXRzOiBbXSwga2VwbGVyTWFwczogW119XG4gICk7XG5cbiAgLy8gYWRkIGtlcGxlciBtYXAgZmlyc3Qgd2l0aCBjb25maWdcbiAgLy8gYWRkIGRhdGFzZXRzIGxhdGVyIGluIG9uZSBhZGQgZGF0YSBjYWxsXG4gIHJldHVybiBjb2xsZWN0aW9uLmtlcGxlck1hcHMuY29uY2F0KHtkYXRhc2V0czogY29sbGVjdGlvbi5kYXRhc2V0c30pO1xufVxuIl19