// Copyright (c) 2022 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.processCsvData = processCsvData;
exports.parseRowsByFields = parseRowsByFields;
exports.parseCsvRowsByFieldType = parseCsvRowsByFieldType;
exports.processRowObject = processRowObject;
exports.processGeojson = processGeojson;
exports.processKeplerglJSON = processKeplerglJSON;
exports.processKeplerglDataset = processKeplerglDataset;
exports.Processors = exports.DATASET_HANDLERS = exports.PARSE_FIELD_VALUE_FROM_STRING = exports.CSV_NULLS = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _d3Dsv = require("d3-dsv");

var _geojsonNormalize = _interopRequireDefault(require("@mapbox/geojson-normalize"));

var _constants = require("@kepler.gl/constants");

var _utils = require("@kepler.gl/utils");

var _schemas = require("@kepler.gl/schemas");

var _PARSE_FIELD_VALUE_FR, _DATASET_HANDLERS;

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

// if any of these value occurs in csv, parse it to null;
// const CSV_NULLS = ['', 'null', 'NULL', 'Null', 'NaN', '/N'];
// matches empty string
var CSV_NULLS = /^(null|NULL|Null|NaN|\/N||)$/;
exports.CSV_NULLS = CSV_NULLS;
var PARSE_FIELD_VALUE_FROM_STRING = (_PARSE_FIELD_VALUE_FR = {}, (0, _defineProperty2["default"])(_PARSE_FIELD_VALUE_FR, _constants.ALL_FIELD_TYPES["boolean"], {
  valid: function valid(d) {
    return typeof d === 'boolean';
  },
  parse: function parse(d) {
    return d === 'true' || d === 'True' || d === 'TRUE' || d === '1';
  }
}), (0, _defineProperty2["default"])(_PARSE_FIELD_VALUE_FR, _constants.ALL_FIELD_TYPES.integer, {
  // @ts-ignore
  valid: function valid(d) {
    return parseInt(d, 10) === d;
  },
  // @ts-ignore
  parse: function parse(d) {
    return parseInt(d, 10);
  }
}), (0, _defineProperty2["default"])(_PARSE_FIELD_VALUE_FR, _constants.ALL_FIELD_TYPES.timestamp, {
  valid: function valid(d, field) {
    return ['x', 'X'].includes(field.format) ? typeof d === 'number' : typeof d === 'string';
  },
  parse: function parse(d, field) {
    return ['x', 'X'].includes(field.format) ? Number(d) : d;
  }
}), (0, _defineProperty2["default"])(_PARSE_FIELD_VALUE_FR, _constants.ALL_FIELD_TYPES.real, {
  // @ts-ignore
  valid: function valid(d) {
    return parseFloat(d) === d;
  },
  // Note this will result in NaN for some string
  parse: parseFloat
}), _PARSE_FIELD_VALUE_FR);
/**
 * Process csv data, output a data object with `{fields: [], rows: []}`.
 * The data object can be wrapped in a `dataset` and pass to [`addDataToMap`](../actions/actions.md#adddatatomap)
 * @param rawData raw csv string
 * @returns data object `{fields: [], rows: []}` can be passed to addDataToMaps
 * @public
 * @example
 * import {processCsvData} from 'kepler.gl/processors';
 *
 * const testData = `gps_data.utc_timestamp,gps_data.lat,gps_data.lng,gps_data.types,epoch,has_result,id,time,begintrip_ts_utc,begintrip_ts_local,date
 * 2016-09-17 00:09:55,29.9900937,31.2590542,driver_analytics,1472688000000,False,1,2016-09-23T00:00:00.000Z,2016-10-01 09:41:39+00:00,2016-10-01 09:41:39+00:00,2016-09-23
 * 2016-09-17 00:10:56,29.9927699,31.2461142,driver_analytics,1472688000000,False,2,2016-09-23T00:00:00.000Z,2016-10-01 09:46:37+00:00,2016-10-01 16:46:37+00:00,2016-09-23
 * 2016-09-17 00:11:56,29.9907261,31.2312742,driver_analytics,1472688000000,False,3,2016-09-23T00:00:00.000Z,,,2016-09-23
 * 2016-09-17 00:12:58,29.9870074,31.2175827,driver_analytics,1472688000000,False,4,2016-09-23T00:00:00.000Z,,,2016-09-23`
 *
 * const dataset = {
 *  info: {id: 'test_data', label: 'My Csv'},
 *  data: processCsvData(testData)
 * };
 *
 * dispatch(addDataToMap({
 *  datasets: [dataset],
 *  options: {centerMap: true, readOnly: true}
 * }));
 */

exports.PARSE_FIELD_VALUE_FROM_STRING = PARSE_FIELD_VALUE_FROM_STRING;

function processCsvData(rawData, header) {
  var rows;
  var headerRow;

  if (typeof rawData === 'string') {
    var _parsedRows = (0, _d3Dsv.csvParseRows)(rawData);

    if (!Array.isArray(_parsedRows) || _parsedRows.length < 2) {
      // looks like an empty file, throw error to be catch
      throw new Error('process Csv Data Failed: CSV is empty');
    }

    headerRow = _parsedRows[0];
    rows = _parsedRows.slice(1);
  } else if (Array.isArray(rawData) && rawData.length) {
    rows = rawData;
    headerRow = header;

    if (!Array.isArray(headerRow)) {
      // if data is passed in as array of rows and missing header
      // assume first row is header
      // @ts-ignore
      headerRow = rawData[0];
      rows = rawData.slice(1);
    }
  }

  if (!rows || !headerRow) {
    throw new Error('invalid input passed to processCsvData');
  } // here we assume the csv file that people uploaded will have first row
  // as name of the column


  cleanUpFalsyCsvValue(rows); // No need to run type detection on every data point
  // here we get a list of none null values to run analyze on

  var sample = (0, _utils.getSampleForTypeAnalyze)({
    fields: headerRow,
    rows: rows
  });
  var fields = (0, _utils.getFieldsFromData)(sample, headerRow);
  var parsedRows = parseRowsByFields(rows, fields);
  return {
    fields: fields,
    rows: parsedRows
  };
}
/**
 * Parse rows of csv by analyzed field types. So that `'1'` -> `1`, `'True'` -> `true`
 * @param rows
 * @param fields
 */


function parseRowsByFields(rows, fields) {
  // Edit rows in place
  var geojsonFieldIdx = fields.findIndex(function (f) {
    return f.name === '_geojson';
  });
  fields.forEach(parseCsvRowsByFieldType.bind(null, rows, geojsonFieldIdx));
  return rows;
}
/**
 * Convert falsy value in csv including `'', 'null', 'NULL', 'Null', 'NaN'` to `null`,
 * so that type-analyzer won't detect it as string
 *
 * @param rows
 */


function cleanUpFalsyCsvValue(rows) {
  var re = new RegExp(CSV_NULLS, 'g');

  for (var i = 0; i < rows.length; i++) {
    for (var j = 0; j < rows[i].length; j++) {
      // analyzer will set any fields to 'string' if there are empty values
      // which will be parsed as '' by d3.csv
      // here we parse empty data as null
      // TODO: create warning when deltect `CSV_NULLS` in the data
      if (typeof rows[i][j] === 'string' && rows[i][j].match(re)) {
        rows[i][j] = null;
      }
    }
  }
}
/**
 * Process uploaded csv file to parse value by field type
 *
 * @param rows
 * @param geoFieldIdx field index
 * @param field
 * @param i
 */


function parseCsvRowsByFieldType(rows, geoFieldIdx, field, i) {
  var parser = PARSE_FIELD_VALUE_FROM_STRING[field.type];

  if (parser) {
    // check first not null value of it's already parsed
    var first = rows.find(function (r) {
      return (0, _utils.notNullorUndefined)(r[i]);
    });

    if (!first || parser.valid(first[i], field)) {
      return;
    }

    rows.forEach(function (row) {
      // parse string value based on field type
      if (row[i] !== null) {
        row[i] = parser.parse(row[i], field);

        if (geoFieldIdx > -1 && (0, _utils.isPlainObject)(row[geoFieldIdx]) && // @ts-ignore
        (0, _utils.hasOwnProperty)(row[geoFieldIdx], 'properties')) {
          // @ts-ignore
          row[geoFieldIdx].properties[field.name] = row[i];
        }
      }
    });
  }
}
/* eslint-enable complexity */

/**
 * Process data where each row is an object, output can be passed to [`addDataToMap`](../actions/actions.md#adddatatomap)
 * NOTE: This function may mutate input.
 * @param rawData an array of row object, each object should have the same number of keys
 * @returns dataset containing `fields` and `rows`
 * @public
 * @example
 * import {addDataToMap} from 'kepler.gl/actions';
 * import {processRowObject} from 'kepler.gl/processors';
 *
 * const data = [
 *  {lat: 31.27, lng: 127.56, value: 3},
 *  {lat: 31.22, lng: 126.26, value: 1}
 * ];
 *
 * dispatch(addDataToMap({
 *  datasets: {
 *    info: {label: 'My Data', id: 'my_data'},
 *    data: processRowObject(data)
 *  }
 * }));
 */


function processRowObject(rawData) {
  if (!Array.isArray(rawData)) {
    return null;
  } else if (!rawData.length) {
    // data is empty
    return {
      fields: [],
      rows: []
    };
  }

  var keys = Object.keys(rawData[0]); // [lat, lng, value]

  var rows = rawData.map(function (d) {
    return keys.map(function (key) {
      return d[key];
    });
  }); // [[31.27, 127.56, 3]]
  // row object an still contain values like `Null` or `N/A`

  cleanUpFalsyCsvValue(rows);
  return processCsvData(rows, keys);
}
/**
 * Process GeoJSON [`FeatureCollection`](http://wiki.geojson.org/GeoJSON_draft_version_6#FeatureCollection),
 * output a data object with `{fields: [], rows: []}`.
 * The data object can be wrapped in a `dataset` and passed to [`addDataToMap`](../actions/actions.md#adddatatomap)
 * NOTE: This function may mutate input.
 *
 * @param rawData raw geojson feature collection
 * @returns dataset containing `fields` and `rows`
 * @public
 * @example
 * import {addDataToMap} from 'kepler.gl/actions';
 * import {processGeojson} from 'kepler.gl/processors';
 *
 * const geojson = {
 * 	"type" : "FeatureCollection",
 * 	"features" : [{
 * 		"type" : "Feature",
 * 		"properties" : {
 * 			"capacity" : "10",
 * 			"type" : "U-Rack"
 * 		},
 * 		"geometry" : {
 * 			"type" : "Point",
 * 			"coordinates" : [ -71.073283, 42.417500 ]
 * 		}
 * 	}]
 * };
 *
 * dispatch(addDataToMap({
 *  datasets: {
 *    info: {
 *      label: 'Sample Taxi Trips in New York City',
 *      id: 'test_trip_data'
 *    },
 *    data: processGeojson(geojson)
 *  }
 * }));
 */


function processGeojson(rawData) {
  var normalizedGeojson = (0, _geojsonNormalize["default"])(rawData);

  if (!normalizedGeojson || !Array.isArray(normalizedGeojson.features)) {
    var error = new Error("Read File Failed: File is not a valid GeoJSON. Read more about [supported file format](".concat(_constants.GUIDES_FILE_FORMAT_DOC, ")"));
    throw error; // fail to normalize geojson
  } // getting all feature fields


  var allDataRows = [];

  for (var i = 0; i < normalizedGeojson.features.length; i++) {
    var f = normalizedGeojson.features[i];

    if (f.geometry) {
      allDataRows.push(_objectSpread({
        // add feature to _geojson field
        _geojson: f
      }, f.properties || {}));
    }
  } // get all the field


  var fields = allDataRows.reduce(function (accu, curr) {
    Object.keys(curr).forEach(function (key) {
      if (!accu.includes(key)) {
        accu.push(key);
      }
    });
    return accu;
  }, []); // make sure each feature has exact same fields

  allDataRows.forEach(function (d) {
    fields.forEach(function (f) {
      if (!(f in d)) {
        d[f] = null;
        d._geojson.properties[f] = null;
      }
    });
  });
  return processRowObject(allDataRows);
}
/**
 * Process saved kepler.gl json to be pass to [`addDataToMap`](../actions/actions.md#adddatatomap).
 * The json object should contain `datasets` and `config`.
 * @param rawData
 * @param schema
 * @returns datasets and config `{datasets: {}, config: {}}`
 * @public
 * @example
 * import {addDataToMap} from 'kepler.gl/actions';
 * import {processKeplerglJSON} from 'kepler.gl/processors';
 *
 * dispatch(addDataToMap(processKeplerglJSON(keplerGlJson)));
 */


function processKeplerglJSON(rawData) {
  var schema = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _schemas.KeplerGlSchema;
  return rawData ? schema.load(rawData.datasets, rawData.config) : null;
}
/**
 * Parse a single or an array of datasets saved using kepler.gl schema
 * @param rawData
 * @param schema
 */


function processKeplerglDataset(rawData) {
  var schema = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _schemas.KeplerGlSchema;

  if (!rawData) {
    return null;
  }

  var results = schema.parseSavedData((0, _utils.toArray)(rawData));

  if (!results) {
    return null;
  }

  return Array.isArray(rawData) ? results : results[0];
}

var DATASET_HANDLERS = (_DATASET_HANDLERS = {}, (0, _defineProperty2["default"])(_DATASET_HANDLERS, _constants.DATASET_FORMATS.row, processRowObject), (0, _defineProperty2["default"])(_DATASET_HANDLERS, _constants.DATASET_FORMATS.geojson, processGeojson), (0, _defineProperty2["default"])(_DATASET_HANDLERS, _constants.DATASET_FORMATS.csv, processCsvData), (0, _defineProperty2["default"])(_DATASET_HANDLERS, _constants.DATASET_FORMATS.keplergl, processKeplerglDataset), _DATASET_HANDLERS);
exports.DATASET_HANDLERS = DATASET_HANDLERS;
var Processors = {
  processGeojson: processGeojson,
  processCsvData: processCsvData,
  processRowObject: processRowObject,
  processKeplerglJSON: processKeplerglJSON,
  processKeplerglDataset: processKeplerglDataset,
  analyzerTypeToFieldType: _utils.analyzerTypeToFieldType,
  getFieldsFromData: _utils.getFieldsFromData,
  parseCsvRowsByFieldType: parseCsvRowsByFieldType
};
exports.Processors = Processors;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9kYXRhLXByb2Nlc3Nvci50cyJdLCJuYW1lcyI6WyJDU1ZfTlVMTFMiLCJQQVJTRV9GSUVMRF9WQUxVRV9GUk9NX1NUUklORyIsIkFMTF9GSUVMRF9UWVBFUyIsInZhbGlkIiwiZCIsInBhcnNlIiwiaW50ZWdlciIsInBhcnNlSW50IiwidGltZXN0YW1wIiwiZmllbGQiLCJpbmNsdWRlcyIsImZvcm1hdCIsIk51bWJlciIsInJlYWwiLCJwYXJzZUZsb2F0IiwicHJvY2Vzc0NzdkRhdGEiLCJyYXdEYXRhIiwiaGVhZGVyIiwicm93cyIsImhlYWRlclJvdyIsInBhcnNlZFJvd3MiLCJBcnJheSIsImlzQXJyYXkiLCJsZW5ndGgiLCJFcnJvciIsInNsaWNlIiwiY2xlYW5VcEZhbHN5Q3N2VmFsdWUiLCJzYW1wbGUiLCJmaWVsZHMiLCJwYXJzZVJvd3NCeUZpZWxkcyIsImdlb2pzb25GaWVsZElkeCIsImZpbmRJbmRleCIsImYiLCJuYW1lIiwiZm9yRWFjaCIsInBhcnNlQ3N2Um93c0J5RmllbGRUeXBlIiwiYmluZCIsInJlIiwiUmVnRXhwIiwiaSIsImoiLCJtYXRjaCIsImdlb0ZpZWxkSWR4IiwicGFyc2VyIiwidHlwZSIsImZpcnN0IiwiZmluZCIsInIiLCJyb3ciLCJwcm9wZXJ0aWVzIiwicHJvY2Vzc1Jvd09iamVjdCIsImtleXMiLCJPYmplY3QiLCJtYXAiLCJrZXkiLCJwcm9jZXNzR2VvanNvbiIsIm5vcm1hbGl6ZWRHZW9qc29uIiwiZmVhdHVyZXMiLCJlcnJvciIsIkdVSURFU19GSUxFX0ZPUk1BVF9ET0MiLCJhbGxEYXRhUm93cyIsImdlb21ldHJ5IiwicHVzaCIsIl9nZW9qc29uIiwicmVkdWNlIiwiYWNjdSIsImN1cnIiLCJwcm9jZXNzS2VwbGVyZ2xKU09OIiwic2NoZW1hIiwiS2VwbGVyR2xTY2hlbWEiLCJsb2FkIiwiZGF0YXNldHMiLCJjb25maWciLCJwcm9jZXNzS2VwbGVyZ2xEYXRhc2V0IiwicmVzdWx0cyIsInBhcnNlU2F2ZWREYXRhIiwiREFUQVNFVF9IQU5ETEVSUyIsIkRBVEFTRVRfRk9STUFUUyIsImdlb2pzb24iLCJjc3YiLCJrZXBsZXJnbCIsIlByb2Nlc3NvcnMiLCJhbmFseXplclR5cGVUb0ZpZWxkVHlwZSIsImdldEZpZWxkc0Zyb21EYXRhIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFvQkE7O0FBQ0E7O0FBQ0E7O0FBRUE7O0FBU0E7Ozs7Ozs7O0FBR0E7QUFDQTtBQUNBO0FBQ08sSUFBTUEsU0FBUyxHQUFHLDhCQUFsQjs7QUFFQSxJQUFNQyw2QkFBNkIsd0ZBQ3ZDQyxxQ0FEdUMsRUFDYjtBQUN6QkMsRUFBQUEsS0FBSyxFQUFFLGVBQUNDLENBQUQ7QUFBQSxXQUF5QixPQUFPQSxDQUFQLEtBQWEsU0FBdEM7QUFBQSxHQURrQjtBQUV6QkMsRUFBQUEsS0FBSyxFQUFFLGVBQUNELENBQUQ7QUFBQSxXQUF5QkEsQ0FBQyxLQUFLLE1BQU4sSUFBZ0JBLENBQUMsS0FBSyxNQUF0QixJQUFnQ0EsQ0FBQyxLQUFLLE1BQXRDLElBQWdEQSxDQUFDLEtBQUssR0FBL0U7QUFBQTtBQUZrQixDQURhLDJEQUt2Q0YsMkJBQWdCSSxPQUx1QixFQUtiO0FBQ3pCO0FBQ0FILEVBQUFBLEtBQUssRUFBRSxlQUFDQyxDQUFEO0FBQUEsV0FBeUJHLFFBQVEsQ0FBQ0gsQ0FBRCxFQUFJLEVBQUosQ0FBUixLQUFvQkEsQ0FBN0M7QUFBQSxHQUZrQjtBQUd6QjtBQUNBQyxFQUFBQSxLQUFLLEVBQUUsZUFBQ0QsQ0FBRDtBQUFBLFdBQXdCRyxRQUFRLENBQUNILENBQUQsRUFBSSxFQUFKLENBQWhDO0FBQUE7QUFKa0IsQ0FMYSwyREFXdkNGLDJCQUFnQk0sU0FYdUIsRUFXWDtBQUMzQkwsRUFBQUEsS0FBSyxFQUFFLGVBQUNDLENBQUQsRUFBYUssS0FBYjtBQUFBLFdBQ0wsQ0FBQyxHQUFELEVBQU0sR0FBTixFQUFXQyxRQUFYLENBQW9CRCxLQUFLLENBQUNFLE1BQTFCLElBQW9DLE9BQU9QLENBQVAsS0FBYSxRQUFq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QUR4Qix1REFFRTJCLDJCQUFnQkMsT0FGbEIsRUFFNEJ2QixjQUY1Qix1REFHRXNCLDJCQUFnQkUsR0FIbEIsRUFHd0JoRSxjQUh4Qix1REFJRThELDJCQUFnQkcsUUFKbEIsRUFJNkJQLHNCQUo3QixxQkFMTTs7QUFZQSxJQUFNUSxVQVNaLEdBQUc7QUFDRjFCLEVBQUFBLGNBQWMsRUFBZEEsY0FERTtBQUVGeEMsRUFBQUEsY0FBYyxFQUFkQSxjQUZFO0FBR0ZtQyxFQUFBQSxnQkFBZ0IsRUFBaEJBLGdCQUhFO0FBSUZpQixFQUFBQSxtQkFBbUIsRUFBbkJBLG1CQUpFO0FBS0ZNLEVBQUFBLHNCQUFzQixFQUF0QkEsc0JBTEU7QUFNRlMsRUFBQUEsdUJBQXVCLEVBQXZCQSw4QkFORTtBQU9GQyxFQUFBQSxpQkFBaUIsRUFBakJBLHdCQVBFO0FBUUZoRCxFQUFBQSx1QkFBdUIsRUFBdkJBO0FBUkUsQ0FURyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAyMiBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5cbmltcG9ydCB7Y3N2UGFyc2VSb3dzfSBmcm9tICdkMy1kc3YnO1xuaW1wb3J0IG5vcm1hbGl6ZSBmcm9tICdAbWFwYm94L2dlb2pzb24tbm9ybWFsaXplJztcbmltcG9ydCB7QUxMX0ZJRUxEX1RZUEVTLCBEQVRBU0VUX0ZPUk1BVFMsIEdVSURFU19GSUxFX0ZPUk1BVF9ET0N9IGZyb20gJ0BrZXBsZXIuZ2wvY29uc3RhbnRzJztcbmltcG9ydCB7UHJvY2Vzc29yUmVzdWx0LCBGaWVsZH0gZnJvbSAnQGtlcGxlci5nbC90eXBlcyc7XG5pbXBvcnQge1xuICBub3ROdWxsb3JVbmRlZmluZWQsXG4gIGhhc093blByb3BlcnR5LFxuICBpc1BsYWluT2JqZWN0LFxuICBhbmFseXplclR5cGVUb0ZpZWxkVHlwZSxcbiAgZ2V0U2FtcGxlRm9yVHlwZUFuYWx5emUsXG4gIGdldEZpZWxkc0Zyb21EYXRhLFxuICB0b0FycmF5XG59IGZyb20gJ0BrZXBsZXIuZ2wvdXRpbHMnO1xuaW1wb3J0IHtLZXBsZXJHbFNjaGVtYSwgUGFyc2VkRGF0YXNldCwgU2F2ZWRNYXAsIExvYWRlZE1hcH0gZnJvbSAnQGtlcGxlci5nbC9zY2hlbWFzJztcbmltcG9ydCB7RmVhdHVyZX0gZnJvbSAnQG5lYnVsYS5nbC9lZGl0LW1vZGVzJztcblxuLy8gaWYgYW55IG9mIHRoZXNlIHZhbHVlIG9jY3VycyBpbiBjc3YsIHBhcnNlIGl0IHRvIG51bGw7XG4vLyBjb25zdCBDU1ZfTlVMTFMgPSBbJycsICdudWxsJywgJ05VTEwnLCAnTnVsbCcsICdOYU4nLCAnL04nXTtcbi8vIG1hdGNoZXMgZW1wdHkgc3RyaW5nXG5leHBvcnQgY29uc3QgQ1NWX05VTExTID0gL14obnVsbHxOVUxMfE51bGx8TmFOfFxcL058fCkkLztcblxuZXhwb3J0IGNvbnN0IFBBUlNFX0ZJRUxEX1ZBTFVFX0ZST01fU1RSSU5HID0ge1xuICBbQUxMX0ZJRUxEX1RZUEVTLmJvb2xlYW5dOiB7XG4gICAgdmFsaWQ6IChkOiB1bmtub3duKTogYm9vbGVhbiA9PiB0eXBlb2YgZCA9PT0gJ2Jvb2xlYW4nLFxuICAgIHBhcnNlOiAoZDogdW5rbm93bik6IGJvb2xlYW4gPT4gZCA9PT0gJ3RydWUnIHx8IGQgPT09ICdUcnVlJyB8fCBkID09PSAnVFJVRScgfHwgZCA9PT0gJzEnXG4gIH0sXG4gIFtBTExfRklFTERfVFlQRVMuaW50ZWdlcl06IHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdmFsaWQ6IChkOiB1bmtub3duKTogYm9vbGVhbiA9PiBwYXJzZUludChkLCAxMCkgPT09IGQsXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHBhcnNlOiAoZDogdW5rbm93bik6IG51bWJlciA9PiBwYXJzZUludChkLCAxMClcbiAgfSxcbiAgW0FMTF9GSUVMRF9UWVBFUy50aW1lc3RhbXBdOiB7XG4gICAgdmFsaWQ6IChkOiB1bmtub3duLCBmaWVsZDogRmllbGQpOiBib29sZWFuID0+XG4gICAgICBbJ3gnLCAnWCddLmluY2x1ZGVzKGZpZWxkLmZvcm1hdCkgPyB0eXBlb2YgZCA9PT0gJ251bWJlcicgOiB0eXBlb2YgZCA9PT0gJ3N0cmluZycsXG4gICAgcGFyc2U6IChkOiBhbnksIGZpZWxkOiBGaWVsZCkgPT4gKFsneCcsICdYJ10uaW5jbHVkZXMoZmllbGQuZm9ybWF0KSA/IE51bWJlcihkKSA6IGQpXG4gIH0sXG4gIFtBTExfRklFTERfVFlQRVMucmVhbF06IHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdmFsaWQ6IChkOiB1bmtub3duKTogYm9vbGVhbiA9PiBwYXJzZUZsb2F0KGQpID09PSBkLFxuICAgIC8vIE5vdGUgdGhpcyB3aWxsIHJlc3VsdCBpbiBOYU4gZm9yIHNvbWUgc3RyaW5nXG4gICAgcGFyc2U6IHBhcnNlRmxvYXRcbiAgfVxufTtcblxuLyoqXG4gKiBQcm9jZXNzIGNzdiBkYXRhLCBvdXRwdXQgYSBkYXRhIG9iamVjdCB3aXRoIGB7ZmllbGRzOiBbXSwgcm93czogW119YC5cbiAqIFRoZSBkYXRhIG9iamVjdCBjYW4gYmUgd3JhcHBlZCBpbiBhIGBkYXRhc2V0YCBhbmQgcGFzcyB0byBbYGFkZERhdGFUb01hcGBdKC4uL2FjdGlvbnMvYWN0aW9ucy5tZCNhZGRkYXRhdG9tYXApXG4gKiBAcGFyYW0gcmF3RGF0YSByYXcgY3N2IHN0cmluZ1xuICogQHJldHVybnMgZGF0YSBvYmplY3QgYHtmaWVsZHM6IFtdLCByb3dzOiBbXX1gIGNhbiBiZSBwYXNzZWQgdG8gYWRkRGF0YVRvTWFwc1xuICogQHB1YmxpY1xuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7cHJvY2Vzc0NzdkRhdGF9IGZyb20gJ2tlcGxlci5nbC9wcm9jZXNzb3JzJztcbiAqXG4gKiBjb25zdCB0ZXN0RGF0YSA9IGBncHNfZGF0YS51dGNfdGltZXN0YW1wLGdwc19kYXRhLmxhdCxncHNfZGF0YS5sbmcsZ3BzX2RhdGEudHlwZXMsZXBvY2gsaGFzX3Jlc3VsdCxpZCx0aW1lLGJlZ2ludHJpcF90c191dGMsYmVnaW50cmlwX3RzX2xvY2FsLGRhdGVcbiAqIDIwMTYtMDktMTcgMDA6MDk6NTUsMjkuOTkwMDkzNywzMS4yNTkwNTQyLGRyaXZlcl9hbmFseXRpY3MsMTQ3MjY4ODAwMDAwMCxGYWxzZSwxLDIwMTYtMDktMjNUMDA6MDA6MDAuMDAwWiwyMDE2LTEwLTAxIDA5OjQxOjM5KzAwOjAwLDIwMTYtMTAtMDEgMDk6NDE6MzkrMDA6MDAsMjAxNi0wOS0yM1xuICogMjAxNi0wOS0xNyAwMDoxMDo1NiwyOS45OTI3Njk5LDMxLjI0NjExNDIsZHJpdmVyX2FuYWx5dGljcywxNDcyNjg4MDAwMDAwLEZhbHNlLDIsMjAxNi0wOS0yM1QwMDowMDowMC4wMDBaLDIwMTYtMTAtMDEgMDk6NDY6MzcrMDA6MDAsMjAxNi0xMC0wMSAxNjo0NjozNyswMDowMCwyMDE2LTA5LTIzXG4gKiAyMDE2LTA5LTE3IDAwOjExOjU2LDI5Ljk5MDcyNjEsMzEuMjMxMjc0Mixkcml2ZXJfYW5hbHl0aWNzLDE0NzI2ODgwMDAwMDAsRmFsc2UsMywyMDE2LTA5LTIzVDAwOjAwOjAwLjAwMFosLCwyMDE2LTA5LTIzXG4gKiAyMDE2LTA5LTE3IDAwOjEyOjU4LDI5Ljk4NzAwNzQsMzEuMjE3NTgyNyxkcml2ZXJfYW5hbHl0aWNzLDE0NzI2ODgwMDAwMDAsRmFsc2UsNCwyMDE2LTA5LTIzVDAwOjAwOjAwLjAwMFosLCwyMDE2LTA5LTIzYFxuICpcbiAqIGNvbnN0IGRhdGFzZXQgPSB7XG4gKiAgaW5mbzoge2lkOiAndGVzdF9kYXRhJywgbGFiZWw6ICdNeSBDc3YnfSxcbiAqICBkYXRhOiBwcm9jZXNzQ3N2RGF0YSh0ZXN0RGF0YSlcbiAqIH07XG4gKlxuICogZGlzcGF0Y2goYWRkRGF0YVRvTWFwKHtcbiAqICBkYXRhc2V0czogW2RhdGFzZXRdLFxuICogIG9wdGlvbnM6IHtjZW50ZXJNYXA6IHRydWUsIHJlYWRPbmx5OiB0cnVlfVxuICogfSkpO1xuICovXG5leHBvcnQgZnVuY3Rpb24gcHJvY2Vzc0NzdkRhdGEocmF3RGF0YTogdW5rbm93bltdW10sIGhlYWRlcj86IHN0cmluZ1tdKTogUHJvY2Vzc29yUmVzdWx0IHtcbiAgbGV0IHJvd3M6IHVua25vd25bXVtdIHwgdW5kZWZpbmVkO1xuICBsZXQgaGVhZGVyUm93OiBzdHJpbmdbXSB8IHVuZGVmaW5lZDtcblxuICBpZiAodHlwZW9mIHJhd0RhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgY29uc3QgcGFyc2VkUm93czogc3RyaW5nW11bXSA9IGNzdlBhcnNlUm93cyhyYXdEYXRhKTtcblxuICAgIGlmICghQXJyYXkuaXNBcnJheShwYXJzZWRSb3dzKSB8fCBwYXJzZWRSb3dzLmxlbmd0aCA8IDIpIHtcbiAgICAgIC8vIGxvb2tzIGxpa2UgYW4gZW1wdHkgZmlsZSwgdGhyb3cgZXJyb3IgdG8gYmUgY2F0Y2hcbiAgICAgIHRocm93IG5ldyBFcnJvcigncHJvY2VzcyBDc3YgRGF0YSBGYWlsZWQ6IENTViBpcyBlbXB0eScpO1xuICAgIH1cbiAgICBoZWFkZXJSb3cgPSBwYXJzZWRSb3dzWzBdO1xuICAgIHJvd3MgPSBwYXJzZWRSb3dzLnNsaWNlKDEpO1xuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocmF3RGF0YSkgJiYgcmF3RGF0YS5sZW5ndGgpIHtcbiAgICByb3dzID0gcmF3RGF0YTtcbiAgICBoZWFkZXJSb3cgPSBoZWFkZXI7XG5cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoaGVhZGVyUm93KSkge1xuICAgICAgLy8gaWYgZGF0YSBpcyBwYXNzZWQgaW4gYXMgYXJyYXkgb2Ygcm93cyBhbmQgbWlzc2luZyBoZWFkZXJcbiAgICAgIC8vIGFzc3VtZSBmaXJzdCByb3cgaXMgaGVhZGVyXG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBoZWFkZXJSb3cgPSByYXdEYXRhWzBdO1xuICAgICAgcm93cyA9IHJhd0RhdGEuc2xpY2UoMSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFyb3dzIHx8ICFoZWFkZXJSb3cpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgaW5wdXQgcGFzc2VkIHRvIHByb2Nlc3NDc3ZEYXRhJyk7XG4gIH1cblxuICAvLyBoZXJlIHdlIGFzc3VtZSB0aGUgY3N2IGZpbGUgdGhhdCBwZW9wbGUgdXBsb2FkZWQgd2lsbCBoYXZlIGZpcnN0IHJvd1xuICAvLyBhcyBuYW1lIG9mIHRoZSBjb2x1bW5cblxuICBjbGVhblVwRmFsc3lDc3ZWYWx1ZShyb3dzKTtcbiAgLy8gTm8gbmVlZCB0byBydW4gdHlwZSBkZXRlY3Rpb24gb24gZXZlcnkgZGF0YSBwb2ludFxuICAvLyBoZXJlIHdlIGdldCBhIGxpc3Qgb2Ygbm9uZSBudWxsIHZhbHVlcyB0byBydW4gYW5hbHl6ZSBvblxuICBjb25zdCBzYW1wbGUgPSBnZXRTYW1wbGVGb3JUeXBlQW5hbHl6ZSh7ZmllbGRzOiBoZWFkZXJSb3csIHJvd3N9KTtcbiAgY29uc3QgZmllbGRzID0gZ2V0RmllbGRzRnJvbURhdGEoc2FtcGxlLCBoZWFkZXJSb3cpO1xuICBjb25zdCBwYXJzZWRSb3dzID0gcGFyc2VSb3dzQnlGaWVsZHMocm93cywgZmllbGRzKTtcblxuICByZXR1cm4ge2ZpZWxkcywgcm93czogcGFyc2VkUm93c307XG59XG5cbi8qKlxuICogUGFyc2Ugcm93cyBvZiBjc3YgYnkgYW5hbHl6ZWQgZmllbGQgdHlwZXMuIFNvIHRoYXQgYCcxJ2AgLT4gYDFgLCBgJ1RydWUnYCAtPiBgdHJ1ZWBcbiAqIEBwYXJhbSByb3dzXG4gKiBAcGFyYW0gZmllbGRzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVJvd3NCeUZpZWxkcyhyb3dzOiBhbnlbXVtdLCBmaWVsZHM6IEZpZWxkW10pIHtcbiAgLy8gRWRpdCByb3dzIGluIHBsYWNlXG4gIGNvbnN0IGdlb2pzb25GaWVsZElkeCA9IGZpZWxkcy5maW5kSW5kZXgoZiA9PiBmLm5hbWUgPT09ICdfZ2VvanNvbicpO1xuICBmaWVsZHMuZm9yRWFjaChwYXJzZUNzdlJvd3NCeUZpZWxkVHlwZS5iaW5kKG51bGwsIHJvd3MsIGdlb2pzb25GaWVsZElkeCkpO1xuXG4gIHJldHVybiByb3dzO1xufVxuXG4vKipcbiAqIENvbnZlcnQgZmFsc3kgdmFsdWUgaW4gY3N2IGluY2x1ZGluZyBgJycsICdudWxsJywgJ05VTEwnLCAnTnVsbCcsICdOYU4nYCB0byBgbnVsbGAsXG4gKiBzbyB0aGF0IHR5cGUtYW5hbHl6ZXIgd29uJ3QgZGV0ZWN0IGl0IGFzIHN0cmluZ1xuICpcbiAqIEBwYXJhbSByb3dzXG4gKi9cbmZ1bmN0aW9uIGNsZWFuVXBGYWxzeUNzdlZhbHVlKHJvd3M6IHVua25vd25bXVtdKTogdm9pZCB7XG4gIGNvbnN0IHJlID0gbmV3IFJlZ0V4cChDU1ZfTlVMTFMsICdnJyk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcm93cy5sZW5ndGg7IGkrKykge1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgcm93c1tpXS5sZW5ndGg7IGorKykge1xuICAgICAgLy8gYW5hbHl6ZXIgd2lsbCBzZXQgYW55IGZpZWxkcyB0byAnc3RyaW5nJyBpZiB0aGVyZSBhcmUgZW1wdHkgdmFsdWVzXG4gICAgICAvLyB3aGljaCB3aWxsIGJlIHBhcnNlZCBhcyAnJyBieSBkMy5jc3ZcbiAgICAgIC8vIGhlcmUgd2UgcGFyc2UgZW1wdHkgZGF0YSBhcyBudWxsXG4gICAgICAvLyBUT0RPOiBjcmVhdGUgd2FybmluZyB3aGVuIGRlbHRlY3QgYENTVl9OVUxMU2AgaW4gdGhlIGRhdGFcbiAgICAgIGlmICh0eXBlb2Ygcm93c1tpXVtqXSA9PT0gJ3N0cmluZycgJiYgKHJvd3NbaV1bal0gYXMgc3RyaW5nKS5tYXRjaChyZSkpIHtcbiAgICAgICAgcm93c1tpXVtqXSA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUHJvY2VzcyB1cGxvYWRlZCBjc3YgZmlsZSB0byBwYXJzZSB2YWx1ZSBieSBmaWVsZCB0eXBlXG4gKlxuICogQHBhcmFtIHJvd3NcbiAqIEBwYXJhbSBnZW9GaWVsZElkeCBmaWVsZCBpbmRleFxuICogQHBhcmFtIGZpZWxkXG4gKiBAcGFyYW0gaVxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VDc3ZSb3dzQnlGaWVsZFR5cGUoXG4gIHJvd3M6IHVua25vd25bXVtdLFxuICBnZW9GaWVsZElkeDogbnVtYmVyLFxuICBmaWVsZDogRmllbGQsXG4gIGk6IG51bWJlclxuKTogdm9pZCB7XG4gIGNvbnN0IHBhcnNlciA9IFBBUlNFX0ZJRUxEX1ZBTFVFX0ZST01fU1RSSU5HW2ZpZWxkLnR5cGVdO1xuICBpZiAocGFyc2VyKSB7XG4gICAgLy8gY2hlY2sgZmlyc3Qgbm90IG51bGwgdmFsdWUgb2YgaXQncyBhbHJlYWR5IHBhcnNlZFxuICAgIGNvbnN0IGZpcnN0ID0gcm93cy5maW5kKHIgPT4gbm90TnVsbG9yVW5kZWZpbmVkKHJbaV0pKTtcbiAgICBpZiAoIWZpcnN0IHx8IHBhcnNlci52YWxpZChmaXJzdFtpXSwgZmllbGQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJvd3MuZm9yRWFjaChyb3cgPT4ge1xuICAgICAgLy8gcGFyc2Ugc3RyaW5nIHZhbHVlIGJhc2VkIG9uIGZpZWxkIHR5cGVcbiAgICAgIGlmIChyb3dbaV0gIT09IG51bGwpIHtcbiAgICAgICAgcm93W2ldID0gcGFyc2VyLnBhcnNlKHJvd1tpXSwgZmllbGQpO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgZ2VvRmllbGRJZHggPiAtMSAmJlxuICAgICAgICAgIGlzUGxhaW5PYmplY3Qocm93W2dlb0ZpZWxkSWR4XSkgJiZcbiAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgaGFzT3duUHJvcGVydHkocm93W2dlb0ZpZWxkSWR4XSwgJ3Byb3BlcnRpZXMnKVxuICAgICAgICApIHtcbiAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgcm93W2dlb0ZpZWxkSWR4XS5wcm9wZXJ0aWVzW2ZpZWxkLm5hbWVdID0gcm93W2ldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxuLyogZXNsaW50LWVuYWJsZSBjb21wbGV4aXR5ICovXG5cbi8qKlxuICogUHJvY2VzcyBkYXRhIHdoZXJlIGVhY2ggcm93IGlzIGFuIG9iamVjdCwgb3V0cHV0IGNhbiBiZSBwYXNzZWQgdG8gW2BhZGREYXRhVG9NYXBgXSguLi9hY3Rpb25zL2FjdGlvbnMubWQjYWRkZGF0YXRvbWFwKVxuICogTk9URTogVGhpcyBmdW5jdGlvbiBtYXkgbXV0YXRlIGlucHV0LlxuICogQHBhcmFtIHJhd0RhdGEgYW4gYXJyYXkgb2Ygcm93IG9iamVjdCwgZWFjaCBvYmplY3Qgc2hvdWxkIGhhdmUgdGhlIHNhbWUgbnVtYmVyIG9mIGtleXNcbiAqIEByZXR1cm5zIGRhdGFzZXQgY29udGFpbmluZyBgZmllbGRzYCBhbmQgYHJvd3NgXG4gKiBAcHVibGljXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHthZGREYXRhVG9NYXB9IGZyb20gJ2tlcGxlci5nbC9hY3Rpb25zJztcbiAqIGltcG9ydCB7cHJvY2Vzc1Jvd09iamVjdH0gZnJvbSAna2VwbGVyLmdsL3Byb2Nlc3NvcnMnO1xuICpcbiAqIGNvbnN0IGRhdGEgPSBbXG4gKiAge2xhdDogMzEuMjcsIGxuZzogMTI3LjU2LCB2YWx1ZTogM30sXG4gKiAge2xhdDogMzEuMjIsIGxuZzogMTI2LjI2LCB2YWx1ZTogMX1cbiAqIF07XG4gKlxuICogZGlzcGF0Y2goYWRkRGF0YVRvTWFwKHtcbiAqICBkYXRhc2V0czoge1xuICogICAgaW5mbzoge2xhYmVsOiAnTXkgRGF0YScsIGlkOiAnbXlfZGF0YSd9LFxuICogICAgZGF0YTogcHJvY2Vzc1Jvd09iamVjdChkYXRhKVxuICogIH1cbiAqIH0pKTtcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByb2Nlc3NSb3dPYmplY3QocmF3RGF0YTogdW5rbm93bltdKTogUHJvY2Vzc29yUmVzdWx0IHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KHJhd0RhdGEpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0gZWxzZSBpZiAoIXJhd0RhdGEubGVuZ3RoKSB7XG4gICAgLy8gZGF0YSBpcyBlbXB0eVxuICAgIHJldHVybiB7XG4gICAgICBmaWVsZHM6IFtdLFxuICAgICAgcm93czogW11cbiAgICB9O1xuICB9XG5cbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHJhd0RhdGFbMF0pOyAvLyBbbGF0LCBsbmcsIHZhbHVlXVxuICBjb25zdCByb3dzID0gcmF3RGF0YS5tYXAoZCA9PiBrZXlzLm1hcChrZXkgPT4gZFtrZXldKSk7IC8vIFtbMzEuMjcsIDEyNy41NiwgM11dXG5cbiAgLy8gcm93IG9iamVjdCBhbiBzdGlsbCBjb250YWluIHZhbHVlcyBsaWtlIGBOdWxsYCBvciBgTi9BYFxuICBjbGVhblVwRmFsc3lDc3ZWYWx1ZShyb3dzKTtcblxuICByZXR1cm4gcHJvY2Vzc0NzdkRhdGEocm93cywga2V5cyk7XG59XG5cbi8qKlxuICogUHJvY2VzcyBHZW9KU09OIFtgRmVhdHVyZUNvbGxlY3Rpb25gXShodHRwOi8vd2lraS5nZW9qc29uLm9yZy9HZW9KU09OX2RyYWZ0X3ZlcnNpb25fNiNGZWF0dXJlQ29sbGVjdGlvbiksXG4gKiBvdXRwdXQgYSBkYXRhIG9iamVjdCB3aXRoIGB7ZmllbGRzOiBbXSwgcm93czogW119YC5cbiAqIFRoZSBkYXRhIG9iamVjdCBjYW4gYmUgd3JhcHBlZCBpbiBhIGBkYXRhc2V0YCBhbmQgcGFzc2VkIHRvIFtgYWRkRGF0YVRvTWFwYF0oLi4vYWN0aW9ucy9hY3Rpb25zLm1kI2FkZGRhdGF0b21hcClcbiAqIE5PVEU6IFRoaXMgZnVuY3Rpb24gbWF5IG11dGF0ZSBpbnB1dC5cbiAqXG4gKiBAcGFyYW0gcmF3RGF0YSByYXcgZ2VvanNvbiBmZWF0dXJlIGNvbGxlY3Rpb25cbiAqIEByZXR1cm5zIGRhdGFzZXQgY29udGFpbmluZyBgZmllbGRzYCBhbmQgYHJvd3NgXG4gKiBAcHVibGljXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHthZGREYXRhVG9NYXB9IGZyb20gJ2tlcGxlci5nbC9hY3Rpb25zJztcbiAqIGltcG9ydCB7cHJvY2Vzc0dlb2pzb259IGZyb20gJ2tlcGxlci5nbC9wcm9jZXNzb3JzJztcbiAqXG4gKiBjb25zdCBnZW9qc29uID0ge1xuICogXHRcInR5cGVcIiA6IFwiRmVhdHVyZUNvbGxlY3Rpb25cIixcbiAqIFx0XCJmZWF0dXJlc1wiIDogW3tcbiAqIFx0XHRcInR5cGVcIiA6IFwiRmVhdHVyZVwiLFxuICogXHRcdFwicHJvcGVydGllc1wiIDoge1xuICogXHRcdFx0XCJjYXBhY2l0eVwiIDogXCIxMFwiLFxuICogXHRcdFx0XCJ0eXBlXCIgOiBcIlUtUmFja1wiXG4gKiBcdFx0fSxcbiAqIFx0XHRcImdlb21ldHJ5XCIgOiB7XG4gKiBcdFx0XHRcInR5cGVcIiA6IFwiUG9pbnRcIixcbiAqIFx0XHRcdFwiY29vcmRpbmF0ZXNcIiA6IFsgLTcxLjA3MzI4MywgNDIuNDE3NTAwIF1cbiAqIFx0XHR9XG4gKiBcdH1dXG4gKiB9O1xuICpcbiAqIGRpc3BhdGNoKGFkZERhdGFUb01hcCh7XG4gKiAgZGF0YXNldHM6IHtcbiAqICAgIGluZm86IHtcbiAqICAgICAgbGFiZWw6ICdTYW1wbGUgVGF4aSBUcmlwcyBpbiBOZXcgWW9yayBDaXR5JyxcbiAqICAgICAgaWQ6ICd0ZXN0X3RyaXBfZGF0YSdcbiAqICAgIH0sXG4gKiAgICBkYXRhOiBwcm9jZXNzR2VvanNvbihnZW9qc29uKVxuICogIH1cbiAqIH0pKTtcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByb2Nlc3NHZW9qc29uKHJhd0RhdGE6IHVua25vd24pOiBQcm9jZXNzb3JSZXN1bHQge1xuICBjb25zdCBub3JtYWxpemVkR2VvanNvbiA9IG5vcm1hbGl6ZShyYXdEYXRhKTtcblxuICBpZiAoIW5vcm1hbGl6ZWRHZW9qc29uIHx8ICFBcnJheS5pc0FycmF5KG5vcm1hbGl6ZWRHZW9qc29uLmZlYXR1cmVzKSkge1xuICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKFxuICAgICAgYFJlYWQgRmlsZSBGYWlsZWQ6IEZpbGUgaXMgbm90IGEgdmFsaWQgR2VvSlNPTi4gUmVhZCBtb3JlIGFib3V0IFtzdXBwb3J0ZWQgZmlsZSBmb3JtYXRdKCR7R1VJREVTX0ZJTEVfRk9STUFUX0RPQ30pYFxuICAgICk7XG4gICAgdGhyb3cgZXJyb3I7XG4gICAgLy8gZmFpbCB0byBub3JtYWxpemUgZ2VvanNvblxuICB9XG5cbiAgLy8gZ2V0dGluZyBhbGwgZmVhdHVyZSBmaWVsZHNcbiAgY29uc3QgYWxsRGF0YVJvd3M6IEFycmF5PHtfZ2VvanNvbjogRmVhdHVyZX0gJiBrZXlvZiBGZWF0dXJlPiA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG5vcm1hbGl6ZWRHZW9qc29uLmZlYXR1cmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgZiA9IG5vcm1hbGl6ZWRHZW9qc29uLmZlYXR1cmVzW2ldO1xuICAgIGlmIChmLmdlb21ldHJ5KSB7XG4gICAgICBhbGxEYXRhUm93cy5wdXNoKHtcbiAgICAgICAgLy8gYWRkIGZlYXR1cmUgdG8gX2dlb2pzb24gZmllbGRcbiAgICAgICAgX2dlb2pzb246IGYsXG4gICAgICAgIC4uLihmLnByb3BlcnRpZXMgfHwge30pXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgLy8gZ2V0IGFsbCB0aGUgZmllbGRcbiAgY29uc3QgZmllbGRzID0gYWxsRGF0YVJvd3MucmVkdWNlPHN0cmluZ1tdPigoYWNjdSwgY3VycikgPT4ge1xuICAgIE9iamVjdC5rZXlzKGN1cnIpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIGlmICghYWNjdS5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgIGFjY3UucHVzaChrZXkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBhY2N1O1xuICB9LCBbXSk7XG5cbiAgLy8gbWFrZSBzdXJlIGVhY2ggZmVhdHVyZSBoYXMgZXhhY3Qgc2FtZSBmaWVsZHNcbiAgYWxsRGF0YVJvd3MuZm9yRWFjaChkID0+IHtcbiAgICBmaWVsZHMuZm9yRWFjaChmID0+IHtcbiAgICAgIGlmICghKGYgaW4gZCkpIHtcbiAgICAgICAgZFtmXSA9IG51bGw7XG4gICAgICAgIGQuX2dlb2pzb24ucHJvcGVydGllc1tmXSA9IG51bGw7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuXG4gIHJldHVybiBwcm9jZXNzUm93T2JqZWN0KGFsbERhdGFSb3dzKTtcbn1cblxuLyoqXG4gKiBQcm9jZXNzIHNhdmVkIGtlcGxlci5nbCBqc29uIHRvIGJlIHBhc3MgdG8gW2BhZGREYXRhVG9NYXBgXSguLi9hY3Rpb25zL2FjdGlvbnMubWQjYWRkZGF0YXRvbWFwKS5cbiAqIFRoZSBqc29uIG9iamVjdCBzaG91bGQgY29udGFpbiBgZGF0YXNldHNgIGFuZCBgY29uZmlnYC5cbiAqIEBwYXJhbSByYXdEYXRhXG4gKiBAcGFyYW0gc2NoZW1hXG4gKiBAcmV0dXJucyBkYXRhc2V0cyBhbmQgY29uZmlnIGB7ZGF0YXNldHM6IHt9LCBjb25maWc6IHt9fWBcbiAqIEBwdWJsaWNcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQge2FkZERhdGFUb01hcH0gZnJvbSAna2VwbGVyLmdsL2FjdGlvbnMnO1xuICogaW1wb3J0IHtwcm9jZXNzS2VwbGVyZ2xKU09OfSBmcm9tICdrZXBsZXIuZ2wvcHJvY2Vzc29ycyc7XG4gKlxuICogZGlzcGF0Y2goYWRkRGF0YVRvTWFwKHByb2Nlc3NLZXBsZXJnbEpTT04oa2VwbGVyR2xKc29uKSkpO1xuICovXG5leHBvcnQgZnVuY3Rpb24gcHJvY2Vzc0tlcGxlcmdsSlNPTihyYXdEYXRhOiBTYXZlZE1hcCwgc2NoZW1hID0gS2VwbGVyR2xTY2hlbWEpOiBMb2FkZWRNYXAgfCBudWxsIHtcbiAgcmV0dXJuIHJhd0RhdGEgPyBzY2hlbWEubG9hZChyYXdEYXRhLmRhdGFzZXRzLCByYXdEYXRhLmNvbmZpZykgOiBudWxsO1xufVxuXG4vKipcbiAqIFBhcnNlIGEgc2luZ2xlIG9yIGFuIGFycmF5IG9mIGRhdGFzZXRzIHNhdmVkIHVzaW5nIGtlcGxlci5nbCBzY2hlbWFcbiAqIEBwYXJhbSByYXdEYXRhXG4gKiBAcGFyYW0gc2NoZW1hXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwcm9jZXNzS2VwbGVyZ2xEYXRhc2V0KFxuICByYXdEYXRhOiBvYmplY3QgfCBvYmplY3RbXSxcbiAgc2NoZW1hID0gS2VwbGVyR2xTY2hlbWFcbik6IFBhcnNlZERhdGFzZXQgfCBQYXJzZWREYXRhc2V0W10gfCBudWxsIHtcbiAgaWYgKCFyYXdEYXRhKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBjb25zdCByZXN1bHRzID0gc2NoZW1hLnBhcnNlU2F2ZWREYXRhKHRvQXJyYXkocmF3RGF0YSkpO1xuICBpZiAoIXJlc3VsdHMpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gQXJyYXkuaXNBcnJheShyYXdEYXRhKSA/IHJlc3VsdHMgOiByZXN1bHRzWzBdO1xufVxuXG5leHBvcnQgY29uc3QgREFUQVNFVF9IQU5ETEVSUzoge1xuICByb3c6IHR5cGVvZiBwcm9jZXNzUm93T2JqZWN0O1xuICBnZW9qc29uOiB0eXBlb2YgcHJvY2Vzc0dlb2pzb247XG4gIGNzdjogdHlwZW9mIHByb2Nlc3NDc3ZEYXRhO1xuICBrZXBsZXJnbDogdHlwZW9mIHByb2Nlc3NLZXBsZXJnbERhdGFzZXQ7XG59ID0ge1xuICBbREFUQVNFVF9GT1JNQVRTLnJvd106IHByb2Nlc3NSb3dPYmplY3QsXG4gIFtEQVRBU0VUX0ZPUk1BVFMuZ2VvanNvbl06IHByb2Nlc3NHZW9qc29uLFxuICBbREFUQVNFVF9GT1JNQVRTLmNzdl06IHByb2Nlc3NDc3ZEYXRhLFxuICBbREFUQVNFVF9GT1JNQVRTLmtlcGxlcmdsXTogcHJvY2Vzc0tlcGxlcmdsRGF0YXNldFxufTtcblxuZXhwb3J0IGNvbnN0IFByb2Nlc3NvcnM6IHtcbiAgcHJvY2Vzc0dlb2pzb246IHR5cGVvZiBwcm9jZXNzR2VvanNvbjtcbiAgcHJvY2Vzc0NzdkRhdGE6IHR5cGVvZiBwcm9jZXNzQ3N2RGF0YTtcbiAgcHJvY2Vzc1Jvd09iamVjdDogdHlwZW9mIHByb2Nlc3NSb3dPYmplY3Q7XG4gIHByb2Nlc3NLZXBsZXJnbEpTT046IHR5cGVvZiBwcm9jZXNzS2VwbGVyZ2xKU09OO1xuICBwcm9jZXNzS2VwbGVyZ2xEYXRhc2V0OiB0eXBlb2YgcHJvY2Vzc0tlcGxlcmdsRGF0YXNldDtcbiAgYW5hbHl6ZXJUeXBlVG9GaWVsZFR5cGU6IHR5cGVvZiBhbmFseXplclR5cGVUb0ZpZWxkVHlwZTtcbiAgZ2V0RmllbGRzRnJvbURhdGE6IHR5cGVvZiBnZXRGaWVsZHNGcm9tRGF0YTtcbiAgcGFyc2VDc3ZSb3dzQnlGaWVsZFR5cGU6IHR5cGVvZiBwYXJzZUNzdlJvd3NCeUZpZWxkVHlwZTtcbn0gPSB7XG4gIHByb2Nlc3NHZW9qc29uLFxuICBwcm9jZXNzQ3N2RGF0YSxcbiAgcHJvY2Vzc1Jvd09iamVjdCxcbiAgcHJvY2Vzc0tlcGxlcmdsSlNPTixcbiAgcHJvY2Vzc0tlcGxlcmdsRGF0YXNldCxcbiAgYW5hbHl6ZXJUeXBlVG9GaWVsZFR5cGUsXG4gIGdldEZpZWxkc0Zyb21EYXRhLFxuICBwYXJzZUNzdlJvd3NCeUZpZWxkVHlwZVxufTtcbiJdfQ==