import { RGBColor, Field, FieldPair, FieldDomain, Filter, ProtoDataset, FilterRecord, FilterDatasetOpt } from '@kepler.gl/types';
import { Layer } from '@kepler.gl/layers';
import { DataContainerInterface } from '@kepler.gl/utils';
export declare type GpuFilter = {
    filterRange: number[][];
    filterValueUpdateTriggers: any;
    filterValueAccessor: (dc: DataContainerInterface) => (getIndex?: (any: any) => number, getData?: (dc_: DataContainerInterface, d: any, fieldIndex: number) => any) => (d: any) => number;
};
export declare function maybeToDate(isTime: boolean, fieldIdx: number, format: string, dc: DataContainerInterface, d: {
    index: number;
}): any;
declare class KeplerTable {
    readonly id: string;
    type?: string;
    label: string;
    color: RGBColor;
    fields: Field[];
    dataContainer: DataContainerInterface;
    allIndexes: number[];
    filteredIndex: number[];
    filteredIdxCPU?: number[];
    filteredIndexForDomain: number[];
    fieldPairs: FieldPair[];
    gpuFilter: GpuFilter;
    filterRecord?: FilterRecord;
    filterRecordCPU?: FilterRecord;
    changedFilters?: any;
    sortColumn?: {
        [key: string]: string;
    };
    sortOrder?: number[] | null;
    pinnedColumns?: string[];
    supportedFilterTypes?: string[] | null;
    disableDataOperation?: boolean;
    metadata: object;
    constructor({ info, data, color, metadata, supportedFilterTypes, disableDataOperation }: {
        info?: ProtoDataset['info'];
        data: ProtoDataset['data'];
        color: RGBColor;
        metadata?: ProtoDataset['metadata'];
        supportedFilterTypes?: ProtoDataset['supportedFilterTypes'];
        disableDataOperation?: ProtoDataset['disableDataOperation'];
    });
    get length(): number;
    /**
     * Get field
     * @param columnName
     */
    getColumnField(columnName: string): Field | undefined;
    /**
     * Get fieldIdx
     * @param columnName
     */
    getColumnFieldIdx(columnName: string): number;
    /**
     * Get the value of a cell
     */
    getValue(columnName: string, rowIdx: number): any;
    /**
     * Updates existing field with a new object
     * @param fieldIdx
     * @param newField
     */
    updateColumnField(fieldIdx: number, newField: Field): void;
    /**
     * Update dataset color by custom color
     * @param newColor
     */
    updateTableColor(newColor: RGBColor): void;
    /**
     * Save filterProps to field and retrieve it
     * @param columnName
     */
    getColumnFilterProps(columnName: string): Field['filterProps'] | null | undefined;
    /**
     * Apply filters to dataset, return the filtered dataset with updated `gpuFilter`, `filterRecord`, `filteredIndex`, `filteredIndexForDomain`
     * @param filters
     * @param layers
     * @param opt
     */
    filterTable(filters: Filter[], layers: Layer[], opt?: FilterDatasetOpt): KeplerTable;
    /**
     * Apply filters to a dataset all on CPU, assign to `filteredIdxCPU`, `filterRecordCPU`
     * @param filters
     * @param layers
     */
    filterTableCPU(filters: Filter[], layers: Layer[]): KeplerTable;
    /**
     * Calculate field domain based on field type and data
     * for Filter
     */
    getColumnFilterDomain(field: Field): FieldDomain;
    /**
     *  Get the domain of this column based on scale type
     */
    getColumnLayerDomain(field: Field, scaleType: string): number[] | string[] | [number, number] | null;
    /**
     * Get a sample of rows to calculate layer boundaries
     */
    /**
     * Parse cell value based on column type and return a string representation
     * Value the field value, type the field type
     */
    /**
     * Assert whether field exist
     * @param fieldName
     * @param condition
     */
    _assetField(fieldName: string, condition: any): void;
}
export declare type Datasets = {
    [key: string]: KeplerTable;
};
/**
 * Find point fields pairs from fields
 *
 * @param fields
 * @returns found point fields
 */
export declare function findPointFieldPairs(fields: Field[]): FieldPair[];
/**
 *
 * @param dataset
 * @param column
 * @param mode
 * @type
 */
export declare function sortDatasetByColumn(dataset: KeplerTable, column: string, mode?: string): KeplerTable;
export declare function pinTableColumns(dataset: KeplerTable, column: string): KeplerTable;
export declare function copyTable(original: KeplerTable): KeplerTable;
/**
 * @type
 * @returns
 */
export declare function copyTableAndUpdate(original: KeplerTable, options?: Partial<KeplerTable>): KeplerTable;
export declare function getFieldValueAccessor<F extends {
    type?: Field['type'];
    format?: Field['format'];
}>(f: F, i: number, dc: DataContainerInterface): (d: {
    index: number;
}) => any;
export default KeplerTable;
