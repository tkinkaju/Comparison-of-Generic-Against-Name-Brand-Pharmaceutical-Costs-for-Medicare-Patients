// Copyright (c) 2022 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.maybeToDate = maybeToDate;
exports.findPointFieldPairs = findPointFieldPairs;
exports.sortDatasetByColumn = sortDatasetByColumn;
exports.pinTableColumns = pinTableColumns;
exports.copyTable = copyTable;
exports.copyTableAndUpdate = copyTableAndUpdate;
exports.getFieldValueAccessor = getFieldValueAccessor;
exports["default"] = void 0;

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _console = require("global/console");

var _d3Array = require("d3-array");

var _constants = require("@kepler.gl/constants");

var _gpuFilterUtils = require("./gpu-filter-utils");

var _utils = require("@kepler.gl/utils");

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

// Unique identifier of each field
var FID_KEY = 'name';

function maybeToDate(isTime, fieldIdx, format, dc, d) {
  if (isTime) {
    return (0, _utils.timeToUnixMilli)(dc.valueAt(d.index, fieldIdx), format);
  }

  return dc.valueAt(d.index, fieldIdx);
}

var KeplerTable = /*#__PURE__*/function () {
  // fields and data
  // table-injected metadata
  // table-injected metadata
  function KeplerTable(_ref) {
    var info = _ref.info,
        data = _ref.data,
        color = _ref.color,
        metadata = _ref.metadata,
        _ref$supportedFilterT = _ref.supportedFilterTypes,
        supportedFilterTypes = _ref$supportedFilterT === void 0 ? null : _ref$supportedFilterT,
        _ref$disableDataOpera = _ref.disableDataOperation,
        disableDataOperation = _ref$disableDataOpera === void 0 ? false : _ref$disableDataOpera;
    (0, _classCallCheck2["default"])(this, KeplerTable);
    (0, _defineProperty2["default"])(this, "id", void 0);
    (0, _defineProperty2["default"])(this, "type", void 0);
    (0, _defineProperty2["default"])(this, "label", void 0);
    (0, _defineProperty2["default"])(this, "color", void 0);
    (0, _defineProperty2["default"])(this, "fields", void 0);
    (0, _defineProperty2["default"])(this, "dataContainer", void 0);
    (0, _defineProperty2["default"])(this, "allIndexes", void 0);
    (0, _defineProperty2["default"])(this, "filteredIndex", void 0);
    (0, _defineProperty2["default"])(this, "filteredIdxCPU", void 0);
    (0, _defineProperty2["default"])(this, "filteredIndexForDomain", void 0);
    (0, _defineProperty2["default"])(this, "fieldPairs", void 0);
    (0, _defineProperty2["default"])(this, "gpuFilter", void 0);
    (0, _defineProperty2["default"])(this, "filterRecord", void 0);
    (0, _defineProperty2["default"])(this, "filterRecordCPU", void 0);
    (0, _defineProperty2["default"])(this, "changedFilters", void 0);
    (0, _defineProperty2["default"])(this, "sortColumn", void 0);
    (0, _defineProperty2["default"])(this, "sortOrder", void 0);
    (0, _defineProperty2["default"])(this, "pinnedColumns", void 0);
    (0, _defineProperty2["default"])(this, "supportedFilterTypes", void 0);
    (0, _defineProperty2["default"])(this, "disableDataOperation", void 0);
    (0, _defineProperty2["default"])(this, "metadata", void 0);
    // TODO - what to do if validation fails? Can kepler handle exceptions?
    // const validatedData = validateInputData(data);
    // if (!validatedData) {
    //   return this;
    // }
    // @ts-expect-error
    var dataContainer = (0, _utils.createDataContainer)(data.rows, {
      fields: data.fields
    });

    var datasetInfo = _objectSpread({
      id: (0, _utils.generateHashId)(4),
      label: 'new dataset',
      type: ''
    }, info);

    var dataId = datasetInfo.id; // @ts-expect-error

    var fields = data.fields.map(function (f, i) {
      return _objectSpread(_objectSpread({}, f), {}, {
        fieldIdx: i,
        id: f.name,
        displayName: f.displayName || f.name,
        valueAccessor: getFieldValueAccessor(f, i, dataContainer)
      });
    });
    var allIndexes = dataContainer.getPlainIndex();
    var defaultMetadata = {
      id: datasetInfo.id,
      // @ts-ignore
      format: datasetInfo.format || '',
      label: datasetInfo.label || ''
    };
    this.id = datasetInfo.id;
    this.type = datasetInfo.type;
    this.label = datasetInfo.label;
    this.color = color;
    this.metadata = _objectSpread(_objectSpread({}, defaultMetadata), metadata);
    this.dataContainer = dataContainer;
    this.allIndexes = allIndexes;
    this.filteredIndex = allIndexes;
    this.filteredIndexForDomain = allIndexes;
    this.fieldPairs = findPointFieldPairs(fields);
    this.fields = fields;
    this.gpuFilter = (0, _gpuFilterUtils.getGpuFilterProps)([], dataId, fields);
    this.supportedFilterTypes = supportedFilterTypes;
    this.disableDataOperation = disableDataOperation;
  }

  (0, _createClass2["default"])(KeplerTable, [{
    key: "length",
    get: function get() {
      return this.dataContainer.numRows();
    }
    /**
     * Get field
     * @param columnName
     */

  }, {
    key: "getColumnField",
    value: function getColumnField(columnName) {
      var field = this.fields.find(function (fd) {
        return fd[FID_KEY] === columnName;
      });

      this._assetField(columnName, field);

      return field;
    }
    /**
     * Get fieldIdx
     * @param columnName
     */

  }, {
    key: "getColumnFieldIdx",
    value: function getColumnFieldIdx(columnName) {
      var fieldIdx = this.fields.findIndex(function (fd) {
        return fd[FID_KEY] === columnName;
      });

      this._assetField(columnName, Boolean(fieldIdx > -1));

      return fieldIdx;
    }
    /**
     * Get the value of a cell
     */

  }, {
    key: "getValue",
    value: function getValue(columnName, rowIdx) {
      var field = this.getColumnField(columnName);
      return field ? field.valueAccessor({
        index: rowIdx
      }) : null;
    }
    /**
     * Updates existing field with a new object
     * @param fieldIdx
     * @param newField
     */

  }, {
    key: "updateColumnField",
    value: function updateColumnField(fieldIdx, newField) {
      this.fields = Object.assign((0, _toConsumableArray2["default"])(this.fields), (0, _defineProperty2["default"])({}, fieldIdx, newField));
    }
    /**
     * Update dataset color by custom color
     * @param newColor
     */

  }, {
    key: "updateTableColor",
    value: function updateTableColor(newColor) {
      this.color = newColor;
    }
    /**
     * Save filterProps to field and retrieve it
     * @param columnName
     */

  }, {
    key: "getColumnFilterProps",
    value: function getColumnFilterProps(columnName) {
      var fieldIdx = this.getColumnFieldIdx(columnName);

      if (fieldIdx < 0) {
        return null;
      }

      var field = this.fields[fieldIdx];

      if (field.hasOwnProperty('filterProps')) {
        return field.filterProps;
      }

      var fieldDomain = this.getColumnFilterDomain(field);

      if (!fieldDomain) {
        return null;
      }

      var filterProps = (0, _utils.getFilterProps)(field, fieldDomain);

      var newField = _objectSpread(_objectSpread({}, field), {}, {
        filterProps: filterProps
      });

      this.updateColumnField(fieldIdx, newField);
      return filterProps;
    }
    /**
     * Apply filters to dataset, return the filtered dataset with updated `gpuFilter`, `filterRecord`, `filteredIndex`, `filteredIndexForDomain`
     * @param filters
     * @param layers
     * @param opt
     */

  }, {
    key: "filterTable",
    value: function filterTable(filters, layers, opt) {
      var _this = this;

      var dataContainer = this.dataContainer,
          dataId = this.id,
          oldFilterRecord = this.filterRecord,
          fields = this.fields; // if there is no filters

      var filterRecord = (0, _utils.getFilterRecord)(dataId, filters, opt || {});
      this.filterRecord = filterRecord;
      this.gpuFilter = (0, _gpuFilterUtils.getGpuFilterProps)(filters, dataId, fields); // const newDataset = set(['filterRecord'], filterRecord, dataset);

      if (!filters.length) {
        this.filteredIndex = this.allIndexes;
        this.filteredIndexForDomain = this.allIndexes;
        return this;
      }

      this.changedFilters = (0, _utils.diffFilters)(filterRecord, oldFilterRecord); // generate 2 sets of filter result
      // filteredIndex used to calculate layer data
      // filteredIndexForDomain used to calculate layer Domain

      var shouldCalDomain = Boolean(this.changedFilters.dynamicDomain);
      var shouldCalIndex = Boolean(this.changedFilters.cpu);
      var filterResult = {};

      if (shouldCalDomain || shouldCalIndex) {
        var dynamicDomainFilters = shouldCalDomain ? filterRecord.dynamicDomain : null;
        var cpuFilters = shouldCalIndex ? filterRecord.cpu : null;
        var filterFuncs = filters.reduce(function (acc, filter) {
          var fieldIndex = (0, _gpuFilterUtils.getDatasetFieldIndexForFilter)(_this.id, filter);
          var field = fieldIndex !== -1 ? fields[fieldIndex] : null;
          return _objectSpread(_objectSpread({}, acc), {}, (0, _defineProperty2["default"])({}, filter.id, (0, _utils.getFilterFunction)(field, _this.id, filter, layers, dataContainer)));
        }, {});
        filterResult = (0, _utils.filterDataByFilterTypes)({
          dynamicDomainFilters: dynamicDomainFilters,
          cpuFilters: cpuFilters,
          filterFuncs: filterFuncs
        }, dataContainer);
      }

      this.filteredIndex = filterResult.filteredIndex || this.filteredIndex;
      this.filteredIndexForDomain = filterResult.filteredIndexForDomain || this.filteredIndexForDomain;
      return this;
    }
    /**
     * Apply filters to a dataset all on CPU, assign to `filteredIdxCPU`, `filterRecordCPU`
     * @param filters
     * @param layers
     */

  }, {
    key: "filterTableCPU",
    value: function filterTableCPU(filters, layers) {
      var opt = {
        cpuOnly: true,
        ignoreDomain: true
      }; // no filter

      if (!filters.length) {
        this.filteredIdxCPU = this.allIndexes;
        this.filterRecordCPU = (0, _utils.getFilterRecord)(this.id, filters, opt);
        return this;
      } // no gpu filter


      if (!filters.find(function (f) {
        return f.gpu;
      })) {
        this.filteredIdxCPU = this.filteredIndex;
        this.filterRecordCPU = (0, _utils.getFilterRecord)(this.id, filters, opt);
        return this;
      } // make a copy for cpu filtering


      var copied = copyTable(this);
      copied.filterRecord = this.filterRecordCPU;
      copied.filteredIndex = this.filteredIdxCPU || [];
      var filtered = copied.filterTable(filters, layers, opt);
      this.filteredIdxCPU = filtered.filteredIndex;
      this.filterRecordCPU = filtered.filterRecord;
      return this;
    }
    /**
     * Calculate field domain based on field type and data
     * for Filter
     */

  }, {
    key: "getColumnFilterDomain",
    value: function getColumnFilterDomain(field) {
      var dataContainer = this.dataContainer;
      var valueAccessor = field.valueAccessor;
      var domain;

      switch (field.type) {
        case _constants.ALL_FIELD_TYPES.real:
        case _constants.ALL_FIELD_TYPES.integer:
          // calculate domain and step
          return (0, _utils.getNumericFieldDomain)(dataContainer, valueAccessor);

        case _constants.ALL_FIELD_TYPES["boolean"]:
          return {
            domain: [true, false]
          };

        case _constants.ALL_FIELD_TYPES.string:
        case _constants.ALL_FIELD_TYPES.date:
          domain = (0, _utils.getOrdinalDomain)(dataContainer, valueAccessor);
          return {
            domain: domain
          };

        case _constants.ALL_FIELD_TYPES.timestamp:
          return (0, _utils.getTimestampFieldDomain)(dataContainer, valueAccessor);

        default:
          return {
            domain: (0, _utils.getOrdinalDomain)(dataContainer, valueAccessor)
          };
      }
    }
    /**
     *  Get the domain of this column based on scale type
     */

  }, {
    key: "getColumnLayerDomain",
    value: function getColumnLayerDomain(field, scaleType) {
      var dataContainer = this.dataContainer,
          filteredIndexForDomain = this.filteredIndexForDomain;

      if (!_constants.SCALE_TYPES[scaleType]) {
        _console.console.error("scale type ".concat(scaleType, " not supported"));

        return null;
      }

      var valueAccessor = field.valueAccessor;

      var indexValueAccessor = function indexValueAccessor(i) {
        return valueAccessor({
          index: i
        });
      };

      var sortFunction = (0, _utils.getSortingFunction)(field.type);

      switch (scaleType) {
        case _constants.SCALE_TYPES.ordinal:
        case _constants.SCALE_TYPES.point:
          // do not recalculate ordinal domain based on filtered data
          // don't need to update ordinal domain every time
          return (0, _utils.getOrdinalDomain)(dataContainer, valueAccessor);

        case _constants.SCALE_TYPES.quantile:
          return (0, _utils.getQuantileDomain)(filteredIndexForDomain, indexValueAccessor, sortFunction);

        case _constants.SCALE_TYPES.log:
          return (0, _utils.getLogDomain)(filteredIndexForDomain, indexValueAccessor);

        case _constants.SCALE_TYPES.quantize:
        case _constants.SCALE_TYPES.linear:
        case _constants.SCALE_TYPES.sqrt:
        default:
          return (0, _utils.getLinearDomain)(filteredIndexForDomain, indexValueAccessor);
      }
    }
    /**
     * Get a sample of rows to calculate layer boundaries
     */
    // getSampleData(rows)

    /**
     * Parse cell value based on column type and return a string representation
     * Value the field value, type the field type
     */
    // parseFieldValue(value, type)
    // sortDatasetByColumn()

    /**
     * Assert whether field exist
     * @param fieldName
     * @param condition
     */

  }, {
    key: "_assetField",
    value: function _assetField(fieldName, condition) {
      if (!condition) {
        _console.console.error("".concat(fieldName, " doesnt exist in dataset ").concat(this.id));
      }
    }
  }]);
  return KeplerTable;
}();

// HELPER FUNCTIONS (MAINLY EXPORTED FOR TEST...)
// have to double excape
var specialCharacterSet = "[#_&@\\.\\-\\ ]";

function foundMatchingFields(re, suffixPair, allNames, fieldName) {
  var partnerIdx = allNames.findIndex(function (d) {
    return d === fieldName.replace(re, function (match) {
      return match.replace(suffixPair[0], suffixPair[1]);
    });
  });
  var altIdx = -1;

  if (partnerIdx > -1) {
    // if found partner, go on and look for altitude
    _constants.ALTITUDE_FIELDS.some(function (alt) {
      altIdx = allNames.findIndex(function (d) {
        return d === fieldName.replace(re, function (match) {
          return match.replace(suffixPair[0], alt);
        });
      });
      return altIdx > -1;
    });
  }

  return {
    partnerIdx: partnerIdx,
    altIdx: altIdx
  };
}
/**
 * Find point fields pairs from fields
 *
 * @param fields
 * @returns found point fields
 */


function findPointFieldPairs(fields) {
  var allNames = fields.map(function (f) {
    return f.name.toLowerCase();
  }); // get list of all fields with matching suffixes

  var acc = [];
  return allNames.reduce(function (carry, fieldName, idx) {
    // This search for pairs will early exit if found.
    var _iterator = _createForOfIteratorHelper(_constants.TRIP_POINT_FIELDS),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var suffixPair = _step.value;
        // match first suffix
        // (^|[#_&@\.\-\ ])lat([#_&@\.\-\ ]|$)
        var re = new RegExp("(^|".concat(specialCharacterSet, ")").concat(suffixPair[0], "(").concat(specialCharacterSet, "|$)"));

        if (re.test(fieldName)) {
          var _foundMatchingFields = foundMatchingFields(re, suffixPair, allNames, fieldName),
              partnerIdx = _foundMatchingFields.partnerIdx,
              altIdx = _foundMatchingFields.altIdx;

          if (partnerIdx > -1) {
            var trimName = fieldName.replace(re, '').trim();
            carry.push({
              defaultName: trimName || 'point',
              pair: _objectSpread({
                lat: {
                  fieldIdx: idx,
                  value: fields[idx].name
                },
                lng: {
                  fieldIdx: partnerIdx,
                  value: fields[partnerIdx].name
                }
              }, altIdx > -1 ? {
                alt: {
                  fieldIdx: altIdx,
                  value: fields[altIdx].name
                }
              } : {}),
              suffix: suffixPair
            });
            return carry;
          }
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    return carry;
  }, acc);
}
/**
 *
 * @param dataset
 * @param column
 * @param mode
 * @type
 */


function sortDatasetByColumn(dataset, column, mode) {
  var allIndexes = dataset.allIndexes,
      fields = dataset.fields,
      dataContainer = dataset.dataContainer;
  var fieldIndex = fields.findIndex(function (f) {
    return f.name === column;
  });

  if (fieldIndex < 0) {
    return dataset;
  }

  var sortBy = _constants.SORT_ORDER[mode || ''] || _constants.SORT_ORDER.ASCENDING;

  if (sortBy === _constants.SORT_ORDER.UNSORT) {
    dataset.sortColumn = {};
    dataset.sortOrder = null;
    return dataset;
  }

  var sortFunction = sortBy === _constants.SORT_ORDER.ASCENDING ? _d3Array.ascending : _d3Array.descending;
  var sortOrder = allIndexes.slice().sort(function (a, b) {
    return sortFunction(dataContainer.valueAt(a, fieldIndex), dataContainer.valueAt(b, fieldIndex));
  });
  dataset.sortColumn = (0, _defineProperty2["default"])({}, column, sortBy);
  dataset.sortOrder = sortOrder;
  return dataset;
}

function pinTableColumns(dataset, column) {
  var field = dataset.getColumnField(column);

  if (!field) {
    return dataset;
  }

  var pinnedColumns;

  if (Array.isArray(dataset.pinnedColumns) && dataset.pinnedColumns.includes(field.name)) {
    // unpin it
    pinnedColumns = dataset.pinnedColumns.filter(function (co) {
      return co !== field.name;
    });
  } else {
    pinnedColumns = (dataset.pinnedColumns || []).concat(field.name);
  } // @ts-ignore


  return copyTableAndUpdate(dataset, {
    pinnedColumns: pinnedColumns
  });
}

function copyTable(original) {
  return Object.assign(Object.create(Object.getPrototypeOf(original)), original);
}
/**
 * @type
 * @returns
 */


function copyTableAndUpdate(original) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return Object.entries(options).reduce(function (acc, entry) {
    acc[entry[0]] = entry[1];
    return acc;
  }, copyTable(original));
}

function getFieldValueAccessor(f, i, dc) {
  return maybeToDate.bind(null, // is time
  f.type === _constants.ALL_FIELD_TYPES.timestamp, i, f.format || '', dc);
}

var _default = KeplerTable;
exports["default"] = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9rZXBsZXItdGFibGUudHMiXSwibmFtZXMiOlsiRklEX0tFWSIsIm1heWJlVG9EYXRlIiwiaXNUaW1lIiwiZmllbGRJZHgiLCJmb3JtYXQiLCJkYyIsImQiLCJ2YWx1ZUF0IiwiaW5kZXgiLCJLZXBsZXJUYWJsZSIsImluZm8iLCJkYXRhIiwiY29sb3IiLCJtZXRhZGF0YSIsInN1cHBvcnRlZEZpbHRlclR5cGVzIiwiZGlzYWJsZURhdGFPcGVyYXRpb24iLCJkYXRhQ29udGFpbmVyIiwicm93cyIsImZpZWxkcyIsImRhdGFzZXRJbmZvIiwiaWQiLCJsYWJlbCIsInR5cGUiLCJkYXRhSWQiLCJtYXAiLCJmIiwiaSIsIm5hbWUiLCJkaXNwbGF5TmFtZSIsInZhbHVlQWNjZXNzb3IiLCJnZXRGaWVsZFZhbHVlQWNjZXNzb3IiLCJhbGxJbmRleGVzIiwiZ2V0UGxhaW5JbmRleCIsImRlZmF1bHRNZXRhZGF0YSIsImZpbHRlcmVkSW5kZXgiLCJmaWx0ZXJlZEluZGV4Rm9yRG9tYWluIiwiZmllbGRQYWlycyIsImZpbmRQb2ludEZpZWxkUGFpcnMiLCJncHVGaWx0ZXIiLCJudW1Sb3dzIiwiY29sdW1uTmFtZSIsImZpZWxkIiwiZmluZCIsImZkIiwiX2Fzc2V0RmllbGQiLCJmaW5kSW5kZXgiLCJCb29sZWFuIiwicm93SWR4IiwiZ2V0Q29sdW1uRmllbGQiLCJuZXdGaWVsZCIsIk9iamVjdCIsImFzc2lnbiIsIm5ld0NvbG9yIiwiZ2V0Q29sdW1uRmllbGRJZHgiLCJoYXNPd25Qcm9wZXJ0eSIsImZpbHRlclByb3BzIiwiZmllbGREb21haW4iLCJnZXRDb2x1bW5GaWx0ZXJEb21haW4iLCJ1cGRhdGVDb2x1bW5GaWVsZCIsImZpbHRlcnMiLCJsYXllcnMiLCJvcHQiLCJvbGRGaWx0ZXJSZWNvcmQiLCJmaWx0ZXJSZWNvcmQiLCJsZW5ndGgiLCJjaGFuZ2VkRmlsdGVycyIsInNob3VsZENhbERvbWFpbiIsImR5bmFtaWNEb21haW4iLCJzaG91bGRDYWxJbmRleCIsImNwdSIsImZpbHRlclJlc3VsdCIsImR5bmFtaWNEb21haW5GaWx0ZXJzIiwiY3B1RmlsdGVycyIsImZpbHRlckZ1bmNzIiwicmVkdWNlIiwiYWNjIiwiZmlsdGVyIiwiZmllbGRJbmRleCIsImNwdU9ubHkiLCJpZ25vcmVEb21haW4iLCJmaWx0ZXJlZElkeENQVSIsImZpbHRlclJlY29yZENQVSIsImdwdSIsImNvcGllZCIsImNvcHlUYWJsZSIsImZpbHRlcmVkIiwiZmlsdGVyVGFibGUiLCJkb21haW4iLCJBTExfRklFTERfVFlQRVMiLCJyZWFsIiwiaW50ZWdlciIsInN0cmluZyIsImRhdGUiLCJ0aW1lc3RhbXAiLCJzY2FsZVR5cGUiLCJTQ0FMRV9UWVBFUyIsIkNvbnNvbGUiLCJlcnJvciIsImluZGV4VmFsdWVBY2Nlc3NvciIsInNvcnRGdW5jdGlvbiIsIm9yZGluYWwiLCJwb2ludCIsInF1YW50aWxlIiwibG9nIiwicXVhbnRpemUiLCJsaW5lYXIiLCJzcXJ0IiwiZmllbGROYW1lIiwiY29uZGl0aW9uIiwic3BlY2lhbENoYXJhY3RlclNldCIsImZvdW5kTWF0Y2hpbmdGaWVsZHMiLCJyZSIsInN1ZmZpeFBhaXIiLCJhbGxOYW1lcyIsInBhcnRuZXJJZHgiLCJyZXBsYWNlIiwibWF0Y2giLCJhbHRJZHgiLCJBTFRJVFVERV9GSUVMRFMiLCJzb21lIiwiYWx0IiwidG9Mb3dlckNhc2UiLCJjYXJyeSIsImlkeCIsIlRSSVBfUE9JTlRfRklFTERTIiwiUmVnRXhwIiwidGVzdCIsInRyaW1OYW1lIiwidHJpbSIsInB1c2giLCJkZWZhdWx0TmFtZSIsInBhaXIiLCJsYXQiLCJ2YWx1ZSIsImxuZyIsInN1ZmZpeCIsInNvcnREYXRhc2V0QnlDb2x1bW4iLCJkYXRhc2V0IiwiY29sdW1uIiwibW9kZSIsInNvcnRCeSIsIlNPUlRfT1JERVIiLCJBU0NFTkRJTkciLCJVTlNPUlQiLCJzb3J0Q29sdW1uIiwic29ydE9yZGVyIiwiYXNjZW5kaW5nIiwiZGVzY2VuZGluZyIsInNsaWNlIiwic29ydCIsImEiLCJiIiwicGluVGFibGVDb2x1bW5zIiwicGlubmVkQ29sdW1ucyIsIkFycmF5IiwiaXNBcnJheSIsImluY2x1ZGVzIiwiY28iLCJjb25jYXQiLCJjb3B5VGFibGVBbmRVcGRhdGUiLCJvcmlnaW5hbCIsImNyZWF0ZSIsImdldFByb3RvdHlwZU9mIiwib3B0aW9ucyIsImVudHJpZXMiLCJlbnRyeSIsImJpbmQiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW9CQTs7QUFDQTs7QUFFQTs7QUFrQkE7O0FBR0E7Ozs7Ozs7Ozs7OztBQStCQTtBQUNBLElBQU1BLE9BQU8sR0FBRyxNQUFoQjs7QUFFTyxTQUFTQyxXQUFULENBQ0xDLE1BREssRUFFTEMsUUFGSyxFQUdMQyxNQUhLLEVBSUxDLEVBSkssRUFLTEMsQ0FMSyxFQU1MO0FBQ0EsTUFBSUosTUFBSixFQUFZO0FBQ1YsV0FBTyw0QkFBZ0JHLEVBQUUsQ0FBQ0UsT0FBSCxDQUFXRCxDQUFDLENBQUNFLEtBQWIsRUFBb0JMLFFBQXBCLENBQWhCLEVBQStDQyxNQUEvQyxDQUFQO0FBQ0Q7O0FBRUQsU0FBT0MsRUFBRSxDQUFDRSxPQUFILENBQVdELENBQUMsQ0FBQ0UsS0FBYixFQUFvQkwsUUFBcEIsQ0FBUDtBQUNEOztJQUVLTSxXO0FBT0o7QUFlQTtBQVdBO0FBR0EsNkJBY0c7QUFBQSxRQWJEQyxJQWFDLFFBYkRBLElBYUM7QUFBQSxRQVpEQyxJQVlDLFFBWkRBLElBWUM7QUFBQSxRQVhEQyxLQVdDLFFBWERBLEtBV0M7QUFBQSxRQVZEQyxRQVVDLFFBVkRBLFFBVUM7QUFBQSxxQ0FUREMsb0JBU0M7QUFBQSxRQVREQSxvQkFTQyxzQ0FUc0IsSUFTdEI7QUFBQSxxQ0FSREMsb0JBUUM7QUFBQSxRQVJEQSxvQkFRQyxzQ0FSc0IsS0FRdEI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFB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LENBQXJCO0FBQ0EsV0FBTzFGLEdBQVA7QUFDRCxHQUhNLEVBR0pTLFNBQVMsQ0FBQzRFLFFBQUQsQ0FITCxDQUFQO0FBSUQ7O0FBRU0sU0FBU2xJLHFCQUFULENBS0xMLENBTEssRUFLQ0MsQ0FMRCxFQUtZckIsRUFMWixFQUt3QztBQUM3QyxTQUFPSixXQUFXLENBQUNxSyxJQUFaLENBQ0wsSUFESyxFQUVMO0FBQ0E3SSxFQUFBQSxDQUFDLENBQUNILElBQUYsS0FBV2tFLDJCQUFnQkssU0FIdEIsRUFJTG5FLENBSkssRUFLTEQsQ0FBQyxDQUFDckIsTUFBRixJQUFZLEVBTFAsRUFNTEMsRUFOSyxDQUFQO0FBUUQ7O2VBRWNJLFciLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMjIgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5pbXBvcnQge2NvbnNvbGUgYXMgQ29uc29sZX0gZnJvbSAnZ2xvYmFsL2NvbnNvbGUnO1xuaW1wb3J0IHthc2NlbmRpbmcsIGRlc2NlbmRpbmd9IGZyb20gJ2QzLWFycmF5JztcblxuaW1wb3J0IHtcbiAgVFJJUF9QT0lOVF9GSUVMRFMsXG4gIFNPUlRfT1JERVIsXG4gIEFMTF9GSUVMRF9UWVBFUyxcbiAgQUxUSVRVREVfRklFTERTLFxuICBTQ0FMRV9UWVBFU1xufSBmcm9tICdAa2VwbGVyLmdsL2NvbnN0YW50cyc7XG5pbXBvcnQge1xuICBSR0JDb2xvcixcbiAgRmllbGQsXG4gIEZpZWxkUGFpcixcbiAgRmllbGREb21haW4sXG4gIEZpbHRlcixcbiAgUHJvdG9EYXRhc2V0LFxuICBGaWx0ZXJSZWNvcmQsXG4gIEZpbHRlckRhdGFzZXRPcHRcbn0gZnJvbSAnQGtlcGxlci5nbC90eXBlcyc7XG5cbmltcG9ydCB7Z2V0R3B1RmlsdGVyUHJvcHMsIGdldERhdGFzZXRGaWVsZEluZGV4Rm9yRmlsdGVyfSBmcm9tICcuL2dwdS1maWx0ZXItdXRpbHMnO1xuXG5pbXBvcnQge0xheWVyfSBmcm9tICdAa2VwbGVyLmdsL2xheWVycyc7XG5pbXBvcnQge1xuICBnZW5lcmF0ZUhhc2hJZCxcbiAgZ2V0U29ydGluZ0Z1bmN0aW9uLFxuICB0aW1lVG9Vbml4TWlsbGksXG4gIGNyZWF0ZURhdGFDb250YWluZXIsXG4gIGRpZmZGaWx0ZXJzLFxuICBmaWx0ZXJEYXRhQnlGaWx0ZXJUeXBlcyxcbiAgRmlsdGVyUmVzdWx0LFxuICBnZXRGaWx0ZXJGdW5jdGlvbixcbiAgZ2V0RmlsdGVyUHJvcHMsXG4gIGdldEZpbHRlclJlY29yZCxcbiAgZ2V0TnVtZXJpY0ZpZWxkRG9tYWluLFxuICBnZXRUaW1lc3RhbXBGaWVsZERvbWFpbixcbiAgZ2V0TGluZWFyRG9tYWluLFxuICBnZXRMb2dEb21haW4sXG4gIGdldE9yZGluYWxEb21haW4sXG4gIGdldFF1YW50aWxlRG9tYWluLFxuICBEYXRhQ29udGFpbmVySW50ZXJmYWNlXG59IGZyb20gJ0BrZXBsZXIuZ2wvdXRpbHMnO1xuXG5leHBvcnQgdHlwZSBHcHVGaWx0ZXIgPSB7XG4gIGZpbHRlclJhbmdlOiBudW1iZXJbXVtdO1xuICBmaWx0ZXJWYWx1ZVVwZGF0ZVRyaWdnZXJzOiBhbnk7XG4gIGZpbHRlclZhbHVlQWNjZXNzb3I6IChcbiAgICBkYzogRGF0YUNvbnRhaW5lckludGVyZmFjZVxuICApID0+IChcbiAgICBnZXRJbmRleD86IChhbnkpID0+IG51bWJlcixcbiAgICBnZXREYXRhPzogKGRjXzogRGF0YUNvbnRhaW5lckludGVyZmFjZSwgZDogYW55LCBmaWVsZEluZGV4OiBudW1iZXIpID0+IGFueVxuICApID0+IChkOiBhbnkpID0+IG51bWJlcjtcbn07XG5cbi8vIFVuaXF1ZSBpZGVudGlmaWVyIG9mIGVhY2ggZmllbGRcbmNvbnN0IEZJRF9LRVkgPSAnbmFtZSc7XG5cbmV4cG9ydCBmdW5jdGlvbiBtYXliZVRvRGF0ZShcbiAgaXNUaW1lOiBib29sZWFuLFxuICBmaWVsZElkeDogbnVtYmVyLFxuICBmb3JtYXQ6IHN0cmluZyxcbiAgZGM6IERhdGFDb250YWluZXJJbnRlcmZhY2UsXG4gIGQ6IHtpbmRleDogbnVtYmVyfVxuKSB7XG4gIGlmIChpc1RpbWUpIHtcbiAgICByZXR1cm4gdGltZVRvVW5peE1pbGxpKGRjLnZhbHVlQXQoZC5pbmRleCwgZmllbGRJZHgpLCBmb3JtYXQpO1xuICB9XG5cbiAgcmV0dXJuIGRjLnZhbHVlQXQoZC5pbmRleCwgZmllbGRJZHgpO1xufVxuXG5jbGFzcyBLZXBsZXJUYWJsZSB7XG4gIHJlYWRvbmx5IGlkOiBzdHJpbmc7XG5cbiAgdHlwZT86IHN0cmluZztcbiAgbGFiZWw6IHN0cmluZztcbiAgY29sb3I6IFJHQkNvbG9yO1xuXG4gIC8vIGZpZWxkcyBhbmQgZGF0YVxuICBmaWVsZHM6IEZpZWxkW107XG5cbiAgZGF0YUNvbnRhaW5lcjogRGF0YUNvbnRhaW5lckludGVyZmFjZTtcblxuICBhbGxJbmRleGVzOiBudW1iZXJbXTtcbiAgZmlsdGVyZWRJbmRleDogbnVtYmVyW107XG4gIGZpbHRlcmVkSWR4Q1BVPzogbnVtYmVyW107XG4gIGZpbHRlcmVkSW5kZXhGb3JEb21haW46IG51bWJlcltdO1xuICBmaWVsZFBhaXJzOiBGaWVsZFBhaXJbXTtcbiAgZ3B1RmlsdGVyOiBHcHVGaWx0ZXI7XG4gIGZpbHRlclJlY29yZD86IEZpbHRlclJlY29yZDtcbiAgZmlsdGVyUmVjb3JkQ1BVPzogRmlsdGVyUmVjb3JkO1xuICBjaGFuZ2VkRmlsdGVycz86IGFueTtcblxuICAvLyB0YWJsZS1pbmplY3RlZCBtZXRhZGF0YVxuICBzb3J0Q29sdW1uPzoge1xuICAgIC8vIGNvbHVtbiBuYW1lOiBzb3J0ZWQgaWR4XG4gICAgW2tleTogc3RyaW5nXTogc3RyaW5nOyAvLyBBU0NFTkRJTkcgfCBERVNDRU5ESU5HIHwgVU5TT1JUXG4gIH07XG4gIHNvcnRPcmRlcj86IG51bWJlcltdIHwgbnVsbDtcblxuICBwaW5uZWRDb2x1bW5zPzogc3RyaW5nW107XG4gIHN1cHBvcnRlZEZpbHRlclR5cGVzPzogc3RyaW5nW10gfCBudWxsO1xuICBkaXNhYmxlRGF0YU9wZXJhdGlvbj86IGJvb2xlYW47XG5cbiAgLy8gdGFibGUtaW5qZWN0ZWQgbWV0YWRhdGFcbiAgbWV0YWRhdGE6IG9iamVjdDtcblxuICBjb25zdHJ1Y3Rvcih7XG4gICAgaW5mbyxcbiAgICBkYXRhLFxuICAgIGNvbG9yLFxuICAgIG1ldGFkYXRhLFxuICAgIHN1cHBvcnRlZEZpbHRlclR5cGVzID0gbnVsbCxcbiAgICBkaXNhYmxlRGF0YU9wZXJhdGlvbiA9IGZhbHNlXG4gIH06IHtcbiAgICBpbmZvPzogUHJvdG9EYXRhc2V0WydpbmZvJ107XG4gICAgZGF0YTogUHJvdG9EYXRhc2V0WydkYXRhJ107XG4gICAgY29sb3I6IFJHQkNvbG9yO1xuICAgIG1ldGFkYXRhPzogUHJvdG9EYXRhc2V0WydtZXRhZGF0YSddO1xuICAgIHN1cHBvcnRlZEZpbHRlclR5cGVzPzogUHJvdG9EYXRhc2V0WydzdXBwb3J0ZWRGaWx0ZXJUeXBlcyddO1xuICAgIGRpc2FibGVEYXRhT3BlcmF0aW9uPzogUHJvdG9EYXRhc2V0WydkaXNhYmxlRGF0YU9wZXJhdGlvbiddO1xuICB9KSB7XG4gICAgLy8gVE9ETyAtIHdoYXQgdG8gZG8gaWYgdmFsaWRhdGlvbiBmYWlscz8gQ2FuIGtlcGxlciBoYW5kbGUgZXhjZXB0aW9ucz9cbiAgICAvLyBjb25zdCB2YWxpZGF0ZWREYXRhID0gdmFsaWRhdGVJbnB1dERhdGEoZGF0YSk7XG4gICAgLy8gaWYgKCF2YWxpZGF0ZWREYXRhKSB7XG4gICAgLy8gICByZXR1cm4gdGhpcztcbiAgICAvLyB9XG5cbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgY29uc3QgZGF0YUNvbnRhaW5lciA9IGNyZWF0ZURhdGFDb250YWluZXIoZGF0YS5yb3dzLCB7ZmllbGRzOiBkYXRhLmZpZWxkc30pO1xuXG4gICAgY29uc3QgZGF0YXNldEluZm8gPSB7XG4gICAgICBpZDogZ2VuZXJhdGVIYXNoSWQoNCksXG4gICAgICBsYWJlbDogJ25ldyBkYXRhc2V0JyxcbiAgICAgIHR5cGU6ICcnLFxuICAgICAgLi4uaW5mb1xuICAgIH07XG4gICAgY29uc3QgZGF0YUlkID0gZGF0YXNldEluZm8uaWQ7XG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgIGNvbnN0IGZpZWxkczogRmllbGRbXSA9IGRhdGEuZmllbGRzLm1hcCgoZiwgaSkgPT4gKHtcbiAgICAgIC4uLmYsXG4gICAgICBmaWVsZElkeDogaSxcbiAgICAgIGlkOiBmLm5hbWUsXG4gICAgICBkaXNwbGF5TmFtZTogZi5kaXNwbGF5TmFtZSB8fCBmLm5hbWUsXG4gICAgICB2YWx1ZUFjY2Vzc29yOiBnZXRGaWVsZFZhbHVlQWNjZXNzb3IoZiwgaSwgZGF0YUNvbnRhaW5lcilcbiAgICB9KSk7XG5cbiAgICBjb25zdCBhbGxJbmRleGVzID0gZGF0YUNvbnRhaW5lci5nZXRQbGFpbkluZGV4KCk7XG4gICAgY29uc3QgZGVmYXVsdE1ldGFkYXRhID0ge1xuICAgICAgaWQ6IGRhdGFzZXRJbmZvLmlkLFxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgZm9ybWF0OiBkYXRhc2V0SW5mby5mb3JtYXQgfHwgJycsXG4gICAgICBsYWJlbDogZGF0YXNldEluZm8ubGFiZWwgfHwgJydcbiAgICB9O1xuXG4gICAgdGhpcy5pZCA9IGRhdGFzZXRJbmZvLmlkO1xuICAgIHRoaXMudHlwZSA9IGRhdGFzZXRJbmZvLnR5cGU7XG4gICAgdGhpcy5sYWJlbCA9IGRhdGFzZXRJbmZvLmxhYmVsO1xuICAgIHRoaXMuY29sb3IgPSBjb2xvcjtcbiAgICB0aGlzLm1ldGFkYXRhID0ge1xuICAgICAgLi4uZGVmYXVsdE1ldGFkYXRhLFxuICAgICAgLi4ubWV0YWRhdGFcbiAgICB9O1xuXG4gICAgdGhpcy5kYXRhQ29udGFpbmVyID0gZGF0YUNvbnRhaW5lcjtcbiAgICB0aGlzLmFsbEluZGV4ZXMgPSBhbGxJbmRleGVzO1xuICAgIHRoaXMuZmlsdGVyZWRJbmRleCA9IGFsbEluZGV4ZXM7XG4gICAgdGhpcy5maWx0ZXJlZEluZGV4Rm9yRG9tYWluID0gYWxsSW5kZXhlcztcbiAgICB0aGlzLmZpZWxkUGFpcnMgPSBmaW5kUG9pbnRGaWVsZFBhaXJzKGZpZWxkcyk7XG4gICAgdGhpcy5maWVsZHMgPSBmaWVsZHM7XG4gICAgdGhpcy5ncHVGaWx0ZXIgPSBnZXRHcHVGaWx0ZXJQcm9wcyhbXSwgZGF0YUlkLCBmaWVsZHMpO1xuICAgIHRoaXMuc3VwcG9ydGVkRmlsdGVyVHlwZXMgPSBzdXBwb3J0ZWRGaWx0ZXJUeXBlcztcbiAgICB0aGlzLmRpc2FibGVEYXRhT3BlcmF0aW9uID0gZGlzYWJsZURhdGFPcGVyYXRpb247XG4gIH1cblxuICBnZXQgbGVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLmRhdGFDb250YWluZXIubnVtUm93cygpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBmaWVsZFxuICAgKiBAcGFyYW0gY29sdW1uTmFtZVxuICAgKi9cbiAgZ2V0Q29sdW1uRmllbGQoY29sdW1uTmFtZTogc3RyaW5nKTogRmllbGQgfCB1bmRlZmluZWQge1xuICAgIGNvbnN0IGZpZWxkID0gdGhpcy5maWVsZHMuZmluZChmZCA9PiBmZFtGSURfS0VZXSA9PT0gY29sdW1uTmFtZSk7XG4gICAgdGhpcy5fYXNzZXRGaWVsZChjb2x1bW5OYW1lLCBmaWVsZCk7XG4gICAgcmV0dXJuIGZpZWxkO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBmaWVsZElkeFxuICAgKiBAcGFyYW0gY29sdW1uTmFtZVxuICAgKi9cbiAgZ2V0Q29sdW1uRmllbGRJZHgoY29sdW1uTmFtZTogc3RyaW5nKTogbnVtYmVyIHtcbiAgICBjb25zdCBmaWVsZElkeCA9IHRoaXMuZmllbGRzLmZpbmRJbmRleChmZCA9PiBmZFtGSURfS0VZXSA9PT0gY29sdW1uTmFtZSk7XG4gICAgdGhpcy5fYXNzZXRGaWVsZChjb2x1bW5OYW1lLCBCb29sZWFuKGZpZWxkSWR4ID4gLTEpKTtcbiAgICByZXR1cm4gZmllbGRJZHg7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB2YWx1ZSBvZiBhIGNlbGxcbiAgICovXG4gIGdldFZhbHVlKGNvbHVtbk5hbWU6IHN0cmluZywgcm93SWR4OiBudW1iZXIpOiBhbnkge1xuICAgIGNvbnN0IGZpZWxkID0gdGhpcy5nZXRDb2x1bW5GaWVsZChjb2x1bW5OYW1lKTtcbiAgICByZXR1cm4gZmllbGQgPyBmaWVsZC52YWx1ZUFjY2Vzc29yKHtpbmRleDogcm93SWR4fSkgOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgZXhpc3RpbmcgZmllbGQgd2l0aCBhIG5ldyBvYmplY3RcbiAgICogQHBhcmFtIGZpZWxkSWR4XG4gICAqIEBwYXJhbSBuZXdGaWVsZFxuICAgKi9cbiAgdXBkYXRlQ29sdW1uRmllbGQoZmllbGRJZHg6IG51bWJlciwgbmV3RmllbGQ6IEZpZWxkKTogdm9pZCB7XG4gICAgdGhpcy5maWVsZHMgPSBPYmplY3QuYXNzaWduKFsuLi50aGlzLmZpZWxkc10sIHtbZmllbGRJZHhdOiBuZXdGaWVsZH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBkYXRhc2V0IGNvbG9yIGJ5IGN1c3RvbSBjb2xvclxuICAgKiBAcGFyYW0gbmV3Q29sb3JcbiAgICovXG4gIHVwZGF0ZVRhYmxlQ29sb3IobmV3Q29sb3I6IFJHQkNvbG9yKTogdm9pZCB7XG4gICAgdGhpcy5jb2xvciA9IG5ld0NvbG9yO1xuICB9XG5cbiAgLyoqXG4gICAqIFNhdmUgZmlsdGVyUHJvcHMgdG8gZmllbGQgYW5kIHJldHJpZXZlIGl0XG4gICAqIEBwYXJhbSBjb2x1bW5OYW1lXG4gICAqL1xuICBnZXRDb2x1bW5GaWx0ZXJQcm9wcyhjb2x1bW5OYW1lOiBzdHJpbmcpOiBGaWVsZFsnZmlsdGVyUHJvcHMnXSB8IG51bGwgfCB1bmRlZmluZWQge1xuICAgIGNvbnN0IGZpZWxkSWR4ID0gdGhpcy5nZXRDb2x1bW5GaWVsZElkeChjb2x1bW5OYW1lKTtcbiAgICBpZiAoZmllbGRJZHggPCAwKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgZmllbGQgPSB0aGlzLmZpZWxkc1tmaWVsZElkeF07XG4gICAgaWYgKGZpZWxkLmhhc093blByb3BlcnR5KCdmaWx0ZXJQcm9wcycpKSB7XG4gICAgICByZXR1cm4gZmllbGQuZmlsdGVyUHJvcHM7XG4gICAgfVxuXG4gICAgY29uc3QgZmllbGREb21haW4gPSB0aGlzLmdldENvbHVtbkZpbHRlckRvbWFpbihmaWVsZCk7XG4gICAgaWYgKCFmaWVsZERvbWFpbikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QgZmlsdGVyUHJvcHMgPSBnZXRGaWx0ZXJQcm9wcyhmaWVsZCwgZmllbGREb21haW4pO1xuICAgIGNvbnN0IG5ld0ZpZWxkID0ge1xuICAgICAgLi4uZmllbGQsXG4gICAgICBmaWx0ZXJQcm9wc1xuICAgIH07XG5cbiAgICB0aGlzLnVwZGF0ZUNvbHVtbkZpZWxkKGZpZWxkSWR4LCBuZXdGaWVsZCk7XG5cbiAgICByZXR1cm4gZmlsdGVyUHJvcHM7XG4gIH1cblxuICAvKipcbiAgICogQXBwbHkgZmlsdGVycyB0byBkYXRhc2V0LCByZXR1cm4gdGhlIGZpbHRlcmVkIGRhdGFzZXQgd2l0aCB1cGRhdGVkIGBncHVGaWx0ZXJgLCBgZmlsdGVyUmVjb3JkYCwgYGZpbHRlcmVkSW5kZXhgLCBgZmlsdGVyZWRJbmRleEZvckRvbWFpbmBcbiAgICogQHBhcmFtIGZpbHRlcnNcbiAgICogQHBhcmFtIGxheWVyc1xuICAgKiBAcGFyYW0gb3B0XG4gICAqL1xuICBmaWx0ZXJUYWJsZShmaWx0ZXJzOiBGaWx0ZXJbXSwgbGF5ZXJzOiBMYXllcltdLCBvcHQ/OiBGaWx0ZXJEYXRhc2V0T3B0KTogS2VwbGVyVGFibGUge1xuICAgIGNvbnN0IHtkYXRhQ29udGFpbmVyLCBpZDogZGF0YUlkLCBmaWx0ZXJSZWNvcmQ6IG9sZEZpbHRlclJlY29yZCwgZmllbGRzfSA9IHRoaXM7XG5cbiAgICAvLyBpZiB0aGVyZSBpcyBubyBmaWx0ZXJzXG4gICAgY29uc3QgZmlsdGVyUmVjb3JkID0gZ2V0RmlsdGVyUmVjb3JkKGRhdGFJZCwgZmlsdGVycywgb3B0IHx8IHt9KTtcblxuICAgIHRoaXMuZmlsdGVyUmVjb3JkID0gZmlsdGVyUmVjb3JkO1xuICAgIHRoaXMuZ3B1RmlsdGVyID0gZ2V0R3B1RmlsdGVyUHJvcHMoZmlsdGVycywgZGF0YUlkLCBmaWVsZHMpO1xuXG4gICAgLy8gY29uc3QgbmV3RGF0YXNldCA9IHNldChbJ2ZpbHRlclJlY29yZCddLCBmaWx0ZXJSZWNvcmQsIGRhdGFzZXQpO1xuXG4gICAgaWYgKCFmaWx0ZXJzLmxlbmd0aCkge1xuICAgICAgdGhpcy5maWx0ZXJlZEluZGV4ID0gdGhpcy5hbGxJbmRleGVzO1xuICAgICAgdGhpcy5maWx0ZXJlZEluZGV4Rm9yRG9tYWluID0gdGhpcy5hbGxJbmRleGVzO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdGhpcy5jaGFuZ2VkRmlsdGVycyA9IGRpZmZGaWx0ZXJzKGZpbHRlclJlY29yZCwgb2xkRmlsdGVyUmVjb3JkKTtcblxuICAgIC8vIGdlbmVyYXRlIDIgc2V0cyBvZiBmaWx0ZXIgcmVzdWx0XG4gICAgLy8gZmlsdGVyZWRJbmRleCB1c2VkIHRvIGNhbGN1bGF0ZSBsYXllciBkYXRhXG4gICAgLy8gZmlsdGVyZWRJbmRleEZvckRvbWFpbiB1c2VkIHRvIGNhbGN1bGF0ZSBsYXllciBEb21haW5cbiAgICBjb25zdCBzaG91bGRDYWxEb21haW4gPSBCb29sZWFuKHRoaXMuY2hhbmdlZEZpbHRlcnMuZHluYW1pY0RvbWFpbik7XG4gICAgY29uc3Qgc2hvdWxkQ2FsSW5kZXggPSBCb29sZWFuKHRoaXMuY2hhbmdlZEZpbHRlcnMuY3B1KTtcblxuICAgIGxldCBmaWx0ZXJSZXN1bHQ6IEZpbHRlclJlc3VsdCA9IHt9O1xuICAgIGlmIChzaG91bGRDYWxEb21haW4gfHwgc2hvdWxkQ2FsSW5kZXgpIHtcbiAgICAgIGNvbnN0IGR5bmFtaWNEb21haW5GaWx0ZXJzID0gc2hvdWxkQ2FsRG9tYWluID8gZmlsdGVyUmVjb3JkLmR5bmFtaWNEb21haW4gOiBudWxsO1xuICAgICAgY29uc3QgY3B1RmlsdGVycyA9IHNob3VsZENhbEluZGV4ID8gZmlsdGVyUmVjb3JkLmNwdSA6IG51bGw7XG5cbiAgICAgIGNvbnN0IGZpbHRlckZ1bmNzID0gZmlsdGVycy5yZWR1Y2UoKGFjYywgZmlsdGVyKSA9PiB7XG4gICAgICAgIGNvbnN0IGZpZWxkSW5kZXggPSBnZXREYXRhc2V0RmllbGRJbmRleEZvckZpbHRlcih0aGlzLmlkLCBmaWx0ZXIpO1xuICAgICAgICBjb25zdCBmaWVsZCA9IGZpZWxkSW5kZXggIT09IC0xID8gZmllbGRzW2ZpZWxkSW5kZXhdIDogbnVsbDtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLmFjYyxcbiAgICAgICAgICBbZmlsdGVyLmlkXTogZ2V0RmlsdGVyRnVuY3Rpb24oZmllbGQsIHRoaXMuaWQsIGZpbHRlciwgbGF5ZXJzLCBkYXRhQ29udGFpbmVyKVxuICAgICAgICB9O1xuICAgICAgfSwge30pO1xuXG4gICAgICBmaWx0ZXJSZXN1bHQgPSBmaWx0ZXJEYXRhQnlGaWx0ZXJUeXBlcyhcbiAgICAgICAge2R5bmFtaWNEb21haW5GaWx0ZXJzLCBjcHVGaWx0ZXJzLCBmaWx0ZXJGdW5jc30sXG4gICAgICAgIGRhdGFDb250YWluZXJcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdGhpcy5maWx0ZXJlZEluZGV4ID0gZmlsdGVyUmVzdWx0LmZpbHRlcmVkSW5kZXggfHwgdGhpcy5maWx0ZXJlZEluZGV4O1xuICAgIHRoaXMuZmlsdGVyZWRJbmRleEZvckRvbWFpbiA9XG4gICAgICBmaWx0ZXJSZXN1bHQuZmlsdGVyZWRJbmRleEZvckRvbWFpbiB8fCB0aGlzLmZpbHRlcmVkSW5kZXhGb3JEb21haW47XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBseSBmaWx0ZXJzIHRvIGEgZGF0YXNldCBhbGwgb24gQ1BVLCBhc3NpZ24gdG8gYGZpbHRlcmVkSWR4Q1BVYCwgYGZpbHRlclJlY29yZENQVWBcbiAgICogQHBhcmFtIGZpbHRlcnNcbiAgICogQHBhcmFtIGxheWVyc1xuICAgKi9cbiAgZmlsdGVyVGFibGVDUFUoZmlsdGVyczogRmlsdGVyW10sIGxheWVyczogTGF5ZXJbXSk6IEtlcGxlclRhYmxlIHtcbiAgICBjb25zdCBvcHQgPSB7XG4gICAgICBjcHVPbmx5OiB0cnVlLFxuICAgICAgaWdub3JlRG9tYWluOiB0cnVlXG4gICAgfTtcblxuICAgIC8vIG5vIGZpbHRlclxuICAgIGlmICghZmlsdGVycy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuZmlsdGVyZWRJZHhDUFUgPSB0aGlzLmFsbEluZGV4ZXM7XG4gICAgICB0aGlzLmZpbHRlclJlY29yZENQVSA9IGdldEZpbHRlclJlY29yZCh0aGlzLmlkLCBmaWx0ZXJzLCBvcHQpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gbm8gZ3B1IGZpbHRlclxuICAgIGlmICghZmlsdGVycy5maW5kKGYgPT4gZi5ncHUpKSB7XG4gICAgICB0aGlzLmZpbHRlcmVkSWR4Q1BVID0gdGhpcy5maWx0ZXJlZEluZGV4O1xuICAgICAgdGhpcy5maWx0ZXJSZWNvcmRDUFUgPSBnZXRGaWx0ZXJSZWNvcmQodGhpcy5pZCwgZmlsdGVycywgb3B0KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIG1ha2UgYSBjb3B5IGZvciBjcHUgZmlsdGVyaW5nXG4gICAgY29uc3QgY29waWVkID0gY29weVRhYmxlKHRoaXMpO1xuXG4gICAgY29waWVkLmZpbHRlclJlY29yZCA9IHRoaXMuZmlsdGVyUmVjb3JkQ1BVO1xuICAgIGNvcGllZC5maWx0ZXJlZEluZGV4ID0gdGhpcy5maWx0ZXJlZElkeENQVSB8fCBbXTtcblxuICAgIGNvbnN0IGZpbHRlcmVkID0gY29waWVkLmZpbHRlclRhYmxlKGZpbHRlcnMsIGxheWVycywgb3B0KTtcblxuICAgIHRoaXMuZmlsdGVyZWRJZHhDUFUgPSBmaWx0ZXJlZC5maWx0ZXJlZEluZGV4O1xuICAgIHRoaXMuZmlsdGVyUmVjb3JkQ1BVID0gZmlsdGVyZWQuZmlsdGVyUmVjb3JkO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlIGZpZWxkIGRvbWFpbiBiYXNlZCBvbiBmaWVsZCB0eXBlIGFuZCBkYXRhXG4gICAqIGZvciBGaWx0ZXJcbiAgICovXG4gIGdldENvbHVtbkZpbHRlckRvbWFpbihmaWVsZDogRmllbGQpOiBGaWVsZERvbWFpbiB7XG4gICAgY29uc3Qge2RhdGFDb250YWluZXJ9ID0gdGhpcztcbiAgICBjb25zdCB7dmFsdWVBY2Nlc3Nvcn0gPSBmaWVsZDtcblxuICAgIGxldCBkb21haW47XG5cbiAgICBzd2l0Y2ggKGZpZWxkLnR5cGUpIHtcbiAgICAgIGNhc2UgQUxMX0ZJRUxEX1RZUEVTLnJlYWw6XG4gICAgICBjYXNlIEFMTF9GSUVMRF9UWVBFUy5pbnRlZ2VyOlxuICAgICAgICAvLyBjYWxjdWxhdGUgZG9tYWluIGFuZCBzdGVwXG4gICAgICAgIHJldHVybiBnZXROdW1lcmljRmllbGREb21haW4oZGF0YUNvbnRhaW5lciwgdmFsdWVBY2Nlc3Nvcik7XG5cbiAgICAgIGNhc2UgQUxMX0ZJRUxEX1RZUEVTLmJvb2xlYW46XG4gICAgICAgIHJldHVybiB7ZG9tYWluOiBbdHJ1ZSwgZmFsc2VdfTtcblxuICAgICAgY2FzZSBBTExfRklFTERfVFlQRVMuc3RyaW5nOlxuICAgICAgY2FzZSBBTExfRklFTERfVFlQRVMuZGF0ZTpcbiAgICAgICAgZG9tYWluID0gZ2V0T3JkaW5hbERvbWFpbihkYXRhQ29udGFpbmVyLCB2YWx1ZUFjY2Vzc29yKTtcbiAgICAgICAgcmV0dXJuIHtkb21haW59O1xuXG4gICAgICBjYXNlIEFMTF9GSUVMRF9UWVBFUy50aW1lc3RhbXA6XG4gICAgICAgIHJldHVybiBnZXRUaW1lc3RhbXBGaWVsZERvbWFpbihkYXRhQ29udGFpbmVyLCB2YWx1ZUFjY2Vzc29yKTtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHtkb21haW46IGdldE9yZGluYWxEb21haW4oZGF0YUNvbnRhaW5lciwgdmFsdWVBY2Nlc3Nvcil9O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiAgR2V0IHRoZSBkb21haW4gb2YgdGhpcyBjb2x1bW4gYmFzZWQgb24gc2NhbGUgdHlwZVxuICAgKi9cbiAgZ2V0Q29sdW1uTGF5ZXJEb21haW4oXG4gICAgZmllbGQ6IEZpZWxkLFxuICAgIHNjYWxlVHlwZTogc3RyaW5nXG4gICk6IG51bWJlcltdIHwgc3RyaW5nW10gfCBbbnVtYmVyLCBudW1iZXJdIHwgbnVsbCB7XG4gICAgY29uc3Qge2RhdGFDb250YWluZXIsIGZpbHRlcmVkSW5kZXhGb3JEb21haW59ID0gdGhpcztcblxuICAgIGlmICghU0NBTEVfVFlQRVNbc2NhbGVUeXBlXSkge1xuICAgICAgQ29uc29sZS5lcnJvcihgc2NhbGUgdHlwZSAke3NjYWxlVHlwZX0gbm90IHN1cHBvcnRlZGApO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3Qge3ZhbHVlQWNjZXNzb3J9ID0gZmllbGQ7XG4gICAgY29uc3QgaW5kZXhWYWx1ZUFjY2Vzc29yID0gaSA9PiB2YWx1ZUFjY2Vzc29yKHtpbmRleDogaX0pO1xuICAgIGNvbnN0IHNvcnRGdW5jdGlvbiA9IGdldFNvcnRpbmdGdW5jdGlvbihmaWVsZC50eXBlKTtcblxuICAgIHN3aXRjaCAoc2NhbGVUeXBlKSB7XG4gICAgICBjYXNlIFNDQUxFX1RZUEVTLm9yZGluYWw6XG4gICAgICBjYXNlIFNDQUxFX1RZUEVTLnBvaW50OlxuICAgICAgICAvLyBkbyBub3QgcmVjYWxjdWxhdGUgb3JkaW5hbCBkb21haW4gYmFzZWQgb24gZmlsdGVyZWQgZGF0YVxuICAgICAgICAvLyBkb24ndCBuZWVkIHRvIHVwZGF0ZSBvcmRpbmFsIGRvbWFpbiBldmVyeSB0aW1lXG4gICAgICAgIHJldHVybiBnZXRPcmRpbmFsRG9tYWluKGRhdGFDb250YWluZXIsIHZhbHVlQWNjZXNzb3IpO1xuXG4gICAgICBjYXNlIFNDQUxFX1RZUEVTLnF1YW50aWxlOlxuICAgICAgICByZXR1cm4gZ2V0UXVhbnRpbGVEb21haW4oZmlsdGVyZWRJbmRleEZvckRvbWFpbiwgaW5kZXhWYWx1ZUFjY2Vzc29yLCBzb3J0RnVuY3Rpb24pO1xuXG4gICAgICBjYXNlIFNDQUxFX1RZUEVTLmxvZzpcbiAgICAgICAgcmV0dXJuIGdldExvZ0RvbWFpbihmaWx0ZXJlZEluZGV4Rm9yRG9tYWluLCBpbmRleFZhbHVlQWNjZXNzb3IpO1xuXG4gICAgICBjYXNlIFNDQUxFX1RZUEVTLnF1YW50aXplOlxuICAgICAgY2FzZSBTQ0FMRV9UWVBFUy5saW5lYXI6XG4gICAgICBjYXNlIFNDQUxFX1RZUEVTLnNxcnQ6XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZ2V0TGluZWFyRG9tYWluKGZpbHRlcmVkSW5kZXhGb3JEb21haW4sIGluZGV4VmFsdWVBY2Nlc3Nvcik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhIHNhbXBsZSBvZiByb3dzIHRvIGNhbGN1bGF0ZSBsYXllciBib3VuZGFyaWVzXG4gICAqL1xuICAvLyBnZXRTYW1wbGVEYXRhKHJvd3MpXG5cbiAgLyoqXG4gICAqIFBhcnNlIGNlbGwgdmFsdWUgYmFzZWQgb24gY29sdW1uIHR5cGUgYW5kIHJldHVybiBhIHN0cmluZyByZXByZXNlbnRhdGlvblxuICAgKiBWYWx1ZSB0aGUgZmllbGQgdmFsdWUsIHR5cGUgdGhlIGZpZWxkIHR5cGVcbiAgICovXG4gIC8vIHBhcnNlRmllbGRWYWx1ZSh2YWx1ZSwgdHlwZSlcblxuICAvLyBzb3J0RGF0YXNldEJ5Q29sdW1uKClcblxuICAvKipcbiAgICogQXNzZXJ0IHdoZXRoZXIgZmllbGQgZXhpc3RcbiAgICogQHBhcmFtIGZpZWxkTmFtZVxuICAgKiBAcGFyYW0gY29uZGl0aW9uXG4gICAqL1xuICBfYXNzZXRGaWVsZChmaWVsZE5hbWU6IHN0cmluZywgY29uZGl0aW9uOiBhbnkpOiB2b2lkIHtcbiAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgQ29uc29sZS5lcnJvcihgJHtmaWVsZE5hbWV9IGRvZXNudCBleGlzdCBpbiBkYXRhc2V0ICR7dGhpcy5pZH1gKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IHR5cGUgRGF0YXNldHMgPSB7XG4gIFtrZXk6IHN0cmluZ106IEtlcGxlclRhYmxlO1xufTtcblxuLy8gSEVMUEVSIEZVTkNUSU9OUyAoTUFJTkxZIEVYUE9SVEVEIEZPUiBURVNULi4uKVxuLy8gaGF2ZSB0byBkb3VibGUgZXhjYXBlXG5jb25zdCBzcGVjaWFsQ2hhcmFjdGVyU2V0ID0gYFsjXyZAXFxcXC5cXFxcLVxcXFwgXWA7XG5cbmZ1bmN0aW9uIGZvdW5kTWF0Y2hpbmdGaWVsZHMocmUsIHN1ZmZpeFBhaXIsIGFsbE5hbWVzLCBmaWVsZE5hbWUpIHtcbiAgY29uc3QgcGFydG5lcklkeCA9IGFsbE5hbWVzLmZpbmRJbmRleChcbiAgICBkID0+IGQgPT09IGZpZWxkTmFtZS5yZXBsYWNlKHJlLCBtYXRjaCA9PiBtYXRjaC5yZXBsYWNlKHN1ZmZpeFBhaXJbMF0sIHN1ZmZpeFBhaXJbMV0pKVxuICApO1xuICBsZXQgYWx0SWR4ID0gLTE7XG4gIGlmIChwYXJ0bmVySWR4ID4gLTEpIHtcbiAgICAvLyBpZiBmb3VuZCBwYXJ0bmVyLCBnbyBvbiBhbmQgbG9vayBmb3IgYWx0aXR1ZGVcbiAgICBBTFRJVFVERV9GSUVMRFMuc29tZShhbHQgPT4ge1xuICAgICAgYWx0SWR4ID0gYWxsTmFtZXMuZmluZEluZGV4KFxuICAgICAgICBkID0+IGQgPT09IGZpZWxkTmFtZS5yZXBsYWNlKHJlLCBtYXRjaCA9PiBtYXRjaC5yZXBsYWNlKHN1ZmZpeFBhaXJbMF0sIGFsdCkpXG4gICAgICApO1xuICAgICAgcmV0dXJuIGFsdElkeCA+IC0xO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiB7cGFydG5lcklkeCwgYWx0SWR4fTtcbn1cbi8qKlxuICogRmluZCBwb2ludCBmaWVsZHMgcGFpcnMgZnJvbSBmaWVsZHNcbiAqXG4gKiBAcGFyYW0gZmllbGRzXG4gKiBAcmV0dXJucyBmb3VuZCBwb2ludCBmaWVsZHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZpbmRQb2ludEZpZWxkUGFpcnMoZmllbGRzOiBGaWVsZFtdKTogRmllbGRQYWlyW10ge1xuICBjb25zdCBhbGxOYW1lcyA9IGZpZWxkcy5tYXAoZiA9PiBmLm5hbWUudG9Mb3dlckNhc2UoKSk7XG5cbiAgLy8gZ2V0IGxpc3Qgb2YgYWxsIGZpZWxkcyB3aXRoIG1hdGNoaW5nIHN1ZmZpeGVzXG4gIGNvbnN0IGFjYzogRmllbGRQYWlyW10gPSBbXTtcbiAgcmV0dXJuIGFsbE5hbWVzLnJlZHVjZSgoY2FycnksIGZpZWxkTmFtZSwgaWR4KSA9PiB7XG4gICAgLy8gVGhpcyBzZWFyY2ggZm9yIHBhaXJzIHdpbGwgZWFybHkgZXhpdCBpZiBmb3VuZC5cbiAgICBmb3IgKGNvbnN0IHN1ZmZpeFBhaXIgb2YgVFJJUF9QT0lOVF9GSUVMRFMpIHtcbiAgICAgIC8vIG1hdGNoIGZpcnN0IHN1ZmZpeFxuICAgICAgLy8gKF58WyNfJkBcXC5cXC1cXCBdKWxhdChbI18mQFxcLlxcLVxcIF18JClcbiAgICAgIGNvbnN0IHJlID0gbmV3IFJlZ0V4cChgKF58JHtzcGVjaWFsQ2hhcmFjdGVyU2V0fSkke3N1ZmZpeFBhaXJbMF19KCR7c3BlY2lhbENoYXJhY3RlclNldH18JClgKTtcblxuICAgICAgaWYgKHJlLnRlc3QoZmllbGROYW1lKSkge1xuICAgICAgICBjb25zdCB7cGFydG5lcklkeCwgYWx0SWR4fSA9IGZvdW5kTWF0Y2hpbmdGaWVsZHMocmUsIHN1ZmZpeFBhaXIsIGFsbE5hbWVzLCBmaWVsZE5hbWUpO1xuXG4gICAgICAgIGlmIChwYXJ0bmVySWR4ID4gLTEpIHtcbiAgICAgICAgICBjb25zdCB0cmltTmFtZSA9IGZpZWxkTmFtZS5yZXBsYWNlKHJlLCAnJykudHJpbSgpO1xuXG4gICAgICAgICAgY2FycnkucHVzaCh7XG4gICAgICAgICAgICBkZWZhdWx0TmFtZTogdHJpbU5hbWUgfHwgJ3BvaW50JyxcbiAgICAgICAgICAgIHBhaXI6IHtcbiAgICAgICAgICAgICAgbGF0OiB7XG4gICAgICAgICAgICAgICAgZmllbGRJZHg6IGlkeCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogZmllbGRzW2lkeF0ubmFtZVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBsbmc6IHtcbiAgICAgICAgICAgICAgICBmaWVsZElkeDogcGFydG5lcklkeCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogZmllbGRzW3BhcnRuZXJJZHhdLm5hbWVcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgLi4uKGFsdElkeCA+IC0xXG4gICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgIGFsdDoge1xuICAgICAgICAgICAgICAgICAgICAgIGZpZWxkSWR4OiBhbHRJZHgsXG4gICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGZpZWxkc1thbHRJZHhdLm5hbWVcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDoge30pXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3VmZml4OiBzdWZmaXhQYWlyXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIGNhcnJ5O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjYXJyeTtcbiAgfSwgYWNjKTtcbn1cblxuLyoqXG4gKlxuICogQHBhcmFtIGRhdGFzZXRcbiAqIEBwYXJhbSBjb2x1bW5cbiAqIEBwYXJhbSBtb2RlXG4gKiBAdHlwZVxuICovXG5leHBvcnQgZnVuY3Rpb24gc29ydERhdGFzZXRCeUNvbHVtbihcbiAgZGF0YXNldDogS2VwbGVyVGFibGUsXG4gIGNvbHVtbjogc3RyaW5nLFxuICBtb2RlPzogc3RyaW5nXG4pOiBLZXBsZXJUYWJsZSB7XG4gIGNvbnN0IHthbGxJbmRleGVzLCBmaWVsZHMsIGRhdGFDb250YWluZXJ9ID0gZGF0YXNldDtcbiAgY29uc3QgZmllbGRJbmRleCA9IGZpZWxkcy5maW5kSW5kZXgoZiA9PiBmLm5hbWUgPT09IGNvbHVtbik7XG4gIGlmIChmaWVsZEluZGV4IDwgMCkge1xuICAgIHJldHVybiBkYXRhc2V0O1xuICB9XG5cbiAgY29uc3Qgc29ydEJ5ID0gU09SVF9PUkRFUlttb2RlIHx8ICcnXSB8fCBTT1JUX09SREVSLkFTQ0VORElORztcblxuICBpZiAoc29ydEJ5ID09PSBTT1JUX09SREVSLlVOU09SVCkge1xuICAgIGRhdGFzZXQuc29ydENvbHVtbiA9IHt9O1xuICAgIGRhdGFzZXQuc29ydE9yZGVyID0gbnVsbDtcblxuICAgIHJldHVybiBkYXRhc2V0O1xuICB9XG5cbiAgY29uc3Qgc29ydEZ1bmN0aW9uID0gc29ydEJ5ID09PSBTT1JUX09SREVSLkFTQ0VORElORyA/IGFzY2VuZGluZyA6IGRlc2NlbmRpbmc7XG4gIGNvbnN0IHNvcnRPcmRlciA9IGFsbEluZGV4ZXNcbiAgICAuc2xpY2UoKVxuICAgIC5zb3J0KChhLCBiKSA9PlxuICAgICAgc29ydEZ1bmN0aW9uKGRhdGFDb250YWluZXIudmFsdWVBdChhLCBmaWVsZEluZGV4KSwgZGF0YUNvbnRhaW5lci52YWx1ZUF0KGIsIGZpZWxkSW5kZXgpKVxuICAgICk7XG5cbiAgZGF0YXNldC5zb3J0Q29sdW1uID0ge1xuICAgIFtjb2x1bW5dOiBzb3J0QnlcbiAgfTtcbiAgZGF0YXNldC5zb3J0T3JkZXIgPSBzb3J0T3JkZXI7XG5cbiAgcmV0dXJuIGRhdGFzZXQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwaW5UYWJsZUNvbHVtbnMoZGF0YXNldDogS2VwbGVyVGFibGUsIGNvbHVtbjogc3RyaW5nKTogS2VwbGVyVGFibGUge1xuICBjb25zdCBmaWVsZCA9IGRhdGFzZXQuZ2V0Q29sdW1uRmllbGQoY29sdW1uKTtcbiAgaWYgKCFmaWVsZCkge1xuICAgIHJldHVybiBkYXRhc2V0O1xuICB9XG5cbiAgbGV0IHBpbm5lZENvbHVtbnM7XG4gIGlmIChBcnJheS5pc0FycmF5KGRhdGFzZXQucGlubmVkQ29sdW1ucykgJiYgZGF0YXNldC5waW5uZWRDb2x1bW5zLmluY2x1ZGVzKGZpZWxkLm5hbWUpKSB7XG4gICAgLy8gdW5waW4gaXRcbiAgICBwaW5uZWRDb2x1bW5zID0gZGF0YXNldC5waW5uZWRDb2x1bW5zLmZpbHRlcihjbyA9PiBjbyAhPT0gZmllbGQubmFtZSk7XG4gIH0gZWxzZSB7XG4gICAgcGlubmVkQ29sdW1ucyA9IChkYXRhc2V0LnBpbm5lZENvbHVtbnMgfHwgW10pLmNvbmNhdChmaWVsZC5uYW1lKTtcbiAgfVxuXG4gIC8vIEB0cy1pZ25vcmVcbiAgcmV0dXJuIGNvcHlUYWJsZUFuZFVwZGF0ZShkYXRhc2V0LCB7cGlubmVkQ29sdW1uc30pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY29weVRhYmxlKG9yaWdpbmFsOiBLZXBsZXJUYWJsZSk6IEtlcGxlclRhYmxlIHtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2Yob3JpZ2luYWwpKSwgb3JpZ2luYWwpO1xufVxuXG4vKipcbiAqIEB0eXBlXG4gKiBAcmV0dXJuc1xuICovXG5leHBvcnQgZnVuY3Rpb24gY29weVRhYmxlQW5kVXBkYXRlKFxuICBvcmlnaW5hbDogS2VwbGVyVGFibGUsXG4gIG9wdGlvbnM6IFBhcnRpYWw8S2VwbGVyVGFibGU+ID0ge31cbik6IEtlcGxlclRhYmxlIHtcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKG9wdGlvbnMpLnJlZHVjZSgoYWNjLCBlbnRyeSkgPT4ge1xuICAgIGFjY1tlbnRyeVswXV0gPSBlbnRyeVsxXTtcbiAgICByZXR1cm4gYWNjO1xuICB9LCBjb3B5VGFibGUob3JpZ2luYWwpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEZpZWxkVmFsdWVBY2Nlc3NvcjxcbiAgRiBleHRlbmRzIHtcbiAgICB0eXBlPzogRmllbGRbJ3R5cGUnXTtcbiAgICBmb3JtYXQ/OiBGaWVsZFsnZm9ybWF0J107XG4gIH1cbj4oZjogRiwgaTogbnVtYmVyLCBkYzogRGF0YUNvbnRhaW5lckludGVyZmFjZSkge1xuICByZXR1cm4gbWF5YmVUb0RhdGUuYmluZChcbiAgICBudWxsLFxuICAgIC8vIGlzIHRpbWVcbiAgICBmLnR5cGUgPT09IEFMTF9GSUVMRF9UWVBFUy50aW1lc3RhbXAsXG4gICAgaSxcbiAgICBmLmZvcm1hdCB8fCAnJyxcbiAgICBkY1xuICApO1xufVxuXG5leHBvcnQgZGVmYXVsdCBLZXBsZXJUYWJsZTtcbiJdfQ==