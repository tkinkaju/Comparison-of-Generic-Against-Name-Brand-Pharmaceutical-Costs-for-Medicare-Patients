// Copyright (c) 2022 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setFilterGpuMode = setFilterGpuMode;
exports.assignGpuChannels = assignGpuChannels;
exports.assignGpuChannel = assignGpuChannel;
exports.resetFilterGpuMode = resetFilterGpuMode;
exports.getGpuFilterProps = getGpuFilterProps;
exports.getDatasetFieldIndexForFilter = getDatasetFieldIndexForFilter;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _moment = _interopRequireDefault(require("moment"));

var _constants = require("@kepler.gl/constants");

var _utils = require("@kepler.gl/utils");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/**
 * Set gpu mode based on current number of gpu filters exists
 */
function setFilterGpuMode(filter, filters) {
  // filter can be applied to multiple datasets, hence gpu filter mode should also be
  // an array, however, to keep us sane, for now, we only check if there is available channel for every dataId,
  // if all of them has, we set gpu mode to true
  // TODO: refactor filter so we don't keep an array of everything
  filter.dataId.forEach(function (dataId, datasetIdx) {
    var gpuFilters = filters.filter(function (f) {
      return f.dataId.includes(dataId) && f.gpu;
    });

    if (filter.gpu && gpuFilters.length === _constants.MAX_GPU_FILTERS) {
      return (0, _utils.set)(['gpu'], false, filter);
    }
  });
  return filter;
}
/**
 * Scan though all filters and assign gpu chanel to gpu filter
 */


function assignGpuChannels(allFilters) {
  return allFilters.reduce(function (accu, f, index) {
    var filters = accu; // if gpu is true assign and validate gpu Channel

    if (f.gpu) {
      f = assignGpuChannel(f, accu);
      filters = (0, _utils.set)([index], f, accu);
    }

    return filters;
  }, allFilters);
}
/**
 * Assign a new gpu filter a channel based on first availability
 */


function assignGpuChannel(filter, filters) {
  // find first available channel
  if (!filter.gpu) {
    return filter;
  }

  var gpuChannel = filter.gpuChannel || [];
  filter.dataId.forEach(function (dataId, datasetIdx) {
    var findGpuChannel = function findGpuChannel(channel) {
      return function (f) {
        var dataIdx = (0, _utils.toArray)(f.dataId).indexOf(dataId);
        return f.id !== filter.id && dataIdx > -1 && f.gpu && (0, _utils.toArray)(f.gpuChannel)[dataIdx] === channel;
      };
    };

    if (Number.isFinite(gpuChannel[datasetIdx]) && !filters.find(findGpuChannel(gpuChannel[datasetIdx]))) {
      // if value is already assigned and valid
      return;
    }

    var i = 0;

    while (i < _constants.MAX_GPU_FILTERS) {
      if (!filters.find(findGpuChannel(i))) {
        gpuChannel[datasetIdx] = i;
        return;
      }

      i++;
    }
  }); // if cannot find channel for all dataid, set gpu back to false
  // TODO: refactor filter to handle same filter different gpu mode

  if (!gpuChannel.length || !gpuChannel.every(Number.isFinite)) {
    return _objectSpread(_objectSpread({}, filter), {}, {
      gpu: false
    });
  }

  return _objectSpread(_objectSpread({}, filter), {}, {
    gpuChannel: gpuChannel
  });
}
/**
 * Edit filter.gpu to ensure that only
 * X number of gpu filers can coexist.
 */


function resetFilterGpuMode(filters) {
  var gpuPerDataset = {};
  return filters.map(function (f, i) {
    if (f.gpu) {
      var gpu = true;
      (0, _utils.toArray)(f.dataId).forEach(function (dataId) {
        var count = gpuPerDataset[dataId];

        if (count === _constants.MAX_GPU_FILTERS) {
          gpu = false;
        } else {
          gpuPerDataset[dataId] = count ? count + 1 : 1;
        }
      });

      if (!gpu) {
        return (0, _utils.set)(['gpu'], false, f);
      }
    }

    return f;
  });
}
/**
 * Initial filter uniform
 */


function getEmptyFilterRange() {
  return new Array(_constants.MAX_GPU_FILTERS).fill(0).map(function (d) {
    return [0, 0];
  });
}
/**
 * Returns index of the data element.
 * @param {any} d Data element with row index info.
 * @returns number
 */


var defaultGetIndex = function defaultGetIndex(d) {
  return d.index;
};
/**
 * Returns value at the specified row from the data container.
 * @param dc Data container.
 * @param d Data element with row index info.
 * @param fieldIndex Column index in the data container.
 * @returns
 */


var defaultGetData = function defaultGetData(dc, d, fieldIndex) {
  return dc.valueAt(d.index, fieldIndex);
};
/**
 * @param channels
 * @param dataId
 * @param fields
 * @return {Function} getFilterValue
 */


var getFilterValueAccessor = function getFilterValueAccessor(channels, dataId, fields) {
  return function (dc) {
    return function () {
      var getIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultGetIndex;
      var getData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultGetData;
      return function (d) {
        return (// for empty channel, value is 0 and min max would be [0, 0]
          channels.map(function (filter) {
            var _filter$domain;

            if (!filter) {
              return 0;
            }

            var fieldIndex = getDatasetFieldIndexForFilter(dataId, filter);
            var field = fields[fieldIndex];
            var value = filter.type === _constants.FILTER_TYPES.timeRange ? field.filterProps && Array.isArray(field.filterProps.mappedValue) ? field.filterProps.mappedValue[getIndex(d)] : _moment["default"].utc(getData(dc, d, fieldIndex)).valueOf() : getData(dc, d, fieldIndex);
            return (0, _utils.notNullorUndefined)(value) ? value - ((_filter$domain = filter.domain) === null || _filter$domain === void 0 ? void 0 : _filter$domain[0]) : Number.MIN_SAFE_INTEGER;
          })
        );
      };
    };
  };
};
/**
 * Get filter properties for gpu filtering
 */


function getGpuFilterProps(filters, dataId, fields) {
  var filterRange = getEmptyFilterRange();
  var triggers = {}; // array of filter for each channel, undefined, if no filter is assigned to that channel

  var channels = [];

  var _loop = function _loop(i) {
    var _filter$domain2, _filter$domain3;

    var filter = filters.find(function (f) {
      return f.gpu && f.dataId.includes(dataId) && f.gpuChannel && f.gpuChannel[f.dataId.indexOf(dataId)] === i;
    });
    filterRange[i][0] = filter ? filter.value[0] - ((_filter$domain2 = filter.domain) === null || _filter$domain2 === void 0 ? void 0 : _filter$domain2[0]) : 0;
    filterRange[i][1] = filter ? filter.value[1] - ((_filter$domain3 = filter.domain) === null || _filter$domain3 === void 0 ? void 0 : _filter$domain3[0]) : 0;
    triggers["gpuFilter_".concat(i)] = filter ? filter.name[filter.dataId.indexOf(dataId)] : null;
    channels.push(filter);
  };

  for (var i = 0; i < _constants.MAX_GPU_FILTERS; i++) {
    _loop(i);
  }

  var filterValueAccessor = getFilterValueAccessor(channels, dataId, fields);
  return {
    filterRange: filterRange,
    filterValueUpdateTriggers: triggers,
    // @ts-expect-error
    filterValueAccessor: filterValueAccessor
  };
}
/**
 * Return dataset field index from filter.fieldIdx
 * The index matches the same dataset index for filter.dataId
 */


function getDatasetFieldIndexForFilter(dataId, filter) {
  var datasetIndex = (0, _utils.toArray)(filter.dataId).indexOf(dataId);

  if (datasetIndex < 0) {
    return -1;
  }

  var fieldIndex = filter.fieldIdx[datasetIndex];
  return (0, _utils.notNullorUndefined)(fieldIndex) ? fieldIndex : -1;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9ncHUtZmlsdGVyLXV0aWxzLnRzIl0sIm5hbWVzIjpbInNldEZpbHRlckdwdU1vZGUiLCJmaWx0ZXIiLCJmaWx0ZXJzIiwiZGF0YUlkIiwiZm9yRWFjaCIsImRhdGFzZXRJZHgiLCJncHVGaWx0ZXJzIiwiZiIsImluY2x1ZGVzIiwiZ3B1IiwibGVuZ3RoIiwiTUFYX0dQVV9GSUxURVJTIiwiYXNzaWduR3B1Q2hhbm5lbHMiLCJhbGxGaWx0ZXJzIiwicmVkdWNlIiwiYWNjdSIsImluZGV4IiwiYXNzaWduR3B1Q2hhbm5lbCIsImdwdUNoYW5uZWwiLCJmaW5kR3B1Q2hhbm5lbCIsImNoYW5uZWwiLCJkYXRhSWR4IiwiaW5kZXhPZiIsImlkIiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJmaW5kIiwiaSIsImV2ZXJ5IiwicmVzZXRGaWx0ZXJHcHVNb2RlIiwiZ3B1UGVyRGF0YXNldCIsIm1hcCIsImNvdW50IiwiZ2V0RW1wdHlGaWx0ZXJSYW5nZSIsIkFycmF5IiwiZmlsbCIsImQiLCJkZWZhdWx0R2V0SW5kZXgiLCJkZWZhdWx0R2V0RGF0YSIsImRjIiwiZmllbGRJbmRleCIsInZhbHVlQXQiLCJnZXRGaWx0ZXJWYWx1ZUFjY2Vzc29yIiwiY2hhbm5lbHMiLCJmaWVsZHMiLCJnZXRJbmRleCIsImdldERhdGEiLCJnZXREYXRhc2V0RmllbGRJbmRleEZvckZpbHRlciIsImZpZWxkIiwidmFsdWUiLCJ0eXBlIiwiRklMVEVSX1RZUEVTIiwidGltZVJhbmdlIiwiZmlsdGVyUHJvcHMiLCJpc0FycmF5IiwibWFwcGVkVmFsdWUiLCJtb21lbnQiLCJ1dGMiLCJ2YWx1ZU9mIiwiZG9tYWluIiwiTUlOX1NBRkVfSU5URUdFUiIsImdldEdwdUZpbHRlclByb3BzIiwiZmlsdGVyUmFuZ2UiLCJ0cmlnZ2VycyIsIm5hbWUiLCJwdXNoIiwiZmlsdGVyVmFsdWVBY2Nlc3NvciIsImZpbHRlclZhbHVlVXBkYXRlVHJpZ2dlcnMiLCJkYXRhc2V0SW5kZXgiLCJmaWVsZElk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Q0xrQixJQUFBQSxXQUFXLEVBQVhBLFdBREs7QUFFTEssSUFBQUEseUJBQXlCLEVBQUVKLFFBRnRCO0FBR0w7QUFDQUcsSUFBQUEsbUJBQW1CLEVBQW5CQTtBQUpLLEdBQVA7QUFNRDtBQUVEO0FBQ0E7QUFDQTtBQUNBOzs7QUFDTyxTQUFTbkIsNkJBQVQsQ0FBdUM1QyxNQUF2QyxFQUF1REYsTUFBdkQsRUFBK0U7QUFDcEYsTUFBTW1FLFlBQVksR0FBRyxvQkFBUW5FLE1BQU0sQ0FBQ0UsTUFBZixFQUF1Qm1CLE9BQXZCLENBQStCbkIsTUFBL0IsQ0FBckI7O0FBQ0EsTUFBSWlFLFlBQVksR0FBRyxDQUFuQixFQUFzQjtBQUNwQixXQUFPLENBQUMsQ0FBUjtBQUNEOztBQUVELE1BQU01QixVQUFVLEdBQUd2QyxNQUFNLENBQUNvRSxRQUFQLENBQWdCRCxZQUFoQixDQUFuQjtBQUVBLFNBQU8sK0JBQW1CNUIsVUFBbkIsSUFBaUNBLFVBQWpDLEdBQThDLENBQUMsQ0FBdEQ7QUFDRCIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAyMiBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5cbmltcG9ydCBtb21lbnQgZnJvbSAnbW9tZW50JztcbmltcG9ydCB7TUFYX0dQVV9GSUxURVJTLCBGSUxURVJfVFlQRVN9IGZyb20gJ0BrZXBsZXIuZ2wvY29uc3RhbnRzJztcbmltcG9ydCB7RmllbGQsIEZpbHRlcn0gZnJvbSAnQGtlcGxlci5nbC90eXBlcyc7XG5cbmltcG9ydCB7c2V0LCB0b0FycmF5LCBub3ROdWxsb3JVbmRlZmluZWQsIERhdGFDb250YWluZXJJbnRlcmZhY2V9IGZyb20gJ0BrZXBsZXIuZ2wvdXRpbHMnO1xuaW1wb3J0IHtHcHVGaWx0ZXJ9IGZyb20gJy4va2VwbGVyLXRhYmxlJztcblxuLyoqXG4gKiBTZXQgZ3B1IG1vZGUgYmFzZWQgb24gY3VycmVudCBudW1iZXIgb2YgZ3B1IGZpbHRlcnMgZXhpc3RzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRGaWx0ZXJHcHVNb2RlKGZpbHRlcjogRmlsdGVyLCBmaWx0ZXJzOiBGaWx0ZXJbXSkge1xuICAvLyBmaWx0ZXIgY2FuIGJlIGFwcGxpZWQgdG8gbXVsdGlwbGUgZGF0YXNldHMsIGhlbmNlIGdwdSBmaWx0ZXIgbW9kZSBzaG91bGQgYWxzbyBiZVxuICAvLyBhbiBhcnJheSwgaG93ZXZlciwgdG8ga2VlcCB1cyBzYW5lLCBmb3Igbm93LCB3ZSBvbmx5IGNoZWNrIGlmIHRoZXJlIGlzIGF2YWlsYWJsZSBjaGFubmVsIGZvciBldmVyeSBkYXRhSWQsXG4gIC8vIGlmIGFsbCBvZiB0aGVtIGhhcywgd2Ugc2V0IGdwdSBtb2RlIHRvIHRydWVcbiAgLy8gVE9ETzogcmVmYWN0b3IgZmlsdGVyIHNvIHdlIGRvbid0IGtlZXAgYW4gYXJyYXkgb2YgZXZlcnl0aGluZ1xuXG4gIGZpbHRlci5kYXRhSWQuZm9yRWFjaCgoZGF0YUlkLCBkYXRhc2V0SWR4KSA9PiB7XG4gICAgY29uc3QgZ3B1RmlsdGVycyA9IGZpbHRlcnMuZmlsdGVyKGYgPT4gZi5kYXRhSWQuaW5jbHVkZXMoZGF0YUlkKSAmJiBmLmdwdSk7XG5cbiAgICBpZiAoZmlsdGVyLmdwdSAmJiBncHVGaWx0ZXJzLmxlbmd0aCA9PT0gTUFYX0dQVV9GSUxURVJTKSB7XG4gICAgICByZXR1cm4gc2V0KFsnZ3B1J10sIGZhbHNlLCBmaWx0ZXIpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGZpbHRlcjtcbn1cblxuLyoqXG4gKiBTY2FuIHRob3VnaCBhbGwgZmlsdGVycyBhbmQgYXNzaWduIGdwdSBjaGFuZWwgdG8gZ3B1IGZpbHRlclxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzaWduR3B1Q2hhbm5lbHMoYWxsRmlsdGVyczogRmlsdGVyW10pIHtcbiAgcmV0dXJuIGFsbEZpbHRlcnMucmVkdWNlKChhY2N1LCBmLCBpbmRleCkgPT4ge1xuICAgIGxldCBmaWx0ZXJzID0gYWNjdTtcblxuICAgIC8vIGlmIGdwdSBpcyB0cnVlIGFzc2lnbiBhbmQgdmFsaWRhdGUgZ3B1IENoYW5uZWxcbiAgICBpZiAoZi5ncHUpIHtcbiAgICAgIGYgPSBhc3NpZ25HcHVDaGFubmVsKGYsIGFjY3UpO1xuICAgICAgZmlsdGVycyA9IHNldChbaW5kZXhdLCBmLCBhY2N1KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmlsdGVycztcbiAgfSwgYWxsRmlsdGVycyk7XG59XG4vKipcbiAqIEFzc2lnbiBhIG5ldyBncHUgZmlsdGVyIGEgY2hhbm5lbCBiYXNlZCBvbiBmaXJzdCBhdmFpbGFiaWxpdHlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2lnbkdwdUNoYW5uZWwoZmlsdGVyOiBGaWx0ZXIsIGZpbHRlcnM6IEZpbHRlcltdKSB7XG4gIC8vIGZpbmQgZmlyc3QgYXZhaWxhYmxlIGNoYW5uZWxcbiAgaWYgKCFmaWx0ZXIuZ3B1KSB7XG4gICAgcmV0dXJuIGZpbHRlcjtcbiAgfVxuXG4gIGNvbnN0IGdwdUNoYW5uZWwgPSBmaWx0ZXIuZ3B1Q2hhbm5lbCB8fCBbXTtcblxuICBmaWx0ZXIuZGF0YUlkLmZvckVhY2goKGRhdGFJZCwgZGF0YXNldElkeCkgPT4ge1xuICAgIGNvbnN0IGZpbmRHcHVDaGFubmVsID0gY2hhbm5lbCA9PiBmID0+IHtcbiAgICAgIGNvbnN0IGRhdGFJZHggPSB0b0FycmF5KGYuZGF0YUlkKS5pbmRleE9mKGRhdGFJZCk7XG4gICAgICByZXR1cm4gKFxuICAgICAgICBmLmlkICE9PSBmaWx0ZXIuaWQgJiYgZGF0YUlkeCA+IC0xICYmIGYuZ3B1ICYmIHRvQXJyYXkoZi5ncHVDaGFubmVsKVtkYXRhSWR4XSA9PT0gY2hhbm5lbFxuICAgICAgKTtcbiAgICB9O1xuXG4gICAgaWYgKFxuICAgICAgTnVtYmVyLmlzRmluaXRlKGdwdUNoYW5uZWxbZGF0YXNldElkeF0pICYmXG4gICAgICAhZmlsdGVycy5maW5kKGZpbmRHcHVDaGFubmVsKGdwdUNoYW5uZWxbZGF0YXNldElkeF0pKVxuICAgICkge1xuICAgICAgLy8gaWYgdmFsdWUgaXMgYWxyZWFkeSBhc3NpZ25lZCBhbmQgdmFsaWRcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgaSA9IDA7XG5cbiAgICB3aGlsZSAoaSA8IE1BWF9HUFVfRklMVEVSUykge1xuICAgICAgaWYgKCFmaWx0ZXJzLmZpbmQoZmluZEdwdUNoYW5uZWwoaSkpKSB7XG4gICAgICAgIGdwdUNoYW5uZWxbZGF0YXNldElkeF0gPSBpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpKys7XG4gICAgfVxuICB9KTtcblxuICAvLyBpZiBjYW5ub3QgZmluZCBjaGFubmVsIGZvciBhbGwgZGF0YWlkLCBzZXQgZ3B1IGJhY2sgdG8gZmFsc2VcbiAgLy8gVE9ETzogcmVmYWN0b3IgZmlsdGVyIHRvIGhhbmRsZSBzYW1lIGZpbHRlciBkaWZmZXJlbnQgZ3B1IG1vZGVcbiAgaWYgKCFncHVDaGFubmVsLmxlbmd0aCB8fCAhZ3B1Q2hhbm5lbC5ldmVyeShOdW1iZXIuaXNGaW5pdGUpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmZpbHRlcixcbiAgICAgIGdwdTogZmFsc2VcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICAuLi5maWx0ZXIsXG4gICAgZ3B1Q2hhbm5lbFxuICB9O1xufVxuLyoqXG4gKiBFZGl0IGZpbHRlci5ncHUgdG8gZW5zdXJlIHRoYXQgb25seVxuICogWCBudW1iZXIgb2YgZ3B1IGZpbGVycyBjYW4gY29leGlzdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlc2V0RmlsdGVyR3B1TW9kZShmaWx0ZXJzOiBGaWx0ZXJbXSk6IEZpbHRlcltdIHtcbiAgY29uc3QgZ3B1UGVyRGF0YXNldCA9IHt9O1xuXG4gIHJldHVybiBmaWx0ZXJzLm1hcCgoZiwgaSkgPT4ge1xuICAgIGlmIChmLmdwdSkge1xuICAgICAgbGV0IGdwdSA9IHRydWU7XG4gICAgICB0b0FycmF5KGYuZGF0YUlkKS5mb3JFYWNoKGRhdGFJZCA9PiB7XG4gICAgICAgIGNvbnN0IGNvdW50ID0gZ3B1UGVyRGF0YXNldFtkYXRhSWRdO1xuXG4gICAgICAgIGlmIChjb3VudCA9PT0gTUFYX0dQVV9GSUxURVJTKSB7XG4gICAgICAgICAgZ3B1ID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZ3B1UGVyRGF0YXNldFtkYXRhSWRdID0gY291bnQgPyBjb3VudCArIDEgOiAxO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKCFncHUpIHtcbiAgICAgICAgcmV0dXJuIHNldChbJ2dwdSddLCBmYWxzZSwgZik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGY7XG4gIH0pO1xufVxuXG4vKipcbiAqIEluaXRpYWwgZmlsdGVyIHVuaWZvcm1cbiAqL1xuZnVuY3Rpb24gZ2V0RW1wdHlGaWx0ZXJSYW5nZSgpIHtcbiAgcmV0dXJuIG5ldyBBcnJheShNQVhfR1BVX0ZJTFRFUlMpLmZpbGwoMCkubWFwKGQgPT4gWzAsIDBdKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGluZGV4IG9mIHRoZSBkYXRhIGVsZW1lbnQuXG4gKiBAcGFyYW0ge2FueX0gZCBEYXRhIGVsZW1lbnQgd2l0aCByb3cgaW5kZXggaW5mby5cbiAqIEByZXR1cm5zIG51bWJlclxuICovXG5jb25zdCBkZWZhdWx0R2V0SW5kZXggPSBkID0+IGQuaW5kZXg7XG5cbi8qKlxuICogUmV0dXJucyB2YWx1ZSBhdCB0aGUgc3BlY2lmaWVkIHJvdyBmcm9tIHRoZSBkYXRhIGNvbnRhaW5lci5cbiAqIEBwYXJhbSBkYyBEYXRhIGNvbnRhaW5lci5cbiAqIEBwYXJhbSBkIERhdGEgZWxlbWVudCB3aXRoIHJvdyBpbmRleCBpbmZvLlxuICogQHBhcmFtIGZpZWxkSW5kZXggQ29sdW1uIGluZGV4IGluIHRoZSBkYXRhIGNvbnRhaW5lci5cbiAqIEByZXR1cm5zXG4gKi9cbmNvbnN0IGRlZmF1bHRHZXREYXRhID0gKGRjOiBEYXRhQ29udGFpbmVySW50ZXJmYWNlLCBkOiBhbnksIGZpZWxkSW5kZXg6IG51bWJlcikgPT4ge1xuICByZXR1cm4gZGMudmFsdWVBdChkLmluZGV4LCBmaWVsZEluZGV4KTtcbn07XG5cbi8qKlxuICogQHBhcmFtIGNoYW5uZWxzXG4gKiBAcGFyYW0gZGF0YUlkXG4gKiBAcGFyYW0gZmllbGRzXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gZ2V0RmlsdGVyVmFsdWVcbiAqL1xuY29uc3QgZ2V0RmlsdGVyVmFsdWVBY2Nlc3NvciA9IChcbiAgY2hhbm5lbHM6IChGaWx0ZXIgfCB1bmRlZmluZWQpW10sXG4gIGRhdGFJZDogc3RyaW5nLFxuICBmaWVsZHM6IGFueVtdXG4pID0+IChkYzogRGF0YUNvbnRhaW5lckludGVyZmFjZSkgPT4gKGdldEluZGV4ID0gZGVmYXVsdEdldEluZGV4LCBnZXREYXRhID0gZGVmYXVsdEdldERhdGEpID0+IGQgPT5cbiAgLy8gZm9yIGVtcHR5IGNoYW5uZWwsIHZhbHVlIGlzIDAgYW5kIG1pbiBtYXggd291bGQgYmUgWzAsIDBdXG4gIGNoYW5uZWxzLm1hcChmaWx0ZXIgPT4ge1xuICAgIGlmICghZmlsdGVyKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgY29uc3QgZmllbGRJbmRleCA9IGdldERhdGFzZXRGaWVsZEluZGV4Rm9yRmlsdGVyKGRhdGFJZCwgZmlsdGVyKTtcbiAgICBjb25zdCBmaWVsZCA9IGZpZWxkc1tmaWVsZEluZGV4XTtcblxuICAgIGNvbnN0IHZhbHVlID1cbiAgICAgIGZpbHRlci50eXBlID09PSBGSUxURVJfVFlQRVMudGltZVJhbmdlXG4gICAgICAgID8gZmllbGQuZmlsdGVyUHJvcHMgJiYgQXJyYXkuaXNBcnJheShmaWVsZC5maWx0ZXJQcm9wcy5tYXBwZWRWYWx1ZSlcbiAgICAgICAgICA/IGZpZWxkLmZpbHRlclByb3BzLm1hcHBlZFZhbHVlW2dldEluZGV4KGQpXVxuICAgICAgICAgIDogbW9tZW50LnV0YyhnZXREYXRhKGRjLCBkLCBmaWVsZEluZGV4KSkudmFsdWVPZigpXG4gICAgICAgIDogZ2V0RGF0YShkYywgZCwgZmllbGRJbmRleCk7XG5cbiAgICByZXR1cm4gbm90TnVsbG9yVW5kZWZpbmVkKHZhbHVlKSA/IHZhbHVlIC0gZmlsdGVyLmRvbWFpbj8uWzBdIDogTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVI7XG4gIH0pO1xuXG4vKipcbiAqIEdldCBmaWx0ZXIgcHJvcGVydGllcyBmb3IgZ3B1IGZpbHRlcmluZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0R3B1RmlsdGVyUHJvcHMoZmlsdGVyczogRmlsdGVyW10sIGRhdGFJZDogc3RyaW5nLCBmaWVsZHM6IEZpZWxkW10pOiBHcHVGaWx0ZXIge1xuICBjb25zdCBmaWx0ZXJSYW5nZSA9IGdldEVtcHR5RmlsdGVyUmFuZ2UoKTtcbiAgY29uc3QgdHJpZ2dlcnMgPSB7fTtcblxuICAvLyBhcnJheSBvZiBmaWx0ZXIgZm9yIGVhY2ggY2hhbm5lbCwgdW5kZWZpbmVkLCBpZiBubyBmaWx0ZXIgaXMgYXNzaWduZWQgdG8gdGhhdCBjaGFubmVsXG4gIGNvbnN0IGNoYW5uZWxzOiAoRmlsdGVyIHwgdW5kZWZpbmVkKVtdID0gW107XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBNQVhfR1BVX0ZJTFRFUlM7IGkrKykge1xuICAgIGNvbnN0IGZpbHRlciA9IGZpbHRlcnMuZmluZChcbiAgICAgIGYgPT5cbiAgICAgICAgZi5ncHUgJiZcbiAgICAgICAgZi5kYXRhSWQuaW5jbHVkZXMoZGF0YUlkKSAmJlxuICAgICAgICBmLmdwdUNoYW5uZWwgJiZcbiAgICAgICAgZi5ncHVDaGFubmVsW2YuZGF0YUlkLmluZGV4T2YoZGF0YUlkKV0gPT09IGlcbiAgICApO1xuXG4gICAgZmlsdGVyUmFuZ2VbaV1bMF0gPSBmaWx0ZXIgPyBmaWx0ZXIudmFsdWVbMF0gLSBmaWx0ZXIuZG9tYWluPy5bMF0gOiAwO1xuICAgIGZpbHRlclJhbmdlW2ldWzFdID0gZmlsdGVyID8gZmlsdGVyLnZhbHVlWzFdIC0gZmlsdGVyLmRvbWFpbj8uWzBdIDogMDtcblxuICAgIHRyaWdnZXJzW2BncHVGaWx0ZXJfJHtpfWBdID0gZmlsdGVyID8gZmlsdGVyLm5hbWVbZmlsdGVyLmRhdGFJZC5pbmRleE9mKGRhdGFJZCldIDogbnVsbDtcbiAgICBjaGFubmVscy5wdXNoKGZpbHRlcik7XG4gIH1cblxuICBjb25zdCBmaWx0ZXJWYWx1ZUFjY2Vzc29yID0gZ2V0RmlsdGVyVmFsdWVBY2Nlc3NvcihjaGFubmVscywgZGF0YUlkLCBmaWVsZHMpO1xuXG4gIHJldHVybiB7XG4gICAgZmlsdGVyUmFuZ2UsXG4gICAgZmlsdGVyVmFsdWVVcGRhdGVUcmlnZ2VyczogdHJpZ2dlcnMsXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgIGZpbHRlclZhbHVlQWNjZXNzb3JcbiAgfTtcbn1cblxuLyoqXG4gKiBSZXR1cm4gZGF0YXNldCBmaWVsZCBpbmRleCBmcm9tIGZpbHRlci5maWVsZElkeFxuICogVGhlIGluZGV4IG1hdGNoZXMgdGhlIHNhbWUgZGF0YXNldCBpbmRleCBmb3IgZmlsdGVyLmRhdGFJZFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGF0YXNldEZpZWxkSW5kZXhGb3JGaWx0ZXIoZGF0YUlkOiBzdHJpbmcsIGZpbHRlcjogRmlsdGVyKTogbnVtYmVyIHtcbiAgY29uc3QgZGF0YXNldEluZGV4ID0gdG9BcnJheShmaWx0ZXIuZGF0YUlkKS5pbmRleE9mKGRhdGFJZCk7XG4gIGlmIChkYXRhc2V0SW5kZXggPCAwKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgY29uc3QgZmllbGRJbmRleCA9IGZpbHRlci5maWVsZElkeFtkYXRhc2V0SW5kZXhdO1xuXG4gIHJldHVybiBub3ROdWxsb3JVbmRlZmluZWQoZmllbGRJbmRleCkgPyBmaWVsZEluZGV4IDogLTE7XG59XG4iXX0=