// Copyright (c) 2022 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getValueFunc = getValueFunc;
exports.getScaleFunctor = getScaleFunctor;
exports.getGetValue = getGetValue;
exports.getDimensionSortedBins = getDimensionSortedBins;
exports.getDimensionValueDomain = getDimensionValueDomain;
exports.getDimensionScale = getDimensionScale;
exports.getAggregatedData = getAggregatedData;
exports["default"] = exports.defaultDimensions = exports.defaultElevationDimension = exports.defaultColorDimension = exports.defaultAggregation = exports.DECK_AGGREGATION_MAP = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _aggregationLayers = require("@deck.gl/aggregation-layers");

var _window = require("global/window");

var _utils = require("@kepler.gl/utils");

var _constants = require("@kepler.gl/constants");

var _DECK_AGGREGATION_MAP;

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var DECK_AGGREGATION_MAP = (_DECK_AGGREGATION_MAP = {}, (0, _defineProperty2["default"])(_DECK_AGGREGATION_MAP, _aggregationLayers.AGGREGATION_OPERATION.SUM, _constants.AGGREGATION_TYPES.sum), (0, _defineProperty2["default"])(_DECK_AGGREGATION_MAP, _aggregationLayers.AGGREGATION_OPERATION.MEAN, _constants.AGGREGATION_TYPES.average), (0, _defineProperty2["default"])(_DECK_AGGREGATION_MAP, _aggregationLayers.AGGREGATION_OPERATION.MIN, _constants.AGGREGATION_TYPES.minimum), (0, _defineProperty2["default"])(_DECK_AGGREGATION_MAP, _aggregationLayers.AGGREGATION_OPERATION.MAX, _constants.AGGREGATION_TYPES.maximum), _DECK_AGGREGATION_MAP);
exports.DECK_AGGREGATION_MAP = DECK_AGGREGATION_MAP;

function getValueFunc(aggregation, accessor) {
  if (!aggregation || !_aggregationLayers.AGGREGATION_OPERATION[aggregation.toUpperCase()]) {
    _window.console.warn("Aggregation ".concat(aggregation, " is not supported"));
  }

  var op = _aggregationLayers.AGGREGATION_OPERATION[aggregation.toUpperCase()] || _aggregationLayers.AGGREGATION_OPERATION.SUM;

  var keplerOp = DECK_AGGREGATION_MAP[op];
  return function (pts) {
    return (0, _utils.aggregate)(pts.map(accessor), keplerOp);
  };
}

function getScaleFunctor(scaleType) {
  if (!scaleType || !_constants.SCALE_FUNC[scaleType]) {
    _window.console.warn("Scale ".concat(scaleType, " is not supported"));
  }

  return _constants.SCALE_FUNC[scaleType] || _constants.SCALE_FUNC.quantize;
}

function nop() {}

function getGetValue(step, props, dimensionUpdater) {
  var key = dimensionUpdater.key;
  var _step$triggers = step.triggers,
      value = _step$triggers.value,
      weight = _step$triggers.weight,
      aggregation = _step$triggers.aggregation;
  var getValue = props[value.prop];

  if (getValue === null) {
    // If `getValue` is not provided from props, build it with aggregation and weight.
    getValue = getValueFunc(props[aggregation.prop], props[weight.prop]);
  }

  if (getValue) {
    this._setDimensionState(key, {
      getValue: getValue
    });
  }
}

function getDimensionSortedBins(step, props, dimensionUpdater) {
  var key = dimensionUpdater.key;
  var getValue = this.state.dimensions[key].getValue; // @ts-expect-error

  var sortedBins = new _aggregationLayers._BinSorter(this.state.layerData.data || [], {
    getValue: getValue,
    filterData: props._filterData
  });

  this._setDimensionState(key, {
    sortedBins: sortedBins
  });
}

function getDimensionValueDomain(step, props, dimensionUpdater) {
  var key = dimensionUpdater.key;
  var _step$triggers2 = step.triggers,
      lowerPercentile = _step$triggers2.lowerPercentile,
      upperPercentile = _step$triggers2.upperPercentile,
      scaleType = _step$triggers2.scaleType;

  if (!this.state.dimensions[key].sortedBins) {
    // the previous step should set sortedBins, if not, something went wrong
    return;
  } // for log and sqrt scale, returns linear domain by default
  // TODO: support other scale function domain in bin sorter


  var valueDomain = this.state.dimensions[key].sortedBins.getValueDomainByScale(props[scaleType.prop], [props[lowerPercentile.prop], props[upperPercentile.prop]]);

  this._setDimensionState(key, {
    valueDomain: valueDomain
  });
}

function getDimensionScale(step, props, dimensionUpdater) {
  var key = dimensionUpdater.key;
  var _step$triggers3 = step.triggers,
      domain = _step$triggers3.domain,
      range = _step$triggers3.range,
      scaleType = _step$triggers3.scaleType;
  var onSet = step.onSet;

  if (!this.state.dimensions[key].valueDomain) {
    // the previous step should set valueDomain, if not, something went wrong
    return;
  }

  var dimensionRange = props[range.prop];
  var dimensionDomain = props[domain.prop] || this.state.dimensions[key].valueDomain;
  var scaleFunctor = getScaleFunctor(scaleType && props[scaleType.prop])();
  var scaleFunc = scaleFunctor.domain(dimensionDomain).range(dimensionRange);

  if ((0, _typeof2["default"])(onSet) === 'object' && typeof props[onSet.props] === 'function') {
    props[onSet.props](scaleFunc.domain());
  }

  this._setDimensionState(key, {
    scaleFunc: scaleFunc
  });
}

function normalizeResult() {
  var result = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  // support previous hexagonAggregator API
  if (result.hexagons) {
    return Object.assign({
      data: result.hexagons
    }, result);
  } else if (result.layerData) {
    return Object.assign({
      data: result.layerData
    }, result);
  }

  return result;
}

function getAggregatedData(step, props, aggregation, aggregationParams) {
  var aggr = step.triggers.aggregator;
  var aggregator = props[aggr.prop]; // result should contain a data array and other props
  // result = {data: [], ...other props}

  var result = aggregator(props, aggregationParams);
  this.setState({
    layerData: normalizeResult(result)
  });
}

var defaultAggregation = {
  key: 'position',
  updateSteps: [{
    key: 'aggregate',
    triggers: {
      cellSize: {
        prop: 'cellSize'
      },
      position: {
        prop: 'getPosition',
        updateTrigger: 'getPosition'
      },
      aggregator: {
        prop: 'gridAggregator'
      }
    },
    updater: getAggregatedData
  }]
};
exports.defaultAggregation = defaultAggregation;

function getSubLayerAccessor(dimensionState, dimension, layerProps) {
  return function (cell) {
    var sortedBins = dimensionState.sortedBins,
        scaleFunc = dimensionState.scaleFunc;
    var bin = sortedBins.binMap[cell.index];

    if (bin && bin.counts === 0) {
      // no points left in bin after filtering
      return dimension.nullValue;
    }

    var cv = bin && bin.value;
    var domain = scaleFunc.domain();
    var isValueInDomain = cv >= domain[0] && cv <= domain[domain.length - 1]; // if cell value is outside domain, set alpha to 0

    return isValueInDomain ? scaleFunc(cv) : dimension.nullValue;
  };
}

var defaultColorDimension = {
  key: 'fillColor',
  accessor: 'getFillColor',
  getPickingInfo: function getPickingInfo(dimensionState, cell) {
    if (!cell) {
      return {};
    }

    var sortedBins = dimensionState.sortedBins;
    var colorValue = sortedBins.binMap[cell.index] && sortedBins.binMap[cell.index].value;
    return {
      colorValue: colorValue
    };
  },
  nullValue: [0, 0, 0, 0],
  updateSteps: [{
    key: 'getValue',
    triggers: {
      value: {
        prop: 'getColorValue',
        updateTrigger: 'getColorValue'
      },
      weight: {
        prop: 'getColorWeight',
        updateTrigger: 'getColorWeight'
      },
      aggregation: {
        prop: 'colorAggregation'
      }
    },
    updater: getGetValue
  }, {
    key: 'getBins',
    triggers: {
      _filterData: {
        prop: '_filterData',
        updateTrigger: '_filterData'
      }
    },
    updater: getDimensionSortedBins
  }, {
    key: 'getDomain',
    triggers: {
      lowerPercentile: {
        prop: 'lowerPercentile'
      },
      upperPercentile: {
        prop: 'upperPercentile'
      },
      scaleType: {
        prop: 'colorScaleType'
      }
    },
    updater: getDimensionValueDomain
  }, {
    key: 'getScaleFunc',
    triggers: {
      domain: {
        prop: 'colorDomain'
      },
      range: {
        prop: 'colorRange'
      },
      scaleType: {
        prop: 'colorScaleType'
      }
    },
    onSet: {
      props: 'onSetColorDomain'
    },
    updater: getDimensionScale
  }],
  getSubLayerAccessor: getSubLayerAccessor
};
exports.defaultColorDimension = defaultColorDimension;
var defaultElevationDimension = {
  key: 'elevation',
  accessor: 'getElevation',
  getPickingInfo: function getPickingInfo(dimensionState, cell) {
    if (!cell) {
      return {};
    }

    var sortedBins = dimensionState.sortedBins;
    var elevationValue = sortedBins.binMap[cell.index] && sortedBins.binMap[cell.index].value;
    return {
      elevationValue: elevationValue
    };
  },
  nullValue: -1,
  updateSteps: [{
    key: 'getValue',
    triggers: {
      value: {
        prop: 'getElevationValue',
        updateTrigger: 'getElevationValue'
      },
      weight: {
        prop: 'getElevationWeight',
        updateTrigger: 'getElevationWeight'
      },
      aggregation: {
        prop: 'elevationAggregation'
      }
    },
    updater: getGetValue
  }, {
    key: 'getBins',
    triggers: {
      _filterData: {
        prop: '_filterData',
        updateTrigger: '_filterData'
      }
    },
    updater: getDimensionSortedBins
  }, {
    key: 'getDomain',
    triggers: {
      lowerPercentile: {
        prop: 'elevationLowerPercentile'
      },
      upperPercentile: {
        prop: 'elevationUpperPercentile'
      },
      scaleType: {
        prop: 'elevationScaleType'
      }
    },
    updater: getDimensionValueDomain
  }, {
    key: 'getScaleFunc',
    triggers: {
      domain: {
        prop: 'elevationDomain'
      },
      range: {
        prop: 'elevationRange'
      },
      scaleType: {
        prop: 'elevationScaleType'
      }
    },
    onSet: {
      props: 'onSetElevationDomain'
    },
    updater: getDimensionScale
  }],
  getSubLayerAccessor: getSubLayerAccessor
};
exports.defaultElevationDimension = defaultElevationDimension;
var _defaultDimensions = [defaultColorDimension, defaultElevationDimension];
exports.defaultDimensions = _defaultDimensions;

var CPUAggregator = /*#__PURE__*/function () {
  function CPUAggregator() {
    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck2["default"])(this, CPUAggregator);
    this.state = _objectSpread({
      layerData: {},
      dimensions: {// color: {
        //   getValue: null,
        //   domain: null,
        //   sortedBins: null,
        //   scaleFunc: nop
        // },
        // elevation: {
        //   getValue: null,
        //   domain: null,
        //   sortedBins: null,
        //   scaleFunc: nop
        // }
      }
    }, opts.initialState);
    this.dimensionUpdaters = {};
    this.aggregationUpdater = opts.aggregation || defaultAggregation;

    this._addDimension(opts.dimensions || _defaultDimensions);
  }

  (0, _createClass2["default"])(CPUAggregator, [{
    key: "updateAllDimensions",
    value: function updateAllDimensions(props) {
      var dimensionChanges = []; // update all dimensions

      for (var dim in this.dimensionUpdaters) {
        var updaters = this._accumulateUpdaters(0, props, this.dimensionUpdaters[dim]);

        dimensionChanges = dimensionChanges.concat(updaters);
      }

      dimensionChanges.forEach(function (f) {
        return typeof f === 'function' && f();
      });
    }
  }, {
    key: "updateAggregation",
    value: function updateAggregation(props, aggregationParams) {
      var updaters = this._accumulateUpdaters(0, props, this.aggregationUpdater);

      updaters.forEach(function (f) {
        return typeof f === 'function' && f(aggregationParams);
      });
    }
  }, {
    key: "updateState",
    value: function updateState(opts, aggregationParams) {
      var oldProps = opts.oldProps,
          props = opts.props,
          changeFlags = opts.changeFlags;
      var dimensionChanges = [];

      if (changeFlags.dataChanged) {
        // if data changed update everything
        this.updateAggregation(props, aggregationParams);
        this.updateAllDimensions(props);
        return this.state;
      }

      var aggregationChanges = this._getAggregationChanges(oldProps, props, changeFlags);

      if (aggregationChanges && aggregationChanges.length) {
        // get aggregatedData
        aggregationChanges.forEach(function (f) {
          return typeof f === 'function' && f(aggregationParams);
        });
        this.updateAllDimensions(props);
      } else {
        // only update dimensions
        dimensionChanges = this._getDimensionChanges(oldProps, props, changeFlags) || [];
        dimensionChanges.forEach(function (f) {
          return typeof f === 'function' && f();
        });
      }

      return this.state;
    } // Update private state

  }, {
    key: "setState",
    value: function setState(updateObject) {
      this.state = Object.assign({}, this.state, updateObject);
    } // Update private state.dimensions

  }, {
    key: "_setDimensionState",
    value: function _setDimensionState(key, updateObject) {
      this.setState({
        dimensions: Object.assign({}, this.state.dimensions, (0, _defineProperty2["default"])({}, key, Object.assign({}, this.state.dimensions[key], updateObject)))
      });
    }
  }, {
    key: "_addAggregation",
    value: function _addAggregation(aggregation) {
      this.aggregationUpdater = aggregation;
    }
  }, {
    key: "_addDimension",
    value: function _addDimension() {
      var _this = this;

      var dimensions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      dimensions.forEach(function (dimension) {
        var key = dimension.key;
        _this.dimensionUpdaters[key] = dimension;
      });
    }
  }, {
    key: "_needUpdateStep",
    value: function _needUpdateStep(dimensionStep, oldProps, props, changeFlags) {
      // whether need to update current dimension step
      // dimension step is the value, domain, scaleFunction of each dimension
      // each step is an object with properties links to layer prop and whether the prop is
      // controlled by updateTriggers
      return Object.values(dimensionStep.triggers).some(function (item) {
        if (item.updateTrigger) {
          // check based on updateTriggers change first
          return changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged[item.updateTrigger]);
        } // fallback to direct comparison


        return oldProps[item.prop] !== props[item.prop];
      });
    }
  }, {
    key: "_accumulateUpdaters",
    value: function _accumulateUpdaters(step, props, dimension) {
      var updaters = [];

      for (var i = step; i < dimension.updateSteps.length; i++) {
        var updater = dimension.updateSteps[i].updater;

        if (typeof updater === 'function') {
          updaters.push(updater.bind(this, dimension.updateSteps[i], props, dimension));
        }
      }

      return updaters;
    }
  }, {
    key: "_getAllUpdaters",
    value: function _getAllUpdaters(dimension, oldProps, props, changeFlags) {
      var _this2 = this;

      var updaters = [];
      var needUpdateStep = dimension.updateSteps.findIndex(function (step) {
        return _this2._needUpdateStep(step, oldProps, props, changeFlags);
      });

      if (needUpdateStep > -1) {
        updaters = updaters.concat(this._accumulateUpdaters(needUpdateStep, props, dimension));
      }

      return updaters;
    }
  }, {
    key: "_getAggregationChanges",
    value: function _getAggregationChanges(oldProps, props, changeFlags) {
      var updaters = this._getAllUpdaters(this.aggregationUpdater, oldProps, props, changeFlags);

      return updaters.length ? updaters : null;
    }
  }, {
    key: "_getDimensionChanges",
    value: function _getDimensionChanges(oldProps, props, changeFlags) {
      var updaters = []; // get dimension to be updated

      for (var _key in this.dimensionUpdaters) {
        // return the first triggered updater for each dimension
        var dimension = this.dimensionUpdaters[_key];

        var dimensionUpdaters = this._getAllUpdaters(dimension, oldProps, props, changeFlags);

        updaters = updaters.concat(dimensionUpdaters);
      }

      return updaters.length ? updaters : null;
    }
  }, {
    key: "getUpdateTriggers",
    value: function getUpdateTriggers(props) {
      var _this3 = this;

      var _updateTriggers = props.updateTriggers || {};

      var updateTriggers = {};

      var _loop = function _loop(_key2) {
        var _this3$dimensionUpdat = _this3.dimensionUpdaters[_key2],
            accessor = _this3$dimensionUpdat.accessor,
            updateSteps = _this3$dimensionUpdat.updateSteps; // fold dimension triggers into each accessor

        updateTriggers[accessor] = {};
        updateSteps.forEach(function (step) {
          Object.values(step.triggers || []).forEach(function (_ref) {
            var prop = _ref.prop,
                updateTrigger = _ref.updateTrigger;

            if (updateTrigger) {
              // if prop is based on updateTrigger e.g. getColorValue, getColorWeight
              // and updateTriggers is passed in from layer prop
              // fold the updateTriggers into accessor
              var fromProp = _updateTriggers[updateTrigger];

              if ((0, _typeof2["default"])(fromProp) === 'object' && !Array.isArray(fromProp)) {
                // if updateTrigger is an object spread it
                Object.assign(updateTriggers[accessor], fromProp);
              } else if (fromProp !== undefined) {
                updateTriggers[accessor][prop] = fromProp;
              }
            } else {
              // if prop is not based on updateTrigger
              updateTriggers[accessor][prop] = props[prop];
            }
          });
        });
      };

      for (var _key2 in this.dimensionUpdaters) {
        _loop(_key2);
      }

      return updateTriggers;
    }
  }, {
    key: "getPickingInfo",
    value: function getPickingInfo(_ref2, layerProps) {
      var info = _ref2.info;
      var isPicked = info.picked && info.index > -1;
      var object = null;
      var cell = isPicked ? this.state.layerData.data[info.index] : null;

      if (cell) {
        var binInfo = {};

        for (var _key3 in this.dimensionUpdaters) {
          var getPickingInfo = this.dimensionUpdaters[_key3].getPickingInfo;

          if (typeof getPickingInfo === 'function') {
            binInfo = Object.assign({}, binInfo, getPickingInfo(this.state.dimensions[_key3], cell, layerProps));
          }
        }

        object = Object.assign(binInfo, cell, {
          points: cell.filteredPoints || cell.points
        });
      } // add bin  and  to info


      return Object.assign(info, {
        picked: Boolean(object),
        // override object with picked cell
        object: object
      });
    }
  }, {
    key: "getAccessor",
    value: function getAccessor(dimensionKey, layerProps) {
      if (!this.dimensionUpdaters.hasOwnProperty(dimensionKey)) {
        return nop;
      }

      return this.dimensionUpdaters[dimensionKey].getSubLayerAccessor(this.state.dimensions[dimensionKey], this.dimensionUpdaters[dimensionKey], layerProps);
    }
  }], [{
    key: "defaultDimensions",
    value: function defaultDimensions() {
      return _defaultDimensions;
    }
  }]);
  return CPUAggregator;
}();

exports["default"] = CPUAggregator;
CPUAggregator.getDimensionScale = getDimensionScale;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9sYXllci11dGlscy9jcHUtYWdncmVnYXRvci50cyJdLCJuYW1lcyI6WyJERUNLX0FHR1JFR0FUSU9OX01BUCIsIkFHR1JFR0FUSU9OX09QRVJBVElPTiIsIlNVTSIsIkFHR1JFR0FUSU9OX1RZUEVTIiwic3VtIiwiTUVBTiIsImF2ZXJhZ2UiLCJNSU4iLCJtaW5pbXVtIiwiTUFYIiwibWF4aW11bSIsImdldFZhbHVlRnVuYyIsImFnZ3JlZ2F0aW9uIiwiYWNjZXNzb3IiLCJ0b1VwcGVyQ2FzZSIsIkNvbnNvbGUiLCJ3YXJuIiwib3AiLCJrZXBsZXJPcCIsInB0cyIsIm1hcCIsImdldFNjYWxlRnVuY3RvciIsInNjYWxlVHlwZSIsIlNDQUxFX0ZVTkMiLCJxdWFudGl6ZSIsIm5vcCIsImdldEdldFZhbHVlIiwic3RlcCIsInByb3BzIiwiZGltZW5zaW9uVXBkYXRlciIsImtleSIsInRyaWdnZXJzIiwidmFsdWUiLCJ3ZWlnaHQiLCJnZXRWYWx1ZSIsInByb3AiLCJfc2V0RGltZW5zaW9uU3RhdGUiLCJnZXREaW1lbnNpb25Tb3J0ZWRCaW5zIiwic3RhdGUiLCJkaW1lbnNpb25zIiwic29ydGVkQmlucyIsIkJpblNvcnRlciIsImxheWVyRGF0YSIsImRhdGEiLCJmaWx0ZXJEYXRhIiwiX2ZpbHRlckRhdGEiLCJnZXREaW1lbnNpb25WYWx1ZURvbWFpbiIsImxvd2VyUGVyY2VudGlsZSIsInVwcGVyUGVyY2VudGlsZSIsInZhbHVlRG9tYWluIiwiZ2V0VmFsdWVEb21haW5CeVNjYWxlIiwiZ2V0RGltZW5zaW9uU2NhbGUiLCJkb21haW4iLCJyYW5nZSIsIm9uU2V0IiwiZGltZW5zaW9uUmFuZ2UiLCJkaW1lbnNpb25Eb21haW4iLCJzY2FsZUZ1bmN0b3IiLCJzY2FsZUZ1bmMiLCJub3JtYWxpemVSZXN1bHQiLCJyZXN1bHQiLCJoZXhhZ29ucyIsIk9iamVjdCIsImFzc2lnbiIsImdldEFnZ3JlZ2F0ZWREYXRhIiwiYWdncmVnYXRpb25QYXJhbXMiLCJhZ2dyIiwiYWdncmVnYXRvciIsInNldFN0YXRlIiwiZGVmYXVsdEFnZ3JlZ2F0aW9uIiwidXBkYXRlU3RlcHMiLCJjZWxsU2l6ZSIsInBvc2l0aW9uIiwidXBkYXRlVHJpZ2dlciIsInVwZGF0ZXIiLCJnZXRTdWJMYXllckFjY2Vzc29yIiwiZGltZW5zaW9uU3RhdGUiLCJkaW1lbnNpb24iLCJsYXllclByb3BzIiwiY2VsbCIsImJpbiIsImJpbk1hcCIsImluZGV4IiwiY291bnRzIiwibnVsbFZhbHVlIiwiY3YiLCJpc1ZhbHVlSW5Eb21haW4iLCJsZW5ndGgiLCJkZWZhdWx0Q29sb3JEaW1lbnNpb24iLCJnZXRQaWNraW5nSW5mbyIsImNvbG9yVmFsdWUiLCJkZWZhdWx0RWxldmF0aW9uRGltZW5zaW9uIiwiZWxldmF0aW9uVmFsdWUiLCJkZWZhdWx0RGltZW5zaW9ucyIsIkNQVUFnZ3JlZ2F0b3IiLCJvcHRzIiwiaW5pdGlhbFN0YXRlIiwiZGltZW5zaW9uVXBkYXRlcnMiLCJhZ2dyZWdhdGlvblVwZGF0ZXIiLCJfYWRkRGltZW5zaW9uIiwiZGltZW5zaW9uQ2hhbmdlcyIsImRpbSIsInVwZGF0ZXJzIiwiX2FjY3VtdWxhdGVVcGRhdGVycyIsImNvbmNhdCIsImZvckVhY2giLCJmIiwib2xkUHJvcHMiLCJjaGFuZ2VGbGFncyIsImRhdGFDaGFuZ2VkIiwidXBkYXRlQWdncmVnYXRpb24iLCJ1cGRhdGVBbGxEaW1lbnNpb25zIiwiYWdncmVnYXRpb25DaGFuZ2VzIiwiX2dldEFnZ3JlZ2F0aW9uQ2hhbmdlcyIsIl9nZXREaW1lbnNpb25DaGFuZ2VzIiwidXBkYXRlT2JqZWN0IiwiZGltZW5zaW9uU3RlcCIsInZhbHVlcyIsInNvbWUiLCJpdGVtIiwidXBkYXRlVHJpZ2dlcnNDaGFuZ2VkIiwiYWxsIiwiaSIsInB1c2giLCJiaW5kIiwibmVlZFVwZGF0ZVN0ZXAiLCJmaW5kSW5kZXgiLCJfbmVlZFVwZGF0ZVN0ZXAiLCJfZ2V0QWxsVXBkYXRlcnMiLCJfdXBkYXRlVHJpZ2dlcnMiLCJ1cGRhdGVUcmlnZ2VycyIsImZyb21Qcm9wIiwiQXJyYXkiLCJpc0FycmF5IiwidW5kZWZpbmVkIiwiaW5mbyIsImlzUGlja2VkIiwicGlja2VkIiwib2JqZWN0IiwiYmluSW5mbyIsInBvaW50cyIsImZpbHRlcmVkUG9pbnRzIiwiQm9vbGVhbiIsImRpbWVuc2lvbktleSIsImhhc093blByb3BlcnR5Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFxQkE7O0FBQ0E7O0FBRUE7O0FBQ0E7Ozs7Ozs7O0FBcURPLElBQU1BLG9CQUFvQix3RkFDOUJDLHlDQUFzQkMsR0FEUSxFQUNGQyw2QkFBa0JDLEdBRGhCLDJEQUU5QkgseUNBQXNCSSxJQUZRLEVBRURGLDZCQUFrQkcsT0FGakIsMkRBRzlCTCx5Q0FBc0JNLEdBSFEsRUFHRkosNkJBQWtCSyxPQUhoQiwyREFJOUJQLHlDQUFzQlEsR0FKUSxFQUlGTiw2QkFBa0JPLE9BSmhCLHlCQUExQjs7O0FBT0EsU0FBU0MsWUFBVCxDQUFzQkMsV0FBdEIsRUFBbUNDLFFBQW5DLEVBQTZDO0FBQ2xELE1BQUksQ0FBQ0QsV0FBRCxJQUFnQixDQUFDWCx5Q0FBc0JXLFdBQVcsQ0FBQ0UsV0FBWixFQUF0QixDQUFyQixFQUF1RTtBQUNyRUMsb0JBQVFDLElBQVIsdUJBQTRCSixXQUE1QjtBQUNEOztBQUVELE1BQU1LLEVBQUUsR0FBR2hCLHlDQUFzQlcsV0FBVyxDQUFDRSxXQUFaLEVBQXRCLEtBQW9EYix5Q0FBc0JDLEdBQXJGOztBQUNBLE1BQU1nQixRQUFRLEdBQUdsQixvQkFBb0IsQ0FBQ2lCLEVBQUQsQ0FBckM7QUFFQSxTQUFPLFVBQUFFLEdBQUc7QUFBQSxXQUFJLHNCQUFVQSxHQUFHLENBQUNDLEdBQUosQ0FBUVAsUUFBUixDQUFWLEVBQTZCSyxRQUE3QixDQUFKO0FBQUEsR0FBVjtBQUNEOztBQUVNLFNBQVNHLGVBQVQsQ0FBeUJDLFNBQXpCLEVBQW9DO0FBQ3pDLE1BQUksQ0FBQ0EsU0FBRCxJQUFjLENBQUNDLHNCQUFXRCxTQUFYLENB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LFFBQUFBLE1BQU0sRUFBRUssT0FBTyxDQUFDSixNQUFELENBRFU7QUFFekI7QUFDQUEsUUFBQUEsTUFBTSxFQUFOQTtBQUh5QixPQUFwQixDQUFQO0FBS0Q7OztXQUVELHFCQUFZSyxZQUFaLEVBQTBCakUsVUFBMUIsRUFBc0M7QUFDcEMsVUFBSSxDQUFDLEtBQUttQixpQkFBTCxDQUF1QitDLGNBQXZCLENBQXNDRCxZQUF0QyxDQUFMLEVBQTBEO0FBQ3hELGVBQU90SCxHQUFQO0FBQ0Q7O0FBQ0QsYUFBTyxLQUFLd0UsaUJBQUwsQ0FBdUI4QyxZQUF2QixFQUFxQ3BFLG1CQUFyQyxDQUNMLEtBQUtyQyxLQUFMLENBQVdDLFVBQVgsQ0FBc0J3RyxZQUF0QixDQURLLEVBRUwsS0FBSzlDLGlCQUFMLENBQXVCOEMsWUFBdkIsQ0FGSyxFQUdMakUsVUFISyxDQUFQO0FBS0Q7OztXQXhPRCw2QkFBMkI7QUFDekIsYUFBT2Usa0JBQVA7QUFDRDs7Ozs7O0FBeU9IQyxhQUFhLENBQUMzQyxpQkFBZCxHQUFrQ0EsaUJBQWxDIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDIyIFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuLyogZXNsaW50LWRpc2FibGUgZ3VhcmQtZm9yLWluICovXG5pbXBvcnQge0FHR1JFR0FUSU9OX09QRVJBVElPTiwgX0JpblNvcnRlciBhcyBCaW5Tb3J0ZXJ9IGZyb20gJ0BkZWNrLmdsL2FnZ3JlZ2F0aW9uLWxheWVycyc7XG5pbXBvcnQge2NvbnNvbGUgYXMgQ29uc29sZX0gZnJvbSAnZ2xvYmFsL3dpbmRvdyc7XG5cbmltcG9ydCB7YWdncmVnYXRlfSBmcm9tICdAa2VwbGVyLmdsL3V0aWxzJztcbmltcG9ydCB7QUdHUkVHQVRJT05fVFlQRVMsIFNDQUxFX0ZVTkN9IGZyb20gJ0BrZXBsZXIuZ2wvY29uc3RhbnRzJztcbmltcG9ydCB7UkdCQUNvbG9yfSBmcm9tICdAa2VwbGVyLmdsL3R5cGVzJztcblxuZXhwb3J0IHR5cGUgVXBkYXRlclR5cGUgPSAodGhpczogQ1BVQWdncmVnYXRvciwgc3RlcCwgcHJvcHMsIGRpbWVuc2lvblVwZGF0ZXIpID0+IHZvaWQ7XG5leHBvcnQgdHlwZSBCaW5kZWRVcGRhdGVyVHlwZSA9ICgpID0+IHZvaWQ7XG5leHBvcnQgdHlwZSBBZ2dyZWdhdGVkVXBkYXRlclR5cGUgPSAoXG4gIHRoaXM6IENQVUFnZ3JlZ2F0b3IsXG4gIHN0ZXAsXG4gIHByb3BzLFxuICBhZ2dyZWdhdGlvbixcbiAgYWdncmVnYXRpb25QYXJhbXNcbikgPT4gdm9pZDtcbmV4cG9ydCB0eXBlIEJpbmRlZEFnZ3JlZ2F0ZWRVcGRhdGVyVHlwZSA9IChhZ2dyZWdhdGlvblBhcmFtcykgPT4gdm9pZDtcblxuZXhwb3J0IHR5cGUgVXBkYXRlU3RlcHNUeXBlID0ge1xuICBrZXk6IHN0cmluZztcbiAgdHJpZ2dlcnM6IHtcbiAgICBba2V5OiBzdHJpbmddOiB7XG4gICAgICBwcm9wOiBzdHJpbmc7XG4gICAgICB1cGRhdGVUcmlnZ2VyPzogc3RyaW5nO1xuICAgIH07XG4gIH07XG4gIG9uU2V0Pzoge1xuICAgIHByb3BzOiBzdHJpbmc7XG4gIH07XG4gIHVwZGF0ZXI6IFVwZGF0ZXJUeXBlO1xufTtcblxuZXhwb3J0IHR5cGUgRGltZW5zaW9uVHlwZTxWYWx1ZVR5cGUgPSBhbnk+ID0ge1xuICBrZXk6IHN0cmluZztcbiAgYWNjZXNzb3I6IHN0cmluZztcbiAgZ2V0UGlja2luZ0luZm86IChkaW1lbnNpb25TdGF0ZSwgY2VsbCwgbGF5ZXJQcm9wcz8pID0+IGFueTtcbiAgbnVsbFZhbHVlOiBWYWx1ZVR5cGU7XG4gIHVwZGF0ZVN0ZXBzOiBVcGRhdGVTdGVwc1R5cGVbXTtcbiAgZ2V0U3ViTGF5ZXJBY2Nlc3Nvcjtcbn07XG5cbmV4cG9ydCB0eXBlIEFnZ3JlZ2F0aW9uVXBkYXRlU3RlcHNUeXBlID0ge1xuICBrZXk6IHN0cmluZztcbiAgdHJpZ2dlcnM6IHtcbiAgICBba2V5OiBzdHJpbmddOiB7XG4gICAgICBwcm9wOiBzdHJpbmc7XG4gICAgICB1cGRhdGVUcmlnZ2VyPzogc3RyaW5nO1xuICAgIH07XG4gIH07XG4gIHVwZGF0ZXI6IEFnZ3JlZ2F0ZWRVcGRhdGVyVHlwZTtcbn07XG5cbmV4cG9ydCB0eXBlIEFnZ3JlZ2F0aW9uVHlwZSA9IHtcbiAga2V5OiBzdHJpbmc7XG4gIHVwZGF0ZVN0ZXBzOiBBZ2dyZWdhdGlvblVwZGF0ZVN0ZXBzVHlwZVtdO1xufTtcblxuZXhwb3J0IGNvbnN0IERFQ0tfQUdHUkVHQVRJT05fTUFQID0ge1xuICBbQUdHUkVHQVRJT05fT1BFUkFUSU9OLlNVTV06IEFHR1JFR0FUSU9OX1RZUEVTLnN1bSxcbiAgW0FHR1JFR0FUSU9OX09QRVJBVElPTi5NRUFOXTogQUdHUkVHQVRJT05fVFlQRVMuYXZlcmFnZSxcbiAgW0FHR1JFR0FUSU9OX09QRVJBVElPTi5NSU5dOiBBR0dSRUdBVElPTl9UWVBFUy5taW5pbXVtLFxuICBbQUdHUkVHQVRJT05fT1BFUkFUSU9OLk1BWF06IEFHR1JFR0FUSU9OX1RZUEVTLm1heGltdW1cbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRWYWx1ZUZ1bmMoYWdncmVnYXRpb24sIGFjY2Vzc29yKSB7XG4gIGlmICghYWdncmVnYXRpb24gfHwgIUFHR1JFR0FUSU9OX09QRVJBVElPTlthZ2dyZWdhdGlvbi50b1VwcGVyQ2FzZSgpXSkge1xuICAgIENvbnNvbGUud2FybihgQWdncmVnYXRpb24gJHthZ2dyZWdhdGlvbn0gaXMgbm90IHN1cHBvcnRlZGApO1xuICB9XG5cbiAgY29uc3Qgb3AgPSBBR0dSRUdBVElPTl9PUEVSQVRJT05bYWdncmVnYXRpb24udG9VcHBlckNhc2UoKV0gfHwgQUdHUkVHQVRJT05fT1BFUkFUSU9OLlNVTTtcbiAgY29uc3Qga2VwbGVyT3AgPSBERUNLX0FHR1JFR0FUSU9OX01BUFtvcF07XG5cbiAgcmV0dXJuIHB0cyA9PiBhZ2dyZWdhdGUocHRzLm1hcChhY2Nlc3NvciksIGtlcGxlck9wKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFNjYWxlRnVuY3RvcihzY2FsZVR5cGUpIHtcbiAgaWYgKCFzY2FsZVR5cGUgfHwgIVNDQUxFX0ZVTkNbc2NhbGVUeXBlXSkge1xuICAgIENvbnNvbGUud2FybihgU2NhbGUgJHtzY2FsZVR5cGV9IGlzIG5vdCBzdXBwb3J0ZWRgKTtcbiAgfVxuICByZXR1cm4gU0NBTEVfRlVOQ1tzY2FsZVR5cGVdIHx8IFNDQUxFX0ZVTkMucXVhbnRpemU7XG59XG5cbmZ1bmN0aW9uIG5vcCgpIHt9XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRHZXRWYWx1ZSh0aGlzOiBDUFVBZ2dyZWdhdG9yLCBzdGVwLCBwcm9wcywgZGltZW5zaW9uVXBkYXRlcikge1xuICBjb25zdCB7a2V5fSA9IGRpbWVuc2lvblVwZGF0ZXI7XG4gIGNvbnN0IHt2YWx1ZSwgd2VpZ2h0LCBhZ2dyZWdhdGlvbn0gPSBzdGVwLnRyaWdnZXJzO1xuXG4gIGxldCBnZXRWYWx1ZSA9IHByb3BzW3ZhbHVlLnByb3BdO1xuXG4gIGlmIChnZXRWYWx1ZSA9PT0gbnVsbCkge1xuICAgIC8vIElmIGBnZXRWYWx1ZWAgaXMgbm90IHByb3ZpZGVkIGZyb20gcHJvcHMsIGJ1aWxkIGl0IHdpdGggYWdncmVnYXRpb24gYW5kIHdlaWdodC5cbiAgICBnZXRWYWx1ZSA9IGdldFZhbHVlRnVuYyhwcm9wc1thZ2dyZWdhdGlvbi5wcm9wXSwgcHJvcHNbd2VpZ2h0LnByb3BdKTtcbiAgfVxuXG4gIGlmIChnZXRWYWx1ZSkge1xuICAgIHRoaXMuX3NldERpbWVuc2lvblN0YXRlKGtleSwge2dldFZhbHVlfSk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldERpbWVuc2lvblNvcnRlZEJpbnModGhpczogQ1BVQWdncmVnYXRvciwgc3RlcCwgcHJvcHMsIGRpbWVuc2lvblVwZGF0ZXIpIHtcbiAgY29uc3Qge2tleX0gPSBkaW1lbnNpb25VcGRhdGVyO1xuICBjb25zdCB7Z2V0VmFsdWV9ID0gdGhpcy5zdGF0ZS5kaW1lbnNpb25zW2tleV07XG4gIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgY29uc3Qgc29ydGVkQmlucyA9IG5ldyBCaW5Tb3J0ZXIodGhpcy5zdGF0ZS5sYXllckRhdGEuZGF0YSB8fCBbXSwge1xuICAgIGdldFZhbHVlLFxuICAgIGZpbHRlckRhdGE6IHByb3BzLl9maWx0ZXJEYXRhXG4gIH0pO1xuICB0aGlzLl9zZXREaW1lbnNpb25TdGF0ZShrZXksIHtzb3J0ZWRCaW5zfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXREaW1lbnNpb25WYWx1ZURvbWFpbih0aGlzOiBDUFVBZ2dyZWdhdG9yLCBzdGVwLCBwcm9wcywgZGltZW5zaW9uVXBkYXRlcikge1xuICBjb25zdCB7a2V5fSA9IGRpbWVuc2lvblVwZGF0ZXI7XG4gIGNvbnN0IHtcbiAgICB0cmlnZ2Vyczoge2xvd2VyUGVyY2VudGlsZSwgdXBwZXJQZXJjZW50aWxlLCBzY2FsZVR5cGV9XG4gIH0gPSBzdGVwO1xuXG4gIGlmICghdGhpcy5zdGF0ZS5kaW1lbnNpb25zW2tleV0uc29ydGVkQmlucykge1xuICAgIC8vIHRoZSBwcmV2aW91cyBzdGVwIHNob3VsZCBzZXQgc29ydGVkQmlucywgaWYgbm90LCBzb21ldGhpbmcgd2VudCB3cm9uZ1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIGZvciBsb2cgYW5kIHNxcnQgc2NhbGUsIHJldHVybnMgbGluZWFyIGRvbWFpbiBieSBkZWZhdWx0XG4gIC8vIFRPRE86IHN1cHBvcnQgb3RoZXIgc2NhbGUgZnVuY3Rpb24gZG9tYWluIGluIGJpbiBzb3J0ZXJcbiAgY29uc3QgdmFsdWVEb21haW4gPSB0aGlzLnN0YXRlLmRpbWVuc2lvbnNba2V5XS5zb3J0ZWRCaW5zLmdldFZhbHVlRG9tYWluQnlTY2FsZShcbiAgICBwcm9wc1tzY2FsZVR5cGUucHJvcF0sXG4gICAgW3Byb3BzW2xvd2VyUGVyY2VudGlsZS5wcm9wXSwgcHJvcHNbdXBwZXJQZXJjZW50aWxlLnByb3BdXVxuICApO1xuXG4gIHRoaXMuX3NldERpbWVuc2lvblN0YXRlKGtleSwge3ZhbHVlRG9tYWlufSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXREaW1lbnNpb25TY2FsZSh0aGlzOiBDUFVBZ2dyZWdhdG9yLCBzdGVwLCBwcm9wcywgZGltZW5zaW9uVXBkYXRlcikge1xuICBjb25zdCB7a2V5fSA9IGRpbWVuc2lvblVwZGF0ZXI7XG4gIGNvbnN0IHtkb21haW4sIHJhbmdlLCBzY2FsZVR5cGV9ID0gc3RlcC50cmlnZ2VycztcbiAgY29uc3Qge29uU2V0fSA9IHN0ZXA7XG4gIGlmICghdGhpcy5zdGF0ZS5kaW1lbnNpb25zW2tleV0udmFsdWVEb21haW4pIHtcbiAgICAvLyB0aGUgcHJldmlvdXMgc3RlcCBzaG91bGQgc2V0IHZhbHVlRG9tYWluLCBpZiBub3QsIHNvbWV0aGluZyB3ZW50IHdyb25nXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgZGltZW5zaW9uUmFuZ2UgPSBwcm9wc1tyYW5nZS5wcm9wXTtcbiAgY29uc3QgZGltZW5zaW9uRG9tYWluID0gcHJvcHNbZG9tYWluLnByb3BdIHx8IHRoaXMuc3RhdGUuZGltZW5zaW9uc1trZXldLnZhbHVlRG9tYWluO1xuXG4gIGNvbnN0IHNjYWxlRnVuY3RvciA9IGdldFNjYWxlRnVuY3RvcihzY2FsZVR5cGUgJiYgcHJvcHNbc2NhbGVUeXBlLnByb3BdKSgpO1xuXG4gIGNvbnN0IHNjYWxlRnVuYyA9IHNjYWxlRnVuY3Rvci5kb21haW4oZGltZW5zaW9uRG9tYWluKS5yYW5nZShkaW1lbnNpb25SYW5nZSk7XG5cbiAgaWYgKHR5cGVvZiBvblNldCA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHByb3BzW29uU2V0LnByb3BzXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHByb3BzW29uU2V0LnByb3BzXShzY2FsZUZ1bmMuZG9tYWluKCkpO1xuICB9XG4gIHRoaXMuX3NldERpbWVuc2lvblN0YXRlKGtleSwge3NjYWxlRnVuY30pO1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemVSZXN1bHQocmVzdWx0OiB7aGV4YWdvbnM/OyBsYXllckRhdGE/fSA9IHt9KSB7XG4gIC8vIHN1cHBvcnQgcHJldmlvdXMgaGV4YWdvbkFnZ3JlZ2F0b3IgQVBJXG4gIGlmIChyZXN1bHQuaGV4YWdvbnMpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7ZGF0YTogcmVzdWx0LmhleGFnb25zfSwgcmVzdWx0KTtcbiAgfSBlbHNlIGlmIChyZXN1bHQubGF5ZXJEYXRhKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe2RhdGE6IHJlc3VsdC5sYXllckRhdGF9LCByZXN1bHQpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEFnZ3JlZ2F0ZWREYXRhKFxuICB0aGlzOiBDUFVBZ2dyZWdhdG9yLFxuICBzdGVwLFxuICBwcm9wcyxcbiAgYWdncmVnYXRpb24sXG4gIGFnZ3JlZ2F0aW9uUGFyYW1zXG4pIHtcbiAgY29uc3Qge1xuICAgIHRyaWdnZXJzOiB7YWdncmVnYXRvcjogYWdncn1cbiAgfSA9IHN0ZXA7XG4gIGNvbnN0IGFnZ3JlZ2F0b3IgPSBwcm9wc1thZ2dyLnByb3BdO1xuXG4gIC8vIHJlc3VsdCBzaG91bGQgY29udGFpbiBhIGRhdGEgYXJyYXkgYW5kIG90aGVyIHByb3BzXG4gIC8vIHJlc3VsdCA9IHtkYXRhOiBbXSwgLi4ub3RoZXIgcHJvcHN9XG4gIGNvbnN0IHJlc3VsdCA9IGFnZ3JlZ2F0b3IocHJvcHMsIGFnZ3JlZ2F0aW9uUGFyYW1zKTtcbiAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgbGF5ZXJEYXRhOiBub3JtYWxpemVSZXN1bHQocmVzdWx0KVxuICB9KTtcbn1cblxuZXhwb3J0IGNvbnN0IGRlZmF1bHRBZ2dyZWdhdGlvbjogQWdncmVnYXRpb25UeXBlID0ge1xuICBrZXk6ICdwb3NpdGlvbicsXG4gIHVwZGF0ZVN0ZXBzOiBbXG4gICAge1xuICAgICAga2V5OiAnYWdncmVnYXRlJyxcbiAgICAgIHRyaWdnZXJzOiB7XG4gICAgICAgIGNlbGxTaXplOiB7XG4gICAgICAgICAgcHJvcDogJ2NlbGxTaXplJ1xuICAgICAgICB9LFxuICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgIHByb3A6ICdnZXRQb3NpdGlvbicsXG4gICAgICAgICAgdXBkYXRlVHJpZ2dlcjogJ2dldFBvc2l0aW9uJ1xuICAgICAgICB9LFxuICAgICAgICBhZ2dyZWdhdG9yOiB7XG4gICAgICAgICAgcHJvcDogJ2dyaWRBZ2dyZWdhdG9yJ1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdXBkYXRlcjogZ2V0QWdncmVnYXRlZERhdGFcbiAgICB9XG4gIF1cbn07XG5cbmZ1bmN0aW9uIGdldFN1YkxheWVyQWNjZXNzb3IoZGltZW5zaW9uU3RhdGUsIGRpbWVuc2lvbiwgbGF5ZXJQcm9wcykge1xuICByZXR1cm4gY2VsbCA9PiB7XG4gICAgY29uc3Qge3NvcnRlZEJpbnMsIHNjYWxlRnVuY30gPSBkaW1lbnNpb25TdGF0ZTtcbiAgICBjb25zdCBiaW4gPSBzb3J0ZWRCaW5zLmJpbk1hcFtjZWxsLmluZGV4XTtcblxuICAgIGlmIChiaW4gJiYgYmluLmNvdW50cyA9PT0gMCkge1xuICAgICAgLy8gbm8gcG9pbnRzIGxlZnQgaW4gYmluIGFmdGVyIGZpbHRlcmluZ1xuICAgICAgcmV0dXJuIGRpbWVuc2lvbi5udWxsVmFsdWU7XG4gICAgfVxuXG4gICAgY29uc3QgY3YgPSBiaW4gJiYgYmluLnZhbHVlO1xuICAgIGNvbnN0IGRvbWFpbiA9IHNjYWxlRnVuYy5kb21haW4oKTtcblxuICAgIGNvbnN0IGlzVmFsdWVJbkRvbWFpbiA9IGN2ID49IGRvbWFpblswXSAmJiBjdiA8PSBkb21haW5bZG9tYWluLmxlbmd0aCAtIDFdO1xuXG4gICAgLy8gaWYgY2VsbCB2YWx1ZSBpcyBvdXRzaWRlIGRvbWFpbiwgc2V0IGFscGhhIHRvIDBcbiAgICByZXR1cm4gaXNWYWx1ZUluRG9tYWluID8gc2NhbGVGdW5jKGN2KSA6IGRpbWVuc2lvbi5udWxsVmFsdWU7XG4gIH07XG59XG5cbmV4cG9ydCBjb25zdCBkZWZhdWx0Q29sb3JEaW1lbnNpb246IERpbWVuc2lvblR5cGU8UkdCQUNvbG9yPiA9IHtcbiAga2V5OiAnZmlsbENvbG9yJyxcbiAgYWNjZXNzb3I6ICdnZXRGaWxsQ29sb3InLFxuICBnZXRQaWNraW5nSW5mbzogKGRpbWVuc2lvblN0YXRlLCBjZWxsKSA9PiB7XG4gICAgaWYgKCFjZWxsKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGNvbnN0IHtzb3J0ZWRCaW5zfSA9IGRpbWVuc2lvblN0YXRlO1xuICAgIGNvbnN0IGNvbG9yVmFsdWUgPSBzb3J0ZWRCaW5zLmJpbk1hcFtjZWxsLmluZGV4XSAmJiBzb3J0ZWRCaW5zLmJpbk1hcFtjZWxsLmluZGV4XS52YWx1ZTtcbiAgICByZXR1cm4ge2NvbG9yVmFsdWV9O1xuICB9LFxuICBudWxsVmFsdWU6IFswLCAwLCAwLCAwXSxcbiAgdXBkYXRlU3RlcHM6IFtcbiAgICB7XG4gICAgICBrZXk6ICdnZXRWYWx1ZScsXG4gICAgICB0cmlnZ2Vyczoge1xuICAgICAgICB2YWx1ZToge1xuICAgICAgICAgIHByb3A6ICdnZXRDb2xvclZhbHVlJyxcbiAgICAgICAgICB1cGRhdGVUcmlnZ2VyOiAnZ2V0Q29sb3JWYWx1ZSdcbiAgICAgICAgfSxcbiAgICAgICAgd2VpZ2h0OiB7XG4gICAgICAgICAgcHJvcDogJ2dldENvbG9yV2VpZ2h0JyxcbiAgICAgICAgICB1cGRhdGVUcmlnZ2VyOiAnZ2V0Q29sb3JXZWlnaHQnXG4gICAgICAgIH0sXG4gICAgICAgIGFnZ3JlZ2F0aW9uOiB7XG4gICAgICAgICAgcHJvcDogJ2NvbG9yQWdncmVnYXRpb24nXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB1cGRhdGVyOiBnZXRHZXRWYWx1ZVxuICAgIH0sXG4gICAge1xuICAgICAga2V5OiAnZ2V0QmlucycsXG4gICAgICB0cmlnZ2Vyczoge1xuICAgICAgICBfZmlsdGVyRGF0YToge1xuICAgICAgICAgIHByb3A6ICdfZmlsdGVyRGF0YScsXG4gICAgICAgICAgdXBkYXRlVHJpZ2dlcjogJ19maWx0ZXJEYXRhJ1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdXBkYXRlcjogZ2V0RGltZW5zaW9uU29ydGVkQmluc1xuICAgIH0sXG4gICAge1xuICAgICAga2V5OiAnZ2V0RG9tYWluJyxcbiAgICAgIHRyaWdnZXJzOiB7XG4gICAgICAgIGxvd2VyUGVyY2VudGlsZToge1xuICAgICAgICAgIHByb3A6ICdsb3dlclBlcmNlbnRpbGUnXG4gICAgICAgIH0sXG4gICAgICAgIHVwcGVyUGVyY2VudGlsZToge1xuICAgICAgICAgIHByb3A6ICd1cHBlclBlcmNlbnRpbGUnXG4gICAgICAgIH0sXG4gICAgICAgIHNjYWxlVHlwZToge3Byb3A6ICdjb2xvclNjYWxlVHlwZSd9XG4gICAgICB9LFxuICAgICAgdXBkYXRlcjogZ2V0RGltZW5zaW9uVmFsdWVEb21haW5cbiAgICB9LFxuICAgIHtcbiAgICAgIGtleTogJ2dldFNjYWxlRnVuYycsXG4gICAgICB0cmlnZ2Vyczoge1xuICAgICAgICBkb21haW46IHtwcm9wOiAnY29sb3JEb21haW4nfSxcbiAgICAgICAgcmFuZ2U6IHtwcm9wOiAnY29sb3JSYW5nZSd9LFxuICAgICAgICBzY2FsZVR5cGU6IHtwcm9wOiAnY29sb3JTY2FsZVR5cGUnfVxuICAgICAgfSxcbiAgICAgIG9uU2V0OiB7XG4gICAgICAgIHByb3BzOiAnb25TZXRDb2xvckRvbWFpbidcbiAgICAgIH0sXG4gICAgICB1cGRhdGVyOiBnZXREaW1lbnNpb25TY2FsZVxuICAgIH1cbiAgXSxcbiAgZ2V0U3ViTGF5ZXJBY2Nlc3NvclxufTtcblxuZXhwb3J0IGNvbnN0IGRlZmF1bHRFbGV2YXRpb25EaW1lbnNpb246IERpbWVuc2lvblR5cGU8bnVtYmVyPiA9IHtcbiAga2V5OiAnZWxldmF0aW9uJyxcbiAgYWNjZXNzb3I6ICdnZXRFbGV2YXRpb24nLFxuICBnZXRQaWNraW5nSW5mbzogKGRpbWVuc2lvblN0YXRlLCBjZWxsKSA9PiB7XG4gICAgaWYgKCFjZWxsKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGNvbnN0IHtzb3J0ZWRCaW5zfSA9IGRpbWVuc2lvblN0YXRlO1xuICAgIGNvbnN0IGVsZXZhdGlvblZhbHVlID0gc29ydGVkQmlucy5iaW5NYXBbY2VsbC5pbmRleF0gJiYgc29ydGVkQmlucy5iaW5NYXBbY2VsbC5pbmRleF0udmFsdWU7XG4gICAgcmV0dXJuIHtlbGV2YXRpb25WYWx1ZX07XG4gIH0sXG4gIG51bGxWYWx1ZTogLTEsXG4gIHVwZGF0ZVN0ZXBzOiBbXG4gICAge1xuICAgICAga2V5OiAnZ2V0VmFsdWUnLFxuICAgICAgdHJpZ2dlcnM6IHtcbiAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICBwcm9wOiAnZ2V0RWxldmF0aW9uVmFsdWUnLFxuICAgICAgICAgIHVwZGF0ZVRyaWdnZXI6ICdnZXRFbGV2YXRpb25WYWx1ZSdcbiAgICAgICAgfSxcbiAgICAgICAgd2VpZ2h0OiB7XG4gICAgICAgICAgcHJvcDogJ2dldEVsZXZhdGlvbldlaWdodCcsXG4gICAgICAgICAgdXBkYXRlVHJpZ2dlcjogJ2dldEVsZXZhdGlvbldlaWdodCdcbiAgICAgICAgfSxcbiAgICAgICAgYWdncmVnYXRpb246IHtcbiAgICAgICAgICBwcm9wOiAnZWxldmF0aW9uQWdncmVnYXRpb24nXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB1cGRhdGVyOiBnZXRHZXRWYWx1ZVxuICAgIH0sXG4gICAge1xuICAgICAga2V5OiAnZ2V0QmlucycsXG4gICAgICB0cmlnZ2Vyczoge1xuICAgICAgICBfZmlsdGVyRGF0YToge1xuICAgICAgICAgIHByb3A6ICdfZmlsdGVyRGF0YScsXG4gICAgICAgICAgdXBkYXRlVHJpZ2dlcjogJ19maWx0ZXJEYXRhJ1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdXBkYXRlcjogZ2V0RGltZW5zaW9uU29ydGVkQmluc1xuICAgIH0sXG4gICAge1xuICAgICAga2V5OiAnZ2V0RG9tYWluJyxcbiAgICAgIHRyaWdnZXJzOiB7XG4gICAgICAgIGxvd2VyUGVyY2VudGlsZToge1xuICAgICAgICAgIHByb3A6ICdlbGV2YXRpb25Mb3dlclBlcmNlbnRpbGUnXG4gICAgICAgIH0sXG4gICAgICAgIHVwcGVyUGVyY2VudGlsZToge1xuICAgICAgICAgIHByb3A6ICdlbGV2YXRpb25VcHBlclBlcmNlbnRpbGUnXG4gICAgICAgIH0sXG4gICAgICAgIHNjYWxlVHlwZToge3Byb3A6ICdlbGV2YXRpb25TY2FsZVR5cGUnfVxuICAgICAgfSxcbiAgICAgIHVwZGF0ZXI6IGdldERpbWVuc2lvblZhbHVlRG9tYWluXG4gICAgfSxcbiAgICB7XG4gICAgICBrZXk6ICdnZXRTY2FsZUZ1bmMnLFxuICAgICAgdHJpZ2dlcnM6IHtcbiAgICAgICAgZG9tYWluOiB7cHJvcDogJ2VsZXZhdGlvbkRvbWFpbid9LFxuICAgICAgICByYW5nZToge3Byb3A6ICdlbGV2YXRpb25SYW5nZSd9LFxuICAgICAgICBzY2FsZVR5cGU6IHtwcm9wOiAnZWxldmF0aW9uU2NhbGVUeXBlJ31cbiAgICAgIH0sXG4gICAgICBvblNldDoge1xuICAgICAgICBwcm9wczogJ29uU2V0RWxldmF0aW9uRG9tYWluJ1xuICAgICAgfSxcbiAgICAgIHVwZGF0ZXI6IGdldERpbWVuc2lvblNjYWxlXG4gICAgfVxuICBdLFxuICBnZXRTdWJMYXllckFjY2Vzc29yXG59O1xuXG5leHBvcnQgY29uc3QgZGVmYXVsdERpbWVuc2lvbnMgPSBbZGVmYXVsdENvbG9yRGltZW5zaW9uLCBkZWZhdWx0RWxldmF0aW9uRGltZW5zaW9uXTtcblxuZXhwb3J0IHR5cGUgQ1BVQWdncmVnYXRvclN0YXRlID0ge2xheWVyRGF0YToge2RhdGE/fTsgZGltZW5zaW9uczoge307IGdlb0pTT04/OyBjbHVzdGVyQnVpbGRlcj99O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDUFVBZ2dyZWdhdG9yIHtcbiAgc3RhdGljIGdldERpbWVuc2lvblNjYWxlOiBhbnk7XG4gIHN0YXRlOiBDUFVBZ2dyZWdhdG9yU3RhdGU7XG4gIGRpbWVuc2lvblVwZGF0ZXJzOiB7W2tleTogc3RyaW5nXTogRGltZW5zaW9uVHlwZX07XG4gIGFnZ3JlZ2F0aW9uVXBkYXRlcjogQWdncmVnYXRpb25UeXBlO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIG9wdHM6IHtcbiAgICAgIGluaXRpYWxTdGF0ZT86IENQVUFnZ3JlZ2F0b3JTdGF0ZTtcbiAgICAgIGRpbWVuc2lvbnM/OiBEaW1lbnNpb25UeXBlW107XG4gICAgICBhZ2dyZWdhdGlvbj86IEFnZ3JlZ2F0aW9uVHlwZTtcbiAgICB9ID0ge31cbiAgKSB7XG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGxheWVyRGF0YToge30sXG4gICAgICBkaW1lbnNpb25zOiB7XG4gICAgICAgIC8vIGNvbG9yOiB7XG4gICAgICAgIC8vICAgZ2V0VmFsdWU6IG51bGwsXG4gICAgICAgIC8vICAgZG9tYWluOiBudWxsLFxuICAgICAgICAvLyAgIHNvcnRlZEJpbnM6IG51bGwsXG4gICAgICAgIC8vICAgc2NhbGVGdW5jOiBub3BcbiAgICAgICAgLy8gfSxcbiAgICAgICAgLy8gZWxldmF0aW9uOiB7XG4gICAgICAgIC8vICAgZ2V0VmFsdWU6IG51bGwsXG4gICAgICAgIC8vICAgZG9tYWluOiBudWxsLFxuICAgICAgICAvLyAgIHNvcnRlZEJpbnM6IG51bGwsXG4gICAgICAgIC8vICAgc2NhbGVGdW5jOiBub3BcbiAgICAgICAgLy8gfVxuICAgICAgfSxcbiAgICAgIC4uLm9wdHMuaW5pdGlhbFN0YXRlXG4gICAgfTtcblxuICAgIHRoaXMuZGltZW5zaW9uVXBkYXRlcnMgPSB7fTtcbiAgICB0aGlzLmFnZ3JlZ2F0aW9uVXBkYXRlciA9IG9wdHMuYWdncmVnYXRpb24gfHwgZGVmYXVsdEFnZ3JlZ2F0aW9uO1xuXG4gICAgdGhpcy5fYWRkRGltZW5zaW9uKG9wdHMuZGltZW5zaW9ucyB8fCBkZWZhdWx0RGltZW5zaW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZGVmYXVsdERpbWVuc2lvbnMoKSB7XG4gICAgcmV0dXJuIGRlZmF1bHREaW1lbnNpb25zO1xuICB9XG5cbiAgdXBkYXRlQWxsRGltZW5zaW9ucyhwcm9wcykge1xuICAgIGxldCBkaW1lbnNpb25DaGFuZ2VzOiBCaW5kZWRVcGRhdGVyVHlwZVtdID0gW107XG4gICAgLy8gdXBkYXRlIGFsbCBkaW1lbnNpb25zXG4gICAgZm9yIChjb25zdCBkaW0gaW4gdGhpcy5kaW1lbnNpb25VcGRhdGVycykge1xuICAgICAgY29uc3QgdXBkYXRlcnMgPSB0aGlzLl9hY2N1bXVsYXRlVXBkYXRlcnMoMCwgcHJvcHMsIHRoaXMuZGltZW5zaW9uVXBkYXRlcnNbZGltXSk7XG4gICAgICBkaW1lbnNpb25DaGFuZ2VzID0gZGltZW5zaW9uQ2hhbmdlcy5jb25jYXQodXBkYXRlcnMpO1xuICAgIH1cblxuICAgIGRpbWVuc2lvbkNoYW5nZXMuZm9yRWFjaChmID0+IHR5cGVvZiBmID09PSAnZnVuY3Rpb24nICYmIGYoKSk7XG4gIH1cblxuICB1cGRhdGVBZ2dyZWdhdGlvbihwcm9wcywgYWdncmVnYXRpb25QYXJhbXMpIHtcbiAgICBjb25zdCB1cGRhdGVycyA9IHRoaXMuX2FjY3VtdWxhdGVVcGRhdGVycygwLCBwcm9wcywgdGhpcy5hZ2dyZWdhdGlvblVwZGF0ZXIpO1xuICAgIHVwZGF0ZXJzLmZvckVhY2goZiA9PiB0eXBlb2YgZiA9PT0gJ2Z1bmN0aW9uJyAmJiBmKGFnZ3JlZ2F0aW9uUGFyYW1zKSk7XG4gIH1cblxuICB1cGRhdGVTdGF0ZShvcHRzLCBhZ2dyZWdhdGlvblBhcmFtcykge1xuICAgIGNvbnN0IHtvbGRQcm9wcywgcHJvcHMsIGNoYW5nZUZsYWdzfSA9IG9wdHM7XG4gICAgbGV0IGRpbWVuc2lvbkNoYW5nZXM6IEJpbmRlZFVwZGF0ZXJUeXBlW10gPSBbXTtcblxuICAgIGlmIChjaGFuZ2VGbGFncy5kYXRhQ2hhbmdlZCkge1xuICAgICAgLy8gaWYgZGF0YSBjaGFuZ2VkIHVwZGF0ZSBldmVyeXRoaW5nXG4gICAgICB0aGlzLnVwZGF0ZUFnZ3JlZ2F0aW9uKHByb3BzLCBhZ2dyZWdhdGlvblBhcmFtcyk7XG4gICAgICB0aGlzLnVwZGF0ZUFsbERpbWVuc2lvbnMocHJvcHMpO1xuXG4gICAgICByZXR1cm4gdGhpcy5zdGF0ZTtcbiAgICB9XG5cbiAgICBjb25zdCBhZ2dyZWdhdGlvbkNoYW5nZXMgPSB0aGlzLl9nZXRBZ2dyZWdhdGlvbkNoYW5nZXMob2xkUHJvcHMsIHByb3BzLCBjaGFuZ2VGbGFncyk7XG5cbiAgICBpZiAoYWdncmVnYXRpb25DaGFuZ2VzICYmIGFnZ3JlZ2F0aW9uQ2hhbmdlcy5sZW5ndGgpIHtcbiAgICAgIC8vIGdldCBhZ2dyZWdhdGVkRGF0YVxuICAgICAgYWdncmVnYXRpb25DaGFuZ2VzLmZvckVhY2goZiA9PiB0eXBlb2YgZiA9PT0gJ2Z1bmN0aW9uJyAmJiBmKGFnZ3JlZ2F0aW9uUGFyYW1zKSk7XG4gICAgICB0aGlzLnVwZGF0ZUFsbERpbWVuc2lvbnMocHJvcHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBvbmx5IHVwZGF0ZSBkaW1lbnNpb25zXG4gICAgICBkaW1lbnNpb25DaGFuZ2VzID0gdGhpcy5fZ2V0RGltZW5zaW9uQ2hhbmdlcyhvbGRQcm9wcywgcHJvcHMsIGNoYW5nZUZsYWdzKSB8fCBbXTtcbiAgICAgIGRpbWVuc2lvbkNoYW5nZXMuZm9yRWFjaChmID0+IHR5cGVvZiBmID09PSAnZnVuY3Rpb24nICYmIGYoKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3RhdGU7XG4gIH1cblxuICAvLyBVcGRhdGUgcHJpdmF0ZSBzdGF0ZVxuICBzZXRTdGF0ZSh1cGRhdGVPYmplY3QpIHtcbiAgICB0aGlzLnN0YXRlID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5zdGF0ZSwgdXBkYXRlT2JqZWN0KTtcbiAgfVxuXG4gIC8vIFVwZGF0ZSBwcml2YXRlIHN0YXRlLmRpbWVuc2lvbnNcbiAgX3NldERpbWVuc2lvblN0YXRlKGtleSwgdXBkYXRlT2JqZWN0KSB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBkaW1lbnNpb25zOiBPYmplY3QuYXNzaWduKHt9LCB0aGlzLnN0YXRlLmRpbWVuc2lvbnMsIHtcbiAgICAgICAgW2tleV06IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuc3RhdGUuZGltZW5zaW9uc1trZXldLCB1cGRhdGVPYmplY3QpXG4gICAgICB9KVxuICAgIH0pO1xuICB9XG5cbiAgX2FkZEFnZ3JlZ2F0aW9uKGFnZ3JlZ2F0aW9uOiBBZ2dyZWdhdGlvblR5cGUpIHtcbiAgICB0aGlzLmFnZ3JlZ2F0aW9uVXBkYXRlciA9IGFnZ3JlZ2F0aW9uO1xuICB9XG5cbiAgX2FkZERpbWVuc2lvbihkaW1lbnNpb25zOiBEaW1lbnNpb25UeXBlW10gPSBbXSkge1xuICAgIGRpbWVuc2lvbnMuZm9yRWFjaChkaW1lbnNpb24gPT4ge1xuICAgICAgY29uc3Qge2tleX0gPSBkaW1lbnNpb247XG4gICAgICB0aGlzLmRpbWVuc2lvblVwZGF0ZXJzW2tleV0gPSBkaW1lbnNpb247XG4gICAgfSk7XG4gIH1cblxuICBfbmVlZFVwZGF0ZVN0ZXAoXG4gICAgZGltZW5zaW9uU3RlcDogVXBkYXRlU3RlcHNUeXBlIHwgQWdncmVnYXRpb25VcGRhdGVTdGVwc1R5cGUsXG4gICAgb2xkUHJvcHMsXG4gICAgcHJvcHMsXG4gICAgY2hhbmdlRmxhZ3NcbiAgKSB7XG4gICAgLy8gd2hldGhlciBuZWVkIHRvIHVwZGF0ZSBjdXJyZW50IGRpbWVuc2lvbiBzdGVwXG4gICAgLy8gZGltZW5zaW9uIHN0ZXAgaXMgdGhlIHZhbHVlLCBkb21haW4sIHNjYWxlRnVuY3Rpb24gb2YgZWFjaCBkaW1lbnNpb25cbiAgICAvLyBlYWNoIHN0ZXAgaXMgYW4gb2JqZWN0IHdpdGggcHJvcGVydGllcyBsaW5rcyB0byBsYXllciBwcm9wIGFuZCB3aGV0aGVyIHRoZSBwcm9wIGlzXG4gICAgLy8gY29udHJvbGxlZCBieSB1cGRhdGVUcmlnZ2Vyc1xuICAgIHJldHVybiBPYmplY3QudmFsdWVzKGRpbWVuc2lvblN0ZXAudHJpZ2dlcnMpLnNvbWUoaXRlbSA9PiB7XG4gICAgICBpZiAoaXRlbS51cGRhdGVUcmlnZ2VyKSB7XG4gICAgICAgIC8vIGNoZWNrIGJhc2VkIG9uIHVwZGF0ZVRyaWdnZXJzIGNoYW5nZSBmaXJzdFxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIGNoYW5nZUZsYWdzLnVwZGF0ZVRyaWdnZXJzQ2hhbmdlZCAmJlxuICAgICAgICAgIChjaGFuZ2VGbGFncy51cGRhdGVUcmlnZ2Vyc0NoYW5nZWQuYWxsIHx8XG4gICAgICAgICAgICBjaGFuZ2VGbGFncy51cGRhdGVUcmlnZ2Vyc0NoYW5nZWRbaXRlbS51cGRhdGVUcmlnZ2VyXSlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIC8vIGZhbGxiYWNrIHRvIGRpcmVjdCBjb21wYXJpc29uXG4gICAgICByZXR1cm4gb2xkUHJvcHNbaXRlbS5wcm9wXSAhPT0gcHJvcHNbaXRlbS5wcm9wXTtcbiAgICB9KTtcbiAgfVxuXG4gIF9hY2N1bXVsYXRlVXBkYXRlcnM8VXBkYXRlck9iamVjdFR5cGUgZXh0ZW5kcyBEaW1lbnNpb25UeXBlIHwgQWdncmVnYXRpb25UeXBlPihcbiAgICBzdGVwLFxuICAgIHByb3BzLFxuICAgIGRpbWVuc2lvbjogVXBkYXRlck9iamVjdFR5cGVcbiAgKSB7XG4gICAgdHlwZSBMb2NhbFVwZGF0ZXJUeXBlID0gVXBkYXRlck9iamVjdFR5cGUgZXh0ZW5kcyBEaW1lbnNpb25UeXBlXG4gICAgICA/IEJpbmRlZFVwZGF0ZXJUeXBlXG4gICAgICA6IEJpbmRlZEFnZ3JlZ2F0ZWRVcGRhdGVyVHlwZTtcbiAgICBjb25zdCB1cGRhdGVyczogTG9jYWxVcGRhdGVyVHlwZVtdID0gW107XG4gICAgZm9yIChsZXQgaSA9IHN0ZXA7IGkgPCBkaW1lbnNpb24udXBkYXRlU3RlcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHVwZGF0ZXIgPSBkaW1lbnNpb24udXBkYXRlU3RlcHNbaV0udXBkYXRlcjtcbiAgICAgIGlmICh0eXBlb2YgdXBkYXRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB1cGRhdGVycy5wdXNoKFxuICAgICAgICAgIHVwZGF0ZXIuYmluZCh0aGlzLCBkaW1lbnNpb24udXBkYXRlU3RlcHNbaV0sIHByb3BzLCBkaW1lbnNpb24pIGFzIExvY2FsVXBkYXRlclR5cGVcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdXBkYXRlcnM7XG4gIH1cblxuICBfZ2V0QWxsVXBkYXRlcnM8VXBkYXRlck9iamVjdFR5cGUgZXh0ZW5kcyBEaW1lbnNpb25UeXBlIHwgQWdncmVnYXRpb25UeXBlPihcbiAgICBkaW1lbnNpb246IFVwZGF0ZXJPYmplY3RUeXBlLFxuICAgIG9sZFByb3BzLFxuICAgIHByb3BzLFxuICAgIGNoYW5nZUZsYWdzXG4gICkge1xuICAgIHR5cGUgTG9jYWxVcGRhdGVyVHlwZSA9IFVwZGF0ZXJPYmplY3RUeXBlIGV4dGVuZHMgRGltZW5zaW9uVHlwZVxuICAgICAgPyBCaW5kZWRVcGRhdGVyVHlwZVxuICAgICAgOiBCaW5kZWRBZ2dyZWdhdGVkVXBkYXRlclR5cGU7XG4gICAgbGV0IHVwZGF0ZXJzOiBMb2NhbFVwZGF0ZXJUeXBlW10gPSBbXTtcbiAgICBjb25zdCBuZWVkVXBkYXRlU3RlcCA9IGRpbWVuc2lvbi51cGRhdGVTdGVwcy5maW5kSW5kZXgoc3RlcCA9PlxuICAgICAgdGhpcy5fbmVlZFVwZGF0ZVN0ZXAoc3RlcCwgb2xkUHJvcHMsIHByb3BzLCBjaGFuZ2VGbGFncylcbiAgICApO1xuXG4gICAgaWYgKG5lZWRVcGRhdGVTdGVwID4gLTEpIHtcbiAgICAgIHVwZGF0ZXJzID0gdXBkYXRlcnMuY29uY2F0KHRoaXMuX2FjY3VtdWxhdGVVcGRhdGVycyhuZWVkVXBkYXRlU3RlcCwgcHJvcHMsIGRpbWVuc2lvbikpO1xuICAgIH1cblxuICAgIHJldHVybiB1cGRhdGVycztcbiAgfVxuXG4gIF9nZXRBZ2dyZWdhdGlvbkNoYW5nZXMob2xkUHJvcHMsIHByb3BzLCBjaGFuZ2VGbGFncykge1xuICAgIGNvbnN0IHVwZGF0ZXJzID0gdGhpcy5fZ2V0QWxsVXBkYXRlcnModGhpcy5hZ2dyZWdhdGlvblVwZGF0ZXIsIG9sZFByb3BzLCBwcm9wcywgY2hhbmdlRmxhZ3MpO1xuICAgIHJldHVybiB1cGRhdGVycy5sZW5ndGggPyB1cGRhdGVycyA6IG51bGw7XG4gIH1cblxuICBfZ2V0RGltZW5zaW9uQ2hhbmdlcyhvbGRQcm9wcywgcHJvcHMsIGNoYW5nZUZsYWdzKSB7XG4gICAgbGV0IHVwZGF0ZXJzOiBCaW5kZWRVcGRhdGVyVHlwZVtdID0gW107XG5cbiAgICAvLyBnZXQgZGltZW5zaW9uIHRvIGJlIHVwZGF0ZWRcbiAgICBmb3IgKGNvbnN0IGtleSBpbiB0aGlzLmRpbWVuc2lvblVwZGF0ZXJzKSB7XG4gICAgICAvLyByZXR1cm4gdGhlIGZpcnN0IHRyaWdnZXJlZCB1cGRhdGVyIGZvciBlYWNoIGRpbWVuc2lvblxuICAgICAgY29uc3QgZGltZW5zaW9uID0gdGhpcy5kaW1lbnNpb25VcGRhdGVyc1trZXldO1xuICAgICAgY29uc3QgZGltZW5zaW9uVXBkYXRlcnMgPSB0aGlzLl9nZXRBbGxVcGRhdGVycyhkaW1lbnNpb24sIG9sZFByb3BzLCBwcm9wcywgY2hhbmdlRmxhZ3MpO1xuICAgICAgdXBkYXRlcnMgPSB1cGRhdGVycy5jb25jYXQoZGltZW5zaW9uVXBkYXRlcnMpO1xuICAgIH1cblxuICAgIHJldHVybiB1cGRhdGVycy5sZW5ndGggPyB1cGRhdGVycyA6IG51bGw7XG4gIH1cblxuICBnZXRVcGRhdGVUcmlnZ2Vycyhwcm9wcykge1xuICAgIGNvbnN0IF91cGRhdGVUcmlnZ2VycyA9IHByb3BzLnVwZGF0ZVRyaWdnZXJzIHx8IHt9O1xuICAgIGNvbnN0IHVwZGF0ZVRyaWdnZXJzID0ge307XG5cbiAgICBmb3IgKGNvbnN0IGtleSBpbiB0aGlzLmRpbWVuc2lvblVwZGF0ZXJzKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGFjY2Vzc29yLFxuICAgICAgICB1cGRhdGVTdGVwc1xuICAgICAgfToge2FjY2Vzc29yOyB1cGRhdGVTdGVwczogVXBkYXRlU3RlcHNUeXBlW119ID0gdGhpcy5kaW1lbnNpb25VcGRhdGVyc1trZXldO1xuICAgICAgLy8gZm9sZCBkaW1lbnNpb24gdHJpZ2dlcnMgaW50byBlYWNoIGFjY2Vzc29yXG4gICAgICB1cGRhdGVUcmlnZ2Vyc1thY2Nlc3Nvcl0gPSB7fTtcblxuICAgICAgdXBkYXRlU3RlcHMuZm9yRWFjaChzdGVwID0+IHtcbiAgICAgICAgT2JqZWN0LnZhbHVlcyhzdGVwLnRyaWdnZXJzIHx8IFtdKS5mb3JFYWNoKCh7cHJvcCwgdXBkYXRlVHJpZ2dlcn0pID0+IHtcbiAgICAgICAgICBpZiAodXBkYXRlVHJpZ2dlcikge1xuICAgICAgICAgICAgLy8gaWYgcHJvcCBpcyBiYXNlZCBvbiB1cGRhdGVUcmlnZ2VyIGUuZy4gZ2V0Q29sb3JWYWx1ZSwgZ2V0Q29sb3JXZWlnaHRcbiAgICAgICAgICAgIC8vIGFuZCB1cGRhdGVUcmlnZ2VycyBpcyBwYXNzZWQgaW4gZnJvbSBsYXllciBwcm9wXG4gICAgICAgICAgICAvLyBmb2xkIHRoZSB1cGRhdGVUcmlnZ2VycyBpbnRvIGFjY2Vzc29yXG4gICAgICAgICAgICBjb25zdCBmcm9tUHJvcCA9IF91cGRhdGVUcmlnZ2Vyc1t1cGRhdGVUcmlnZ2VyXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZnJvbVByb3AgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KGZyb21Qcm9wKSkge1xuICAgICAgICAgICAgICAvLyBpZiB1cGRhdGVUcmlnZ2VyIGlzIGFuIG9iamVjdCBzcHJlYWQgaXRcbiAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih1cGRhdGVUcmlnZ2Vyc1thY2Nlc3Nvcl0sIGZyb21Qcm9wKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZnJvbVByb3AgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICB1cGRhdGVUcmlnZ2Vyc1thY2Nlc3Nvcl1bcHJvcF0gPSBmcm9tUHJvcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gaWYgcHJvcCBpcyBub3QgYmFzZWQgb24gdXBkYXRlVHJpZ2dlclxuICAgICAgICAgICAgdXBkYXRlVHJpZ2dlcnNbYWNjZXNzb3JdW3Byb3BdID0gcHJvcHNbcHJvcF07XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB1cGRhdGVUcmlnZ2VycztcbiAgfVxuXG4gIGdldFBpY2tpbmdJbmZvKHtpbmZvfSwgbGF5ZXJQcm9wcykge1xuICAgIGNvbnN0IGlzUGlja2VkID0gaW5mby5waWNrZWQgJiYgaW5mby5pbmRleCA+IC0xO1xuICAgIGxldCBvYmplY3QgPSBudWxsO1xuICAgIGNvbnN0IGNlbGwgPSBpc1BpY2tlZCA/IHRoaXMuc3RhdGUubGF5ZXJEYXRhLmRhdGFbaW5mby5pbmRleF0gOiBudWxsO1xuICAgIGlmIChjZWxsKSB7XG4gICAgICBsZXQgYmluSW5mbyA9IHt9O1xuICAgICAgZm9yIChjb25zdCBrZXkgaW4gdGhpcy5kaW1lbnNpb25VcGRhdGVycykge1xuICAgICAgICBjb25zdCB7Z2V0UGlja2luZ0luZm99ID0gdGhpcy5kaW1lbnNpb25VcGRhdGVyc1trZXldO1xuICAgICAgICBpZiAodHlwZW9mIGdldFBpY2tpbmdJbmZvID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgYmluSW5mbyA9IE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAgICB7fSxcbiAgICAgICAgICAgIGJpbkluZm8sXG4gICAgICAgICAgICBnZXRQaWNraW5nSW5mbyh0aGlzLnN0YXRlLmRpbWVuc2lvbnNba2V5XSwgY2VsbCwgbGF5ZXJQcm9wcylcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG9iamVjdCA9IE9iamVjdC5hc3NpZ24oYmluSW5mbywgY2VsbCwge1xuICAgICAgICBwb2ludHM6IGNlbGwuZmlsdGVyZWRQb2ludHMgfHwgY2VsbC5wb2ludHNcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIGFkZCBiaW4gIGFuZCAgdG8gaW5mb1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKGluZm8sIHtcbiAgICAgIHBpY2tlZDogQm9vbGVhbihvYmplY3QpLFxuICAgICAgLy8gb3ZlcnJpZGUgb2JqZWN0IHdpdGggcGlja2VkIGNlbGxcbiAgICAgIG9iamVjdFxuICAgIH0pO1xuICB9XG5cbiAgZ2V0QWNjZXNzb3IoZGltZW5zaW9uS2V5LCBsYXllclByb3BzKSB7XG4gICAgaWYgKCF0aGlzLmRpbWVuc2lvblVwZGF0ZXJzLmhhc093blByb3BlcnR5KGRpbWVuc2lvbktleSkpIHtcbiAgICAgIHJldHVybiBub3A7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmRpbWVuc2lvblVwZGF0ZXJzW2RpbWVuc2lvbktleV0uZ2V0U3ViTGF5ZXJBY2Nlc3NvcihcbiAgICAgIHRoaXMuc3RhdGUuZGltZW5zaW9uc1tkaW1lbnNpb25LZXldLFxuICAgICAgdGhpcy5kaW1lbnNpb25VcGRhdGVyc1tkaW1lbnNpb25LZXldLFxuICAgICAgbGF5ZXJQcm9wc1xuICAgICk7XG4gIH1cbn1cblxuQ1BVQWdncmVnYXRvci5nZXREaW1lbnNpb25TY2FsZSA9IGdldERpbWVuc2lvblNjYWxlO1xuIl19