// Copyright (c) 2022 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = exports.clusterAggregation = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _layers = require("@deck.gl/layers");

var _aggregationLayers = require("@deck.gl/aggregation-layers");

var _geoViewport = _interopRequireDefault(require("@mapbox/geo-viewport"));

var _cpuAggregator = _interopRequireWildcard(require("../layer-utils/cpu-aggregator"));

var _viewportMercatorProject = require("viewport-mercator-project");

var _d3Array = require("d3-array");

var _constants = require("@kepler.gl/constants");

var _clusterUtils = _interopRequireWildcard(require("../layer-utils/cluster-utils"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var defaultRadius = _constants.LAYER_VIS_CONFIGS.clusterRadius.defaultValue;
var defaultRadiusRange = _constants.LAYER_VIS_CONFIGS.clusterRadiusRange.defaultValue;

var defaultGetColorValue = function defaultGetColorValue(points) {
  return points.length;
};

var defaultGetRadiusValue = function defaultGetRadiusValue(cell) {
  return cell.filteredPoints ? cell.filteredPoints.length : cell.points.length;
};

function processGeoJSON(step, props, aggregation, _ref) {
  var viewport = _ref.viewport;
  var data = props.data,
      getPosition = props.getPosition,
      filterData = props.filterData;
  var geoJSON = (0, _clusterUtils.getGeoJSON)(data, getPosition, filterData);
  var clusterBuilder = new _clusterUtils["default"]();
  this.setState({
    geoJSON: geoJSON,
    clusterBuilder: clusterBuilder
  });
}

function getClusters(step, props, aggregation, _ref2) {
  var viewport = _ref2.viewport;
  var _this$state = this.state,
      geoJSON = _this$state.geoJSON,
      clusterBuilder = _this$state.clusterBuilder;
  var clusterRadius = props.clusterRadius,
      zoom = props.zoom,
      width = props.width,
      height = props.height;
  var longitude = viewport.longitude,
      latitude = viewport.latitude; // zoom needs to be an integer for the different map utils. Also helps with cache key.

  var bbox = _geoViewport["default"].bounds([longitude, latitude], zoom, [width, height]);

  var clusters = clusterBuilder.clustersAtZoom({
    bbox: bbox,
    clusterRadius: clusterRadius,
    geoJSON: geoJSON,
    zoom: zoom
  });
  this.setState({
    layerData: {
      data: clusters
    }
  });
}

function getSubLayerRadius(dimensionState, dimension, layerProps) {
  return function (cell) {
    var getRadiusValue = layerProps.getRadiusValue;
    var scaleFunc = dimensionState.scaleFunc;
    return scaleFunc(getRadiusValue(cell));
  };
}

var clusterAggregation = {
  key: 'position',
  updateSteps: [{
    key: 'geojson',
    triggers: {
      position: {
        prop: 'getPosition',
        updateTrigger: 'getPosition'
      },
      filterData: {
        prop: 'filterData',
        updateTrigger: 'filterData'
      }
    },
    updater: processGeoJSON
  }, {
    key: 'clustering',
    triggers: {
      clusterRadius: {
        prop: 'clusterRadius'
      },
      zoom: {
        prop: 'zoom'
      },
      width: {
        prop: 'width'
      },
      height: {
        prop: 'height'
      }
    },
    updater: getClusters
  }]
};
exports.clusterAggregation = clusterAggregation;

function getRadiusValueDomain(step, props, dimensionUpdater) {
  var key = dimensionUpdater.key;
  var getRadiusValue = props.getRadiusValue;
  var layerData = this.state.layerData;
  var valueDomain = [0, (0, _d3Array.max)(layerData.data, getRadiusValue)];

  this._setDimensionState(key, {
    valueDomain: valueDomain
  });
}

var clusterLayerDimensions = [_cpuAggregator.defaultColorDimension, {
  key: 'radius',
  accessor: 'getRadius',
  nullValue: 0,
  updateSteps: [{
    key: 'getDomain',
    triggers: {
      value: {
        prop: 'getRadiusValue',
        updateTrigger: 'getRadiusValue'
      }
    },
    updater: getRadiusValueDomain
  }, {
    key: 'getScaleFunc',
    triggers: {
      domain: {
        prop: 'radiusDomain'
      },
      range: {
        prop: 'radiusRange'
      },
      scaleType: {
        prop: 'radiusScaleType'
      }
    },
    updater: _cpuAggregator.getDimensionScale
  }],
  getSubLayerAccessor: getSubLayerRadius,
  getPickingInfo: function getPickingInfo(dimensionState, cell, layerProps) {
    var radiusValue = layerProps.getRadiusValue(cell);
    return {
      radiusValue: radiusValue
    };
  }
}];
var defaultProps = {
  clusterRadius: defaultRadius,
  colorDomain: null,
  colorRange: _constants.DEFAULT_COLOR_RANGE,
  colorScaleType: _constants.SCALE_TYPES.quantize,
  radiusScaleType: _constants.SCALE_TYPES.sqrt,
  radiusRange: defaultRadiusRange,
  getPosition: {
    type: 'accessor',
    value: function value(x) {
      return x.position;
    }
  },
  getColorValue: {
    type: 'accessor',
    value: defaultGetColorValue
  },
  getRadiusValue: {
    type: 'accessor',
    value: defaultGetRadiusValue
  }
};

var ClusterLayer = /*#__PURE__*/function (_AggregationLayer) {
  (0, _inherits2["default"])(ClusterLayer, _AggregationLayer);

  var _super = _createSuper(ClusterLayer);

  function ClusterLayer() {
    (0, _classCallCheck2["default"])(this, ClusterLayer);
    return _super.apply(this, arguments);
  }

  (0, _createClass2["default"])(ClusterLayer, [{
    key: "initializeState",
    value: function initializeState() {
      var cpuAggregator = new _cpuAggregator["default"]({
        aggregation: clusterAggregation,
        dimensions: clusterLayerDimensions
      });
      this.state = {
        cpuAggregator: cpuAggregator,
        aggregatorState: cpuAggregator.state
      };
      var attributeManager = this.getAttributeManager();
      attributeManager.add({
        positions: {
          size: 3,
          accessor: 'getPosition'
        }
      });
    }
  }, {
    key: "updateState",
    value: function updateState(_ref3) {
      var oldProps = _ref3.oldProps,
          props = _ref3.props,
          changeFlags = _ref3.changeFlags;
      this.setState({
        // make a copy of the internal state of cpuAggregator for testing
        aggregatorState: this.state.cpuAggregator.updateState({
          oldProps: oldProps,
          props: props,
          changeFlags: changeFlags
        }, {
          viewport: this.context.viewport,
          attributes: this.getAttributes(),
          numInstances: this.getNumInstances(props)
        })
      });
    }
  }, {
    key: "getPickingInfo",
    value: function getPickingInfo(_ref4) {
      var info = _ref4.info;
      return this.state.cpuAggregator.getPickingInfo({
        info: info
      }, this.props);
    }
  }, {
    key: "_getSublayerUpdateTriggers",
    value: function _getSublayerUpdateTriggers() {
      return this.state.cpuAggregator.getUpdateTriggers(this.props);
    }
  }, {
    key: "_getSubLayerAccessors",
    value: function _getSubLayerAccessors() {
      return {
        getRadius: this.state.cpuAggregator.getAccessor('radius', this.props),
        getFillColor: this.state.cpuAggregator.getAccessor('fillColor', this.props)
      };
    }
  }, {
    key: "renderLayers",
    value: function renderLayers() {
      // for subclassing, override this method to return
      // customized sub layer props
      var _this$props = this.props,
          id = _this$props.id,
          radiusScale = _this$props.radiusScale;
      var cpuAggregator = this.state.cpuAggregator; // base layer props

      var _this$props2 = this.props,
          visible = _this$props2.visible,
          opacity = _this$props2.opacity,
          pickable = _this$props2.pickable,
          autoHighlight = _this$props2.autoHighlight,
          highlightColor = _this$props2.highlightColor;

      var updateTriggers = this._getSublayerUpdateTriggers();

      var accessors = this._getSubLayerAccessors(); // @ts-expect-error


      var distanceScale = (0, _viewportMercatorProject.getDistanceScales)(this.context.viewport);
      var metersPerPixel = distanceScale.metersPerPixel[0]; // return props to the sublayer constructor

      return new _layers.ScatterplotLayer(_objectSpread({
        id: "".concat(id, "-cluster"),
        data: cpuAggregator.state.layerData.data,
        radiusScale: metersPerPixel * radiusScale,
        visible: visible,
        opacity: opacity,
        pickable: pickable,
        autoHighlight: autoHighlight,
        highlightColor: highlightColor,
        updateTriggers: updateTriggers,
        parameters: {
          depthMask: false
        }
      }, accessors));
    }
  }]);
  return ClusterLayer;
}(_aggregationLayers._AggregationLayer);

exports["default"] = ClusterLayer;
ClusterLayer.layerName = 'ClusterLayer';
ClusterLayer.defaultProps = defaultProps;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jbHVzdGVyLWxheWVyL2NsdXN0ZXItbGF5ZXIudHMiXSwibmFtZXMiOlsiZGVmYXVsdFJhZGl1cyIsIkxBWUVSX1ZJU19DT05GSUdTIiwiY2x1c3RlclJhZGl1cyIsImRlZmF1bHRWYWx1ZSIsImRlZmF1bHRSYWRpdXNSYW5nZSIsImNsdXN0ZXJSYWRpdXNSYW5nZSIsImRlZmF1bHRHZXRDb2xvclZhbHVlIiwicG9pbnRzIiwibGVuZ3RoIiwiZGVmYXVsdEdldFJhZGl1c1ZhbHVlIiwiY2VsbCIsImZpbHRlcmVkUG9pbnRzIiwicHJvY2Vzc0dlb0pTT04iLCJzdGVwIiwicHJvcHMiLCJhZ2dyZWdhdGlvbiIsInZpZXdwb3J0IiwiZGF0YSIsImdldFBvc2l0aW9uIiwiZmlsdGVyRGF0YSIsImdlb0pTT04iLCJjbHVzdGVyQnVpbGRlciIsIkNsdXN0ZXJCdWlsZGVyIiwic2V0U3RhdGUiLCJnZXRDbHVzdGVycyIsInN0YXRlIiwiem9vbSIsIndpZHRoIiwiaGVpZ2h0IiwibG9uZ2l0dWRlIiwibGF0aXR1ZGUiLCJiYm94IiwiZ2VvVmlld3BvcnQiLCJib3VuZHMiLCJjbHVzdGVycyIsImNsdXN0ZXJzQXRab29tIiwibGF5ZXJEYXRhIiwiZ2V0U3ViTGF5ZXJSYWRpdXMiLCJkaW1lbnNpb25TdGF0ZSIsImRpbWVuc2lvbiIsImxheWVyUHJvcHMiLCJnZXRSYWRpdXNWYWx1ZSIsInNjYWxlRnVuYyIsImNsdXN0ZXJBZ2dyZWdhdGlvbiIsImtleSIsInVwZGF0ZVN0ZXBzIiwidHJpZ2dlcnMiLCJwb3NpdGlvbiIsInByb3AiLCJ1cGRhdGVUcmlnZ2VyIiwidXBkYXRlciIsImdldFJhZGl1c1ZhbHVlRG9tYWluIiwiZGltZW5zaW9uVXBkYXRlciIsInZhbHVlRG9tYWluIiwiX3NldERpbWVuc2lvblN0YXRlIiwiY2x1c3RlckxheWVyRGltZW5zaW9ucyIsImRlZmF1bHRDb2xvckRpbWVuc2lvbiIsImFjY2Vzc29yIiwibnVsbFZhbHVlIiwidmFsdWUiLCJkb21haW4iLCJyYW5nZSIsInNjYWxlVHlwZSIsImdldERpbWVuc2lvblNjYWxlIiwiZ2V0U3ViTGF5ZXJBY2Nlc3NvciIsImdldFBpY2tpbmdJbmZvIiwicmFkaXVzVmFsdWUiLCJkZWZhdWx0UHJvcHMiLCJjb2xvckRvbWFpbiIsImNvbG9yUmFuZ2UiLCJERUZBVUxUX0NPTE9SX1JBTkdFIiwiY29sb3JTY2FsZVR5cGUiLCJTQ0FMRV9UWVBFUyIsInF1YW50aXplIiwicmFkaXVzU2NhbGVUeXBlIiwic3FydCIsInJhZGl1c1JhbmdlIiwidHlwZSIsIngiLCJnZXRDb2xvclZhbHVlIiwiQ2x1c3RlckxheWVyIiwiY3B1QWdncmVnYXRvciIsIkNQVUFnZ3JlZ2F0b3IiLCJkaW1lbnNpb25zIiwiYWdncmVnYXRvclN0YXRlIiwiYXR0cmlidXRlTWFuYWdlciIsImdldEF0dHJpYnV0ZU1hbmFnZXIiLCJhZGQiLCJwb3NpdGlvbnMiLCJzaXplIiwib2xkUHJvcHMiLCJjaGFuZ2VGbGFncyIsInVwZGF0ZVN0YXRlIiwiY29udGV4dCIsImF0dHJpYnV0ZXMiLCJnZXRBdHRyaWJ1dGVzIiwibnVtSW5zdGFuY2VzIiwiZ2V0TnVtSW5zdGFuY2VzIiwiaW5mbyIsImdldFVwZGF0ZVRyaWdnZXJzIiwiZ2V0UmFkaXVzIiwiZ2V0QWNjZXNzb3IiLCJnZXRGaWxsQ29sb3IiLCJpZCIsInJhZGl1c1NjYWxlIiwidmlzaWJsZSIsIm9wYWNpdHkiLCJwaWNrYWJsZSIsImF1dG9IaWdobGlnaHQiLCJoaWdobGlnaHRDb2xvciIsInVwZGF0ZVRyaWdnZXJzIiwiX2dldFN1YmxheWVyVXBkYXRlVHJpZ2dlcnMiLCJhY2Nlc3NvcnMiLCJfZ2V0U3ViTGF5ZXJBY2Nlc3NvcnMiLCJkaXN0YW5jZVNjYWxlIiwibWV0ZXJzUGVyUGl4ZWwiLCJTY2F0dGVycGxvdExheWVyIiwicGFyYW1ldGVycyIsImRlcHRoTWFzayIsIkFnZ3JlZ2F0aW9uTGF5ZXIiLCJsYXllck5hbWUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7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QUYvQjtBQUdMdUYsUUFBQUEsV0FBVyxFQUFFVyxjQUFjLEdBQUdYLFdBSHpCO0FBSUxDLFFBQUFBLE9BQU8sRUFBUEEsT0FKSztBQUtMQyxRQUFBQSxPQUFPLEVBQVBBLE9BTEs7QUFNTEMsUUFBQUEsUUFBUSxFQUFSQSxRQU5LO0FBT0xDLFFBQUFBLGFBQWEsRUFBYkEsYUFQSztBQVFMQyxRQUFBQSxjQUFjLEVBQWRBLGNBUks7QUFTTEMsUUFBQUEsY0FBYyxFQUFkQSxjQVRLO0FBVUxPLFFBQUFBLFVBQVUsRUFBRTtBQUNWQyxVQUFBQSxTQUFTLEVBQUU7QUFERDtBQVZQLFNBYUZOLFNBYkUsRUFBUDtBQWVEOzs7RUFoRnVDTyxvQzs7O0FBbUYxQ3ZDLFlBQVksQ0FBQ3dDLFNBQWIsR0FBeUIsY0FBekI7QUFDQXhDLFlBQVksQ0FBQ2IsWUFBYixHQUE0QkEsWUFBNUIiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMjIgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5pbXBvcnQge1NjYXR0ZXJwbG90TGF5ZXJ9IGZyb20gJ0BkZWNrLmdsL2xheWVycyc7XG5pbXBvcnQge19BZ2dyZWdhdGlvbkxheWVyIGFzIEFnZ3JlZ2F0aW9uTGF5ZXJ9IGZyb20gJ0BkZWNrLmdsL2FnZ3JlZ2F0aW9uLWxheWVycyc7XG5cbmltcG9ydCBnZW9WaWV3cG9ydCBmcm9tICdAbWFwYm94L2dlby12aWV3cG9ydCc7XG5pbXBvcnQgQ1BVQWdncmVnYXRvciwge1xuICBBZ2dyZWdhdGlvblR5cGUsXG4gIGRlZmF1bHRDb2xvckRpbWVuc2lvbixcbiAgRGltZW5zaW9uVHlwZSxcbiAgZ2V0RGltZW5zaW9uU2NhbGVcbn0gZnJvbSAnLi4vbGF5ZXItdXRpbHMvY3B1LWFnZ3JlZ2F0b3InO1xuaW1wb3J0IHtnZXREaXN0YW5jZVNjYWxlc30gZnJvbSAndmlld3BvcnQtbWVyY2F0b3ItcHJvamVjdCc7XG5pbXBvcnQge21heH0gZnJvbSAnZDMtYXJyYXknO1xuXG5pbXBvcnQge1NDQUxFX1RZUEVTLCBERUZBVUxUX0NPTE9SX1JBTkdFLCBMQVlFUl9WSVNfQ09ORklHU30gZnJvbSAnQGtlcGxlci5nbC9jb25zdGFudHMnO1xuaW1wb3J0IENsdXN0ZXJCdWlsZGVyLCB7Z2V0R2VvSlNPTn0gZnJvbSAnLi4vbGF5ZXItdXRpbHMvY2x1c3Rlci11dGlscyc7XG5pbXBvcnQge1JHQkFDb2xvcn0gZnJvbSAnQGtlcGxlci5nbC90eXBlcyc7XG5pbXBvcnQge0FnZ3JlZ2F0aW9uTGF5ZXJQcm9wc30gZnJvbSAnQGRlY2suZ2wvYWdncmVnYXRpb24tbGF5ZXJzL2FnZ3JlZ2F0aW9uLWxheWVyJztcblxuY29uc3QgZGVmYXVsdFJhZGl1cyA9IExBWUVSX1ZJU19DT05GSUdTLmNsdXN0ZXJSYWRpdXMuZGVmYXVsdFZhbHVlO1xuY29uc3QgZGVmYXVsdFJhZGl1c1JhbmdlID0gTEFZRVJfVklTX0NPTkZJR1MuY2x1c3RlclJhZGl1c1JhbmdlLmRlZmF1bHRWYWx1ZTtcblxuY29uc3QgZGVmYXVsdEdldENvbG9yVmFsdWUgPSBwb2ludHMgPT4gcG9pbnRzLmxlbmd0aDtcbmNvbnN0IGRlZmF1bHRHZXRSYWRpdXNWYWx1ZSA9IGNlbGwgPT5cbiAgY2VsbC5maWx0ZXJlZFBvaW50cyA/IGNlbGwuZmlsdGVyZWRQb2ludHMubGVuZ3RoIDogY2VsbC5wb2ludHMubGVuZ3RoO1xuXG5mdW5jdGlvbiBwcm9jZXNzR2VvSlNPTih0aGlzOiBDUFVBZ2dyZWdhdG9yLCBzdGVwLCBwcm9wcywgYWdncmVnYXRpb24sIHt2aWV3cG9ydH0pIHtcbiAgY29uc3Qge2RhdGEsIGdldFBvc2l0aW9uLCBmaWx0ZXJEYXRhfSA9IHByb3BzO1xuICBjb25zdCBnZW9KU09OID0gZ2V0R2VvSlNPTihkYXRhLCBnZXRQb3NpdGlvbiwgZmlsdGVyRGF0YSk7XG4gIGNvbnN0IGNsdXN0ZXJCdWlsZGVyID0gbmV3IENsdXN0ZXJCdWlsZGVyKCk7XG5cbiAgdGhpcy5zZXRTdGF0ZSh7Z2VvSlNPTiwgY2x1c3RlckJ1aWxkZXJ9KTtcbn1cblxuZnVuY3Rpb24gZ2V0Q2x1c3RlcnModGhpczogQ1BVQWdncmVnYXRvciwgc3RlcCwgcHJvcHMsIGFnZ3JlZ2F0aW9uLCB7dmlld3BvcnR9KSB7XG4gIGNvbnN0IHtnZW9KU09OLCBjbHVzdGVyQnVpbGRlcn0gPSB0aGlzLnN0YXRlO1xuICBjb25zdCB7Y2x1c3RlclJhZGl1cywgem9vbSwgd2lkdGgsIGhlaWdodH0gPSBwcm9wcztcbiAgY29uc3Qge2xvbmdpdHVkZSwgbGF0aXR1ZGV9ID0gdmlld3BvcnQ7XG5cbiAgLy8gem9vbSBuZWVkcyB0byBiZSBhbiBpbnRlZ2VyIGZvciB0aGUgZGlmZmVyZW50IG1hcCB1dGlscy4gQWxzbyBoZWxwcyB3aXRoIGNhY2hlIGtleS5cbiAgY29uc3QgYmJveCA9IGdlb1ZpZXdwb3J0LmJvdW5kcyhbbG9uZ2l0dWRlLCBsYXRpdHVkZV0sIHpvb20sIFt3aWR0aCwgaGVpZ2h0XSk7XG4gIGNvbnN0IGNsdXN0ZXJzID0gY2x1c3RlckJ1aWxkZXIuY2x1c3RlcnNBdFpvb20oe2Jib3gsIGNsdXN0ZXJSYWRpdXMsIGdlb0pTT04sIHpvb219KTtcblxuICB0aGlzLnNldFN0YXRlKHtcbiAgICBsYXllckRhdGE6IHtkYXRhOiBjbHVzdGVyc31cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldFN1YkxheWVyUmFkaXVzKGRpbWVuc2lvblN0YXRlLCBkaW1lbnNpb24sIGxheWVyUHJvcHMpIHtcbiAgcmV0dXJuIGNlbGwgPT4ge1xuICAgIGNvbnN0IHtnZXRSYWRpdXNWYWx1ZX0gPSBsYXllclByb3BzO1xuICAgIGNvbnN0IHtzY2FsZUZ1bmN9ID0gZGltZW5zaW9uU3RhdGU7XG4gICAgcmV0dXJuIHNjYWxlRnVuYyhnZXRSYWRpdXNWYWx1ZShjZWxsKSk7XG4gIH07XG59XG5cbmV4cG9ydCBjb25zdCBjbHVzdGVyQWdncmVnYXRpb246IEFnZ3JlZ2F0aW9uVHlwZSA9IHtcbiAga2V5OiAncG9zaXRpb24nLFxuICB1cGRhdGVTdGVwczogW1xuICAgIHtcbiAgICAgIGtleTogJ2dlb2pzb24nLFxuICAgICAgdHJpZ2dlcnM6IHtcbiAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICBwcm9wOiAnZ2V0UG9zaXRpb24nLFxuICAgICAgICAgIHVwZGF0ZVRyaWdnZXI6ICdnZXRQb3NpdGlvbidcbiAgICAgICAgfSxcbiAgICAgICAgZmlsdGVyRGF0YToge1xuICAgICAgICAgIHByb3A6ICdmaWx0ZXJEYXRhJyxcbiAgICAgICAgICB1cGRhdGVUcmlnZ2VyOiAnZmlsdGVyRGF0YSdcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVwZGF0ZXI6IHByb2Nlc3NHZW9KU09OXG4gICAgfSxcbiAgICB7XG4gICAgICBrZXk6ICdjbHVzdGVyaW5nJyxcbiAgICAgIHRyaWdnZXJzOiB7XG4gICAgICAgIGNsdXN0ZXJSYWRpdXM6IHtcbiAgICAgICAgICBwcm9wOiAnY2x1c3RlclJhZGl1cydcbiAgICAgICAgfSxcbiAgICAgICAgem9vbToge1xuICAgICAgICAgIHByb3A6ICd6b29tJ1xuICAgICAgICB9LFxuICAgICAgICB3aWR0aDoge1xuICAgICAgICAgIHByb3A6ICd3aWR0aCdcbiAgICAgICAgfSxcbiAgICAgICAgaGVpZ2h0OiB7XG4gICAgICAgICAgcHJvcDogJ2hlaWdodCdcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVwZGF0ZXI6IGdldENsdXN0ZXJzXG4gICAgfVxuICBdXG59O1xuXG5mdW5jdGlvbiBnZXRSYWRpdXNWYWx1ZURvbWFpbih0aGlzOiBDUFVBZ2dyZWdhdG9yLCBzdGVwLCBwcm9wcywgZGltZW5zaW9uVXBkYXRlcikge1xuICBjb25zdCB7a2V5fSA9IGRpbWVuc2lvblVwZGF0ZXI7XG4gIGNvbnN0IHtnZXRSYWRpdXNWYWx1ZX0gPSBwcm9wcztcbiAgY29uc3Qge2xheWVyRGF0YX0gPSB0aGlzLnN0YXRlO1xuXG4gIGNvbnN0IHZhbHVlRG9tYWluID0gWzAsIG1heChsYXllckRhdGEuZGF0YSwgZ2V0UmFkaXVzVmFsdWUpXTtcbiAgdGhpcy5fc2V0RGltZW5zaW9uU3RhdGUoa2V5LCB7dmFsdWVEb21haW59KTtcbn1cblxuY29uc3QgY2x1c3RlckxheWVyRGltZW5zaW9uczogW0RpbWVuc2lvblR5cGU8UkdCQUNvbG9yPiwgRGltZW5zaW9uVHlwZTxudW1iZXI+XSA9IFtcbiAgZGVmYXVsdENvbG9yRGltZW5zaW9uLFxuICB7XG4gICAga2V5OiAncmFkaXVzJyxcbiAgICBhY2Nlc3NvcjogJ2dldFJhZGl1cycsXG4gICAgbnVsbFZhbHVlOiAwLFxuICAgIHVwZGF0ZVN0ZXBzOiBbXG4gICAgICB7XG4gICAgICAgIGtleTogJ2dldERvbWFpbicsXG4gICAgICAgIHRyaWdnZXJzOiB7XG4gICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgIHByb3A6ICdnZXRSYWRpdXNWYWx1ZScsXG4gICAgICAgICAgICB1cGRhdGVUcmlnZ2VyOiAnZ2V0UmFkaXVzVmFsdWUnXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB1cGRhdGVyOiBnZXRSYWRpdXNWYWx1ZURvbWFpblxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAga2V5OiAnZ2V0U2NhbGVGdW5jJyxcbiAgICAgICAgdHJpZ2dlcnM6IHtcbiAgICAgICAgICBkb21haW46IHtwcm9wOiAncmFkaXVzRG9tYWluJ30sXG4gICAgICAgICAgcmFuZ2U6IHtwcm9wOiAncmFkaXVzUmFuZ2UnfSxcbiAgICAgICAgICBzY2FsZVR5cGU6IHtwcm9wOiAncmFkaXVzU2NhbGVUeXBlJ31cbiAgICAgICAgfSxcbiAgICAgICAgdXBkYXRlcjogZ2V0RGltZW5zaW9uU2NhbGVcbiAgICAgIH1cbiAgICBdLFxuICAgIGdldFN1YkxheWVyQWNjZXNzb3I6IGdldFN1YkxheWVyUmFkaXVzLFxuICAgIGdldFBpY2tpbmdJbmZvOiAoZGltZW5zaW9uU3RhdGUsIGNlbGwsIGxheWVyUHJvcHMpID0+IHtcbiAgICAgIGNvbnN0IHJhZGl1c1ZhbHVlID0gbGF5ZXJQcm9wcy5nZXRSYWRpdXNWYWx1ZShjZWxsKTtcbiAgICAgIHJldHVybiB7cmFkaXVzVmFsdWV9O1xuICAgIH1cbiAgfVxuXTtcblxuY29uc3QgZGVmYXVsdFByb3BzID0ge1xuICBjbHVzdGVyUmFkaXVzOiBkZWZhdWx0UmFkaXVzLFxuICBjb2xvckRvbWFpbjogbnVsbCxcbiAgY29sb3JSYW5nZTogREVGQVVMVF9DT0xPUl9SQU5HRSxcbiAgY29sb3JTY2FsZVR5cGU6IFNDQUxFX1RZUEVTLnF1YW50aXplLFxuICByYWRpdXNTY2FsZVR5cGU6IFNDQUxFX1RZUEVTLnNxcnQsXG4gIHJhZGl1c1JhbmdlOiBkZWZhdWx0UmFkaXVzUmFuZ2UsXG4gIGdldFBvc2l0aW9uOiB7dHlwZTogJ2FjY2Vzc29yJywgdmFsdWU6IHggPT4geC5wb3NpdGlvbn0sXG4gIGdldENvbG9yVmFsdWU6IHt0eXBlOiAnYWNjZXNzb3InLCB2YWx1ZTogZGVmYXVsdEdldENvbG9yVmFsdWV9LFxuICBnZXRSYWRpdXNWYWx1ZToge3R5cGU6ICdhY2Nlc3NvcicsIHZhbHVlOiBkZWZhdWx0R2V0UmFkaXVzVmFsdWV9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDbHVzdGVyTGF5ZXIgZXh0ZW5kcyBBZ2dyZWdhdGlvbkxheWVyPFxuICBhbnksXG4gIEFnZ3JlZ2F0aW9uTGF5ZXJQcm9wczxhbnk+ICYge3JhZGl1c1NjYWxlOiBudW1iZXJ9XG4+IHtcbiAgaW5pdGlhbGl6ZVN0YXRlKCkge1xuICAgIGNvbnN0IGNwdUFnZ3JlZ2F0b3IgPSBuZXcgQ1BVQWdncmVnYXRvcih7XG4gICAgICBhZ2dyZWdhdGlvbjogY2x1c3RlckFnZ3JlZ2F0aW9uLFxuICAgICAgZGltZW5zaW9uczogY2x1c3RlckxheWVyRGltZW5zaW9uc1xuICAgIH0pO1xuXG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGNwdUFnZ3JlZ2F0b3IsXG4gICAgICBhZ2dyZWdhdG9yU3RhdGU6IGNwdUFnZ3JlZ2F0b3Iuc3RhdGVcbiAgICB9O1xuICAgIGNvbnN0IGF0dHJpYnV0ZU1hbmFnZXIgPSB0aGlzLmdldEF0dHJpYnV0ZU1hbmFnZXIoKTtcbiAgICBhdHRyaWJ1dGVNYW5hZ2VyLmFkZCh7XG4gICAgICBwb3NpdGlvbnM6IHtzaXplOiAzLCBhY2Nlc3NvcjogJ2dldFBvc2l0aW9uJ31cbiAgICB9KTtcbiAgfVxuXG4gIHVwZGF0ZVN0YXRlKHtvbGRQcm9wcywgcHJvcHMsIGNoYW5nZUZsYWdzfSkge1xuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgLy8gbWFrZSBhIGNvcHkgb2YgdGhlIGludGVybmFsIHN0YXRlIG9mIGNwdUFnZ3JlZ2F0b3IgZm9yIHRlc3RpbmdcbiAgICAgIGFnZ3JlZ2F0b3JTdGF0ZTogdGhpcy5zdGF0ZS5jcHVBZ2dyZWdhdG9yLnVwZGF0ZVN0YXRlKFxuICAgICAgICB7b2xkUHJvcHMsIHByb3BzLCBjaGFuZ2VGbGFnc30sXG4gICAgICAgIHtcbiAgICAgICAgICB2aWV3cG9ydDogdGhpcy5jb250ZXh0LnZpZXdwb3J0LFxuICAgICAgICAgIGF0dHJpYnV0ZXM6IHRoaXMuZ2V0QXR0cmlidXRlcygpLFxuICAgICAgICAgIG51bUluc3RhbmNlczogdGhpcy5nZXROdW1JbnN0YW5jZXMocHJvcHMpXG4gICAgICAgIH1cbiAgICAgIClcbiAgICB9KTtcbiAgfVxuXG4gIGdldFBpY2tpbmdJbmZvKHtpbmZvfSkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLmNwdUFnZ3JlZ2F0b3IuZ2V0UGlja2luZ0luZm8oe2luZm99LCB0aGlzLnByb3BzKTtcbiAgfVxuXG4gIF9nZXRTdWJsYXllclVwZGF0ZVRyaWdnZXJzKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLmNwdUFnZ3JlZ2F0b3IuZ2V0VXBkYXRlVHJpZ2dlcnModGhpcy5wcm9wcyk7XG4gIH1cblxuICBfZ2V0U3ViTGF5ZXJBY2Nlc3NvcnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGdldFJhZGl1czogdGhpcy5zdGF0ZS5jcHVBZ2dyZWdhdG9yLmdldEFjY2Vzc29yKCdyYWRpdXMnLCB0aGlzLnByb3BzKSxcbiAgICAgIGdldEZpbGxDb2xvcjogdGhpcy5zdGF0ZS5jcHVBZ2dyZWdhdG9yLmdldEFjY2Vzc29yKCdmaWxsQ29sb3InLCB0aGlzLnByb3BzKVxuICAgIH07XG4gIH1cblxuICByZW5kZXJMYXllcnMoKSB7XG4gICAgLy8gZm9yIHN1YmNsYXNzaW5nLCBvdmVycmlkZSB0aGlzIG1ldGhvZCB0byByZXR1cm5cbiAgICAvLyBjdXN0b21pemVkIHN1YiBsYXllciBwcm9wc1xuICAgIGNvbnN0IHtpZCwgcmFkaXVzU2NhbGV9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB7Y3B1QWdncmVnYXRvcn0gPSB0aGlzLnN0YXRlO1xuXG4gICAgLy8gYmFzZSBsYXllciBwcm9wc1xuICAgIGNvbnN0IHt2aXNpYmxlLCBvcGFjaXR5LCBwaWNrYWJsZSwgYXV0b0hpZ2hsaWdodCwgaGlnaGxpZ2h0Q29sb3J9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB1cGRhdGVUcmlnZ2VycyA9IHRoaXMuX2dldFN1YmxheWVyVXBkYXRlVHJpZ2dlcnMoKTtcbiAgICBjb25zdCBhY2Nlc3NvcnMgPSB0aGlzLl9nZXRTdWJMYXllckFjY2Vzc29ycygpO1xuXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgIGNvbnN0IGRpc3RhbmNlU2NhbGUgPSBnZXREaXN0YW5jZVNjYWxlcyh0aGlzLmNvbnRleHQudmlld3BvcnQpO1xuICAgIGNvbnN0IG1ldGVyc1BlclBpeGVsID0gZGlzdGFuY2VTY2FsZS5tZXRlcnNQZXJQaXhlbFswXTtcblxuICAgIC8vIHJldHVybiBwcm9wcyB0byB0aGUgc3VibGF5ZXIgY29uc3RydWN0b3JcbiAgICByZXR1cm4gbmV3IFNjYXR0ZXJwbG90TGF5ZXIoe1xuICAgICAgaWQ6IGAke2lkfS1jbHVzdGVyYCxcbiAgICAgIGRhdGE6IGNwdUFnZ3JlZ2F0b3Iuc3RhdGUubGF5ZXJEYXRhLmRhdGEsXG4gICAgICByYWRpdXNTY2FsZTogbWV0ZXJzUGVyUGl4ZWwgKiByYWRpdXNTY2FsZSxcbiAgICAgIHZpc2libGUsXG4gICAgICBvcGFjaXR5LFxuICAgICAgcGlja2FibGUsXG4gICAgICBhdXRvSGlnaGxpZ2h0LFxuICAgICAgaGlnaGxpZ2h0Q29sb3IsXG4gICAgICB1cGRhdGVUcmlnZ2VycyxcbiAgICAgIHBhcmFtZXRlcnM6IHtcbiAgICAgICAgZGVwdGhNYXNrOiBmYWxzZVxuICAgICAgfSxcbiAgICAgIC4uLmFjY2Vzc29yc1xuICAgIH0pO1xuICB9XG59XG5cbkNsdXN0ZXJMYXllci5sYXllck5hbWUgPSAnQ2x1c3RlckxheWVyJztcbkNsdXN0ZXJMYXllci5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHM7XG4iXX0=