(function webpackUniversalModuleDefinition(root, factory) {
  if (typeof exports === 'object' && typeof module === 'object')
    module.exports = factory();
  else if (typeof define === 'function' && define.amd) define([], factory);
        else if (typeof exports === 'object') exports['deck'] = factory();
  else root['deck'] = factory();})(globalThis, function () {
"use strict";
var __exports__ = (() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __require = /* @__PURE__ */ ((x2) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x2, {
    get: (a2, b) => (typeof require !== "undefined" ? require : a2)[b]
  }) : x2)(function(x2) {
    if (typeof require !== "undefined")
      return require.apply(this, arguments);
    throw new Error('Dynamic require of "' + x2 + '" is not supported');
  });
  var __commonJS = (cb, mod2) => function __require2() {
    return mod2 || (0, cb[__getOwnPropNames(cb)[0]])((mod2 = { exports: {} }).exports, mod2), mod2.exports;
  };
  var __export = (target, all) => {
    for (var name10 in all)
      __defProp(target, name10, { get: all[name10], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __reExport = (target, mod2, secondTarget) => (__copyProps(target, mod2, "default"), secondTarget && __copyProps(secondTarget, mod2, "default"));
  var __toESM = (mod2, isNodeMode, target) => (target = mod2 != null ? __create(__getProtoOf(mod2)) : {}, __copyProps(
    isNodeMode || !mod2 || !mod2.__esModule ? __defProp(target, "default", { value: mod2, enumerable: true }) : target,
    mod2
  ));
  var __toCommonJS = (mod2) => __copyProps(__defProp({}, "__esModule", { value: true }), mod2);
  var __publicField = (obj, key, value) => {
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };

  // external-global-plugin:@deck.gl/layers
  var require_layers = __commonJS({
    "external-global-plugin:@deck.gl/layers"(exports, module2) {
      module2.exports = globalThis.deck;
    }
  });

  // external-global-plugin:@deck.gl/core
  var require_core = __commonJS({
    "external-global-plugin:@deck.gl/core"(exports, module2) {
      module2.exports = globalThis.deck;
    }
  });

  // ../../node_modules/fast-xml-parser/src/util.js
  var require_util = __commonJS({
    "../../node_modules/fast-xml-parser/src/util.js"(exports) {
      "use strict";
      var nameStartChar = ":A-Za-z_\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
      var nameChar = nameStartChar + "\\-.\\d\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
      var nameRegexp = "[" + nameStartChar + "][" + nameChar + "]*";
      var regexName = new RegExp("^" + nameRegexp + "$");
      var getAllMatches = function(string, regex) {
        const matches3 = [];
        let match = regex.exec(string);
        while (match) {
          const allmatches = [];
          allmatches.startIndex = regex.lastIndex - match[0].length;
          const len2 = match.length;
          for (let index = 0; index < len2; index++) {
            allmatches.push(match[index]);
          }
          matches3.push(allmatches);
          match = regex.exec(string);
        }
        return matches3;
      };
      var isName = function(string) {
        const match = regexName.exec(string);
        return !(match === null || typeof match === "undefined");
      };
      exports.isExist = function(v) {
        return typeof v !== "undefined";
      };
      exports.isEmptyObject = function(obj) {
        return Object.keys(obj).length === 0;
      };
      exports.merge = function(target, a2, arrayMode) {
        if (a2) {
          const keys = Object.keys(a2);
          const len2 = keys.length;
          for (let i3 = 0; i3 < len2; i3++) {
            if (arrayMode === "strict") {
              target[keys[i3]] = [a2[keys[i3]]];
            } else {
              target[keys[i3]] = a2[keys[i3]];
            }
          }
        }
      };
      exports.getValue = function(v) {
        if (exports.isExist(v)) {
          return v;
        } else {
          return "";
        }
      };
      exports.isName = isName;
      exports.getAllMatches = getAllMatches;
      exports.nameRegexp = nameRegexp;
    }
  });

  // ../../node_modules/fast-xml-parser/src/validator.js
  var require_validator = __commonJS({
    "../../node_modules/fast-xml-parser/src/validator.js"(exports) {
      "use strict";
      var util = require_util();
      var defaultOptions = {
        allowBooleanAttributes: false,
        unpairedTags: []
      };
      exports.validate = function(xmlData, options) {
        options = Object.assign({}, defaultOptions, options);
        const tags = [];
        let tagFound = false;
        let reachedRoot = false;
        if (xmlData[0] === "\uFEFF") {
          xmlData = xmlData.substr(1);
        }
        for (let i3 = 0; i3 < xmlData.length; i3++) {
          if (xmlData[i3] === "<" && xmlData[i3 + 1] === "?") {
            i3 += 2;
            i3 = readPI(xmlData, i3);
            if (i3.err)
              return i3;
          } else if (xmlData[i3] === "<") {
            let tagStartPos = i3;
            i3++;
            if (xmlData[i3] === "!") {
              i3 = readCommentAndCDATA(xmlData, i3);
              continue;
            } else {
              let closingTag = false;
              if (xmlData[i3] === "/") {
                closingTag = true;
                i3++;
              }
              let tagName = "";
              for (; i3 < xmlData.length && xmlData[i3] !== ">" && xmlData[i3] !== " " && xmlData[i3] !== "	" && xmlData[i3] !== "\n" && xmlData[i3] !== "\r"; i3++) {
                tagName += xmlData[i3];
              }
              tagName = tagName.trim();
              if (tagName[tagName.length - 1] === "/") {
                tagName = tagName.substring(0, tagName.length - 1);
                i3--;
              }
              if (!validateTagName(tagName)) {
                let msg;
                if (tagName.trim().length === 0) {
                  msg = "Invalid space after '<'.";
                } else {
                  msg = "Tag '" + tagName + "' is an invalid name.";
                }
                return getErrorObject("InvalidTag", msg, getLineNumberForPosition(xmlData, i3));
              }
              const result = readAttributeStr(xmlData, i3);
              if (result === false) {
                return getErrorObject("InvalidAttr", "Attributes for '" + tagName + "' have open quote.", getLineNumberForPosition(xmlData, i3));
              }
              let attrStr = result.value;
              i3 = result.index;
              if (attrStr[attrStr.length - 1] === "/") {
                const attrStrStart = i3 - attrStr.length;
                attrStr = attrStr.substring(0, attrStr.length - 1);
                const isValid = validateAttributeString(attrStr, options);
                if (isValid === true) {
                  tagFound = true;
                } else {
                  return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, attrStrStart + isValid.err.line));
                }
              } else if (closingTag) {
                if (!result.tagClosed) {
                  return getErrorObject("InvalidTag", "Closing tag '" + tagName + "' doesn't have proper closing.", getLineNumberForPosition(xmlData, i3));
                } else if (attrStr.trim().length > 0) {
                  return getErrorObject("InvalidTag", "Closing tag '" + tagName + "' can't have attributes or invalid starting.", getLineNumberForPosition(xmlData, tagStartPos));
                } else {
                  const otg = tags.pop();
                  if (tagName !== otg.tagName) {
                    let openPos = getLineNumberForPosition(xmlData, otg.tagStartPos);
                    return getErrorObject("InvalidTag", "Expected closing tag '" + otg.tagName + "' (opened in line " + openPos.line + ", col " + openPos.col + ") instead of closing tag '" + tagName + "'.", getLineNumberForPosition(xmlData, tagStartPos));
                  }
                  if (tags.length == 0) {
                    reachedRoot = true;
                  }
                }
              } else {
                const isValid = validateAttributeString(attrStr, options);
                if (isValid !== true) {
                  return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, i3 - attrStr.length + isValid.err.line));
                }
                if (reachedRoot === true) {
                  return getErrorObject("InvalidXml", "Multiple possible root nodes found.", getLineNumberForPosition(xmlData, i3));
                } else if (options.unpairedTags.indexOf(tagName) !== -1) {
                } else {
                  tags.push({
                    tagName,
                    tagStartPos
                  });
                }
                tagFound = true;
              }
              for (i3++; i3 < xmlData.length; i3++) {
                if (xmlData[i3] === "<") {
                  if (xmlData[i3 + 1] === "!") {
                    i3++;
                    i3 = readCommentAndCDATA(xmlData, i3);
                    continue;
                  } else if (xmlData[i3 + 1] === "?") {
                    i3 = readPI(xmlData, ++i3);
                    if (i3.err)
                      return i3;
                  } else {
                    break;
                  }
                } else if (xmlData[i3] === "&") {
                  const afterAmp = validateAmpersand(xmlData, i3);
                  if (afterAmp == -1)
                    return getErrorObject("InvalidChar", "char '&' is not expected.", getLineNumberForPosition(xmlData, i3));
                  i3 = afterAmp;
                } else {
                  if (reachedRoot === true && !isWhiteSpace(xmlData[i3])) {
                    return getErrorObject("InvalidXml", "Extra text at the end", getLineNumberForPosition(xmlData, i3));
                  }
                }
              }
              if (xmlData[i3] === "<") {
                i3--;
              }
            }
          } else {
            if (isWhiteSpace(xmlData[i3])) {
              continue;
            }
            return getErrorObject("InvalidChar", "char '" + xmlData[i3] + "' is not expected.", getLineNumberForPosition(xmlData, i3));
          }
        }
        if (!tagFound) {
          return getErrorObject("InvalidXml", "Start tag expected.", 1);
        } else if (tags.length == 1) {
          return getErrorObject("InvalidTag", "Unclosed tag '" + tags[0].tagName + "'.", getLineNumberForPosition(xmlData, tags[0].tagStartPos));
        } else if (tags.length > 0) {
          return getErrorObject("InvalidXml", "Invalid '" + JSON.stringify(tags.map((t2) => t2.tagName), null, 4).replace(/\r?\n/g, "") + "' found.", {
            line: 1,
            col: 1
          });
        }
        return true;
      };
      function isWhiteSpace(char) {
        return char === " " || char === "	" || char === "\n" || char === "\r";
      }
      function readPI(xmlData, i3) {
        const start = i3;
        for (; i3 < xmlData.length; i3++) {
          if (xmlData[i3] == "?" || xmlData[i3] == " ") {
            const tagname = xmlData.substr(start, i3 - start);
            if (i3 > 5 && tagname === "xml") {
              return getErrorObject("InvalidXml", "XML declaration allowed only at the start of the document.", getLineNumberForPosition(xmlData, i3));
            } else if (xmlData[i3] == "?" && xmlData[i3 + 1] == ">") {
              i3++;
              break;
            } else {
              continue;
            }
          }
        }
        return i3;
      }
      function readCommentAndCDATA(xmlData, i3) {
        if (xmlData.length > i3 + 5 && xmlData[i3 + 1] === "-" && xmlData[i3 + 2] === "-") {
          for (i3 += 3; i3 < xmlData.length; i3++) {
            if (xmlData[i3] === "-" && xmlData[i3 + 1] === "-" && xmlData[i3 + 2] === ">") {
              i3 += 2;
              break;
            }
          }
        } else if (xmlData.length > i3 + 8 && xmlData[i3 + 1] === "D" && xmlData[i3 + 2] === "O" && xmlData[i3 + 3] === "C" && xmlData[i3 + 4] === "T" && xmlData[i3 + 5] === "Y" && xmlData[i3 + 6] === "P" && xmlData[i3 + 7] === "E") {
          let angleBracketsCount = 1;
          for (i3 += 8; i3 < xmlData.length; i3++) {
            if (xmlData[i3] === "<") {
              angleBracketsCount++;
            } else if (xmlData[i3] === ">") {
              angleBracketsCount--;
              if (angleBracketsCount === 0) {
                break;
              }
            }
          }
        } else if (xmlData.length > i3 + 9 && xmlData[i3 + 1] === "[" && xmlData[i3 + 2] === "C" && xmlData[i3 + 3] === "D" && xmlData[i3 + 4] === "A" && xmlData[i3 + 5] === "T" && xmlData[i3 + 6] === "A" && xmlData[i3 + 7] === "[") {
          for (i3 += 8; i3 < xmlData.length; i3++) {
            if (xmlData[i3] === "]" && xmlData[i3 + 1] === "]" && xmlData[i3 + 2] === ">") {
              i3 += 2;
              break;
            }
          }
        }
        return i3;
      }
      var doubleQuote = '"';
      var singleQuote = "'";
      function readAttributeStr(xmlData, i3) {
        let attrStr = "";
        let startChar = "";
        let tagClosed = false;
        for (; i3 < xmlData.length; i3++) {
          if (xmlData[i3] === doubleQuote || xmlData[i3] === singleQuote) {
            if (startChar === "") {
              startChar = xmlData[i3];
            } else if (startChar !== xmlData[i3]) {
            } else {
              startChar = "";
            }
          } else if (xmlData[i3] === ">") {
            if (startChar === "") {
              tagClosed = true;
              break;
            }
          }
          attrStr += xmlData[i3];
        }
        if (startChar !== "") {
          return false;
        }
        return {
          value: attrStr,
          index: i3,
          tagClosed
        };
      }
      var validAttrStrRegxp = new RegExp(`(\\s*)([^\\s=]+)(\\s*=)?(\\s*(['"])(([\\s\\S])*?)\\5)?`, "g");
      function validateAttributeString(attrStr, options) {
        const matches3 = util.getAllMatches(attrStr, validAttrStrRegxp);
        const attrNames = {};
        for (let i3 = 0; i3 < matches3.length; i3++) {
          if (matches3[i3][1].length === 0) {
            return getErrorObject("InvalidAttr", "Attribute '" + matches3[i3][2] + "' has no space in starting.", getPositionFromMatch(matches3[i3]));
          } else if (matches3[i3][3] !== void 0 && matches3[i3][4] === void 0) {
            return getErrorObject("InvalidAttr", "Attribute '" + matches3[i3][2] + "' is without value.", getPositionFromMatch(matches3[i3]));
          } else if (matches3[i3][3] === void 0 && !options.allowBooleanAttributes) {
            return getErrorObject("InvalidAttr", "boolean attribute '" + matches3[i3][2] + "' is not allowed.", getPositionFromMatch(matches3[i3]));
          }
          const attrName = matches3[i3][2];
          if (!validateAttrName(attrName)) {
            return getErrorObject("InvalidAttr", "Attribute '" + attrName + "' is an invalid name.", getPositionFromMatch(matches3[i3]));
          }
          if (!attrNames.hasOwnProperty(attrName)) {
            attrNames[attrName] = 1;
          } else {
            return getErrorObject("InvalidAttr", "Attribute '" + attrName + "' is repeated.", getPositionFromMatch(matches3[i3]));
          }
        }
        return true;
      }
      function validateNumberAmpersand(xmlData, i3) {
        let re = /\d/;
        if (xmlData[i3] === "x") {
          i3++;
          re = /[\da-fA-F]/;
        }
        for (; i3 < xmlData.length; i3++) {
          if (xmlData[i3] === ";")
            return i3;
          if (!xmlData[i3].match(re))
            break;
        }
        return -1;
      }
      function validateAmpersand(xmlData, i3) {
        i3++;
        if (xmlData[i3] === ";")
          return -1;
        if (xmlData[i3] === "#") {
          i3++;
          return validateNumberAmpersand(xmlData, i3);
        }
        let count = 0;
        for (; i3 < xmlData.length; i3++, count++) {
          if (xmlData[i3].match(/\w/) && count < 20)
            continue;
          if (xmlData[i3] === ";")
            break;
          return -1;
        }
        return i3;
      }
      function getErrorObject(code, message, lineNumber) {
        return {
          err: {
            code,
            msg: message,
            line: lineNumber.line || lineNumber,
            col: lineNumber.col
          }
        };
      }
      function validateAttrName(attrName) {
        return util.isName(attrName);
      }
      function validateTagName(tagname) {
        return util.isName(tagname);
      }
      function getLineNumberForPosition(xmlData, index) {
        const lines = xmlData.substring(0, index).split(/\r?\n/);
        return {
          line: lines.length,
          col: lines[lines.length - 1].length + 1
        };
      }
      function getPositionFromMatch(match) {
        return match.startIndex + match[1].length;
      }
    }
  });

  // ../../node_modules/fast-xml-parser/src/xmlparser/OptionsBuilder.js
  var require_OptionsBuilder = __commonJS({
    "../../node_modules/fast-xml-parser/src/xmlparser/OptionsBuilder.js"(exports) {
      var defaultOptions = {
        preserveOrder: false,
        attributeNamePrefix: "@_",
        attributesGroupName: false,
        textNodeName: "#text",
        ignoreAttributes: true,
        removeNSPrefix: false,
        allowBooleanAttributes: false,
        parseTagValue: true,
        parseAttributeValue: false,
        trimValues: true,
        cdataPropName: false,
        numberParseOptions: {
          hex: true,
          leadingZeros: true,
          eNotation: true
        },
        tagValueProcessor: function(tagName, val) {
          return val;
        },
        attributeValueProcessor: function(attrName, val) {
          return val;
        },
        stopNodes: [],
        alwaysCreateTextNode: false,
        isArray: () => false,
        commentPropName: false,
        unpairedTags: [],
        processEntities: true,
        htmlEntities: false,
        ignoreDeclaration: false,
        ignorePiTags: false,
        transformTagName: false,
        transformAttributeName: false
      };
      var buildOptions = function(options) {
        return Object.assign({}, defaultOptions, options);
      };
      exports.buildOptions = buildOptions;
      exports.defaultOptions = defaultOptions;
    }
  });

  // ../../node_modules/fast-xml-parser/src/xmlparser/xmlNode.js
  var require_xmlNode = __commonJS({
    "../../node_modules/fast-xml-parser/src/xmlparser/xmlNode.js"(exports, module2) {
      "use strict";
      var XmlNode = class {
        constructor(tagname) {
          this.tagname = tagname;
          this.child = [];
          this[":@"] = {};
        }
        add(key, val) {
          if (key === "__proto__")
            key = "#__proto__";
          this.child.push({
            [key]: val
          });
        }
        addChild(node2) {
          if (node2.tagname === "__proto__")
            node2.tagname = "#__proto__";
          if (node2[":@"] && Object.keys(node2[":@"]).length > 0) {
            this.child.push({
              [node2.tagname]: node2.child,
              [":@"]: node2[":@"]
            });
          } else {
            this.child.push({
              [node2.tagname]: node2.child
            });
          }
        }
      };
      module2.exports = XmlNode;
    }
  });

  // ../../node_modules/fast-xml-parser/src/xmlparser/DocTypeReader.js
  var require_DocTypeReader = __commonJS({
    "../../node_modules/fast-xml-parser/src/xmlparser/DocTypeReader.js"(exports, module2) {
      function readDocType(xmlData, i3) {
        const entities = {};
        if (xmlData[i3 + 3] === "O" && xmlData[i3 + 4] === "C" && xmlData[i3 + 5] === "T" && xmlData[i3 + 6] === "Y" && xmlData[i3 + 7] === "P" && xmlData[i3 + 8] === "E") {
          i3 = i3 + 9;
          let angleBracketsCount = 1;
          let hasBody = false, entity = false, comment = false;
          let exp = "";
          for (; i3 < xmlData.length; i3++) {
            if (xmlData[i3] === "<" && !comment) {
              if (hasBody && xmlData[i3 + 1] === "!" && xmlData[i3 + 2] === "E" && xmlData[i3 + 3] === "N" && xmlData[i3 + 4] === "T" && xmlData[i3 + 5] === "I" && xmlData[i3 + 6] === "T" && xmlData[i3 + 7] === "Y") {
                i3 += 7;
                entity = true;
              } else if (hasBody && xmlData[i3 + 1] === "!" && xmlData[i3 + 2] === "E" && xmlData[i3 + 3] === "L" && xmlData[i3 + 4] === "E" && xmlData[i3 + 5] === "M" && xmlData[i3 + 6] === "E" && xmlData[i3 + 7] === "N" && xmlData[i3 + 8] === "T") {
                i3 += 8;
              } else if (hasBody && xmlData[i3 + 1] === "!" && xmlData[i3 + 2] === "A" && xmlData[i3 + 3] === "T" && xmlData[i3 + 4] === "T" && xmlData[i3 + 5] === "L" && xmlData[i3 + 6] === "I" && xmlData[i3 + 7] === "S" && xmlData[i3 + 8] === "T") {
                i3 += 8;
              } else if (hasBody && xmlData[i3 + 1] === "!" && xmlData[i3 + 2] === "N" && xmlData[i3 + 3] === "O" && xmlData[i3 + 4] === "T" && xmlData[i3 + 5] === "A" && xmlData[i3 + 6] === "T" && xmlData[i3 + 7] === "I" && xmlData[i3 + 8] === "O" && xmlData[i3 + 9] === "N") {
                i3 += 9;
              } else if (xmlData[i3 + 1] === "!" && xmlData[i3 + 2] === "-" && xmlData[i3 + 3] === "-") {
                comment = true;
              } else {
                throw new Error("Invalid DOCTYPE");
              }
              angleBracketsCount++;
              exp = "";
            } else if (xmlData[i3] === ">") {
              if (comment) {
                if (xmlData[i3 - 1] === "-" && xmlData[i3 - 2] === "-") {
                  comment = false;
                  angleBracketsCount--;
                }
              } else {
                if (entity) {
                  parseEntityExp(exp, entities);
                  entity = false;
                }
                angleBracketsCount--;
              }
              if (angleBracketsCount === 0) {
                break;
              }
            } else if (xmlData[i3] === "[") {
              hasBody = true;
            } else {
              exp += xmlData[i3];
            }
          }
          if (angleBracketsCount !== 0) {
            throw new Error(`Unclosed DOCTYPE`);
          }
        } else {
          throw new Error(`Invalid Tag instead of DOCTYPE`);
        }
        return {
          entities,
          i: i3
        };
      }
      var entityRegex = RegExp(`^\\s([a-zA-z0-0]+)[ 	](['"])([^&]+)\\2`);
      function parseEntityExp(exp, entities) {
        const match = entityRegex.exec(exp);
        if (match) {
          entities[match[1]] = {
            regx: RegExp(`&${match[1]};`, "g"),
            val: match[3]
          };
        }
      }
      module2.exports = readDocType;
    }
  });

  // ../../node_modules/strnum/strnum.js
  var require_strnum = __commonJS({
    "../../node_modules/strnum/strnum.js"(exports, module2) {
      var hexRegex = /^[-+]?0x[a-fA-F0-9]+$/;
      var numRegex = /^([\-\+])?(0*)(\.[0-9]+([eE]\-?[0-9]+)?|[0-9]+(\.[0-9]+([eE]\-?[0-9]+)?)?)$/;
      if (!Number.parseInt && window.parseInt) {
        Number.parseInt = window.parseInt;
      }
      if (!Number.parseFloat && window.parseFloat) {
        Number.parseFloat = window.parseFloat;
      }
      var consider = {
        hex: true,
        leadingZeros: true,
        decimalPoint: ".",
        eNotation: true
      };
      function toNumber(str, options = {}) {
        options = Object.assign({}, consider, options);
        if (!str || typeof str !== "string")
          return str;
        let trimmedStr = str.trim();
        if (options.skipLike !== void 0 && options.skipLike.test(trimmedStr))
          return str;
        else if (options.hex && hexRegex.test(trimmedStr)) {
          return Number.parseInt(trimmedStr, 16);
        } else {
          const match = numRegex.exec(trimmedStr);
          if (match) {
            const sign2 = match[1];
            const leadingZeros = match[2];
            let numTrimmedByZeros = trimZeros(match[3]);
            const eNotation = match[4] || match[6];
            if (!options.leadingZeros && leadingZeros.length > 0 && sign2 && trimmedStr[2] !== ".")
              return str;
            else if (!options.leadingZeros && leadingZeros.length > 0 && !sign2 && trimmedStr[1] !== ".")
              return str;
            else {
              const num = Number(trimmedStr);
              const numStr = "" + num;
              if (numStr.search(/[eE]/) !== -1) {
                if (options.eNotation)
                  return num;
                else
                  return str;
              } else if (eNotation) {
                if (options.eNotation)
                  return num;
                else
                  return str;
              } else if (trimmedStr.indexOf(".") !== -1) {
                if (numStr === "0" && numTrimmedByZeros === "")
                  return num;
                else if (numStr === numTrimmedByZeros)
                  return num;
                else if (sign2 && numStr === "-" + numTrimmedByZeros)
                  return num;
                else
                  return str;
              }
              if (leadingZeros) {
                if (numTrimmedByZeros === numStr)
                  return num;
                else if (sign2 + numTrimmedByZeros === numStr)
                  return num;
                else
                  return str;
              }
              if (trimmedStr === numStr)
                return num;
              else if (trimmedStr === sign2 + numStr)
                return num;
              return str;
            }
          } else {
            return str;
          }
        }
      }
      function trimZeros(numStr) {
        if (numStr && numStr.indexOf(".") !== -1) {
          numStr = numStr.replace(/0+$/, "");
          if (numStr === ".")
            numStr = "0";
          else if (numStr[0] === ".")
            numStr = "0" + numStr;
          else if (numStr[numStr.length - 1] === ".")
            numStr = numStr.substr(0, numStr.length - 1);
          return numStr;
        }
        return numStr;
      }
      module2.exports = toNumber;
    }
  });

  // ../../node_modules/fast-xml-parser/src/xmlparser/OrderedObjParser.js
  var require_OrderedObjParser = __commonJS({
    "../../node_modules/fast-xml-parser/src/xmlparser/OrderedObjParser.js"(exports, module2) {
      "use strict";
      var util = require_util();
      var xmlNode = require_xmlNode();
      var readDocType = require_DocTypeReader();
      var toNumber = require_strnum();
      var regx = "<((!\\[CDATA\\[([\\s\\S]*?)(]]>))|((NAME:)?(NAME))([^>]*)>|((\\/)(NAME)\\s*>))([^<]*)".replace(/NAME/g, util.nameRegexp);
      var OrderedObjParser = class {
        constructor(options) {
          this.options = options;
          this.currentNode = null;
          this.tagsNodeStack = [];
          this.docTypeEntities = {};
          this.lastEntities = {
            "apos": {
              regex: /&(apos|#39|#x27);/g,
              val: "'"
            },
            "gt": {
              regex: /&(gt|#62|#x3E);/g,
              val: ">"
            },
            "lt": {
              regex: /&(lt|#60|#x3C);/g,
              val: "<"
            },
            "quot": {
              regex: /&(quot|#34|#x22);/g,
              val: '"'
            }
          };
          this.ampEntity = {
            regex: /&(amp|#38|#x26);/g,
            val: "&"
          };
          this.htmlEntities = {
            "space": {
              regex: /&(nbsp|#160);/g,
              val: " "
            },
            "cent": {
              regex: /&(cent|#162);/g,
              val: "\xA2"
            },
            "pound": {
              regex: /&(pound|#163);/g,
              val: "\xA3"
            },
            "yen": {
              regex: /&(yen|#165);/g,
              val: "\xA5"
            },
            "euro": {
              regex: /&(euro|#8364);/g,
              val: "\u20AC"
            },
            "copyright": {
              regex: /&(copy|#169);/g,
              val: "\xA9"
            },
            "reg": {
              regex: /&(reg|#174);/g,
              val: "\xAE"
            },
            "inr": {
              regex: /&(inr|#8377);/g,
              val: "\u20B9"
            }
          };
          this.addExternalEntities = addExternalEntities;
          this.parseXml = parseXml;
          this.parseTextData = parseTextData;
          this.resolveNameSpace = resolveNameSpace;
          this.buildAttributesMap = buildAttributesMap;
          this.isItStopNode = isItStopNode;
          this.replaceEntitiesValue = replaceEntitiesValue;
          this.readStopNodeData = readStopNodeData;
          this.saveTextToParentTag = saveTextToParentTag;
        }
      };
      function addExternalEntities(externalEntities) {
        const entKeys = Object.keys(externalEntities);
        for (let i3 = 0; i3 < entKeys.length; i3++) {
          const ent = entKeys[i3];
          this.lastEntities[ent] = {
            regex: new RegExp("&" + ent + ";", "g"),
            val: externalEntities[ent]
          };
        }
      }
      function parseTextData(val, tagName, jPath, dontTrim, hasAttributes, isLeafNode, escapeEntities) {
        if (val !== void 0) {
          if (this.options.trimValues && !dontTrim) {
            val = val.trim();
          }
          if (val.length > 0) {
            if (!escapeEntities)
              val = this.replaceEntitiesValue(val);
            const newval = this.options.tagValueProcessor(tagName, val, jPath, hasAttributes, isLeafNode);
            if (newval === null || newval === void 0) {
              return val;
            } else if (typeof newval !== typeof val || newval !== val) {
              return newval;
            } else if (this.options.trimValues) {
              return parseValue(val, this.options.parseTagValue, this.options.numberParseOptions);
            } else {
              const trimmedVal = val.trim();
              if (trimmedVal === val) {
                return parseValue(val, this.options.parseTagValue, this.options.numberParseOptions);
              } else {
                return val;
              }
            }
          }
        }
      }
      function resolveNameSpace(tagname) {
        if (this.options.removeNSPrefix) {
          const tags = tagname.split(":");
          const prefix = tagname.charAt(0) === "/" ? "/" : "";
          if (tags[0] === "xmlns") {
            return "";
          }
          if (tags.length === 2) {
            tagname = prefix + tags[1];
          }
        }
        return tagname;
      }
      var attrsRegx = new RegExp(`([^\\s=]+)\\s*(=\\s*(['"])([\\s\\S]*?)\\3)?`, "gm");
      function buildAttributesMap(attrStr, jPath) {
        if (!this.options.ignoreAttributes && typeof attrStr === "string") {
          const matches3 = util.getAllMatches(attrStr, attrsRegx);
          const len2 = matches3.length;
          const attrs = {};
          for (let i3 = 0; i3 < len2; i3++) {
            const attrName = this.resolveNameSpace(matches3[i3][1]);
            let oldVal = matches3[i3][4];
            let aName = this.options.attributeNamePrefix + attrName;
            if (attrName.length) {
              if (this.options.transformAttributeName) {
                aName = this.options.transformAttributeName(aName);
              }
              if (aName === "__proto__")
                aName = "#__proto__";
              if (oldVal !== void 0) {
                if (this.options.trimValues) {
                  oldVal = oldVal.trim();
                }
                oldVal = this.replaceEntitiesValue(oldVal);
                const newVal = this.options.attributeValueProcessor(attrName, oldVal, jPath);
                if (newVal === null || newVal === void 0) {
                  attrs[aName] = oldVal;
                } else if (typeof newVal !== typeof oldVal || newVal !== oldVal) {
                  attrs[aName] = newVal;
                } else {
                  attrs[aName] = parseValue(oldVal, this.options.parseAttributeValue, this.options.numberParseOptions);
                }
              } else if (this.options.allowBooleanAttributes) {
                attrs[aName] = true;
              }
            }
          }
          if (!Object.keys(attrs).length) {
            return;
          }
          if (this.options.attributesGroupName) {
            const attrCollection = {};
            attrCollection[this.options.attributesGroupName] = attrs;
            return attrCollection;
          }
          return attrs;
        }
      }
      var parseXml = function(xmlData) {
        xmlData = xmlData.replace(/\r\n?/g, "\n");
        const xmlObj = new xmlNode("!xml");
        let currentNode = xmlObj;
        let textData = "";
        let jPath = "";
        for (let i3 = 0; i3 < xmlData.length; i3++) {
          const ch = xmlData[i3];
          if (ch === "<") {
            if (xmlData[i3 + 1] === "/") {
              const closeIndex = findClosingIndex(xmlData, ">", i3, "Closing Tag is not closed.");
              let tagName = xmlData.substring(i3 + 2, closeIndex).trim();
              if (this.options.removeNSPrefix) {
                const colonIndex = tagName.indexOf(":");
                if (colonIndex !== -1) {
                  tagName = tagName.substr(colonIndex + 1);
                }
              }
              if (this.options.transformTagName) {
                tagName = this.options.transformTagName(tagName);
              }
              if (currentNode) {
                textData = this.saveTextToParentTag(textData, currentNode, jPath);
              }
              jPath = jPath.substr(0, jPath.lastIndexOf("."));
              currentNode = this.tagsNodeStack.pop();
              textData = "";
              i3 = closeIndex;
            } else if (xmlData[i3 + 1] === "?") {
              let tagData = readTagExp(xmlData, i3, false, "?>");
              if (!tagData)
                throw new Error("Pi Tag is not closed.");
              textData = this.saveTextToParentTag(textData, currentNode, jPath);
              if (this.options.ignoreDeclaration && tagData.tagName === "?xml" || this.options.ignorePiTags) {
              } else {
                const childNode = new xmlNode(tagData.tagName);
                childNode.add(this.options.textNodeName, "");
                if (tagData.tagName !== tagData.tagExp && tagData.attrExpPresent) {
                  childNode[":@"] = this.buildAttributesMap(tagData.tagExp, jPath);
                }
                currentNode.addChild(childNode);
              }
              i3 = tagData.closeIndex + 1;
            } else if (xmlData.substr(i3 + 1, 3) === "!--") {
              const endIndex = findClosingIndex(xmlData, "-->", i3 + 4, "Comment is not closed.");
              if (this.options.commentPropName) {
                const comment = xmlData.substring(i3 + 4, endIndex - 2);
                textData = this.saveTextToParentTag(textData, currentNode, jPath);
                currentNode.add(this.options.commentPropName, [{
                  [this.options.textNodeName]: comment
                }]);
              }
              i3 = endIndex;
            } else if (xmlData.substr(i3 + 1, 2) === "!D") {
              const result = readDocType(xmlData, i3);
              this.docTypeEntities = result.entities;
              i3 = result.i;
            } else if (xmlData.substr(i3 + 1, 2) === "![") {
              const closeIndex = findClosingIndex(xmlData, "]]>", i3, "CDATA is not closed.") - 2;
              const tagExp = xmlData.substring(i3 + 9, closeIndex);
              textData = this.saveTextToParentTag(textData, currentNode, jPath);
              if (this.options.cdataPropName) {
                currentNode.add(this.options.cdataPropName, [{
                  [this.options.textNodeName]: tagExp
                }]);
              } else {
                let val = this.parseTextData(tagExp, currentNode.tagname, jPath, true, false, true);
                if (val == void 0)
                  val = "";
                currentNode.add(this.options.textNodeName, val);
              }
              i3 = closeIndex + 2;
            } else {
              let result = readTagExp(xmlData, i3, this.options.removeNSPrefix);
              let tagName = result.tagName;
              let tagExp = result.tagExp;
              let attrExpPresent = result.attrExpPresent;
              let closeIndex = result.closeIndex;
              if (this.options.transformTagName) {
                tagName = this.options.transformTagName(tagName);
              }
              if (currentNode && textData) {
                if (currentNode.tagname !== "!xml") {
                  textData = this.saveTextToParentTag(textData, currentNode, jPath, false);
                }
              }
              if (tagName !== xmlObj.tagname) {
                jPath += jPath ? "." + tagName : tagName;
              }
              const lastTag = currentNode;
              if (lastTag && this.options.unpairedTags.indexOf(lastTag.tagname) !== -1) {
                currentNode = this.tagsNodeStack.pop();
              }
              if (this.isItStopNode(this.options.stopNodes, jPath, tagName)) {
                let tagContent = "";
                if (tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1) {
                  i3 = result.closeIndex;
                } else if (this.options.unpairedTags.indexOf(tagName) !== -1) {
                  i3 = result.closeIndex;
                } else {
                  const result2 = this.readStopNodeData(xmlData, tagName, closeIndex + 1);
                  if (!result2)
                    throw new Error(`Unexpected end of ${tagName}`);
                  i3 = result2.i;
                  tagContent = result2.tagContent;
                }
                const childNode = new xmlNode(tagName);
                if (tagName !== tagExp && attrExpPresent) {
                  childNode[":@"] = this.buildAttributesMap(tagExp, jPath);
                }
                if (tagContent) {
                  tagContent = this.parseTextData(tagContent, tagName, jPath, true, attrExpPresent, true, true);
                }
                jPath = jPath.substr(0, jPath.lastIndexOf("."));
                childNode.add(this.options.textNodeName, tagContent);
                currentNode.addChild(childNode);
              } else {
                if (tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1) {
                  if (tagName[tagName.length - 1] === "/") {
                    tagName = tagName.substr(0, tagName.length - 1);
                    tagExp = tagName;
                  } else {
                    tagExp = tagExp.substr(0, tagExp.length - 1);
                  }
                  if (this.options.transformTagName) {
                    tagName = this.options.transformTagName(tagName);
                  }
                  const childNode = new xmlNode(tagName);
                  if (tagName !== tagExp && attrExpPresent) {
                    childNode[":@"] = this.buildAttributesMap(tagExp, jPath);
                  }
                  jPath = jPath.substr(0, jPath.lastIndexOf("."));
                  currentNode.addChild(childNode);
                } else {
                  const childNode = new xmlNode(tagName);
                  this.tagsNodeStack.push(currentNode);
                  if (tagName !== tagExp && attrExpPresent) {
                    childNode[":@"] = this.buildAttributesMap(tagExp, jPath);
                  }
                  currentNode.addChild(childNode);
                  currentNode = childNode;
                }
                textData = "";
                i3 = closeIndex;
              }
            }
          } else {
            textData += xmlData[i3];
          }
        }
        return xmlObj.child;
      };
      var replaceEntitiesValue = function(val) {
        if (this.options.processEntities) {
          for (let entityName in this.docTypeEntities) {
            const entity = this.docTypeEntities[entityName];
            val = val.replace(entity.regx, entity.val);
          }
          for (let entityName in this.lastEntities) {
            const entity = this.lastEntities[entityName];
            val = val.replace(entity.regex, entity.val);
          }
          if (this.options.htmlEntities) {
            for (let entityName in this.htmlEntities) {
              const entity = this.htmlEntities[entityName];
              val = val.replace(entity.regex, entity.val);
            }
          }
          val = val.replace(this.ampEntity.regex, this.ampEntity.val);
        }
        return val;
      };
      function saveTextToParentTag(textData, currentNode, jPath, isLeafNode) {
        if (textData) {
          if (isLeafNode === void 0)
            isLeafNode = Object.keys(currentNode.child).length === 0;
          textData = this.parseTextData(textData, currentNode.tagname, jPath, false, currentNode[":@"] ? Object.keys(currentNode[":@"]).length !== 0 : false, isLeafNode);
          if (textData !== void 0 && textData !== "")
            currentNode.add(this.options.textNodeName, textData);
          textData = "";
        }
        return textData;
      }
      function isItStopNode(stopNodes, jPath, currentTagName) {
        const allNodesExp = "*." + currentTagName;
        for (const stopNodePath in stopNodes) {
          const stopNodeExp = stopNodes[stopNodePath];
          if (allNodesExp === stopNodeExp || jPath === stopNodeExp)
            return true;
        }
        return false;
      }
      function tagExpWithClosingIndex(xmlData, i3, closingChar = ">") {
        let attrBoundary;
        let tagExp = "";
        for (let index = i3; index < xmlData.length; index++) {
          let ch = xmlData[index];
          if (attrBoundary) {
            if (ch === attrBoundary)
              attrBoundary = "";
          } else if (ch === '"' || ch === "'") {
            attrBoundary = ch;
          } else if (ch === closingChar[0]) {
            if (closingChar[1]) {
              if (xmlData[index + 1] === closingChar[1]) {
                return {
                  data: tagExp,
                  index
                };
              }
            } else {
              return {
                data: tagExp,
                index
              };
            }
          } else if (ch === "	") {
            ch = " ";
          }
          tagExp += ch;
        }
      }
      function findClosingIndex(xmlData, str, i3, errMsg) {
        const closingIndex = xmlData.indexOf(str, i3);
        if (closingIndex === -1) {
          throw new Error(errMsg);
        } else {
          return closingIndex + str.length - 1;
        }
      }
      function readTagExp(xmlData, i3, removeNSPrefix, closingChar = ">") {
        const result = tagExpWithClosingIndex(xmlData, i3 + 1, closingChar);
        if (!result)
          return;
        let tagExp = result.data;
        const closeIndex = result.index;
        const separatorIndex = tagExp.search(/\s/);
        let tagName = tagExp;
        let attrExpPresent = true;
        if (separatorIndex !== -1) {
          tagName = tagExp.substr(0, separatorIndex).replace(/\s\s*$/, "");
          tagExp = tagExp.substr(separatorIndex + 1);
        }
        if (removeNSPrefix) {
          const colonIndex = tagName.indexOf(":");
          if (colonIndex !== -1) {
            tagName = tagName.substr(colonIndex + 1);
            attrExpPresent = tagName !== result.data.substr(colonIndex + 1);
          }
        }
        return {
          tagName,
          tagExp,
          closeIndex,
          attrExpPresent
        };
      }
      function readStopNodeData(xmlData, tagName, i3) {
        const startIndex = i3;
        let openTagCount = 1;
        for (; i3 < xmlData.length; i3++) {
          if (xmlData[i3] === "<") {
            if (xmlData[i3 + 1] === "/") {
              const closeIndex = findClosingIndex(xmlData, ">", i3, `${tagName} is not closed`);
              let closeTagName = xmlData.substring(i3 + 2, closeIndex).trim();
              if (closeTagName === tagName) {
                openTagCount--;
                if (openTagCount === 0) {
                  return {
                    tagContent: xmlData.substring(startIndex, i3),
                    i: closeIndex
                  };
                }
              }
              i3 = closeIndex;
            } else if (xmlData[i3 + 1] === "?") {
              const closeIndex = findClosingIndex(xmlData, "?>", i3 + 1, "StopNode is not closed.");
              i3 = closeIndex;
            } else if (xmlData.substr(i3 + 1, 3) === "!--") {
              const closeIndex = findClosingIndex(xmlData, "-->", i3 + 3, "StopNode is not closed.");
              i3 = closeIndex;
            } else if (xmlData.substr(i3 + 1, 2) === "![") {
              const closeIndex = findClosingIndex(xmlData, "]]>", i3, "StopNode is not closed.") - 2;
              i3 = closeIndex;
            } else {
              const tagData = readTagExp(xmlData, i3, ">");
              if (tagData) {
                const openTagName = tagData && tagData.tagName;
                if (openTagName === tagName && tagData.tagExp[tagData.tagExp.length - 1] !== "/") {
                  openTagCount++;
                }
                i3 = tagData.closeIndex;
              }
            }
          }
        }
      }
      function parseValue(val, shouldParse, options) {
        if (shouldParse && typeof val === "string") {
          const newval = val.trim();
          if (newval === "true")
            return true;
          else if (newval === "false")
            return false;
          else
            return toNumber(val, options);
        } else {
          if (util.isExist(val)) {
            return val;
          } else {
            return "";
          }
        }
      }
      module2.exports = OrderedObjParser;
    }
  });

  // ../../node_modules/fast-xml-parser/src/xmlparser/node2json.js
  var require_node2json = __commonJS({
    "../../node_modules/fast-xml-parser/src/xmlparser/node2json.js"(exports) {
      "use strict";
      function prettify(node2, options) {
        return compress(node2, options);
      }
      function compress(arr, options, jPath) {
        let text;
        const compressedObj = {};
        for (let i3 = 0; i3 < arr.length; i3++) {
          const tagObj = arr[i3];
          const property = propName(tagObj);
          let newJpath = "";
          if (jPath === void 0)
            newJpath = property;
          else
            newJpath = jPath + "." + property;
          if (property === options.textNodeName) {
            if (text === void 0)
              text = tagObj[property];
            else
              text += "" + tagObj[property];
          } else if (property === void 0) {
            continue;
          } else if (tagObj[property]) {
            let val = compress(tagObj[property], options, newJpath);
            const isLeaf = isLeafTag(val, options);
            if (tagObj[":@"]) {
              assignAttributes(val, tagObj[":@"], newJpath, options);
            } else if (Object.keys(val).length === 1 && val[options.textNodeName] !== void 0 && !options.alwaysCreateTextNode) {
              val = val[options.textNodeName];
            } else if (Object.keys(val).length === 0) {
              if (options.alwaysCreateTextNode)
                val[options.textNodeName] = "";
              else
                val = "";
            }
            if (compressedObj[property] !== void 0 && compressedObj.hasOwnProperty(property)) {
              if (!Array.isArray(compressedObj[property])) {
                compressedObj[property] = [compressedObj[property]];
              }
              compressedObj[property].push(val);
            } else {
              if (options.isArray(property, newJpath, isLeaf)) {
                compressedObj[property] = [val];
              } else {
                compressedObj[property] = val;
              }
            }
          }
        }
        if (typeof text === "string") {
          if (text.length > 0)
            compressedObj[options.textNodeName] = text;
        } else if (text !== void 0)
          compressedObj[options.textNodeName] = text;
        return compressedObj;
      }
      function propName(obj) {
        const keys = Object.keys(obj);
        for (let i3 = 0; i3 < keys.length; i3++) {
          const key = keys[i3];
          if (key !== ":@")
            return key;
        }
      }
      function assignAttributes(obj, attrMap, jpath, options) {
        if (attrMap) {
          const keys = Object.keys(attrMap);
          const len2 = keys.length;
          for (let i3 = 0; i3 < len2; i3++) {
            const atrrName = keys[i3];
            if (options.isArray(atrrName, jpath + "." + atrrName, true, true)) {
              obj[atrrName] = [attrMap[atrrName]];
            } else {
              obj[atrrName] = attrMap[atrrName];
            }
          }
        }
      }
      function isLeafTag(obj, options) {
        const propCount = Object.keys(obj).length;
        if (propCount === 0 || propCount === 1 && obj[options.textNodeName])
          return true;
        return false;
      }
      exports.prettify = prettify;
    }
  });

  // ../../node_modules/fast-xml-parser/src/xmlparser/XMLParser.js
  var require_XMLParser = __commonJS({
    "../../node_modules/fast-xml-parser/src/xmlparser/XMLParser.js"(exports, module2) {
      var {
        buildOptions
      } = require_OptionsBuilder();
      var OrderedObjParser = require_OrderedObjParser();
      var {
        prettify
      } = require_node2json();
      var validator = require_validator();
      var XMLParser = class {
        constructor(options) {
          this.externalEntities = {};
          this.options = buildOptions(options);
        }
        parse(xmlData, validationOption) {
          if (typeof xmlData === "string") {
          } else if (xmlData.toString) {
            xmlData = xmlData.toString();
          } else {
            throw new Error("XML data is accepted in String or Bytes[] form.");
          }
          if (validationOption) {
            if (validationOption === true)
              validationOption = {};
            const result = validator.validate(xmlData, validationOption);
            if (result !== true) {
              throw Error(`${result.err.msg}:${result.err.line}:${result.err.col}`);
            }
          }
          const orderedObjParser = new OrderedObjParser(this.options);
          orderedObjParser.addExternalEntities(this.externalEntities);
          const orderedResult = orderedObjParser.parseXml(xmlData);
          if (this.options.preserveOrder || orderedResult === void 0)
            return orderedResult;
          else
            return prettify(orderedResult, this.options);
        }
        addEntity(key, value) {
          if (value.indexOf("&") !== -1) {
            throw new Error("Entity value can't have '&'");
          } else if (key.indexOf("&") !== -1 || key.indexOf(";") !== -1) {
            throw new Error("An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'");
          } else if (value === "&") {
            throw new Error("An entity with value '&' is not permitted");
          } else {
            this.externalEntities[key] = value;
          }
        }
      };
      module2.exports = XMLParser;
    }
  });

  // ../../node_modules/fast-xml-parser/src/xmlbuilder/orderedJs2Xml.js
  var require_orderedJs2Xml = __commonJS({
    "../../node_modules/fast-xml-parser/src/xmlbuilder/orderedJs2Xml.js"(exports, module2) {
      var EOL = "\n";
      function toXml(jArray, options) {
        let indentation = "";
        if (options.format && options.indentBy.length > 0) {
          indentation = EOL;
        }
        return arrToStr(jArray, options, "", indentation);
      }
      function arrToStr(arr, options, jPath, indentation) {
        let xmlStr = "";
        let isPreviousElementTag = false;
        for (let i3 = 0; i3 < arr.length; i3++) {
          const tagObj = arr[i3];
          const tagName = propName(tagObj);
          let newJPath = "";
          if (jPath.length === 0)
            newJPath = tagName;
          else
            newJPath = `${jPath}.${tagName}`;
          if (tagName === options.textNodeName) {
            let tagText = tagObj[tagName];
            if (!isStopNode(newJPath, options)) {
              tagText = options.tagValueProcessor(tagName, tagText);
              tagText = replaceEntitiesValue(tagText, options);
            }
            if (isPreviousElementTag) {
              xmlStr += indentation;
            }
            xmlStr += tagText;
            isPreviousElementTag = false;
            continue;
          } else if (tagName === options.cdataPropName) {
            if (isPreviousElementTag) {
              xmlStr += indentation;
            }
            xmlStr += `<![CDATA[${tagObj[tagName][0][options.textNodeName]}]]>`;
            isPreviousElementTag = false;
            continue;
          } else if (tagName === options.commentPropName) {
            xmlStr += indentation + `<!--${tagObj[tagName][0][options.textNodeName]}-->`;
            isPreviousElementTag = true;
            continue;
          } else if (tagName[0] === "?") {
            const attStr2 = attr_to_str(tagObj[":@"], options);
            const tempInd = tagName === "?xml" ? "" : indentation;
            let piTextNodeName = tagObj[tagName][0][options.textNodeName];
            piTextNodeName = piTextNodeName.length !== 0 ? " " + piTextNodeName : "";
            xmlStr += tempInd + `<${tagName}${piTextNodeName}${attStr2}?>`;
            isPreviousElementTag = true;
            continue;
          }
          let newIdentation = indentation;
          if (newIdentation !== "") {
            newIdentation += options.indentBy;
          }
          const attStr = attr_to_str(tagObj[":@"], options);
          const tagStart = indentation + `<${tagName}${attStr}`;
          const tagValue = arrToStr(tagObj[tagName], options, newJPath, newIdentation);
          if (options.unpairedTags.indexOf(tagName) !== -1) {
            if (options.suppressUnpairedNode)
              xmlStr += tagStart + ">";
            else
              xmlStr += tagStart + "/>";
          } else if ((!tagValue || tagValue.length === 0) && options.suppressEmptyNode) {
            xmlStr += tagStart + "/>";
          } else if (tagValue && tagValue.endsWith(">")) {
            xmlStr += tagStart + `>${tagValue}${indentation}</${tagName}>`;
          } else {
            xmlStr += tagStart + ">";
            if (tagValue && indentation !== "" && (tagValue.includes("/>") || tagValue.includes("</"))) {
              xmlStr += indentation + options.indentBy + tagValue + indentation;
            } else {
              xmlStr += tagValue;
            }
            xmlStr += `</${tagName}>`;
          }
          isPreviousElementTag = true;
        }
        return xmlStr;
      }
      function propName(obj) {
        const keys = Object.keys(obj);
        for (let i3 = 0; i3 < keys.length; i3++) {
          const key = keys[i3];
          if (key !== ":@")
            return key;
        }
      }
      function attr_to_str(attrMap, options) {
        let attrStr = "";
        if (attrMap && !options.ignoreAttributes) {
          for (let attr in attrMap) {
            let attrVal = options.attributeValueProcessor(attr, attrMap[attr]);
            attrVal = replaceEntitiesValue(attrVal, options);
            if (attrVal === true && options.suppressBooleanAttributes) {
              attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}`;
            } else {
              attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}="${attrVal}"`;
            }
          }
        }
        return attrStr;
      }
      function isStopNode(jPath, options) {
        jPath = jPath.substr(0, jPath.length - options.textNodeName.length - 1);
        let tagName = jPath.substr(jPath.lastIndexOf(".") + 1);
        for (let index in options.stopNodes) {
          if (options.stopNodes[index] === jPath || options.stopNodes[index] === "*." + tagName)
            return true;
        }
        return false;
      }
      function replaceEntitiesValue(textValue, options) {
        if (textValue && textValue.length > 0 && options.processEntities) {
          for (let i3 = 0; i3 < options.entities.length; i3++) {
            const entity = options.entities[i3];
            textValue = textValue.replace(entity.regex, entity.val);
          }
        }
        return textValue;
      }
      module2.exports = toXml;
    }
  });

  // ../../node_modules/fast-xml-parser/src/xmlbuilder/json2xml.js
  var require_json2xml = __commonJS({
    "../../node_modules/fast-xml-parser/src/xmlbuilder/json2xml.js"(exports, module2) {
      "use strict";
      var buildFromOrderedJs = require_orderedJs2Xml();
      var defaultOptions = {
        attributeNamePrefix: "@_",
        attributesGroupName: false,
        textNodeName: "#text",
        ignoreAttributes: true,
        cdataPropName: false,
        format: false,
        indentBy: "  ",
        suppressEmptyNode: false,
        suppressUnpairedNode: true,
        suppressBooleanAttributes: true,
        tagValueProcessor: function(key, a2) {
          return a2;
        },
        attributeValueProcessor: function(attrName, a2) {
          return a2;
        },
        preserveOrder: false,
        commentPropName: false,
        unpairedTags: [],
        entities: [
          {
            regex: new RegExp("&", "g"),
            val: "&amp;"
          },
          {
            regex: new RegExp(">", "g"),
            val: "&gt;"
          },
          {
            regex: new RegExp("<", "g"),
            val: "&lt;"
          },
          {
            regex: new RegExp("'", "g"),
            val: "&apos;"
          },
          {
            regex: new RegExp('"', "g"),
            val: "&quot;"
          }
        ],
        processEntities: true,
        stopNodes: []
      };
      function Builder(options) {
        this.options = Object.assign({}, defaultOptions, options);
        if (this.options.ignoreAttributes || this.options.attributesGroupName) {
          this.isAttribute = function() {
            return false;
          };
        } else {
          this.attrPrefixLen = this.options.attributeNamePrefix.length;
          this.isAttribute = isAttribute;
        }
        this.processTextOrObjNode = processTextOrObjNode;
        if (this.options.format) {
          this.indentate = indentate;
          this.tagEndChar = ">\n";
          this.newLine = "\n";
        } else {
          this.indentate = function() {
            return "";
          };
          this.tagEndChar = ">";
          this.newLine = "";
        }
      }
      Builder.prototype.build = function(jObj) {
        if (this.options.preserveOrder) {
          return buildFromOrderedJs(jObj, this.options);
        } else {
          if (Array.isArray(jObj) && this.options.arrayNodeName && this.options.arrayNodeName.length > 1) {
            jObj = {
              [this.options.arrayNodeName]: jObj
            };
          }
          return this.j2x(jObj, 0).val;
        }
      };
      Builder.prototype.j2x = function(jObj, level) {
        let attrStr = "";
        let val = "";
        for (let key in jObj) {
          if (typeof jObj[key] === "undefined") {
          } else if (jObj[key] === null) {
            if (key[0] === "?")
              val += this.indentate(level) + "<" + key + "?" + this.tagEndChar;
            else
              val += this.indentate(level) + "<" + key + "/" + this.tagEndChar;
          } else if (jObj[key] instanceof Date) {
            val += this.buildTextValNode(jObj[key], key, "", level);
          } else if (typeof jObj[key] !== "object") {
            const attr = this.isAttribute(key);
            if (attr) {
              attrStr += this.buildAttrPairStr(attr, "" + jObj[key]);
            } else {
              if (key === this.options.textNodeName) {
                let newval = this.options.tagValueProcessor(key, "" + jObj[key]);
                val += this.replaceEntitiesValue(newval);
              } else {
                val += this.buildTextValNode(jObj[key], key, "", level);
              }
            }
          } else if (Array.isArray(jObj[key])) {
            const arrLen = jObj[key].length;
            for (let j = 0; j < arrLen; j++) {
              const item = jObj[key][j];
              if (typeof item === "undefined") {
              } else if (item === null) {
                if (key[0] === "?")
                  val += this.indentate(level) + "<" + key + "?" + this.tagEndChar;
                else
                  val += this.indentate(level) + "<" + key + "/" + this.tagEndChar;
              } else if (typeof item === "object") {
                val += this.processTextOrObjNode(item, key, level);
              } else {
                val += this.buildTextValNode(item, key, "", level);
              }
            }
          } else {
            if (this.options.attributesGroupName && key === this.options.attributesGroupName) {
              const Ks = Object.keys(jObj[key]);
              const L = Ks.length;
              for (let j = 0; j < L; j++) {
                attrStr += this.buildAttrPairStr(Ks[j], "" + jObj[key][Ks[j]]);
              }
            } else {
              val += this.processTextOrObjNode(jObj[key], key, level);
            }
          }
        }
        return {
          attrStr,
          val
        };
      };
      Builder.prototype.buildAttrPairStr = function(attrName, val) {
        val = this.options.attributeValueProcessor(attrName, "" + val);
        val = this.replaceEntitiesValue(val);
        if (this.options.suppressBooleanAttributes && val === "true") {
          return " " + attrName;
        } else
          return " " + attrName + '="' + val + '"';
      };
      function processTextOrObjNode(object, key, level) {
        const result = this.j2x(object, level + 1);
        if (object[this.options.textNodeName] !== void 0 && Object.keys(object).length === 1) {
          return this.buildTextValNode(object[this.options.textNodeName], key, result.attrStr, level);
        } else {
          return this.buildObjectNode(result.val, key, result.attrStr, level);
        }
      }
      Builder.prototype.buildObjectNode = function(val, key, attrStr, level) {
        if (val === "") {
          if (key[0] === "?")
            return this.indentate(level) + "<" + key + attrStr + "?" + this.tagEndChar;
          else {
            return this.indentate(level) + "<" + key + attrStr + this.closeTag(key) + this.tagEndChar;
          }
        } else {
          let tagEndExp = "</" + key + this.tagEndChar;
          let piClosingChar = "";
          if (key[0] === "?") {
            piClosingChar = "?";
            tagEndExp = "";
          }
          if (attrStr && val.indexOf("<") === -1) {
            return this.indentate(level) + "<" + key + attrStr + piClosingChar + ">" + val + tagEndExp;
          } else if (this.options.commentPropName !== false && key === this.options.commentPropName && piClosingChar.length === 0) {
            return this.indentate(level) + `<!--${val}-->` + this.newLine;
          } else {
            return this.indentate(level) + "<" + key + attrStr + piClosingChar + this.tagEndChar + val + this.indentate(level) + tagEndExp;
          }
        }
      };
      Builder.prototype.closeTag = function(key) {
        let closeTag = "";
        if (this.options.unpairedTags.indexOf(key) !== -1) {
          if (!this.options.suppressUnpairedNode)
            closeTag = "/";
        } else if (this.options.suppressEmptyNode) {
          closeTag = "/";
        } else {
          closeTag = `></${key}`;
        }
        return closeTag;
      };
      Builder.prototype.buildTextValNode = function(val, key, attrStr, level) {
        if (this.options.cdataPropName !== false && key === this.options.cdataPropName) {
          return this.indentate(level) + `<![CDATA[${val}]]>` + this.newLine;
        } else if (this.options.commentPropName !== false && key === this.options.commentPropName) {
          return this.indentate(level) + `<!--${val}-->` + this.newLine;
        } else if (key[0] === "?") {
          return this.indentate(level) + "<" + key + attrStr + "?" + this.tagEndChar;
        } else {
          let textValue = this.options.tagValueProcessor(key, val);
          textValue = this.replaceEntitiesValue(textValue);
          if (textValue === "") {
            return this.indentate(level) + "<" + key + attrStr + this.closeTag(key) + this.tagEndChar;
          } else {
            return this.indentate(level) + "<" + key + attrStr + ">" + textValue + "</" + key + this.tagEndChar;
          }
        }
      };
      Builder.prototype.replaceEntitiesValue = function(textValue) {
        if (textValue && textValue.length > 0 && this.options.processEntities) {
          for (let i3 = 0; i3 < this.options.entities.length; i3++) {
            const entity = this.options.entities[i3];
            textValue = textValue.replace(entity.regex, entity.val);
          }
        }
        return textValue;
      };
      function indentate(level) {
        return this.options.indentBy.repeat(level);
      }
      function isAttribute(name10) {
        if (name10.startsWith(this.options.attributeNamePrefix)) {
          return name10.substr(this.attrPrefixLen);
        } else {
          return false;
        }
      }
      module2.exports = Builder;
    }
  });

  // ../../node_modules/fast-xml-parser/src/fxp.js
  var require_fxp = __commonJS({
    "../../node_modules/fast-xml-parser/src/fxp.js"(exports, module2) {
      "use strict";
      var validator = require_validator();
      var XMLParser = require_XMLParser();
      var XMLBuilder = require_json2xml();
      module2.exports = {
        XMLParser,
        XMLValidator: validator,
        XMLBuilder
      };
    }
  });

  // (disabled):../../node_modules/@loaders.gl/worker-utils/dist/esm/lib/node/require-utils.node
  var require_require_utils = __commonJS({
    "(disabled):../../node_modules/@loaders.gl/worker-utils/dist/esm/lib/node/require-utils.node"() {
    }
  });

  // ../../node_modules/long/dist/long.js
  var require_long = __commonJS({
    "../../node_modules/long/dist/long.js"(exports, module2) {
      (function(global2, factory) {
        if (typeof define === "function" && define["amd"])
          define([], factory);
        else if (typeof __require === "function" && typeof module2 === "object" && module2 && module2["exports"])
          module2["exports"] = factory();
        else
          (global2["dcodeIO"] = global2["dcodeIO"] || {})["Long"] = factory();
      })(exports, function() {
        "use strict";
        function Long3(low, high, unsigned) {
          this.low = low | 0;
          this.high = high | 0;
          this.unsigned = !!unsigned;
        }
        Long3.prototype.__isLong__;
        Object.defineProperty(Long3.prototype, "__isLong__", {
          value: true,
          enumerable: false,
          configurable: false
        });
        function isLong(obj) {
          return (obj && obj["__isLong__"]) === true;
        }
        Long3.isLong = isLong;
        var INT_CACHE = {};
        var UINT_CACHE = {};
        function fromInt(value, unsigned) {
          var obj, cachedObj, cache2;
          if (unsigned) {
            value >>>= 0;
            if (cache2 = 0 <= value && value < 256) {
              cachedObj = UINT_CACHE[value];
              if (cachedObj)
                return cachedObj;
            }
            obj = fromBits(value, (value | 0) < 0 ? -1 : 0, true);
            if (cache2)
              UINT_CACHE[value] = obj;
            return obj;
          } else {
            value |= 0;
            if (cache2 = -128 <= value && value < 128) {
              cachedObj = INT_CACHE[value];
              if (cachedObj)
                return cachedObj;
            }
            obj = fromBits(value, value < 0 ? -1 : 0, false);
            if (cache2)
              INT_CACHE[value] = obj;
            return obj;
          }
        }
        Long3.fromInt = fromInt;
        function fromNumber(value, unsigned) {
          if (isNaN(value) || !isFinite(value))
            return unsigned ? UZERO : ZERO4;
          if (unsigned) {
            if (value < 0)
              return UZERO;
            if (value >= TWO_PWR_64_DBL)
              return MAX_UNSIGNED_VALUE;
          } else {
            if (value <= -TWO_PWR_63_DBL)
              return MIN_VALUE;
            if (value + 1 >= TWO_PWR_63_DBL)
              return MAX_VALUE;
          }
          if (value < 0)
            return fromNumber(-value, unsigned).neg();
          return fromBits(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0, unsigned);
        }
        Long3.fromNumber = fromNumber;
        function fromBits(lowBits, highBits, unsigned) {
          return new Long3(lowBits, highBits, unsigned);
        }
        Long3.fromBits = fromBits;
        var pow_dbl = Math.pow;
        function fromString(str, unsigned, radix) {
          if (str.length === 0)
            throw Error("empty string");
          if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity")
            return ZERO4;
          if (typeof unsigned === "number") {
            radix = unsigned, unsigned = false;
          } else {
            unsigned = !!unsigned;
          }
          radix = radix || 10;
          if (radix < 2 || 36 < radix)
            throw RangeError("radix");
          var p2;
          if ((p2 = str.indexOf("-")) > 0)
            throw Error("interior hyphen");
          else if (p2 === 0) {
            return fromString(str.substring(1), unsigned, radix).neg();
          }
          var radixToPower = fromNumber(pow_dbl(radix, 8));
          var result = ZERO4;
          for (var i3 = 0; i3 < str.length; i3 += 8) {
            var size = Math.min(8, str.length - i3), value = parseInt(str.substring(i3, i3 + size), radix);
            if (size < 8) {
              var power = fromNumber(pow_dbl(radix, size));
              result = result.mul(power).add(fromNumber(value));
            } else {
              result = result.mul(radixToPower);
              result = result.add(fromNumber(value));
            }
          }
          result.unsigned = unsigned;
          return result;
        }
        Long3.fromString = fromString;
        function fromValue(val) {
          if (val instanceof Long3)
            return val;
          if (typeof val === "number")
            return fromNumber(val);
          if (typeof val === "string")
            return fromString(val);
          return fromBits(val.low, val.high, val.unsigned);
        }
        Long3.fromValue = fromValue;
        var TWO_PWR_16_DBL = 1 << 16;
        var TWO_PWR_24_DBL = 1 << 24;
        var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;
        var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;
        var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;
        var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);
        var ZERO4 = fromInt(0);
        Long3.ZERO = ZERO4;
        var UZERO = fromInt(0, true);
        Long3.UZERO = UZERO;
        var ONE = fromInt(1);
        Long3.ONE = ONE;
        var UONE = fromInt(1, true);
        Long3.UONE = UONE;
        var NEG_ONE = fromInt(-1);
        Long3.NEG_ONE = NEG_ONE;
        var MAX_VALUE = fromBits(4294967295 | 0, 2147483647 | 0, false);
        Long3.MAX_VALUE = MAX_VALUE;
        var MAX_UNSIGNED_VALUE = fromBits(4294967295 | 0, 4294967295 | 0, true);
        Long3.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;
        var MIN_VALUE = fromBits(0, 2147483648 | 0, false);
        Long3.MIN_VALUE = MIN_VALUE;
        var LongPrototype = Long3.prototype;
        LongPrototype.toInt = function toInt() {
          return this.unsigned ? this.low >>> 0 : this.low;
        };
        LongPrototype.toNumber = function toNumber() {
          if (this.unsigned)
            return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);
          return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
        };
        LongPrototype.toString = function toString(radix) {
          radix = radix || 10;
          if (radix < 2 || 36 < radix)
            throw RangeError("radix");
          if (this.isZero())
            return "0";
          if (this.isNegative()) {
            if (this.eq(MIN_VALUE)) {
              var radixLong = fromNumber(radix), div = this.div(radixLong), rem1 = div.mul(radixLong).sub(this);
              return div.toString(radix) + rem1.toInt().toString(radix);
            } else
              return "-" + this.neg().toString(radix);
          }
          var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned), rem = this;
          var result = "";
          while (true) {
            var remDiv = rem.div(radixToPower), intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0, digits = intval.toString(radix);
            rem = remDiv;
            if (rem.isZero())
              return digits + result;
            else {
              while (digits.length < 6)
                digits = "0" + digits;
              result = "" + digits + result;
            }
          }
        };
        LongPrototype.getHighBits = function getHighBits() {
          return this.high;
        };
        LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
          return this.high >>> 0;
        };
        LongPrototype.getLowBits = function getLowBits() {
          return this.low;
        };
        LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
          return this.low >>> 0;
        };
        LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
          if (this.isNegative())
            return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
          var val = this.high != 0 ? this.high : this.low;
          for (var bit = 31; bit > 0; bit--)
            if ((val & 1 << bit) != 0)
              break;
          return this.high != 0 ? bit + 33 : bit + 1;
        };
        LongPrototype.isZero = function isZero() {
          return this.high === 0 && this.low === 0;
        };
        LongPrototype.isNegative = function isNegative() {
          return !this.unsigned && this.high < 0;
        };
        LongPrototype.isPositive = function isPositive() {
          return this.unsigned || this.high >= 0;
        };
        LongPrototype.isOdd = function isOdd() {
          return (this.low & 1) === 1;
        };
        LongPrototype.isEven = function isEven() {
          return (this.low & 1) === 0;
        };
        LongPrototype.equals = function equals4(other) {
          if (!isLong(other))
            other = fromValue(other);
          if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1)
            return false;
          return this.high === other.high && this.low === other.low;
        };
        LongPrototype.eq = LongPrototype.equals;
        LongPrototype.notEquals = function notEquals(other) {
          return !this.eq(other);
        };
        LongPrototype.neq = LongPrototype.notEquals;
        LongPrototype.lessThan = function lessThan(other) {
          return this.comp(other) < 0;
        };
        LongPrototype.lt = LongPrototype.lessThan;
        LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
          return this.comp(other) <= 0;
        };
        LongPrototype.lte = LongPrototype.lessThanOrEqual;
        LongPrototype.greaterThan = function greaterThan(other) {
          return this.comp(other) > 0;
        };
        LongPrototype.gt = LongPrototype.greaterThan;
        LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
          return this.comp(other) >= 0;
        };
        LongPrototype.gte = LongPrototype.greaterThanOrEqual;
        LongPrototype.compare = function compare(other) {
          if (!isLong(other))
            other = fromValue(other);
          if (this.eq(other))
            return 0;
          var thisNeg = this.isNegative(), otherNeg = other.isNegative();
          if (thisNeg && !otherNeg)
            return -1;
          if (!thisNeg && otherNeg)
            return 1;
          if (!this.unsigned)
            return this.sub(other).isNegative() ? -1 : 1;
          return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;
        };
        LongPrototype.comp = LongPrototype.compare;
        LongPrototype.negate = function negate() {
          if (!this.unsigned && this.eq(MIN_VALUE))
            return MIN_VALUE;
          return this.not().add(ONE);
        };
        LongPrototype.neg = LongPrototype.negate;
        LongPrototype.add = function add3(addend) {
          if (!isLong(addend))
            addend = fromValue(addend);
          var a48 = this.high >>> 16;
          var a32 = this.high & 65535;
          var a16 = this.low >>> 16;
          var a00 = this.low & 65535;
          var b48 = addend.high >>> 16;
          var b32 = addend.high & 65535;
          var b16 = addend.low >>> 16;
          var b00 = addend.low & 65535;
          var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
          c00 += a00 + b00;
          c16 += c00 >>> 16;
          c00 &= 65535;
          c16 += a16 + b16;
          c32 += c16 >>> 16;
          c16 &= 65535;
          c32 += a32 + b32;
          c48 += c32 >>> 16;
          c32 &= 65535;
          c48 += a48 + b48;
          c48 &= 65535;
          return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
        };
        LongPrototype.subtract = function subtract(subtrahend) {
          if (!isLong(subtrahend))
            subtrahend = fromValue(subtrahend);
          return this.add(subtrahend.neg());
        };
        LongPrototype.sub = LongPrototype.subtract;
        LongPrototype.multiply = function multiply4(multiplier) {
          if (this.isZero())
            return ZERO4;
          if (!isLong(multiplier))
            multiplier = fromValue(multiplier);
          if (multiplier.isZero())
            return ZERO4;
          if (this.eq(MIN_VALUE))
            return multiplier.isOdd() ? MIN_VALUE : ZERO4;
          if (multiplier.eq(MIN_VALUE))
            return this.isOdd() ? MIN_VALUE : ZERO4;
          if (this.isNegative()) {
            if (multiplier.isNegative())
              return this.neg().mul(multiplier.neg());
            else
              return this.neg().mul(multiplier).neg();
          } else if (multiplier.isNegative())
            return this.mul(multiplier.neg()).neg();
          if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))
            return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);
          var a48 = this.high >>> 16;
          var a32 = this.high & 65535;
          var a16 = this.low >>> 16;
          var a00 = this.low & 65535;
          var b48 = multiplier.high >>> 16;
          var b32 = multiplier.high & 65535;
          var b16 = multiplier.low >>> 16;
          var b00 = multiplier.low & 65535;
          var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
          c00 += a00 * b00;
          c16 += c00 >>> 16;
          c00 &= 65535;
          c16 += a16 * b00;
          c32 += c16 >>> 16;
          c16 &= 65535;
          c16 += a00 * b16;
          c32 += c16 >>> 16;
          c16 &= 65535;
          c32 += a32 * b00;
          c48 += c32 >>> 16;
          c32 &= 65535;
          c32 += a16 * b16;
          c48 += c32 >>> 16;
          c32 &= 65535;
          c32 += a00 * b32;
          c48 += c32 >>> 16;
          c32 &= 65535;
          c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
          c48 &= 65535;
          return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
        };
        LongPrototype.mul = LongPrototype.multiply;
        LongPrototype.divide = function divide(divisor) {
          if (!isLong(divisor))
            divisor = fromValue(divisor);
          if (divisor.isZero())
            throw Error("division by zero");
          if (this.isZero())
            return this.unsigned ? UZERO : ZERO4;
          var approx, rem, res;
          if (!this.unsigned) {
            if (this.eq(MIN_VALUE)) {
              if (divisor.eq(ONE) || divisor.eq(NEG_ONE))
                return MIN_VALUE;
              else if (divisor.eq(MIN_VALUE))
                return ONE;
              else {
                var halfThis = this.shr(1);
                approx = halfThis.div(divisor).shl(1);
                if (approx.eq(ZERO4)) {
                  return divisor.isNegative() ? ONE : NEG_ONE;
                } else {
                  rem = this.sub(divisor.mul(approx));
                  res = approx.add(rem.div(divisor));
                  return res;
                }
              }
            } else if (divisor.eq(MIN_VALUE))
              return this.unsigned ? UZERO : ZERO4;
            if (this.isNegative()) {
              if (divisor.isNegative())
                return this.neg().div(divisor.neg());
              return this.neg().div(divisor).neg();
            } else if (divisor.isNegative())
              return this.div(divisor.neg()).neg();
            res = ZERO4;
          } else {
            if (!divisor.unsigned)
              divisor = divisor.toUnsigned();
            if (divisor.gt(this))
              return UZERO;
            if (divisor.gt(this.shru(1)))
              return UONE;
            res = UZERO;
          }
          rem = this;
          while (rem.gte(divisor)) {
            approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));
            var log22 = Math.ceil(Math.log(approx) / Math.LN2), delta = log22 <= 48 ? 1 : pow_dbl(2, log22 - 48), approxRes = fromNumber(approx), approxRem = approxRes.mul(divisor);
            while (approxRem.isNegative() || approxRem.gt(rem)) {
              approx -= delta;
              approxRes = fromNumber(approx, this.unsigned);
              approxRem = approxRes.mul(divisor);
            }
            if (approxRes.isZero())
              approxRes = ONE;
            res = res.add(approxRes);
            rem = rem.sub(approxRem);
          }
          return res;
        };
        LongPrototype.div = LongPrototype.divide;
        LongPrototype.modulo = function modulo(divisor) {
          if (!isLong(divisor))
            divisor = fromValue(divisor);
          return this.sub(this.div(divisor).mul(divisor));
        };
        LongPrototype.mod = LongPrototype.modulo;
        LongPrototype.not = function not() {
          return fromBits(~this.low, ~this.high, this.unsigned);
        };
        LongPrototype.and = function and(other) {
          if (!isLong(other))
            other = fromValue(other);
          return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
        };
        LongPrototype.or = function or(other) {
          if (!isLong(other))
            other = fromValue(other);
          return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
        };
        LongPrototype.xor = function xor(other) {
          if (!isLong(other))
            other = fromValue(other);
          return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
        };
        LongPrototype.shiftLeft = function shiftLeft(numBits) {
          if (isLong(numBits))
            numBits = numBits.toInt();
          if ((numBits &= 63) === 0)
            return this;
          else if (numBits < 32)
            return fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);
          else
            return fromBits(0, this.low << numBits - 32, this.unsigned);
        };
        LongPrototype.shl = LongPrototype.shiftLeft;
        LongPrototype.shiftRight = function shiftRight(numBits) {
          if (isLong(numBits))
            numBits = numBits.toInt();
          if ((numBits &= 63) === 0)
            return this;
          else if (numBits < 32)
            return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);
          else
            return fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);
        };
        LongPrototype.shr = LongPrototype.shiftRight;
        LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
          if (isLong(numBits))
            numBits = numBits.toInt();
          numBits &= 63;
          if (numBits === 0)
            return this;
          else {
            var high = this.high;
            if (numBits < 32) {
              var low = this.low;
              return fromBits(low >>> numBits | high << 32 - numBits, high >>> numBits, this.unsigned);
            } else if (numBits === 32)
              return fromBits(high, 0, this.unsigned);
            else
              return fromBits(high >>> numBits - 32, 0, this.unsigned);
          }
        };
        LongPrototype.shru = LongPrototype.shiftRightUnsigned;
        LongPrototype.toSigned = function toSigned() {
          if (!this.unsigned)
            return this;
          return fromBits(this.low, this.high, false);
        };
        LongPrototype.toUnsigned = function toUnsigned() {
          if (this.unsigned)
            return this;
          return fromBits(this.low, this.high, true);
        };
        LongPrototype.toBytes = function(le) {
          return le ? this.toBytesLE() : this.toBytesBE();
        };
        LongPrototype.toBytesLE = function() {
          var hi = this.high, lo = this.low;
          return [
            lo & 255,
            lo >>> 8 & 255,
            lo >>> 16 & 255,
            lo >>> 24 & 255,
            hi & 255,
            hi >>> 8 & 255,
            hi >>> 16 & 255,
            hi >>> 24 & 255
          ];
        };
        LongPrototype.toBytesBE = function() {
          var hi = this.high, lo = this.low;
          return [
            hi >>> 24 & 255,
            hi >>> 16 & 255,
            hi >>> 8 & 255,
            hi & 255,
            lo >>> 24 & 255,
            lo >>> 16 & 255,
            lo >>> 8 & 255,
            lo & 255
          ];
        };
        return Long3;
      });
    }
  });

  // external-global-plugin:h3-js
  var require_h3_js = __commonJS({
    "external-global-plugin:h3-js"(exports, module2) {
      module2.exports = globalThis.h3 || {};
    }
  });

  // external-global-plugin:@luma.gl/core
  var require_core2 = __commonJS({
    "external-global-plugin:@luma.gl/core"(exports, module2) {
      module2.exports = globalThis.luma;
    }
  });

  // external-global-plugin:@deck.gl/mesh-layers
  var require_mesh_layers = __commonJS({
    "external-global-plugin:@deck.gl/mesh-layers"(exports, module2) {
      module2.exports = globalThis.deck;
    }
  });

  // external-global-plugin:@loaders.gl/core
  var require_core3 = __commonJS({
    "external-global-plugin:@loaders.gl/core"(exports, module2) {
      module2.exports = globalThis.loaders;
    }
  });

  // external-global-plugin:@deck.gl/extensions
  var require_extensions = __commonJS({
    "external-global-plugin:@deck.gl/extensions"(exports, module2) {
      module2.exports = globalThis.deck;
    }
  });

  // ../../node_modules/pbf/node_modules/ieee754/index.js
  var require_ieee754 = __commonJS({
    "../../node_modules/pbf/node_modules/ieee754/index.js"(exports) {
      exports.read = function(buffer, offset, isLE, mLen, nBytes) {
        var e, m;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var nBits = -7;
        var i3 = isLE ? nBytes - 1 : 0;
        var d = isLE ? -1 : 1;
        var s2 = buffer[offset + i3];
        i3 += d;
        e = s2 & (1 << -nBits) - 1;
        s2 >>= -nBits;
        nBits += eLen;
        for (; nBits > 0; e = e * 256 + buffer[offset + i3], i3 += d, nBits -= 8) {
        }
        m = e & (1 << -nBits) - 1;
        e >>= -nBits;
        nBits += mLen;
        for (; nBits > 0; m = m * 256 + buffer[offset + i3], i3 += d, nBits -= 8) {
        }
        if (e === 0) {
          e = 1 - eBias;
        } else if (e === eMax) {
          return m ? NaN : (s2 ? -1 : 1) * Infinity;
        } else {
          m = m + Math.pow(2, mLen);
          e = e - eBias;
        }
        return (s2 ? -1 : 1) * m * Math.pow(2, e - mLen);
      };
      exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
        var e, m, c;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
        var i3 = isLE ? 0 : nBytes - 1;
        var d = isLE ? 1 : -1;
        var s2 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
        value = Math.abs(value);
        if (isNaN(value) || value === Infinity) {
          m = isNaN(value) ? 1 : 0;
          e = eMax;
        } else {
          e = Math.floor(Math.log(value) / Math.LN2);
          if (value * (c = Math.pow(2, -e)) < 1) {
            e--;
            c *= 2;
          }
          if (e + eBias >= 1) {
            value += rt / c;
          } else {
            value += rt * Math.pow(2, 1 - eBias);
          }
          if (value * c >= 2) {
            e++;
            c /= 2;
          }
          if (e + eBias >= eMax) {
            m = 0;
            e = eMax;
          } else if (e + eBias >= 1) {
            m = (value * c - 1) * Math.pow(2, mLen);
            e = e + eBias;
          } else {
            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e = 0;
          }
        }
        for (; mLen >= 8; buffer[offset + i3] = m & 255, i3 += d, m /= 256, mLen -= 8) {
        }
        e = e << mLen | m;
        eLen += mLen;
        for (; eLen > 0; buffer[offset + i3] = e & 255, i3 += d, e /= 256, eLen -= 8) {
        }
        buffer[offset + i3 - d] |= s2 * 128;
      };
    }
  });

  // ../../node_modules/pbf/index.js
  var require_pbf = __commonJS({
    "../../node_modules/pbf/index.js"(exports, module2) {
      "use strict";
      module2.exports = Pbf;
      var ieee754 = require_ieee754();
      function Pbf(buf) {
        this.buf = ArrayBuffer.isView && ArrayBuffer.isView(buf) ? buf : new Uint8Array(buf || 0);
        this.pos = 0;
        this.type = 0;
        this.length = this.buf.length;
      }
      Pbf.Varint = 0;
      Pbf.Fixed64 = 1;
      Pbf.Bytes = 2;
      Pbf.Fixed32 = 5;
      var SHIFT_LEFT_32 = (1 << 16) * (1 << 16);
      var SHIFT_RIGHT_32 = 1 / SHIFT_LEFT_32;
      var TEXT_DECODER_MIN_LENGTH = 12;
      var utf8TextDecoder = typeof TextDecoder === "undefined" ? null : new TextDecoder("utf8");
      Pbf.prototype = {
        destroy: function() {
          this.buf = null;
        },
        readFields: function(readField, result, end) {
          end = end || this.length;
          while (this.pos < end) {
            var val = this.readVarint(), tag = val >> 3, startPos = this.pos;
            this.type = val & 7;
            readField(tag, result, this);
            if (this.pos === startPos)
              this.skip(val);
          }
          return result;
        },
        readMessage: function(readField, result) {
          return this.readFields(readField, result, this.readVarint() + this.pos);
        },
        readFixed32: function() {
          var val = readUInt32(this.buf, this.pos);
          this.pos += 4;
          return val;
        },
        readSFixed32: function() {
          var val = readInt32(this.buf, this.pos);
          this.pos += 4;
          return val;
        },
        readFixed64: function() {
          var val = readUInt32(this.buf, this.pos) + readUInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;
          this.pos += 8;
          return val;
        },
        readSFixed64: function() {
          var val = readUInt32(this.buf, this.pos) + readInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;
          this.pos += 8;
          return val;
        },
        readFloat: function() {
          var val = ieee754.read(this.buf, this.pos, true, 23, 4);
          this.pos += 4;
          return val;
        },
        readDouble: function() {
          var val = ieee754.read(this.buf, this.pos, true, 52, 8);
          this.pos += 8;
          return val;
        },
        readVarint: function(isSigned) {
          var buf = this.buf, val, b;
          b = buf[this.pos++];
          val = b & 127;
          if (b < 128)
            return val;
          b = buf[this.pos++];
          val |= (b & 127) << 7;
          if (b < 128)
            return val;
          b = buf[this.pos++];
          val |= (b & 127) << 14;
          if (b < 128)
            return val;
          b = buf[this.pos++];
          val |= (b & 127) << 21;
          if (b < 128)
            return val;
          b = buf[this.pos];
          val |= (b & 15) << 28;
          return readVarintRemainder(val, isSigned, this);
        },
        readVarint64: function() {
          return this.readVarint(true);
        },
        readSVarint: function() {
          var num = this.readVarint();
          return num % 2 === 1 ? (num + 1) / -2 : num / 2;
        },
        readBoolean: function() {
          return Boolean(this.readVarint());
        },
        readString: function() {
          var end = this.readVarint() + this.pos;
          var pos = this.pos;
          this.pos = end;
          if (end - pos >= TEXT_DECODER_MIN_LENGTH && utf8TextDecoder) {
            return readUtf8TextDecoder(this.buf, pos, end);
          }
          return readUtf8(this.buf, pos, end);
        },
        readBytes: function() {
          var end = this.readVarint() + this.pos, buffer = this.buf.subarray(this.pos, end);
          this.pos = end;
          return buffer;
        },
        readPackedVarint: function(arr, isSigned) {
          if (this.type !== Pbf.Bytes)
            return arr.push(this.readVarint(isSigned));
          var end = readPackedEnd(this);
          arr = arr || [];
          while (this.pos < end)
            arr.push(this.readVarint(isSigned));
          return arr;
        },
        readPackedSVarint: function(arr) {
          if (this.type !== Pbf.Bytes)
            return arr.push(this.readSVarint());
          var end = readPackedEnd(this);
          arr = arr || [];
          while (this.pos < end)
            arr.push(this.readSVarint());
          return arr;
        },
        readPackedBoolean: function(arr) {
          if (this.type !== Pbf.Bytes)
            return arr.push(this.readBoolean());
          var end = readPackedEnd(this);
          arr = arr || [];
          while (this.pos < end)
            arr.push(this.readBoolean());
          return arr;
        },
        readPackedFloat: function(arr) {
          if (this.type !== Pbf.Bytes)
            return arr.push(this.readFloat());
          var end = readPackedEnd(this);
          arr = arr || [];
          while (this.pos < end)
            arr.push(this.readFloat());
          return arr;
        },
        readPackedDouble: function(arr) {
          if (this.type !== Pbf.Bytes)
            return arr.push(this.readDouble());
          var end = readPackedEnd(this);
          arr = arr || [];
          while (this.pos < end)
            arr.push(this.readDouble());
          return arr;
        },
        readPackedFixed32: function(arr) {
          if (this.type !== Pbf.Bytes)
            return arr.push(this.readFixed32());
          var end = readPackedEnd(this);
          arr = arr || [];
          while (this.pos < end)
            arr.push(this.readFixed32());
          return arr;
        },
        readPackedSFixed32: function(arr) {
          if (this.type !== Pbf.Bytes)
            return arr.push(this.readSFixed32());
          var end = readPackedEnd(this);
          arr = arr || [];
          while (this.pos < end)
            arr.push(this.readSFixed32());
          return arr;
        },
        readPackedFixed64: function(arr) {
          if (this.type !== Pbf.Bytes)
            return arr.push(this.readFixed64());
          var end = readPackedEnd(this);
          arr = arr || [];
          while (this.pos < end)
            arr.push(this.readFixed64());
          return arr;
        },
        readPackedSFixed64: function(arr) {
          if (this.type !== Pbf.Bytes)
            return arr.push(this.readSFixed64());
          var end = readPackedEnd(this);
          arr = arr || [];
          while (this.pos < end)
            arr.push(this.readSFixed64());
          return arr;
        },
        skip: function(val) {
          var type = val & 7;
          if (type === Pbf.Varint)
            while (this.buf[this.pos++] > 127) {
            }
          else if (type === Pbf.Bytes)
            this.pos = this.readVarint() + this.pos;
          else if (type === Pbf.Fixed32)
            this.pos += 4;
          else if (type === Pbf.Fixed64)
            this.pos += 8;
          else
            throw new Error("Unimplemented type: " + type);
        },
        writeTag: function(tag, type) {
          this.writeVarint(tag << 3 | type);
        },
        realloc: function(min) {
          var length5 = this.length || 16;
          while (length5 < this.pos + min)
            length5 *= 2;
          if (length5 !== this.length) {
            var buf = new Uint8Array(length5);
            buf.set(this.buf);
            this.buf = buf;
            this.length = length5;
          }
        },
        finish: function() {
          this.length = this.pos;
          this.pos = 0;
          return this.buf.subarray(0, this.length);
        },
        writeFixed32: function(val) {
          this.realloc(4);
          writeInt32(this.buf, val, this.pos);
          this.pos += 4;
        },
        writeSFixed32: function(val) {
          this.realloc(4);
          writeInt32(this.buf, val, this.pos);
          this.pos += 4;
        },
        writeFixed64: function(val) {
          this.realloc(8);
          writeInt32(this.buf, val & -1, this.pos);
          writeInt32(this.buf, Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);
          this.pos += 8;
        },
        writeSFixed64: function(val) {
          this.realloc(8);
          writeInt32(this.buf, val & -1, this.pos);
          writeInt32(this.buf, Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);
          this.pos += 8;
        },
        writeVarint: function(val) {
          val = +val || 0;
          if (val > 268435455 || val < 0) {
            writeBigVarint(val, this);
            return;
          }
          this.realloc(4);
          this.buf[this.pos++] = val & 127 | (val > 127 ? 128 : 0);
          if (val <= 127)
            return;
          this.buf[this.pos++] = (val >>>= 7) & 127 | (val > 127 ? 128 : 0);
          if (val <= 127)
            return;
          this.buf[this.pos++] = (val >>>= 7) & 127 | (val > 127 ? 128 : 0);
          if (val <= 127)
            return;
          this.buf[this.pos++] = val >>> 7 & 127;
        },
        writeSVarint: function(val) {
          this.writeVarint(val < 0 ? -val * 2 - 1 : val * 2);
        },
        writeBoolean: function(val) {
          this.writeVarint(Boolean(val));
        },
        writeString: function(str) {
          str = String(str);
          this.realloc(str.length * 4);
          this.pos++;
          var startPos = this.pos;
          this.pos = writeUtf8(this.buf, str, this.pos);
          var len2 = this.pos - startPos;
          if (len2 >= 128)
            makeRoomForExtraLength(startPos, len2, this);
          this.pos = startPos - 1;
          this.writeVarint(len2);
          this.pos += len2;
        },
        writeFloat: function(val) {
          this.realloc(4);
          ieee754.write(this.buf, val, this.pos, true, 23, 4);
          this.pos += 4;
        },
        writeDouble: function(val) {
          this.realloc(8);
          ieee754.write(this.buf, val, this.pos, true, 52, 8);
          this.pos += 8;
        },
        writeBytes: function(buffer) {
          var len2 = buffer.length;
          this.writeVarint(len2);
          this.realloc(len2);
          for (var i3 = 0; i3 < len2; i3++)
            this.buf[this.pos++] = buffer[i3];
        },
        writeRawMessage: function(fn, obj) {
          this.pos++;
          var startPos = this.pos;
          fn(obj, this);
          var len2 = this.pos - startPos;
          if (len2 >= 128)
            makeRoomForExtraLength(startPos, len2, this);
          this.pos = startPos - 1;
          this.writeVarint(len2);
          this.pos += len2;
        },
        writeMessage: function(tag, fn, obj) {
          this.writeTag(tag, Pbf.Bytes);
          this.writeRawMessage(fn, obj);
        },
        writePackedVarint: function(tag, arr) {
          if (arr.length)
            this.writeMessage(tag, writePackedVarint, arr);
        },
        writePackedSVarint: function(tag, arr) {
          if (arr.length)
            this.writeMessage(tag, writePackedSVarint, arr);
        },
        writePackedBoolean: function(tag, arr) {
          if (arr.length)
            this.writeMessage(tag, writePackedBoolean, arr);
        },
        writePackedFloat: function(tag, arr) {
          if (arr.length)
            this.writeMessage(tag, writePackedFloat, arr);
        },
        writePackedDouble: function(tag, arr) {
          if (arr.length)
            this.writeMessage(tag, writePackedDouble, arr);
        },
        writePackedFixed32: function(tag, arr) {
          if (arr.length)
            this.writeMessage(tag, writePackedFixed32, arr);
        },
        writePackedSFixed32: function(tag, arr) {
          if (arr.length)
            this.writeMessage(tag, writePackedSFixed32, arr);
        },
        writePackedFixed64: function(tag, arr) {
          if (arr.length)
            this.writeMessage(tag, writePackedFixed64, arr);
        },
        writePackedSFixed64: function(tag, arr) {
          if (arr.length)
            this.writeMessage(tag, writePackedSFixed64, arr);
        },
        writeBytesField: function(tag, buffer) {
          this.writeTag(tag, Pbf.Bytes);
          this.writeBytes(buffer);
        },
        writeFixed32Field: function(tag, val) {
          this.writeTag(tag, Pbf.Fixed32);
          this.writeFixed32(val);
        },
        writeSFixed32Field: function(tag, val) {
          this.writeTag(tag, Pbf.Fixed32);
          this.writeSFixed32(val);
        },
        writeFixed64Field: function(tag, val) {
          this.writeTag(tag, Pbf.Fixed64);
          this.writeFixed64(val);
        },
        writeSFixed64Field: function(tag, val) {
          this.writeTag(tag, Pbf.Fixed64);
          this.writeSFixed64(val);
        },
        writeVarintField: function(tag, val) {
          this.writeTag(tag, Pbf.Varint);
          this.writeVarint(val);
        },
        writeSVarintField: function(tag, val) {
          this.writeTag(tag, Pbf.Varint);
          this.writeSVarint(val);
        },
        writeStringField: function(tag, str) {
          this.writeTag(tag, Pbf.Bytes);
          this.writeString(str);
        },
        writeFloatField: function(tag, val) {
          this.writeTag(tag, Pbf.Fixed32);
          this.writeFloat(val);
        },
        writeDoubleField: function(tag, val) {
          this.writeTag(tag, Pbf.Fixed64);
          this.writeDouble(val);
        },
        writeBooleanField: function(tag, val) {
          this.writeVarintField(tag, Boolean(val));
        }
      };
      function readVarintRemainder(l2, s2, p2) {
        var buf = p2.buf, h, b;
        b = buf[p2.pos++];
        h = (b & 112) >> 4;
        if (b < 128)
          return toNum(l2, h, s2);
        b = buf[p2.pos++];
        h |= (b & 127) << 3;
        if (b < 128)
          return toNum(l2, h, s2);
        b = buf[p2.pos++];
        h |= (b & 127) << 10;
        if (b < 128)
          return toNum(l2, h, s2);
        b = buf[p2.pos++];
        h |= (b & 127) << 17;
        if (b < 128)
          return toNum(l2, h, s2);
        b = buf[p2.pos++];
        h |= (b & 127) << 24;
        if (b < 128)
          return toNum(l2, h, s2);
        b = buf[p2.pos++];
        h |= (b & 1) << 31;
        if (b < 128)
          return toNum(l2, h, s2);
        throw new Error("Expected varint not more than 10 bytes");
      }
      function readPackedEnd(pbf) {
        return pbf.type === Pbf.Bytes ? pbf.readVarint() + pbf.pos : pbf.pos + 1;
      }
      function toNum(low, high, isSigned) {
        if (isSigned) {
          return high * 4294967296 + (low >>> 0);
        }
        return (high >>> 0) * 4294967296 + (low >>> 0);
      }
      function writeBigVarint(val, pbf) {
        var low, high;
        if (val >= 0) {
          low = val % 4294967296 | 0;
          high = val / 4294967296 | 0;
        } else {
          low = ~(-val % 4294967296);
          high = ~(-val / 4294967296);
          if (low ^ 4294967295) {
            low = low + 1 | 0;
          } else {
            low = 0;
            high = high + 1 | 0;
          }
        }
        if (val >= 18446744073709552e3 || val < -18446744073709552e3) {
          throw new Error("Given varint doesn't fit into 10 bytes");
        }
        pbf.realloc(10);
        writeBigVarintLow(low, high, pbf);
        writeBigVarintHigh(high, pbf);
      }
      function writeBigVarintLow(low, high, pbf) {
        pbf.buf[pbf.pos++] = low & 127 | 128;
        low >>>= 7;
        pbf.buf[pbf.pos++] = low & 127 | 128;
        low >>>= 7;
        pbf.buf[pbf.pos++] = low & 127 | 128;
        low >>>= 7;
        pbf.buf[pbf.pos++] = low & 127 | 128;
        low >>>= 7;
        pbf.buf[pbf.pos] = low & 127;
      }
      function writeBigVarintHigh(high, pbf) {
        var lsb = (high & 7) << 4;
        pbf.buf[pbf.pos++] |= lsb | ((high >>>= 3) ? 128 : 0);
        if (!high)
          return;
        pbf.buf[pbf.pos++] = high & 127 | ((high >>>= 7) ? 128 : 0);
        if (!high)
          return;
        pbf.buf[pbf.pos++] = high & 127 | ((high >>>= 7) ? 128 : 0);
        if (!high)
          return;
        pbf.buf[pbf.pos++] = high & 127 | ((high >>>= 7) ? 128 : 0);
        if (!high)
          return;
        pbf.buf[pbf.pos++] = high & 127 | ((high >>>= 7) ? 128 : 0);
        if (!high)
          return;
        pbf.buf[pbf.pos++] = high & 127;
      }
      function makeRoomForExtraLength(startPos, len2, pbf) {
        var extraLen = len2 <= 16383 ? 1 : len2 <= 2097151 ? 2 : len2 <= 268435455 ? 3 : Math.floor(Math.log(len2) / (Math.LN2 * 7));
        pbf.realloc(extraLen);
        for (var i3 = pbf.pos - 1; i3 >= startPos; i3--)
          pbf.buf[i3 + extraLen] = pbf.buf[i3];
      }
      function writePackedVarint(arr, pbf) {
        for (var i3 = 0; i3 < arr.length; i3++)
          pbf.writeVarint(arr[i3]);
      }
      function writePackedSVarint(arr, pbf) {
        for (var i3 = 0; i3 < arr.length; i3++)
          pbf.writeSVarint(arr[i3]);
      }
      function writePackedFloat(arr, pbf) {
        for (var i3 = 0; i3 < arr.length; i3++)
          pbf.writeFloat(arr[i3]);
      }
      function writePackedDouble(arr, pbf) {
        for (var i3 = 0; i3 < arr.length; i3++)
          pbf.writeDouble(arr[i3]);
      }
      function writePackedBoolean(arr, pbf) {
        for (var i3 = 0; i3 < arr.length; i3++)
          pbf.writeBoolean(arr[i3]);
      }
      function writePackedFixed32(arr, pbf) {
        for (var i3 = 0; i3 < arr.length; i3++)
          pbf.writeFixed32(arr[i3]);
      }
      function writePackedSFixed32(arr, pbf) {
        for (var i3 = 0; i3 < arr.length; i3++)
          pbf.writeSFixed32(arr[i3]);
      }
      function writePackedFixed64(arr, pbf) {
        for (var i3 = 0; i3 < arr.length; i3++)
          pbf.writeFixed64(arr[i3]);
      }
      function writePackedSFixed64(arr, pbf) {
        for (var i3 = 0; i3 < arr.length; i3++)
          pbf.writeSFixed64(arr[i3]);
      }
      function readUInt32(buf, pos) {
        return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16) + buf[pos + 3] * 16777216;
      }
      function writeInt32(buf, val, pos) {
        buf[pos] = val;
        buf[pos + 1] = val >>> 8;
        buf[pos + 2] = val >>> 16;
        buf[pos + 3] = val >>> 24;
      }
      function readInt32(buf, pos) {
        return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16) + (buf[pos + 3] << 24);
      }
      function readUtf8(buf, pos, end) {
        var str = "";
        var i3 = pos;
        while (i3 < end) {
          var b0 = buf[i3];
          var c = null;
          var bytesPerSequence = b0 > 239 ? 4 : b0 > 223 ? 3 : b0 > 191 ? 2 : 1;
          if (i3 + bytesPerSequence > end)
            break;
          var b1, b2, b3;
          if (bytesPerSequence === 1) {
            if (b0 < 128) {
              c = b0;
            }
          } else if (bytesPerSequence === 2) {
            b1 = buf[i3 + 1];
            if ((b1 & 192) === 128) {
              c = (b0 & 31) << 6 | b1 & 63;
              if (c <= 127) {
                c = null;
              }
            }
          } else if (bytesPerSequence === 3) {
            b1 = buf[i3 + 1];
            b2 = buf[i3 + 2];
            if ((b1 & 192) === 128 && (b2 & 192) === 128) {
              c = (b0 & 15) << 12 | (b1 & 63) << 6 | b2 & 63;
              if (c <= 2047 || c >= 55296 && c <= 57343) {
                c = null;
              }
            }
          } else if (bytesPerSequence === 4) {
            b1 = buf[i3 + 1];
            b2 = buf[i3 + 2];
            b3 = buf[i3 + 3];
            if ((b1 & 192) === 128 && (b2 & 192) === 128 && (b3 & 192) === 128) {
              c = (b0 & 15) << 18 | (b1 & 63) << 12 | (b2 & 63) << 6 | b3 & 63;
              if (c <= 65535 || c >= 1114112) {
                c = null;
              }
            }
          }
          if (c === null) {
            c = 65533;
            bytesPerSequence = 1;
          } else if (c > 65535) {
            c -= 65536;
            str += String.fromCharCode(c >>> 10 & 1023 | 55296);
            c = 56320 | c & 1023;
          }
          str += String.fromCharCode(c);
          i3 += bytesPerSequence;
        }
        return str;
      }
      function readUtf8TextDecoder(buf, pos, end) {
        return utf8TextDecoder.decode(buf.subarray(pos, end));
      }
      function writeUtf8(buf, str, pos) {
        for (var i3 = 0, c, lead; i3 < str.length; i3++) {
          c = str.charCodeAt(i3);
          if (c > 55295 && c < 57344) {
            if (lead) {
              if (c < 56320) {
                buf[pos++] = 239;
                buf[pos++] = 191;
                buf[pos++] = 189;
                lead = c;
                continue;
              } else {
                c = lead - 55296 << 10 | c - 56320 | 65536;
                lead = null;
              }
            } else {
              if (c > 56319 || i3 + 1 === str.length) {
                buf[pos++] = 239;
                buf[pos++] = 191;
                buf[pos++] = 189;
              } else {
                lead = c;
              }
              continue;
            }
          } else if (lead) {
            buf[pos++] = 239;
            buf[pos++] = 191;
            buf[pos++] = 189;
            lead = null;
          }
          if (c < 128) {
            buf[pos++] = c;
          } else {
            if (c < 2048) {
              buf[pos++] = c >> 6 | 192;
            } else {
              if (c < 65536) {
                buf[pos++] = c >> 12 | 224;
              } else {
                buf[pos++] = c >> 18 | 240;
                buf[pos++] = c >> 12 & 63 | 128;
              }
              buf[pos++] = c >> 6 & 63 | 128;
            }
            buf[pos++] = c & 63 | 128;
          }
        }
        return pos;
      }
    }
  });

  // bundle.ts
  var bundle_exports = {};
  __export(bundle_exports, {
    GeohashLayer: () => GeohashLayer,
    GreatCircleLayer: () => GreatCircleLayer,
    H3ClusterLayer: () => H3ClusterLayer,
    H3HexagonLayer: () => H3HexagonLayer,
    MVTLayer: () => MVTLayer,
    QuadkeyLayer: () => QuadkeyLayer,
    S2Layer: () => S2Layer,
    TerrainLayer: () => TerrainLayer,
    Tile3DLayer: () => Tile3DLayer,
    TileLayer: () => TileLayer,
    TripsLayer: () => TripsLayer,
    _GeoCellLayer: () => GeoCellLayer,
    _Tile2DHeader: () => Tile2DHeader,
    _Tileset2D: () => Tileset2D,
    _WMSLayer: () => WMSLayer,
    _getURLFromTemplate: () => getURLFromTemplate
  });

  // ../layers/bundle/peer-dependency.ts
  var peer_dependency_exports = {};
  var import_layers = __toESM(require_layers());
  __reExport(peer_dependency_exports, __toESM(require_layers()));
  if (!import_layers.GeoJsonLayer) {
    throw new Error("@deck.gl/layers is not found");
  }

  // bundle.ts
  __reExport(bundle_exports, peer_dependency_exports);

  // src/wms-layer/wms-layer.ts
  var import_core = __toESM(require_core());
  var import_layers2 = __toESM(require_layers());

  // ../../node_modules/@babel/runtime/helpers/esm/defineProperty.js
  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }

  // ../../node_modules/@loaders.gl/xml/dist/esm/lib/parse-xml.js
  var import_fast_xml_parser = __toESM(require_fxp());
  function parseXML(text, options) {
    const parser = new import_fast_xml_parser.XMLParser({
      ignoreAttributes: false,
      attributeNamePrefix: "",
      ...options === null || options === void 0 ? void 0 : options.xml
    });
    const parsedXML = parser.parse(text);
    return parsedXML;
  }

  // ../../node_modules/@loaders.gl/xml/dist/esm/xml-loader.js
  var VERSION = true ? "3.3.1" : "latest";
  var XMLLoader = {
    name: "XML",
    id: "xml",
    module: "xml",
    version: VERSION,
    worker: false,
    extensions: ["xml"],
    mimeTypes: ["application/xml", "text/xml"],
    testText: testXMLFile,
    options: {
      xml: {}
    },
    parse: async (arrayBuffer, options) => parseXML(new TextDecoder().decode(arrayBuffer), options),
    parseTextSync: (text, options) => parseXML(text, options)
  };
  function testXMLFile(text) {
    return text.startsWith("<?xml");
  }

  // ../../node_modules/@loaders.gl/wms/dist/esm/lib/wms/parse-wms.js
  function parseWMSCapabilities(text, options) {
    const parsedXML = XMLLoader.parseTextSync(text, options);
    const xmlCapabilities = parsedXML.WMT_MS_Capabilities || parsedXML.WMS_Capabilities || parsedXML;
    return extractCapabilities(xmlCapabilities);
  }
  function extractCapabilities(xml) {
    var _xml$Service, _xml$Service2, _xml$Capability;
    const capabilities = {
      name: ((_xml$Service = xml.Service) === null || _xml$Service === void 0 ? void 0 : _xml$Service.Name) || "unnamed",
      title: (_xml$Service2 = xml.Service) === null || _xml$Service2 === void 0 ? void 0 : _xml$Service2.Title,
      keywords: [],
      requests: {},
      layer: extractLayer((_xml$Capability = xml.Capability) === null || _xml$Capability === void 0 ? void 0 : _xml$Capability.Layer),
      raw: xml
    };
    for (const keyword of ((_xml$Service3 = xml.Service) === null || _xml$Service3 === void 0 ? void 0 : (_xml$Service3$Keyword = _xml$Service3.KeywordList) === null || _xml$Service3$Keyword === void 0 ? void 0 : _xml$Service3$Keyword.Keyword) || []) {
      var _xml$Service3, _xml$Service3$Keyword;
      capabilities.keywords.push(keyword);
    }
    for (const [name10, xmlRequest] of Object.entries(((_xml$Capability2 = xml.Capability) === null || _xml$Capability2 === void 0 ? void 0 : _xml$Capability2.Request) || {})) {
      var _xml$Capability2;
      capabilities.requests[name10] = extractRequest(name10, xmlRequest);
    }
    return capabilities;
  }
  function extractRequest(name10, xmlRequest) {
    const format = xmlRequest === null || xmlRequest === void 0 ? void 0 : xmlRequest.Format;
    const mimeTypes = Array.isArray(format) ? format : [format];
    return {
      name: name10,
      mimeTypes
    };
  }
  function extractLayer(xmlLayer) {
    const layer = {
      name: xmlLayer === null || xmlLayer === void 0 ? void 0 : xmlLayer.Name,
      title: xmlLayer === null || xmlLayer === void 0 ? void 0 : xmlLayer.Title,
      srs: (xmlLayer === null || xmlLayer === void 0 ? void 0 : xmlLayer.SRS) || [],
      layers: []
    };
    const xmlLayers = getXMLArray(xmlLayer === null || xmlLayer === void 0 ? void 0 : xmlLayer.Layer);
    for (const xmlSubLayer of xmlLayers) {
      var _layer$layers;
      (_layer$layers = layer.layers) === null || _layer$layers === void 0 ? void 0 : _layer$layers.push(extractLayer(xmlSubLayer));
    }
    return layer;
  }
  function getXMLArray(xmlValue) {
    if (Array.isArray(xmlValue)) {
      return xmlValue;
    }
    if (xmlValue) {
      return [xmlValue];
    }
    return [];
  }
  function parseWMSFeatureInfo(text, options) {
    var _parsedXML$FeatureInf;
    const parsedXML = XMLLoader.parseTextSync(text, options);
    const xmlFeatureInfo = ((_parsedXML$FeatureInf = parsedXML.FeatureInfoResponse) === null || _parsedXML$FeatureInf === void 0 ? void 0 : _parsedXML$FeatureInf.FIELDS) || [];
    const xmlFeatures = Array.isArray(xmlFeatureInfo) ? xmlFeatureInfo : [xmlFeatureInfo];
    return {
      features: xmlFeatures.map((xmlFeature) => extractFeature(xmlFeature))
    };
  }
  function extractFeature(xmlFeature) {
    const xmlFields = xmlFeature || {};
    return {
      attributes: xmlFields,
      type: "",
      bounds: {
        bottom: 0,
        top: 0,
        left: 0,
        right: 0
      }
    };
  }
  function parseWMSLayerDescription(text, options) {
    const parsedXML = XMLLoader.parseTextSync(text, options);
    return parsedXML;
  }
  function parseWMSError(text, options) {
    var _XMLLoader$parseTextS, _parsedXML$ServiceExc, _parsedXML$ogcServic;
    const parsedXML = (_XMLLoader$parseTextS = XMLLoader.parseTextSync) === null || _XMLLoader$parseTextS === void 0 ? void 0 : _XMLLoader$parseTextS.call(XMLLoader, text, options);
    const serviceExceptionXML = (parsedXML === null || parsedXML === void 0 ? void 0 : (_parsedXML$ServiceExc = parsedXML.ServiceExceptionReport) === null || _parsedXML$ServiceExc === void 0 ? void 0 : _parsedXML$ServiceExc.ServiceException) || (parsedXML === null || parsedXML === void 0 ? void 0 : (_parsedXML$ogcServic = parsedXML["ogc:ServiceExceptionReport"]) === null || _parsedXML$ogcServic === void 0 ? void 0 : _parsedXML$ogcServic["ogc:ServiceException"]);
    const message = typeof serviceExceptionXML === "string" ? serviceExceptionXML : serviceExceptionXML["#text"] || serviceExceptionXML.code || "Unknown error";
    return message;
  }

  // ../../node_modules/@loaders.gl/wms/dist/esm/wms-error-loader.js
  var VERSION2 = true ? "3.3.1" : "latest";
  var WMSErrorLoader = {
    id: "wms-error",
    name: "WMS Error",
    module: "wms",
    version: VERSION2,
    worker: false,
    extensions: ["xml"],
    mimeTypes: ["application/vnd.ogc.se_xml", "application/xml", "text/xml"],
    testText: testXMLFile2,
    options: {
      wms: {
        throwOnError: false
      }
    },
    parse: async (arrayBuffer, options) => parseTextSync(new TextDecoder().decode(arrayBuffer), options),
    parseSync: (arrayBuffer, options) => parseTextSync(new TextDecoder().decode(arrayBuffer), options),
    parseTextSync: (text, options) => parseTextSync(text, options)
  };
  function testXMLFile2(text) {
    return text.startsWith("<?xml");
  }
  function parseTextSync(text, options) {
    const wmsOptions = {
      ...WMSErrorLoader.options.wms,
      ...options === null || options === void 0 ? void 0 : options.wms
    };
    const error2 = parseWMSError(text, wmsOptions);
    const message = wmsOptions.minimalErrors ? error2 : "WMS Service error: ".concat(error2);
    if (wmsOptions.throwOnError) {
      throw new Error(message);
    }
    return message;
  }

  // ../../node_modules/@loaders.gl/wms/dist/esm/wms-capabilities-loader.js
  var VERSION3 = true ? "3.3.1" : "latest";
  var WMSCapabilitiesLoader = {
    id: "wms-capabilities",
    name: "WMS Capabilities",
    module: "wms",
    version: VERSION3,
    worker: false,
    extensions: ["xml"],
    mimeTypes: ["application/vnd.ogc.wms_xml", "application/xml", "text/xml"],
    testText: testXMLFile3,
    options: {
      wms: {}
    },
    parse: async (arrayBuffer, options) => parseWMSCapabilities(new TextDecoder().decode(arrayBuffer), options),
    parseTextSync: (text, options) => parseWMSCapabilities(text, options)
  };
  function testXMLFile3(text) {
    return text.startsWith("<?xml");
  }

  // ../../node_modules/@loaders.gl/wms/dist/esm/lib/data-sources/image-source.js
  var ImageSource = class {
  };

  // ../../node_modules/@loaders.gl/images/dist/esm/lib/utils/version.js
  var VERSION4 = true ? "3.3.1" : "latest";

  // ../../node_modules/@loaders.gl/loader-utils/dist/esm/lib/env-utils/assert.js
  function assert2(condition, message) {
    if (!condition) {
      throw new Error(message || "loader assertion failed.");
    }
  }

  // ../../node_modules/@loaders.gl/loader-utils/dist/esm/lib/env-utils/globals.js
  var globals = {
    self: typeof self !== "undefined" && self,
    window: typeof window !== "undefined" && window,
    global: typeof global !== "undefined" && global,
    document: typeof document !== "undefined" && document
  };
  var self_ = globals.self || globals.window || globals.global || {};
  var window_ = globals.window || globals.self || globals.global || {};
  var global_ = globals.global || globals.self || globals.window || {};
  var document_ = globals.document || {};
  var isBrowser = Boolean(typeof process !== "object" || String(process) !== "[object process]" || process.browser);
  var matches = typeof process !== "undefined" && process.version && /v([0-9]*)/.exec(process.version);
  var nodeVersion = matches && parseFloat(matches[1]) || 0;

  // ../../node_modules/@loaders.gl/worker-utils/dist/esm/lib/env-utils/assert.js
  function assert3(condition, message) {
    if (!condition) {
      throw new Error(message || "loaders.gl assertion failed.");
    }
  }

  // ../../node_modules/@loaders.gl/worker-utils/dist/esm/lib/env-utils/globals.js
  var globals2 = {
    self: typeof self !== "undefined" && self,
    window: typeof window !== "undefined" && window,
    global: typeof global !== "undefined" && global,
    document: typeof document !== "undefined" && document
  };
  var self_2 = globals2.self || globals2.window || globals2.global || {};
  var window_2 = globals2.window || globals2.self || globals2.global || {};
  var global_2 = globals2.global || globals2.self || globals2.window || {};
  var document_2 = globals2.document || {};
  var isBrowser2 = typeof process !== "object" || String(process) !== "[object process]" || process.browser;
  var isWorker = typeof importScripts === "function";
  var isMobile = typeof window !== "undefined" && typeof window.orientation !== "undefined";
  var matches2 = typeof process !== "undefined" && process.version && /v([0-9]*)/.exec(process.version);
  var nodeVersion2 = matches2 && parseFloat(matches2[1]) || 0;

  // ../../node_modules/@loaders.gl/worker-utils/dist/esm/lib/library-utils/library-utils.js
  var node = __toESM(require_require_utils());
  var VERSION5 = true ? "3.3.1" : LATEST;
  var loadLibraryPromises = {};
  async function loadLibrary(libraryUrl) {
    let moduleName = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (moduleName) {
      libraryUrl = getLibraryUrl(libraryUrl, moduleName, options);
    }
    loadLibraryPromises[libraryUrl] = loadLibraryPromises[libraryUrl] || loadLibraryFromFile(libraryUrl);
    return await loadLibraryPromises[libraryUrl];
  }
  function getLibraryUrl(library, moduleName, options) {
    if (library.startsWith("http")) {
      return library;
    }
    const modules = options.modules || {};
    if (modules[library]) {
      return modules[library];
    }
    if (!isBrowser2) {
      return "modules/".concat(moduleName, "/dist/libs/").concat(library);
    }
    if (options.CDN) {
      assert3(options.CDN.startsWith("http"));
      return "".concat(options.CDN, "/").concat(moduleName, "@").concat(VERSION5, "/dist/libs/").concat(library);
    }
    if (isWorker) {
      return "../src/libs/".concat(library);
    }
    return "modules/".concat(moduleName, "/src/libs/").concat(library);
  }
  async function loadLibraryFromFile(libraryUrl) {
    if (libraryUrl.endsWith("wasm")) {
      const response2 = await fetch(libraryUrl);
      return await response2.arrayBuffer();
    }
    if (!isBrowser2) {
      try {
        return node && node.requireFromFile && await node.requireFromFile(libraryUrl);
      } catch {
        return null;
      }
    }
    if (isWorker) {
      return importScripts(libraryUrl);
    }
    const response = await fetch(libraryUrl);
    const scriptSource = await response.text();
    return loadLibraryFromString(scriptSource, libraryUrl);
  }
  function loadLibraryFromString(scriptSource, id) {
    if (!isBrowser2) {
      return node.requireFromString && node.requireFromString(scriptSource, id);
    }
    if (isWorker) {
      eval.call(global_2, scriptSource);
      return null;
    }
    const script = document.createElement("script");
    script.id = id;
    try {
      script.appendChild(document.createTextNode(scriptSource));
    } catch (e) {
      script.text = scriptSource;
    }
    document.body.appendChild(script);
    return null;
  }

  // ../../node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/get-first-characters.js
  function getFirstCharacters(data) {
    let length5 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 5;
    if (typeof data === "string") {
      return data.slice(0, length5);
    } else if (ArrayBuffer.isView(data)) {
      return getMagicString(data.buffer, data.byteOffset, length5);
    } else if (data instanceof ArrayBuffer) {
      const byteOffset = 0;
      return getMagicString(data, byteOffset, length5);
    }
    return "";
  }
  function getMagicString(arrayBuffer, byteOffset, length5) {
    if (arrayBuffer.byteLength <= byteOffset + length5) {
      return "";
    }
    const dataView = new DataView(arrayBuffer);
    let magic = "";
    for (let i3 = 0; i3 < length5; i3++) {
      magic += String.fromCharCode(dataView.getUint8(byteOffset + i3));
    }
    return magic;
  }

  // ../../node_modules/@loaders.gl/loader-utils/dist/esm/lib/parser-utils/parse-json.js
  function parseJSON(string) {
    try {
      return JSON.parse(string);
    } catch (_) {
      throw new Error('Failed to parse JSON from data starting with "'.concat(getFirstCharacters(string), '"'));
    }
  }

  // ../../node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/array-buffer-utils.js
  function concatenateTypedArrays() {
    for (var _len2 = arguments.length, typedArrays = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      typedArrays[_key2] = arguments[_key2];
    }
    const arrays = typedArrays;
    const TypedArrayConstructor = arrays && arrays.length > 1 && arrays[0].constructor || null;
    if (!TypedArrayConstructor) {
      throw new Error('"concatenateTypedArrays" - incorrect quantity of arguments or arguments have incompatible data types');
    }
    const sumLength = arrays.reduce((acc, value) => acc + value.length, 0);
    const result = new TypedArrayConstructor(sumLength);
    let offset = 0;
    for (const array of arrays) {
      result.set(array, offset);
      offset += array.length;
    }
    return result;
  }
  function sliceArrayBuffer(arrayBuffer, byteOffset, byteLength) {
    const subArray = byteLength !== void 0 ? new Uint8Array(arrayBuffer).subarray(byteOffset, byteOffset + byteLength) : new Uint8Array(arrayBuffer).subarray(byteOffset);
    const arrayCopy = new Uint8Array(subArray);
    return arrayCopy.buffer;
  }

  // ../../node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/memory-copy-utils.js
  function padToNBytes(byteLength, padding) {
    assert2(byteLength >= 0);
    assert2(padding > 0);
    return byteLength + (padding - 1) & ~(padding - 1);
  }
  function copyToArray(source, target, targetOffset) {
    let sourceArray;
    if (source instanceof ArrayBuffer) {
      sourceArray = new Uint8Array(source);
    } else {
      const srcByteOffset = source.byteOffset;
      const srcByteLength = source.byteLength;
      sourceArray = new Uint8Array(source.buffer || source.arrayBuffer, srcByteOffset, srcByteLength);
    }
    target.set(sourceArray, targetOffset);
    return targetOffset + padToNBytes(sourceArray.byteLength, 4);
  }

  // ../../node_modules/@probe.gl/stats/dist/esm/utils/hi-res-timestamp.js
  function getHiResTimestamp() {
    let timestamp;
    if (typeof window !== "undefined" && window.performance) {
      timestamp = window.performance.now();
    } else if (typeof process !== "undefined" && process.hrtime) {
      const timeParts = process.hrtime();
      timestamp = timeParts[0] * 1e3 + timeParts[1] / 1e6;
    } else {
      timestamp = Date.now();
    }
    return timestamp;
  }

  // ../../node_modules/@probe.gl/stats/dist/esm/lib/stat.js
  var Stat = class {
    constructor(name10, type) {
      _defineProperty(this, "name", void 0);
      _defineProperty(this, "type", void 0);
      _defineProperty(this, "sampleSize", 1);
      _defineProperty(this, "time", void 0);
      _defineProperty(this, "count", void 0);
      _defineProperty(this, "samples", void 0);
      _defineProperty(this, "lastTiming", void 0);
      _defineProperty(this, "lastSampleTime", void 0);
      _defineProperty(this, "lastSampleCount", void 0);
      _defineProperty(this, "_count", 0);
      _defineProperty(this, "_time", 0);
      _defineProperty(this, "_samples", 0);
      _defineProperty(this, "_startTime", 0);
      _defineProperty(this, "_timerPending", false);
      this.name = name10;
      this.type = type;
      this.reset();
    }
    setSampleSize(samples) {
      this.sampleSize = samples;
      return this;
    }
    incrementCount() {
      this.addCount(1);
      return this;
    }
    decrementCount() {
      this.subtractCount(1);
      return this;
    }
    addCount(value) {
      this._count += value;
      this._samples++;
      this._checkSampling();
      return this;
    }
    subtractCount(value) {
      this._count -= value;
      this._samples++;
      this._checkSampling();
      return this;
    }
    addTime(time) {
      this._time += time;
      this.lastTiming = time;
      this._samples++;
      this._checkSampling();
      return this;
    }
    timeStart() {
      this._startTime = getHiResTimestamp();
      this._timerPending = true;
      return this;
    }
    timeEnd() {
      if (!this._timerPending) {
        return this;
      }
      this.addTime(getHiResTimestamp() - this._startTime);
      this._timerPending = false;
      this._checkSampling();
      return this;
    }
    getSampleAverageCount() {
      return this.sampleSize > 0 ? this.lastSampleCount / this.sampleSize : 0;
    }
    getSampleAverageTime() {
      return this.sampleSize > 0 ? this.lastSampleTime / this.sampleSize : 0;
    }
    getSampleHz() {
      return this.lastSampleTime > 0 ? this.sampleSize / (this.lastSampleTime / 1e3) : 0;
    }
    getAverageCount() {
      return this.samples > 0 ? this.count / this.samples : 0;
    }
    getAverageTime() {
      return this.samples > 0 ? this.time / this.samples : 0;
    }
    getHz() {
      return this.time > 0 ? this.samples / (this.time / 1e3) : 0;
    }
    reset() {
      this.time = 0;
      this.count = 0;
      this.samples = 0;
      this.lastTiming = 0;
      this.lastSampleTime = 0;
      this.lastSampleCount = 0;
      this._count = 0;
      this._time = 0;
      this._samples = 0;
      this._startTime = 0;
      this._timerPending = false;
      return this;
    }
    _checkSampling() {
      if (this._samples === this.sampleSize) {
        this.lastSampleTime = this._time;
        this.lastSampleCount = this._count;
        this.count += this._count;
        this.time += this._time;
        this.samples += this._samples;
        this._time = 0;
        this._count = 0;
        this._samples = 0;
      }
    }
  };

  // ../../node_modules/@probe.gl/stats/dist/esm/lib/stats.js
  var Stats = class {
    constructor(options) {
      _defineProperty(this, "id", void 0);
      _defineProperty(this, "stats", {});
      this.id = options.id;
      this.stats = {};
      this._initializeStats(options.stats);
      Object.seal(this);
    }
    get(name10) {
      let type = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "count";
      return this._getOrCreate({
        name: name10,
        type
      });
    }
    get size() {
      return Object.keys(this.stats).length;
    }
    reset() {
      for (const key in this.stats) {
        this.stats[key].reset();
      }
      return this;
    }
    forEach(fn) {
      for (const key in this.stats) {
        fn(this.stats[key]);
      }
    }
    getTable() {
      const table = {};
      this.forEach((stat) => {
        table[stat.name] = {
          time: stat.time || 0,
          count: stat.count || 0,
          average: stat.getAverageTime() || 0,
          hz: stat.getHz() || 0
        };
      });
      return table;
    }
    _initializeStats() {
      let stats = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      stats.forEach((stat) => this._getOrCreate(stat));
    }
    _getOrCreate(stat) {
      if (!stat || !stat.name) {
        return null;
      }
      const {
        name: name10,
        type
      } = stat;
      if (!this.stats[name10]) {
        if (stat instanceof Stat) {
          this.stats[name10] = stat;
        } else {
          this.stats[name10] = new Stat(name10, type);
        }
      }
      return this.stats[name10];
    }
  };

  // ../../node_modules/@loaders.gl/loader-utils/dist/esm/lib/request-utils/request-scheduler.js
  var STAT_QUEUED_REQUESTS = "Queued Requests";
  var STAT_ACTIVE_REQUESTS = "Active Requests";
  var STAT_CANCELLED_REQUESTS = "Cancelled Requests";
  var STAT_QUEUED_REQUESTS_EVER = "Queued Requests Ever";
  var STAT_ACTIVE_REQUESTS_EVER = "Active Requests Ever";
  var DEFAULT_PROPS = {
    id: "request-scheduler",
    throttleRequests: true,
    maxRequests: 6
  };
  var RequestScheduler = class {
    constructor() {
      let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      _defineProperty(this, "props", void 0);
      _defineProperty(this, "stats", void 0);
      _defineProperty(this, "activeRequestCount", 0);
      _defineProperty(this, "requestQueue", []);
      _defineProperty(this, "requestMap", /* @__PURE__ */ new Map());
      _defineProperty(this, "deferredUpdate", null);
      this.props = {
        ...DEFAULT_PROPS,
        ...props
      };
      this.stats = new Stats({
        id: this.props.id
      });
      this.stats.get(STAT_QUEUED_REQUESTS);
      this.stats.get(STAT_ACTIVE_REQUESTS);
      this.stats.get(STAT_CANCELLED_REQUESTS);
      this.stats.get(STAT_QUEUED_REQUESTS_EVER);
      this.stats.get(STAT_ACTIVE_REQUESTS_EVER);
    }
    scheduleRequest(handle) {
      let getPriority = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : () => 0;
      if (!this.props.throttleRequests) {
        return Promise.resolve({
          done: () => {
          }
        });
      }
      if (this.requestMap.has(handle)) {
        return this.requestMap.get(handle);
      }
      const request = {
        handle,
        priority: 0,
        getPriority
      };
      const promise = new Promise((resolve) => {
        request.resolve = resolve;
        return request;
      });
      this.requestQueue.push(request);
      this.requestMap.set(handle, promise);
      this._issueNewRequests();
      return promise;
    }
    _issueRequest(request) {
      const {
        handle,
        resolve
      } = request;
      let isDone = false;
      const done = () => {
        if (!isDone) {
          isDone = true;
          this.requestMap.delete(handle);
          this.activeRequestCount--;
          this._issueNewRequests();
        }
      };
      this.activeRequestCount++;
      return resolve ? resolve({
        done
      }) : Promise.resolve({
        done
      });
    }
    _issueNewRequests() {
      if (!this.deferredUpdate) {
        this.deferredUpdate = setTimeout(() => this._issueNewRequestsAsync(), 0);
      }
    }
    _issueNewRequestsAsync() {
      this.deferredUpdate = null;
      const freeSlots = Math.max(this.props.maxRequests - this.activeRequestCount, 0);
      if (freeSlots === 0) {
        return;
      }
      this._updateAllRequests();
      for (let i3 = 0; i3 < freeSlots; ++i3) {
        const request = this.requestQueue.shift();
        if (request) {
          this._issueRequest(request);
        }
      }
    }
    _updateAllRequests() {
      const requestQueue = this.requestQueue;
      for (let i3 = 0; i3 < requestQueue.length; ++i3) {
        const request = requestQueue[i3];
        if (!this._updateRequest(request)) {
          requestQueue.splice(i3, 1);
          this.requestMap.delete(request.handle);
          i3--;
        }
      }
      requestQueue.sort((a2, b) => a2.priority - b.priority);
    }
    _updateRequest(request) {
      request.priority = request.getPriority(request.handle);
      if (request.priority < 0) {
        request.resolve(null);
        return false;
      }
      return true;
    }
  };

  // ../../node_modules/@loaders.gl/loader-utils/dist/esm/lib/path-utils/path.js
  var path_exports = {};
  __export(path_exports, {
    dirname: () => dirname,
    filename: () => filename,
    join: () => join
  });
  function filename(url) {
    const slashIndex = url && url.lastIndexOf("/");
    return slashIndex >= 0 ? url.substr(slashIndex + 1) : "";
  }
  function dirname(url) {
    const slashIndex = url && url.lastIndexOf("/");
    return slashIndex >= 0 ? url.substr(0, slashIndex) : "";
  }
  function join() {
    for (var _len = arguments.length, parts = new Array(_len), _key = 0; _key < _len; _key++) {
      parts[_key] = arguments[_key];
    }
    const separator = "/";
    parts = parts.map((part, index) => {
      if (index) {
        part = part.replace(new RegExp("^".concat(separator)), "");
      }
      if (index !== parts.length - 1) {
        part = part.replace(new RegExp("".concat(separator, "$")), "");
      }
      return part;
    });
    return parts.join(separator);
  }

  // ../../node_modules/@loaders.gl/images/dist/esm/lib/category-api/image-type.js
  var {
    _parseImageNode
  } = globalThis;
  var IMAGE_SUPPORTED = typeof Image !== "undefined";
  var IMAGE_BITMAP_SUPPORTED = typeof ImageBitmap !== "undefined";
  var NODE_IMAGE_SUPPORTED = Boolean(_parseImageNode);
  var DATA_SUPPORTED = isBrowser ? true : NODE_IMAGE_SUPPORTED;
  function isImageTypeSupported(type) {
    switch (type) {
      case "auto":
        return IMAGE_BITMAP_SUPPORTED || IMAGE_SUPPORTED || DATA_SUPPORTED;
      case "imagebitmap":
        return IMAGE_BITMAP_SUPPORTED;
      case "image":
        return IMAGE_SUPPORTED;
      case "data":
        return DATA_SUPPORTED;
      default:
        throw new Error("@loaders.gl/images: image ".concat(type, " not supported in this environment"));
    }
  }
  function getDefaultImageType() {
    if (IMAGE_BITMAP_SUPPORTED) {
      return "imagebitmap";
    }
    if (IMAGE_SUPPORTED) {
      return "image";
    }
    if (DATA_SUPPORTED) {
      return "data";
    }
    throw new Error("Install '@loaders.gl/polyfills' to parse images under Node.js");
  }

  // ../../node_modules/@loaders.gl/images/dist/esm/lib/category-api/parsed-image-api.js
  function getImageType(image) {
    const format = getImageTypeOrNull(image);
    if (!format) {
      throw new Error("Not an image");
    }
    return format;
  }
  function getImageData(image) {
    switch (getImageType(image)) {
      case "data":
        return image;
      case "image":
      case "imagebitmap":
        const canvas = document.createElement("canvas");
        const context = canvas.getContext("2d");
        if (!context) {
          throw new Error("getImageData");
        }
        canvas.width = image.width;
        canvas.height = image.height;
        context.drawImage(image, 0, 0);
        return context.getImageData(0, 0, image.width, image.height);
      default:
        throw new Error("getImageData");
    }
  }
  function getImageTypeOrNull(image) {
    if (typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
      return "imagebitmap";
    }
    if (typeof Image !== "undefined" && image instanceof Image) {
      return "image";
    }
    if (image && typeof image === "object" && image.data && image.width && image.height) {
      return "data";
    }
    return null;
  }

  // ../../node_modules/@loaders.gl/images/dist/esm/lib/parsers/svg-utils.js
  var SVG_DATA_URL_PATTERN = /^data:image\/svg\+xml/;
  var SVG_URL_PATTERN = /\.svg((\?|#).*)?$/;
  function isSVG(url) {
    return url && (SVG_DATA_URL_PATTERN.test(url) || SVG_URL_PATTERN.test(url));
  }
  function getBlobOrSVGDataUrl(arrayBuffer, url) {
    if (isSVG(url)) {
      const textDecoder = new TextDecoder();
      let xmlText = textDecoder.decode(arrayBuffer);
      try {
        if (typeof unescape === "function" && typeof encodeURIComponent === "function") {
          xmlText = unescape(encodeURIComponent(xmlText));
        }
      } catch (error2) {
        throw new Error(error2.message);
      }
      const src = "data:image/svg+xml;base64,".concat(btoa(xmlText));
      return src;
    }
    return getBlob(arrayBuffer, url);
  }
  function getBlob(arrayBuffer, url) {
    if (isSVG(url)) {
      throw new Error("SVG cannot be parsed directly to imagebitmap");
    }
    return new Blob([new Uint8Array(arrayBuffer)]);
  }

  // ../../node_modules/@loaders.gl/images/dist/esm/lib/parsers/parse-to-image.js
  async function parseToImage(arrayBuffer, options, url) {
    const blobOrDataUrl = getBlobOrSVGDataUrl(arrayBuffer, url);
    const URL2 = self.URL || self.webkitURL;
    const objectUrl = typeof blobOrDataUrl !== "string" && URL2.createObjectURL(blobOrDataUrl);
    try {
      return await loadToImage(objectUrl || blobOrDataUrl, options);
    } finally {
      if (objectUrl) {
        URL2.revokeObjectURL(objectUrl);
      }
    }
  }
  async function loadToImage(url, options) {
    const image = new Image();
    image.src = url;
    if (options.image && options.image.decode && image.decode) {
      await image.decode();
      return image;
    }
    return await new Promise((resolve, reject) => {
      try {
        image.onload = () => resolve(image);
        image.onerror = (err) => reject(new Error("Could not load image ".concat(url, ": ").concat(err)));
      } catch (error2) {
        reject(error2);
      }
    });
  }

  // ../../node_modules/@loaders.gl/images/dist/esm/lib/parsers/parse-to-image-bitmap.js
  var EMPTY_OBJECT = {};
  var imagebitmapOptionsSupported = true;
  async function parseToImageBitmap(arrayBuffer, options, url) {
    let blob;
    if (isSVG(url)) {
      const image = await parseToImage(arrayBuffer, options, url);
      blob = image;
    } else {
      blob = getBlob(arrayBuffer, url);
    }
    const imagebitmapOptions = options && options.imagebitmap;
    return await safeCreateImageBitmap(blob, imagebitmapOptions);
  }
  async function safeCreateImageBitmap(blob) {
    let imagebitmapOptions = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    if (isEmptyObject(imagebitmapOptions) || !imagebitmapOptionsSupported) {
      imagebitmapOptions = null;
    }
    if (imagebitmapOptions) {
      try {
        return await createImageBitmap(blob, imagebitmapOptions);
      } catch (error2) {
        console.warn(error2);
        imagebitmapOptionsSupported = false;
      }
    }
    return await createImageBitmap(blob);
  }
  function isEmptyObject(object) {
    for (const key in object || EMPTY_OBJECT) {
      return false;
    }
    return true;
  }

  // ../../node_modules/@loaders.gl/images/dist/esm/lib/category-api/binary-image-api.js
  var BIG_ENDIAN = false;
  var LITTLE_ENDIAN = true;
  function getBinaryImageMetadata(binaryData) {
    const dataView = toDataView(binaryData);
    return getPngMetadata(dataView) || getJpegMetadata(dataView) || getGifMetadata(dataView) || getBmpMetadata(dataView);
  }
  function getPngMetadata(binaryData) {
    const dataView = toDataView(binaryData);
    const isPng = dataView.byteLength >= 24 && dataView.getUint32(0, BIG_ENDIAN) === 2303741511;
    if (!isPng) {
      return null;
    }
    return {
      mimeType: "image/png",
      width: dataView.getUint32(16, BIG_ENDIAN),
      height: dataView.getUint32(20, BIG_ENDIAN)
    };
  }
  function getGifMetadata(binaryData) {
    const dataView = toDataView(binaryData);
    const isGif = dataView.byteLength >= 10 && dataView.getUint32(0, BIG_ENDIAN) === 1195984440;
    if (!isGif) {
      return null;
    }
    return {
      mimeType: "image/gif",
      width: dataView.getUint16(6, LITTLE_ENDIAN),
      height: dataView.getUint16(8, LITTLE_ENDIAN)
    };
  }
  function getBmpMetadata(binaryData) {
    const dataView = toDataView(binaryData);
    const isBmp = dataView.byteLength >= 14 && dataView.getUint16(0, BIG_ENDIAN) === 16973 && dataView.getUint32(2, LITTLE_ENDIAN) === dataView.byteLength;
    if (!isBmp) {
      return null;
    }
    return {
      mimeType: "image/bmp",
      width: dataView.getUint32(18, LITTLE_ENDIAN),
      height: dataView.getUint32(22, LITTLE_ENDIAN)
    };
  }
  function getJpegMetadata(binaryData) {
    const dataView = toDataView(binaryData);
    const isJpeg = dataView.byteLength >= 3 && dataView.getUint16(0, BIG_ENDIAN) === 65496 && dataView.getUint8(2) === 255;
    if (!isJpeg) {
      return null;
    }
    const {
      tableMarkers,
      sofMarkers
    } = getJpegMarkers();
    let i3 = 2;
    while (i3 + 9 < dataView.byteLength) {
      const marker2 = dataView.getUint16(i3, BIG_ENDIAN);
      if (sofMarkers.has(marker2)) {
        return {
          mimeType: "image/jpeg",
          height: dataView.getUint16(i3 + 5, BIG_ENDIAN),
          width: dataView.getUint16(i3 + 7, BIG_ENDIAN)
        };
      }
      if (!tableMarkers.has(marker2)) {
        return null;
      }
      i3 += 2;
      i3 += dataView.getUint16(i3, BIG_ENDIAN);
    }
    return null;
  }
  function getJpegMarkers() {
    const tableMarkers = /* @__PURE__ */ new Set([65499, 65476, 65484, 65501, 65534]);
    for (let i3 = 65504; i3 < 65520; ++i3) {
      tableMarkers.add(i3);
    }
    const sofMarkers = /* @__PURE__ */ new Set([65472, 65473, 65474, 65475, 65477, 65478, 65479, 65481, 65482, 65483, 65485, 65486, 65487, 65502]);
    return {
      tableMarkers,
      sofMarkers
    };
  }
  function toDataView(data) {
    if (data instanceof DataView) {
      return data;
    }
    if (ArrayBuffer.isView(data)) {
      return new DataView(data.buffer);
    }
    if (data instanceof ArrayBuffer) {
      return new DataView(data);
    }
    throw new Error("toDataView");
  }

  // ../../node_modules/@loaders.gl/images/dist/esm/lib/parsers/parse-to-node-image.js
  async function parseToNodeImage(arrayBuffer, options) {
    const {
      mimeType
    } = getBinaryImageMetadata(arrayBuffer) || {};
    const _parseImageNode2 = globalThis._parseImageNode;
    assert2(_parseImageNode2);
    return await _parseImageNode2(arrayBuffer, mimeType);
  }

  // ../../node_modules/@loaders.gl/images/dist/esm/lib/parsers/parse-image.js
  async function parseImage(arrayBuffer, options, context) {
    options = options || {};
    const imageOptions = options.image || {};
    const imageType = imageOptions.type || "auto";
    const {
      url
    } = context || {};
    const loadType = getLoadableImageType(imageType);
    let image;
    switch (loadType) {
      case "imagebitmap":
        image = await parseToImageBitmap(arrayBuffer, options, url);
        break;
      case "image":
        image = await parseToImage(arrayBuffer, options, url);
        break;
      case "data":
        image = await parseToNodeImage(arrayBuffer, options);
        break;
      default:
        assert2(false);
    }
    if (imageType === "data") {
      image = getImageData(image);
    }
    return image;
  }
  function getLoadableImageType(type) {
    switch (type) {
      case "auto":
      case "data":
        return getDefaultImageType();
      default:
        isImageTypeSupported(type);
        return type;
    }
  }

  // ../../node_modules/@loaders.gl/images/dist/esm/image-loader.js
  var EXTENSIONS = ["png", "jpg", "jpeg", "gif", "webp", "bmp", "ico", "svg"];
  var MIME_TYPES = ["image/png", "image/jpeg", "image/gif", "image/webp", "image/bmp", "image/vnd.microsoft.icon", "image/svg+xml"];
  var DEFAULT_IMAGE_LOADER_OPTIONS = {
    image: {
      type: "auto",
      decode: true
    }
  };
  var ImageLoader = {
    id: "image",
    module: "images",
    name: "Images",
    version: VERSION4,
    mimeTypes: MIME_TYPES,
    extensions: EXTENSIONS,
    parse: parseImage,
    tests: [(arrayBuffer) => Boolean(getBinaryImageMetadata(new DataView(arrayBuffer)))],
    options: DEFAULT_IMAGE_LOADER_OPTIONS
  };

  // ../../node_modules/@loaders.gl/images/dist/esm/lib/category-api/image-format.js
  var NODE_FORMAT_SUPPORT = ["image/png", "image/jpeg", "image/gif"];
  var mimeTypeSupported = {};
  function _isImageFormatSupported(mimeType) {
    if (mimeTypeSupported[mimeType] === void 0) {
      mimeTypeSupported[mimeType] = checkFormatSupport(mimeType);
    }
    return mimeTypeSupported[mimeType];
  }
  function checkFormatSupport(mimeType) {
    switch (mimeType) {
      case "image/webp":
        return checkWebPSupport();
      case "image/svg":
        return isBrowser;
      default:
        if (!isBrowser) {
          const {
            _parseImageNode: _parseImageNode2
          } = globalThis;
          return Boolean(_parseImageNode2) && NODE_FORMAT_SUPPORT.includes(mimeType);
        }
        return true;
    }
  }
  function checkWebPSupport() {
    if (!isBrowser) {
      return false;
    }
    try {
      const element = document.createElement("canvas");
      return element.toDataURL("image/webp").indexOf("data:image/webp") === 0;
    } catch {
      return false;
    }
  }

  // ../../node_modules/@loaders.gl/wms/dist/esm/lib/data-sources/image-services/image-service.js
  var ImageService = class extends ImageSource {
    constructor(props) {
      super();
      _defineProperty(this, "props", void 0);
      _defineProperty(this, "fetch", void 0);
      this.props = mergeImageServiceProps(props);
      this.fetch = getFetchFunction(props);
    }
    async getMetadata() {
      throw new Error("ImageSource.getMetadata not implemented");
    }
    async getImage(parameters) {
      const granularParameters = this.getGranularParameters(parameters);
      const url = this.getURLFromTemplate(granularParameters);
      const response = await this.fetch(url);
      const arrayBuffer = await response.arrayBuffer();
      return await ImageLoader.parse(arrayBuffer);
    }
    getGranularParameters(parameters) {
      const [east, north, west, south] = parameters.bbox;
      return {
        ...parameters,
        east,
        north,
        south,
        west
      };
    }
    getURLFromTemplate(parameters) {
      let url = this.props.url;
      for (const [key, value] of Object.entries(parameters)) {
        url = url.replace("${".concat(key, "}"), String(value));
        url = url.replace("{".concat(key, "}"), String(value));
      }
      return url;
    }
  };
  _defineProperty(ImageService, "type", "template");
  _defineProperty(ImageService, "testURL", (url) => url.toLowerCase().includes("{"));
  function getFetchFunction(options) {
    const fetchFunction = options === null || options === void 0 ? void 0 : options.fetch;
    if (fetchFunction && typeof fetchFunction === "function") {
      return (url, fetchOptions2) => fetchFunction(url, fetchOptions2);
    }
    const fetchOptions = options === null || options === void 0 ? void 0 : options.fetch;
    if (fetchOptions && typeof fetchOptions !== "function") {
      return (url) => fetch(url, fetchOptions);
    }
    return (url) => fetch(url);
  }
  function mergeImageServiceProps(props) {
    return {
      ...props,
      loadOptions: {
        ...props.loadOptions,
        fetch: getFetchFunction(props.loadOptions)
      }
    };
  }

  // ../../node_modules/@loaders.gl/wms/dist/esm/wip/wms-feature-info-loader.js
  var WMSFeatureInfoLoader = {
    ...WMSCapabilitiesLoader,
    id: "wms-feature-info",
    name: "WMS FeatureInfo",
    parse: async (arrayBuffer, options) => parseWMSFeatureInfo(new TextDecoder().decode(arrayBuffer), options),
    parseTextSync: (text, options) => parseWMSFeatureInfo(text, options)
  };

  // ../../node_modules/@loaders.gl/wms/dist/esm/wip/wms-layer-description-loader.js
  var WMSLayerDescriptionLoader = {
    ...WMSCapabilitiesLoader,
    id: "wms-layer-description",
    name: "WMS DescribeLayer",
    parse: async (arrayBuffer, options) => parseWMSLayerDescription(new TextDecoder().decode(arrayBuffer), options),
    parseTextSync: (text, options) => parseWMSLayerDescription(text, options)
  };

  // ../../node_modules/@loaders.gl/wms/dist/esm/lib/data-sources/image-services/wms-service.js
  var WMSService = class extends ImageSource {
    constructor(props) {
      var _this$props$loadOptio;
      super();
      _defineProperty(this, "props", void 0);
      _defineProperty(this, "fetch", void 0);
      _defineProperty(this, "capabilities", null);
      _defineProperty(this, "loaders", [ImageLoader, WMSErrorLoader, WMSCapabilitiesLoader, WMSFeatureInfoLoader, WMSLayerDescriptionLoader]);
      this.props = mergeImageServiceProps(props);
      this.fetch = getFetchFunction(this.props);
      this.props.loadOptions = {
        ...this.props.loadOptions,
        wms: {
          ...(_this$props$loadOptio = this.props.loadOptions) === null || _this$props$loadOptio === void 0 ? void 0 : _this$props$loadOptio.wms,
          throwOnError: true
        }
      };
    }
    getMetadata() {
      return this.getCapabilities();
    }
    getImage(parameters) {
      return this.getMap(parameters);
    }
    async getCapabilities(wmsParameters, vendorParameters) {
      const url = this.getCapabilitiesURL(wmsParameters, vendorParameters);
      const response = await this.fetch(url);
      const arrayBuffer = await response.arrayBuffer();
      this._checkResponse(response, arrayBuffer);
      const capabilities = await WMSCapabilitiesLoader.parse(arrayBuffer, this.props.loadOptions);
      this.capabilities = capabilities;
      return capabilities;
    }
    async getMap(options, vendorParameters) {
      const url = this.getMapURL(options, vendorParameters);
      const response = await this.fetch(url);
      const arrayBuffer = await response.arrayBuffer();
      this._checkResponse(response, arrayBuffer);
      try {
        return await ImageLoader.parse(arrayBuffer, this.props.loadOptions);
      } catch {
        throw this._parseError(arrayBuffer);
      }
    }
    async getFeatureInfo(options, vendorParameters) {
      const url = this.getFeatureInfoURL(options, vendorParameters);
      const response = await this.fetch(url);
      const arrayBuffer = await response.arrayBuffer();
      this._checkResponse(response, arrayBuffer);
      return await WMSFeatureInfoLoader.parse(arrayBuffer, this.props.loadOptions);
    }
    async getFeatureInfoText(options, vendorParameters) {
      options = {
        ...options,
        info_format: "text/plain"
      };
      const url = this.getFeatureInfoURL(options, vendorParameters);
      const response = await this.fetch(url);
      const arrayBuffer = await response.arrayBuffer();
      this._checkResponse(response, arrayBuffer);
      return new TextDecoder().decode(arrayBuffer);
    }
    async describeLayer(options, vendorParameters) {
      const url = this.describeLayerURL(options, vendorParameters);
      const response = await this.fetch(url);
      const arrayBuffer = await response.arrayBuffer();
      this._checkResponse(response, arrayBuffer);
      return await WMSLayerDescriptionLoader.parse(arrayBuffer, this.props.loadOptions);
    }
    async getLegendGraphic(options, vendorParameters) {
      const url = this.getLegendGraphicURL(options, vendorParameters);
      const response = await this.fetch(url);
      const arrayBuffer = await response.arrayBuffer();
      this._checkResponse(response, arrayBuffer);
      try {
        return await ImageLoader.parse(arrayBuffer, this.props.loadOptions);
      } catch {
        throw this._parseError(arrayBuffer);
      }
    }
    getCapabilitiesURL(wmsParameters, vendorParameters) {
      const options = {
        service: "WMS",
        version: "1.1.1",
        request: "GetCapabilities",
        ...wmsParameters,
        ...vendorParameters
      };
      return this._getWMSUrl(options, vendorParameters);
    }
    getMapURL(wmsParameters, vendorParameters) {
      const options = {
        service: "WMS",
        version: "1.1.1",
        request: "GetMap",
        styles: void 0,
        srs: "EPSG:4326",
        format: "image/png",
        ...wmsParameters,
        ...vendorParameters
      };
      return this._getWMSUrl(options, vendorParameters);
    }
    getFeatureInfoURL(wmsParameters, vendorParameters) {
      const options = {
        service: "WMS",
        version: "1.1.1",
        request: "GetFeatureInfo",
        srs: "EPSG:4326",
        format: "image/png",
        info_format: "text/plain",
        styles: void 0,
        ...wmsParameters,
        ...vendorParameters
      };
      return this._getWMSUrl(options, vendorParameters);
    }
    describeLayerURL(wmsParameters, vendorParameters) {
      const options = {
        service: "WMS",
        version: "1.1.1",
        request: "DescribeLayer",
        ...wmsParameters,
        ...vendorParameters
      };
      return this._getWMSUrl(options, vendorParameters);
    }
    getLegendGraphicURL(wmsParameters, vendorParameters) {
      const options = {
        service: "WMS",
        version: "1.1.1",
        request: "GetLegendGraphic",
        ...wmsParameters,
        ...vendorParameters
      };
      return this._getWMSUrl(options, vendorParameters);
    }
    _getWMSUrl(options, vendorParameters) {
      let url = this.props.url;
      let first = true;
      for (const [key, value] of Object.entries(options)) {
        url += first ? "?" : "&";
        first = false;
        if (Array.isArray(value)) {
          url += "".concat(key.toUpperCase(), "=").concat(value.join(","));
        } else {
          url += "".concat(key.toUpperCase(), "=").concat(value ? String(value) : "");
        }
      }
      return encodeURI(url);
    }
    _checkResponse(response, arrayBuffer) {
      const contentType = response.headers["content-type"];
      if (!response.ok || WMSErrorLoader.mimeTypes.includes(contentType)) {
        const error2 = WMSErrorLoader.parseSync(arrayBuffer, this.props.loadOptions);
        throw new Error(error2);
      }
    }
    _parseError(arrayBuffer) {
      const error2 = WMSErrorLoader.parseSync(arrayBuffer, this.props.loadOptions);
      return new Error(error2);
    }
  };
  _defineProperty(WMSService, "type", "wms");
  _defineProperty(WMSService, "testURL", (url) => url.toLowerCase().includes("wms"));

  // ../../node_modules/@loaders.gl/wms/dist/esm/lib/data-sources/image-services/arcgis-image-service.js
  var ArcGISImageService = class extends ImageSource {
    constructor(props) {
      super();
      _defineProperty(this, "props", void 0);
      _defineProperty(this, "fetch", void 0);
      this.props = mergeImageServiceProps(props);
      this.fetch = getFetchFunction(this.props);
    }
    async getMetadata() {
      return await this.info();
    }
    async getImage(parameters) {
      throw new Error("not implemented");
    }
    async info() {
      throw new Error("not implemented");
    }
    exportImage(options) {
      throw new Error("not implemented");
    }
    infoURL(options) {
      return this.props.url;
    }
    exportImageURL(options) {
      return this.props.url;
    }
    getUrl(options, extra) {
      let url = "".concat(this.props.url);
      let first = true;
      for (const [key, value] of Object.entries(options)) {
        url += first ? "?" : "&";
        first = false;
        if (Array.isArray(value)) {
          url += "".concat(key.toUpperCase(), "=").concat(value.join(","));
        } else {
          url += "".concat(key.toUpperCase(), "=").concat(value ? String(value) : "");
        }
      }
      return url;
    }
    async checkResponse(response) {
      if (!response.ok) {
        throw new Error("error");
      }
    }
  };
  _defineProperty(ArcGISImageService, "type", "arcgis-image-server");
  _defineProperty(ArcGISImageService, "testURL", (url) => url.toLowerCase().includes("ImageServer"));

  // ../../node_modules/@loaders.gl/wms/dist/esm/lib/data-sources/create-image-source.js
  var SERVICES = [WMSService, ArcGISImageService, ImageService];
  function createImageSource(props) {
    const {
      type = "auto"
    } = props;
    const serviceType = type === "auto" ? guessServiceType(props.url) : type;
    switch (serviceType) {
      case "template":
        return new ImageService(props);
      case "wms":
        return new WMSService(props);
      default:
        throw new Error("Not a valid image source type");
    }
  }
  function guessServiceType(url) {
    for (const Service of SERVICES) {
      if (Service.testURL && Service.testURL(url)) {
        return Service.type;
      }
    }
    return "wms";
  }

  // ../../node_modules/gl-matrix/esm/common.js
  var EPSILON = 1e-6;
  var ARRAY_TYPE = typeof Float32Array !== "undefined" ? Float32Array : Array;
  var degree = Math.PI / 180;
  if (!Math.hypot)
    Math.hypot = function() {
      var y2 = 0, i3 = arguments.length;
      while (i3--) {
        y2 += arguments[i3] * arguments[i3];
      }
      return Math.sqrt(y2);
    };

  // ../../node_modules/gl-matrix/esm/vec4.js
  function create() {
    var out = new ARRAY_TYPE(4);
    if (ARRAY_TYPE != Float32Array) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      out[3] = 0;
    }
    return out;
  }
  function add(out, a2, b) {
    out[0] = a2[0] + b[0];
    out[1] = a2[1] + b[1];
    out[2] = a2[2] + b[2];
    out[3] = a2[3] + b[3];
    return out;
  }
  function scale(out, a2, b) {
    out[0] = a2[0] * b;
    out[1] = a2[1] * b;
    out[2] = a2[2] * b;
    out[3] = a2[3] * b;
    return out;
  }
  function length(a2) {
    var x2 = a2[0];
    var y2 = a2[1];
    var z = a2[2];
    var w = a2[3];
    return Math.hypot(x2, y2, z, w);
  }
  function squaredLength(a2) {
    var x2 = a2[0];
    var y2 = a2[1];
    var z = a2[2];
    var w = a2[3];
    return x2 * x2 + y2 * y2 + z * z + w * w;
  }
  function normalize(out, a2) {
    var x2 = a2[0];
    var y2 = a2[1];
    var z = a2[2];
    var w = a2[3];
    var len2 = x2 * x2 + y2 * y2 + z * z + w * w;
    if (len2 > 0) {
      len2 = 1 / Math.sqrt(len2);
    }
    out[0] = x2 * len2;
    out[1] = y2 * len2;
    out[2] = z * len2;
    out[3] = w * len2;
    return out;
  }
  function dot(a2, b) {
    return a2[0] * b[0] + a2[1] * b[1] + a2[2] * b[2] + a2[3] * b[3];
  }
  function lerp(out, a2, b, t2) {
    var ax = a2[0];
    var ay = a2[1];
    var az = a2[2];
    var aw = a2[3];
    out[0] = ax + t2 * (b[0] - ax);
    out[1] = ay + t2 * (b[1] - ay);
    out[2] = az + t2 * (b[2] - az);
    out[3] = aw + t2 * (b[3] - aw);
    return out;
  }
  function transformMat4(out, a2, m) {
    var x2 = a2[0], y2 = a2[1], z = a2[2], w = a2[3];
    out[0] = m[0] * x2 + m[4] * y2 + m[8] * z + m[12] * w;
    out[1] = m[1] * x2 + m[5] * y2 + m[9] * z + m[13] * w;
    out[2] = m[2] * x2 + m[6] * y2 + m[10] * z + m[14] * w;
    out[3] = m[3] * x2 + m[7] * y2 + m[11] * z + m[15] * w;
    return out;
  }
  function transformQuat(out, a2, q) {
    var x2 = a2[0], y2 = a2[1], z = a2[2];
    var qx = q[0], qy = q[1], qz = q[2], qw = q[3];
    var ix = qw * x2 + qy * z - qz * y2;
    var iy = qw * y2 + qz * x2 - qx * z;
    var iz = qw * z + qx * y2 - qy * x2;
    var iw = -qx * x2 - qy * y2 - qz * z;
    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    out[3] = a2[3];
    return out;
  }
  var forEach = function() {
    var vec = create();
    return function(a2, stride, offset, count, fn, arg) {
      var i3, l2;
      if (!stride) {
        stride = 4;
      }
      if (!offset) {
        offset = 0;
      }
      if (count) {
        l2 = Math.min(count * stride + offset, a2.length);
      } else {
        l2 = a2.length;
      }
      for (i3 = offset; i3 < l2; i3 += stride) {
        vec[0] = a2[i3];
        vec[1] = a2[i3 + 1];
        vec[2] = a2[i3 + 2];
        vec[3] = a2[i3 + 3];
        fn(vec, vec, arg);
        a2[i3] = vec[0];
        a2[i3 + 1] = vec[1];
        a2[i3 + 2] = vec[2];
        a2[i3 + 3] = vec[3];
      }
      return a2;
    };
  }();

  // ../../node_modules/gl-matrix/esm/mat4.js
  function identity(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  function transpose(out, a2) {
    if (out === a2) {
      var a01 = a2[1], a02 = a2[2], a03 = a2[3];
      var a12 = a2[6], a13 = a2[7];
      var a23 = a2[11];
      out[1] = a2[4];
      out[2] = a2[8];
      out[3] = a2[12];
      out[4] = a01;
      out[6] = a2[9];
      out[7] = a2[13];
      out[8] = a02;
      out[9] = a12;
      out[11] = a2[14];
      out[12] = a03;
      out[13] = a13;
      out[14] = a23;
    } else {
      out[0] = a2[0];
      out[1] = a2[4];
      out[2] = a2[8];
      out[3] = a2[12];
      out[4] = a2[1];
      out[5] = a2[5];
      out[6] = a2[9];
      out[7] = a2[13];
      out[8] = a2[2];
      out[9] = a2[6];
      out[10] = a2[10];
      out[11] = a2[14];
      out[12] = a2[3];
      out[13] = a2[7];
      out[14] = a2[11];
      out[15] = a2[15];
    }
    return out;
  }
  function invert(out, a2) {
    var a00 = a2[0], a01 = a2[1], a02 = a2[2], a03 = a2[3];
    var a10 = a2[4], a11 = a2[5], a12 = a2[6], a13 = a2[7];
    var a20 = a2[8], a21 = a2[9], a22 = a2[10], a23 = a2[11];
    var a30 = a2[12], a31 = a2[13], a32 = a2[14], a33 = a2[15];
    var b00 = a00 * a11 - a01 * a10;
    var b01 = a00 * a12 - a02 * a10;
    var b02 = a00 * a13 - a03 * a10;
    var b03 = a01 * a12 - a02 * a11;
    var b04 = a01 * a13 - a03 * a11;
    var b05 = a02 * a13 - a03 * a12;
    var b06 = a20 * a31 - a21 * a30;
    var b07 = a20 * a32 - a22 * a30;
    var b08 = a20 * a33 - a23 * a30;
    var b09 = a21 * a32 - a22 * a31;
    var b10 = a21 * a33 - a23 * a31;
    var b11 = a22 * a33 - a23 * a32;
    var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
    if (!det) {
      return null;
    }
    det = 1 / det;
    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
    return out;
  }
  function determinant(a2) {
    var a00 = a2[0], a01 = a2[1], a02 = a2[2], a03 = a2[3];
    var a10 = a2[4], a11 = a2[5], a12 = a2[6], a13 = a2[7];
    var a20 = a2[8], a21 = a2[9], a22 = a2[10], a23 = a2[11];
    var a30 = a2[12], a31 = a2[13], a32 = a2[14], a33 = a2[15];
    var b00 = a00 * a11 - a01 * a10;
    var b01 = a00 * a12 - a02 * a10;
    var b02 = a00 * a13 - a03 * a10;
    var b03 = a01 * a12 - a02 * a11;
    var b04 = a01 * a13 - a03 * a11;
    var b05 = a02 * a13 - a03 * a12;
    var b06 = a20 * a31 - a21 * a30;
    var b07 = a20 * a32 - a22 * a30;
    var b08 = a20 * a33 - a23 * a30;
    var b09 = a21 * a32 - a22 * a31;
    var b10 = a21 * a33 - a23 * a31;
    var b11 = a22 * a33 - a23 * a32;
    return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
  }
  function multiply(out, a2, b) {
    var a00 = a2[0], a01 = a2[1], a02 = a2[2], a03 = a2[3];
    var a10 = a2[4], a11 = a2[5], a12 = a2[6], a13 = a2[7];
    var a20 = a2[8], a21 = a2[9], a22 = a2[10], a23 = a2[11];
    var a30 = a2[12], a31 = a2[13], a32 = a2[14], a33 = a2[15];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[4];
    b1 = b[5];
    b2 = b[6];
    b3 = b[7];
    out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[8];
    b1 = b[9];
    b2 = b[10];
    b3 = b[11];
    out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[12];
    b1 = b[13];
    b2 = b[14];
    b3 = b[15];
    out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    return out;
  }
  function translate(out, a2, v) {
    var x2 = v[0], y2 = v[1], z = v[2];
    var a00, a01, a02, a03;
    var a10, a11, a12, a13;
    var a20, a21, a22, a23;
    if (a2 === out) {
      out[12] = a2[0] * x2 + a2[4] * y2 + a2[8] * z + a2[12];
      out[13] = a2[1] * x2 + a2[5] * y2 + a2[9] * z + a2[13];
      out[14] = a2[2] * x2 + a2[6] * y2 + a2[10] * z + a2[14];
      out[15] = a2[3] * x2 + a2[7] * y2 + a2[11] * z + a2[15];
    } else {
      a00 = a2[0];
      a01 = a2[1];
      a02 = a2[2];
      a03 = a2[3];
      a10 = a2[4];
      a11 = a2[5];
      a12 = a2[6];
      a13 = a2[7];
      a20 = a2[8];
      a21 = a2[9];
      a22 = a2[10];
      a23 = a2[11];
      out[0] = a00;
      out[1] = a01;
      out[2] = a02;
      out[3] = a03;
      out[4] = a10;
      out[5] = a11;
      out[6] = a12;
      out[7] = a13;
      out[8] = a20;
      out[9] = a21;
      out[10] = a22;
      out[11] = a23;
      out[12] = a00 * x2 + a10 * y2 + a20 * z + a2[12];
      out[13] = a01 * x2 + a11 * y2 + a21 * z + a2[13];
      out[14] = a02 * x2 + a12 * y2 + a22 * z + a2[14];
      out[15] = a03 * x2 + a13 * y2 + a23 * z + a2[15];
    }
    return out;
  }
  function scale2(out, a2, v) {
    var x2 = v[0], y2 = v[1], z = v[2];
    out[0] = a2[0] * x2;
    out[1] = a2[1] * x2;
    out[2] = a2[2] * x2;
    out[3] = a2[3] * x2;
    out[4] = a2[4] * y2;
    out[5] = a2[5] * y2;
    out[6] = a2[6] * y2;
    out[7] = a2[7] * y2;
    out[8] = a2[8] * z;
    out[9] = a2[9] * z;
    out[10] = a2[10] * z;
    out[11] = a2[11] * z;
    out[12] = a2[12];
    out[13] = a2[13];
    out[14] = a2[14];
    out[15] = a2[15];
    return out;
  }
  function rotate(out, a2, rad, axis) {
    var x2 = axis[0], y2 = axis[1], z = axis[2];
    var len2 = Math.hypot(x2, y2, z);
    var s2, c, t2;
    var a00, a01, a02, a03;
    var a10, a11, a12, a13;
    var a20, a21, a22, a23;
    var b00, b01, b02;
    var b10, b11, b12;
    var b20, b21, b22;
    if (len2 < EPSILON) {
      return null;
    }
    len2 = 1 / len2;
    x2 *= len2;
    y2 *= len2;
    z *= len2;
    s2 = Math.sin(rad);
    c = Math.cos(rad);
    t2 = 1 - c;
    a00 = a2[0];
    a01 = a2[1];
    a02 = a2[2];
    a03 = a2[3];
    a10 = a2[4];
    a11 = a2[5];
    a12 = a2[6];
    a13 = a2[7];
    a20 = a2[8];
    a21 = a2[9];
    a22 = a2[10];
    a23 = a2[11];
    b00 = x2 * x2 * t2 + c;
    b01 = y2 * x2 * t2 + z * s2;
    b02 = z * x2 * t2 - y2 * s2;
    b10 = x2 * y2 * t2 - z * s2;
    b11 = y2 * y2 * t2 + c;
    b12 = z * y2 * t2 + x2 * s2;
    b20 = x2 * z * t2 + y2 * s2;
    b21 = y2 * z * t2 - x2 * s2;
    b22 = z * z * t2 + c;
    out[0] = a00 * b00 + a10 * b01 + a20 * b02;
    out[1] = a01 * b00 + a11 * b01 + a21 * b02;
    out[2] = a02 * b00 + a12 * b01 + a22 * b02;
    out[3] = a03 * b00 + a13 * b01 + a23 * b02;
    out[4] = a00 * b10 + a10 * b11 + a20 * b12;
    out[5] = a01 * b10 + a11 * b11 + a21 * b12;
    out[6] = a02 * b10 + a12 * b11 + a22 * b12;
    out[7] = a03 * b10 + a13 * b11 + a23 * b12;
    out[8] = a00 * b20 + a10 * b21 + a20 * b22;
    out[9] = a01 * b20 + a11 * b21 + a21 * b22;
    out[10] = a02 * b20 + a12 * b21 + a22 * b22;
    out[11] = a03 * b20 + a13 * b21 + a23 * b22;
    if (a2 !== out) {
      out[12] = a2[12];
      out[13] = a2[13];
      out[14] = a2[14];
      out[15] = a2[15];
    }
    return out;
  }
  function rotateX(out, a2, rad) {
    var s2 = Math.sin(rad);
    var c = Math.cos(rad);
    var a10 = a2[4];
    var a11 = a2[5];
    var a12 = a2[6];
    var a13 = a2[7];
    var a20 = a2[8];
    var a21 = a2[9];
    var a22 = a2[10];
    var a23 = a2[11];
    if (a2 !== out) {
      out[0] = a2[0];
      out[1] = a2[1];
      out[2] = a2[2];
      out[3] = a2[3];
      out[12] = a2[12];
      out[13] = a2[13];
      out[14] = a2[14];
      out[15] = a2[15];
    }
    out[4] = a10 * c + a20 * s2;
    out[5] = a11 * c + a21 * s2;
    out[6] = a12 * c + a22 * s2;
    out[7] = a13 * c + a23 * s2;
    out[8] = a20 * c - a10 * s2;
    out[9] = a21 * c - a11 * s2;
    out[10] = a22 * c - a12 * s2;
    out[11] = a23 * c - a13 * s2;
    return out;
  }
  function rotateY(out, a2, rad) {
    var s2 = Math.sin(rad);
    var c = Math.cos(rad);
    var a00 = a2[0];
    var a01 = a2[1];
    var a02 = a2[2];
    var a03 = a2[3];
    var a20 = a2[8];
    var a21 = a2[9];
    var a22 = a2[10];
    var a23 = a2[11];
    if (a2 !== out) {
      out[4] = a2[4];
      out[5] = a2[5];
      out[6] = a2[6];
      out[7] = a2[7];
      out[12] = a2[12];
      out[13] = a2[13];
      out[14] = a2[14];
      out[15] = a2[15];
    }
    out[0] = a00 * c - a20 * s2;
    out[1] = a01 * c - a21 * s2;
    out[2] = a02 * c - a22 * s2;
    out[3] = a03 * c - a23 * s2;
    out[8] = a00 * s2 + a20 * c;
    out[9] = a01 * s2 + a21 * c;
    out[10] = a02 * s2 + a22 * c;
    out[11] = a03 * s2 + a23 * c;
    return out;
  }
  function rotateZ(out, a2, rad) {
    var s2 = Math.sin(rad);
    var c = Math.cos(rad);
    var a00 = a2[0];
    var a01 = a2[1];
    var a02 = a2[2];
    var a03 = a2[3];
    var a10 = a2[4];
    var a11 = a2[5];
    var a12 = a2[6];
    var a13 = a2[7];
    if (a2 !== out) {
      out[8] = a2[8];
      out[9] = a2[9];
      out[10] = a2[10];
      out[11] = a2[11];
      out[12] = a2[12];
      out[13] = a2[13];
      out[14] = a2[14];
      out[15] = a2[15];
    }
    out[0] = a00 * c + a10 * s2;
    out[1] = a01 * c + a11 * s2;
    out[2] = a02 * c + a12 * s2;
    out[3] = a03 * c + a13 * s2;
    out[4] = a10 * c - a00 * s2;
    out[5] = a11 * c - a01 * s2;
    out[6] = a12 * c - a02 * s2;
    out[7] = a13 * c - a03 * s2;
    return out;
  }
  function getScaling(out, mat) {
    var m11 = mat[0];
    var m12 = mat[1];
    var m13 = mat[2];
    var m21 = mat[4];
    var m22 = mat[5];
    var m23 = mat[6];
    var m31 = mat[8];
    var m32 = mat[9];
    var m33 = mat[10];
    out[0] = Math.hypot(m11, m12, m13);
    out[1] = Math.hypot(m21, m22, m23);
    out[2] = Math.hypot(m31, m32, m33);
    return out;
  }
  function fromQuat(out, q) {
    var x2 = q[0], y2 = q[1], z = q[2], w = q[3];
    var x22 = x2 + x2;
    var y22 = y2 + y2;
    var z2 = z + z;
    var xx = x2 * x22;
    var yx = y2 * x22;
    var yy = y2 * y22;
    var zx = z * x22;
    var zy = z * y22;
    var zz = z * z2;
    var wx = w * x22;
    var wy = w * y22;
    var wz = w * z2;
    out[0] = 1 - yy - zz;
    out[1] = yx + wz;
    out[2] = zx - wy;
    out[3] = 0;
    out[4] = yx - wz;
    out[5] = 1 - xx - zz;
    out[6] = zy + wx;
    out[7] = 0;
    out[8] = zx + wy;
    out[9] = zy - wx;
    out[10] = 1 - xx - yy;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  function frustum(out, left, right, bottom, top, near, far) {
    var rl = 1 / (right - left);
    var tb = 1 / (top - bottom);
    var nf = 1 / (near - far);
    out[0] = near * 2 * rl;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = near * 2 * tb;
    out[6] = 0;
    out[7] = 0;
    out[8] = (right + left) * rl;
    out[9] = (top + bottom) * tb;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = far * near * 2 * nf;
    out[15] = 0;
    return out;
  }
  function perspectiveNO(out, fovy, aspect, near, far) {
    var f2 = 1 / Math.tan(fovy / 2), nf;
    out[0] = f2 / aspect;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = f2;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[15] = 0;
    if (far != null && far !== Infinity) {
      nf = 1 / (near - far);
      out[10] = (far + near) * nf;
      out[14] = 2 * far * near * nf;
    } else {
      out[10] = -1;
      out[14] = -2 * near;
    }
    return out;
  }
  var perspective = perspectiveNO;
  function orthoNO(out, left, right, bottom, top, near, far) {
    var lr = 1 / (left - right);
    var bt = 1 / (bottom - top);
    var nf = 1 / (near - far);
    out[0] = -2 * lr;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = -2 * bt;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 2 * nf;
    out[11] = 0;
    out[12] = (left + right) * lr;
    out[13] = (top + bottom) * bt;
    out[14] = (far + near) * nf;
    out[15] = 1;
    return out;
  }
  var ortho = orthoNO;
  function lookAt(out, eye, center, up) {
    var x0, x1, x2, y0, y1, y2, z0, z1, z2, len2;
    var eyex = eye[0];
    var eyey = eye[1];
    var eyez = eye[2];
    var upx = up[0];
    var upy = up[1];
    var upz = up[2];
    var centerx = center[0];
    var centery = center[1];
    var centerz = center[2];
    if (Math.abs(eyex - centerx) < EPSILON && Math.abs(eyey - centery) < EPSILON && Math.abs(eyez - centerz) < EPSILON) {
      return identity(out);
    }
    z0 = eyex - centerx;
    z1 = eyey - centery;
    z2 = eyez - centerz;
    len2 = 1 / Math.hypot(z0, z1, z2);
    z0 *= len2;
    z1 *= len2;
    z2 *= len2;
    x0 = upy * z2 - upz * z1;
    x1 = upz * z0 - upx * z2;
    x2 = upx * z1 - upy * z0;
    len2 = Math.hypot(x0, x1, x2);
    if (!len2) {
      x0 = 0;
      x1 = 0;
      x2 = 0;
    } else {
      len2 = 1 / len2;
      x0 *= len2;
      x1 *= len2;
      x2 *= len2;
    }
    y0 = z1 * x2 - z2 * x1;
    y1 = z2 * x0 - z0 * x2;
    y2 = z0 * x1 - z1 * x0;
    len2 = Math.hypot(y0, y1, y2);
    if (!len2) {
      y0 = 0;
      y1 = 0;
      y2 = 0;
    } else {
      len2 = 1 / len2;
      y0 *= len2;
      y1 *= len2;
      y2 *= len2;
    }
    out[0] = x0;
    out[1] = y0;
    out[2] = z0;
    out[3] = 0;
    out[4] = x1;
    out[5] = y1;
    out[6] = z1;
    out[7] = 0;
    out[8] = x2;
    out[9] = y2;
    out[10] = z2;
    out[11] = 0;
    out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
    out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
    out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
    out[15] = 1;
    return out;
  }

  // ../../node_modules/gl-matrix/esm/vec2.js
  function create2() {
    var out = new ARRAY_TYPE(2);
    if (ARRAY_TYPE != Float32Array) {
      out[0] = 0;
      out[1] = 0;
    }
    return out;
  }
  function transformMat2(out, a2, m) {
    var x2 = a2[0], y2 = a2[1];
    out[0] = m[0] * x2 + m[2] * y2;
    out[1] = m[1] * x2 + m[3] * y2;
    return out;
  }
  function transformMat2d(out, a2, m) {
    var x2 = a2[0], y2 = a2[1];
    out[0] = m[0] * x2 + m[2] * y2 + m[4];
    out[1] = m[1] * x2 + m[3] * y2 + m[5];
    return out;
  }
  function transformMat3(out, a2, m) {
    var x2 = a2[0], y2 = a2[1];
    out[0] = m[0] * x2 + m[3] * y2 + m[6];
    out[1] = m[1] * x2 + m[4] * y2 + m[7];
    return out;
  }
  function transformMat42(out, a2, m) {
    var x2 = a2[0];
    var y2 = a2[1];
    out[0] = m[0] * x2 + m[4] * y2 + m[12];
    out[1] = m[1] * x2 + m[5] * y2 + m[13];
    return out;
  }
  var forEach2 = function() {
    var vec = create2();
    return function(a2, stride, offset, count, fn, arg) {
      var i3, l2;
      if (!stride) {
        stride = 2;
      }
      if (!offset) {
        offset = 0;
      }
      if (count) {
        l2 = Math.min(count * stride + offset, a2.length);
      } else {
        l2 = a2.length;
      }
      for (i3 = offset; i3 < l2; i3 += stride) {
        vec[0] = a2[i3];
        vec[1] = a2[i3 + 1];
        fn(vec, vec, arg);
        a2[i3] = vec[0];
        a2[i3 + 1] = vec[1];
      }
      return a2;
    };
  }();

  // ../../node_modules/gl-matrix/esm/vec3.js
  function create3() {
    var out = new ARRAY_TYPE(3);
    if (ARRAY_TYPE != Float32Array) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
    }
    return out;
  }
  function length2(a2) {
    var x2 = a2[0];
    var y2 = a2[1];
    var z = a2[2];
    return Math.hypot(x2, y2, z);
  }
  function fromValues(x2, y2, z) {
    var out = new ARRAY_TYPE(3);
    out[0] = x2;
    out[1] = y2;
    out[2] = z;
    return out;
  }
  function normalize2(out, a2) {
    var x2 = a2[0];
    var y2 = a2[1];
    var z = a2[2];
    var len2 = x2 * x2 + y2 * y2 + z * z;
    if (len2 > 0) {
      len2 = 1 / Math.sqrt(len2);
    }
    out[0] = a2[0] * len2;
    out[1] = a2[1] * len2;
    out[2] = a2[2] * len2;
    return out;
  }
  function dot2(a2, b) {
    return a2[0] * b[0] + a2[1] * b[1] + a2[2] * b[2];
  }
  function cross(out, a2, b) {
    var ax = a2[0], ay = a2[1], az = a2[2];
    var bx = b[0], by = b[1], bz = b[2];
    out[0] = ay * bz - az * by;
    out[1] = az * bx - ax * bz;
    out[2] = ax * by - ay * bx;
    return out;
  }
  function transformMat43(out, a2, m) {
    var x2 = a2[0], y2 = a2[1], z = a2[2];
    var w = m[3] * x2 + m[7] * y2 + m[11] * z + m[15];
    w = w || 1;
    out[0] = (m[0] * x2 + m[4] * y2 + m[8] * z + m[12]) / w;
    out[1] = (m[1] * x2 + m[5] * y2 + m[9] * z + m[13]) / w;
    out[2] = (m[2] * x2 + m[6] * y2 + m[10] * z + m[14]) / w;
    return out;
  }
  function transformMat32(out, a2, m) {
    var x2 = a2[0], y2 = a2[1], z = a2[2];
    out[0] = x2 * m[0] + y2 * m[3] + z * m[6];
    out[1] = x2 * m[1] + y2 * m[4] + z * m[7];
    out[2] = x2 * m[2] + y2 * m[5] + z * m[8];
    return out;
  }
  function transformQuat2(out, a2, q) {
    var qx = q[0], qy = q[1], qz = q[2], qw = q[3];
    var x2 = a2[0], y2 = a2[1], z = a2[2];
    var uvx = qy * z - qz * y2, uvy = qz * x2 - qx * z, uvz = qx * y2 - qy * x2;
    var uuvx = qy * uvz - qz * uvy, uuvy = qz * uvx - qx * uvz, uuvz = qx * uvy - qy * uvx;
    var w2 = qw * 2;
    uvx *= w2;
    uvy *= w2;
    uvz *= w2;
    uuvx *= 2;
    uuvy *= 2;
    uuvz *= 2;
    out[0] = x2 + uvx + uuvx;
    out[1] = y2 + uvy + uuvy;
    out[2] = z + uvz + uuvz;
    return out;
  }
  function rotateX2(out, a2, b, rad) {
    var p2 = [], r2 = [];
    p2[0] = a2[0] - b[0];
    p2[1] = a2[1] - b[1];
    p2[2] = a2[2] - b[2];
    r2[0] = p2[0];
    r2[1] = p2[1] * Math.cos(rad) - p2[2] * Math.sin(rad);
    r2[2] = p2[1] * Math.sin(rad) + p2[2] * Math.cos(rad);
    out[0] = r2[0] + b[0];
    out[1] = r2[1] + b[1];
    out[2] = r2[2] + b[2];
    return out;
  }
  function rotateY2(out, a2, b, rad) {
    var p2 = [], r2 = [];
    p2[0] = a2[0] - b[0];
    p2[1] = a2[1] - b[1];
    p2[2] = a2[2] - b[2];
    r2[0] = p2[2] * Math.sin(rad) + p2[0] * Math.cos(rad);
    r2[1] = p2[1];
    r2[2] = p2[2] * Math.cos(rad) - p2[0] * Math.sin(rad);
    out[0] = r2[0] + b[0];
    out[1] = r2[1] + b[1];
    out[2] = r2[2] + b[2];
    return out;
  }
  function rotateZ2(out, a2, b, rad) {
    var p2 = [], r2 = [];
    p2[0] = a2[0] - b[0];
    p2[1] = a2[1] - b[1];
    p2[2] = a2[2] - b[2];
    r2[0] = p2[0] * Math.cos(rad) - p2[1] * Math.sin(rad);
    r2[1] = p2[0] * Math.sin(rad) + p2[1] * Math.cos(rad);
    r2[2] = p2[2];
    out[0] = r2[0] + b[0];
    out[1] = r2[1] + b[1];
    out[2] = r2[2] + b[2];
    return out;
  }
  function angle(a2, b) {
    var ax = a2[0], ay = a2[1], az = a2[2], bx = b[0], by = b[1], bz = b[2], mag1 = Math.sqrt(ax * ax + ay * ay + az * az), mag2 = Math.sqrt(bx * bx + by * by + bz * bz), mag = mag1 * mag2, cosine = mag && dot2(a2, b) / mag;
    return Math.acos(Math.min(Math.max(cosine, -1), 1));
  }
  var len = length2;
  var forEach3 = function() {
    var vec = create3();
    return function(a2, stride, offset, count, fn, arg) {
      var i3, l2;
      if (!stride) {
        stride = 3;
      }
      if (!offset) {
        offset = 0;
      }
      if (count) {
        l2 = Math.min(count * stride + offset, a2.length);
      } else {
        l2 = a2.length;
      }
      for (i3 = offset; i3 < l2; i3 += stride) {
        vec[0] = a2[i3];
        vec[1] = a2[i3 + 1];
        vec[2] = a2[i3 + 2];
        fn(vec, vec, arg);
        a2[i3] = vec[0];
        a2[i3 + 1] = vec[1];
        a2[i3 + 2] = vec[2];
      }
      return a2;
    };
  }();

  // ../../node_modules/@math.gl/web-mercator/dist/esm/assert.js
  function assert4(condition, message) {
    if (!condition) {
      throw new Error(message || "@math.gl/web-mercator: assertion failed.");
    }
  }

  // ../../node_modules/@math.gl/web-mercator/dist/esm/web-mercator-utils.js
  var PI = Math.PI;
  var PI_4 = PI / 4;
  var DEGREES_TO_RADIANS = PI / 180;
  var RADIANS_TO_DEGREES = 180 / PI;
  var TILE_SIZE = 512;
  function lngLatToWorld(lngLat) {
    const [lng, lat] = lngLat;
    assert4(Number.isFinite(lng));
    assert4(Number.isFinite(lat) && lat >= -90 && lat <= 90, "invalid latitude");
    const lambda2 = lng * DEGREES_TO_RADIANS;
    const phi2 = lat * DEGREES_TO_RADIANS;
    const x2 = TILE_SIZE * (lambda2 + PI) / (2 * PI);
    const y2 = TILE_SIZE * (PI + Math.log(Math.tan(PI_4 + phi2 * 0.5))) / (2 * PI);
    return [x2, y2];
  }
  function worldToLngLat(xy) {
    const [x2, y2] = xy;
    const lambda2 = x2 / TILE_SIZE * (2 * PI) - PI;
    const phi2 = 2 * (Math.atan(Math.exp(y2 / TILE_SIZE * (2 * PI) - PI)) - PI_4);
    return [lambda2 * RADIANS_TO_DEGREES, phi2 * RADIANS_TO_DEGREES];
  }

  // ../../node_modules/@math.gl/web-mercator/dist/esm/get-bounds.js
  var DEGREES_TO_RADIANS2 = Math.PI / 180;

  // src/wms-layer/utils.ts
  var HALF_EARTH_CIRCUMFERENCE = 6378137 * Math.PI;
  function WGS84ToPseudoMercator(coord) {
    const mercator = lngLatToWorld(coord);
    mercator[0] = (mercator[0] / 256 - 1) * HALF_EARTH_CIRCUMFERENCE;
    mercator[1] = (mercator[1] / 256 - 1) * HALF_EARTH_CIRCUMFERENCE;
    return mercator;
  }

  // src/wms-layer/wms-layer.ts
  var defaultProps = {
    id: "imagery-layer",
    data: "",
    serviceType: "auto",
    srs: "auto",
    layers: {
      type: "array",
      compare: true,
      value: []
    },
    onMetadataLoad: {
      type: "function",
      value: () => {
      }
    },
    onMetadataLoadError: {
      type: "function",
      value: console.error
    },
    onImageLoadStart: {
      type: "function",
      value: () => {
      }
    },
    onImageLoad: {
      type: "function",
      value: () => {
      }
    },
    onImageLoadError: {
      type: "function",
      compare: false,
      value: (requestId, error2) => console.error(error2, requestId)
    }
  };
  var WMSLayer = class extends import_core.CompositeLayer {
    shouldUpdateState() {
      return true;
    }
    initializeState() {
      this.state._nextRequestId = 0;
      this.state.lastRequestId = -1;
    }
    updateState({
      changeFlags,
      props,
      oldProps
    }) {
      const {
        viewport
      } = this.context;
      if (changeFlags.dataChanged || props.serviceType !== oldProps.serviceType) {
        this.state.imageSource = this._createImageSource(props);
        this._loadMetadata();
        this.debounce(() => this.loadImage(viewport, "image source changed"), 0);
      } else if (!(0, import_core._deepEqual)(props.layers, oldProps.layers, 1)) {
        this.debounce(() => this.loadImage(viewport, "layers changed"), 0);
      } else if (changeFlags.viewportChanged) {
        this.debounce(() => this.loadImage(viewport, "viewport changed"));
      }
    }
    finalizeState() {
    }
    renderLayers() {
      const {
        bounds,
        image,
        lastRequestParameters
      } = this.state;
      return image && new import_layers2.BitmapLayer({
        ...this.getSubLayerProps({
          id: "bitmap"
        }),
        _imageCoordinateSystem: lastRequestParameters.srs === "EPSG:4326" ? import_core.COORDINATE_SYSTEM.LNGLAT : import_core.COORDINATE_SYSTEM.CARTESIAN,
        bounds,
        image
      });
    }
    async getFeatureInfoText(x2, y2) {
      const {
        lastRequestParameters
      } = this.state;
      if (lastRequestParameters) {
        const featureInfo = await this.state.imageSource.getFeatureInfoText?.({
          ...lastRequestParameters,
          query_layers: lastRequestParameters.layers,
          x: x2,
          y: y2,
          info_format: "application/vnd.ogc.gml"
        });
        return featureInfo;
      }
      return "";
    }
    _createImageSource(props) {
      if (props.data instanceof ImageSource) {
        return props.data;
      }
      if (typeof props.data === "string") {
        return createImageSource({
          url: props.data,
          loadOptions: props.loadOptions,
          type: props.serviceType
        });
      }
      throw new Error("invalid image source in props.data");
    }
    async _loadMetadata() {
      const {
        imageSource
      } = this.state;
      try {
        const metadata = await imageSource.getMetadata();
        if (this.state.imageSource === imageSource) {
          this.getCurrentLayer()?.props.onMetadataLoad(metadata);
        }
      } catch (error2) {
        this.getCurrentLayer()?.props.onMetadataLoadError(error2);
      }
    }
    async loadImage(viewport, reason) {
      const {
        layers,
        serviceType
      } = this.props;
      if (serviceType === "wms" && layers.length === 0) {
        return;
      }
      const bounds = viewport.getBounds();
      const {
        width,
        height
      } = viewport;
      const requestId = this.getRequestId();
      let {
        srs
      } = this.props;
      if (srs === "auto") {
        srs = viewport.resolution ? "EPSG:4326" : "EPSG:3857";
      }
      const requestParams = {
        width,
        height,
        bbox: bounds,
        layers,
        srs
      };
      if (srs === "EPSG:3857") {
        const [minX, minY] = WGS84ToPseudoMercator([bounds[0], bounds[1]]);
        const [maxX, maxY] = WGS84ToPseudoMercator([bounds[2], bounds[3]]);
        requestParams.bbox = [minX, minY, maxX, maxY];
      }
      try {
        this.props.onImageLoadStart(requestId);
        const image = await this.state.imageSource.getImage(requestParams);
        if (this.state.lastRequestId < requestId) {
          this.getCurrentLayer()?.props.onImageLoad(requestId);
          this.setState({
            image,
            bounds,
            lastRequestParameters: requestParams,
            lastRequestId: requestId
          });
        }
      } catch (error2) {
        this.raiseError(error2, "Load image");
        this.getCurrentLayer()?.props.onImageLoadError(requestId, error2);
      }
    }
    getRequestId() {
      return this.state._nextRequestId++;
    }
    debounce(fn, ms = 500) {
      clearTimeout(this.state._timeoutId);
      this.state._timeoutId = setTimeout(() => fn(), ms);
    }
  };
  __publicField(WMSLayer, "layerName", "WMSLayer");
  __publicField(WMSLayer, "defaultProps", defaultProps);

  // src/great-circle-layer/great-circle-layer.ts
  var import_layers3 = __toESM(require_layers());
  var defaultProps2 = {
    getHeight: {
      type: "accessor",
      value: 0
    },
    greatCircle: true
  };
  var GreatCircleLayer = class extends import_layers3.ArcLayer {
  };
  __publicField(GreatCircleLayer, "layerName", "GreatCircleLayer");
  __publicField(GreatCircleLayer, "defaultProps", defaultProps2);

  // src/geo-cell-layer/GeoCellLayer.ts
  var import_core2 = __toESM(require_core());
  var import_layers4 = __toESM(require_layers());
  var defaultProps3 = {
    ...import_layers4.PolygonLayer.defaultProps
  };
  var GeoCellLayer = class extends import_core2.CompositeLayer {
    indexToBounds() {
      return null;
    }
    renderLayers() {
      const {
        elevationScale,
        extruded,
        wireframe,
        filled,
        stroked,
        lineWidthUnits,
        lineWidthScale,
        lineWidthMinPixels,
        lineWidthMaxPixels,
        lineJointRounded,
        lineMiterLimit,
        lineDashJustified,
        getElevation,
        getFillColor,
        getLineColor,
        getLineWidth
      } = this.props;
      const {
        updateTriggers,
        material,
        transitions
      } = this.props;
      const CellLayer = this.getSubLayerClass("cell", import_layers4.PolygonLayer);
      return new CellLayer({
        filled,
        wireframe,
        extruded,
        elevationScale,
        stroked,
        lineWidthUnits,
        lineWidthScale,
        lineWidthMinPixels,
        lineWidthMaxPixels,
        lineJointRounded,
        lineMiterLimit,
        lineDashJustified,
        material,
        transitions,
        getElevation,
        getFillColor,
        getLineColor,
        getLineWidth
      }, this.getSubLayerProps({
        id: "cell",
        updateTriggers: updateTriggers && {
          getElevation: updateTriggers.getElevation,
          getFillColor: updateTriggers.getFillColor,
          getLineColor: updateTriggers.getLineColor,
          getLineWidth: updateTriggers.getLineWidth
        }
      }), this.indexToBounds());
    }
  };
  __publicField(GeoCellLayer, "layerName", "GeoCellLayer");
  __publicField(GeoCellLayer, "defaultProps", defaultProps3);

  // src/s2-layer/s2-geometry.ts
  var import_long = __toESM(require_long());
  var FACE_BITS = 3;
  var MAX_LEVEL = 30;
  var POS_BITS = 2 * MAX_LEVEL + 1;
  var RADIAN_TO_DEGREE = 180 / Math.PI;
  function IJToST(ij, order, offsets) {
    const maxSize = 1 << order;
    return [(ij[0] + offsets[0]) / maxSize, (ij[1] + offsets[1]) / maxSize];
  }
  function singleSTtoUV(st) {
    if (st >= 0.5) {
      return 1 / 3 * (4 * st * st - 1);
    }
    return 1 / 3 * (1 - 4 * (1 - st) * (1 - st));
  }
  function STToUV(st) {
    return [singleSTtoUV(st[0]), singleSTtoUV(st[1])];
  }
  function FaceUVToXYZ(face, [u, v]) {
    switch (face) {
      case 0:
        return [1, u, v];
      case 1:
        return [-u, 1, v];
      case 2:
        return [-u, -v, 1];
      case 3:
        return [-1, -v, -u];
      case 4:
        return [v, -1, -u];
      case 5:
        return [v, u, -1];
      default:
        throw new Error("Invalid face");
    }
  }
  function XYZToLngLat([x2, y2, z]) {
    const lat = Math.atan2(z, Math.sqrt(x2 * x2 + y2 * y2));
    const lng = Math.atan2(y2, x2);
    return [lng * RADIAN_TO_DEGREE, lat * RADIAN_TO_DEGREE];
  }
  function toHilbertQuadkey(idS) {
    let bin = import_long.default.fromString(idS, true, 10).toString(2);
    while (bin.length < FACE_BITS + POS_BITS) {
      bin = "0" + bin;
    }
    const lsbIndex = bin.lastIndexOf("1");
    const faceB = bin.substring(0, 3);
    const posB = bin.substring(3, lsbIndex);
    const levelN = posB.length / 2;
    const faceS = import_long.default.fromString(faceB, true, 2).toString(10);
    let posS = import_long.default.fromString(posB, true, 2).toString(4);
    while (posS.length < levelN) {
      posS = "0" + posS;
    }
    return `${faceS}/${posS}`;
  }
  function rotateAndFlipQuadrant(n2, point, rx, ry) {
    if (ry === 0) {
      if (rx === 1) {
        point[0] = n2 - 1 - point[0];
        point[1] = n2 - 1 - point[1];
      }
      const x2 = point[0];
      point[0] = point[1];
      point[1] = x2;
    }
  }
  function FromHilbertQuadKey(hilbertQuadkey) {
    const parts = hilbertQuadkey.split("/");
    const face = parseInt(parts[0], 10);
    const position = parts[1];
    const maxLevel = position.length;
    const point = [0, 0];
    let level;
    for (let i3 = maxLevel - 1; i3 >= 0; i3--) {
      level = maxLevel - i3;
      const bit = position[i3];
      let rx = 0;
      let ry = 0;
      if (bit === "1") {
        ry = 1;
      } else if (bit === "2") {
        rx = 1;
        ry = 1;
      } else if (bit === "3") {
        rx = 1;
      }
      const val = Math.pow(2, level - 1);
      rotateAndFlipQuadrant(val, point, rx, ry);
      point[0] += val * rx;
      point[1] += val * ry;
    }
    if (face % 2 === 1) {
      const t2 = point[0];
      point[0] = point[1];
      point[1] = t2;
    }
    return {
      face,
      ij: point,
      level
    };
  }

  // src/s2-layer/s2-utils.ts
  var import_long2 = __toESM(require_long());
  function getIdFromToken(token) {
    const paddedToken = token.padEnd(16, "0");
    return import_long2.default.fromString(paddedToken, 16);
  }
  var MAX_RESOLUTION = 100;
  function getGeoBounds({
    face,
    ij,
    level
  }) {
    const offsets = [[0, 0], [0, 1], [1, 1], [1, 0], [0, 0]];
    const resolution = Math.max(1, Math.ceil(MAX_RESOLUTION * Math.pow(2, -level)));
    const result = new Float64Array(4 * resolution * 2 + 2);
    let ptIndex = 0;
    let prevLng = 0;
    for (let i3 = 0; i3 < 4; i3++) {
      const offset = offsets[i3].slice(0);
      const nextOffset = offsets[i3 + 1];
      const stepI = (nextOffset[0] - offset[0]) / resolution;
      const stepJ = (nextOffset[1] - offset[1]) / resolution;
      for (let j = 0; j < resolution; j++) {
        offset[0] += stepI;
        offset[1] += stepJ;
        const st = IJToST(ij, level, offset);
        const uv = STToUV(st);
        const xyz = FaceUVToXYZ(face, uv);
        const lngLat = XYZToLngLat(xyz);
        if (Math.abs(lngLat[1]) > 89.999) {
          lngLat[0] = prevLng;
        }
        const deltaLng = lngLat[0] - prevLng;
        lngLat[0] += deltaLng > 180 ? -360 : deltaLng < -180 ? 360 : 0;
        result[ptIndex++] = lngLat[0];
        result[ptIndex++] = lngLat[1];
        prevLng = lngLat[0];
      }
    }
    result[ptIndex++] = result[0];
    result[ptIndex++] = result[1];
    return result;
  }
  function getS2QuadKey(token) {
    if (typeof token === "string") {
      if (token.indexOf("/") > 0) {
        return token;
      }
      token = getIdFromToken(token);
    }
    return toHilbertQuadkey(token.toString());
  }
  function getS2Polygon(token) {
    const key = getS2QuadKey(token);
    const s2cell = FromHilbertQuadKey(key);
    return getGeoBounds(s2cell);
  }

  // src/s2-layer/s2-layer.ts
  var defaultProps4 = {
    getS2Token: {
      type: "accessor",
      value: (d) => d.token
    }
  };
  var S2Layer = class extends GeoCellLayer {
    indexToBounds() {
      const {
        data,
        getS2Token
      } = this.props;
      return {
        data,
        _normalize: false,
        positionFormat: "XY",
        getPolygon: (x2, objectInfo) => getS2Polygon(getS2Token(x2, objectInfo))
      };
    }
  };
  __publicField(S2Layer, "layerName", "S2Layer");
  __publicField(S2Layer, "defaultProps", defaultProps4);

  // src/quadkey-layer/quadkey-utils.ts
  var TILE_SIZE2 = 512;
  function quadkeyToWorldBounds(quadkey) {
    let x2 = 0;
    let y2 = 0;
    let mask = 1 << quadkey.length;
    const scale5 = mask / TILE_SIZE2;
    for (let i3 = 0; i3 < quadkey.length; i3++) {
      mask >>= 1;
      const q = parseInt(quadkey[i3]);
      if (q % 2)
        x2 |= mask;
      if (q > 1)
        y2 |= mask;
    }
    return [[x2 / scale5, TILE_SIZE2 - y2 / scale5], [(x2 + 0.99) / scale5, TILE_SIZE2 - (y2 + 0.99) / scale5]];
  }
  function getQuadkeyPolygon(quadkey) {
    const [topLeft, bottomRight] = quadkeyToWorldBounds(quadkey);
    const [w, n2] = worldToLngLat(topLeft);
    const [e, s2] = worldToLngLat(bottomRight);
    return [e, n2, e, s2, w, s2, w, n2, e, n2];
  }

  // src/quadkey-layer/quadkey-layer.ts
  var defaultProps5 = {
    getQuadkey: {
      type: "accessor",
      value: (d) => d.quadkey
    }
  };
  var QuadkeyLayer = class extends GeoCellLayer {
    indexToBounds() {
      const {
        data,
        getQuadkey
      } = this.props;
      return {
        data,
        _normalize: false,
        positionFormat: "XY",
        getPolygon: (x2, objectInfo) => getQuadkeyPolygon(getQuadkey(x2, objectInfo))
      };
    }
  };
  __publicField(QuadkeyLayer, "layerName", "QuadkeyLayer");
  __publicField(QuadkeyLayer, "defaultProps", defaultProps5);

  // src/tile-layer/tile-layer.ts
  var import_core14 = __toESM(require_core());
  var import_layers5 = __toESM(require_layers());

  // ../../node_modules/@math.gl/core/dist/esm/lib/assert.js
  function assert5(condition, message) {
    if (!condition) {
      throw new Error("math.gl assertion ".concat(message));
    }
  }

  // ../../node_modules/@math.gl/core/dist/esm/lib/common.js
  var RADIANS_TO_DEGREES2 = 1 / Math.PI * 180;
  var DEGREES_TO_RADIANS3 = 1 / 180 * Math.PI;
  var config = {
    EPSILON: 1e-12,
    debug: false,
    precision: 4,
    printTypes: false,
    printDegrees: false,
    printRowMajor: true
  };
  function formatValue(value, {
    precision = config.precision
  } = {}) {
    value = round(value);
    return "".concat(parseFloat(value.toPrecision(precision)));
  }
  function isArray(value) {
    return Array.isArray(value) || ArrayBuffer.isView(value) && !(value instanceof DataView);
  }
  function toRadians(degrees2) {
    return radians(degrees2);
  }
  function toDegrees(radians2) {
    return degrees(radians2);
  }
  function radians(degrees2, result) {
    return map(degrees2, (degrees3) => degrees3 * DEGREES_TO_RADIANS3, result);
  }
  function degrees(radians2, result) {
    return map(radians2, (radians3) => radians3 * RADIANS_TO_DEGREES2, result);
  }
  function clamp2(value, min, max) {
    return map(value, (value2) => Math.max(min, Math.min(max, value2)));
  }
  function lerp3(a2, b, t2) {
    if (isArray(a2)) {
      return a2.map((ai, i3) => lerp3(ai, b[i3], t2));
    }
    return t2 * b + (1 - t2) * a2;
  }
  function equals(a2, b, epsilon) {
    const oldEpsilon = config.EPSILON;
    if (epsilon) {
      config.EPSILON = epsilon;
    }
    try {
      if (a2 === b) {
        return true;
      }
      if (isArray(a2) && isArray(b)) {
        if (a2.length !== b.length) {
          return false;
        }
        for (let i3 = 0; i3 < a2.length; ++i3) {
          if (!equals(a2[i3], b[i3])) {
            return false;
          }
        }
        return true;
      }
      if (a2 && a2.equals) {
        return a2.equals(b);
      }
      if (b && b.equals) {
        return b.equals(a2);
      }
      if (typeof a2 === "number" && typeof b === "number") {
        return Math.abs(a2 - b) <= config.EPSILON * Math.max(1, Math.abs(a2), Math.abs(b));
      }
      return false;
    } finally {
      config.EPSILON = oldEpsilon;
    }
  }
  function round(value) {
    return Math.round(value / config.EPSILON) * config.EPSILON;
  }
  function duplicateArray(array) {
    return array.clone ? array.clone() : new Array(array.length);
  }
  function map(value, func, result) {
    if (isArray(value)) {
      const array = value;
      result = result || duplicateArray(array);
      for (let i3 = 0; i3 < result.length && i3 < array.length; ++i3) {
        result[i3] = func(value[i3], i3, result);
      }
      return result;
    }
    return func(value);
  }

  // ../../node_modules/@math.gl/core/dist/esm/classes/base/math-array.js
  function _extendableBuiltin(cls) {
    function ExtendableBuiltin() {
      var instance = Reflect.construct(cls, Array.from(arguments));
      Object.setPrototypeOf(instance, Object.getPrototypeOf(this));
      return instance;
    }
    ExtendableBuiltin.prototype = Object.create(cls.prototype, {
      constructor: {
        value: cls,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(ExtendableBuiltin, cls);
    } else {
      ExtendableBuiltin.__proto__ = cls;
    }
    return ExtendableBuiltin;
  }
  var MathArray = class extends _extendableBuiltin(Array) {
    clone() {
      return new this.constructor().copy(this);
    }
    fromArray(array, offset = 0) {
      for (let i3 = 0; i3 < this.ELEMENTS; ++i3) {
        this[i3] = array[i3 + offset];
      }
      return this.check();
    }
    toArray(targetArray = [], offset = 0) {
      for (let i3 = 0; i3 < this.ELEMENTS; ++i3) {
        targetArray[offset + i3] = this[i3];
      }
      return targetArray;
    }
    from(arrayOrObject) {
      return Array.isArray(arrayOrObject) ? this.copy(arrayOrObject) : this.fromObject(arrayOrObject);
    }
    to(arrayOrObject) {
      if (arrayOrObject === this) {
        return this;
      }
      return isArray(arrayOrObject) ? this.toArray(arrayOrObject) : this.toObject(arrayOrObject);
    }
    toTarget(target) {
      return target ? this.to(target) : this;
    }
    toFloat32Array() {
      return new Float32Array(this);
    }
    toString() {
      return this.formatString(config);
    }
    formatString(opts) {
      let string = "";
      for (let i3 = 0; i3 < this.ELEMENTS; ++i3) {
        string += (i3 > 0 ? ", " : "") + formatValue(this[i3], opts);
      }
      return "".concat(opts.printTypes ? this.constructor.name : "", "[").concat(string, "]");
    }
    equals(array) {
      if (!array || this.length !== array.length) {
        return false;
      }
      for (let i3 = 0; i3 < this.ELEMENTS; ++i3) {
        if (!equals(this[i3], array[i3])) {
          return false;
        }
      }
      return true;
    }
    exactEquals(array) {
      if (!array || this.length !== array.length) {
        return false;
      }
      for (let i3 = 0; i3 < this.ELEMENTS; ++i3) {
        if (this[i3] !== array[i3]) {
          return false;
        }
      }
      return true;
    }
    negate() {
      for (let i3 = 0; i3 < this.ELEMENTS; ++i3) {
        this[i3] = -this[i3];
      }
      return this.check();
    }
    lerp(a2, b, t2) {
      if (t2 === void 0) {
        return this.lerp(this, a2, b);
      }
      for (let i3 = 0; i3 < this.ELEMENTS; ++i3) {
        const ai = a2[i3];
        this[i3] = ai + t2 * (b[i3] - ai);
      }
      return this.check();
    }
    min(vector) {
      for (let i3 = 0; i3 < this.ELEMENTS; ++i3) {
        this[i3] = Math.min(vector[i3], this[i3]);
      }
      return this.check();
    }
    max(vector) {
      for (let i3 = 0; i3 < this.ELEMENTS; ++i3) {
        this[i3] = Math.max(vector[i3], this[i3]);
      }
      return this.check();
    }
    clamp(minVector, maxVector) {
      for (let i3 = 0; i3 < this.ELEMENTS; ++i3) {
        this[i3] = Math.min(Math.max(this[i3], minVector[i3]), maxVector[i3]);
      }
      return this.check();
    }
    add(...vectors) {
      for (const vector of vectors) {
        for (let i3 = 0; i3 < this.ELEMENTS; ++i3) {
          this[i3] += vector[i3];
        }
      }
      return this.check();
    }
    subtract(...vectors) {
      for (const vector of vectors) {
        for (let i3 = 0; i3 < this.ELEMENTS; ++i3) {
          this[i3] -= vector[i3];
        }
      }
      return this.check();
    }
    scale(scale5) {
      if (typeof scale5 === "number") {
        for (let i3 = 0; i3 < this.ELEMENTS; ++i3) {
          this[i3] *= scale5;
        }
      } else {
        for (let i3 = 0; i3 < this.ELEMENTS && i3 < scale5.length; ++i3) {
          this[i3] *= scale5[i3];
        }
      }
      return this.check();
    }
    multiplyByScalar(scalar) {
      for (let i3 = 0; i3 < this.ELEMENTS; ++i3) {
        this[i3] *= scalar;
      }
      return this.check();
    }
    check() {
      if (config.debug && !this.validate()) {
        throw new Error("math.gl: ".concat(this.constructor.name, " some fields set to invalid numbers'"));
      }
      return this;
    }
    validate() {
      let valid = this.length === this.ELEMENTS;
      for (let i3 = 0; i3 < this.ELEMENTS; ++i3) {
        valid = valid && Number.isFinite(this[i3]);
      }
      return valid;
    }
    sub(a2) {
      return this.subtract(a2);
    }
    setScalar(a2) {
      for (let i3 = 0; i3 < this.ELEMENTS; ++i3) {
        this[i3] = a2;
      }
      return this.check();
    }
    addScalar(a2) {
      for (let i3 = 0; i3 < this.ELEMENTS; ++i3) {
        this[i3] += a2;
      }
      return this.check();
    }
    subScalar(a2) {
      return this.addScalar(-a2);
    }
    multiplyScalar(scalar) {
      for (let i3 = 0; i3 < this.ELEMENTS; ++i3) {
        this[i3] *= scalar;
      }
      return this.check();
    }
    divideScalar(a2) {
      return this.multiplyByScalar(1 / a2);
    }
    clampScalar(min, max) {
      for (let i3 = 0; i3 < this.ELEMENTS; ++i3) {
        this[i3] = Math.min(Math.max(this[i3], min), max);
      }
      return this.check();
    }
    get elements() {
      return this;
    }
  };

  // ../../node_modules/@math.gl/core/dist/esm/lib/validators.js
  function validateVector(v, length5) {
    if (v.length !== length5) {
      return false;
    }
    for (let i3 = 0; i3 < v.length; ++i3) {
      if (!Number.isFinite(v[i3])) {
        return false;
      }
    }
    return true;
  }
  function checkNumber(value) {
    if (!Number.isFinite(value)) {
      throw new Error("Invalid number ".concat(value));
    }
    return value;
  }
  function checkVector(v, length5, callerName = "") {
    if (config.debug && !validateVector(v, length5)) {
      throw new Error("math.gl: ".concat(callerName, " some fields set to invalid numbers'"));
    }
    return v;
  }

  // ../../node_modules/@math.gl/core/dist/esm/classes/base/vector.js
  var Vector = class extends MathArray {
    get x() {
      return this[0];
    }
    set x(value) {
      this[0] = checkNumber(value);
    }
    get y() {
      return this[1];
    }
    set y(value) {
      this[1] = checkNumber(value);
    }
    len() {
      return Math.sqrt(this.lengthSquared());
    }
    magnitude() {
      return this.len();
    }
    lengthSquared() {
      let length5 = 0;
      for (let i3 = 0; i3 < this.ELEMENTS; ++i3) {
        length5 += this[i3] * this[i3];
      }
      return length5;
    }
    magnitudeSquared() {
      return this.lengthSquared();
    }
    distance(mathArray) {
      return Math.sqrt(this.distanceSquared(mathArray));
    }
    distanceSquared(mathArray) {
      let length5 = 0;
      for (let i3 = 0; i3 < this.ELEMENTS; ++i3) {
        const dist = this[i3] - mathArray[i3];
        length5 += dist * dist;
      }
      return checkNumber(length5);
    }
    dot(mathArray) {
      let product = 0;
      for (let i3 = 0; i3 < this.ELEMENTS; ++i3) {
        product += this[i3] * mathArray[i3];
      }
      return checkNumber(product);
    }
    normalize() {
      const length5 = this.magnitude();
      if (length5 !== 0) {
        for (let i3 = 0; i3 < this.ELEMENTS; ++i3) {
          this[i3] /= length5;
        }
      }
      return this.check();
    }
    multiply(...vectors) {
      for (const vector of vectors) {
        for (let i3 = 0; i3 < this.ELEMENTS; ++i3) {
          this[i3] *= vector[i3];
        }
      }
      return this.check();
    }
    divide(...vectors) {
      for (const vector of vectors) {
        for (let i3 = 0; i3 < this.ELEMENTS; ++i3) {
          this[i3] /= vector[i3];
        }
      }
      return this.check();
    }
    lengthSq() {
      return this.lengthSquared();
    }
    distanceTo(vector) {
      return this.distance(vector);
    }
    distanceToSquared(vector) {
      return this.distanceSquared(vector);
    }
    getComponent(i3) {
      assert5(i3 >= 0 && i3 < this.ELEMENTS, "index is out of range");
      return checkNumber(this[i3]);
    }
    setComponent(i3, value) {
      assert5(i3 >= 0 && i3 < this.ELEMENTS, "index is out of range");
      this[i3] = value;
      return this.check();
    }
    addVectors(a2, b) {
      return this.copy(a2).add(b);
    }
    subVectors(a2, b) {
      return this.copy(a2).subtract(b);
    }
    multiplyVectors(a2, b) {
      return this.copy(a2).multiply(b);
    }
    addScaledVector(a2, b) {
      return this.add(new this.constructor(a2).multiplyScalar(b));
    }
  };

  // ../../node_modules/@math.gl/core/dist/esm/lib/gl-matrix-extras.js
  function vec2_transformMat4AsVector(out, a2, m) {
    const x2 = a2[0];
    const y2 = a2[1];
    const w = m[3] * x2 + m[7] * y2 || 1;
    out[0] = (m[0] * x2 + m[4] * y2) / w;
    out[1] = (m[1] * x2 + m[5] * y2) / w;
    return out;
  }
  function vec3_transformMat4AsVector(out, a2, m) {
    const x2 = a2[0];
    const y2 = a2[1];
    const z = a2[2];
    const w = m[3] * x2 + m[7] * y2 + m[11] * z || 1;
    out[0] = (m[0] * x2 + m[4] * y2 + m[8] * z) / w;
    out[1] = (m[1] * x2 + m[5] * y2 + m[9] * z) / w;
    out[2] = (m[2] * x2 + m[6] * y2 + m[10] * z) / w;
    return out;
  }
  function vec3_transformMat2(out, a2, m) {
    const x2 = a2[0];
    const y2 = a2[1];
    out[0] = m[0] * x2 + m[2] * y2;
    out[1] = m[1] * x2 + m[3] * y2;
    out[2] = a2[2];
    return out;
  }
  function vec4_transformMat2(out, a2, m) {
    const x2 = a2[0];
    const y2 = a2[1];
    out[0] = m[0] * x2 + m[2] * y2;
    out[1] = m[1] * x2 + m[3] * y2;
    out[2] = a2[2];
    out[3] = a2[3];
    return out;
  }
  function vec4_transformMat3(out, a2, m) {
    const x2 = a2[0];
    const y2 = a2[1];
    const z = a2[2];
    out[0] = m[0] * x2 + m[3] * y2 + m[6] * z;
    out[1] = m[1] * x2 + m[4] * y2 + m[7] * z;
    out[2] = m[2] * x2 + m[5] * y2 + m[8] * z;
    out[3] = a2[3];
    return out;
  }

  // ../../node_modules/@math.gl/core/dist/esm/classes/vector2.js
  var Vector2 = class extends Vector {
    constructor(x2 = 0, y2 = 0) {
      super(2);
      if (isArray(x2) && arguments.length === 1) {
        this.copy(x2);
      } else {
        if (config.debug) {
          checkNumber(x2);
          checkNumber(y2);
        }
        this[0] = x2;
        this[1] = y2;
      }
    }
    set(x2, y2) {
      this[0] = x2;
      this[1] = y2;
      return this.check();
    }
    copy(array) {
      this[0] = array[0];
      this[1] = array[1];
      return this.check();
    }
    fromObject(object) {
      if (config.debug) {
        checkNumber(object.x);
        checkNumber(object.y);
      }
      this[0] = object.x;
      this[1] = object.y;
      return this.check();
    }
    toObject(object) {
      object.x = this[0];
      object.y = this[1];
      return object;
    }
    get ELEMENTS() {
      return 2;
    }
    horizontalAngle() {
      return Math.atan2(this.y, this.x);
    }
    verticalAngle() {
      return Math.atan2(this.x, this.y);
    }
    transform(matrix4) {
      return this.transformAsPoint(matrix4);
    }
    transformAsPoint(matrix4) {
      transformMat42(this, this, matrix4);
      return this.check();
    }
    transformAsVector(matrix4) {
      vec2_transformMat4AsVector(this, this, matrix4);
      return this.check();
    }
    transformByMatrix3(matrix3) {
      transformMat3(this, this, matrix3);
      return this.check();
    }
    transformByMatrix2x3(matrix2x3) {
      transformMat2d(this, this, matrix2x3);
      return this.check();
    }
    transformByMatrix2(matrix2) {
      transformMat2(this, this, matrix2);
      return this.check();
    }
  };

  // ../../node_modules/@math.gl/core/dist/esm/classes/vector3.js
  var ORIGIN = [0, 0, 0];
  var ZERO;
  var Vector3 = class extends Vector {
    static get ZERO() {
      if (!ZERO) {
        ZERO = new Vector3(0, 0, 0);
        Object.freeze(ZERO);
      }
      return ZERO;
    }
    constructor(x2 = 0, y2 = 0, z = 0) {
      super(-0, -0, -0);
      if (arguments.length === 1 && isArray(x2)) {
        this.copy(x2);
      } else {
        if (config.debug) {
          checkNumber(x2);
          checkNumber(y2);
          checkNumber(z);
        }
        this[0] = x2;
        this[1] = y2;
        this[2] = z;
      }
    }
    set(x2, y2, z) {
      this[0] = x2;
      this[1] = y2;
      this[2] = z;
      return this.check();
    }
    copy(array) {
      this[0] = array[0];
      this[1] = array[1];
      this[2] = array[2];
      return this.check();
    }
    fromObject(object) {
      if (config.debug) {
        checkNumber(object.x);
        checkNumber(object.y);
        checkNumber(object.z);
      }
      this[0] = object.x;
      this[1] = object.y;
      this[2] = object.z;
      return this.check();
    }
    toObject(object) {
      object.x = this[0];
      object.y = this[1];
      object.z = this[2];
      return object;
    }
    get ELEMENTS() {
      return 3;
    }
    get z() {
      return this[2];
    }
    set z(value) {
      this[2] = checkNumber(value);
    }
    angle(vector) {
      return angle(this, vector);
    }
    cross(vector) {
      cross(this, this, vector);
      return this.check();
    }
    rotateX({
      radians: radians2,
      origin = ORIGIN
    }) {
      rotateX2(this, this, origin, radians2);
      return this.check();
    }
    rotateY({
      radians: radians2,
      origin = ORIGIN
    }) {
      rotateY2(this, this, origin, radians2);
      return this.check();
    }
    rotateZ({
      radians: radians2,
      origin = ORIGIN
    }) {
      rotateZ2(this, this, origin, radians2);
      return this.check();
    }
    transform(matrix4) {
      return this.transformAsPoint(matrix4);
    }
    transformAsPoint(matrix4) {
      transformMat43(this, this, matrix4);
      return this.check();
    }
    transformAsVector(matrix4) {
      vec3_transformMat4AsVector(this, this, matrix4);
      return this.check();
    }
    transformByMatrix3(matrix3) {
      transformMat32(this, this, matrix3);
      return this.check();
    }
    transformByMatrix2(matrix2) {
      vec3_transformMat2(this, this, matrix2);
      return this.check();
    }
    transformByQuaternion(quaternion) {
      transformQuat2(this, this, quaternion);
      return this.check();
    }
  };

  // ../../node_modules/@math.gl/core/dist/esm/classes/vector4.js
  var ZERO2;
  var Vector4 = class extends Vector {
    static get ZERO() {
      if (!ZERO2) {
        ZERO2 = new Vector4(0, 0, 0, 0);
        Object.freeze(ZERO2);
      }
      return ZERO2;
    }
    constructor(x2 = 0, y2 = 0, z = 0, w = 0) {
      super(-0, -0, -0, -0);
      if (isArray(x2) && arguments.length === 1) {
        this.copy(x2);
      } else {
        if (config.debug) {
          checkNumber(x2);
          checkNumber(y2);
          checkNumber(z);
          checkNumber(w);
        }
        this[0] = x2;
        this[1] = y2;
        this[2] = z;
        this[3] = w;
      }
    }
    set(x2, y2, z, w) {
      this[0] = x2;
      this[1] = y2;
      this[2] = z;
      this[3] = w;
      return this.check();
    }
    copy(array) {
      this[0] = array[0];
      this[1] = array[1];
      this[2] = array[2];
      this[3] = array[3];
      return this.check();
    }
    fromObject(object) {
      if (config.debug) {
        checkNumber(object.x);
        checkNumber(object.y);
        checkNumber(object.z);
        checkNumber(object.w);
      }
      this[0] = object.x;
      this[1] = object.y;
      this[2] = object.z;
      this[3] = object.w;
      return this;
    }
    toObject(object) {
      object.x = this[0];
      object.y = this[1];
      object.z = this[2];
      object.w = this[3];
      return object;
    }
    get ELEMENTS() {
      return 4;
    }
    get z() {
      return this[2];
    }
    set z(value) {
      this[2] = checkNumber(value);
    }
    get w() {
      return this[3];
    }
    set w(value) {
      this[3] = checkNumber(value);
    }
    transform(matrix4) {
      transformMat43(this, this, matrix4);
      return this.check();
    }
    transformByMatrix3(matrix3) {
      vec4_transformMat3(this, this, matrix3);
      return this.check();
    }
    transformByMatrix2(matrix2) {
      vec4_transformMat2(this, this, matrix2);
      return this.check();
    }
    transformByQuaternion(quaternion) {
      transformQuat2(this, this, quaternion);
      return this.check();
    }
    applyMatrix4(m) {
      m.transform(this, this);
      return this;
    }
  };

  // ../../node_modules/@math.gl/core/dist/esm/classes/base/matrix.js
  var Matrix = class extends MathArray {
    toString() {
      let string = "[";
      if (config.printRowMajor) {
        string += "row-major:";
        for (let row = 0; row < this.RANK; ++row) {
          for (let col = 0; col < this.RANK; ++col) {
            string += " ".concat(this[col * this.RANK + row]);
          }
        }
      } else {
        string += "column-major:";
        for (let i3 = 0; i3 < this.ELEMENTS; ++i3) {
          string += " ".concat(this[i3]);
        }
      }
      string += "]";
      return string;
    }
    getElementIndex(row, col) {
      return col * this.RANK + row;
    }
    getElement(row, col) {
      return this[col * this.RANK + row];
    }
    setElement(row, col, value) {
      this[col * this.RANK + row] = checkNumber(value);
      return this;
    }
    getColumn(columnIndex, result = new Array(this.RANK).fill(-0)) {
      const firstIndex = columnIndex * this.RANK;
      for (let i3 = 0; i3 < this.RANK; ++i3) {
        result[i3] = this[firstIndex + i3];
      }
      return result;
    }
    setColumn(columnIndex, columnVector) {
      const firstIndex = columnIndex * this.RANK;
      for (let i3 = 0; i3 < this.RANK; ++i3) {
        this[firstIndex + i3] = columnVector[i3];
      }
      return this;
    }
  };

  // ../../node_modules/gl-matrix/esm/mat3.js
  function create4() {
    var out = new ARRAY_TYPE(9);
    if (ARRAY_TYPE != Float32Array) {
      out[1] = 0;
      out[2] = 0;
      out[3] = 0;
      out[5] = 0;
      out[6] = 0;
      out[7] = 0;
    }
    out[0] = 1;
    out[4] = 1;
    out[8] = 1;
    return out;
  }
  function transpose2(out, a2) {
    if (out === a2) {
      var a01 = a2[1], a02 = a2[2], a12 = a2[5];
      out[1] = a2[3];
      out[2] = a2[6];
      out[3] = a01;
      out[5] = a2[7];
      out[6] = a02;
      out[7] = a12;
    } else {
      out[0] = a2[0];
      out[1] = a2[3];
      out[2] = a2[6];
      out[3] = a2[1];
      out[4] = a2[4];
      out[5] = a2[7];
      out[6] = a2[2];
      out[7] = a2[5];
      out[8] = a2[8];
    }
    return out;
  }
  function invert2(out, a2) {
    var a00 = a2[0], a01 = a2[1], a02 = a2[2];
    var a10 = a2[3], a11 = a2[4], a12 = a2[5];
    var a20 = a2[6], a21 = a2[7], a22 = a2[8];
    var b01 = a22 * a11 - a12 * a21;
    var b11 = -a22 * a10 + a12 * a20;
    var b21 = a21 * a10 - a11 * a20;
    var det = a00 * b01 + a01 * b11 + a02 * b21;
    if (!det) {
      return null;
    }
    det = 1 / det;
    out[0] = b01 * det;
    out[1] = (-a22 * a01 + a02 * a21) * det;
    out[2] = (a12 * a01 - a02 * a11) * det;
    out[3] = b11 * det;
    out[4] = (a22 * a00 - a02 * a20) * det;
    out[5] = (-a12 * a00 + a02 * a10) * det;
    out[6] = b21 * det;
    out[7] = (-a21 * a00 + a01 * a20) * det;
    out[8] = (a11 * a00 - a01 * a10) * det;
    return out;
  }
  function determinant2(a2) {
    var a00 = a2[0], a01 = a2[1], a02 = a2[2];
    var a10 = a2[3], a11 = a2[4], a12 = a2[5];
    var a20 = a2[6], a21 = a2[7], a22 = a2[8];
    return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
  }
  function multiply2(out, a2, b) {
    var a00 = a2[0], a01 = a2[1], a02 = a2[2];
    var a10 = a2[3], a11 = a2[4], a12 = a2[5];
    var a20 = a2[6], a21 = a2[7], a22 = a2[8];
    var b00 = b[0], b01 = b[1], b02 = b[2];
    var b10 = b[3], b11 = b[4], b12 = b[5];
    var b20 = b[6], b21 = b[7], b22 = b[8];
    out[0] = b00 * a00 + b01 * a10 + b02 * a20;
    out[1] = b00 * a01 + b01 * a11 + b02 * a21;
    out[2] = b00 * a02 + b01 * a12 + b02 * a22;
    out[3] = b10 * a00 + b11 * a10 + b12 * a20;
    out[4] = b10 * a01 + b11 * a11 + b12 * a21;
    out[5] = b10 * a02 + b11 * a12 + b12 * a22;
    out[6] = b20 * a00 + b21 * a10 + b22 * a20;
    out[7] = b20 * a01 + b21 * a11 + b22 * a21;
    out[8] = b20 * a02 + b21 * a12 + b22 * a22;
    return out;
  }
  function translate2(out, a2, v) {
    var a00 = a2[0], a01 = a2[1], a02 = a2[2], a10 = a2[3], a11 = a2[4], a12 = a2[5], a20 = a2[6], a21 = a2[7], a22 = a2[8], x2 = v[0], y2 = v[1];
    out[0] = a00;
    out[1] = a01;
    out[2] = a02;
    out[3] = a10;
    out[4] = a11;
    out[5] = a12;
    out[6] = x2 * a00 + y2 * a10 + a20;
    out[7] = x2 * a01 + y2 * a11 + a21;
    out[8] = x2 * a02 + y2 * a12 + a22;
    return out;
  }
  function rotate2(out, a2, rad) {
    var a00 = a2[0], a01 = a2[1], a02 = a2[2], a10 = a2[3], a11 = a2[4], a12 = a2[5], a20 = a2[6], a21 = a2[7], a22 = a2[8], s2 = Math.sin(rad), c = Math.cos(rad);
    out[0] = c * a00 + s2 * a10;
    out[1] = c * a01 + s2 * a11;
    out[2] = c * a02 + s2 * a12;
    out[3] = c * a10 - s2 * a00;
    out[4] = c * a11 - s2 * a01;
    out[5] = c * a12 - s2 * a02;
    out[6] = a20;
    out[7] = a21;
    out[8] = a22;
    return out;
  }
  function scale3(out, a2, v) {
    var x2 = v[0], y2 = v[1];
    out[0] = x2 * a2[0];
    out[1] = x2 * a2[1];
    out[2] = x2 * a2[2];
    out[3] = y2 * a2[3];
    out[4] = y2 * a2[4];
    out[5] = y2 * a2[5];
    out[6] = a2[6];
    out[7] = a2[7];
    out[8] = a2[8];
    return out;
  }
  function fromQuat2(out, q) {
    var x2 = q[0], y2 = q[1], z = q[2], w = q[3];
    var x22 = x2 + x2;
    var y22 = y2 + y2;
    var z2 = z + z;
    var xx = x2 * x22;
    var yx = y2 * x22;
    var yy = y2 * y22;
    var zx = z * x22;
    var zy = z * y22;
    var zz = z * z2;
    var wx = w * x22;
    var wy = w * y22;
    var wz = w * z2;
    out[0] = 1 - yy - zz;
    out[3] = yx - wz;
    out[6] = zx + wy;
    out[1] = yx + wz;
    out[4] = 1 - xx - zz;
    out[7] = zy - wx;
    out[2] = zx - wy;
    out[5] = zy + wx;
    out[8] = 1 - xx - yy;
    return out;
  }

  // ../../node_modules/@math.gl/core/dist/esm/classes/matrix3.js
  var INDICES;
  (function(INDICES3) {
    INDICES3[INDICES3["COL0ROW0"] = 0] = "COL0ROW0";
    INDICES3[INDICES3["COL0ROW1"] = 1] = "COL0ROW1";
    INDICES3[INDICES3["COL0ROW2"] = 2] = "COL0ROW2";
    INDICES3[INDICES3["COL1ROW0"] = 3] = "COL1ROW0";
    INDICES3[INDICES3["COL1ROW1"] = 4] = "COL1ROW1";
    INDICES3[INDICES3["COL1ROW2"] = 5] = "COL1ROW2";
    INDICES3[INDICES3["COL2ROW0"] = 6] = "COL2ROW0";
    INDICES3[INDICES3["COL2ROW1"] = 7] = "COL2ROW1";
    INDICES3[INDICES3["COL2ROW2"] = 8] = "COL2ROW2";
  })(INDICES || (INDICES = {}));
  var IDENTITY_MATRIX = Object.freeze([1, 0, 0, 0, 1, 0, 0, 0, 1]);
  var Matrix3 = class extends Matrix {
    static get IDENTITY() {
      return getIdentityMatrix();
    }
    static get ZERO() {
      return getZeroMatrix();
    }
    get ELEMENTS() {
      return 9;
    }
    get RANK() {
      return 3;
    }
    get INDICES() {
      return INDICES;
    }
    constructor(array, ...args) {
      super(-0, -0, -0, -0, -0, -0, -0, -0, -0);
      if (arguments.length === 1 && Array.isArray(array)) {
        this.copy(array);
      } else if (args.length > 0) {
        this.copy([array, ...args]);
      } else {
        this.identity();
      }
    }
    copy(array) {
      this[0] = array[0];
      this[1] = array[1];
      this[2] = array[2];
      this[3] = array[3];
      this[4] = array[4];
      this[5] = array[5];
      this[6] = array[6];
      this[7] = array[7];
      this[8] = array[8];
      return this.check();
    }
    identity() {
      return this.copy(IDENTITY_MATRIX);
    }
    fromObject(object) {
      return this.check();
    }
    fromQuaternion(q) {
      fromQuat2(this, q);
      return this.check();
    }
    set(m00, m10, m20, m01, m11, m21, m02, m12, m22) {
      this[0] = m00;
      this[1] = m10;
      this[2] = m20;
      this[3] = m01;
      this[4] = m11;
      this[5] = m21;
      this[6] = m02;
      this[7] = m12;
      this[8] = m22;
      return this.check();
    }
    setRowMajor(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
      this[0] = m00;
      this[1] = m10;
      this[2] = m20;
      this[3] = m01;
      this[4] = m11;
      this[5] = m21;
      this[6] = m02;
      this[7] = m12;
      this[8] = m22;
      return this.check();
    }
    determinant() {
      return determinant2(this);
    }
    transpose() {
      transpose2(this, this);
      return this.check();
    }
    invert() {
      invert2(this, this);
      return this.check();
    }
    multiplyLeft(a2) {
      multiply2(this, a2, this);
      return this.check();
    }
    multiplyRight(a2) {
      multiply2(this, this, a2);
      return this.check();
    }
    rotate(radians2) {
      rotate2(this, this, radians2);
      return this.check();
    }
    scale(factor) {
      if (Array.isArray(factor)) {
        scale3(this, this, factor);
      } else {
        scale3(this, this, [factor, factor]);
      }
      return this.check();
    }
    translate(vec) {
      translate2(this, this, vec);
      return this.check();
    }
    transform(vector, result) {
      let out;
      switch (vector.length) {
        case 2:
          out = transformMat3(result || [-0, -0], vector, this);
          break;
        case 3:
          out = transformMat32(result || [-0, -0, -0], vector, this);
          break;
        case 4:
          out = vec4_transformMat3(result || [-0, -0, -0, -0], vector, this);
          break;
        default:
          throw new Error("Illegal vector");
      }
      checkVector(out, vector.length);
      return out;
    }
    transformVector(vector, result) {
      return this.transform(vector, result);
    }
    transformVector2(vector, result) {
      return this.transform(vector, result);
    }
    transformVector3(vector, result) {
      return this.transform(vector, result);
    }
  };
  var ZERO_MATRIX3;
  var IDENTITY_MATRIX3;
  function getZeroMatrix() {
    if (!ZERO_MATRIX3) {
      ZERO_MATRIX3 = new Matrix3([0, 0, 0, 0, 0, 0, 0, 0, 0]);
      Object.freeze(ZERO_MATRIX3);
    }
    return ZERO_MATRIX3;
  }
  function getIdentityMatrix() {
    if (!IDENTITY_MATRIX3) {
      IDENTITY_MATRIX3 = new Matrix3();
      Object.freeze(IDENTITY_MATRIX3);
    }
    return IDENTITY_MATRIX3;
  }

  // ../../node_modules/@math.gl/core/dist/esm/classes/matrix4.js
  var INDICES2;
  (function(INDICES3) {
    INDICES3[INDICES3["COL0ROW0"] = 0] = "COL0ROW0";
    INDICES3[INDICES3["COL0ROW1"] = 1] = "COL0ROW1";
    INDICES3[INDICES3["COL0ROW2"] = 2] = "COL0ROW2";
    INDICES3[INDICES3["COL0ROW3"] = 3] = "COL0ROW3";
    INDICES3[INDICES3["COL1ROW0"] = 4] = "COL1ROW0";
    INDICES3[INDICES3["COL1ROW1"] = 5] = "COL1ROW1";
    INDICES3[INDICES3["COL1ROW2"] = 6] = "COL1ROW2";
    INDICES3[INDICES3["COL1ROW3"] = 7] = "COL1ROW3";
    INDICES3[INDICES3["COL2ROW0"] = 8] = "COL2ROW0";
    INDICES3[INDICES3["COL2ROW1"] = 9] = "COL2ROW1";
    INDICES3[INDICES3["COL2ROW2"] = 10] = "COL2ROW2";
    INDICES3[INDICES3["COL2ROW3"] = 11] = "COL2ROW3";
    INDICES3[INDICES3["COL3ROW0"] = 12] = "COL3ROW0";
    INDICES3[INDICES3["COL3ROW1"] = 13] = "COL3ROW1";
    INDICES3[INDICES3["COL3ROW2"] = 14] = "COL3ROW2";
    INDICES3[INDICES3["COL3ROW3"] = 15] = "COL3ROW3";
  })(INDICES2 || (INDICES2 = {}));
  var DEFAULT_FOVY = 45 * Math.PI / 180;
  var DEFAULT_ASPECT = 1;
  var DEFAULT_NEAR = 0.1;
  var DEFAULT_FAR = 500;
  var IDENTITY_MATRIX2 = Object.freeze([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
  var Matrix4 = class extends Matrix {
    static get IDENTITY() {
      return getIdentityMatrix2();
    }
    static get ZERO() {
      return getZeroMatrix2();
    }
    get ELEMENTS() {
      return 16;
    }
    get RANK() {
      return 4;
    }
    get INDICES() {
      return INDICES2;
    }
    constructor(array) {
      super(-0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0);
      if (arguments.length === 1 && Array.isArray(array)) {
        this.copy(array);
      } else {
        this.identity();
      }
    }
    copy(array) {
      this[0] = array[0];
      this[1] = array[1];
      this[2] = array[2];
      this[3] = array[3];
      this[4] = array[4];
      this[5] = array[5];
      this[6] = array[6];
      this[7] = array[7];
      this[8] = array[8];
      this[9] = array[9];
      this[10] = array[10];
      this[11] = array[11];
      this[12] = array[12];
      this[13] = array[13];
      this[14] = array[14];
      this[15] = array[15];
      return this.check();
    }
    set(m00, m10, m20, m30, m01, m11, m21, m31, m02, m12, m22, m32, m03, m13, m23, m33) {
      this[0] = m00;
      this[1] = m10;
      this[2] = m20;
      this[3] = m30;
      this[4] = m01;
      this[5] = m11;
      this[6] = m21;
      this[7] = m31;
      this[8] = m02;
      this[9] = m12;
      this[10] = m22;
      this[11] = m32;
      this[12] = m03;
      this[13] = m13;
      this[14] = m23;
      this[15] = m33;
      return this.check();
    }
    setRowMajor(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
      this[0] = m00;
      this[1] = m10;
      this[2] = m20;
      this[3] = m30;
      this[4] = m01;
      this[5] = m11;
      this[6] = m21;
      this[7] = m31;
      this[8] = m02;
      this[9] = m12;
      this[10] = m22;
      this[11] = m32;
      this[12] = m03;
      this[13] = m13;
      this[14] = m23;
      this[15] = m33;
      return this.check();
    }
    toRowMajor(result) {
      result[0] = this[0];
      result[1] = this[4];
      result[2] = this[8];
      result[3] = this[12];
      result[4] = this[1];
      result[5] = this[5];
      result[6] = this[9];
      result[7] = this[13];
      result[8] = this[2];
      result[9] = this[6];
      result[10] = this[10];
      result[11] = this[14];
      result[12] = this[3];
      result[13] = this[7];
      result[14] = this[11];
      result[15] = this[15];
      return result;
    }
    identity() {
      return this.copy(IDENTITY_MATRIX2);
    }
    fromObject(object) {
      return this.check();
    }
    fromQuaternion(quaternion) {
      fromQuat(this, quaternion);
      return this.check();
    }
    frustum(view) {
      const {
        left,
        right,
        bottom,
        top,
        near = DEFAULT_NEAR,
        far = DEFAULT_FAR
      } = view;
      if (far === Infinity) {
        computeInfinitePerspectiveOffCenter(this, left, right, bottom, top, near);
      } else {
        frustum(this, left, right, bottom, top, near, far);
      }
      return this.check();
    }
    lookAt(view) {
      const {
        eye,
        center = [0, 0, 0],
        up = [0, 1, 0]
      } = view;
      lookAt(this, eye, center, up);
      return this.check();
    }
    ortho(view) {
      const {
        left,
        right,
        bottom,
        top,
        near = DEFAULT_NEAR,
        far = DEFAULT_FAR
      } = view;
      ortho(this, left, right, bottom, top, near, far);
      return this.check();
    }
    orthographic(view) {
      const {
        fovy = DEFAULT_FOVY,
        aspect = DEFAULT_ASPECT,
        focalDistance = 1,
        near = DEFAULT_NEAR,
        far = DEFAULT_FAR
      } = view;
      checkRadians(fovy);
      const halfY = fovy / 2;
      const top = focalDistance * Math.tan(halfY);
      const right = top * aspect;
      return this.ortho({
        left: -right,
        right,
        bottom: -top,
        top,
        near,
        far
      });
    }
    perspective(view) {
      const {
        fovy = 45 * Math.PI / 180,
        aspect = 1,
        near = 0.1,
        far = 500
      } = view;
      checkRadians(fovy);
      perspective(this, fovy, aspect, near, far);
      return this.check();
    }
    determinant() {
      return determinant(this);
    }
    getScale(result = [-0, -0, -0]) {
      result[0] = Math.sqrt(this[0] * this[0] + this[1] * this[1] + this[2] * this[2]);
      result[1] = Math.sqrt(this[4] * this[4] + this[5] * this[5] + this[6] * this[6]);
      result[2] = Math.sqrt(this[8] * this[8] + this[9] * this[9] + this[10] * this[10]);
      return result;
    }
    getTranslation(result = [-0, -0, -0]) {
      result[0] = this[12];
      result[1] = this[13];
      result[2] = this[14];
      return result;
    }
    getRotation(result, scaleResult) {
      result = result || [-0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0];
      scaleResult = scaleResult || [-0, -0, -0];
      const scale5 = this.getScale(scaleResult);
      const inverseScale0 = 1 / scale5[0];
      const inverseScale1 = 1 / scale5[1];
      const inverseScale2 = 1 / scale5[2];
      result[0] = this[0] * inverseScale0;
      result[1] = this[1] * inverseScale1;
      result[2] = this[2] * inverseScale2;
      result[3] = 0;
      result[4] = this[4] * inverseScale0;
      result[5] = this[5] * inverseScale1;
      result[6] = this[6] * inverseScale2;
      result[7] = 0;
      result[8] = this[8] * inverseScale0;
      result[9] = this[9] * inverseScale1;
      result[10] = this[10] * inverseScale2;
      result[11] = 0;
      result[12] = 0;
      result[13] = 0;
      result[14] = 0;
      result[15] = 1;
      return result;
    }
    getRotationMatrix3(result, scaleResult) {
      result = result || [-0, -0, -0, -0, -0, -0, -0, -0, -0];
      scaleResult = scaleResult || [-0, -0, -0];
      const scale5 = this.getScale(scaleResult);
      const inverseScale0 = 1 / scale5[0];
      const inverseScale1 = 1 / scale5[1];
      const inverseScale2 = 1 / scale5[2];
      result[0] = this[0] * inverseScale0;
      result[1] = this[1] * inverseScale1;
      result[2] = this[2] * inverseScale2;
      result[3] = this[4] * inverseScale0;
      result[4] = this[5] * inverseScale1;
      result[5] = this[6] * inverseScale2;
      result[6] = this[8] * inverseScale0;
      result[7] = this[9] * inverseScale1;
      result[8] = this[10] * inverseScale2;
      return result;
    }
    transpose() {
      transpose(this, this);
      return this.check();
    }
    invert() {
      invert(this, this);
      return this.check();
    }
    multiplyLeft(a2) {
      multiply(this, a2, this);
      return this.check();
    }
    multiplyRight(a2) {
      multiply(this, this, a2);
      return this.check();
    }
    rotateX(radians2) {
      rotateX(this, this, radians2);
      return this.check();
    }
    rotateY(radians2) {
      rotateY(this, this, radians2);
      return this.check();
    }
    rotateZ(radians2) {
      rotateZ(this, this, radians2);
      return this.check();
    }
    rotateXYZ(angleXYZ) {
      return this.rotateX(angleXYZ[0]).rotateY(angleXYZ[1]).rotateZ(angleXYZ[2]);
    }
    rotateAxis(radians2, axis) {
      rotate(this, this, radians2, axis);
      return this.check();
    }
    scale(factor) {
      scale2(this, this, Array.isArray(factor) ? factor : [factor, factor, factor]);
      return this.check();
    }
    translate(vector) {
      translate(this, this, vector);
      return this.check();
    }
    transform(vector, result) {
      if (vector.length === 4) {
        result = transformMat4(result || [-0, -0, -0, -0], vector, this);
        checkVector(result, 4);
        return result;
      }
      return this.transformAsPoint(vector, result);
    }
    transformAsPoint(vector, result) {
      const {
        length: length5
      } = vector;
      let out;
      switch (length5) {
        case 2:
          out = transformMat42(result || [-0, -0], vector, this);
          break;
        case 3:
          out = transformMat43(result || [-0, -0, -0], vector, this);
          break;
        default:
          throw new Error("Illegal vector");
      }
      checkVector(out, vector.length);
      return out;
    }
    transformAsVector(vector, result) {
      let out;
      switch (vector.length) {
        case 2:
          out = vec2_transformMat4AsVector(result || [-0, -0], vector, this);
          break;
        case 3:
          out = vec3_transformMat4AsVector(result || [-0, -0, -0], vector, this);
          break;
        default:
          throw new Error("Illegal vector");
      }
      checkVector(out, vector.length);
      return out;
    }
    transformPoint(vector, result) {
      return this.transformAsPoint(vector, result);
    }
    transformVector(vector, result) {
      return this.transformAsPoint(vector, result);
    }
    transformDirection(vector, result) {
      return this.transformAsVector(vector, result);
    }
    makeRotationX(radians2) {
      return this.identity().rotateX(radians2);
    }
    makeTranslation(x2, y2, z) {
      return this.identity().translate([x2, y2, z]);
    }
  };
  var ZERO3;
  var IDENTITY;
  function getZeroMatrix2() {
    if (!ZERO3) {
      ZERO3 = new Matrix4([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
      Object.freeze(ZERO3);
    }
    return ZERO3;
  }
  function getIdentityMatrix2() {
    if (!IDENTITY) {
      IDENTITY = new Matrix4();
      Object.freeze(IDENTITY);
    }
    return IDENTITY;
  }
  function checkRadians(possiblyDegrees) {
    if (possiblyDegrees > Math.PI * 2) {
      throw Error("expected radians");
    }
  }
  function computeInfinitePerspectiveOffCenter(result, left, right, bottom, top, near) {
    const column0Row0 = 2 * near / (right - left);
    const column1Row1 = 2 * near / (top - bottom);
    const column2Row0 = (right + left) / (right - left);
    const column2Row1 = (top + bottom) / (top - bottom);
    const column2Row2 = -1;
    const column2Row3 = -1;
    const column3Row2 = -2 * near;
    result[0] = column0Row0;
    result[1] = 0;
    result[2] = 0;
    result[3] = 0;
    result[4] = 0;
    result[5] = column1Row1;
    result[6] = 0;
    result[7] = 0;
    result[8] = column2Row0;
    result[9] = column2Row1;
    result[10] = column2Row2;
    result[11] = column2Row3;
    result[12] = 0;
    result[13] = 0;
    result[14] = column3Row2;
    result[15] = 0;
    return result;
  }

  // ../../node_modules/gl-matrix/esm/quat.js
  function create5() {
    var out = new ARRAY_TYPE(4);
    if (ARRAY_TYPE != Float32Array) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
    }
    out[3] = 1;
    return out;
  }
  function identity2(out) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
  }
  function setAxisAngle(out, axis, rad) {
    rad = rad * 0.5;
    var s2 = Math.sin(rad);
    out[0] = s2 * axis[0];
    out[1] = s2 * axis[1];
    out[2] = s2 * axis[2];
    out[3] = Math.cos(rad);
    return out;
  }
  function multiply3(out, a2, b) {
    var ax = a2[0], ay = a2[1], az = a2[2], aw = a2[3];
    var bx = b[0], by = b[1], bz = b[2], bw = b[3];
    out[0] = ax * bw + aw * bx + ay * bz - az * by;
    out[1] = ay * bw + aw * by + az * bx - ax * bz;
    out[2] = az * bw + aw * bz + ax * by - ay * bx;
    out[3] = aw * bw - ax * bx - ay * by - az * bz;
    return out;
  }
  function rotateX3(out, a2, rad) {
    rad *= 0.5;
    var ax = a2[0], ay = a2[1], az = a2[2], aw = a2[3];
    var bx = Math.sin(rad), bw = Math.cos(rad);
    out[0] = ax * bw + aw * bx;
    out[1] = ay * bw + az * bx;
    out[2] = az * bw - ay * bx;
    out[3] = aw * bw - ax * bx;
    return out;
  }
  function rotateY3(out, a2, rad) {
    rad *= 0.5;
    var ax = a2[0], ay = a2[1], az = a2[2], aw = a2[3];
    var by = Math.sin(rad), bw = Math.cos(rad);
    out[0] = ax * bw - az * by;
    out[1] = ay * bw + aw * by;
    out[2] = az * bw + ax * by;
    out[3] = aw * bw - ay * by;
    return out;
  }
  function rotateZ3(out, a2, rad) {
    rad *= 0.5;
    var ax = a2[0], ay = a2[1], az = a2[2], aw = a2[3];
    var bz = Math.sin(rad), bw = Math.cos(rad);
    out[0] = ax * bw + ay * bz;
    out[1] = ay * bw - ax * bz;
    out[2] = az * bw + aw * bz;
    out[3] = aw * bw - az * bz;
    return out;
  }
  function calculateW(out, a2) {
    var x2 = a2[0], y2 = a2[1], z = a2[2];
    out[0] = x2;
    out[1] = y2;
    out[2] = z;
    out[3] = Math.sqrt(Math.abs(1 - x2 * x2 - y2 * y2 - z * z));
    return out;
  }
  function slerp(out, a2, b, t2) {
    var ax = a2[0], ay = a2[1], az = a2[2], aw = a2[3];
    var bx = b[0], by = b[1], bz = b[2], bw = b[3];
    var omega, cosom, sinom, scale0, scale1;
    cosom = ax * bx + ay * by + az * bz + aw * bw;
    if (cosom < 0) {
      cosom = -cosom;
      bx = -bx;
      by = -by;
      bz = -bz;
      bw = -bw;
    }
    if (1 - cosom > EPSILON) {
      omega = Math.acos(cosom);
      sinom = Math.sin(omega);
      scale0 = Math.sin((1 - t2) * omega) / sinom;
      scale1 = Math.sin(t2 * omega) / sinom;
    } else {
      scale0 = 1 - t2;
      scale1 = t2;
    }
    out[0] = scale0 * ax + scale1 * bx;
    out[1] = scale0 * ay + scale1 * by;
    out[2] = scale0 * az + scale1 * bz;
    out[3] = scale0 * aw + scale1 * bw;
    return out;
  }
  function invert3(out, a2) {
    var a0 = a2[0], a1 = a2[1], a22 = a2[2], a3 = a2[3];
    var dot4 = a0 * a0 + a1 * a1 + a22 * a22 + a3 * a3;
    var invDot = dot4 ? 1 / dot4 : 0;
    out[0] = -a0 * invDot;
    out[1] = -a1 * invDot;
    out[2] = -a22 * invDot;
    out[3] = a3 * invDot;
    return out;
  }
  function conjugate(out, a2) {
    out[0] = -a2[0];
    out[1] = -a2[1];
    out[2] = -a2[2];
    out[3] = a2[3];
    return out;
  }
  function fromMat3(out, m) {
    var fTrace = m[0] + m[4] + m[8];
    var fRoot;
    if (fTrace > 0) {
      fRoot = Math.sqrt(fTrace + 1);
      out[3] = 0.5 * fRoot;
      fRoot = 0.5 / fRoot;
      out[0] = (m[5] - m[7]) * fRoot;
      out[1] = (m[6] - m[2]) * fRoot;
      out[2] = (m[1] - m[3]) * fRoot;
    } else {
      var i3 = 0;
      if (m[4] > m[0])
        i3 = 1;
      if (m[8] > m[i3 * 3 + i3])
        i3 = 2;
      var j = (i3 + 1) % 3;
      var k = (i3 + 2) % 3;
      fRoot = Math.sqrt(m[i3 * 3 + i3] - m[j * 3 + j] - m[k * 3 + k] + 1);
      out[i3] = 0.5 * fRoot;
      fRoot = 0.5 / fRoot;
      out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;
      out[j] = (m[j * 3 + i3] + m[i3 * 3 + j]) * fRoot;
      out[k] = (m[k * 3 + i3] + m[i3 * 3 + k]) * fRoot;
    }
    return out;
  }
  var add2 = add;
  var scale4 = scale;
  var dot3 = dot;
  var lerp4 = lerp;
  var length3 = length;
  var squaredLength2 = squaredLength;
  var normalize3 = normalize;
  var rotationTo = function() {
    var tmpvec3 = create3();
    var xUnitVec3 = fromValues(1, 0, 0);
    var yUnitVec3 = fromValues(0, 1, 0);
    return function(out, a2, b) {
      var dot4 = dot2(a2, b);
      if (dot4 < -0.999999) {
        cross(tmpvec3, xUnitVec3, a2);
        if (len(tmpvec3) < 1e-6)
          cross(tmpvec3, yUnitVec3, a2);
        normalize2(tmpvec3, tmpvec3);
        setAxisAngle(out, tmpvec3, Math.PI);
        return out;
      } else if (dot4 > 0.999999) {
        out[0] = 0;
        out[1] = 0;
        out[2] = 0;
        out[3] = 1;
        return out;
      } else {
        cross(tmpvec3, a2, b);
        out[0] = tmpvec3[0];
        out[1] = tmpvec3[1];
        out[2] = tmpvec3[2];
        out[3] = 1 + dot4;
        return normalize3(out, out);
      }
    };
  }();
  var sqlerp = function() {
    var temp1 = create5();
    var temp2 = create5();
    return function(out, a2, b, c, d, t2) {
      slerp(temp1, a2, d, t2);
      slerp(temp2, b, c, t2);
      slerp(out, temp1, temp2, 2 * t2 * (1 - t2));
      return out;
    };
  }();
  var setAxes = function() {
    var matr = create4();
    return function(out, view, right, up) {
      matr[0] = right[0];
      matr[3] = right[1];
      matr[6] = right[2];
      matr[1] = up[0];
      matr[4] = up[1];
      matr[7] = up[2];
      matr[2] = -view[0];
      matr[5] = -view[1];
      matr[8] = -view[2];
      return normalize3(out, fromMat3(out, matr));
    };
  }();

  // ../../node_modules/@math.gl/core/dist/esm/classes/quaternion.js
  var IDENTITY_QUATERNION = [0, 0, 0, 1];
  var Quaternion = class extends MathArray {
    constructor(x2 = 0, y2 = 0, z = 0, w = 1) {
      super(-0, -0, -0, -0);
      if (Array.isArray(x2) && arguments.length === 1) {
        this.copy(x2);
      } else {
        this.set(x2, y2, z, w);
      }
    }
    copy(array) {
      this[0] = array[0];
      this[1] = array[1];
      this[2] = array[2];
      this[3] = array[3];
      return this.check();
    }
    set(x2, y2, z, w) {
      this[0] = x2;
      this[1] = y2;
      this[2] = z;
      this[3] = w;
      return this.check();
    }
    fromObject(object) {
      this[0] = object.x;
      this[1] = object.y;
      this[2] = object.z;
      this[3] = object.w;
      return this.check();
    }
    fromMatrix3(m) {
      fromMat3(this, m);
      return this.check();
    }
    fromAxisRotation(axis, rad) {
      setAxisAngle(this, axis, rad);
      return this.check();
    }
    identity() {
      identity2(this);
      return this.check();
    }
    setAxisAngle(axis, rad) {
      return this.fromAxisRotation(axis, rad);
    }
    get ELEMENTS() {
      return 4;
    }
    get x() {
      return this[0];
    }
    set x(value) {
      this[0] = checkNumber(value);
    }
    get y() {
      return this[1];
    }
    set y(value) {
      this[1] = checkNumber(value);
    }
    get z() {
      return this[2];
    }
    set z(value) {
      this[2] = checkNumber(value);
    }
    get w() {
      return this[3];
    }
    set w(value) {
      this[3] = checkNumber(value);
    }
    len() {
      return length3(this);
    }
    lengthSquared() {
      return squaredLength2(this);
    }
    dot(a2) {
      return dot3(this, a2);
    }
    rotationTo(vectorA, vectorB) {
      rotationTo(this, vectorA, vectorB);
      return this.check();
    }
    add(a2) {
      add2(this, this, a2);
      return this.check();
    }
    calculateW() {
      calculateW(this, this);
      return this.check();
    }
    conjugate() {
      conjugate(this, this);
      return this.check();
    }
    invert() {
      invert3(this, this);
      return this.check();
    }
    lerp(a2, b, t2) {
      if (t2 === void 0) {
        return this.lerp(this, a2, b);
      }
      lerp4(this, a2, b, t2);
      return this.check();
    }
    multiplyRight(a2) {
      multiply3(this, this, a2);
      return this.check();
    }
    multiplyLeft(a2) {
      multiply3(this, a2, this);
      return this.check();
    }
    normalize() {
      const length5 = this.len();
      const l2 = length5 > 0 ? 1 / length5 : 0;
      this[0] = this[0] * l2;
      this[1] = this[1] * l2;
      this[2] = this[2] * l2;
      this[3] = this[3] * l2;
      if (length5 === 0) {
        this[3] = 1;
      }
      return this.check();
    }
    rotateX(rad) {
      rotateX3(this, this, rad);
      return this.check();
    }
    rotateY(rad) {
      rotateY3(this, this, rad);
      return this.check();
    }
    rotateZ(rad) {
      rotateZ3(this, this, rad);
      return this.check();
    }
    scale(b) {
      scale4(this, this, b);
      return this.check();
    }
    slerp(arg0, arg1, arg2) {
      let start;
      let target;
      let ratio;
      switch (arguments.length) {
        case 1:
          ({
            start = IDENTITY_QUATERNION,
            target,
            ratio
          } = arg0);
          break;
        case 2:
          start = this;
          target = arg0;
          ratio = arg1;
          break;
        default:
          start = arg0;
          target = arg1;
          ratio = arg2;
      }
      slerp(this, start, target, ratio);
      return this.check();
    }
    transformVector4(vector, result = new Vector4()) {
      transformQuat(result, vector, this);
      return checkVector(result, 4);
    }
    lengthSq() {
      return this.lengthSquared();
    }
    setFromAxisAngle(axis, rad) {
      return this.setAxisAngle(axis, rad);
    }
    premultiply(a2) {
      return this.multiplyLeft(a2);
    }
    multiply(a2) {
      return this.multiplyRight(a2);
    }
  };

  // ../../node_modules/@math.gl/core/dist/esm/lib/math-utils.js
  var math_utils_default = {
    EPSILON1: 0.1,
    EPSILON2: 0.01,
    EPSILON3: 1e-3,
    EPSILON4: 1e-4,
    EPSILON5: 1e-5,
    EPSILON6: 1e-6,
    EPSILON7: 1e-7,
    EPSILON8: 1e-8,
    EPSILON9: 1e-9,
    EPSILON10: 1e-10,
    EPSILON11: 1e-11,
    EPSILON12: 1e-12,
    EPSILON13: 1e-13,
    EPSILON14: 1e-14,
    EPSILON15: 1e-15,
    EPSILON16: 1e-16,
    EPSILON17: 1e-17,
    EPSILON18: 1e-18,
    EPSILON19: 1e-19,
    EPSILON20: 1e-20,
    PI_OVER_TWO: Math.PI / 2,
    PI_OVER_FOUR: Math.PI / 4,
    PI_OVER_SIX: Math.PI / 6,
    TWO_PI: Math.PI * 2
  };

  // src/tileset-2d/tile-2d-header.ts
  var Tile2DHeader = class {
    constructor(index) {
      this.index = index;
      this.isVisible = false;
      this.isSelected = false;
      this.parent = null;
      this.children = [];
      this.content = null;
      this._loader = void 0;
      this._abortController = null;
      this._loaderId = 0;
      this._isLoaded = false;
      this._isCancelled = false;
      this._needsReload = false;
    }
    get data() {
      return this.isLoading && this._loader ? this._loader.then(() => this.data) : this.content;
    }
    get isLoaded() {
      return this._isLoaded && !this._needsReload;
    }
    get isLoading() {
      return Boolean(this._loader) && !this._isCancelled;
    }
    get needsReload() {
      return this._needsReload || this._isCancelled;
    }
    get byteLength() {
      const result = this.content ? this.content.byteLength : 0;
      if (!Number.isFinite(result)) {
        console.error("byteLength not defined in tile data");
      }
      return result;
    }
    async _loadData({
      getData,
      requestScheduler,
      onLoad,
      onError
    }) {
      const {
        index,
        id,
        bbox,
        userData,
        zoom
      } = this;
      const loaderId = this._loaderId;
      this._abortController = new AbortController();
      const {
        signal
      } = this._abortController;
      const requestToken = await requestScheduler.scheduleRequest(this, (tile) => {
        return tile.isSelected ? 1 : -1;
      });
      if (!requestToken) {
        this._isCancelled = true;
        return;
      }
      if (this._isCancelled) {
        requestToken.done();
        return;
      }
      let tileData = null;
      let error2;
      try {
        tileData = await getData({
          index,
          id,
          bbox,
          userData,
          zoom,
          signal
        });
      } catch (err) {
        error2 = err || true;
      } finally {
        requestToken.done();
      }
      if (loaderId !== this._loaderId) {
        return;
      }
      this._loader = void 0;
      this.content = tileData;
      if (this._isCancelled && !tileData) {
        this._isLoaded = false;
        return;
      }
      this._isLoaded = true;
      this._isCancelled = false;
      if (error2) {
        onError(error2, this);
      } else {
        onLoad(this);
      }
    }
    loadData(opts) {
      this._isLoaded = false;
      this._isCancelled = false;
      this._needsReload = false;
      this._loaderId++;
      this._loader = this._loadData(opts);
      return this._loader;
    }
    setNeedsReload() {
      if (this.isLoading) {
        this.abort();
        this._loader = void 0;
      }
      this._needsReload = true;
    }
    abort() {
      if (this.isLoaded) {
        return;
      }
      this._isCancelled = true;
      this._abortController?.abort();
    }
  };

  // src/tileset-2d/tile-2d-traversal.ts
  var import_core12 = __toESM(require_core());

  // ../../node_modules/@math.gl/culling/dist/esm/constants.js
  var INTERSECTION = {
    OUTSIDE: -1,
    INTERSECTING: 0,
    INSIDE: 1
  };

  // ../../node_modules/@math.gl/culling/node_modules/@babel/runtime/helpers/esm/defineProperty.js
  function _defineProperty3(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }

  // ../../node_modules/@math.gl/culling/dist/esm/lib/bounding-volumes/axis-aligned-bounding-box.js
  var scratchVector = new Vector3();
  var scratchNormal = new Vector3();
  var AxisAlignedBoundingBox = class {
    constructor(minimum = [0, 0, 0], maximum = [0, 0, 0], center) {
      _defineProperty3(this, "center", void 0);
      _defineProperty3(this, "halfDiagonal", void 0);
      _defineProperty3(this, "minimum", void 0);
      _defineProperty3(this, "maximum", void 0);
      center = center || scratchVector.copy(minimum).add(maximum).scale(0.5);
      this.center = new Vector3(center);
      this.halfDiagonal = new Vector3(maximum).subtract(this.center);
      this.minimum = new Vector3(minimum);
      this.maximum = new Vector3(maximum);
    }
    clone() {
      return new AxisAlignedBoundingBox(this.minimum, this.maximum, this.center);
    }
    equals(right) {
      return this === right || Boolean(right) && this.minimum.equals(right.minimum) && this.maximum.equals(right.maximum);
    }
    transform(transform2) {
      this.center.transformAsPoint(transform2);
      this.halfDiagonal.transform(transform2);
      this.minimum.transform(transform2);
      this.maximum.transform(transform2);
      return this;
    }
    intersectPlane(plane) {
      const {
        halfDiagonal
      } = this;
      const normal = scratchNormal.from(plane.normal);
      const e = halfDiagonal.x * Math.abs(normal.x) + halfDiagonal.y * Math.abs(normal.y) + halfDiagonal.z * Math.abs(normal.z);
      const s2 = this.center.dot(normal) + plane.distance;
      if (s2 - e > 0) {
        return INTERSECTION.INSIDE;
      }
      if (s2 + e < 0) {
        return INTERSECTION.OUTSIDE;
      }
      return INTERSECTION.INTERSECTING;
    }
    distanceTo(point) {
      return Math.sqrt(this.distanceSquaredTo(point));
    }
    distanceSquaredTo(point) {
      const offset = scratchVector.from(point).subtract(this.center);
      const {
        halfDiagonal
      } = this;
      let distanceSquared = 0;
      let d;
      d = Math.abs(offset.x) - halfDiagonal.x;
      if (d > 0) {
        distanceSquared += d * d;
      }
      d = Math.abs(offset.y) - halfDiagonal.y;
      if (d > 0) {
        distanceSquared += d * d;
      }
      d = Math.abs(offset.z) - halfDiagonal.z;
      if (d > 0) {
        distanceSquared += d * d;
      }
      return distanceSquared;
    }
  };

  // ../../node_modules/@math.gl/culling/dist/esm/lib/bounding-volumes/bounding-sphere.js
  var scratchVector2 = new Vector3();
  var scratchVector22 = new Vector3();
  var BoundingSphere = class {
    constructor(center = [0, 0, 0], radius = 0) {
      _defineProperty3(this, "center", void 0);
      _defineProperty3(this, "radius", void 0);
      this.radius = -0;
      this.center = new Vector3();
      this.fromCenterRadius(center, radius);
    }
    fromCenterRadius(center, radius) {
      this.center.from(center);
      this.radius = radius;
      return this;
    }
    fromCornerPoints(corner, oppositeCorner) {
      oppositeCorner = scratchVector2.from(oppositeCorner);
      this.center = new Vector3().from(corner).add(oppositeCorner).scale(0.5);
      this.radius = this.center.distance(oppositeCorner);
      return this;
    }
    equals(right) {
      return this === right || Boolean(right) && this.center.equals(right.center) && this.radius === right.radius;
    }
    clone() {
      return new BoundingSphere(this.center, this.radius);
    }
    union(boundingSphere) {
      const leftCenter = this.center;
      const leftRadius = this.radius;
      const rightCenter = boundingSphere.center;
      const rightRadius = boundingSphere.radius;
      const toRightCenter = scratchVector2.copy(rightCenter).subtract(leftCenter);
      const centerSeparation = toRightCenter.magnitude();
      if (leftRadius >= centerSeparation + rightRadius) {
        return this.clone();
      }
      if (rightRadius >= centerSeparation + leftRadius) {
        return boundingSphere.clone();
      }
      const halfDistanceBetweenTangentPoints = (leftRadius + centerSeparation + rightRadius) * 0.5;
      scratchVector22.copy(toRightCenter).scale((-leftRadius + halfDistanceBetweenTangentPoints) / centerSeparation).add(leftCenter);
      this.center.copy(scratchVector22);
      this.radius = halfDistanceBetweenTangentPoints;
      return this;
    }
    expand(point) {
      const scratchPoint = scratchVector2.from(point);
      const radius = scratchPoint.subtract(this.center).magnitude();
      if (radius > this.radius) {
        this.radius = radius;
      }
      return this;
    }
    transform(transform2) {
      this.center.transform(transform2);
      const scale5 = getScaling(scratchVector2, transform2);
      this.radius = Math.max(scale5[0], Math.max(scale5[1], scale5[2])) * this.radius;
      return this;
    }
    distanceSquaredTo(point) {
      const d = this.distanceTo(point);
      return d * d;
    }
    distanceTo(point) {
      const scratchPoint = scratchVector2.from(point);
      const delta = scratchPoint.subtract(this.center);
      return Math.max(0, delta.len() - this.radius);
    }
    intersectPlane(plane) {
      const center = this.center;
      const radius = this.radius;
      const normal = plane.normal;
      const distanceToPlane = normal.dot(center) + plane.distance;
      if (distanceToPlane < -radius) {
        return INTERSECTION.OUTSIDE;
      }
      if (distanceToPlane < radius) {
        return INTERSECTION.INTERSECTING;
      }
      return INTERSECTION.INSIDE;
    }
  };

  // ../../node_modules/@math.gl/culling/dist/esm/lib/bounding-volumes/oriented-bounding-box.js
  var scratchVector3 = new Vector3();
  var scratchOffset = new Vector3();
  var scratchVectorU = new Vector3();
  var scratchVectorV = new Vector3();
  var scratchVectorW = new Vector3();
  var scratchCorner = new Vector3();
  var scratchToCenter = new Vector3();
  var MATRIX3 = {
    COLUMN0ROW0: 0,
    COLUMN0ROW1: 1,
    COLUMN0ROW2: 2,
    COLUMN1ROW0: 3,
    COLUMN1ROW1: 4,
    COLUMN1ROW2: 5,
    COLUMN2ROW0: 6,
    COLUMN2ROW1: 7,
    COLUMN2ROW2: 8
  };
  var OrientedBoundingBox = class {
    constructor(center = [0, 0, 0], halfAxes = [0, 0, 0, 0, 0, 0, 0, 0, 0]) {
      _defineProperty3(this, "center", void 0);
      _defineProperty3(this, "halfAxes", void 0);
      this.center = new Vector3().from(center);
      this.halfAxes = new Matrix3(halfAxes);
    }
    get halfSize() {
      const xAxis = this.halfAxes.getColumn(0);
      const yAxis = this.halfAxes.getColumn(1);
      const zAxis = this.halfAxes.getColumn(2);
      return [new Vector3(xAxis).len(), new Vector3(yAxis).len(), new Vector3(zAxis).len()];
    }
    get quaternion() {
      const xAxis = this.halfAxes.getColumn(0);
      const yAxis = this.halfAxes.getColumn(1);
      const zAxis = this.halfAxes.getColumn(2);
      const normXAxis = new Vector3(xAxis).normalize();
      const normYAxis = new Vector3(yAxis).normalize();
      const normZAxis = new Vector3(zAxis).normalize();
      return new Quaternion().fromMatrix3(new Matrix3([...normXAxis, ...normYAxis, ...normZAxis]));
    }
    fromCenterHalfSizeQuaternion(center, halfSize, quaternion) {
      const quaternionObject = new Quaternion(quaternion);
      const directionsMatrix = new Matrix3().fromQuaternion(quaternionObject);
      directionsMatrix[0] = directionsMatrix[0] * halfSize[0];
      directionsMatrix[1] = directionsMatrix[1] * halfSize[0];
      directionsMatrix[2] = directionsMatrix[2] * halfSize[0];
      directionsMatrix[3] = directionsMatrix[3] * halfSize[1];
      directionsMatrix[4] = directionsMatrix[4] * halfSize[1];
      directionsMatrix[5] = directionsMatrix[5] * halfSize[1];
      directionsMatrix[6] = directionsMatrix[6] * halfSize[2];
      directionsMatrix[7] = directionsMatrix[7] * halfSize[2];
      directionsMatrix[8] = directionsMatrix[8] * halfSize[2];
      this.center = new Vector3().from(center);
      this.halfAxes = directionsMatrix;
      return this;
    }
    clone() {
      return new OrientedBoundingBox(this.center, this.halfAxes);
    }
    equals(right) {
      return this === right || Boolean(right) && this.center.equals(right.center) && this.halfAxes.equals(right.halfAxes);
    }
    getBoundingSphere(result = new BoundingSphere()) {
      const halfAxes = this.halfAxes;
      const u = halfAxes.getColumn(0, scratchVectorU);
      const v = halfAxes.getColumn(1, scratchVectorV);
      const w = halfAxes.getColumn(2, scratchVectorW);
      const cornerVector = scratchVector3.copy(u).add(v).add(w);
      result.center.copy(this.center);
      result.radius = cornerVector.magnitude();
      return result;
    }
    intersectPlane(plane) {
      const center = this.center;
      const normal = plane.normal;
      const halfAxes = this.halfAxes;
      const normalX = normal.x;
      const normalY = normal.y;
      const normalZ = normal.z;
      const radEffective = Math.abs(normalX * halfAxes[MATRIX3.COLUMN0ROW0] + normalY * halfAxes[MATRIX3.COLUMN0ROW1] + normalZ * halfAxes[MATRIX3.COLUMN0ROW2]) + Math.abs(normalX * halfAxes[MATRIX3.COLUMN1ROW0] + normalY * halfAxes[MATRIX3.COLUMN1ROW1] + normalZ * halfAxes[MATRIX3.COLUMN1ROW2]) + Math.abs(normalX * halfAxes[MATRIX3.COLUMN2ROW0] + normalY * halfAxes[MATRIX3.COLUMN2ROW1] + normalZ * halfAxes[MATRIX3.COLUMN2ROW2]);
      const distanceToPlane = normal.dot(center) + plane.distance;
      if (distanceToPlane <= -radEffective) {
        return INTERSECTION.OUTSIDE;
      } else if (distanceToPlane >= radEffective) {
        return INTERSECTION.INSIDE;
      }
      return INTERSECTION.INTERSECTING;
    }
    distanceTo(point) {
      return Math.sqrt(this.distanceSquaredTo(point));
    }
    distanceSquaredTo(point) {
      const offset = scratchOffset.from(point).subtract(this.center);
      const halfAxes = this.halfAxes;
      const u = halfAxes.getColumn(0, scratchVectorU);
      const v = halfAxes.getColumn(1, scratchVectorV);
      const w = halfAxes.getColumn(2, scratchVectorW);
      const uHalf = u.magnitude();
      const vHalf = v.magnitude();
      const wHalf = w.magnitude();
      u.normalize();
      v.normalize();
      w.normalize();
      let distanceSquared = 0;
      let d;
      d = Math.abs(offset.dot(u)) - uHalf;
      if (d > 0) {
        distanceSquared += d * d;
      }
      d = Math.abs(offset.dot(v)) - vHalf;
      if (d > 0) {
        distanceSquared += d * d;
      }
      d = Math.abs(offset.dot(w)) - wHalf;
      if (d > 0) {
        distanceSquared += d * d;
      }
      return distanceSquared;
    }
    computePlaneDistances(position, direction, result = [-0, -0]) {
      let minDist = Number.POSITIVE_INFINITY;
      let maxDist = Number.NEGATIVE_INFINITY;
      const center = this.center;
      const halfAxes = this.halfAxes;
      const u = halfAxes.getColumn(0, scratchVectorU);
      const v = halfAxes.getColumn(1, scratchVectorV);
      const w = halfAxes.getColumn(2, scratchVectorW);
      const corner = scratchCorner.copy(u).add(v).add(w).add(center);
      const toCenter = scratchToCenter.copy(corner).subtract(position);
      let mag = direction.dot(toCenter);
      minDist = Math.min(mag, minDist);
      maxDist = Math.max(mag, maxDist);
      corner.copy(center).add(u).add(v).subtract(w);
      toCenter.copy(corner).subtract(position);
      mag = direction.dot(toCenter);
      minDist = Math.min(mag, minDist);
      maxDist = Math.max(mag, maxDist);
      corner.copy(center).add(u).subtract(v).add(w);
      toCenter.copy(corner).subtract(position);
      mag = direction.dot(toCenter);
      minDist = Math.min(mag, minDist);
      maxDist = Math.max(mag, maxDist);
      corner.copy(center).add(u).subtract(v).subtract(w);
      toCenter.copy(corner).subtract(position);
      mag = direction.dot(toCenter);
      minDist = Math.min(mag, minDist);
      maxDist = Math.max(mag, maxDist);
      center.copy(corner).subtract(u).add(v).add(w);
      toCenter.copy(corner).subtract(position);
      mag = direction.dot(toCenter);
      minDist = Math.min(mag, minDist);
      maxDist = Math.max(mag, maxDist);
      center.copy(corner).subtract(u).add(v).subtract(w);
      toCenter.copy(corner).subtract(position);
      mag = direction.dot(toCenter);
      minDist = Math.min(mag, minDist);
      maxDist = Math.max(mag, maxDist);
      center.copy(corner).subtract(u).subtract(v).add(w);
      toCenter.copy(corner).subtract(position);
      mag = direction.dot(toCenter);
      minDist = Math.min(mag, minDist);
      maxDist = Math.max(mag, maxDist);
      center.copy(corner).subtract(u).subtract(v).subtract(w);
      toCenter.copy(corner).subtract(position);
      mag = direction.dot(toCenter);
      minDist = Math.min(mag, minDist);
      maxDist = Math.max(mag, maxDist);
      result[0] = minDist;
      result[1] = maxDist;
      return result;
    }
    transform(transformation) {
      this.center.transformAsPoint(transformation);
      const xAxis = this.halfAxes.getColumn(0, scratchVectorU);
      xAxis.transformAsPoint(transformation);
      const yAxis = this.halfAxes.getColumn(1, scratchVectorV);
      yAxis.transformAsPoint(transformation);
      const zAxis = this.halfAxes.getColumn(2, scratchVectorW);
      zAxis.transformAsPoint(transformation);
      this.halfAxes = new Matrix3([...xAxis, ...yAxis, ...zAxis]);
      return this;
    }
    getTransform() {
      throw new Error("not implemented");
    }
  };

  // ../../node_modules/@math.gl/culling/dist/esm/lib/plane.js
  var scratchPosition = new Vector3();
  var scratchNormal2 = new Vector3();
  var Plane = class {
    constructor(normal = [0, 0, 1], distance = 0) {
      _defineProperty3(this, "normal", void 0);
      _defineProperty3(this, "distance", void 0);
      this.normal = new Vector3();
      this.distance = -0;
      this.fromNormalDistance(normal, distance);
    }
    fromNormalDistance(normal, distance) {
      assert5(Number.isFinite(distance));
      this.normal.from(normal).normalize();
      this.distance = distance;
      return this;
    }
    fromPointNormal(point, normal) {
      point = scratchPosition.from(point);
      this.normal.from(normal).normalize();
      const distance = -this.normal.dot(point);
      this.distance = distance;
      return this;
    }
    fromCoefficients(a2, b, c, d) {
      this.normal.set(a2, b, c);
      assert5(equals(this.normal.len(), 1));
      this.distance = d;
      return this;
    }
    clone() {
      return new Plane(this.normal, this.distance);
    }
    equals(right) {
      return equals(this.distance, right.distance) && equals(this.normal, right.normal);
    }
    getPointDistance(point) {
      return this.normal.dot(point) + this.distance;
    }
    transform(matrix4) {
      const normal = scratchNormal2.copy(this.normal).transformAsVector(matrix4).normalize();
      const point = this.normal.scale(-this.distance).transform(matrix4);
      return this.fromPointNormal(point, normal);
    }
    projectPointOntoPlane(point, result = [0, 0, 0]) {
      point = scratchPosition.from(point);
      const pointDistance = this.getPointDistance(point);
      const scaledNormal = scratchNormal2.copy(this.normal).scale(pointDistance);
      return point.subtract(scaledNormal).to(result);
    }
  };

  // ../../node_modules/@math.gl/culling/dist/esm/lib/culling-volume.js
  var faces = [new Vector3([1, 0, 0]), new Vector3([0, 1, 0]), new Vector3([0, 0, 1])];
  var scratchPlaneCenter = new Vector3();
  var scratchPlaneNormal = new Vector3();
  var scratchPlane = new Plane(new Vector3(1, 0, 0), 0);
  var CullingVolume = class {
    constructor(planes = []) {
      _defineProperty3(this, "planes", void 0);
      this.planes = planes;
    }
    fromBoundingSphere(boundingSphere) {
      this.planes.length = 2 * faces.length;
      const center = boundingSphere.center;
      const radius = boundingSphere.radius;
      let planeIndex = 0;
      for (const faceNormal of faces) {
        let plane0 = this.planes[planeIndex];
        let plane1 = this.planes[planeIndex + 1];
        if (!plane0) {
          plane0 = this.planes[planeIndex] = new Plane();
        }
        if (!plane1) {
          plane1 = this.planes[planeIndex + 1] = new Plane();
        }
        const plane0Center = scratchPlaneCenter.copy(faceNormal).scale(-radius).add(center);
        const plane0Distance = -faceNormal.dot(plane0Center);
        plane0.fromPointNormal(plane0Center, faceNormal);
        const plane1Center = scratchPlaneCenter.copy(faceNormal).scale(radius).add(center);
        const negatedFaceNormal = scratchPlaneNormal.copy(faceNormal).negate();
        const plane1Distance = -negatedFaceNormal.dot(plane1Center);
        plane1.fromPointNormal(plane1Center, negatedFaceNormal);
        planeIndex += 2;
      }
      return this;
    }
    computeVisibility(boundingVolume) {
      let intersect2 = INTERSECTION.INSIDE;
      for (const plane of this.planes) {
        const result = boundingVolume.intersectPlane(plane);
        switch (result) {
          case INTERSECTION.OUTSIDE:
            return INTERSECTION.OUTSIDE;
          case INTERSECTION.INTERSECTING:
            intersect2 = INTERSECTION.INTERSECTING;
            break;
          default:
        }
      }
      return intersect2;
    }
    computeVisibilityWithPlaneMask(boundingVolume, parentPlaneMask) {
      assert5(Number.isFinite(parentPlaneMask), "parentPlaneMask is required.");
      if (parentPlaneMask === CullingVolume.MASK_OUTSIDE || parentPlaneMask === CullingVolume.MASK_INSIDE) {
        return parentPlaneMask;
      }
      let mask = CullingVolume.MASK_INSIDE;
      const planes = this.planes;
      for (let k = 0; k < this.planes.length; ++k) {
        const flag = k < 31 ? 1 << k : 0;
        if (k < 31 && (parentPlaneMask & flag) === 0) {
          continue;
        }
        const plane = planes[k];
        const result = boundingVolume.intersectPlane(plane);
        if (result === INTERSECTION.OUTSIDE) {
          return CullingVolume.MASK_OUTSIDE;
        } else if (result === INTERSECTION.INTERSECTING) {
          mask |= flag;
        }
      }
      return mask;
    }
  };
  _defineProperty3(CullingVolume, "MASK_OUTSIDE", 4294967295);
  _defineProperty3(CullingVolume, "MASK_INSIDE", 0);
  _defineProperty3(CullingVolume, "MASK_INDETERMINATE", 2147483647);

  // ../../node_modules/@math.gl/culling/dist/esm/lib/perspective-off-center-frustum.js
  var scratchPlaneUpVector = new Vector3();
  var scratchPlaneRightVector = new Vector3();
  var scratchPlaneNearCenter = new Vector3();
  var scratchPlaneFarCenter = new Vector3();
  var scratchPlaneNormal2 = new Vector3();

  // ../../node_modules/@math.gl/culling/dist/esm/lib/algorithms/bounding-sphere-from-points.js
  var fromPointsXMin = new Vector3();
  var fromPointsYMin = new Vector3();
  var fromPointsZMin = new Vector3();
  var fromPointsXMax = new Vector3();
  var fromPointsYMax = new Vector3();
  var fromPointsZMax = new Vector3();
  var fromPointsCurrentPos = new Vector3();
  var fromPointsScratch = new Vector3();
  var fromPointsRitterCenter = new Vector3();
  var fromPointsMinBoxPt = new Vector3();
  var fromPointsMaxBoxPt = new Vector3();
  var fromPointsNaiveCenterScratch = new Vector3();
  var volumeConstant = 4 / 3 * Math.PI;

  // ../../node_modules/@math.gl/culling/dist/esm/lib/algorithms/compute-eigen-decomposition.js
  var scratchMatrix = new Matrix3();
  var scratchUnitary = new Matrix3();
  var scratchDiagonal = new Matrix3();
  var jMatrix = new Matrix3();
  var jMatrixTranspose = new Matrix3();
  function computeEigenDecomposition(matrix, result = {}) {
    const EIGEN_TOLERANCE = math_utils_default.EPSILON20;
    const EIGEN_MAX_SWEEPS = 10;
    let count = 0;
    let sweep = 0;
    const unitaryMatrix = scratchUnitary;
    const diagonalMatrix = scratchDiagonal;
    unitaryMatrix.identity();
    diagonalMatrix.copy(matrix);
    const epsilon = EIGEN_TOLERANCE * computeFrobeniusNorm(diagonalMatrix);
    while (sweep < EIGEN_MAX_SWEEPS && offDiagonalFrobeniusNorm(diagonalMatrix) > epsilon) {
      shurDecomposition(diagonalMatrix, jMatrix);
      jMatrixTranspose.copy(jMatrix).transpose();
      diagonalMatrix.multiplyRight(jMatrix);
      diagonalMatrix.multiplyLeft(jMatrixTranspose);
      unitaryMatrix.multiplyRight(jMatrix);
      if (++count > 2) {
        ++sweep;
        count = 0;
      }
    }
    result.unitary = unitaryMatrix.toTarget(result.unitary);
    result.diagonal = diagonalMatrix.toTarget(result.diagonal);
    return result;
  }
  function computeFrobeniusNorm(matrix) {
    let norm = 0;
    for (let i3 = 0; i3 < 9; ++i3) {
      const temp = matrix[i3];
      norm += temp * temp;
    }
    return Math.sqrt(norm);
  }
  var rowVal = [1, 0, 0];
  var colVal = [2, 2, 1];
  function offDiagonalFrobeniusNorm(matrix) {
    let norm = 0;
    for (let i3 = 0; i3 < 3; ++i3) {
      const temp = matrix[scratchMatrix.getElementIndex(colVal[i3], rowVal[i3])];
      norm += 2 * temp * temp;
    }
    return Math.sqrt(norm);
  }
  function shurDecomposition(matrix, result) {
    const tolerance = math_utils_default.EPSILON15;
    let maxDiagonal = 0;
    let rotAxis = 1;
    for (let i3 = 0; i3 < 3; ++i3) {
      const temp = Math.abs(matrix[scratchMatrix.getElementIndex(colVal[i3], rowVal[i3])]);
      if (temp > maxDiagonal) {
        rotAxis = i3;
        maxDiagonal = temp;
      }
    }
    const p2 = rowVal[rotAxis];
    const q = colVal[rotAxis];
    let c = 1;
    let s2 = 0;
    if (Math.abs(matrix[scratchMatrix.getElementIndex(q, p2)]) > tolerance) {
      const qq = matrix[scratchMatrix.getElementIndex(q, q)];
      const pp = matrix[scratchMatrix.getElementIndex(p2, p2)];
      const qp = matrix[scratchMatrix.getElementIndex(q, p2)];
      const tau = (qq - pp) / 2 / qp;
      let t2;
      if (tau < 0) {
        t2 = -1 / (-tau + Math.sqrt(1 + tau * tau));
      } else {
        t2 = 1 / (tau + Math.sqrt(1 + tau * tau));
      }
      c = 1 / Math.sqrt(1 + t2 * t2);
      s2 = t2 * c;
    }
    Matrix3.IDENTITY.to(result);
    result[scratchMatrix.getElementIndex(p2, p2)] = result[scratchMatrix.getElementIndex(q, q)] = c;
    result[scratchMatrix.getElementIndex(q, p2)] = s2;
    result[scratchMatrix.getElementIndex(p2, q)] = -s2;
    return result;
  }

  // ../../node_modules/@math.gl/culling/dist/esm/lib/algorithms/bounding-box-from-points.js
  var scratchVector23 = new Vector3();
  var scratchVector32 = new Vector3();
  var scratchVector4 = new Vector3();
  var scratchVector5 = new Vector3();
  var scratchVector6 = new Vector3();
  var scratchCovarianceResult = new Matrix3();
  var scratchEigenResult = {
    diagonal: new Matrix3(),
    unitary: new Matrix3()
  };
  function makeOrientedBoundingBoxFromPoints(positions, result = new OrientedBoundingBox()) {
    if (!positions || positions.length === 0) {
      result.halfAxes = new Matrix3([0, 0, 0, 0, 0, 0, 0, 0, 0]);
      result.center = new Vector3();
      return result;
    }
    const length5 = positions.length;
    const meanPoint = new Vector3(0, 0, 0);
    for (const position of positions) {
      meanPoint.add(position);
    }
    const invLength = 1 / length5;
    meanPoint.multiplyByScalar(invLength);
    let exx = 0;
    let exy = 0;
    let exz = 0;
    let eyy = 0;
    let eyz = 0;
    let ezz = 0;
    for (const position of positions) {
      const p2 = scratchVector23.copy(position).subtract(meanPoint);
      exx += p2.x * p2.x;
      exy += p2.x * p2.y;
      exz += p2.x * p2.z;
      eyy += p2.y * p2.y;
      eyz += p2.y * p2.z;
      ezz += p2.z * p2.z;
    }
    exx *= invLength;
    exy *= invLength;
    exz *= invLength;
    eyy *= invLength;
    eyz *= invLength;
    ezz *= invLength;
    const covarianceMatrix = scratchCovarianceResult;
    covarianceMatrix[0] = exx;
    covarianceMatrix[1] = exy;
    covarianceMatrix[2] = exz;
    covarianceMatrix[3] = exy;
    covarianceMatrix[4] = eyy;
    covarianceMatrix[5] = eyz;
    covarianceMatrix[6] = exz;
    covarianceMatrix[7] = eyz;
    covarianceMatrix[8] = ezz;
    const {
      unitary
    } = computeEigenDecomposition(covarianceMatrix, scratchEigenResult);
    const rotation = result.halfAxes.copy(unitary);
    let v1 = rotation.getColumn(0, scratchVector4);
    let v2 = rotation.getColumn(1, scratchVector5);
    let v3 = rotation.getColumn(2, scratchVector6);
    let u1 = -Number.MAX_VALUE;
    let u2 = -Number.MAX_VALUE;
    let u3 = -Number.MAX_VALUE;
    let l1 = Number.MAX_VALUE;
    let l2 = Number.MAX_VALUE;
    let l3 = Number.MAX_VALUE;
    for (const position of positions) {
      scratchVector23.copy(position);
      u1 = Math.max(scratchVector23.dot(v1), u1);
      u2 = Math.max(scratchVector23.dot(v2), u2);
      u3 = Math.max(scratchVector23.dot(v3), u3);
      l1 = Math.min(scratchVector23.dot(v1), l1);
      l2 = Math.min(scratchVector23.dot(v2), l2);
      l3 = Math.min(scratchVector23.dot(v3), l3);
    }
    v1 = v1.multiplyByScalar(0.5 * (l1 + u1));
    v2 = v2.multiplyByScalar(0.5 * (l2 + u2));
    v3 = v3.multiplyByScalar(0.5 * (l3 + u3));
    result.center.copy(v1).add(v2).add(v3);
    const scale5 = scratchVector32.set(u1 - l1, u2 - l2, u3 - l3).multiplyByScalar(0.5);
    const scaleMatrix = new Matrix3([scale5[0], 0, 0, 0, scale5[1], 0, 0, 0, scale5[2]]);
    result.halfAxes.multiplyRight(scaleMatrix);
    return result;
  }

  // src/tileset-2d/tile-2d-traversal.ts
  var TILE_SIZE3 = 512;
  var MAX_MAPS = 3;
  var REF_POINTS_5 = [[0.5, 0.5], [0, 0], [0, 1], [1, 0], [1, 1]];
  var REF_POINTS_9 = REF_POINTS_5.concat([[0, 0.5], [0.5, 0], [1, 0.5], [0.5, 1]]);
  var REF_POINTS_11 = REF_POINTS_9.concat([[0.25, 0.5], [0.75, 0.5]]);
  var OSMNode = class {
    constructor(x2, y2, z) {
      this.x = x2;
      this.y = y2;
      this.z = z;
    }
    get children() {
      if (!this._children) {
        const x2 = this.x * 2;
        const y2 = this.y * 2;
        const z = this.z + 1;
        this._children = [new OSMNode(x2, y2, z), new OSMNode(x2, y2 + 1, z), new OSMNode(x2 + 1, y2, z), new OSMNode(x2 + 1, y2 + 1, z)];
      }
      return this._children;
    }
    update(params) {
      const {
        viewport,
        cullingVolume: cullingVolume2,
        elevationBounds,
        minZ,
        maxZ,
        bounds,
        offset,
        project: project2
      } = params;
      const boundingVolume = this.getBoundingVolume(elevationBounds, offset, project2);
      if (bounds && !this.insideBounds(bounds)) {
        return false;
      }
      const isInside = cullingVolume2.computeVisibility(boundingVolume);
      if (isInside < 0) {
        return false;
      }
      if (!this.childVisible) {
        let {
          z
        } = this;
        if (z < maxZ && z >= minZ) {
          const distance = boundingVolume.distanceTo(viewport.cameraPosition) * viewport.scale / viewport.height;
          z += Math.floor(Math.log2(distance));
        }
        if (z >= maxZ) {
          this.selected = true;
          return true;
        }
      }
      this.selected = false;
      this.childVisible = true;
      for (const child of this.children) {
        child.update(params);
      }
      return true;
    }
    getSelected(result = []) {
      if (this.selected) {
        result.push(this);
      }
      if (this._children) {
        for (const node2 of this._children) {
          node2.getSelected(result);
        }
      }
      return result;
    }
    insideBounds([minX, minY, maxX, maxY]) {
      const scale5 = Math.pow(2, this.z);
      const extent = TILE_SIZE3 / scale5;
      return this.x * extent < maxX && this.y * extent < maxY && (this.x + 1) * extent > minX && (this.y + 1) * extent > minY;
    }
    getBoundingVolume(zRange, worldOffset, project2) {
      if (project2) {
        const refPoints = this.z < 1 ? REF_POINTS_11 : this.z < 2 ? REF_POINTS_9 : REF_POINTS_5;
        const refPointPositions = [];
        for (const p2 of refPoints) {
          const lngLat = osmTile2lngLat(this.x + p2[0], this.y + p2[1], this.z);
          lngLat[2] = zRange[0];
          refPointPositions.push(project2(lngLat));
          if (zRange[0] !== zRange[1]) {
            lngLat[2] = zRange[1];
            refPointPositions.push(project2(lngLat));
          }
        }
        return makeOrientedBoundingBoxFromPoints(refPointPositions);
      }
      const scale5 = Math.pow(2, this.z);
      const extent = TILE_SIZE3 / scale5;
      const originX = this.x * extent + worldOffset * TILE_SIZE3;
      const originY = TILE_SIZE3 - (this.y + 1) * extent;
      return new AxisAlignedBoundingBox([originX, originY, zRange[0]], [originX + extent, originY + extent, zRange[1]]);
    }
  };
  function getOSMTileIndices(viewport, maxZ, zRange, bounds) {
    const project2 = viewport instanceof import_core12._GlobeViewport && viewport.resolution ? viewport.projectPosition : null;
    const planes = Object.values(viewport.getFrustumPlanes()).map(({
      normal,
      distance
    }) => new Plane(normal.clone().negate(), distance));
    const cullingVolume2 = new CullingVolume(planes);
    const unitsPerMeter2 = viewport.distanceScales.unitsPerMeter[2];
    const elevationMin = zRange && zRange[0] * unitsPerMeter2 || 0;
    const elevationMax = zRange && zRange[1] * unitsPerMeter2 || 0;
    const minZ = viewport instanceof import_core12.WebMercatorViewport && viewport.pitch <= 60 ? maxZ : 0;
    if (bounds) {
      const [minLng, minLat, maxLng, maxLat] = bounds;
      const topLeft = lngLatToWorld([minLng, maxLat]);
      const bottomRight = lngLatToWorld([maxLng, minLat]);
      bounds = [topLeft[0], TILE_SIZE3 - topLeft[1], bottomRight[0], TILE_SIZE3 - bottomRight[1]];
    }
    const root = new OSMNode(0, 0, 0);
    const traversalParams = {
      viewport,
      project: project2,
      cullingVolume: cullingVolume2,
      elevationBounds: [elevationMin, elevationMax],
      minZ,
      maxZ,
      bounds,
      offset: 0
    };
    root.update(traversalParams);
    if (viewport instanceof import_core12.WebMercatorViewport && viewport.subViewports && viewport.subViewports.length > 1) {
      traversalParams.offset = -1;
      while (root.update(traversalParams)) {
        if (--traversalParams.offset < -MAX_MAPS) {
          break;
        }
      }
      traversalParams.offset = 1;
      while (root.update(traversalParams)) {
        if (++traversalParams.offset > MAX_MAPS) {
          break;
        }
      }
    }
    return root.getSelected();
  }

  // src/tileset-2d/utils.ts
  var TILE_SIZE4 = 512;
  var DEFAULT_EXTENT = [-Infinity, -Infinity, Infinity, Infinity];
  var urlType = {
    type: "object",
    value: null,
    validate: (value, propType) => propType.optional && value === null || typeof value === "string" || Array.isArray(value) && value.every((url) => typeof url === "string"),
    equal: (value1, value2) => {
      if (value1 === value2) {
        return true;
      }
      if (!Array.isArray(value1) || !Array.isArray(value2)) {
        return false;
      }
      const len2 = value1.length;
      if (len2 !== value2.length) {
        return false;
      }
      for (let i3 = 0; i3 < len2; i3++) {
        if (value1[i3] !== value2[i3]) {
          return false;
        }
      }
      return true;
    }
  };
  function transformBox(bbox, modelMatrix) {
    const transformedCoords = [
      modelMatrix.transformAsPoint([bbox[0], bbox[1]]),
      modelMatrix.transformAsPoint([bbox[2], bbox[1]]),
      modelMatrix.transformAsPoint([bbox[0], bbox[3]]),
      modelMatrix.transformAsPoint([bbox[2], bbox[3]])
    ];
    const transformedBox = [
      Math.min(...transformedCoords.map((i3) => i3[0])),
      Math.min(...transformedCoords.map((i3) => i3[1])),
      Math.max(...transformedCoords.map((i3) => i3[0])),
      Math.max(...transformedCoords.map((i3) => i3[1]))
    ];
    return transformedBox;
  }
  function stringHash(s2) {
    return Math.abs(s2.split("").reduce((a2, b) => (a2 << 5) - a2 + b.charCodeAt(0) | 0, 0));
  }
  function getURLFromTemplate(template, tile) {
    if (!template || !template.length) {
      return null;
    }
    const {
      index,
      id
    } = tile;
    if (Array.isArray(template)) {
      const i3 = stringHash(id) % template.length;
      template = template[i3];
    }
    let url = template;
    for (const key of Object.keys(index)) {
      const regex = new RegExp(`{${key}}`, "g");
      url = url.replace(regex, String(index[key]));
    }
    if (Number.isInteger(index.y) && Number.isInteger(index.z)) {
      url = url.replace(/\{-y\}/g, String(Math.pow(2, index.z) - index.y - 1));
    }
    return url;
  }
  function getBoundingBox(viewport, zRange, extent) {
    let bounds;
    if (zRange && zRange.length === 2) {
      const [minZ, maxZ] = zRange;
      const bounds0 = viewport.getBounds({
        z: minZ
      });
      const bounds1 = viewport.getBounds({
        z: maxZ
      });
      bounds = [Math.min(bounds0[0], bounds1[0]), Math.min(bounds0[1], bounds1[1]), Math.max(bounds0[2], bounds1[2]), Math.max(bounds0[3], bounds1[3])];
    } else {
      bounds = viewport.getBounds();
    }
    if (!viewport.isGeospatial) {
      return [
        Math.max(Math.min(bounds[0], extent[2]), extent[0]),
        Math.max(Math.min(bounds[1], extent[3]), extent[1]),
        Math.min(Math.max(bounds[2], extent[0]), extent[2]),
        Math.min(Math.max(bounds[3], extent[1]), extent[3])
      ];
    }
    return [Math.max(bounds[0], extent[0]), Math.max(bounds[1], extent[1]), Math.min(bounds[2], extent[2]), Math.min(bounds[3], extent[3])];
  }
  function getCullBounds({
    viewport,
    z = 0,
    cullRect
  }) {
    const subViewports = viewport.subViewports || [viewport];
    return subViewports.map((v) => getCullBoundsInViewport(v, z, cullRect));
  }
  function getCullBoundsInViewport(viewport, z, cullRect) {
    if (!Array.isArray(z)) {
      const x2 = cullRect.x - viewport.x;
      const y2 = cullRect.y - viewport.y;
      const {
        width,
        height
      } = cullRect;
      const unprojectOption = {
        targetZ: z
      };
      const topLeft = viewport.unproject([x2, y2], unprojectOption);
      const topRight = viewport.unproject([x2 + width, y2], unprojectOption);
      const bottomLeft = viewport.unproject([x2, y2 + height], unprojectOption);
      const bottomRight = viewport.unproject([x2 + width, y2 + height], unprojectOption);
      return [Math.min(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]), Math.min(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1]), Math.max(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]), Math.max(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1])];
    }
    const bounds0 = getCullBoundsInViewport(viewport, z[0], cullRect);
    const bounds1 = getCullBoundsInViewport(viewport, z[1], cullRect);
    return [Math.min(bounds0[0], bounds1[0]), Math.min(bounds0[1], bounds1[1]), Math.max(bounds0[2], bounds1[2]), Math.max(bounds0[3], bounds1[3])];
  }
  function getIndexingCoords(bbox, scale5, modelMatrixInverse) {
    if (modelMatrixInverse) {
      const transformedTileIndex = transformBox(bbox, modelMatrixInverse).map((i3) => i3 * scale5 / TILE_SIZE4);
      return transformedTileIndex;
    }
    return bbox.map((i3) => i3 * scale5 / TILE_SIZE4);
  }
  function getScale(z, tileSize) {
    return Math.pow(2, z) * TILE_SIZE4 / tileSize;
  }
  function osmTile2lngLat(x2, y2, z) {
    const scale5 = getScale(z, TILE_SIZE4);
    const lng = x2 / scale5 * 360 - 180;
    const n2 = Math.PI - 2 * Math.PI * y2 / scale5;
    const lat = 180 / Math.PI * Math.atan(0.5 * (Math.exp(n2) - Math.exp(-n2)));
    return [lng, lat];
  }
  function tile2XY(x2, y2, z, tileSize) {
    const scale5 = getScale(z, tileSize);
    return [x2 / scale5 * TILE_SIZE4, y2 / scale5 * TILE_SIZE4];
  }
  function tileToBoundingBox(viewport, x2, y2, z, tileSize = TILE_SIZE4) {
    if (viewport.isGeospatial) {
      const [west, north] = osmTile2lngLat(x2, y2, z);
      const [east, south] = osmTile2lngLat(x2 + 1, y2 + 1, z);
      return {
        west,
        north,
        east,
        south
      };
    }
    const [left, top] = tile2XY(x2, y2, z, tileSize);
    const [right, bottom] = tile2XY(x2 + 1, y2 + 1, z, tileSize);
    return {
      left,
      top,
      right,
      bottom
    };
  }
  function getIdentityTileIndices(viewport, z, tileSize, extent, modelMatrixInverse) {
    const bbox = getBoundingBox(viewport, null, extent);
    const scale5 = getScale(z, tileSize);
    const [minX, minY, maxX, maxY] = getIndexingCoords(bbox, scale5, modelMatrixInverse);
    const indices = [];
    for (let x2 = Math.floor(minX); x2 < maxX; x2++) {
      for (let y2 = Math.floor(minY); y2 < maxY; y2++) {
        indices.push({
          x: x2,
          y: y2,
          z
        });
      }
    }
    return indices;
  }
  function getTileIndices({
    viewport,
    maxZoom,
    minZoom,
    zRange,
    extent,
    tileSize = TILE_SIZE4,
    modelMatrix,
    modelMatrixInverse,
    zoomOffset = 0
  }) {
    let z = viewport.isGeospatial ? Math.round(viewport.zoom + Math.log2(TILE_SIZE4 / tileSize)) + zoomOffset : Math.ceil(viewport.zoom) + zoomOffset;
    if (typeof minZoom === "number" && Number.isFinite(minZoom) && z < minZoom) {
      if (!extent) {
        return [];
      }
      z = minZoom;
    }
    if (typeof maxZoom === "number" && Number.isFinite(maxZoom) && z > maxZoom) {
      z = maxZoom;
    }
    let transformedExtent = extent;
    if (modelMatrix && modelMatrixInverse && extent && !viewport.isGeospatial) {
      transformedExtent = transformBox(extent, modelMatrix);
    }
    return viewport.isGeospatial ? getOSMTileIndices(viewport, z, zRange, extent) : getIdentityTileIndices(viewport, z, tileSize, transformedExtent || DEFAULT_EXTENT, modelMatrixInverse);
  }
  function isURLTemplate(s2) {
    return /(?=.*{z})(?=.*{x})(?=.*({y}|{-y}))/.test(s2);
  }
  function isGeoBoundingBox(v) {
    return Number.isFinite(v.west) && Number.isFinite(v.north) && Number.isFinite(v.east) && Number.isFinite(v.south);
  }

  // src/tileset-2d/memoize.ts
  function memoize(compute) {
    let cachedArgs = {};
    let cachedResult;
    return (args) => {
      for (const key in args) {
        if (!isEqual(args[key], cachedArgs[key])) {
          cachedResult = compute(args);
          cachedArgs = args;
          break;
        }
      }
      return cachedResult;
    };
  }
  function isEqual(a2, b) {
    if (a2 === b) {
      return true;
    }
    if (Array.isArray(a2)) {
      const len2 = a2.length;
      if (!b || b.length !== len2) {
        return false;
      }
      for (let i3 = 0; i3 < len2; i3++) {
        if (a2[i3] !== b[i3]) {
          return false;
        }
      }
      return true;
    }
    return false;
  }

  // src/tileset-2d/tileset-2d.ts
  var TILE_STATE_VISITED = 1;
  var TILE_STATE_VISIBLE = 2;
  var STRATEGY_NEVER = "never";
  var STRATEGY_REPLACE = "no-overlap";
  var STRATEGY_DEFAULT = "best-available";
  var DEFAULT_CACHE_SCALE = 5;
  var STRATEGIES = {
    [STRATEGY_DEFAULT]: updateTileStateDefault,
    [STRATEGY_REPLACE]: updateTileStateReplace,
    [STRATEGY_NEVER]: () => {
    }
  };
  var DEFAULT_TILESET2D_PROPS = {
    extent: null,
    tileSize: 512,
    maxZoom: null,
    minZoom: null,
    maxCacheSize: null,
    maxCacheByteSize: null,
    refinementStrategy: "best-available",
    zRange: null,
    maxRequests: 6,
    zoomOffset: 0,
    onTileLoad: () => {
    },
    onTileUnload: () => {
    },
    onTileError: () => {
    }
  };
  var Tileset2D = class {
    constructor(opts) {
      this.opts = {
        ...DEFAULT_TILESET2D_PROPS,
        ...opts
      };
      this.onTileLoad = (tile) => {
        this.opts.onTileLoad?.(tile);
        if (this.opts.maxCacheByteSize) {
          this._cacheByteSize += tile.byteLength;
          this._resizeCache();
        }
      };
      this._requestScheduler = new RequestScheduler({
        maxRequests: opts.maxRequests,
        throttleRequests: Boolean(opts.maxRequests && opts.maxRequests > 0)
      });
      this._cache = /* @__PURE__ */ new Map();
      this._tiles = [];
      this._dirty = false;
      this._cacheByteSize = 0;
      this._viewport = null;
      this._selectedTiles = null;
      this._frameNumber = 0;
      this._modelMatrix = new Matrix4();
      this._modelMatrixInverse = new Matrix4();
      this.setOptions(opts);
    }
    get tiles() {
      return this._tiles;
    }
    get selectedTiles() {
      return this._selectedTiles;
    }
    get isLoaded() {
      return this._selectedTiles !== null && this._selectedTiles.every((tile) => tile.isLoaded);
    }
    get needsReload() {
      return this._selectedTiles !== null && this._selectedTiles.some((tile) => tile.needsReload);
    }
    setOptions(opts) {
      Object.assign(this.opts, opts);
      if (Number.isFinite(opts.maxZoom)) {
        this._maxZoom = Math.floor(opts.maxZoom);
      }
      if (Number.isFinite(opts.minZoom)) {
        this._minZoom = Math.ceil(opts.minZoom);
      }
    }
    finalize() {
      for (const tile of this._cache.values()) {
        if (tile.isLoading) {
          tile.abort();
        }
      }
      this._cache.clear();
      this._tiles = [];
      this._selectedTiles = null;
    }
    reloadAll() {
      for (const id of this._cache.keys()) {
        const tile = this._cache.get(id);
        if (!this._selectedTiles || !this._selectedTiles.includes(tile)) {
          this._cache.delete(id);
        } else {
          tile.setNeedsReload();
        }
      }
    }
    update(viewport, {
      zRange,
      modelMatrix
    } = {}) {
      const modelMatrixAsMatrix4 = new Matrix4(modelMatrix);
      const isModelMatrixNew = !modelMatrixAsMatrix4.equals(this._modelMatrix);
      if (!this._viewport || !viewport.equals(this._viewport) || !equals(this._zRange, zRange) || isModelMatrixNew) {
        if (isModelMatrixNew) {
          this._modelMatrixInverse = modelMatrixAsMatrix4.clone().invert();
          this._modelMatrix = modelMatrixAsMatrix4;
        }
        this._viewport = viewport;
        this._zRange = zRange;
        const tileIndices = this.getTileIndices({
          viewport,
          maxZoom: this._maxZoom,
          minZoom: this._minZoom,
          zRange,
          modelMatrix: this._modelMatrix,
          modelMatrixInverse: this._modelMatrixInverse
        });
        this._selectedTiles = tileIndices.map((index) => this._getTile(index, true));
        if (this._dirty) {
          this._rebuildTree();
        }
      } else if (this.needsReload) {
        this._selectedTiles = this._selectedTiles.map((tile) => this._getTile(tile.index, true));
      }
      const changed = this.updateTileStates();
      this._pruneRequests();
      if (this._dirty) {
        this._resizeCache();
      }
      if (changed) {
        this._frameNumber++;
      }
      return this._frameNumber;
    }
    isTileVisible(tile, cullRect) {
      if (!tile.isVisible) {
        return false;
      }
      if (cullRect && this._viewport) {
        const boundsArr = this._getCullBounds({
          viewport: this._viewport,
          z: this._zRange,
          cullRect
        });
        const {
          bbox
        } = tile;
        for (const [minX, minY, maxX, maxY] of boundsArr) {
          let overlaps;
          if ("west" in bbox) {
            overlaps = bbox.west < maxX && bbox.east > minX && bbox.south < maxY && bbox.north > minY;
          } else {
            const y0 = Math.min(bbox.top, bbox.bottom);
            const y1 = Math.max(bbox.top, bbox.bottom);
            overlaps = bbox.left < maxX && bbox.right > minX && y0 < maxY && y1 > minY;
          }
          if (overlaps) {
            return true;
          }
        }
        return false;
      }
      return true;
    }
    getTileIndices({
      viewport,
      maxZoom,
      minZoom,
      zRange,
      modelMatrix,
      modelMatrixInverse
    }) {
      const {
        tileSize,
        extent,
        zoomOffset
      } = this.opts;
      return getTileIndices({
        viewport,
        maxZoom,
        minZoom,
        zRange,
        tileSize,
        extent,
        modelMatrix,
        modelMatrixInverse,
        zoomOffset
      });
    }
    getTileId(index) {
      return `${index.x}-${index.y}-${index.z}`;
    }
    getTileZoom(index) {
      return index.z;
    }
    getTileMetadata(index) {
      const {
        tileSize
      } = this.opts;
      return {
        bbox: tileToBoundingBox(this._viewport, index.x, index.y, index.z, tileSize)
      };
    }
    getParentIndex(index) {
      const x2 = Math.floor(index.x / 2);
      const y2 = Math.floor(index.y / 2);
      const z = index.z - 1;
      return {
        x: x2,
        y: y2,
        z
      };
    }
    updateTileStates() {
      const refinementStrategy = this.opts.refinementStrategy || STRATEGY_DEFAULT;
      const visibilities = new Array(this._cache.size);
      let i3 = 0;
      for (const tile of this._cache.values()) {
        visibilities[i3++] = tile.isVisible;
        tile.isSelected = false;
        tile.isVisible = false;
      }
      for (const tile of this._selectedTiles) {
        tile.isSelected = true;
        tile.isVisible = true;
      }
      (typeof refinementStrategy === "function" ? refinementStrategy : STRATEGIES[refinementStrategy])(Array.from(this._cache.values()));
      i3 = 0;
      for (const tile of this._cache.values()) {
        if (visibilities[i3++] !== tile.isVisible) {
          return true;
        }
      }
      return false;
    }
    _getCullBounds = memoize(getCullBounds);
    _pruneRequests() {
      const {
        maxRequests = 0
      } = this.opts;
      const abortCandidates = [];
      let ongoingRequestCount = 0;
      for (const tile of this._cache.values()) {
        if (tile.isLoading) {
          ongoingRequestCount++;
          if (!tile.isSelected && !tile.isVisible) {
            abortCandidates.push(tile);
          }
        }
      }
      while (maxRequests > 0 && ongoingRequestCount > maxRequests && abortCandidates.length > 0) {
        const tile = abortCandidates.shift();
        tile.abort();
        ongoingRequestCount--;
      }
    }
    _rebuildTree() {
      const {
        _cache
      } = this;
      for (const tile of _cache.values()) {
        tile.parent = null;
        if (tile.children) {
          tile.children.length = 0;
        }
      }
      for (const tile of _cache.values()) {
        const parent = this._getNearestAncestor(tile);
        tile.parent = parent;
        if (parent?.children) {
          parent.children.push(tile);
        }
      }
    }
    _resizeCache() {
      const {
        _cache,
        opts
      } = this;
      const maxCacheSize = opts.maxCacheSize || (opts.maxCacheByteSize ? Infinity : DEFAULT_CACHE_SCALE * this.selectedTiles.length);
      const maxCacheByteSize = opts.maxCacheByteSize || Infinity;
      const overflown = _cache.size > maxCacheSize || this._cacheByteSize > maxCacheByteSize;
      if (overflown) {
        for (const [id, tile] of _cache) {
          if (!tile.isVisible && !tile.isSelected) {
            this._cacheByteSize -= opts.maxCacheByteSize ? tile.byteLength : 0;
            _cache.delete(id);
            this.opts.onTileUnload?.(tile);
          }
          if (_cache.size <= maxCacheSize && this._cacheByteSize <= maxCacheByteSize) {
            break;
          }
        }
        this._rebuildTree();
        this._dirty = true;
      }
      if (this._dirty) {
        this._tiles = Array.from(this._cache.values()).sort((t1, t2) => t1.zoom - t2.zoom);
        this._dirty = false;
      }
    }
    _getTile(index, create6) {
      const id = this.getTileId(index);
      let tile = this._cache.get(id);
      let needsReload = false;
      if (!tile && create6) {
        tile = new Tile2DHeader(index);
        Object.assign(tile, this.getTileMetadata(tile.index));
        Object.assign(tile, {
          id,
          zoom: this.getTileZoom(tile.index)
        });
        needsReload = true;
        this._cache.set(id, tile);
        this._dirty = true;
      } else if (tile && tile.needsReload) {
        needsReload = true;
      }
      if (tile && needsReload) {
        tile.loadData({
          getData: this.opts.getTileData,
          requestScheduler: this._requestScheduler,
          onLoad: this.onTileLoad,
          onError: this.opts.onTileError
        });
      }
      return tile;
    }
    _getNearestAncestor(tile) {
      const {
        _minZoom = 0
      } = this;
      let index = tile.index;
      while (this.getTileZoom(index) > _minZoom) {
        index = this.getParentIndex(index);
        const parent = this._getTile(index);
        if (parent) {
          return parent;
        }
      }
      return null;
    }
  };
  function updateTileStateDefault(allTiles) {
    for (const tile of allTiles) {
      tile.state = 0;
    }
    for (const tile of allTiles) {
      if (tile.isSelected && !getPlaceholderInAncestors(tile)) {
        getPlaceholderInChildren(tile);
      }
    }
    for (const tile of allTiles) {
      tile.isVisible = Boolean(tile.state & TILE_STATE_VISIBLE);
    }
  }
  function updateTileStateReplace(allTiles) {
    for (const tile of allTiles) {
      tile.state = 0;
    }
    for (const tile of allTiles) {
      if (tile.isSelected) {
        getPlaceholderInAncestors(tile);
      }
    }
    const sortedTiles = Array.from(allTiles).sort((t1, t2) => t1.zoom - t2.zoom);
    for (const tile of sortedTiles) {
      tile.isVisible = Boolean(tile.state & TILE_STATE_VISIBLE);
      if (tile.children && (tile.isVisible || tile.state & TILE_STATE_VISITED)) {
        for (const child of tile.children) {
          child.state = TILE_STATE_VISITED;
        }
      } else if (tile.isSelected) {
        getPlaceholderInChildren(tile);
      }
    }
  }
  function getPlaceholderInAncestors(startTile) {
    let tile = startTile;
    while (tile) {
      if (tile.isLoaded || tile.content) {
        tile.state |= TILE_STATE_VISIBLE;
        return true;
      }
      tile = tile.parent;
    }
    return false;
  }
  function getPlaceholderInChildren(tile) {
    for (const child of tile.children) {
      if (child.isLoaded || child.content) {
        child.state |= TILE_STATE_VISIBLE;
      } else {
        getPlaceholderInChildren(child);
      }
    }
  }

  // src/tile-layer/tile-layer.ts
  var defaultProps6 = {
    TilesetClass: Tileset2D,
    data: {
      type: "data",
      value: []
    },
    dataComparator: urlType.equal,
    renderSubLayers: {
      type: "function",
      value: (props) => new import_layers5.GeoJsonLayer(props)
    },
    getTileData: {
      type: "function",
      optional: true,
      value: null
    },
    onViewportLoad: {
      type: "function",
      optional: true,
      value: null
    },
    onTileLoad: {
      type: "function",
      value: (tile) => {
      }
    },
    onTileUnload: {
      type: "function",
      value: (tile) => {
      }
    },
    onTileError: {
      type: "function",
      value: (err) => console.error(err)
    },
    extent: {
      type: "array",
      optional: true,
      value: null,
      compare: true
    },
    tileSize: 512,
    maxZoom: null,
    minZoom: 0,
    maxCacheSize: null,
    maxCacheByteSize: null,
    refinementStrategy: STRATEGY_DEFAULT,
    zRange: null,
    maxRequests: 6,
    zoomOffset: 0
  };
  var TileLayer = class extends import_core14.CompositeLayer {
    initializeState() {
      this.state = {
        tileset: null,
        isLoaded: false
      };
    }
    finalizeState() {
      this.state?.tileset?.finalize();
    }
    get isLoaded() {
      return this.state?.tileset?.selectedTiles.every((tile) => tile.isLoaded && tile.layers && tile.layers.every((layer) => layer.isLoaded));
    }
    shouldUpdateState({
      changeFlags
    }) {
      return changeFlags.somethingChanged;
    }
    updateState({
      changeFlags
    }) {
      let {
        tileset
      } = this.state;
      const propsChanged = changeFlags.propsOrDataChanged || changeFlags.updateTriggersChanged;
      const dataChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getTileData);
      if (!tileset) {
        tileset = new this.props.TilesetClass(this._getTilesetOptions());
        this.setState({
          tileset
        });
      } else if (propsChanged) {
        tileset.setOptions(this._getTilesetOptions());
        if (dataChanged) {
          tileset.reloadAll();
        } else {
          this.state.tileset.tiles.forEach((tile) => {
            tile.layers = null;
          });
        }
      }
      this._updateTileset();
    }
    _getTilesetOptions() {
      const {
        tileSize,
        maxCacheSize,
        maxCacheByteSize,
        refinementStrategy,
        extent,
        maxZoom,
        minZoom,
        maxRequests,
        zoomOffset
      } = this.props;
      return {
        maxCacheSize,
        maxCacheByteSize,
        maxZoom,
        minZoom,
        tileSize,
        refinementStrategy,
        extent,
        maxRequests,
        zoomOffset,
        getTileData: this.getTileData.bind(this),
        onTileLoad: this._onTileLoad.bind(this),
        onTileError: this._onTileError.bind(this),
        onTileUnload: this._onTileUnload.bind(this)
      };
    }
    _updateTileset() {
      const {
        tileset
      } = this.state;
      const {
        zRange,
        modelMatrix
      } = this.props;
      const frameNumber = tileset.update(this.context.viewport, {
        zRange,
        modelMatrix
      });
      const {
        isLoaded
      } = tileset;
      const loadingStateChanged = this.state.isLoaded !== isLoaded;
      const tilesetChanged = this.state.frameNumber !== frameNumber;
      if (isLoaded && (loadingStateChanged || tilesetChanged)) {
        this._onViewportLoad();
      }
      if (tilesetChanged) {
        this.setState({
          frameNumber
        });
      }
      this.state.isLoaded = isLoaded;
    }
    _onViewportLoad() {
      const {
        tileset
      } = this.state;
      const {
        onViewportLoad
      } = this.props;
      if (onViewportLoad) {
        onViewportLoad(tileset.selectedTiles);
      }
    }
    _onTileLoad(tile) {
      this.props.onTileLoad(tile);
      tile.layers = null;
      this.setNeedsUpdate();
    }
    _onTileError(error2, tile) {
      this.props.onTileError(error2);
      tile.layers = null;
      this.setNeedsUpdate();
    }
    _onTileUnload(tile) {
      this.props.onTileUnload(tile);
    }
    getTileData(tile) {
      const {
        data,
        getTileData,
        fetch: fetch2
      } = this.props;
      const {
        signal
      } = tile;
      tile.url = typeof data === "string" || Array.isArray(data) ? getURLFromTemplate(data, tile) : null;
      if (getTileData) {
        return getTileData(tile);
      }
      if (fetch2 && tile.url) {
        return fetch2(tile.url, {
          propName: "data",
          layer: this,
          signal
        });
      }
      return null;
    }
    renderSubLayers(props) {
      return this.props.renderSubLayers(props);
    }
    getSubLayerPropsByTile(tile) {
      return null;
    }
    getPickingInfo({
      info,
      sourceLayer
    }) {
      const sourceTile = sourceLayer.props.tile;
      if (info.picked) {
        info.tile = sourceTile;
      }
      info.sourceTile = sourceTile;
      return info;
    }
    _updateAutoHighlight(info) {
      const sourceTile = info.sourceTile;
      if (sourceTile && sourceTile.layers) {
        for (const layer of sourceTile.layers) {
          layer.updateAutoHighlight(info);
        }
      }
    }
    renderLayers() {
      return this.state.tileset.tiles.map((tile) => {
        const subLayerProps = this.getSubLayerPropsByTile(tile);
        if (!tile.isLoaded && !tile.content) {
        } else if (!tile.layers) {
          const layers = this.renderSubLayers({
            ...this.props,
            id: `${this.id}-${tile.id}`,
            data: tile.content,
            _offset: 0,
            tile
          });
          tile.layers = (0, import_core14._flatten)(layers, Boolean).map((layer) => layer.clone({
            tile,
            ...subLayerProps
          }));
        } else if (subLayerProps && tile.layers[0] && Object.keys(subLayerProps).some((propName) => tile.layers[0].props[propName] !== subLayerProps[propName])) {
          tile.layers = tile.layers.map((layer) => layer.clone(subLayerProps));
        }
        return tile.layers;
      });
    }
    filterSubLayer({
      layer,
      cullRect
    }) {
      const {
        tile
      } = layer.props;
      return this.state.tileset.isTileVisible(tile, cullRect);
    }
  };
  __publicField(TileLayer, "defaultProps", defaultProps6);
  __publicField(TileLayer, "layerName", "TileLayer");

  // src/trips-layer/trips-layer.ts
  var import_layers6 = __toESM(require_layers());
  var defaultProps7 = {
    fadeTrail: true,
    trailLength: {
      type: "number",
      value: 120,
      min: 0
    },
    currentTime: {
      type: "number",
      value: 0,
      min: 0
    },
    getTimestamps: {
      type: "accessor",
      value: (d) => d.timestamps
    }
  };
  var TripsLayer = class extends import_layers6.PathLayer {
    getShaders() {
      const shaders = super.getShaders();
      shaders.inject = {
        "vs:#decl": `uniform float trailLength;
attribute float instanceTimestamps;
attribute float instanceNextTimestamps;
varying float vTime;
`,
        "vs:#main-end": `vTime = instanceTimestamps + (instanceNextTimestamps - instanceTimestamps) * vPathPosition.y / vPathLength;
`,
        "fs:#decl": `uniform bool fadeTrail;
uniform float trailLength;
uniform float currentTime;
varying float vTime;
`,
        "fs:#main-start": `if(vTime > currentTime || (fadeTrail && (vTime < currentTime - trailLength))) {
  discard;
}
`,
        "fs:DECKGL_FILTER_COLOR": `if(fadeTrail) {
  color.a *= 1.0 - (currentTime - vTime) / trailLength;
}
`
      };
      return shaders;
    }
    initializeState() {
      super.initializeState();
      const attributeManager = this.getAttributeManager();
      attributeManager.addInstanced({
        timestamps: {
          size: 1,
          accessor: "getTimestamps",
          shaderAttributes: {
            instanceTimestamps: {
              vertexOffset: 0
            },
            instanceNextTimestamps: {
              vertexOffset: 1
            }
          }
        }
      });
    }
    draw(params) {
      const {
        fadeTrail,
        trailLength,
        currentTime
      } = this.props;
      params.uniforms = {
        ...params.uniforms,
        fadeTrail,
        trailLength,
        currentTime
      };
      super.draw(params);
    }
  };
  __publicField(TripsLayer, "layerName", "TripsLayer");
  __publicField(TripsLayer, "defaultProps", defaultProps7);

  // src/h3-layers/h3-cluster-layer.ts
  var import_h3_js2 = __toESM(require_h3_js());
  var import_core17 = __toESM(require_core());

  // src/h3-layers/h3-hexagon-layer.ts
  var import_h3_js = __toESM(require_h3_js());
  var import_core16 = __toESM(require_core());
  var import_layers7 = __toESM(require_layers());
  var UPDATE_THRESHOLD_KM = 10;
  function normalizeLongitudes(vertices, refLng) {
    refLng = refLng === void 0 ? vertices[0][0] : refLng;
    for (const pt of vertices) {
      const deltaLng = pt[0] - refLng;
      if (deltaLng > 180) {
        pt[0] -= 360;
      } else if (deltaLng < -180) {
        pt[0] += 360;
      }
    }
  }
  function scalePolygon(hexId, vertices, factor) {
    const [lat, lng] = (0, import_h3_js.h3ToGeo)(hexId);
    const actualCount = vertices.length;
    normalizeLongitudes(vertices, lng);
    const vertexCount = vertices[0] === vertices[actualCount - 1] ? actualCount - 1 : actualCount;
    for (let i3 = 0; i3 < vertexCount; i3++) {
      vertices[i3][0] = lerp3(lng, vertices[i3][0], factor);
      vertices[i3][1] = lerp3(lat, vertices[i3][1], factor);
    }
  }
  function getHexagonCentroid(getHexagon, object, objectInfo) {
    const hexagonId = getHexagon(object, objectInfo);
    const [lat, lng] = (0, import_h3_js.h3ToGeo)(hexagonId);
    return [lng, lat];
  }
  function h3ToPolygon(hexId, coverage = 1) {
    const vertices = (0, import_h3_js.h3ToGeoBoundary)(hexId, true);
    if (coverage !== 1) {
      scalePolygon(hexId, vertices, coverage);
    } else {
      normalizeLongitudes(vertices);
    }
    return vertices;
  }
  function flattenPolygon(vertices) {
    const positions = new Float64Array(vertices.length * 2);
    let i3 = 0;
    for (const pt of vertices) {
      positions[i3++] = pt[0];
      positions[i3++] = pt[1];
    }
    return positions;
  }
  function mergeTriggers(getHexagon, coverage) {
    let trigger;
    if (getHexagon === void 0 || getHexagon === null) {
      trigger = coverage;
    } else if (typeof getHexagon === "object") {
      trigger = {
        ...getHexagon,
        coverage
      };
    } else {
      trigger = {
        getHexagon,
        coverage
      };
    }
    return trigger;
  }
  var defaultProps8 = {
    ...import_layers7.PolygonLayer.defaultProps,
    highPrecision: "auto",
    coverage: {
      type: "number",
      min: 0,
      max: 1,
      value: 1
    },
    centerHexagon: null,
    getHexagon: {
      type: "accessor",
      value: (x2) => x2.hexagon
    },
    extruded: true
  };
  var _H3HexagonLayer = class extends import_core16.CompositeLayer {
    initializeState() {
      _H3HexagonLayer._checkH3Lib();
      this.state = {
        edgeLengthKM: 0,
        resolution: -1
      };
    }
    shouldUpdateState({
      changeFlags
    }) {
      return this._shouldUseHighPrecision() ? changeFlags.propsOrDataChanged : changeFlags.somethingChanged;
    }
    updateState({
      props,
      changeFlags
    }) {
      if (props.highPrecision !== true && (changeFlags.dataChanged || changeFlags.updateTriggersChanged && changeFlags.updateTriggersChanged.getHexagon)) {
        const dataProps = this._calculateH3DataProps();
        this.setState(dataProps);
      }
      this._updateVertices(this.context.viewport);
    }
    _calculateH3DataProps() {
      let resolution = -1;
      let hasPentagon = false;
      let hasMultipleRes = false;
      const {
        iterable,
        objectInfo
      } = (0, import_core16.createIterable)(this.props.data);
      for (const object of iterable) {
        objectInfo.index++;
        const hexId = this.props.getHexagon(object, objectInfo);
        const hexResolution = (0, import_h3_js.h3GetResolution)(hexId);
        if (resolution < 0) {
          resolution = hexResolution;
          if (!this.props.highPrecision)
            break;
        } else if (resolution !== hexResolution) {
          hasMultipleRes = true;
          break;
        }
        if ((0, import_h3_js.h3IsPentagon)(hexId)) {
          hasPentagon = true;
          break;
        }
      }
      return {
        resolution,
        edgeLengthKM: resolution >= 0 ? (0, import_h3_js.edgeLength)(resolution, "km") : 0,
        hasMultipleRes,
        hasPentagon
      };
    }
    _shouldUseHighPrecision() {
      if (this.props.highPrecision === "auto") {
        const {
          resolution,
          hasPentagon,
          hasMultipleRes
        } = this.state;
        const {
          viewport
        } = this.context;
        return Boolean(viewport?.resolution) || hasMultipleRes || hasPentagon || resolution >= 0 && resolution <= 5;
      }
      return this.props.highPrecision;
    }
    _updateVertices(viewport) {
      if (this._shouldUseHighPrecision()) {
        return;
      }
      const {
        resolution,
        edgeLengthKM,
        centerHex
      } = this.state;
      if (resolution < 0) {
        return;
      }
      const hex = this.props.centerHexagon || (0, import_h3_js.geoToH3)(viewport.latitude, viewport.longitude, resolution);
      if (centerHex === hex) {
        return;
      }
      if (centerHex) {
        const distance = (0, import_h3_js.h3Distance)(centerHex, hex);
        if (distance >= 0 && distance * edgeLengthKM < UPDATE_THRESHOLD_KM) {
          return;
        }
      }
      const {
        unitsPerMeter: unitsPerMeter2
      } = viewport.distanceScales;
      let vertices = h3ToPolygon(hex);
      const [centerLat, centerLng] = (0, import_h3_js.h3ToGeo)(hex);
      const [centerX, centerY] = viewport.projectFlat([centerLng, centerLat]);
      vertices = vertices.map((p2) => {
        const worldPosition = viewport.projectFlat(p2);
        return [(worldPosition[0] - centerX) / unitsPerMeter2[0], (worldPosition[1] - centerY) / unitsPerMeter2[1]];
      });
      this.setState({
        centerHex: hex,
        vertices
      });
    }
    renderLayers() {
      return this._shouldUseHighPrecision() ? this._renderPolygonLayer() : this._renderColumnLayer();
    }
    _getForwardProps() {
      const {
        elevationScale,
        material,
        coverage,
        extruded,
        wireframe,
        stroked,
        filled,
        lineWidthUnits,
        lineWidthScale,
        lineWidthMinPixels,
        lineWidthMaxPixels,
        getFillColor,
        getElevation,
        getLineColor,
        getLineWidth,
        transitions,
        updateTriggers
      } = this.props;
      return {
        elevationScale,
        extruded,
        coverage,
        wireframe,
        stroked,
        filled,
        lineWidthUnits,
        lineWidthScale,
        lineWidthMinPixels,
        lineWidthMaxPixels,
        material,
        getElevation,
        getFillColor,
        getLineColor,
        getLineWidth,
        transitions,
        updateTriggers: {
          getFillColor: updateTriggers.getFillColor,
          getElevation: updateTriggers.getElevation,
          getLineColor: updateTriggers.getLineColor,
          getLineWidth: updateTriggers.getLineWidth
        }
      };
    }
    _renderPolygonLayer() {
      const {
        data,
        getHexagon,
        updateTriggers,
        coverage
      } = this.props;
      const SubLayerClass = this.getSubLayerClass("hexagon-cell-hifi", import_layers7.PolygonLayer);
      const forwardProps = this._getForwardProps();
      forwardProps.updateTriggers.getPolygon = mergeTriggers(updateTriggers.getHexagon, coverage);
      return new SubLayerClass(forwardProps, this.getSubLayerProps({
        id: "hexagon-cell-hifi",
        updateTriggers: forwardProps.updateTriggers
      }), {
        data,
        _normalize: false,
        _windingOrder: "CCW",
        positionFormat: "XY",
        getPolygon: (object, objectInfo) => {
          const hexagonId = getHexagon(object, objectInfo);
          return flattenPolygon(h3ToPolygon(hexagonId, coverage));
        }
      });
    }
    _renderColumnLayer() {
      const {
        data,
        getHexagon,
        updateTriggers
      } = this.props;
      const SubLayerClass = this.getSubLayerClass("hexagon-cell", import_layers7.ColumnLayer);
      const forwardProps = this._getForwardProps();
      forwardProps.updateTriggers.getPosition = updateTriggers.getHexagon;
      return new SubLayerClass(forwardProps, this.getSubLayerProps({
        id: "hexagon-cell",
        flatShading: true,
        updateTriggers: forwardProps.updateTriggers
      }), {
        data,
        diskResolution: 6,
        radius: 1,
        vertices: this.state.vertices,
        getPosition: getHexagonCentroid.bind(null, getHexagon)
      });
    }
  };
  var H3HexagonLayer = _H3HexagonLayer;
  __publicField(H3HexagonLayer, "defaultProps", defaultProps8);
  __publicField(H3HexagonLayer, "layerName", "H3HexagonLayer");
  __publicField(H3HexagonLayer, "_checkH3Lib", () => {
  });

  // src/h3-layers/h3-cluster-layer.ts
  var defaultProps9 = {
    getHexagons: {
      type: "accessor",
      value: (d) => d.hexagons
    }
  };
  var H3ClusterLayer = class extends GeoCellLayer {
    initializeState() {
      H3HexagonLayer._checkH3Lib();
    }
    updateState({
      props,
      changeFlags
    }) {
      if (changeFlags.dataChanged || changeFlags.updateTriggersChanged && changeFlags.updateTriggersChanged.getHexagons) {
        const {
          data,
          getHexagons
        } = props;
        const polygons = [];
        const {
          iterable,
          objectInfo
        } = (0, import_core17.createIterable)(data);
        for (const object of iterable) {
          objectInfo.index++;
          const hexagons = getHexagons(object, objectInfo);
          const multiPolygon = (0, import_h3_js2.h3SetToMultiPolygon)(hexagons, true);
          for (const polygon of multiPolygon) {
            polygons.push(this.getSubLayerRow({
              polygon
            }, object, objectInfo.index));
          }
        }
        this.setState({
          polygons
        });
      }
    }
    indexToBounds() {
      const {
        getElevation,
        getFillColor,
        getLineColor,
        getLineWidth
      } = this.props;
      return {
        data: this.state.polygons,
        getPolygon: (d) => d.polygon,
        getElevation: this.getSubLayerAccessor(getElevation),
        getFillColor: this.getSubLayerAccessor(getFillColor),
        getLineColor: this.getSubLayerAccessor(getLineColor),
        getLineWidth: this.getSubLayerAccessor(getLineWidth)
      };
    }
  };
  __publicField(H3ClusterLayer, "layerName", "H3ClusterLayer");
  __publicField(H3ClusterLayer, "defaultProps", defaultProps9);

  // ../../node_modules/@luma.gl/constants/dist/esm/index.js
  var esm_default = {
    DEPTH_BUFFER_BIT: 256,
    STENCIL_BUFFER_BIT: 1024,
    COLOR_BUFFER_BIT: 16384,
    POINTS: 0,
    LINES: 1,
    LINE_LOOP: 2,
    LINE_STRIP: 3,
    TRIANGLES: 4,
    TRIANGLE_STRIP: 5,
    TRIANGLE_FAN: 6,
    ZERO: 0,
    ONE: 1,
    SRC_COLOR: 768,
    ONE_MINUS_SRC_COLOR: 769,
    SRC_ALPHA: 770,
    ONE_MINUS_SRC_ALPHA: 771,
    DST_ALPHA: 772,
    ONE_MINUS_DST_ALPHA: 773,
    DST_COLOR: 774,
    ONE_MINUS_DST_COLOR: 775,
    SRC_ALPHA_SATURATE: 776,
    CONSTANT_COLOR: 32769,
    ONE_MINUS_CONSTANT_COLOR: 32770,
    CONSTANT_ALPHA: 32771,
    ONE_MINUS_CONSTANT_ALPHA: 32772,
    FUNC_ADD: 32774,
    FUNC_SUBTRACT: 32778,
    FUNC_REVERSE_SUBTRACT: 32779,
    BLEND_EQUATION: 32777,
    BLEND_EQUATION_RGB: 32777,
    BLEND_EQUATION_ALPHA: 34877,
    BLEND_DST_RGB: 32968,
    BLEND_SRC_RGB: 32969,
    BLEND_DST_ALPHA: 32970,
    BLEND_SRC_ALPHA: 32971,
    BLEND_COLOR: 32773,
    ARRAY_BUFFER_BINDING: 34964,
    ELEMENT_ARRAY_BUFFER_BINDING: 34965,
    LINE_WIDTH: 2849,
    ALIASED_POINT_SIZE_RANGE: 33901,
    ALIASED_LINE_WIDTH_RANGE: 33902,
    CULL_FACE_MODE: 2885,
    FRONT_FACE: 2886,
    DEPTH_RANGE: 2928,
    DEPTH_WRITEMASK: 2930,
    DEPTH_CLEAR_VALUE: 2931,
    DEPTH_FUNC: 2932,
    STENCIL_CLEAR_VALUE: 2961,
    STENCIL_FUNC: 2962,
    STENCIL_FAIL: 2964,
    STENCIL_PASS_DEPTH_FAIL: 2965,
    STENCIL_PASS_DEPTH_PASS: 2966,
    STENCIL_REF: 2967,
    STENCIL_VALUE_MASK: 2963,
    STENCIL_WRITEMASK: 2968,
    STENCIL_BACK_FUNC: 34816,
    STENCIL_BACK_FAIL: 34817,
    STENCIL_BACK_PASS_DEPTH_FAIL: 34818,
    STENCIL_BACK_PASS_DEPTH_PASS: 34819,
    STENCIL_BACK_REF: 36003,
    STENCIL_BACK_VALUE_MASK: 36004,
    STENCIL_BACK_WRITEMASK: 36005,
    VIEWPORT: 2978,
    SCISSOR_BOX: 3088,
    COLOR_CLEAR_VALUE: 3106,
    COLOR_WRITEMASK: 3107,
    UNPACK_ALIGNMENT: 3317,
    PACK_ALIGNMENT: 3333,
    MAX_TEXTURE_SIZE: 3379,
    MAX_VIEWPORT_DIMS: 3386,
    SUBPIXEL_BITS: 3408,
    RED_BITS: 3410,
    GREEN_BITS: 3411,
    BLUE_BITS: 3412,
    ALPHA_BITS: 3413,
    DEPTH_BITS: 3414,
    STENCIL_BITS: 3415,
    POLYGON_OFFSET_UNITS: 10752,
    POLYGON_OFFSET_FACTOR: 32824,
    TEXTURE_BINDING_2D: 32873,
    SAMPLE_BUFFERS: 32936,
    SAMPLES: 32937,
    SAMPLE_COVERAGE_VALUE: 32938,
    SAMPLE_COVERAGE_INVERT: 32939,
    COMPRESSED_TEXTURE_FORMATS: 34467,
    VENDOR: 7936,
    RENDERER: 7937,
    VERSION: 7938,
    IMPLEMENTATION_COLOR_READ_TYPE: 35738,
    IMPLEMENTATION_COLOR_READ_FORMAT: 35739,
    BROWSER_DEFAULT_WEBGL: 37444,
    STATIC_DRAW: 35044,
    STREAM_DRAW: 35040,
    DYNAMIC_DRAW: 35048,
    ARRAY_BUFFER: 34962,
    ELEMENT_ARRAY_BUFFER: 34963,
    BUFFER_SIZE: 34660,
    BUFFER_USAGE: 34661,
    CURRENT_VERTEX_ATTRIB: 34342,
    VERTEX_ATTRIB_ARRAY_ENABLED: 34338,
    VERTEX_ATTRIB_ARRAY_SIZE: 34339,
    VERTEX_ATTRIB_ARRAY_STRIDE: 34340,
    VERTEX_ATTRIB_ARRAY_TYPE: 34341,
    VERTEX_ATTRIB_ARRAY_NORMALIZED: 34922,
    VERTEX_ATTRIB_ARRAY_POINTER: 34373,
    VERTEX_ATTRIB_ARRAY_BUFFER_BINDING: 34975,
    CULL_FACE: 2884,
    FRONT: 1028,
    BACK: 1029,
    FRONT_AND_BACK: 1032,
    BLEND: 3042,
    DEPTH_TEST: 2929,
    DITHER: 3024,
    POLYGON_OFFSET_FILL: 32823,
    SAMPLE_ALPHA_TO_COVERAGE: 32926,
    SAMPLE_COVERAGE: 32928,
    SCISSOR_TEST: 3089,
    STENCIL_TEST: 2960,
    NO_ERROR: 0,
    INVALID_ENUM: 1280,
    INVALID_VALUE: 1281,
    INVALID_OPERATION: 1282,
    OUT_OF_MEMORY: 1285,
    CONTEXT_LOST_WEBGL: 37442,
    CW: 2304,
    CCW: 2305,
    DONT_CARE: 4352,
    FASTEST: 4353,
    NICEST: 4354,
    GENERATE_MIPMAP_HINT: 33170,
    BYTE: 5120,
    UNSIGNED_BYTE: 5121,
    SHORT: 5122,
    UNSIGNED_SHORT: 5123,
    INT: 5124,
    UNSIGNED_INT: 5125,
    FLOAT: 5126,
    DOUBLE: 5130,
    DEPTH_COMPONENT: 6402,
    ALPHA: 6406,
    RGB: 6407,
    RGBA: 6408,
    LUMINANCE: 6409,
    LUMINANCE_ALPHA: 6410,
    UNSIGNED_SHORT_4_4_4_4: 32819,
    UNSIGNED_SHORT_5_5_5_1: 32820,
    UNSIGNED_SHORT_5_6_5: 33635,
    FRAGMENT_SHADER: 35632,
    VERTEX_SHADER: 35633,
    COMPILE_STATUS: 35713,
    DELETE_STATUS: 35712,
    LINK_STATUS: 35714,
    VALIDATE_STATUS: 35715,
    ATTACHED_SHADERS: 35717,
    ACTIVE_ATTRIBUTES: 35721,
    ACTIVE_UNIFORMS: 35718,
    MAX_VERTEX_ATTRIBS: 34921,
    MAX_VERTEX_UNIFORM_VECTORS: 36347,
    MAX_VARYING_VECTORS: 36348,
    MAX_COMBINED_TEXTURE_IMAGE_UNITS: 35661,
    MAX_VERTEX_TEXTURE_IMAGE_UNITS: 35660,
    MAX_TEXTURE_IMAGE_UNITS: 34930,
    MAX_FRAGMENT_UNIFORM_VECTORS: 36349,
    SHADER_TYPE: 35663,
    SHADING_LANGUAGE_VERSION: 35724,
    CURRENT_PROGRAM: 35725,
    NEVER: 512,
    ALWAYS: 519,
    LESS: 513,
    EQUAL: 514,
    LEQUAL: 515,
    GREATER: 516,
    GEQUAL: 518,
    NOTEQUAL: 517,
    KEEP: 7680,
    REPLACE: 7681,
    INCR: 7682,
    DECR: 7683,
    INVERT: 5386,
    INCR_WRAP: 34055,
    DECR_WRAP: 34056,
    NEAREST: 9728,
    LINEAR: 9729,
    NEAREST_MIPMAP_NEAREST: 9984,
    LINEAR_MIPMAP_NEAREST: 9985,
    NEAREST_MIPMAP_LINEAR: 9986,
    LINEAR_MIPMAP_LINEAR: 9987,
    TEXTURE_MAG_FILTER: 10240,
    TEXTURE_MIN_FILTER: 10241,
    TEXTURE_WRAP_S: 10242,
    TEXTURE_WRAP_T: 10243,
    TEXTURE_2D: 3553,
    TEXTURE: 5890,
    TEXTURE_CUBE_MAP: 34067,
    TEXTURE_BINDING_CUBE_MAP: 34068,
    TEXTURE_CUBE_MAP_POSITIVE_X: 34069,
    TEXTURE_CUBE_MAP_NEGATIVE_X: 34070,
    TEXTURE_CUBE_MAP_POSITIVE_Y: 34071,
    TEXTURE_CUBE_MAP_NEGATIVE_Y: 34072,
    TEXTURE_CUBE_MAP_POSITIVE_Z: 34073,
    TEXTURE_CUBE_MAP_NEGATIVE_Z: 34074,
    MAX_CUBE_MAP_TEXTURE_SIZE: 34076,
    TEXTURE0: 33984,
    ACTIVE_TEXTURE: 34016,
    REPEAT: 10497,
    CLAMP_TO_EDGE: 33071,
    MIRRORED_REPEAT: 33648,
    TEXTURE_WIDTH: 4096,
    TEXTURE_HEIGHT: 4097,
    FLOAT_VEC2: 35664,
    FLOAT_VEC3: 35665,
    FLOAT_VEC4: 35666,
    INT_VEC2: 35667,
    INT_VEC3: 35668,
    INT_VEC4: 35669,
    BOOL: 35670,
    BOOL_VEC2: 35671,
    BOOL_VEC3: 35672,
    BOOL_VEC4: 35673,
    FLOAT_MAT2: 35674,
    FLOAT_MAT3: 35675,
    FLOAT_MAT4: 35676,
    SAMPLER_2D: 35678,
    SAMPLER_CUBE: 35680,
    LOW_FLOAT: 36336,
    MEDIUM_FLOAT: 36337,
    HIGH_FLOAT: 36338,
    LOW_INT: 36339,
    MEDIUM_INT: 36340,
    HIGH_INT: 36341,
    FRAMEBUFFER: 36160,
    RENDERBUFFER: 36161,
    RGBA4: 32854,
    RGB5_A1: 32855,
    RGB565: 36194,
    DEPTH_COMPONENT16: 33189,
    STENCIL_INDEX: 6401,
    STENCIL_INDEX8: 36168,
    DEPTH_STENCIL: 34041,
    RENDERBUFFER_WIDTH: 36162,
    RENDERBUFFER_HEIGHT: 36163,
    RENDERBUFFER_INTERNAL_FORMAT: 36164,
    RENDERBUFFER_RED_SIZE: 36176,
    RENDERBUFFER_GREEN_SIZE: 36177,
    RENDERBUFFER_BLUE_SIZE: 36178,
    RENDERBUFFER_ALPHA_SIZE: 36179,
    RENDERBUFFER_DEPTH_SIZE: 36180,
    RENDERBUFFER_STENCIL_SIZE: 36181,
    FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE: 36048,
    FRAMEBUFFER_ATTACHMENT_OBJECT_NAME: 36049,
    FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL: 36050,
    FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE: 36051,
    COLOR_ATTACHMENT0: 36064,
    DEPTH_ATTACHMENT: 36096,
    STENCIL_ATTACHMENT: 36128,
    DEPTH_STENCIL_ATTACHMENT: 33306,
    NONE: 0,
    FRAMEBUFFER_COMPLETE: 36053,
    FRAMEBUFFER_INCOMPLETE_ATTACHMENT: 36054,
    FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT: 36055,
    FRAMEBUFFER_INCOMPLETE_DIMENSIONS: 36057,
    FRAMEBUFFER_UNSUPPORTED: 36061,
    FRAMEBUFFER_BINDING: 36006,
    RENDERBUFFER_BINDING: 36007,
    READ_FRAMEBUFFER: 36008,
    DRAW_FRAMEBUFFER: 36009,
    MAX_RENDERBUFFER_SIZE: 34024,
    INVALID_FRAMEBUFFER_OPERATION: 1286,
    UNPACK_FLIP_Y_WEBGL: 37440,
    UNPACK_PREMULTIPLY_ALPHA_WEBGL: 37441,
    UNPACK_COLORSPACE_CONVERSION_WEBGL: 37443,
    READ_BUFFER: 3074,
    UNPACK_ROW_LENGTH: 3314,
    UNPACK_SKIP_ROWS: 3315,
    UNPACK_SKIP_PIXELS: 3316,
    PACK_ROW_LENGTH: 3330,
    PACK_SKIP_ROWS: 3331,
    PACK_SKIP_PIXELS: 3332,
    TEXTURE_BINDING_3D: 32874,
    UNPACK_SKIP_IMAGES: 32877,
    UNPACK_IMAGE_HEIGHT: 32878,
    MAX_3D_TEXTURE_SIZE: 32883,
    MAX_ELEMENTS_VERTICES: 33e3,
    MAX_ELEMENTS_INDICES: 33001,
    MAX_TEXTURE_LOD_BIAS: 34045,
    MAX_FRAGMENT_UNIFORM_COMPONENTS: 35657,
    MAX_VERTEX_UNIFORM_COMPONENTS: 35658,
    MAX_ARRAY_TEXTURE_LAYERS: 35071,
    MIN_PROGRAM_TEXEL_OFFSET: 35076,
    MAX_PROGRAM_TEXEL_OFFSET: 35077,
    MAX_VARYING_COMPONENTS: 35659,
    FRAGMENT_SHADER_DERIVATIVE_HINT: 35723,
    RASTERIZER_DISCARD: 35977,
    VERTEX_ARRAY_BINDING: 34229,
    MAX_VERTEX_OUTPUT_COMPONENTS: 37154,
    MAX_FRAGMENT_INPUT_COMPONENTS: 37157,
    MAX_SERVER_WAIT_TIMEOUT: 37137,
    MAX_ELEMENT_INDEX: 36203,
    RED: 6403,
    RGB8: 32849,
    RGBA8: 32856,
    RGB10_A2: 32857,
    TEXTURE_3D: 32879,
    TEXTURE_WRAP_R: 32882,
    TEXTURE_MIN_LOD: 33082,
    TEXTURE_MAX_LOD: 33083,
    TEXTURE_BASE_LEVEL: 33084,
    TEXTURE_MAX_LEVEL: 33085,
    TEXTURE_COMPARE_MODE: 34892,
    TEXTURE_COMPARE_FUNC: 34893,
    SRGB: 35904,
    SRGB8: 35905,
    SRGB8_ALPHA8: 35907,
    COMPARE_REF_TO_TEXTURE: 34894,
    RGBA32F: 34836,
    RGB32F: 34837,
    RGBA16F: 34842,
    RGB16F: 34843,
    TEXTURE_2D_ARRAY: 35866,
    TEXTURE_BINDING_2D_ARRAY: 35869,
    R11F_G11F_B10F: 35898,
    RGB9_E5: 35901,
    RGBA32UI: 36208,
    RGB32UI: 36209,
    RGBA16UI: 36214,
    RGB16UI: 36215,
    RGBA8UI: 36220,
    RGB8UI: 36221,
    RGBA32I: 36226,
    RGB32I: 36227,
    RGBA16I: 36232,
    RGB16I: 36233,
    RGBA8I: 36238,
    RGB8I: 36239,
    RED_INTEGER: 36244,
    RGB_INTEGER: 36248,
    RGBA_INTEGER: 36249,
    R8: 33321,
    RG8: 33323,
    R16F: 33325,
    R32F: 33326,
    RG16F: 33327,
    RG32F: 33328,
    R8I: 33329,
    R8UI: 33330,
    R16I: 33331,
    R16UI: 33332,
    R32I: 33333,
    R32UI: 33334,
    RG8I: 33335,
    RG8UI: 33336,
    RG16I: 33337,
    RG16UI: 33338,
    RG32I: 33339,
    RG32UI: 33340,
    R8_SNORM: 36756,
    RG8_SNORM: 36757,
    RGB8_SNORM: 36758,
    RGBA8_SNORM: 36759,
    RGB10_A2UI: 36975,
    TEXTURE_IMMUTABLE_FORMAT: 37167,
    TEXTURE_IMMUTABLE_LEVELS: 33503,
    UNSIGNED_INT_2_10_10_10_REV: 33640,
    UNSIGNED_INT_10F_11F_11F_REV: 35899,
    UNSIGNED_INT_5_9_9_9_REV: 35902,
    FLOAT_32_UNSIGNED_INT_24_8_REV: 36269,
    UNSIGNED_INT_24_8: 34042,
    HALF_FLOAT: 5131,
    RG: 33319,
    RG_INTEGER: 33320,
    INT_2_10_10_10_REV: 36255,
    CURRENT_QUERY: 34917,
    QUERY_RESULT: 34918,
    QUERY_RESULT_AVAILABLE: 34919,
    ANY_SAMPLES_PASSED: 35887,
    ANY_SAMPLES_PASSED_CONSERVATIVE: 36202,
    MAX_DRAW_BUFFERS: 34852,
    DRAW_BUFFER0: 34853,
    DRAW_BUFFER1: 34854,
    DRAW_BUFFER2: 34855,
    DRAW_BUFFER3: 34856,
    DRAW_BUFFER4: 34857,
    DRAW_BUFFER5: 34858,
    DRAW_BUFFER6: 34859,
    DRAW_BUFFER7: 34860,
    DRAW_BUFFER8: 34861,
    DRAW_BUFFER9: 34862,
    DRAW_BUFFER10: 34863,
    DRAW_BUFFER11: 34864,
    DRAW_BUFFER12: 34865,
    DRAW_BUFFER13: 34866,
    DRAW_BUFFER14: 34867,
    DRAW_BUFFER15: 34868,
    MAX_COLOR_ATTACHMENTS: 36063,
    COLOR_ATTACHMENT1: 36065,
    COLOR_ATTACHMENT2: 36066,
    COLOR_ATTACHMENT3: 36067,
    COLOR_ATTACHMENT4: 36068,
    COLOR_ATTACHMENT5: 36069,
    COLOR_ATTACHMENT6: 36070,
    COLOR_ATTACHMENT7: 36071,
    COLOR_ATTACHMENT8: 36072,
    COLOR_ATTACHMENT9: 36073,
    COLOR_ATTACHMENT10: 36074,
    COLOR_ATTACHMENT11: 36075,
    COLOR_ATTACHMENT12: 36076,
    COLOR_ATTACHMENT13: 36077,
    COLOR_ATTACHMENT14: 36078,
    COLOR_ATTACHMENT15: 36079,
    SAMPLER_3D: 35679,
    SAMPLER_2D_SHADOW: 35682,
    SAMPLER_2D_ARRAY: 36289,
    SAMPLER_2D_ARRAY_SHADOW: 36292,
    SAMPLER_CUBE_SHADOW: 36293,
    INT_SAMPLER_2D: 36298,
    INT_SAMPLER_3D: 36299,
    INT_SAMPLER_CUBE: 36300,
    INT_SAMPLER_2D_ARRAY: 36303,
    UNSIGNED_INT_SAMPLER_2D: 36306,
    UNSIGNED_INT_SAMPLER_3D: 36307,
    UNSIGNED_INT_SAMPLER_CUBE: 36308,
    UNSIGNED_INT_SAMPLER_2D_ARRAY: 36311,
    MAX_SAMPLES: 36183,
    SAMPLER_BINDING: 35097,
    PIXEL_PACK_BUFFER: 35051,
    PIXEL_UNPACK_BUFFER: 35052,
    PIXEL_PACK_BUFFER_BINDING: 35053,
    PIXEL_UNPACK_BUFFER_BINDING: 35055,
    COPY_READ_BUFFER: 36662,
    COPY_WRITE_BUFFER: 36663,
    COPY_READ_BUFFER_BINDING: 36662,
    COPY_WRITE_BUFFER_BINDING: 36663,
    FLOAT_MAT2x3: 35685,
    FLOAT_MAT2x4: 35686,
    FLOAT_MAT3x2: 35687,
    FLOAT_MAT3x4: 35688,
    FLOAT_MAT4x2: 35689,
    FLOAT_MAT4x3: 35690,
    UNSIGNED_INT_VEC2: 36294,
    UNSIGNED_INT_VEC3: 36295,
    UNSIGNED_INT_VEC4: 36296,
    UNSIGNED_NORMALIZED: 35863,
    SIGNED_NORMALIZED: 36764,
    VERTEX_ATTRIB_ARRAY_INTEGER: 35069,
    VERTEX_ATTRIB_ARRAY_DIVISOR: 35070,
    TRANSFORM_FEEDBACK_BUFFER_MODE: 35967,
    MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS: 35968,
    TRANSFORM_FEEDBACK_VARYINGS: 35971,
    TRANSFORM_FEEDBACK_BUFFER_START: 35972,
    TRANSFORM_FEEDBACK_BUFFER_SIZE: 35973,
    TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN: 35976,
    MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS: 35978,
    MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS: 35979,
    INTERLEAVED_ATTRIBS: 35980,
    SEPARATE_ATTRIBS: 35981,
    TRANSFORM_FEEDBACK_BUFFER: 35982,
    TRANSFORM_FEEDBACK_BUFFER_BINDING: 35983,
    TRANSFORM_FEEDBACK: 36386,
    TRANSFORM_FEEDBACK_PAUSED: 36387,
    TRANSFORM_FEEDBACK_ACTIVE: 36388,
    TRANSFORM_FEEDBACK_BINDING: 36389,
    FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING: 33296,
    FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE: 33297,
    FRAMEBUFFER_ATTACHMENT_RED_SIZE: 33298,
    FRAMEBUFFER_ATTACHMENT_GREEN_SIZE: 33299,
    FRAMEBUFFER_ATTACHMENT_BLUE_SIZE: 33300,
    FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE: 33301,
    FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE: 33302,
    FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE: 33303,
    FRAMEBUFFER_DEFAULT: 33304,
    DEPTH24_STENCIL8: 35056,
    DRAW_FRAMEBUFFER_BINDING: 36006,
    READ_FRAMEBUFFER_BINDING: 36010,
    RENDERBUFFER_SAMPLES: 36011,
    FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER: 36052,
    FRAMEBUFFER_INCOMPLETE_MULTISAMPLE: 36182,
    UNIFORM_BUFFER: 35345,
    UNIFORM_BUFFER_BINDING: 35368,
    UNIFORM_BUFFER_START: 35369,
    UNIFORM_BUFFER_SIZE: 35370,
    MAX_VERTEX_UNIFORM_BLOCKS: 35371,
    MAX_FRAGMENT_UNIFORM_BLOCKS: 35373,
    MAX_COMBINED_UNIFORM_BLOCKS: 35374,
    MAX_UNIFORM_BUFFER_BINDINGS: 35375,
    MAX_UNIFORM_BLOCK_SIZE: 35376,
    MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS: 35377,
    MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS: 35379,
    UNIFORM_BUFFER_OFFSET_ALIGNMENT: 35380,
    ACTIVE_UNIFORM_BLOCKS: 35382,
    UNIFORM_TYPE: 35383,
    UNIFORM_SIZE: 35384,
    UNIFORM_BLOCK_INDEX: 35386,
    UNIFORM_OFFSET: 35387,
    UNIFORM_ARRAY_STRIDE: 35388,
    UNIFORM_MATRIX_STRIDE: 35389,
    UNIFORM_IS_ROW_MAJOR: 35390,
    UNIFORM_BLOCK_BINDING: 35391,
    UNIFORM_BLOCK_DATA_SIZE: 35392,
    UNIFORM_BLOCK_ACTIVE_UNIFORMS: 35394,
    UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES: 35395,
    UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER: 35396,
    UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER: 35398,
    OBJECT_TYPE: 37138,
    SYNC_CONDITION: 37139,
    SYNC_STATUS: 37140,
    SYNC_FLAGS: 37141,
    SYNC_FENCE: 37142,
    SYNC_GPU_COMMANDS_COMPLETE: 37143,
    UNSIGNALED: 37144,
    SIGNALED: 37145,
    ALREADY_SIGNALED: 37146,
    TIMEOUT_EXPIRED: 37147,
    CONDITION_SATISFIED: 37148,
    WAIT_FAILED: 37149,
    SYNC_FLUSH_COMMANDS_BIT: 1,
    COLOR: 6144,
    DEPTH: 6145,
    STENCIL: 6146,
    MIN: 32775,
    MAX: 32776,
    DEPTH_COMPONENT24: 33190,
    STREAM_READ: 35041,
    STREAM_COPY: 35042,
    STATIC_READ: 35045,
    STATIC_COPY: 35046,
    DYNAMIC_READ: 35049,
    DYNAMIC_COPY: 35050,
    DEPTH_COMPONENT32F: 36012,
    DEPTH32F_STENCIL8: 36013,
    INVALID_INDEX: 4294967295,
    TIMEOUT_IGNORED: -1,
    MAX_CLIENT_WAIT_TIMEOUT_WEBGL: 37447,
    VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE: 35070,
    UNMASKED_VENDOR_WEBGL: 37445,
    UNMASKED_RENDERER_WEBGL: 37446,
    MAX_TEXTURE_MAX_ANISOTROPY_EXT: 34047,
    TEXTURE_MAX_ANISOTROPY_EXT: 34046,
    COMPRESSED_RGB_S3TC_DXT1_EXT: 33776,
    COMPRESSED_RGBA_S3TC_DXT1_EXT: 33777,
    COMPRESSED_RGBA_S3TC_DXT3_EXT: 33778,
    COMPRESSED_RGBA_S3TC_DXT5_EXT: 33779,
    COMPRESSED_R11_EAC: 37488,
    COMPRESSED_SIGNED_R11_EAC: 37489,
    COMPRESSED_RG11_EAC: 37490,
    COMPRESSED_SIGNED_RG11_EAC: 37491,
    COMPRESSED_RGB8_ETC2: 37492,
    COMPRESSED_RGBA8_ETC2_EAC: 37493,
    COMPRESSED_SRGB8_ETC2: 37494,
    COMPRESSED_SRGB8_ALPHA8_ETC2_EAC: 37495,
    COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2: 37496,
    COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2: 37497,
    COMPRESSED_RGB_PVRTC_4BPPV1_IMG: 35840,
    COMPRESSED_RGBA_PVRTC_4BPPV1_IMG: 35842,
    COMPRESSED_RGB_PVRTC_2BPPV1_IMG: 35841,
    COMPRESSED_RGBA_PVRTC_2BPPV1_IMG: 35843,
    COMPRESSED_RGB_ETC1_WEBGL: 36196,
    COMPRESSED_RGB_ATC_WEBGL: 35986,
    COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL: 35986,
    COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL: 34798,
    UNSIGNED_INT_24_8_WEBGL: 34042,
    HALF_FLOAT_OES: 36193,
    RGBA32F_EXT: 34836,
    RGB32F_EXT: 34837,
    FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE_EXT: 33297,
    UNSIGNED_NORMALIZED_EXT: 35863,
    MIN_EXT: 32775,
    MAX_EXT: 32776,
    SRGB_EXT: 35904,
    SRGB_ALPHA_EXT: 35906,
    SRGB8_ALPHA8_EXT: 35907,
    FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING_EXT: 33296,
    FRAGMENT_SHADER_DERIVATIVE_HINT_OES: 35723,
    COLOR_ATTACHMENT0_WEBGL: 36064,
    COLOR_ATTACHMENT1_WEBGL: 36065,
    COLOR_ATTACHMENT2_WEBGL: 36066,
    COLOR_ATTACHMENT3_WEBGL: 36067,
    COLOR_ATTACHMENT4_WEBGL: 36068,
    COLOR_ATTACHMENT5_WEBGL: 36069,
    COLOR_ATTACHMENT6_WEBGL: 36070,
    COLOR_ATTACHMENT7_WEBGL: 36071,
    COLOR_ATTACHMENT8_WEBGL: 36072,
    COLOR_ATTACHMENT9_WEBGL: 36073,
    COLOR_ATTACHMENT10_WEBGL: 36074,
    COLOR_ATTACHMENT11_WEBGL: 36075,
    COLOR_ATTACHMENT12_WEBGL: 36076,
    COLOR_ATTACHMENT13_WEBGL: 36077,
    COLOR_ATTACHMENT14_WEBGL: 36078,
    COLOR_ATTACHMENT15_WEBGL: 36079,
    DRAW_BUFFER0_WEBGL: 34853,
    DRAW_BUFFER1_WEBGL: 34854,
    DRAW_BUFFER2_WEBGL: 34855,
    DRAW_BUFFER3_WEBGL: 34856,
    DRAW_BUFFER4_WEBGL: 34857,
    DRAW_BUFFER5_WEBGL: 34858,
    DRAW_BUFFER6_WEBGL: 34859,
    DRAW_BUFFER7_WEBGL: 34860,
    DRAW_BUFFER8_WEBGL: 34861,
    DRAW_BUFFER9_WEBGL: 34862,
    DRAW_BUFFER10_WEBGL: 34863,
    DRAW_BUFFER11_WEBGL: 34864,
    DRAW_BUFFER12_WEBGL: 34865,
    DRAW_BUFFER13_WEBGL: 34866,
    DRAW_BUFFER14_WEBGL: 34867,
    DRAW_BUFFER15_WEBGL: 34868,
    MAX_COLOR_ATTACHMENTS_WEBGL: 36063,
    MAX_DRAW_BUFFERS_WEBGL: 34852,
    VERTEX_ARRAY_BINDING_OES: 34229,
    QUERY_COUNTER_BITS_EXT: 34916,
    CURRENT_QUERY_EXT: 34917,
    QUERY_RESULT_EXT: 34918,
    QUERY_RESULT_AVAILABLE_EXT: 34919,
    TIME_ELAPSED_EXT: 35007,
    TIMESTAMP_EXT: 36392,
    GPU_DISJOINT_EXT: 36795
  };

  // src/tile-3d-layer/tile-3d-layer.ts
  var import_core41 = __toESM(require_core2());
  var import_core42 = __toESM(require_core());
  var import_layers8 = __toESM(require_layers());
  var import_mesh_layers2 = __toESM(require_mesh_layers());

  // ../../node_modules/@probe.gl/env/dist/esm/lib/is-electron.js
  function isElectron(mockUserAgent) {
    if (typeof window !== "undefined" && typeof window.process === "object" && window.process.type === "renderer") {
      return true;
    }
    if (typeof process !== "undefined" && typeof process.versions === "object" && Boolean(process.versions.electron)) {
      return true;
    }
    const realUserAgent = typeof navigator === "object" && typeof navigator.userAgent === "string" && navigator.userAgent;
    const userAgent = mockUserAgent || realUserAgent;
    if (userAgent && userAgent.indexOf("Electron") >= 0) {
      return true;
    }
    return false;
  }

  // ../../node_modules/@probe.gl/env/dist/esm/lib/is-browser.js
  function isBrowser3() {
    const isNode = typeof process === "object" && String(process) === "[object process]" && !process.browser;
    return !isNode || isElectron();
  }

  // ../../node_modules/@probe.gl/env/dist/esm/lib/globals.js
  var globals3 = {
    self: typeof self !== "undefined" && self,
    window: typeof window !== "undefined" && window,
    global: typeof global !== "undefined" && global,
    document: typeof document !== "undefined" && document,
    process: typeof process === "object" && process
  };
  var self_3 = globals3.self || globals3.window || globals3.global;
  var window_3 = globals3.window || globals3.self || globals3.global;
  var document_3 = globals3.document || {};
  var process_ = globals3.process || {};

  // ../../node_modules/@probe.gl/env/dist/esm/utils/globals.js
  var VERSION6 = typeof __VERSION__ !== "undefined" ? __VERSION__ : "untranspiled source";
  var isBrowser4 = isBrowser3();

  // ../../node_modules/@probe.gl/log/dist/esm/utils/local-storage.js
  function getStorage(type) {
    try {
      const storage = window[type];
      const x2 = "__storage_test__";
      storage.setItem(x2, x2);
      storage.removeItem(x2);
      return storage;
    } catch (e) {
      return null;
    }
  }
  var LocalStorage = class {
    constructor(id) {
      let defaultSettings = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      let type = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "sessionStorage";
      _defineProperty(this, "storage", void 0);
      _defineProperty(this, "id", void 0);
      _defineProperty(this, "config", {});
      this.storage = getStorage(type);
      this.id = id;
      this.config = {};
      Object.assign(this.config, defaultSettings);
      this._loadConfiguration();
    }
    getConfiguration() {
      return this.config;
    }
    setConfiguration(configuration) {
      this.config = {};
      return this.updateConfiguration(configuration);
    }
    updateConfiguration(configuration) {
      Object.assign(this.config, configuration);
      if (this.storage) {
        const serialized = JSON.stringify(this.config);
        this.storage.setItem(this.id, serialized);
      }
      return this;
    }
    _loadConfiguration() {
      let configuration = {};
      if (this.storage) {
        const serializedConfiguration = this.storage.getItem(this.id);
        configuration = serializedConfiguration ? JSON.parse(serializedConfiguration) : {};
      }
      Object.assign(this.config, configuration);
      return this;
    }
  };

  // ../../node_modules/@probe.gl/log/dist/esm/utils/formatters.js
  function formatTime(ms) {
    let formatted;
    if (ms < 10) {
      formatted = "".concat(ms.toFixed(2), "ms");
    } else if (ms < 100) {
      formatted = "".concat(ms.toFixed(1), "ms");
    } else if (ms < 1e3) {
      formatted = "".concat(ms.toFixed(0), "ms");
    } else {
      formatted = "".concat((ms / 1e3).toFixed(2), "s");
    }
    return formatted;
  }
  function leftPad(string) {
    let length5 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 8;
    const padLength = Math.max(length5 - string.length, 0);
    return "".concat(" ".repeat(padLength)).concat(string);
  }
  function formatImage(image, message, scale5) {
    let maxWidth = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 600;
    const imageUrl = image.src.replace(/\(/g, "%28").replace(/\)/g, "%29");
    if (image.width > maxWidth) {
      scale5 = Math.min(scale5, maxWidth / image.width);
    }
    const width = image.width * scale5;
    const height = image.height * scale5;
    const style = ["font-size:1px;", "padding:".concat(Math.floor(height / 2), "px ").concat(Math.floor(width / 2), "px;"), "line-height:".concat(height, "px;"), "background:url(".concat(imageUrl, ");"), "background-size:".concat(width, "px ").concat(height, "px;"), "color:transparent;"].join("");
    return ["".concat(message, " %c+"), style];
  }

  // ../../node_modules/@probe.gl/log/dist/esm/utils/color.js
  var COLOR;
  (function(COLOR2) {
    COLOR2[COLOR2["BLACK"] = 30] = "BLACK";
    COLOR2[COLOR2["RED"] = 31] = "RED";
    COLOR2[COLOR2["GREEN"] = 32] = "GREEN";
    COLOR2[COLOR2["YELLOW"] = 33] = "YELLOW";
    COLOR2[COLOR2["BLUE"] = 34] = "BLUE";
    COLOR2[COLOR2["MAGENTA"] = 35] = "MAGENTA";
    COLOR2[COLOR2["CYAN"] = 36] = "CYAN";
    COLOR2[COLOR2["WHITE"] = 37] = "WHITE";
    COLOR2[COLOR2["BRIGHT_BLACK"] = 90] = "BRIGHT_BLACK";
    COLOR2[COLOR2["BRIGHT_RED"] = 91] = "BRIGHT_RED";
    COLOR2[COLOR2["BRIGHT_GREEN"] = 92] = "BRIGHT_GREEN";
    COLOR2[COLOR2["BRIGHT_YELLOW"] = 93] = "BRIGHT_YELLOW";
    COLOR2[COLOR2["BRIGHT_BLUE"] = 94] = "BRIGHT_BLUE";
    COLOR2[COLOR2["BRIGHT_MAGENTA"] = 95] = "BRIGHT_MAGENTA";
    COLOR2[COLOR2["BRIGHT_CYAN"] = 96] = "BRIGHT_CYAN";
    COLOR2[COLOR2["BRIGHT_WHITE"] = 97] = "BRIGHT_WHITE";
  })(COLOR || (COLOR = {}));
  function getColor(color) {
    return typeof color === "string" ? COLOR[color.toUpperCase()] || COLOR.WHITE : color;
  }
  function addColor(string, color, background) {
    if (!isBrowser3 && typeof string === "string") {
      if (color) {
        color = getColor(color);
        string = "\x1B[".concat(color, "m").concat(string, "\x1B[39m");
      }
      if (background) {
        color = getColor(background);
        string = "\x1B[".concat(background + 10, "m").concat(string, "\x1B[49m");
      }
    }
    return string;
  }

  // ../../node_modules/@probe.gl/log/dist/esm/utils/autobind.js
  function autobind(obj) {
    let predefined = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ["constructor"];
    const proto = Object.getPrototypeOf(obj);
    const propNames = Object.getOwnPropertyNames(proto);
    for (const key of propNames) {
      if (typeof obj[key] === "function") {
        if (!predefined.find((name10) => key === name10)) {
          obj[key] = obj[key].bind(obj);
        }
      }
    }
  }

  // ../../node_modules/@probe.gl/log/dist/esm/utils/assert.js
  function assert6(condition, message) {
    if (!condition) {
      throw new Error(message || "Assertion failed");
    }
  }

  // ../../node_modules/@probe.gl/log/dist/esm/utils/hi-res-timestamp.js
  function getHiResTimestamp2() {
    let timestamp;
    if (isBrowser3 && "performance" in window_3) {
      var _window$performance, _window$performance$n;
      timestamp = window_3 === null || window_3 === void 0 ? void 0 : (_window$performance = window_3.performance) === null || _window$performance === void 0 ? void 0 : (_window$performance$n = _window$performance.now) === null || _window$performance$n === void 0 ? void 0 : _window$performance$n.call(_window$performance);
    } else if ("hrtime" in process_) {
      var _process$hrtime;
      const timeParts = process_ === null || process_ === void 0 ? void 0 : (_process$hrtime = process_.hrtime) === null || _process$hrtime === void 0 ? void 0 : _process$hrtime.call(process_);
      timestamp = timeParts[0] * 1e3 + timeParts[1] / 1e6;
    } else {
      timestamp = Date.now();
    }
    return timestamp;
  }

  // ../../node_modules/@probe.gl/log/dist/esm/log.js
  var originalConsole = {
    debug: isBrowser3 ? console.debug || console.log : console.log,
    log: console.log,
    info: console.info,
    warn: console.warn,
    error: console.error
  };
  var DEFAULT_SETTINGS = {
    enabled: true,
    level: 0
  };
  function noop() {
  }
  var cache = {};
  var ONCE = {
    once: true
  };
  var Log = class {
    constructor() {
      let {
        id
      } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
        id: ""
      };
      _defineProperty(this, "id", void 0);
      _defineProperty(this, "VERSION", VERSION6);
      _defineProperty(this, "_startTs", getHiResTimestamp2());
      _defineProperty(this, "_deltaTs", getHiResTimestamp2());
      _defineProperty(this, "_storage", void 0);
      _defineProperty(this, "userData", {});
      _defineProperty(this, "LOG_THROTTLE_TIMEOUT", 0);
      this.id = id;
      this._storage = new LocalStorage("__probe-".concat(this.id, "__"), DEFAULT_SETTINGS);
      this.userData = {};
      this.timeStamp("".concat(this.id, " started"));
      autobind(this);
      Object.seal(this);
    }
    set level(newLevel) {
      this.setLevel(newLevel);
    }
    get level() {
      return this.getLevel();
    }
    isEnabled() {
      return this._storage.config.enabled;
    }
    getLevel() {
      return this._storage.config.level;
    }
    getTotal() {
      return Number((getHiResTimestamp2() - this._startTs).toPrecision(10));
    }
    getDelta() {
      return Number((getHiResTimestamp2() - this._deltaTs).toPrecision(10));
    }
    set priority(newPriority) {
      this.level = newPriority;
    }
    get priority() {
      return this.level;
    }
    getPriority() {
      return this.level;
    }
    enable() {
      let enabled = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
      this._storage.updateConfiguration({
        enabled
      });
      return this;
    }
    setLevel(level) {
      this._storage.updateConfiguration({
        level
      });
      return this;
    }
    get(setting) {
      return this._storage.config[setting];
    }
    set(setting, value) {
      this._storage.updateConfiguration({
        [setting]: value
      });
    }
    settings() {
      if (console.table) {
        console.table(this._storage.config);
      } else {
        console.log(this._storage.config);
      }
    }
    assert(condition, message) {
      assert6(condition, message);
    }
    warn(message) {
      return this._getLogFunction(0, message, originalConsole.warn, arguments, ONCE);
    }
    error(message) {
      return this._getLogFunction(0, message, originalConsole.error, arguments);
    }
    deprecated(oldUsage, newUsage) {
      return this.warn("`".concat(oldUsage, "` is deprecated and will be removed in a later version. Use `").concat(newUsage, "` instead"));
    }
    removed(oldUsage, newUsage) {
      return this.error("`".concat(oldUsage, "` has been removed. Use `").concat(newUsage, "` instead"));
    }
    probe(logLevel, message) {
      return this._getLogFunction(logLevel, message, originalConsole.log, arguments, {
        time: true,
        once: true
      });
    }
    log(logLevel, message) {
      return this._getLogFunction(logLevel, message, originalConsole.debug, arguments);
    }
    info(logLevel, message) {
      return this._getLogFunction(logLevel, message, console.info, arguments);
    }
    once(logLevel, message) {
      for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
        args[_key - 2] = arguments[_key];
      }
      return this._getLogFunction(logLevel, message, originalConsole.debug || originalConsole.info, arguments, ONCE);
    }
    table(logLevel, table, columns) {
      if (table) {
        return this._getLogFunction(logLevel, table, console.table || noop, columns && [columns], {
          tag: getTableHeader(table)
        });
      }
      return noop;
    }
    image(_ref) {
      let {
        logLevel,
        priority,
        image,
        message = "",
        scale: scale5 = 1
      } = _ref;
      if (!this._shouldLog(logLevel || priority)) {
        return noop;
      }
      return isBrowser3 ? logImageInBrowser({
        image,
        message,
        scale: scale5
      }) : logImageInNode({
        image,
        message,
        scale: scale5
      });
    }
    time(logLevel, message) {
      return this._getLogFunction(logLevel, message, console.time ? console.time : console.info);
    }
    timeEnd(logLevel, message) {
      return this._getLogFunction(logLevel, message, console.timeEnd ? console.timeEnd : console.info);
    }
    timeStamp(logLevel, message) {
      return this._getLogFunction(logLevel, message, console.timeStamp || noop);
    }
    group(logLevel, message) {
      let opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
        collapsed: false
      };
      const options = normalizeArguments({
        logLevel,
        message,
        opts
      });
      const {
        collapsed
      } = opts;
      options.method = (collapsed ? console.groupCollapsed : console.group) || console.info;
      return this._getLogFunction(options);
    }
    groupCollapsed(logLevel, message) {
      let opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      return this.group(logLevel, message, Object.assign({}, opts, {
        collapsed: true
      }));
    }
    groupEnd(logLevel) {
      return this._getLogFunction(logLevel, "", console.groupEnd || noop);
    }
    withGroup(logLevel, message, func) {
      this.group(logLevel, message)();
      try {
        func();
      } finally {
        this.groupEnd(logLevel)();
      }
    }
    trace() {
      if (console.trace) {
        console.trace();
      }
    }
    _shouldLog(logLevel) {
      return this.isEnabled() && this.getLevel() >= normalizeLogLevel(logLevel);
    }
    _getLogFunction(logLevel, message, method, args, opts) {
      if (this._shouldLog(logLevel)) {
        opts = normalizeArguments({
          logLevel,
          message,
          args,
          opts
        });
        method = method || opts.method;
        assert6(method);
        opts.total = this.getTotal();
        opts.delta = this.getDelta();
        this._deltaTs = getHiResTimestamp2();
        const tag = opts.tag || opts.message;
        if (opts.once) {
          if (!cache[tag]) {
            cache[tag] = getHiResTimestamp2();
          } else {
            return noop;
          }
        }
        message = decorateMessage(this.id, opts.message, opts);
        return method.bind(console, message, ...opts.args);
      }
      return noop;
    }
  };
  _defineProperty(Log, "VERSION", VERSION6);
  function normalizeLogLevel(logLevel) {
    if (!logLevel) {
      return 0;
    }
    let resolvedLevel;
    switch (typeof logLevel) {
      case "number":
        resolvedLevel = logLevel;
        break;
      case "object":
        resolvedLevel = logLevel.logLevel || logLevel.priority || 0;
        break;
      default:
        return 0;
    }
    assert6(Number.isFinite(resolvedLevel) && resolvedLevel >= 0);
    return resolvedLevel;
  }
  function normalizeArguments(opts) {
    const {
      logLevel,
      message
    } = opts;
    opts.logLevel = normalizeLogLevel(logLevel);
    const args = opts.args ? Array.from(opts.args) : [];
    while (args.length && args.shift() !== message) {
    }
    switch (typeof logLevel) {
      case "string":
      case "function":
        if (message !== void 0) {
          args.unshift(message);
        }
        opts.message = logLevel;
        break;
      case "object":
        Object.assign(opts, logLevel);
        break;
      default:
    }
    if (typeof opts.message === "function") {
      opts.message = opts.message();
    }
    const messageType = typeof opts.message;
    assert6(messageType === "string" || messageType === "object");
    return Object.assign(opts, {
      args
    }, opts.opts);
  }
  function decorateMessage(id, message, opts) {
    if (typeof message === "string") {
      const time = opts.time ? leftPad(formatTime(opts.total)) : "";
      message = opts.time ? "".concat(id, ": ").concat(time, "  ").concat(message) : "".concat(id, ": ").concat(message);
      message = addColor(message, opts.color, opts.background);
    }
    return message;
  }
  function logImageInNode(_ref2) {
    let {
      image,
      message = "",
      scale: scale5 = 1
    } = _ref2;
    let asciify = null;
    try {
      asciify = module.require("asciify-image");
    } catch (error2) {
    }
    if (asciify) {
      return () => asciify(image, {
        fit: "box",
        width: "".concat(Math.round(80 * scale5), "%")
      }).then((data) => console.log(data));
    }
    return noop;
  }
  function logImageInBrowser(_ref3) {
    let {
      image,
      message = "",
      scale: scale5 = 1
    } = _ref3;
    if (typeof image === "string") {
      const img = new Image();
      img.onload = () => {
        const args = formatImage(img, message, scale5);
        console.log(...args);
      };
      img.src = image;
      return noop;
    }
    const element = image.nodeName || "";
    if (element.toLowerCase() === "img") {
      console.log(...formatImage(image, message, scale5));
      return noop;
    }
    if (element.toLowerCase() === "canvas") {
      const img = new Image();
      img.onload = () => console.log(...formatImage(img, message, scale5));
      img.src = image.toDataURL();
      return noop;
    }
    return noop;
  }
  function getTableHeader(table) {
    for (const key in table) {
      for (const title in table[key]) {
        return title || "untitled";
      }
    }
    return "empty";
  }

  // ../../node_modules/@probe.gl/log/dist/esm/index.js
  var esm_default2 = new Log({
    id: "@probe.gl/log"
  });

  // ../../node_modules/@luma.gl/gltools/dist/esm/utils/log.js
  var log = new Log({
    id: "luma.gl"
  });

  // ../../node_modules/@luma.gl/gltools/dist/esm/utils/assert.js
  function assert7(condition, message) {
    if (!condition) {
      throw new Error(message || "luma.gl: assertion failed.");
    }
  }

  // ../../node_modules/@luma.gl/gltools/dist/esm/utils/webgl-checks.js
  var ERR_CONTEXT = "Invalid WebGLRenderingContext";
  var ERR_WEBGL2 = "Requires WebGL2";
  function isWebGL(gl) {
    if (typeof WebGLRenderingContext !== "undefined" && gl instanceof WebGLRenderingContext) {
      return true;
    }
    if (typeof WebGL2RenderingContext !== "undefined" && gl instanceof WebGL2RenderingContext) {
      return true;
    }
    return Boolean(gl && Number.isFinite(gl._version));
  }
  function isWebGL2(gl) {
    if (typeof WebGL2RenderingContext !== "undefined" && gl instanceof WebGL2RenderingContext) {
      return true;
    }
    return Boolean(gl && gl._version === 2);
  }
  function getWebGL2Context(gl) {
    return isWebGL2(gl) ? gl : null;
  }
  function assertWebGLContext(gl) {
    assert7(isWebGL(gl), ERR_CONTEXT);
    return gl;
  }
  function assertWebGL2Context(gl) {
    assert7(isWebGL2(gl), ERR_WEBGL2);
    return gl;
  }

  // ../../node_modules/@luma.gl/gltools/dist/esm/polyfill/polyfill-vertex-array-object.js
  var glErrorShadow = {};
  function error(msg) {
    if (globalThis.console && globalThis.console.error) {
      globalThis.console.error(msg);
    }
  }
  function log3(msg) {
    if (globalThis.console && globalThis.console.log) {
      globalThis.console.log(msg);
    }
  }
  function synthesizeGLError(err, opt_msg) {
    glErrorShadow[err] = true;
    if (opt_msg !== void 0) {
      error(opt_msg);
    }
  }
  function wrapGLError(gl) {
    const f2 = gl.getError;
    gl.getError = function getError() {
      let err;
      do {
        err = f2.apply(gl);
        if (err !== 0) {
          glErrorShadow[err] = true;
        }
      } while (err !== 0);
      for (err in glErrorShadow) {
        if (glErrorShadow[err]) {
          delete glErrorShadow[err];
          return parseInt(err, 10);
        }
      }
      return 0;
    };
  }
  var WebGLVertexArrayObjectOES = function WebGLVertexArrayObjectOES2(ext) {
    const gl = ext.gl;
    this.ext = ext;
    this.isAlive = true;
    this.hasBeenBound = false;
    this.elementArrayBuffer = null;
    this.attribs = new Array(ext.maxVertexAttribs);
    for (let n2 = 0; n2 < this.attribs.length; n2++) {
      const attrib = new WebGLVertexArrayObjectOES2.VertexAttrib(gl);
      this.attribs[n2] = attrib;
    }
    this.maxAttrib = 0;
  };
  WebGLVertexArrayObjectOES.VertexAttrib = function VertexAttrib(gl) {
    this.enabled = false;
    this.buffer = null;
    this.size = 4;
    this.type = 5126;
    this.normalized = false;
    this.stride = 16;
    this.offset = 0;
    this.cached = "";
    this.recache();
  };
  WebGLVertexArrayObjectOES.VertexAttrib.prototype.recache = function recache() {
    this.cached = [this.size, this.type, this.normalized, this.stride, this.offset].join(":");
  };
  var OESVertexArrayObject = function OESVertexArrayObject2(gl) {
    const self2 = this;
    this.gl = gl;
    wrapGLError(gl);
    const original = this.original = {
      getParameter: gl.getParameter,
      enableVertexAttribArray: gl.enableVertexAttribArray,
      disableVertexAttribArray: gl.disableVertexAttribArray,
      bindBuffer: gl.bindBuffer,
      getVertexAttrib: gl.getVertexAttrib,
      vertexAttribPointer: gl.vertexAttribPointer
    };
    gl.getParameter = function getParameter(pname) {
      if (pname === self2.VERTEX_ARRAY_BINDING_OES) {
        if (self2.currentVertexArrayObject === self2.defaultVertexArrayObject) {
          return null;
        }
        return self2.currentVertexArrayObject;
      }
      return original.getParameter.apply(this, arguments);
    };
    gl.enableVertexAttribArray = function enableVertexAttribArray(index) {
      const vao = self2.currentVertexArrayObject;
      vao.maxAttrib = Math.max(vao.maxAttrib, index);
      const attrib = vao.attribs[index];
      attrib.enabled = true;
      return original.enableVertexAttribArray.apply(this, arguments);
    };
    gl.disableVertexAttribArray = function disableVertexAttribArray(index) {
      const vao = self2.currentVertexArrayObject;
      vao.maxAttrib = Math.max(vao.maxAttrib, index);
      const attrib = vao.attribs[index];
      attrib.enabled = false;
      return original.disableVertexAttribArray.apply(this, arguments);
    };
    gl.bindBuffer = function bindBuffer(target, buffer) {
      switch (target) {
        case 34962:
          self2.currentArrayBuffer = buffer;
          break;
        case 34963:
          self2.currentVertexArrayObject.elementArrayBuffer = buffer;
          break;
        default:
      }
      return original.bindBuffer.apply(this, arguments);
    };
    gl.getVertexAttrib = function getVertexAttrib(index, pname) {
      const vao = self2.currentVertexArrayObject;
      const attrib = vao.attribs[index];
      switch (pname) {
        case 34975:
          return attrib.buffer;
        case 34338:
          return attrib.enabled;
        case 34339:
          return attrib.size;
        case 34340:
          return attrib.stride;
        case 34341:
          return attrib.type;
        case 34922:
          return attrib.normalized;
        default:
          return original.getVertexAttrib.apply(this, arguments);
      }
    };
    gl.vertexAttribPointer = function vertexAttribPointer(indx, size, type, normalized, stride, offset) {
      const vao = self2.currentVertexArrayObject;
      vao.maxAttrib = Math.max(vao.maxAttrib, indx);
      const attrib = vao.attribs[indx];
      attrib.buffer = self2.currentArrayBuffer;
      attrib.size = size;
      attrib.type = type;
      attrib.normalized = normalized;
      attrib.stride = stride;
      attrib.offset = offset;
      attrib.recache();
      return original.vertexAttribPointer.apply(this, arguments);
    };
    if (gl.instrumentExtension) {
      gl.instrumentExtension(this, "OES_vertex_array_object");
    }
    if (gl.canvas) {
      gl.canvas.addEventListener("webglcontextrestored", () => {
        log3("OESVertexArrayObject emulation library context restored");
        self2.reset_();
      }, true);
    }
    this.reset_();
  };
  OESVertexArrayObject.prototype.VERTEX_ARRAY_BINDING_OES = 34229;
  OESVertexArrayObject.prototype.reset_ = function reset_() {
    const contextWasLost = this.vertexArrayObjects !== void 0;
    if (contextWasLost) {
      for (let ii = 0; ii < this.vertexArrayObjects.length; ++ii) {
        this.vertexArrayObjects.isAlive = false;
      }
    }
    const gl = this.gl;
    this.maxVertexAttribs = gl.getParameter(34921);
    this.defaultVertexArrayObject = new WebGLVertexArrayObjectOES(this);
    this.currentVertexArrayObject = null;
    this.currentArrayBuffer = null;
    this.vertexArrayObjects = [this.defaultVertexArrayObject];
    this.bindVertexArrayOES(null);
  };
  OESVertexArrayObject.prototype.createVertexArrayOES = function createVertexArrayOES() {
    const arrayObject = new WebGLVertexArrayObjectOES(this);
    this.vertexArrayObjects.push(arrayObject);
    return arrayObject;
  };
  OESVertexArrayObject.prototype.deleteVertexArrayOES = function deleteVertexArrayOES(arrayObject) {
    arrayObject.isAlive = false;
    this.vertexArrayObjects.splice(this.vertexArrayObjects.indexOf(arrayObject), 1);
    if (this.currentVertexArrayObject === arrayObject) {
      this.bindVertexArrayOES(null);
    }
  };
  OESVertexArrayObject.prototype.isVertexArrayOES = function isVertexArrayOES(arrayObject) {
    if (arrayObject && arrayObject instanceof WebGLVertexArrayObjectOES) {
      if (arrayObject.hasBeenBound && arrayObject.ext === this) {
        return true;
      }
    }
    return false;
  };
  OESVertexArrayObject.prototype.bindVertexArrayOES = function bindVertexArrayOES(arrayObject) {
    const gl = this.gl;
    if (arrayObject && !arrayObject.isAlive) {
      synthesizeGLError(1282, "bindVertexArrayOES: attempt to bind deleted arrayObject");
      return;
    }
    const original = this.original;
    const oldVAO = this.currentVertexArrayObject;
    this.currentVertexArrayObject = arrayObject || this.defaultVertexArrayObject;
    this.currentVertexArrayObject.hasBeenBound = true;
    const newVAO = this.currentVertexArrayObject;
    if (oldVAO === newVAO) {
      return;
    }
    if (!oldVAO || newVAO.elementArrayBuffer !== oldVAO.elementArrayBuffer) {
      original.bindBuffer.call(gl, 34963, newVAO.elementArrayBuffer);
    }
    let currentBinding = this.currentArrayBuffer;
    const maxAttrib = Math.max(oldVAO ? oldVAO.maxAttrib : 0, newVAO.maxAttrib);
    for (let n2 = 0; n2 <= maxAttrib; n2++) {
      const attrib = newVAO.attribs[n2];
      const oldAttrib = oldVAO ? oldVAO.attribs[n2] : null;
      if (!oldVAO || attrib.enabled !== oldAttrib.enabled) {
        if (attrib.enabled) {
          original.enableVertexAttribArray.call(gl, n2);
        } else {
          original.disableVertexAttribArray.call(gl, n2);
        }
      }
      if (attrib.enabled) {
        let bufferChanged = false;
        if (!oldVAO || attrib.buffer !== oldAttrib.buffer) {
          if (currentBinding !== attrib.buffer) {
            original.bindBuffer.call(gl, 34962, attrib.buffer);
            currentBinding = attrib.buffer;
          }
          bufferChanged = true;
        }
        if (bufferChanged || attrib.cached !== oldAttrib.cached) {
          original.vertexAttribPointer.call(gl, n2, attrib.size, attrib.type, attrib.normalized, attrib.stride, attrib.offset);
        }
      }
    }
    if (this.currentArrayBuffer !== currentBinding) {
      original.bindBuffer.call(gl, 34962, this.currentArrayBuffer);
    }
  };
  function polyfillVertexArrayObject(gl) {
    if (typeof gl.createVertexArray === "function") {
      return;
    }
    const original_getSupportedExtensions = gl.getSupportedExtensions;
    gl.getSupportedExtensions = function getSupportedExtensions() {
      const list = original_getSupportedExtensions.call(this) || [];
      if (list.indexOf("OES_vertex_array_object") < 0) {
        list.push("OES_vertex_array_object");
      }
      return list;
    };
    const original_getExtension = gl.getExtension;
    gl.getExtension = function getExtension(name10) {
      const ext = original_getExtension.call(this, name10);
      if (ext) {
        return ext;
      }
      if (name10 !== "OES_vertex_array_object") {
        return null;
      }
      if (!gl.__OESVertexArrayObject) {
        this.__OESVertexArrayObject = new OESVertexArrayObject(this);
      }
      return this.__OESVertexArrayObject;
    };
  }

  // ../../node_modules/@luma.gl/gltools/dist/esm/polyfill/get-parameter-polyfill.js
  var OES_element_index = "OES_element_index";
  var WEBGL_draw_buffers = "WEBGL_draw_buffers";
  var EXT_disjoint_timer_query = "EXT_disjoint_timer_query";
  var EXT_disjoint_timer_query_webgl2 = "EXT_disjoint_timer_query_webgl2";
  var EXT_texture_filter_anisotropic = "EXT_texture_filter_anisotropic";
  var WEBGL_debug_renderer_info = "WEBGL_debug_renderer_info";
  var GL_FRAGMENT_SHADER_DERIVATIVE_HINT = 35723;
  var GL_DONT_CARE = 4352;
  var GL_GPU_DISJOINT_EXT = 36795;
  var GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT = 34047;
  var GL_UNMASKED_VENDOR_WEBGL = 37445;
  var GL_UNMASKED_RENDERER_WEBGL = 37446;
  var getWebGL2ValueOrZero = (gl) => !isWebGL2(gl) ? 0 : void 0;
  var WEBGL_PARAMETERS = {
    [3074]: (gl) => !isWebGL2(gl) ? 36064 : void 0,
    [GL_FRAGMENT_SHADER_DERIVATIVE_HINT]: (gl) => !isWebGL2(gl) ? GL_DONT_CARE : void 0,
    [35977]: getWebGL2ValueOrZero,
    [32937]: getWebGL2ValueOrZero,
    [GL_GPU_DISJOINT_EXT]: (gl, getParameter) => {
      const ext = isWebGL2(gl) ? gl.getExtension(EXT_disjoint_timer_query_webgl2) : gl.getExtension(EXT_disjoint_timer_query);
      return ext && ext.GPU_DISJOINT_EXT ? getParameter(ext.GPU_DISJOINT_EXT) : 0;
    },
    [GL_UNMASKED_VENDOR_WEBGL]: (gl, getParameter) => {
      const ext = gl.getExtension(WEBGL_debug_renderer_info);
      return getParameter(ext && ext.UNMASKED_VENDOR_WEBGL || 7936);
    },
    [GL_UNMASKED_RENDERER_WEBGL]: (gl, getParameter) => {
      const ext = gl.getExtension(WEBGL_debug_renderer_info);
      return getParameter(ext && ext.UNMASKED_RENDERER_WEBGL || 7937);
    },
    [GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT]: (gl, getParameter) => {
      const ext = gl.luma.extensions[EXT_texture_filter_anisotropic];
      return ext ? getParameter(ext.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 1;
    },
    [32883]: getWebGL2ValueOrZero,
    [35071]: getWebGL2ValueOrZero,
    [37447]: getWebGL2ValueOrZero,
    [36063]: (gl, getParameter) => {
      if (!isWebGL2(gl)) {
        const ext = gl.getExtension(WEBGL_draw_buffers);
        return ext ? getParameter(ext.MAX_COLOR_ATTACHMENTS_WEBGL) : 0;
      }
      return void 0;
    },
    [35379]: getWebGL2ValueOrZero,
    [35374]: getWebGL2ValueOrZero,
    [35377]: getWebGL2ValueOrZero,
    [34852]: (gl) => {
      if (!isWebGL2(gl)) {
        const ext = gl.getExtension(WEBGL_draw_buffers);
        return ext ? ext.MAX_DRAW_BUFFERS_WEBGL : 0;
      }
      return void 0;
    },
    [36203]: (gl) => gl.getExtension(OES_element_index) ? 2147483647 : 65535,
    [33001]: (gl) => gl.getExtension(OES_element_index) ? 16777216 : 65535,
    [33e3]: (gl) => 16777216,
    [37157]: getWebGL2ValueOrZero,
    [35373]: getWebGL2ValueOrZero,
    [35657]: getWebGL2ValueOrZero,
    [36183]: getWebGL2ValueOrZero,
    [37137]: getWebGL2ValueOrZero,
    [34045]: getWebGL2ValueOrZero,
    [35978]: getWebGL2ValueOrZero,
    [35979]: getWebGL2ValueOrZero,
    [35968]: getWebGL2ValueOrZero,
    [35376]: getWebGL2ValueOrZero,
    [35375]: getWebGL2ValueOrZero,
    [35659]: getWebGL2ValueOrZero,
    [37154]: getWebGL2ValueOrZero,
    [35371]: getWebGL2ValueOrZero,
    [35658]: getWebGL2ValueOrZero,
    [35076]: getWebGL2ValueOrZero,
    [35077]: getWebGL2ValueOrZero,
    [35380]: getWebGL2ValueOrZero
  };
  function getParameterPolyfill(gl, originalGetParameter, pname) {
    const limit = WEBGL_PARAMETERS[pname];
    const value = typeof limit === "function" ? limit(gl, originalGetParameter, pname) : limit;
    const result = value !== void 0 ? value : originalGetParameter(pname);
    return result;
  }

  // ../../node_modules/@luma.gl/gltools/dist/esm/polyfill/polyfill-table.js
  var OES_vertex_array_object = "OES_vertex_array_object";
  var ANGLE_instanced_arrays = "ANGLE_instanced_arrays";
  var WEBGL_draw_buffers2 = "WEBGL_draw_buffers";
  var EXT_disjoint_timer_query2 = "EXT_disjoint_timer_query";
  var EXT_texture_filter_anisotropic2 = "EXT_texture_filter_anisotropic";
  var ERR_VAO_NOT_SUPPORTED = "VertexArray requires WebGL2 or OES_vertex_array_object extension";
  function getExtensionData(gl, extension) {
    return {
      webgl2: isWebGL2(gl),
      ext: gl.getExtension(extension)
    };
  }
  var WEBGL2_CONTEXT_POLYFILLS = {
    [OES_vertex_array_object]: {
      meta: {
        suffix: "OES"
      },
      createVertexArray: () => {
        assert7(false, ERR_VAO_NOT_SUPPORTED);
      },
      deleteVertexArray: () => {
      },
      bindVertexArray: () => {
      },
      isVertexArray: () => false
    },
    [ANGLE_instanced_arrays]: {
      meta: {
        suffix: "ANGLE"
      },
      vertexAttribDivisor(location, divisor) {
        assert7(divisor === 0, "WebGL instanced rendering not supported");
      },
      drawElementsInstanced: () => {
      },
      drawArraysInstanced: () => {
      }
    },
    [WEBGL_draw_buffers2]: {
      meta: {
        suffix: "WEBGL"
      },
      drawBuffers: () => {
        assert7(false);
      }
    },
    [EXT_disjoint_timer_query2]: {
      meta: {
        suffix: "EXT"
      },
      createQuery: () => {
        assert7(false);
      },
      deleteQuery: () => {
        assert7(false);
      },
      beginQuery: () => {
        assert7(false);
      },
      endQuery: () => {
      },
      getQuery(handle, pname) {
        return this.getQueryObject(handle, pname);
      },
      getQueryParameter(handle, pname) {
        return this.getQueryObject(handle, pname);
      },
      getQueryObject: () => {
      }
    }
  };
  var WEBGL2_CONTEXT_OVERRIDES = {
    readBuffer: (gl, originalFunc, attachment) => {
      if (isWebGL2(gl)) {
        originalFunc(attachment);
      } else {
      }
    },
    getVertexAttrib: (gl, originalFunc, location, pname) => {
      const {
        webgl2,
        ext
      } = getExtensionData(gl, ANGLE_instanced_arrays);
      let result;
      switch (pname) {
        case 35069:
          result = !webgl2 ? false : void 0;
          break;
        case 35070:
          result = !webgl2 && !ext ? 0 : void 0;
          break;
        default:
      }
      return result !== void 0 ? result : originalFunc(location, pname);
    },
    getProgramParameter: (gl, originalFunc, program, pname) => {
      if (!isWebGL2(gl)) {
        switch (pname) {
          case 35967:
            return 35981;
          case 35971:
            return 0;
          case 35382:
            return 0;
          default:
        }
      }
      return originalFunc(program, pname);
    },
    getInternalformatParameter: (gl, originalFunc, target, format, pname) => {
      if (!isWebGL2(gl)) {
        switch (pname) {
          case 32937:
            return new Int32Array([0]);
          default:
        }
      }
      return gl.getInternalformatParameter(target, format, pname);
    },
    getTexParameter(gl, originalFunc, target, pname) {
      switch (pname) {
        case 34046:
          const {
            extensions
          } = gl.luma;
          const ext = extensions[EXT_texture_filter_anisotropic2];
          pname = ext && ext.TEXTURE_MAX_ANISOTROPY_EXT || 34046;
          break;
        default:
      }
      return originalFunc(target, pname);
    },
    getParameter: getParameterPolyfill,
    hint(gl, originalFunc, pname, value) {
      return originalFunc(pname, value);
    }
  };

  // ../../node_modules/@luma.gl/gltools/dist/esm/polyfill/polyfill-context.js
  function polyfillContext(gl) {
    gl.luma = gl.luma || {};
    const {
      luma
    } = gl;
    if (!luma.polyfilled) {
      polyfillVertexArrayObject(gl);
      initializeExtensions(gl);
      installPolyfills(gl, WEBGL2_CONTEXT_POLYFILLS);
      installOverrides(gl, {
        target: luma,
        target2: gl
      });
      luma.polyfilled = true;
    }
    return gl;
  }
  globalThis.polyfillContext = polyfillContext;
  function initializeExtensions(gl) {
    gl.luma.extensions = {};
    const EXTENSIONS3 = gl.getSupportedExtensions() || [];
    for (const extension of EXTENSIONS3) {
      gl.luma[extension] = gl.getExtension(extension);
    }
  }
  function installOverrides(gl, _ref) {
    let {
      target,
      target2
    } = _ref;
    Object.keys(WEBGL2_CONTEXT_OVERRIDES).forEach((key) => {
      if (typeof WEBGL2_CONTEXT_OVERRIDES[key] === "function") {
        const originalFunc = gl[key] ? gl[key].bind(gl) : () => {
        };
        const polyfill = WEBGL2_CONTEXT_OVERRIDES[key].bind(null, gl, originalFunc);
        target[key] = polyfill;
        target2[key] = polyfill;
      }
    });
  }
  function installPolyfills(gl, polyfills) {
    for (const extension of Object.getOwnPropertyNames(polyfills)) {
      if (extension !== "overrides") {
        polyfillExtension(gl, {
          extension,
          target: gl.luma,
          target2: gl
        });
      }
    }
  }
  function polyfillExtension(gl, _ref2) {
    let {
      extension,
      target,
      target2
    } = _ref2;
    const defaults = WEBGL2_CONTEXT_POLYFILLS[extension];
    assert7(defaults);
    const {
      meta = {}
    } = defaults;
    const {
      suffix = ""
    } = meta;
    const ext = gl.getExtension(extension);
    for (const key of Object.keys(defaults)) {
      const extKey = "".concat(key).concat(suffix);
      let polyfill = null;
      if (key === "meta") {
      } else if (typeof gl[key] === "function") {
      } else if (ext && typeof ext[extKey] === "function") {
        polyfill = function() {
          return ext[extKey](...arguments);
        };
      } else if (typeof defaults[key] === "function") {
        polyfill = defaults[key].bind(target);
      }
      if (polyfill) {
        target[key] = polyfill;
        target2[key] = polyfill;
      }
    }
  }

  // ../../node_modules/@luma.gl/gltools/dist/esm/state-tracker/webgl-parameter-tables.js
  var GL_PARAMETER_DEFAULTS = {
    [3042]: false,
    [32773]: new Float32Array([0, 0, 0, 0]),
    [32777]: 32774,
    [34877]: 32774,
    [32969]: 1,
    [32968]: 0,
    [32971]: 1,
    [32970]: 0,
    [3106]: new Float32Array([0, 0, 0, 0]),
    [3107]: [true, true, true, true],
    [2884]: false,
    [2885]: 1029,
    [2929]: false,
    [2931]: 1,
    [2932]: 513,
    [2928]: new Float32Array([0, 1]),
    [2930]: true,
    [3024]: true,
    [36006]: null,
    [2886]: 2305,
    [33170]: 4352,
    [2849]: 1,
    [32823]: false,
    [32824]: 0,
    [10752]: 0,
    [32938]: 1,
    [32939]: false,
    [3089]: false,
    [3088]: new Int32Array([0, 0, 1024, 1024]),
    [2960]: false,
    [2961]: 0,
    [2968]: 4294967295,
    [36005]: 4294967295,
    [2962]: 519,
    [2967]: 0,
    [2963]: 4294967295,
    [34816]: 519,
    [36003]: 0,
    [36004]: 4294967295,
    [2964]: 7680,
    [2965]: 7680,
    [2966]: 7680,
    [34817]: 7680,
    [34818]: 7680,
    [34819]: 7680,
    [2978]: [0, 0, 1024, 1024],
    [3333]: 4,
    [3317]: 4,
    [37440]: false,
    [37441]: false,
    [37443]: 37444,
    [35723]: 4352,
    [36010]: null,
    [35977]: false,
    [3330]: 0,
    [3332]: 0,
    [3331]: 0,
    [3314]: 0,
    [32878]: 0,
    [3316]: 0,
    [3315]: 0,
    [32877]: 0
  };
  var enable = (gl, value, key) => value ? gl.enable(key) : gl.disable(key);
  var hint = (gl, value, key) => gl.hint(key, value);
  var pixelStorei = (gl, value, key) => gl.pixelStorei(key, value);
  var drawFramebuffer = (gl, value) => {
    const target = isWebGL2(gl) ? 36009 : 36160;
    return gl.bindFramebuffer(target, value);
  };
  var readFramebuffer = (gl, value) => {
    return gl.bindFramebuffer(36008, value);
  };
  function isArray2(array) {
    return Array.isArray(array) || ArrayBuffer.isView(array);
  }
  var GL_PARAMETER_SETTERS = {
    [3042]: enable,
    [32773]: (gl, value) => gl.blendColor(...value),
    [32777]: "blendEquation",
    [34877]: "blendEquation",
    [32969]: "blendFunc",
    [32968]: "blendFunc",
    [32971]: "blendFunc",
    [32970]: "blendFunc",
    [3106]: (gl, value) => gl.clearColor(...value),
    [3107]: (gl, value) => gl.colorMask(...value),
    [2884]: enable,
    [2885]: (gl, value) => gl.cullFace(value),
    [2929]: enable,
    [2931]: (gl, value) => gl.clearDepth(value),
    [2932]: (gl, value) => gl.depthFunc(value),
    [2928]: (gl, value) => gl.depthRange(...value),
    [2930]: (gl, value) => gl.depthMask(value),
    [3024]: enable,
    [35723]: hint,
    [36006]: drawFramebuffer,
    [2886]: (gl, value) => gl.frontFace(value),
    [33170]: hint,
    [2849]: (gl, value) => gl.lineWidth(value),
    [32823]: enable,
    [32824]: "polygonOffset",
    [10752]: "polygonOffset",
    [35977]: enable,
    [32938]: "sampleCoverage",
    [32939]: "sampleCoverage",
    [3089]: enable,
    [3088]: (gl, value) => gl.scissor(...value),
    [2960]: enable,
    [2961]: (gl, value) => gl.clearStencil(value),
    [2968]: (gl, value) => gl.stencilMaskSeparate(1028, value),
    [36005]: (gl, value) => gl.stencilMaskSeparate(1029, value),
    [2962]: "stencilFuncFront",
    [2967]: "stencilFuncFront",
    [2963]: "stencilFuncFront",
    [34816]: "stencilFuncBack",
    [36003]: "stencilFuncBack",
    [36004]: "stencilFuncBack",
    [2964]: "stencilOpFront",
    [2965]: "stencilOpFront",
    [2966]: "stencilOpFront",
    [34817]: "stencilOpBack",
    [34818]: "stencilOpBack",
    [34819]: "stencilOpBack",
    [2978]: (gl, value) => gl.viewport(...value),
    [3333]: pixelStorei,
    [3317]: pixelStorei,
    [37440]: pixelStorei,
    [37441]: pixelStorei,
    [37443]: pixelStorei,
    [3330]: pixelStorei,
    [3332]: pixelStorei,
    [3331]: pixelStorei,
    [36010]: readFramebuffer,
    [3314]: pixelStorei,
    [32878]: pixelStorei,
    [3316]: pixelStorei,
    [3315]: pixelStorei,
    [32877]: pixelStorei,
    framebuffer: (gl, framebuffer) => {
      const handle = framebuffer && "handle" in framebuffer ? framebuffer.handle : framebuffer;
      return gl.bindFramebuffer(36160, handle);
    },
    blend: (gl, value) => value ? gl.enable(3042) : gl.disable(3042),
    blendColor: (gl, value) => gl.blendColor(...value),
    blendEquation: (gl, args) => {
      args = isArray2(args) ? args : [args, args];
      gl.blendEquationSeparate(...args);
    },
    blendFunc: (gl, args) => {
      args = isArray2(args) && args.length === 2 ? [...args, ...args] : args;
      gl.blendFuncSeparate(...args);
    },
    clearColor: (gl, value) => gl.clearColor(...value),
    clearDepth: (gl, value) => gl.clearDepth(value),
    clearStencil: (gl, value) => gl.clearStencil(value),
    colorMask: (gl, value) => gl.colorMask(...value),
    cull: (gl, value) => value ? gl.enable(2884) : gl.disable(2884),
    cullFace: (gl, value) => gl.cullFace(value),
    depthTest: (gl, value) => value ? gl.enable(2929) : gl.disable(2929),
    depthFunc: (gl, value) => gl.depthFunc(value),
    depthMask: (gl, value) => gl.depthMask(value),
    depthRange: (gl, value) => gl.depthRange(...value),
    dither: (gl, value) => value ? gl.enable(3024) : gl.disable(3024),
    derivativeHint: (gl, value) => {
      gl.hint(35723, value);
    },
    frontFace: (gl, value) => gl.frontFace(value),
    mipmapHint: (gl, value) => gl.hint(33170, value),
    lineWidth: (gl, value) => gl.lineWidth(value),
    polygonOffsetFill: (gl, value) => value ? gl.enable(32823) : gl.disable(32823),
    polygonOffset: (gl, value) => gl.polygonOffset(...value),
    sampleCoverage: (gl, value) => gl.sampleCoverage(...value),
    scissorTest: (gl, value) => value ? gl.enable(3089) : gl.disable(3089),
    scissor: (gl, value) => gl.scissor(...value),
    stencilTest: (gl, value) => value ? gl.enable(2960) : gl.disable(2960),
    stencilMask: (gl, value) => {
      value = isArray2(value) ? value : [value, value];
      const [mask, backMask] = value;
      gl.stencilMaskSeparate(1028, mask);
      gl.stencilMaskSeparate(1029, backMask);
    },
    stencilFunc: (gl, args) => {
      args = isArray2(args) && args.length === 3 ? [...args, ...args] : args;
      const [func, ref, mask, backFunc, backRef, backMask] = args;
      gl.stencilFuncSeparate(1028, func, ref, mask);
      gl.stencilFuncSeparate(1029, backFunc, backRef, backMask);
    },
    stencilOp: (gl, args) => {
      args = isArray2(args) && args.length === 3 ? [...args, ...args] : args;
      const [sfail, dpfail, dppass, backSfail, backDpfail, backDppass] = args;
      gl.stencilOpSeparate(1028, sfail, dpfail, dppass);
      gl.stencilOpSeparate(1029, backSfail, backDpfail, backDppass);
    },
    viewport: (gl, value) => gl.viewport(...value)
  };
  function getValue(glEnum, values, cache2) {
    return values[glEnum] !== void 0 ? values[glEnum] : cache2[glEnum];
  }
  var GL_COMPOSITE_PARAMETER_SETTERS = {
    blendEquation: (gl, values, cache2) => gl.blendEquationSeparate(getValue(32777, values, cache2), getValue(34877, values, cache2)),
    blendFunc: (gl, values, cache2) => gl.blendFuncSeparate(getValue(32969, values, cache2), getValue(32968, values, cache2), getValue(32971, values, cache2), getValue(32970, values, cache2)),
    polygonOffset: (gl, values, cache2) => gl.polygonOffset(getValue(32824, values, cache2), getValue(10752, values, cache2)),
    sampleCoverage: (gl, values, cache2) => gl.sampleCoverage(getValue(32938, values, cache2), getValue(32939, values, cache2)),
    stencilFuncFront: (gl, values, cache2) => gl.stencilFuncSeparate(1028, getValue(2962, values, cache2), getValue(2967, values, cache2), getValue(2963, values, cache2)),
    stencilFuncBack: (gl, values, cache2) => gl.stencilFuncSeparate(1029, getValue(34816, values, cache2), getValue(36003, values, cache2), getValue(36004, values, cache2)),
    stencilOpFront: (gl, values, cache2) => gl.stencilOpSeparate(1028, getValue(2964, values, cache2), getValue(2965, values, cache2), getValue(2966, values, cache2)),
    stencilOpBack: (gl, values, cache2) => gl.stencilOpSeparate(1029, getValue(34817, values, cache2), getValue(34818, values, cache2), getValue(34819, values, cache2))
  };
  var GL_HOOKED_SETTERS = {
    enable: (update, capability) => update({
      [capability]: true
    }),
    disable: (update, capability) => update({
      [capability]: false
    }),
    pixelStorei: (update, pname, value) => update({
      [pname]: value
    }),
    hint: (update, pname, hint2) => update({
      [pname]: hint2
    }),
    bindFramebuffer: (update, target, framebuffer) => {
      switch (target) {
        case 36160:
          return update({
            [36006]: framebuffer,
            [36010]: framebuffer
          });
        case 36009:
          return update({
            [36006]: framebuffer
          });
        case 36008:
          return update({
            [36010]: framebuffer
          });
        default:
          return null;
      }
    },
    blendColor: (update, r2, g, b, a2) => update({
      [32773]: new Float32Array([r2, g, b, a2])
    }),
    blendEquation: (update, mode) => update({
      [32777]: mode,
      [34877]: mode
    }),
    blendEquationSeparate: (update, modeRGB, modeAlpha) => update({
      [32777]: modeRGB,
      [34877]: modeAlpha
    }),
    blendFunc: (update, src, dst) => update({
      [32969]: src,
      [32968]: dst,
      [32971]: src,
      [32970]: dst
    }),
    blendFuncSeparate: (update, srcRGB, dstRGB, srcAlpha, dstAlpha) => update({
      [32969]: srcRGB,
      [32968]: dstRGB,
      [32971]: srcAlpha,
      [32970]: dstAlpha
    }),
    clearColor: (update, r2, g, b, a2) => update({
      [3106]: new Float32Array([r2, g, b, a2])
    }),
    clearDepth: (update, depth) => update({
      [2931]: depth
    }),
    clearStencil: (update, s2) => update({
      [2961]: s2
    }),
    colorMask: (update, r2, g, b, a2) => update({
      [3107]: [r2, g, b, a2]
    }),
    cullFace: (update, mode) => update({
      [2885]: mode
    }),
    depthFunc: (update, func) => update({
      [2932]: func
    }),
    depthRange: (update, zNear, zFar) => update({
      [2928]: new Float32Array([zNear, zFar])
    }),
    depthMask: (update, mask) => update({
      [2930]: mask
    }),
    frontFace: (update, face) => update({
      [2886]: face
    }),
    lineWidth: (update, width) => update({
      [2849]: width
    }),
    polygonOffset: (update, factor, units) => update({
      [32824]: factor,
      [10752]: units
    }),
    sampleCoverage: (update, value, invert4) => update({
      [32938]: value,
      [32939]: invert4
    }),
    scissor: (update, x2, y2, width, height) => update({
      [3088]: new Int32Array([x2, y2, width, height])
    }),
    stencilMask: (update, mask) => update({
      [2968]: mask,
      [36005]: mask
    }),
    stencilMaskSeparate: (update, face, mask) => update({
      [face === 1028 ? 2968 : 36005]: mask
    }),
    stencilFunc: (update, func, ref, mask) => update({
      [2962]: func,
      [2967]: ref,
      [2963]: mask,
      [34816]: func,
      [36003]: ref,
      [36004]: mask
    }),
    stencilFuncSeparate: (update, face, func, ref, mask) => update({
      [face === 1028 ? 2962 : 34816]: func,
      [face === 1028 ? 2967 : 36003]: ref,
      [face === 1028 ? 2963 : 36004]: mask
    }),
    stencilOp: (update, fail, zfail, zpass) => update({
      [2964]: fail,
      [2965]: zfail,
      [2966]: zpass,
      [34817]: fail,
      [34818]: zfail,
      [34819]: zpass
    }),
    stencilOpSeparate: (update, face, fail, zfail, zpass) => update({
      [face === 1028 ? 2964 : 34817]: fail,
      [face === 1028 ? 2965 : 34818]: zfail,
      [face === 1028 ? 2966 : 34819]: zpass
    }),
    viewport: (update, x2, y2, width, height) => update({
      [2978]: [x2, y2, width, height]
    })
  };
  var isEnabled = (gl, key) => gl.isEnabled(key);
  var GL_PARAMETER_GETTERS = {
    [3042]: isEnabled,
    [2884]: isEnabled,
    [2929]: isEnabled,
    [3024]: isEnabled,
    [32823]: isEnabled,
    [32926]: isEnabled,
    [32928]: isEnabled,
    [3089]: isEnabled,
    [2960]: isEnabled,
    [35977]: isEnabled
  };

  // ../../node_modules/@luma.gl/gltools/dist/esm/utils/utils.js
  function isObjectEmpty(object) {
    for (const key in object) {
      return false;
    }
    return true;
  }
  function deepArrayEqual(x2, y2) {
    if (x2 === y2) {
      return true;
    }
    const isArrayX = Array.isArray(x2) || ArrayBuffer.isView(x2);
    const isArrayY = Array.isArray(y2) || ArrayBuffer.isView(y2);
    if (isArrayX && isArrayY && x2.length === y2.length) {
      for (let i3 = 0; i3 < x2.length; ++i3) {
        if (x2[i3] !== y2[i3]) {
          return false;
        }
      }
      return true;
    }
    return false;
  }

  // ../../node_modules/@luma.gl/gltools/dist/esm/state-tracker/track-context-state.js
  function installGetterOverride(gl, functionName) {
    const originalGetterFunc = gl[functionName].bind(gl);
    gl[functionName] = function get() {
      const pname = arguments.length <= 0 ? void 0 : arguments[0];
      if (!(pname in gl.state.cache)) {
        return originalGetterFunc(...arguments);
      }
      return gl.state.enable ? gl.state.cache[pname] : originalGetterFunc(...arguments);
    };
    Object.defineProperty(gl[functionName], "name", {
      value: "".concat(functionName, "-from-cache"),
      configurable: false
    });
  }
  function installSetterSpy(gl, functionName, setter) {
    const originalSetterFunc = gl[functionName].bind(gl);
    gl[functionName] = function set2() {
      for (var _len = arguments.length, params = new Array(_len), _key = 0; _key < _len; _key++) {
        params[_key] = arguments[_key];
      }
      const {
        valueChanged,
        oldValue
      } = setter(gl.state._updateCache, ...params);
      if (valueChanged) {
        originalSetterFunc(...params);
      }
      return oldValue;
    };
    Object.defineProperty(gl[functionName], "name", {
      value: "".concat(functionName, "-to-cache"),
      configurable: false
    });
  }
  function installProgramSpy(gl) {
    const originalUseProgram = gl.useProgram.bind(gl);
    gl.useProgram = function useProgramLuma(handle) {
      if (gl.state.program !== handle) {
        originalUseProgram(handle);
        gl.state.program = handle;
      }
    };
  }
  var GLState = class {
    constructor(gl) {
      let {
        copyState = false,
        log: log7 = () => {
        }
      } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      this.gl = gl;
      this.program = null;
      this.stateStack = [];
      this.enable = true;
      this.cache = copyState ? getParameters(gl) : Object.assign({}, GL_PARAMETER_DEFAULTS);
      this.log = log7;
      this._updateCache = this._updateCache.bind(this);
      Object.seal(this);
    }
    push() {
      let values = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      this.stateStack.push({});
    }
    pop() {
      assert7(this.stateStack.length > 0);
      const oldValues = this.stateStack[this.stateStack.length - 1];
      setParameters(this.gl, oldValues);
      this.stateStack.pop();
    }
    _updateCache(values) {
      let valueChanged = false;
      let oldValue;
      const oldValues = this.stateStack.length > 0 && this.stateStack[this.stateStack.length - 1];
      for (const key in values) {
        assert7(key !== void 0);
        const value = values[key];
        const cached = this.cache[key];
        if (!deepArrayEqual(value, cached)) {
          valueChanged = true;
          oldValue = cached;
          if (oldValues && !(key in oldValues)) {
            oldValues[key] = cached;
          }
          this.cache[key] = value;
        }
      }
      return {
        valueChanged,
        oldValue
      };
    }
  };
  function trackContextState(gl) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const {
      enable: enable2 = true,
      copyState
    } = options;
    assert7(copyState !== void 0);
    if (!gl.state) {
      const {
        polyfillContext: polyfillContext2
      } = globalThis;
      if (polyfillContext2) {
        polyfillContext2(gl);
      }
      gl.state = new GLState(gl, {
        copyState
      });
      installProgramSpy(gl);
      for (const key in GL_HOOKED_SETTERS) {
        const setter = GL_HOOKED_SETTERS[key];
        installSetterSpy(gl, key, setter);
      }
      installGetterOverride(gl, "getParameter");
      installGetterOverride(gl, "isEnabled");
    }
    gl.state.enable = enable2;
    return gl;
  }
  function pushContextState(gl) {
    if (!gl.state) {
      trackContextState(gl, {
        copyState: false
      });
    }
    gl.state.push();
  }
  function popContextState(gl) {
    assert7(gl.state);
    gl.state.pop();
  }

  // ../../node_modules/@luma.gl/gltools/dist/esm/state-tracker/unified-parameter-api.js
  function setParameters(gl, values) {
    assert7(isWebGL(gl), "setParameters requires a WebGL context");
    if (isObjectEmpty(values)) {
      return;
    }
    const compositeSetters = {};
    for (const key in values) {
      const glConstant = Number(key);
      const setter = GL_PARAMETER_SETTERS[key];
      if (setter) {
        if (typeof setter === "string") {
          compositeSetters[setter] = true;
        } else {
          setter(gl, values[key], glConstant);
        }
      }
    }
    const cache2 = gl.state && gl.state.cache;
    if (cache2) {
      for (const key in compositeSetters) {
        const compositeSetter = GL_COMPOSITE_PARAMETER_SETTERS[key];
        compositeSetter(gl, values, cache2);
      }
    }
  }
  function getParameters(gl, parameters) {
    parameters = parameters || GL_PARAMETER_DEFAULTS;
    if (typeof parameters === "number") {
      const key = parameters;
      const getter = GL_PARAMETER_GETTERS[key];
      return getter ? getter(gl, key) : gl.getParameter(key);
    }
    const parameterKeys = Array.isArray(parameters) ? parameters : Object.keys(parameters);
    const state = {};
    for (const key of parameterKeys) {
      const getter = GL_PARAMETER_GETTERS[key];
      state[key] = getter ? getter(gl, Number(key)) : gl.getParameter(Number(key));
    }
    return state;
  }
  function withParameters(gl, parameters, func) {
    if (isObjectEmpty(parameters)) {
      return func(gl);
    }
    const {
      nocatch = true
    } = parameters;
    pushContextState(gl);
    setParameters(gl, parameters);
    let value;
    if (nocatch) {
      value = func(gl);
      popContextState(gl);
    } else {
      try {
        value = func(gl);
      } finally {
        popContextState(gl);
      }
    }
    return value;
  }

  // ../../node_modules/@luma.gl/gltools/dist/esm/context/context.js
  var isBrowser5 = isBrowser3();

  // ../../node_modules/@luma.gl/webgl/dist/esm/init.js
  var VERSION7 = true ? "8.5.16" : "untranspiled source";
  var STARTUP_MESSAGE = "set luma.log.level=1 (or higher) to trace rendering";
  var StatsManager = class {
    constructor() {
      this.stats = /* @__PURE__ */ new Map();
    }
    get(name10) {
      if (!this.stats.has(name10)) {
        this.stats.set(name10, new Stats({
          id: name10
        }));
      }
      return this.stats.get(name10);
    }
  };
  var lumaStats = new StatsManager();
  if (globalThis.luma && globalThis.luma.VERSION !== VERSION7) {
    throw new Error("luma.gl - multiple VERSIONs detected: ".concat(globalThis.luma.VERSION, " vs ").concat(VERSION7));
  }
  if (!globalThis.luma) {
    if (isBrowser3()) {
      log.log(1, "luma.gl ".concat(VERSION7, " - ").concat(STARTUP_MESSAGE))();
    }
    globalThis.luma = globalThis.luma || {
      VERSION: VERSION7,
      version: VERSION7,
      log,
      stats: lumaStats,
      globals: {
        modules: {},
        nodeIO: {}
      }
    };
  }
  var init_default = globalThis.luma;

  // ../../node_modules/@luma.gl/webgl/dist/esm/utils/assert.js
  function assert8(condition, message) {
    if (!condition) {
      throw new Error(message || "luma.gl: assertion failed.");
    }
  }

  // ../../node_modules/@luma.gl/webgl/dist/esm/webgl-utils/constants-to-keys.js
  function getKeyValue(gl, name10) {
    if (typeof name10 !== "string") {
      return name10;
    }
    const number = Number(name10);
    if (!isNaN(number)) {
      return number;
    }
    name10 = name10.replace(/^.*\./, "");
    const value = gl[name10];
    assert8(value !== void 0, "Accessing undefined constant GL.".concat(name10));
    return value;
  }
  function getKey(gl, value) {
    value = Number(value);
    for (const key in gl) {
      if (gl[key] === value) {
        return "GL.".concat(key);
      }
    }
    return String(value);
  }

  // ../../node_modules/@luma.gl/webgl/dist/esm/utils/utils.js
  var uidCounters = {};
  function uid() {
    let id = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "id";
    uidCounters[id] = uidCounters[id] || 1;
    const count = uidCounters[id]++;
    return "".concat(id, "-").concat(count);
  }
  function isPowerOfTwo(n2) {
    assert8(typeof n2 === "number", "Input must be a number");
    return n2 && (n2 & n2 - 1) === 0;
  }

  // ../../node_modules/@luma.gl/webgl/dist/esm/utils/stub-methods.js
  function stubRemovedMethods(instance, className, version, methodNames) {
    const upgradeMessage = "See luma.gl ".concat(version, " Upgrade Guide at https://luma.gl/docs/upgrade-guide");
    const prototype = Object.getPrototypeOf(instance);
    methodNames.forEach((methodName) => {
      if (prototype.methodName) {
        return;
      }
      prototype[methodName] = () => {
        log.removed("Calling removed method ".concat(className, ".").concat(methodName, ": "), upgradeMessage)();
        throw new Error(methodName);
      };
    });
  }

  // ../../node_modules/@luma.gl/webgl/dist/esm/classes/resource.js
  var ERR_RESOURCE_METHOD_UNDEFINED = "Resource subclass must define virtual methods";
  var Resource = class {
    get [Symbol.toStringTag]() {
      return "Resource";
    }
    constructor(gl) {
      let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      assertWebGLContext(gl);
      const {
        id,
        userData = {}
      } = opts;
      this.gl = gl;
      this.gl2 = gl;
      this.id = id || uid(this[Symbol.toStringTag]);
      this.userData = userData;
      this._bound = false;
      this._handle = opts.handle;
      if (this._handle === void 0) {
        this._handle = this._createHandle();
      }
      this.byteLength = 0;
      this._initStats();
      this._addStats();
    }
    toString() {
      return "".concat(this[Symbol.toStringTag] || this.constructor.name, "(").concat(this.id, ")");
    }
    get handle() {
      return this._handle;
    }
    delete() {
      let {
        deleteChildren = false
      } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const children = this._handle && this._deleteHandle(this._handle);
      if (this._handle) {
        this._removeStats();
      }
      this._handle = null;
      if (children && deleteChildren) {
        children.filter(Boolean).forEach((child) => child.delete());
      }
      return this;
    }
    bind() {
      let funcOrHandle = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.handle;
      if (typeof funcOrHandle !== "function") {
        this._bindHandle(funcOrHandle);
        return this;
      }
      let value;
      if (!this._bound) {
        this._bindHandle(this.handle);
        this._bound = true;
        value = funcOrHandle();
        this._bound = false;
        this._bindHandle(null);
      } else {
        value = funcOrHandle();
      }
      return value;
    }
    unbind() {
      this.bind(null);
    }
    getParameter(pname) {
      let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      pname = getKeyValue(this.gl, pname);
      assert8(pname);
      const parameters = this.constructor.PARAMETERS || {};
      const parameter = parameters[pname];
      if (parameter) {
        const isWebgl2 = isWebGL2(this.gl);
        const parameterAvailable = (!("webgl2" in parameter) || isWebgl2) && (!("extension" in parameter) || this.gl.getExtension(parameter.extension));
        if (!parameterAvailable) {
          const webgl1Default = parameter.webgl1;
          const webgl2Default = "webgl2" in parameter ? parameter.webgl2 : parameter.webgl1;
          const defaultValue2 = isWebgl2 ? webgl2Default : webgl1Default;
          return defaultValue2;
        }
      }
      return this._getParameter(pname, opts);
    }
    getParameters() {
      let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const {
        parameters,
        keys
      } = options;
      const PARAMETERS = this.constructor.PARAMETERS || {};
      const isWebgl2 = isWebGL2(this.gl);
      const values = {};
      const parameterKeys = parameters || Object.keys(PARAMETERS);
      for (const pname of parameterKeys) {
        const parameter = PARAMETERS[pname];
        const parameterAvailable = parameter && (!("webgl2" in parameter) || isWebgl2) && (!("extension" in parameter) || this.gl.getExtension(parameter.extension));
        if (parameterAvailable) {
          const key = keys ? getKey(this.gl, pname) : pname;
          values[key] = this.getParameter(pname, options);
          if (keys && parameter.type === "GLenum") {
            values[key] = getKey(this.gl, values[key]);
          }
        }
      }
      return values;
    }
    setParameter(pname, value) {
      pname = getKeyValue(this.gl, pname);
      assert8(pname);
      const parameters = this.constructor.PARAMETERS || {};
      const parameter = parameters[pname];
      if (parameter) {
        const isWebgl2 = isWebGL2(this.gl);
        const parameterAvailable = (!("webgl2" in parameter) || isWebgl2) && (!("extension" in parameter) || this.gl.getExtension(parameter.extension));
        if (!parameterAvailable) {
          throw new Error("Parameter not available on this platform");
        }
        if (parameter.type === "GLenum") {
          value = getKeyValue(value);
        }
      }
      this._setParameter(pname, value);
      return this;
    }
    setParameters(parameters) {
      for (const pname in parameters) {
        this.setParameter(pname, parameters[pname]);
      }
      return this;
    }
    stubRemovedMethods(className, version, methodNames) {
      return stubRemovedMethods(this, className, version, methodNames);
    }
    initialize(opts) {
    }
    _createHandle() {
      throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
    }
    _deleteHandle() {
      throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
    }
    _bindHandle(handle) {
      throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
    }
    _getOptsFromHandle() {
      throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
    }
    _getParameter(pname, opts) {
      throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
    }
    _setParameter(pname, value) {
      throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
    }
    _context() {
      this.gl.luma = this.gl.luma || {};
      return this.gl.luma;
    }
    _initStats() {
      this.gl.stats = this.gl.stats || new StatsManager();
    }
    _addStats() {
      const name10 = this[Symbol.toStringTag];
      const stats = lumaStats.get("Resource Counts");
      stats.get("Resources Created").incrementCount();
      stats.get("".concat(name10, "s Created")).incrementCount();
      stats.get("".concat(name10, "s Active")).incrementCount();
    }
    _removeStats() {
      const name10 = this[Symbol.toStringTag];
      const stats = lumaStats.get("Resource Counts");
      stats.get("".concat(name10, "s Active")).decrementCount();
    }
    _trackAllocatedMemory(bytes) {
      let name10 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this[Symbol.toStringTag];
      this._doTrackAllocatedMemory(bytes, name10);
      this._doTrackAllocatedMemory(bytes, name10, this.gl.stats.get("Memory Usage"));
    }
    _doTrackAllocatedMemory(bytes) {
      let name10 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this[Symbol.toStringTag];
      let stats = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : lumaStats.get("Memory Usage");
      stats.get("GPU Memory").addCount(bytes);
      stats.get("".concat(name10, " Memory")).addCount(bytes);
      this.byteLength = bytes;
    }
    _trackDeallocatedMemory() {
      let name10 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this[Symbol.toStringTag];
      this._doTrackDeallocatedMemory(name10);
      this._doTrackDeallocatedMemory(name10, this.gl.stats.get("Memory Usage"));
    }
    _doTrackDeallocatedMemory() {
      let name10 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this[Symbol.toStringTag];
      let stats = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : lumaStats.get("Memory Usage");
      stats.get("GPU Memory").subtractCount(this.byteLength);
      stats.get("".concat(name10, " Memory")).subtractCount(this.byteLength);
      this.byteLength = 0;
    }
  };

  // ../../node_modules/@luma.gl/webgl/dist/esm/webgl-utils/typed-array-utils.js
  var ERR_TYPE_DEDUCTION = "Failed to deduce GL constant from typed array";
  function getGLTypeFromTypedArray(arrayOrType) {
    const type = ArrayBuffer.isView(arrayOrType) ? arrayOrType.constructor : arrayOrType;
    switch (type) {
      case Float32Array:
        return 5126;
      case Uint16Array:
        return 5123;
      case Uint32Array:
        return 5125;
      case Uint8Array:
        return 5121;
      case Uint8ClampedArray:
        return 5121;
      case Int8Array:
        return 5120;
      case Int16Array:
        return 5122;
      case Int32Array:
        return 5124;
      default:
        throw new Error(ERR_TYPE_DEDUCTION);
    }
  }
  function getTypedArrayFromGLType(glType) {
    let {
      clamped = true
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    switch (glType) {
      case 5126:
        return Float32Array;
      case 5123:
      case 33635:
      case 32819:
      case 32820:
        return Uint16Array;
      case 5125:
        return Uint32Array;
      case 5121:
        return clamped ? Uint8ClampedArray : Uint8Array;
      case 5120:
        return Int8Array;
      case 5122:
        return Int16Array;
      case 5124:
        return Int32Array;
      default:
        throw new Error("Failed to deduce typed array type from GL constant");
    }
  }
  function flipRows(_ref) {
    let {
      data,
      width,
      height,
      bytesPerPixel = 4,
      temp
    } = _ref;
    const bytesPerRow = width * bytesPerPixel;
    temp = temp || new Uint8Array(bytesPerRow);
    for (let y2 = 0; y2 < height / 2; ++y2) {
      const topOffset = y2 * bytesPerRow;
      const bottomOffset = (height - y2 - 1) * bytesPerRow;
      temp.set(data.subarray(topOffset, topOffset + bytesPerRow));
      data.copyWithin(topOffset, bottomOffset, bottomOffset + bytesPerRow);
      data.set(temp, bottomOffset);
    }
  }
  function scalePixels(_ref2) {
    let {
      data,
      width,
      height
    } = _ref2;
    const newWidth = Math.round(width / 2);
    const newHeight = Math.round(height / 2);
    const newData = new Uint8Array(newWidth * newHeight * 4);
    for (let y2 = 0; y2 < newHeight; y2++) {
      for (let x2 = 0; x2 < newWidth; x2++) {
        for (let c = 0; c < 4; c++) {
          newData[(y2 * newWidth + x2) * 4 + c] = data[(y2 * 2 * width + x2 * 2) * 4 + c];
        }
      }
    }
    return {
      data: newData,
      width: newWidth,
      height: newHeight
    };
  }

  // ../../node_modules/@luma.gl/webgl/dist/esm/utils/check-props.js
  function checkProps(className, props, propChecks) {
    const {
      removedProps = {},
      deprecatedProps = {},
      replacedProps = {}
    } = propChecks;
    for (const propName in removedProps) {
      if (propName in props) {
        const replacementProp = removedProps[propName];
        const replacement = replacementProp ? "".concat(className, ".").concat(removedProps[propName]) : "N/A";
        log.removed("".concat(className, ".").concat(propName), replacement)();
      }
    }
    for (const propName in deprecatedProps) {
      if (propName in props) {
        const replacementProp = deprecatedProps[propName];
        log.deprecated("".concat(className, ".").concat(propName), "".concat(className, ".").concat(replacementProp))();
      }
    }
    let newProps = null;
    for (const propName in replacedProps) {
      if (propName in props) {
        const replacementProp = replacedProps[propName];
        log.deprecated("".concat(className, ".").concat(propName), "".concat(className, ".").concat(replacementProp))();
        newProps = newProps || Object.assign({}, props);
        newProps[replacementProp] = props[propName];
        delete newProps[propName];
      }
    }
    return newProps || props;
  }

  // ../../node_modules/@luma.gl/webgl/dist/esm/classes/accessor.js
  var DEFAULT_ACCESSOR_VALUES = {
    offset: 0,
    stride: 0,
    type: 5126,
    size: 1,
    divisor: 0,
    normalized: false,
    integer: false
  };
  var PROP_CHECKS = {
    deprecatedProps: {
      instanced: "divisor",
      isInstanced: "divisor"
    }
  };
  var Accessor = class {
    static getBytesPerElement(accessor) {
      const ArrayType = getTypedArrayFromGLType(accessor.type || 5126);
      return ArrayType.BYTES_PER_ELEMENT;
    }
    static getBytesPerVertex(accessor) {
      assert8(accessor.size);
      const ArrayType = getTypedArrayFromGLType(accessor.type || 5126);
      return ArrayType.BYTES_PER_ELEMENT * accessor.size;
    }
    static resolve() {
      for (var _len = arguments.length, accessors = new Array(_len), _key = 0; _key < _len; _key++) {
        accessors[_key] = arguments[_key];
      }
      return new Accessor(...[DEFAULT_ACCESSOR_VALUES, ...accessors]);
    }
    constructor() {
      for (var _len2 = arguments.length, accessors = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        accessors[_key2] = arguments[_key2];
      }
      accessors.forEach((accessor) => this._assign(accessor));
      Object.freeze(this);
    }
    toString() {
      return JSON.stringify(this);
    }
    get BYTES_PER_ELEMENT() {
      return Accessor.getBytesPerElement(this);
    }
    get BYTES_PER_VERTEX() {
      return Accessor.getBytesPerVertex(this);
    }
    _assign() {
      let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      props = checkProps("Accessor", props, PROP_CHECKS);
      if (props.type !== void 0) {
        this.type = props.type;
        if (props.type === 5124 || props.type === 5125) {
          this.integer = true;
        }
      }
      if (props.size !== void 0) {
        this.size = props.size;
      }
      if (props.offset !== void 0) {
        this.offset = props.offset;
      }
      if (props.stride !== void 0) {
        this.stride = props.stride;
      }
      if (props.normalized !== void 0) {
        this.normalized = props.normalized;
      }
      if (props.integer !== void 0) {
        this.integer = props.integer;
      }
      if (props.divisor !== void 0) {
        this.divisor = props.divisor;
      }
      if (props.buffer !== void 0) {
        this.buffer = props.buffer;
      }
      if (props.index !== void 0) {
        if (typeof props.index === "boolean") {
          this.index = props.index ? 1 : 0;
        } else {
          this.index = props.index;
        }
      }
      if (props.instanced !== void 0) {
        this.divisor = props.instanced ? 1 : 0;
      }
      if (props.isInstanced !== void 0) {
        this.divisor = props.isInstanced ? 1 : 0;
      }
      return this;
    }
  };

  // ../../node_modules/@luma.gl/webgl/dist/esm/classes/buffer.js
  var DEBUG_DATA_LENGTH = 10;
  var DEPRECATED_PROPS = {
    offset: "accessor.offset",
    stride: "accessor.stride",
    type: "accessor.type",
    size: "accessor.size",
    divisor: "accessor.divisor",
    normalized: "accessor.normalized",
    integer: "accessor.integer",
    instanced: "accessor.divisor",
    isInstanced: "accessor.divisor"
  };
  var PROP_CHECKS_INITIALIZE = {
    removedProps: {},
    replacedProps: {
      bytes: "byteLength"
    },
    deprecatedProps: DEPRECATED_PROPS
  };
  var PROP_CHECKS_SET_PROPS = {
    removedProps: DEPRECATED_PROPS
  };
  var Buffer2 = class extends Resource {
    get [Symbol.toStringTag]() {
      return "Buffer";
    }
    constructor(gl) {
      let props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      super(gl, props);
      this.stubRemovedMethods("Buffer", "v6.0", ["layout", "setLayout", "getIndexedParameter"]);
      this.target = props.target || (this.gl.webgl2 ? 36662 : 34962);
      this.initialize(props);
      Object.seal(this);
    }
    getElementCount() {
      let accessor = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.accessor;
      return Math.round(this.byteLength / Accessor.getBytesPerElement(accessor));
    }
    getVertexCount() {
      let accessor = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.accessor;
      return Math.round(this.byteLength / Accessor.getBytesPerVertex(accessor));
    }
    initialize() {
      let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      if (ArrayBuffer.isView(props)) {
        props = {
          data: props
        };
      }
      if (Number.isFinite(props)) {
        props = {
          byteLength: props
        };
      }
      props = checkProps("Buffer", props, PROP_CHECKS_INITIALIZE);
      this.usage = props.usage || 35044;
      this.debugData = null;
      this.setAccessor(Object.assign({}, props, props.accessor));
      if (props.data) {
        this._setData(props.data, props.offset, props.byteLength);
      } else {
        this._setByteLength(props.byteLength || 0);
      }
      return this;
    }
    setProps(props) {
      props = checkProps("Buffer", props, PROP_CHECKS_SET_PROPS);
      if ("accessor" in props) {
        this.setAccessor(props.accessor);
      }
      return this;
    }
    setAccessor(accessor) {
      accessor = Object.assign({}, accessor);
      delete accessor.buffer;
      this.accessor = new Accessor(accessor);
      return this;
    }
    reallocate(byteLength) {
      if (byteLength > this.byteLength) {
        this._setByteLength(byteLength);
        return true;
      }
      this.bytesUsed = byteLength;
      return false;
    }
    setData(props) {
      return this.initialize(props);
    }
    subData(props) {
      if (ArrayBuffer.isView(props)) {
        props = {
          data: props
        };
      }
      const {
        data,
        offset = 0,
        srcOffset = 0
      } = props;
      const byteLength = props.byteLength || props.length;
      assert8(data);
      const target = this.gl.webgl2 ? 36663 : this.target;
      this.gl.bindBuffer(target, this.handle);
      if (srcOffset !== 0 || byteLength !== void 0) {
        assertWebGL2Context(this.gl);
        this.gl.bufferSubData(this.target, offset, data, srcOffset, byteLength);
      } else {
        this.gl.bufferSubData(target, offset, data);
      }
      this.gl.bindBuffer(target, null);
      this.debugData = null;
      this._inferType(data);
      return this;
    }
    copyData(_ref) {
      let {
        sourceBuffer,
        readOffset = 0,
        writeOffset = 0,
        size
      } = _ref;
      const {
        gl
      } = this;
      assertWebGL2Context(gl);
      gl.bindBuffer(36662, sourceBuffer.handle);
      gl.bindBuffer(36663, this.handle);
      gl.copyBufferSubData(36662, 36663, readOffset, writeOffset, size);
      gl.bindBuffer(36662, null);
      gl.bindBuffer(36663, null);
      this.debugData = null;
      return this;
    }
    getData() {
      let {
        dstData = null,
        srcByteOffset = 0,
        dstOffset = 0,
        length: length5 = 0
      } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      assertWebGL2Context(this.gl);
      const ArrayType = getTypedArrayFromGLType(this.accessor.type || 5126, {
        clamped: false
      });
      const sourceAvailableElementCount = this._getAvailableElementCount(srcByteOffset);
      const dstElementOffset = dstOffset;
      let dstAvailableElementCount;
      let dstElementCount;
      if (dstData) {
        dstElementCount = dstData.length;
        dstAvailableElementCount = dstElementCount - dstElementOffset;
      } else {
        dstAvailableElementCount = Math.min(sourceAvailableElementCount, length5 || sourceAvailableElementCount);
        dstElementCount = dstElementOffset + dstAvailableElementCount;
      }
      const copyElementCount = Math.min(sourceAvailableElementCount, dstAvailableElementCount);
      length5 = length5 || copyElementCount;
      assert8(length5 <= copyElementCount);
      dstData = dstData || new ArrayType(dstElementCount);
      this.gl.bindBuffer(36662, this.handle);
      this.gl.getBufferSubData(36662, srcByteOffset, dstData, dstOffset, length5);
      this.gl.bindBuffer(36662, null);
      return dstData;
    }
    bind() {
      let {
        target = this.target,
        index = this.accessor && this.accessor.index,
        offset = 0,
        size
      } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      if (target === 35345 || target === 35982) {
        if (size !== void 0) {
          this.gl.bindBufferRange(target, index, this.handle, offset, size);
        } else {
          assert8(offset === 0);
          this.gl.bindBufferBase(target, index, this.handle);
        }
      } else {
        this.gl.bindBuffer(target, this.handle);
      }
      return this;
    }
    unbind() {
      let {
        target = this.target,
        index = this.accessor && this.accessor.index
      } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const isIndexedBuffer = target === 35345 || target === 35982;
      if (isIndexedBuffer) {
        this.gl.bindBufferBase(target, index, null);
      } else {
        this.gl.bindBuffer(target, null);
      }
      return this;
    }
    getDebugData() {
      if (!this.debugData) {
        this.debugData = this.getData({
          length: Math.min(DEBUG_DATA_LENGTH, this.byteLength)
        });
        return {
          data: this.debugData,
          changed: true
        };
      }
      return {
        data: this.debugData,
        changed: false
      };
    }
    invalidateDebugData() {
      this.debugData = null;
    }
    _setData(data) {
      let offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      let byteLength = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : data.byteLength + offset;
      assert8(ArrayBuffer.isView(data));
      this._trackDeallocatedMemory();
      const target = this._getTarget();
      this.gl.bindBuffer(target, this.handle);
      this.gl.bufferData(target, byteLength, this.usage);
      this.gl.bufferSubData(target, offset, data);
      this.gl.bindBuffer(target, null);
      this.debugData = data.slice(0, DEBUG_DATA_LENGTH);
      this.bytesUsed = byteLength;
      this._trackAllocatedMemory(byteLength);
      const type = getGLTypeFromTypedArray(data);
      assert8(type);
      this.setAccessor(new Accessor(this.accessor, {
        type
      }));
      return this;
    }
    _setByteLength(byteLength) {
      let usage = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.usage;
      assert8(byteLength >= 0);
      this._trackDeallocatedMemory();
      let data = byteLength;
      if (byteLength === 0) {
        data = new Float32Array(0);
      }
      const target = this._getTarget();
      this.gl.bindBuffer(target, this.handle);
      this.gl.bufferData(target, data, usage);
      this.gl.bindBuffer(target, null);
      this.usage = usage;
      this.debugData = null;
      this.bytesUsed = byteLength;
      this._trackAllocatedMemory(byteLength);
      return this;
    }
    _getTarget() {
      return this.gl.webgl2 ? 36663 : this.target;
    }
    _getAvailableElementCount(srcByteOffset) {
      const ArrayType = getTypedArrayFromGLType(this.accessor.type || 5126, {
        clamped: false
      });
      const sourceElementOffset = srcByteOffset / ArrayType.BYTES_PER_ELEMENT;
      return this.getElementCount() - sourceElementOffset;
    }
    _inferType(data) {
      if (!this.accessor.type) {
        this.setAccessor(new Accessor(this.accessor, {
          type: getGLTypeFromTypedArray(data)
        }));
      }
    }
    _createHandle() {
      return this.gl.createBuffer();
    }
    _deleteHandle() {
      this.gl.deleteBuffer(this.handle);
      this._trackDeallocatedMemory();
    }
    _getParameter(pname) {
      this.gl.bindBuffer(this.target, this.handle);
      const value = this.gl.getBufferParameter(this.target, pname);
      this.gl.bindBuffer(this.target, null);
      return value;
    }
    get type() {
      log.deprecated("Buffer.type", "Buffer.accessor.type")();
      return this.accessor.type;
    }
    get bytes() {
      log.deprecated("Buffer.bytes", "Buffer.byteLength")();
      return this.byteLength;
    }
    setByteLength(byteLength) {
      log.deprecated("setByteLength", "reallocate")();
      return this.reallocate(byteLength);
    }
    updateAccessor(opts) {
      log.deprecated("updateAccessor(...)", "setAccessor(new Accessor(buffer.accessor, ...)")();
      this.accessor = new Accessor(this.accessor, opts);
      return this;
    }
  };

  // ../../node_modules/@luma.gl/webgl/dist/esm/classes/texture-formats.js
  var TEXTURE_FORMATS = {
    [6407]: {
      dataFormat: 6407,
      types: [5121, 33635]
    },
    [6408]: {
      dataFormat: 6408,
      types: [5121, 32819, 32820]
    },
    [6406]: {
      dataFormat: 6406,
      types: [5121]
    },
    [6409]: {
      dataFormat: 6409,
      types: [5121]
    },
    [6410]: {
      dataFormat: 6410,
      types: [5121]
    },
    [33326]: {
      dataFormat: 6403,
      types: [5126],
      gl2: true
    },
    [33328]: {
      dataFormat: 33319,
      types: [5126],
      gl2: true
    },
    [34837]: {
      dataFormat: 6407,
      types: [5126],
      gl2: true
    },
    [34836]: {
      dataFormat: 6408,
      types: [5126],
      gl2: true
    }
  };
  var DATA_FORMAT_CHANNELS = {
    [6403]: 1,
    [36244]: 1,
    [33319]: 2,
    [33320]: 2,
    [6407]: 3,
    [36248]: 3,
    [6408]: 4,
    [36249]: 4,
    [6402]: 1,
    [34041]: 1,
    [6406]: 1,
    [6409]: 1,
    [6410]: 2
  };
  var TYPE_SIZES = {
    [5126]: 4,
    [5125]: 4,
    [5124]: 4,
    [5123]: 2,
    [5122]: 2,
    [5131]: 2,
    [5120]: 1,
    [5121]: 1
  };
  function isFormatSupported(gl, format) {
    const info = TEXTURE_FORMATS[format];
    if (!info) {
      return false;
    }
    if (info.gl1 === void 0 && info.gl2 === void 0) {
      return true;
    }
    const value = isWebGL2(gl) ? info.gl2 || info.gl1 : info.gl1;
    return typeof value === "string" ? gl.getExtension(value) : value;
  }
  function isLinearFilteringSupported(gl, format) {
    const info = TEXTURE_FORMATS[format];
    switch (info && info.types[0]) {
      case 5126:
        return gl.getExtension("OES_texture_float_linear");
      case 5131:
        return gl.getExtension("OES_texture_half_float_linear");
      default:
        return true;
    }
  }

  // ../../node_modules/@luma.gl/webgl/dist/esm/classes/texture.js
  var NPOT_MIN_FILTERS = [9729, 9728];
  var WebGLBuffer = globalThis.WebGLBuffer || function WebGLBuffer2() {
  };
  var Texture = class extends Resource {
    get [Symbol.toStringTag]() {
      return "Texture";
    }
    static isSupported(gl) {
      let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      const {
        format,
        linearFiltering
      } = opts;
      let supported = true;
      if (format) {
        supported = supported && isFormatSupported(gl, format);
        supported = supported && (!linearFiltering || isLinearFilteringSupported(gl, format));
      }
      return supported;
    }
    constructor(gl, props) {
      const {
        id = uid("texture"),
        handle,
        target
      } = props;
      super(gl, {
        id,
        handle
      });
      this.target = target;
      this.textureUnit = void 0;
      this.loaded = false;
      this.width = void 0;
      this.height = void 0;
      this.depth = void 0;
      this.format = void 0;
      this.type = void 0;
      this.dataFormat = void 0;
      this.border = void 0;
      this.textureUnit = void 0;
      this.mipmaps = void 0;
    }
    toString() {
      return "Texture(".concat(this.id, ",").concat(this.width, "x").concat(this.height, ")");
    }
    initialize() {
      let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      let data = props.data;
      if (data instanceof Promise) {
        data.then((resolvedImageData) => this.initialize(Object.assign({}, props, {
          pixels: resolvedImageData,
          data: resolvedImageData
        })));
        return this;
      }
      const isVideo = typeof HTMLVideoElement !== "undefined" && data instanceof HTMLVideoElement;
      if (isVideo && data.readyState < HTMLVideoElement.HAVE_METADATA) {
        this._video = null;
        data.addEventListener("loadeddata", () => this.initialize(props));
        return this;
      }
      const {
        pixels = null,
        format = 6408,
        border = 0,
        recreate = false,
        parameters = {},
        pixelStore = {},
        textureUnit = void 0
      } = props;
      if (!data) {
        data = pixels;
      }
      let {
        width,
        height,
        dataFormat,
        type,
        compressed = false,
        mipmaps = true
      } = props;
      const {
        depth = 0
      } = props;
      ({
        width,
        height,
        compressed,
        dataFormat,
        type
      } = this._deduceParameters({
        format,
        type,
        dataFormat,
        compressed,
        data,
        width,
        height
      }));
      this.width = width;
      this.height = height;
      this.depth = depth;
      this.format = format;
      this.type = type;
      this.dataFormat = dataFormat;
      this.border = border;
      this.textureUnit = textureUnit;
      if (Number.isFinite(this.textureUnit)) {
        this.gl.activeTexture(33984 + this.textureUnit);
        this.gl.bindTexture(this.target, this.handle);
      }
      if (mipmaps && this._isNPOT()) {
        log.warn("texture: ".concat(this, " is Non-Power-Of-Two, disabling mipmaping"))();
        mipmaps = false;
        this._updateForNPOT(parameters);
      }
      this.mipmaps = mipmaps;
      this.setImageData({
        data,
        width,
        height,
        depth,
        format,
        type,
        dataFormat,
        border,
        mipmaps,
        parameters: pixelStore,
        compressed
      });
      if (mipmaps) {
        this.generateMipmap();
      }
      this.setParameters(parameters);
      if (recreate) {
        this.data = data;
      }
      if (isVideo) {
        this._video = {
          video: data,
          parameters,
          lastTime: data.readyState >= HTMLVideoElement.HAVE_CURRENT_DATA ? data.currentTime : -1
        };
      }
      return this;
    }
    update() {
      if (this._video) {
        const {
          video,
          parameters,
          lastTime
        } = this._video;
        if (lastTime === video.currentTime || video.readyState < HTMLVideoElement.HAVE_CURRENT_DATA) {
          return;
        }
        this.setSubImageData({
          data: video,
          parameters
        });
        if (this.mipmaps) {
          this.generateMipmap();
        }
        this._video.lastTime = video.currentTime;
      }
    }
    resize(_ref) {
      let {
        height,
        width,
        mipmaps = false
      } = _ref;
      if (width !== this.width || height !== this.height) {
        return this.initialize({
          width,
          height,
          format: this.format,
          type: this.type,
          dataFormat: this.dataFormat,
          border: this.border,
          mipmaps
        });
      }
      return this;
    }
    generateMipmap() {
      let params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      if (this._isNPOT()) {
        log.warn("texture: ".concat(this, " is Non-Power-Of-Two, disabling mipmaping"))();
        return this;
      }
      this.mipmaps = true;
      this.gl.bindTexture(this.target, this.handle);
      withParameters(this.gl, params, () => {
        this.gl.generateMipmap(this.target);
      });
      this.gl.bindTexture(this.target, null);
      return this;
    }
    setImageData(options) {
      this._trackDeallocatedMemory("Texture");
      const {
        target = this.target,
        pixels = null,
        level = 0,
        format = this.format,
        border = this.border,
        offset = 0,
        parameters = {}
      } = options;
      let {
        data = null,
        type = this.type,
        width = this.width,
        height = this.height,
        dataFormat = this.dataFormat,
        compressed = false
      } = options;
      if (!data) {
        data = pixels;
      }
      ({
        type,
        dataFormat,
        compressed,
        width,
        height
      } = this._deduceParameters({
        format,
        type,
        dataFormat,
        compressed,
        data,
        width,
        height
      }));
      const {
        gl
      } = this;
      gl.bindTexture(this.target, this.handle);
      let dataType = null;
      ({
        data,
        dataType
      } = this._getDataType({
        data,
        compressed
      }));
      let gl2;
      let compressedTextureSize = 0;
      withParameters(this.gl, parameters, () => {
        switch (dataType) {
          case "null":
            gl.texImage2D(target, level, format, width, height, border, dataFormat, type, data);
            break;
          case "typed-array":
            gl.texImage2D(target, level, format, width, height, border, dataFormat, type, data, offset);
            break;
          case "buffer":
            gl2 = assertWebGL2Context(gl);
            gl2.bindBuffer(35052, data.handle || data);
            gl2.texImage2D(target, level, format, width, height, border, dataFormat, type, offset);
            gl2.bindBuffer(35052, null);
            break;
          case "browser-object":
            if (isWebGL2(gl)) {
              gl.texImage2D(target, level, format, width, height, border, dataFormat, type, data);
            } else {
              gl.texImage2D(target, level, format, dataFormat, type, data);
            }
            break;
          case "compressed":
            for (const [levelIndex, levelData] of data.entries()) {
              gl.compressedTexImage2D(target, levelIndex, levelData.format, levelData.width, levelData.height, border, levelData.data);
              compressedTextureSize += levelData.levelSize;
            }
            break;
          default:
            assert8(false, "Unknown image data type");
        }
      });
      if (dataType === "compressed") {
        this._trackAllocatedMemory(compressedTextureSize, "Texture");
      } else if (data && data.byteLength) {
        this._trackAllocatedMemory(data.byteLength, "Texture");
      } else {
        const channels = DATA_FORMAT_CHANNELS[this.dataFormat] || 4;
        const channelSize = TYPE_SIZES[this.type] || 1;
        this._trackAllocatedMemory(this.width * this.height * channels * channelSize, "Texture");
      }
      this.loaded = true;
      return this;
    }
    setSubImageData(_ref2) {
      let {
        target = this.target,
        pixels = null,
        data = null,
        x: x2 = 0,
        y: y2 = 0,
        width = this.width,
        height = this.height,
        level = 0,
        format = this.format,
        type = this.type,
        dataFormat = this.dataFormat,
        compressed = false,
        offset = 0,
        border = this.border,
        parameters = {}
      } = _ref2;
      ({
        type,
        dataFormat,
        compressed,
        width,
        height
      } = this._deduceParameters({
        format,
        type,
        dataFormat,
        compressed,
        data,
        width,
        height
      }));
      assert8(this.depth === 0, "texSubImage not supported for 3D textures");
      if (!data) {
        data = pixels;
      }
      if (data && data.data) {
        const ndarray = data;
        data = ndarray.data;
        width = ndarray.shape[0];
        height = ndarray.shape[1];
      }
      if (data instanceof Buffer2) {
        data = data.handle;
      }
      this.gl.bindTexture(this.target, this.handle);
      withParameters(this.gl, parameters, () => {
        if (compressed) {
          this.gl.compressedTexSubImage2D(target, level, x2, y2, width, height, format, data);
        } else if (data === null) {
          this.gl.texSubImage2D(target, level, x2, y2, width, height, dataFormat, type, null);
        } else if (ArrayBuffer.isView(data)) {
          this.gl.texSubImage2D(target, level, x2, y2, width, height, dataFormat, type, data, offset);
        } else if (data instanceof WebGLBuffer) {
          const gl2 = assertWebGL2Context(this.gl);
          gl2.bindBuffer(35052, data);
          gl2.texSubImage2D(target, level, x2, y2, width, height, dataFormat, type, offset);
          gl2.bindBuffer(35052, null);
        } else if (isWebGL2(this.gl)) {
          const gl2 = assertWebGL2Context(this.gl);
          gl2.texSubImage2D(target, level, x2, y2, width, height, dataFormat, type, data);
        } else {
          this.gl.texSubImage2D(target, level, x2, y2, dataFormat, type, data);
        }
      });
      this.gl.bindTexture(this.target, null);
    }
    copyFramebuffer() {
      let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      log.error("Texture.copyFramebuffer({...}) is no logner supported, use copyToTexture(source, target, opts})")();
      return null;
    }
    getActiveUnit() {
      return this.gl.getParameter(34016) - 33984;
    }
    bind() {
      let textureUnit = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.textureUnit;
      const {
        gl
      } = this;
      if (textureUnit !== void 0) {
        this.textureUnit = textureUnit;
        gl.activeTexture(33984 + textureUnit);
      }
      gl.bindTexture(this.target, this.handle);
      return textureUnit;
    }
    unbind() {
      let textureUnit = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.textureUnit;
      const {
        gl
      } = this;
      if (textureUnit !== void 0) {
        this.textureUnit = textureUnit;
        gl.activeTexture(33984 + textureUnit);
      }
      gl.bindTexture(this.target, null);
      return textureUnit;
    }
    _getDataType(_ref3) {
      let {
        data,
        compressed = false
      } = _ref3;
      if (compressed) {
        return {
          data,
          dataType: "compressed"
        };
      }
      if (data === null) {
        return {
          data,
          dataType: "null"
        };
      }
      if (ArrayBuffer.isView(data)) {
        return {
          data,
          dataType: "typed-array"
        };
      }
      if (data instanceof Buffer2) {
        return {
          data: data.handle,
          dataType: "buffer"
        };
      }
      if (data instanceof WebGLBuffer) {
        return {
          data,
          dataType: "buffer"
        };
      }
      return {
        data,
        dataType: "browser-object"
      };
    }
    _deduceParameters(opts) {
      const {
        format,
        data
      } = opts;
      let {
        width,
        height,
        dataFormat,
        type,
        compressed
      } = opts;
      const textureFormat = TEXTURE_FORMATS[format];
      dataFormat = dataFormat || textureFormat && textureFormat.dataFormat;
      type = type || textureFormat && textureFormat.types[0];
      compressed = compressed || textureFormat && textureFormat.compressed;
      ({
        width,
        height
      } = this._deduceImageSize(data, width, height));
      return {
        dataFormat,
        type,
        compressed,
        width,
        height,
        format,
        data
      };
    }
    _deduceImageSize(data, width, height) {
      let size;
      if (typeof ImageData !== "undefined" && data instanceof ImageData) {
        size = {
          width: data.width,
          height: data.height
        };
      } else if (typeof HTMLImageElement !== "undefined" && data instanceof HTMLImageElement) {
        size = {
          width: data.naturalWidth,
          height: data.naturalHeight
        };
      } else if (typeof HTMLCanvasElement !== "undefined" && data instanceof HTMLCanvasElement) {
        size = {
          width: data.width,
          height: data.height
        };
      } else if (typeof ImageBitmap !== "undefined" && data instanceof ImageBitmap) {
        size = {
          width: data.width,
          height: data.height
        };
      } else if (typeof HTMLVideoElement !== "undefined" && data instanceof HTMLVideoElement) {
        size = {
          width: data.videoWidth,
          height: data.videoHeight
        };
      } else if (!data) {
        size = {
          width: width >= 0 ? width : 1,
          height: height >= 0 ? height : 1
        };
      } else {
        size = {
          width,
          height
        };
      }
      assert8(size, "Could not deduced texture size");
      assert8(width === void 0 || size.width === width, "Deduced texture width does not match supplied width");
      assert8(height === void 0 || size.height === height, "Deduced texture height does not match supplied height");
      return size;
    }
    _createHandle() {
      return this.gl.createTexture();
    }
    _deleteHandle() {
      this.gl.deleteTexture(this.handle);
      this._trackDeallocatedMemory("Texture");
    }
    _getParameter(pname) {
      switch (pname) {
        case 4096:
          return this.width;
        case 4097:
          return this.height;
        default:
          this.gl.bindTexture(this.target, this.handle);
          const value = this.gl.getTexParameter(this.target, pname);
          this.gl.bindTexture(this.target, null);
          return value;
      }
    }
    _setParameter(pname, param) {
      this.gl.bindTexture(this.target, this.handle);
      param = this._getNPOTParam(pname, param);
      switch (pname) {
        case 33082:
        case 33083:
          this.gl.texParameterf(this.handle, pname, param);
          break;
        case 4096:
        case 4097:
          assert8(false);
          break;
        default:
          this.gl.texParameteri(this.target, pname, param);
          break;
      }
      this.gl.bindTexture(this.target, null);
      return this;
    }
    _isNPOT() {
      if (isWebGL2(this.gl)) {
        return false;
      }
      if (!this.width || !this.height) {
        return false;
      }
      return !isPowerOfTwo(this.width) || !isPowerOfTwo(this.height);
    }
    _updateForNPOT(parameters) {
      if (parameters[this.gl.TEXTURE_MIN_FILTER] === void 0) {
        parameters[this.gl.TEXTURE_MIN_FILTER] = this.gl.LINEAR;
      }
      if (parameters[this.gl.TEXTURE_WRAP_S] === void 0) {
        parameters[this.gl.TEXTURE_WRAP_S] = this.gl.CLAMP_TO_EDGE;
      }
      if (parameters[this.gl.TEXTURE_WRAP_T] === void 0) {
        parameters[this.gl.TEXTURE_WRAP_T] = this.gl.CLAMP_TO_EDGE;
      }
    }
    _getNPOTParam(pname, param) {
      if (this._isNPOT()) {
        switch (pname) {
          case 10241:
            if (NPOT_MIN_FILTERS.indexOf(param) === -1) {
              param = 9729;
            }
            break;
          case 10242:
          case 10243:
            if (param !== 33071) {
              param = 33071;
            }
            break;
          default:
            break;
        }
      }
      return param;
    }
  };

  // ../../node_modules/@luma.gl/webgl/dist/esm/utils/load-file.js
  var pathPrefix = "";
  function loadImage(url, opts) {
    assert8(typeof url === "string");
    url = pathPrefix + url;
    return new Promise((resolve, reject) => {
      try {
        const image = new Image();
        image.onload = () => resolve(image);
        image.onerror = () => reject(new Error("Could not load image ".concat(url, ".")));
        image.crossOrigin = opts && opts.crossOrigin || "anonymous";
        image.src = url;
      } catch (error2) {
        reject(error2);
      }
    });
  }

  // ../../node_modules/@luma.gl/webgl/dist/esm/classes/texture-2d.js
  var Texture2D = class extends Texture {
    get [Symbol.toStringTag]() {
      return "Texture2D";
    }
    static isSupported(gl, opts) {
      return Texture.isSupported(gl, opts);
    }
    constructor(gl) {
      let props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      assertWebGLContext(gl);
      if (props instanceof Promise || typeof props === "string") {
        props = {
          data: props
        };
      }
      if (typeof props.data === "string") {
        props = Object.assign({}, props, {
          data: loadImage(props.data)
        });
      }
      super(gl, Object.assign({}, props, {
        target: 3553
      }));
      this.initialize(props);
      Object.seal(this);
    }
  };

  // ../../node_modules/@luma.gl/webgl/dist/esm/classes/renderbuffer-formats.js
  var EXT_FLOAT_WEBGL2 = "EXT_color_buffer_float";
  var renderbuffer_formats_default = {
    [33189]: {
      bpp: 2
    },
    [33190]: {
      gl2: true,
      bpp: 3
    },
    [36012]: {
      gl2: true,
      bpp: 4
    },
    [36168]: {
      bpp: 1
    },
    [34041]: {
      bpp: 4
    },
    [35056]: {
      gl2: true,
      bpp: 4
    },
    [36013]: {
      gl2: true,
      bpp: 5
    },
    [32854]: {
      bpp: 2
    },
    [36194]: {
      bpp: 2
    },
    [32855]: {
      bpp: 2
    },
    [33321]: {
      gl2: true,
      bpp: 1
    },
    [33330]: {
      gl2: true,
      bpp: 1
    },
    [33329]: {
      gl2: true,
      bpp: 1
    },
    [33332]: {
      gl2: true,
      bpp: 2
    },
    [33331]: {
      gl2: true,
      bpp: 2
    },
    [33334]: {
      gl2: true,
      bpp: 4
    },
    [33333]: {
      gl2: true,
      bpp: 4
    },
    [33323]: {
      gl2: true,
      bpp: 2
    },
    [33336]: {
      gl2: true,
      bpp: 2
    },
    [33335]: {
      gl2: true,
      bpp: 2
    },
    [33338]: {
      gl2: true,
      bpp: 4
    },
    [33337]: {
      gl2: true,
      bpp: 4
    },
    [33340]: {
      gl2: true,
      bpp: 8
    },
    [33339]: {
      gl2: true,
      bpp: 8
    },
    [32849]: {
      gl2: true,
      bpp: 3
    },
    [32856]: {
      gl2: true,
      bpp: 4
    },
    [32857]: {
      gl2: true,
      bpp: 4
    },
    [36220]: {
      gl2: true,
      bpp: 4
    },
    [36238]: {
      gl2: true,
      bpp: 4
    },
    [36975]: {
      gl2: true,
      bpp: 4
    },
    [36214]: {
      gl2: true,
      bpp: 8
    },
    [36232]: {
      gl2: true,
      bpp: 8
    },
    [36226]: {
      gl2: true,
      bpp: 16
    },
    [36208]: {
      gl2: true,
      bpp: 16
    },
    [33325]: {
      gl2: EXT_FLOAT_WEBGL2,
      bpp: 2
    },
    [33327]: {
      gl2: EXT_FLOAT_WEBGL2,
      bpp: 4
    },
    [34842]: {
      gl2: EXT_FLOAT_WEBGL2,
      bpp: 8
    },
    [33326]: {
      gl2: EXT_FLOAT_WEBGL2,
      bpp: 4
    },
    [33328]: {
      gl2: EXT_FLOAT_WEBGL2,
      bpp: 8
    },
    [34836]: {
      gl2: EXT_FLOAT_WEBGL2,
      bpp: 16
    },
    [35898]: {
      gl2: EXT_FLOAT_WEBGL2,
      bpp: 4
    }
  };

  // ../../node_modules/@luma.gl/webgl/dist/esm/classes/renderbuffer.js
  function isFormatSupported2(gl, format, formats2) {
    const info = formats2[format];
    if (!info) {
      return false;
    }
    const value = isWebGL2(gl) ? info.gl2 || info.gl1 : info.gl1;
    if (typeof value === "string") {
      return gl.getExtension(value);
    }
    return value;
  }
  var Renderbuffer = class extends Resource {
    get [Symbol.toStringTag]() {
      return "Renderbuffer";
    }
    static isSupported(gl) {
      let {
        format
      } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
        format: null
      };
      return !format || isFormatSupported2(gl, format, renderbuffer_formats_default);
    }
    static getSamplesForFormat(gl, _ref) {
      let {
        format
      } = _ref;
      return gl.getInternalformatParameter(36161, format, 32937);
    }
    constructor(gl) {
      let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      super(gl, opts);
      this.initialize(opts);
      Object.seal(this);
    }
    initialize(_ref2) {
      let {
        format,
        width = 1,
        height = 1,
        samples = 0
      } = _ref2;
      assert8(format, "Needs format");
      this._trackDeallocatedMemory();
      this.gl.bindRenderbuffer(36161, this.handle);
      if (samples !== 0 && isWebGL2(this.gl)) {
        this.gl.renderbufferStorageMultisample(36161, samples, format, width, height);
      } else {
        this.gl.renderbufferStorage(36161, format, width, height);
      }
      this.format = format;
      this.width = width;
      this.height = height;
      this.samples = samples;
      this._trackAllocatedMemory(this.width * this.height * (this.samples || 1) * renderbuffer_formats_default[this.format].bpp);
      return this;
    }
    resize(_ref3) {
      let {
        width,
        height
      } = _ref3;
      if (width !== this.width || height !== this.height) {
        return this.initialize({
          width,
          height,
          format: this.format,
          samples: this.samples
        });
      }
      return this;
    }
    _createHandle() {
      return this.gl.createRenderbuffer();
    }
    _deleteHandle() {
      this.gl.deleteRenderbuffer(this.handle);
      this._trackDeallocatedMemory();
    }
    _bindHandle(handle) {
      this.gl.bindRenderbuffer(36161, handle);
    }
    _syncHandle(handle) {
      this.format = this.getParameter(36164);
      this.width = this.getParameter(36162);
      this.height = this.getParameter(36163);
      this.samples = this.getParameter(36011);
    }
    _getParameter(pname) {
      this.gl.bindRenderbuffer(36161, this.handle);
      const value = this.gl.getRenderbufferParameter(36161, pname);
      return value;
    }
  };

  // ../../node_modules/@luma.gl/webgl/dist/esm/classes/clear.js
  var GL_DEPTH_BUFFER_BIT = 256;
  var GL_STENCIL_BUFFER_BIT = 1024;
  var GL_COLOR_BUFFER_BIT = 16384;
  var GL_COLOR = 6144;
  var GL_DEPTH = 6145;
  var GL_STENCIL = 6146;
  var GL_DEPTH_STENCIL = 34041;
  var ERR_ARGUMENTS = "clear: bad arguments";
  function clear(gl) {
    let {
      framebuffer = null,
      color = null,
      depth = null,
      stencil = null
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const parameters = {};
    if (framebuffer) {
      parameters.framebuffer = framebuffer;
    }
    let clearFlags = 0;
    if (color) {
      clearFlags |= GL_COLOR_BUFFER_BIT;
      if (color !== true) {
        parameters.clearColor = color;
      }
    }
    if (depth) {
      clearFlags |= GL_DEPTH_BUFFER_BIT;
      if (depth !== true) {
        parameters.clearDepth = depth;
      }
    }
    if (stencil) {
      clearFlags |= GL_STENCIL_BUFFER_BIT;
      if (depth !== true) {
        parameters.clearStencil = depth;
      }
    }
    assert8(clearFlags !== 0, ERR_ARGUMENTS);
    withParameters(gl, parameters, () => {
      gl.clear(clearFlags);
    });
  }
  function clearBuffer(gl) {
    let {
      framebuffer = null,
      buffer = GL_COLOR,
      drawBuffer = 0,
      value = [0, 0, 0, 0]
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    assertWebGL2Context(gl);
    withParameters(gl, {
      framebuffer
    }, () => {
      switch (buffer) {
        case GL_COLOR:
          switch (value.constructor) {
            case Int32Array:
              gl.clearBufferiv(buffer, drawBuffer, value);
              break;
            case Uint32Array:
              gl.clearBufferuiv(buffer, drawBuffer, value);
              break;
            case Float32Array:
            default:
              gl.clearBufferfv(buffer, drawBuffer, value);
          }
          break;
        case GL_DEPTH:
          gl.clearBufferfv(GL_DEPTH, 0, [value]);
          break;
        case GL_STENCIL:
          gl.clearBufferiv(GL_STENCIL, 0, [value]);
          break;
        case GL_DEPTH_STENCIL:
          const [depth, stencil] = value;
          gl.clearBufferfi(GL_DEPTH_STENCIL, 0, depth, stencil);
          break;
        default:
          assert8(false, ERR_ARGUMENTS);
      }
    });
  }

  // ../../node_modules/@luma.gl/webgl/dist/esm/webgl-utils/format-utils.js
  function glFormatToComponents(format) {
    switch (format) {
      case 6406:
      case 33326:
      case 6403:
        return 1;
      case 33328:
      case 33319:
        return 2;
      case 6407:
      case 34837:
        return 3;
      case 6408:
      case 34836:
        return 4;
      default:
        assert8(false);
        return 0;
    }
  }

  // ../../node_modules/@luma.gl/webgl/dist/esm/classes/copy-and-blit.js
  function readPixelsToArray(source) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const {
      sourceX = 0,
      sourceY = 0,
      sourceFormat = 6408
    } = options;
    let {
      sourceAttachment = 36064,
      target = null,
      sourceWidth,
      sourceHeight,
      sourceType
    } = options;
    const {
      framebuffer,
      deleteFramebuffer
    } = getFramebuffer(source);
    assert8(framebuffer);
    const {
      gl,
      handle,
      attachments
    } = framebuffer;
    sourceWidth = sourceWidth || framebuffer.width;
    sourceHeight = sourceHeight || framebuffer.height;
    if (sourceAttachment === 36064 && handle === null) {
      sourceAttachment = 1028;
    }
    assert8(attachments[sourceAttachment]);
    sourceType = sourceType || attachments[sourceAttachment].type;
    target = getPixelArray(target, sourceType, sourceFormat, sourceWidth, sourceHeight);
    sourceType = sourceType || getGLTypeFromTypedArray(target);
    const prevHandle = gl.bindFramebuffer(36160, handle);
    gl.readPixels(sourceX, sourceY, sourceWidth, sourceHeight, sourceFormat, sourceType, target);
    gl.bindFramebuffer(36160, prevHandle || null);
    if (deleteFramebuffer) {
      framebuffer.delete();
    }
    return target;
  }
  function copyToDataUrl(source) {
    let {
      sourceAttachment = 36064,
      targetMaxHeight = Number.MAX_SAFE_INTEGER
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    let data = readPixelsToArray(source, {
      sourceAttachment
    });
    let {
      width,
      height
    } = source;
    while (height > targetMaxHeight) {
      ({
        data,
        width,
        height
      } = scalePixels({
        data,
        width,
        height
      }));
    }
    flipRows({
      data,
      width,
      height
    });
    const canvas = document.createElement("canvas");
    canvas.width = width;
    canvas.height = height;
    const context = canvas.getContext("2d");
    const imageData = context.createImageData(width, height);
    imageData.data.set(data);
    context.putImageData(imageData, 0, 0);
    return canvas.toDataURL();
  }
  function getFramebuffer(source) {
    if (!(source instanceof Framebuffer)) {
      return {
        framebuffer: toFramebuffer(source),
        deleteFramebuffer: true
      };
    }
    return {
      framebuffer: source,
      deleteFramebuffer: false
    };
  }
  function getPixelArray(pixelArray, type, format, width, height) {
    if (pixelArray) {
      return pixelArray;
    }
    type = type || 5121;
    const ArrayType = getTypedArrayFromGLType(type, {
      clamped: false
    });
    const components = glFormatToComponents(format);
    return new ArrayType(width * height * components);
  }

  // ../../node_modules/@luma.gl/webgl/dist/esm/features/webgl-features-table.js
  var FEATURES = {
    WEBGL2: "WEBGL2",
    VERTEX_ARRAY_OBJECT: "VERTEX_ARRAY_OBJECT",
    TIMER_QUERY: "TIMER_QUERY",
    INSTANCED_RENDERING: "INSTANCED_RENDERING",
    MULTIPLE_RENDER_TARGETS: "MULTIPLE_RENDER_TARGETS",
    ELEMENT_INDEX_UINT32: "ELEMENT_INDEX_UINT32",
    BLEND_EQUATION_MINMAX: "BLEND_EQUATION_MINMAX",
    FLOAT_BLEND: "FLOAT_BLEND",
    COLOR_ENCODING_SRGB: "COLOR_ENCODING_SRGB",
    TEXTURE_DEPTH: "TEXTURE_DEPTH",
    TEXTURE_FLOAT: "TEXTURE_FLOAT",
    TEXTURE_HALF_FLOAT: "TEXTURE_HALF_FLOAT",
    TEXTURE_FILTER_LINEAR_FLOAT: "TEXTURE_FILTER_LINEAR_FLOAT",
    TEXTURE_FILTER_LINEAR_HALF_FLOAT: "TEXTURE_FILTER_LINEAR_HALF_FLOAT",
    TEXTURE_FILTER_ANISOTROPIC: "TEXTURE_FILTER_ANISOTROPIC",
    COLOR_ATTACHMENT_RGBA32F: "COLOR_ATTACHMENT_RGBA32F",
    COLOR_ATTACHMENT_FLOAT: "COLOR_ATTACHMENT_FLOAT",
    COLOR_ATTACHMENT_HALF_FLOAT: "COLOR_ATTACHMENT_HALF_FLOAT",
    GLSL_FRAG_DATA: "GLSL_FRAG_DATA",
    GLSL_FRAG_DEPTH: "GLSL_FRAG_DEPTH",
    GLSL_DERIVATIVES: "GLSL_DERIVATIVES",
    GLSL_TEXTURE_LOD: "GLSL_TEXTURE_LOD"
  };
  function checkFloat32ColorAttachment(gl) {
    const testTexture = new Texture2D(gl, {
      format: 6408,
      type: 5126,
      dataFormat: 6408
    });
    const testFb = new Framebuffer(gl, {
      id: "test-framebuffer",
      check: false,
      attachments: {
        [36064]: testTexture
      }
    });
    const status = testFb.getStatus();
    testTexture.delete();
    testFb.delete();
    return status === 36053;
  }
  var webgl_features_table_default = {
    [FEATURES.WEBGL2]: [false, true],
    [FEATURES.VERTEX_ARRAY_OBJECT]: ["OES_vertex_array_object", true],
    [FEATURES.TIMER_QUERY]: ["EXT_disjoint_timer_query", "EXT_disjoint_timer_query_webgl2"],
    [FEATURES.INSTANCED_RENDERING]: ["ANGLE_instanced_arrays", true],
    [FEATURES.MULTIPLE_RENDER_TARGETS]: ["WEBGL_draw_buffers", true],
    [FEATURES.ELEMENT_INDEX_UINT32]: ["OES_element_index_uint", true],
    [FEATURES.BLEND_EQUATION_MINMAX]: ["EXT_blend_minmax", true],
    [FEATURES.FLOAT_BLEND]: ["EXT_float_blend"],
    [FEATURES.COLOR_ENCODING_SRGB]: ["EXT_sRGB", true],
    [FEATURES.TEXTURE_DEPTH]: ["WEBGL_depth_texture", true],
    [FEATURES.TEXTURE_FLOAT]: ["OES_texture_float", true],
    [FEATURES.TEXTURE_HALF_FLOAT]: ["OES_texture_half_float", true],
    [FEATURES.TEXTURE_FILTER_LINEAR_FLOAT]: ["OES_texture_float_linear"],
    [FEATURES.TEXTURE_FILTER_LINEAR_HALF_FLOAT]: ["OES_texture_half_float_linear"],
    [FEATURES.TEXTURE_FILTER_ANISOTROPIC]: ["EXT_texture_filter_anisotropic"],
    [FEATURES.COLOR_ATTACHMENT_RGBA32F]: [checkFloat32ColorAttachment, "EXT_color_buffer_float"],
    [FEATURES.COLOR_ATTACHMENT_FLOAT]: [false, "EXT_color_buffer_float"],
    [FEATURES.COLOR_ATTACHMENT_HALF_FLOAT]: ["EXT_color_buffer_half_float"],
    [FEATURES.GLSL_FRAG_DATA]: ["WEBGL_draw_buffers", true],
    [FEATURES.GLSL_FRAG_DEPTH]: ["EXT_frag_depth", true],
    [FEATURES.GLSL_DERIVATIVES]: ["OES_standard_derivatives", true],
    [FEATURES.GLSL_TEXTURE_LOD]: ["EXT_shader_texture_lod", true]
  };

  // ../../node_modules/@luma.gl/webgl/dist/esm/features/features.js
  var LOG_UNSUPPORTED_FEATURE = 2;
  function hasFeature(gl, feature) {
    return hasFeatures(gl, feature);
  }
  function hasFeatures(gl, features) {
    features = Array.isArray(features) ? features : [features];
    return features.every((feature) => {
      return isFeatureSupported(gl, feature);
    });
  }
  function getFeatures(gl) {
    gl.luma = gl.luma || {};
    gl.luma.caps = gl.luma.caps || {};
    for (const cap in webgl_features_table_default) {
      if (gl.luma.caps[cap] === void 0) {
        gl.luma.caps[cap] = isFeatureSupported(gl, cap);
      }
    }
    return gl.luma.caps;
  }
  function isFeatureSupported(gl, cap) {
    gl.luma = gl.luma || {};
    gl.luma.caps = gl.luma.caps || {};
    if (gl.luma.caps[cap] === void 0) {
      gl.luma.caps[cap] = queryFeature(gl, cap);
    }
    if (!gl.luma.caps[cap]) {
      log.log(LOG_UNSUPPORTED_FEATURE, "Feature: ".concat(cap, " not supported"))();
    }
    return gl.luma.caps[cap];
  }
  function queryFeature(gl, cap) {
    const feature = webgl_features_table_default[cap];
    assert8(feature, cap);
    let isSupported;
    const featureDefinition = isWebGL2(gl) ? feature[1] || feature[0] : feature[0];
    if (typeof featureDefinition === "function") {
      isSupported = featureDefinition(gl);
    } else if (Array.isArray(featureDefinition)) {
      isSupported = true;
      for (const extension of featureDefinition) {
        isSupported = isSupported && Boolean(gl.getExtension(extension));
      }
    } else if (typeof featureDefinition === "string") {
      isSupported = Boolean(gl.getExtension(featureDefinition));
    } else if (typeof featureDefinition === "boolean") {
      isSupported = featureDefinition;
    } else {
      assert8(false);
    }
    return isSupported;
  }

  // ../../node_modules/@luma.gl/webgl/dist/esm/classes/framebuffer.js
  var ERR_MULTIPLE_RENDERTARGETS = "Multiple render targets not supported";
  var Framebuffer = class extends Resource {
    get [Symbol.toStringTag]() {
      return "Framebuffer";
    }
    static isSupported(gl) {
      let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      const {
        colorBufferFloat,
        colorBufferHalfFloat
      } = options;
      let supported = true;
      if (colorBufferFloat) {
        supported = Boolean(gl.getExtension("EXT_color_buffer_float") || gl.getExtension("WEBGL_color_buffer_float") || gl.getExtension("OES_texture_float"));
      }
      if (colorBufferHalfFloat) {
        supported = supported && Boolean(gl.getExtension("EXT_color_buffer_float") || gl.getExtension("EXT_color_buffer_half_float"));
      }
      return supported;
    }
    static getDefaultFramebuffer(gl) {
      gl.luma = gl.luma || {};
      gl.luma.defaultFramebuffer = gl.luma.defaultFramebuffer || new Framebuffer(gl, {
        id: "default-framebuffer",
        handle: null,
        attachments: {}
      });
      return gl.luma.defaultFramebuffer;
    }
    get MAX_COLOR_ATTACHMENTS() {
      const gl2 = assertWebGL2Context(this.gl);
      return gl2.getParameter(gl2.MAX_COLOR_ATTACHMENTS);
    }
    get MAX_DRAW_BUFFERS() {
      const gl2 = assertWebGL2Context(this.gl);
      return gl2.getParameter(gl2.MAX_DRAW_BUFFERS);
    }
    constructor(gl) {
      let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      super(gl, opts);
      this.width = null;
      this.height = null;
      this.attachments = {};
      this.readBuffer = 36064;
      this.drawBuffers = [36064];
      this.ownResources = [];
      this.initialize(opts);
      Object.seal(this);
    }
    get color() {
      return this.attachments[36064] || null;
    }
    get texture() {
      return this.attachments[36064] || null;
    }
    get depth() {
      return this.attachments[36096] || this.attachments[33306] || null;
    }
    get stencil() {
      return this.attachments[36128] || this.attachments[33306] || null;
    }
    initialize(_ref) {
      let {
        width = 1,
        height = 1,
        attachments = null,
        color = true,
        depth = true,
        stencil = false,
        check = true,
        readBuffer = void 0,
        drawBuffers = void 0
      } = _ref;
      assert8(width >= 0 && height >= 0, "Width and height need to be integers");
      this.width = width;
      this.height = height;
      if (attachments) {
        for (const attachment in attachments) {
          const target = attachments[attachment];
          const object = Array.isArray(target) ? target[0] : target;
          object.resize({
            width,
            height
          });
        }
      } else {
        attachments = this._createDefaultAttachments(color, depth, stencil, width, height);
      }
      this.update({
        clearAttachments: true,
        attachments,
        readBuffer,
        drawBuffers
      });
      if (attachments && check) {
        this.checkStatus();
      }
    }
    delete() {
      for (const resource of this.ownResources) {
        resource.delete();
      }
      super.delete();
      return this;
    }
    update(_ref2) {
      let {
        attachments = {},
        readBuffer,
        drawBuffers,
        clearAttachments = false,
        resizeAttachments = true
      } = _ref2;
      this.attach(attachments, {
        clearAttachments,
        resizeAttachments
      });
      const {
        gl
      } = this;
      const prevHandle = gl.bindFramebuffer(36160, this.handle);
      if (readBuffer) {
        this._setReadBuffer(readBuffer);
      }
      if (drawBuffers) {
        this._setDrawBuffers(drawBuffers);
      }
      gl.bindFramebuffer(36160, prevHandle || null);
      return this;
    }
    resize() {
      let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      let {
        width,
        height
      } = options;
      if (this.handle === null) {
        assert8(width === void 0 && height === void 0);
        this.width = this.gl.drawingBufferWidth;
        this.height = this.gl.drawingBufferHeight;
        return this;
      }
      if (width === void 0) {
        width = this.gl.drawingBufferWidth;
      }
      if (height === void 0) {
        height = this.gl.drawingBufferHeight;
      }
      if (width !== this.width && height !== this.height) {
        log.log(2, "Resizing framebuffer ".concat(this.id, " to ").concat(width, "x").concat(height))();
      }
      for (const attachmentPoint in this.attachments) {
        this.attachments[attachmentPoint].resize({
          width,
          height
        });
      }
      this.width = width;
      this.height = height;
      return this;
    }
    attach(attachments) {
      let {
        clearAttachments = false,
        resizeAttachments = true
      } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      const newAttachments = {};
      if (clearAttachments) {
        Object.keys(this.attachments).forEach((key) => {
          newAttachments[key] = null;
        });
      }
      Object.assign(newAttachments, attachments);
      const prevHandle = this.gl.bindFramebuffer(36160, this.handle);
      for (const key in newAttachments) {
        assert8(key !== void 0, "Misspelled framebuffer binding point?");
        const attachment = Number(key);
        const descriptor = newAttachments[attachment];
        let object = descriptor;
        if (!object) {
          this._unattach(attachment);
        } else if (object instanceof Renderbuffer) {
          this._attachRenderbuffer({
            attachment,
            renderbuffer: object
          });
        } else if (Array.isArray(descriptor)) {
          const [texture, layer = 0, level = 0] = descriptor;
          object = texture;
          this._attachTexture({
            attachment,
            texture,
            layer,
            level
          });
        } else {
          this._attachTexture({
            attachment,
            texture: object,
            layer: 0,
            level: 0
          });
        }
        if (resizeAttachments && object) {
          object.resize({
            width: this.width,
            height: this.height
          });
        }
      }
      this.gl.bindFramebuffer(36160, prevHandle || null);
      Object.assign(this.attachments, attachments);
      Object.keys(this.attachments).filter((key) => !this.attachments[key]).forEach((key) => {
        delete this.attachments[key];
      });
    }
    checkStatus() {
      const {
        gl
      } = this;
      const status = this.getStatus();
      if (status !== 36053) {
        throw new Error(_getFrameBufferStatus(status));
      }
      return this;
    }
    getStatus() {
      const {
        gl
      } = this;
      const prevHandle = gl.bindFramebuffer(36160, this.handle);
      const status = gl.checkFramebufferStatus(36160);
      gl.bindFramebuffer(36160, prevHandle || null);
      return status;
    }
    clear() {
      let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const {
        color,
        depth,
        stencil,
        drawBuffers = []
      } = options;
      const prevHandle = this.gl.bindFramebuffer(36160, this.handle);
      if (color || depth || stencil) {
        clear(this.gl, {
          color,
          depth,
          stencil
        });
      }
      drawBuffers.forEach((value, drawBuffer) => {
        clearBuffer(this.gl, {
          drawBuffer,
          value
        });
      });
      this.gl.bindFramebuffer(36160, prevHandle || null);
      return this;
    }
    readPixels() {
      let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      log.error("Framebuffer.readPixels() is no logner supported, use readPixelsToArray(framebuffer)")();
      return null;
    }
    readPixelsToBuffer() {
      let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      log.error("Framebuffer.readPixelsToBuffer()is no logner supported, use readPixelsToBuffer(framebuffer)")();
      return null;
    }
    copyToDataUrl() {
      let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      log.error("Framebuffer.copyToDataUrl() is no logner supported, use copyToDataUrl(framebuffer)")();
      return null;
    }
    copyToImage() {
      let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      log.error("Framebuffer.copyToImage() is no logner supported, use copyToImage(framebuffer)")();
      return null;
    }
    copyToTexture() {
      let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      log.error("Framebuffer.copyToTexture({...}) is no logner supported, use copyToTexture(source, target, opts})")();
      return null;
    }
    blit() {
      let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      log.error("Framebuffer.blit({...}) is no logner supported, use blit(source, target, opts)")();
      return null;
    }
    invalidate(_ref3) {
      let {
        attachments = [],
        x: x2 = 0,
        y: y2 = 0,
        width,
        height
      } = _ref3;
      const gl2 = assertWebGL2Context(this.gl);
      const prevHandle = gl2.bindFramebuffer(36008, this.handle);
      const invalidateAll = x2 === 0 && y2 === 0 && width === void 0 && height === void 0;
      if (invalidateAll) {
        gl2.invalidateFramebuffer(36008, attachments);
      } else {
        gl2.invalidateFramebuffer(36008, attachments, x2, y2, width, height);
      }
      gl2.bindFramebuffer(36008, prevHandle);
      return this;
    }
    getAttachmentParameter(attachment, pname, keys) {
      let value = this._getAttachmentParameterFallback(pname);
      if (value === null) {
        this.gl.bindFramebuffer(36160, this.handle);
        value = this.gl.getFramebufferAttachmentParameter(36160, attachment, pname);
        this.gl.bindFramebuffer(36160, null);
      }
      if (keys && value > 1e3) {
        value = getKey(this.gl, value);
      }
      return value;
    }
    getAttachmentParameters() {
      let attachment = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 36064;
      let keys = arguments.length > 1 ? arguments[1] : void 0;
      let parameters = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.constructor.ATTACHMENT_PARAMETERS || [];
      const values = {};
      for (const pname of parameters) {
        const key = keys ? getKey(this.gl, pname) : pname;
        values[key] = this.getAttachmentParameter(attachment, pname, keys);
      }
      return values;
    }
    getParameters() {
      let keys = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
      const attachments = Object.keys(this.attachments);
      const parameters = {};
      for (const attachmentName of attachments) {
        const attachment = Number(attachmentName);
        const key = keys ? getKey(this.gl, attachment) : attachment;
        parameters[key] = this.getAttachmentParameters(attachment, keys);
      }
      return parameters;
    }
    show() {
      if (typeof window !== "undefined") {
        window.open(copyToDataUrl(this), "luma-debug-texture");
      }
      return this;
    }
    log() {
      let logLevel = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      let message = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
      if (logLevel > log.level || typeof window === "undefined") {
        return this;
      }
      message = message || "Framebuffer ".concat(this.id);
      const image = copyToDataUrl(this, {
        targetMaxHeight: 100
      });
      log.image({
        logLevel,
        message,
        image
      }, message)();
      return this;
    }
    bind() {
      let {
        target = 36160
      } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      this.gl.bindFramebuffer(target, this.handle);
      return this;
    }
    unbind() {
      let {
        target = 36160
      } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      this.gl.bindFramebuffer(target, null);
      return this;
    }
    _createDefaultAttachments(color, depth, stencil, width, height) {
      let defaultAttachments = null;
      if (color) {
        defaultAttachments = defaultAttachments || {};
        defaultAttachments[36064] = new Texture2D(this.gl, {
          id: "".concat(this.id, "-color0"),
          pixels: null,
          format: 6408,
          type: 5121,
          width,
          height,
          mipmaps: false,
          parameters: {
            [10241]: 9729,
            [10240]: 9729,
            [10242]: 33071,
            [10243]: 33071
          }
        });
        this.ownResources.push(defaultAttachments[36064]);
      }
      if (depth && stencil) {
        defaultAttachments = defaultAttachments || {};
        defaultAttachments[33306] = new Renderbuffer(this.gl, {
          id: "".concat(this.id, "-depth-stencil"),
          format: 35056,
          width,
          height: 111
        });
        this.ownResources.push(defaultAttachments[33306]);
      } else if (depth) {
        defaultAttachments = defaultAttachments || {};
        defaultAttachments[36096] = new Renderbuffer(this.gl, {
          id: "".concat(this.id, "-depth"),
          format: 33189,
          width,
          height
        });
        this.ownResources.push(defaultAttachments[36096]);
      } else if (stencil) {
        assert8(false);
      }
      return defaultAttachments;
    }
    _unattach(attachment) {
      const oldAttachment = this.attachments[attachment];
      if (!oldAttachment) {
        return;
      }
      if (oldAttachment instanceof Renderbuffer) {
        this.gl.framebufferRenderbuffer(36160, attachment, 36161, null);
      } else {
        this.gl.framebufferTexture2D(36160, attachment, 3553, null, 0);
      }
      delete this.attachments[attachment];
    }
    _attachRenderbuffer(_ref4) {
      let {
        attachment = 36064,
        renderbuffer
      } = _ref4;
      const {
        gl
      } = this;
      gl.framebufferRenderbuffer(36160, attachment, 36161, renderbuffer.handle);
      this.attachments[attachment] = renderbuffer;
    }
    _attachTexture(_ref5) {
      let {
        attachment = 36064,
        texture,
        layer,
        level
      } = _ref5;
      const {
        gl
      } = this;
      gl.bindTexture(texture.target, texture.handle);
      switch (texture.target) {
        case 35866:
        case 32879:
          const gl2 = assertWebGL2Context(gl);
          gl2.framebufferTextureLayer(36160, attachment, texture.target, level, layer);
          break;
        case 34067:
          const face = mapIndexToCubeMapFace(layer);
          gl.framebufferTexture2D(36160, attachment, face, texture.handle, level);
          break;
        case 3553:
          gl.framebufferTexture2D(36160, attachment, 3553, texture.handle, level);
          break;
        default:
          assert8(false, "Illegal texture type");
      }
      gl.bindTexture(texture.target, null);
      this.attachments[attachment] = texture;
    }
    _setReadBuffer(readBuffer) {
      const gl2 = getWebGL2Context(this.gl);
      if (gl2) {
        gl2.readBuffer(readBuffer);
      } else {
        assert8(readBuffer === 36064 || readBuffer === 1029, ERR_MULTIPLE_RENDERTARGETS);
      }
      this.readBuffer = readBuffer;
    }
    _setDrawBuffers(drawBuffers) {
      const {
        gl
      } = this;
      const gl2 = assertWebGL2Context(gl);
      if (gl2) {
        gl2.drawBuffers(drawBuffers);
      } else {
        const ext = gl.getExtension("WEBGL_draw_buffers");
        if (ext) {
          ext.drawBuffersWEBGL(drawBuffers);
        } else {
          assert8(drawBuffers.length === 1 && (drawBuffers[0] === 36064 || drawBuffers[0] === 1029), ERR_MULTIPLE_RENDERTARGETS);
        }
      }
      this.drawBuffers = drawBuffers;
    }
    _getAttachmentParameterFallback(pname) {
      const caps = getFeatures(this.gl);
      switch (pname) {
        case 36052:
          return !caps.WEBGL2 ? 0 : null;
        case 33298:
        case 33299:
        case 33300:
        case 33301:
        case 33302:
        case 33303:
          return !caps.WEBGL2 ? 8 : null;
        case 33297:
          return !caps.WEBGL2 ? 5125 : null;
        case 33296:
          return !caps.WEBGL2 && !caps.EXT_sRGB ? 9729 : null;
        default:
          return null;
      }
    }
    _createHandle() {
      return this.gl.createFramebuffer();
    }
    _deleteHandle() {
      this.gl.deleteFramebuffer(this.handle);
    }
    _bindHandle(handle) {
      return this.gl.bindFramebuffer(36160, handle);
    }
  };
  function mapIndexToCubeMapFace(layer) {
    return layer < 34069 ? layer + 34069 : layer;
  }
  function _getFrameBufferStatus(status) {
    const STATUS2 = Framebuffer.STATUS || {};
    return STATUS2[status] || "Framebuffer error ".concat(status);
  }
  var FRAMEBUFFER_ATTACHMENT_PARAMETERS = [36049, 36048, 33296, 33298, 33299, 33300, 33301, 33302, 33303];
  Framebuffer.ATTACHMENT_PARAMETERS = FRAMEBUFFER_ATTACHMENT_PARAMETERS;

  // ../../node_modules/@luma.gl/webgl/dist/esm/webgl-utils/texture-utils.js
  function toFramebuffer(texture, opts) {
    const {
      gl,
      width,
      height,
      id
    } = texture;
    const framebuffer = new Framebuffer(gl, Object.assign({}, opts, {
      id: "framebuffer-for-".concat(id),
      width,
      height,
      attachments: {
        [36064]: texture
      }
    }));
    return framebuffer;
  }

  // ../../node_modules/@luma.gl/experimental/dist/esm/gltf/gltf-material-parser.js
  var GLTFMaterialParser = class {
    constructor(gl, _ref) {
      let {
        attributes,
        material,
        pbrDebug,
        imageBasedLightingEnvironment,
        lights,
        useTangents
      } = _ref;
      this.gl = gl;
      this.defines = {
        MANUAL_SRGB: 1,
        SRGB_FAST_APPROXIMATION: 1
      };
      if (hasFeature(gl, FEATURES.GLSL_TEXTURE_LOD)) {
        this.defines.USE_TEX_LOD = 1;
      }
      this.uniforms = {
        u_Camera: [0, 0, 0],
        u_MetallicRoughnessValues: [1, 1]
      };
      this.parameters = {};
      this.generatedTextures = [];
      if (imageBasedLightingEnvironment) {
        this.uniforms.u_DiffuseEnvSampler = imageBasedLightingEnvironment.getDiffuseEnvSampler();
        this.uniforms.u_SpecularEnvSampler = imageBasedLightingEnvironment.getSpecularEnvSampler();
        this.uniforms.u_brdfLUT = imageBasedLightingEnvironment.getBrdfTexture();
        this.uniforms.u_ScaleIBLAmbient = [1, 1];
      }
      if (pbrDebug) {
        this.uniforms.u_ScaleDiffBaseMR = [0, 0, 0, 0];
        this.uniforms.u_ScaleFGDSpec = [0, 0, 0, 0];
      }
      this.defineIfPresent(attributes.NORMAL, "HAS_NORMALS");
      this.defineIfPresent(attributes.TANGENT && useTangents, "HAS_TANGENTS");
      this.defineIfPresent(attributes.TEXCOORD_0, "HAS_UV");
      this.defineIfPresent(imageBasedLightingEnvironment, "USE_IBL");
      this.defineIfPresent(lights, "USE_LIGHTS");
      this.defineIfPresent(pbrDebug, "PBR_DEBUG");
      if (material) {
        this.parseMaterial(material);
      }
    }
    defineIfPresent(value, name10) {
      if (value) {
        this.defines[name10] = 1;
      }
    }
    parseTexture(gltfTexture, name10) {
      let define2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
      const parameters = gltfTexture.texture && gltfTexture.texture.sampler && gltfTexture.texture.sampler.parameters || {};
      const image = gltfTexture.texture.source.image;
      let textureOptions;
      let specialTextureParameters = {};
      if (image.compressed) {
        textureOptions = image;
        specialTextureParameters = {
          [this.gl.TEXTURE_MIN_FILTER]: image.data.length > 1 ? this.gl.LINEAR_MIPMAP_NEAREST : this.gl.LINEAR
        };
      } else {
        textureOptions = {
          data: image
        };
      }
      const texture = new Texture2D(this.gl, {
        id: gltfTexture.name || gltfTexture.id,
        parameters: {
          ...parameters,
          ...specialTextureParameters
        },
        pixelStore: {
          [this.gl.UNPACK_FLIP_Y_WEBGL]: false
        },
        ...textureOptions
      });
      this.uniforms[name10] = texture;
      this.defineIfPresent(define2, define2);
      this.generatedTextures.push(texture);
    }
    parsePbrMetallicRoughness(pbrMetallicRoughness) {
      if (pbrMetallicRoughness.baseColorTexture) {
        this.parseTexture(pbrMetallicRoughness.baseColorTexture, "u_BaseColorSampler", "HAS_BASECOLORMAP");
      }
      this.uniforms.u_BaseColorFactor = pbrMetallicRoughness.baseColorFactor || [1, 1, 1, 1];
      if (pbrMetallicRoughness.metallicRoughnessTexture) {
        this.parseTexture(pbrMetallicRoughness.metallicRoughnessTexture, "u_MetallicRoughnessSampler", "HAS_METALROUGHNESSMAP");
      }
      const {
        metallicFactor = 1,
        roughnessFactor = 1
      } = pbrMetallicRoughness;
      this.uniforms.u_MetallicRoughnessValues = [metallicFactor, roughnessFactor];
    }
    parseMaterial(material) {
      this.uniforms.pbr_uUnlit = Boolean(material.unlit);
      if (material.pbrMetallicRoughness) {
        this.parsePbrMetallicRoughness(material.pbrMetallicRoughness);
      }
      if (material.normalTexture) {
        this.parseTexture(material.normalTexture, "u_NormalSampler", "HAS_NORMALMAP");
        const {
          scale: scale5 = 1
        } = material.normalTexture;
        this.uniforms.u_NormalScale = scale5;
      }
      if (material.occlusionTexture) {
        this.parseTexture(material.occlusionTexture, "u_OcclusionSampler", "HAS_OCCLUSIONMAP");
        const {
          strength = 1
        } = material.occlusionTexture;
        this.uniforms.u_OcclusionStrength = strength;
      }
      if (material.emissiveTexture) {
        this.parseTexture(material.emissiveTexture, "u_EmissiveSampler", "HAS_EMISSIVEMAP");
        this.uniforms.u_EmissiveFactor = material.emissiveFactor || [0, 0, 0];
      }
      if (material.alphaMode === "MASK") {
        const {
          alphaCutoff = 0.5
        } = material;
        this.defines.ALPHA_CUTOFF = 1;
        this.uniforms.u_AlphaCutoff = alphaCutoff;
      } else if (material.alphaMode === "BLEND") {
        log.warn("BLEND alphaMode might not work well because it requires mesh sorting")();
        Object.assign(this.parameters, {
          blend: true,
          blendEquation: this.gl.FUNC_ADD,
          blendFunc: [this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA, this.gl.ONE, this.gl.ONE_MINUS_SRC_ALPHA]
        });
      }
    }
    delete() {
      this.generatedTextures.forEach((texture) => texture.delete());
    }
  };

  // src/mesh-layer/mesh-layer.ts
  var import_core18 = __toESM(require_core2());
  var import_mesh_layers = __toESM(require_mesh_layers());

  // src/mesh-layer/mesh-layer-vertex.glsl.ts
  var mesh_layer_vertex_glsl_default = `#version 300 es
#define SHADER_NAME simple-mesh-layer-vs

// Scale the model
uniform float sizeScale;
uniform bool composeModelMatrix;
uniform bool pickFeatureIds;

// Primitive attributes
in vec3 positions;
in vec3 normals;
in vec3 colors;
in vec2 texCoords;
in vec4 uvRegions;
in vec3 featureIdsPickingColors;

// Instance attributes
in vec4 instanceColors;
in vec3 instancePickingColors;
in mat3 instanceModelMatrix;

// Outputs to fragment shader
out vec2 vTexCoord;
out vec3 cameraPosition;
out vec3 normals_commonspace;
out vec4 position_commonspace;
out vec4 vColor;

vec2 applyUVRegion(vec2 uv) {
  #ifdef HAS_UV_REGIONS
    // https://github.com/Esri/i3s-spec/blob/master/docs/1.7/geometryUVRegion.cmn.md
    return fract(uv) * (uvRegions.zw - uvRegions.xy) + uvRegions.xy;
  #else
    return uv;
  #endif
}

void main(void) {
  vec2 uv = applyUVRegion(texCoords);
  geometry.uv = uv;

  if (pickFeatureIds) {
    geometry.pickingColor = featureIdsPickingColors;
  } else {
    geometry.pickingColor = instancePickingColors;
  }

  vTexCoord = uv;
  cameraPosition = project_uCameraPosition;
  vColor = vec4(colors * instanceColors.rgb, instanceColors.a);

  vec3 pos = (instanceModelMatrix * positions) * sizeScale;
  vec3 projectedPosition = project_position(positions);
  position_commonspace = vec4(projectedPosition, 1.0);
  gl_Position = project_common_position_to_clipspace(position_commonspace);

  geometry.position = position_commonspace;
  normals_commonspace = project_normal(instanceModelMatrix * normals);
  geometry.normal = normals_commonspace;

  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);

  #ifdef MODULE_PBR
    // set PBR data
    pbr_vPosition = geometry.position.xyz;
    #ifdef HAS_NORMALS
      pbr_vNormal = geometry.normal;
    #endif

    #ifdef HAS_UV
      pbr_vUV = uv;
    #else
      pbr_vUV = vec2(0., 0.);
    #endif
    geometry.uv = pbr_vUV;
  #endif

  DECKGL_FILTER_COLOR(vColor, geometry);
}
`;

  // src/mesh-layer/mesh-layer-fragment.glsl.ts
  var mesh_layer_fragment_glsl_default = `#version 300 es
#define SHADER_NAME simple-mesh-layer-fs

precision highp float;

uniform bool hasTexture;
uniform sampler2D sampler;
uniform bool flatShading;
uniform float opacity;

in vec2 vTexCoord;
in vec3 cameraPosition;
in vec3 normals_commonspace;
in vec4 position_commonspace;
in vec4 vColor;

out vec4 fragColor;

void main(void) {
  
#ifdef MODULE_PBR

  fragColor = vColor * pbr_filterColor(vec4(0));
  geometry.uv = pbr_vUV;
  fragColor.a *= opacity;

#else

  geometry.uv = vTexCoord;

  vec3 normal;
  if (flatShading) {

// NOTE(Tarek): This is necessary because
// headless.gl reports the extension as
// available but does not support it in
// the shader.
#ifdef DERIVATIVES_AVAILABLE
    normal = normalize(cross(dFdx(position_commonspace.xyz), dFdy(position_commonspace.xyz)));
#else
    normal = vec3(0.0, 0.0, 1.0);
#endif
  } else {
    normal = normals_commonspace;
  }

  vec4 color = hasTexture ? texture(sampler, vTexCoord) : vColor;
  vec3 lightColor = lighting_getLightColor(color.rgb, cameraPosition, position_commonspace.xyz, normal);
  fragColor = vec4(lightColor, color.a * opacity);

#endif

  DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;

  // src/mesh-layer/mesh-layer.ts
  function validateGeometryAttributes(attributes) {
    const hasColorAttribute = attributes.COLOR_0 || attributes.colors;
    if (!hasColorAttribute) {
      attributes.colors = {
        constant: true,
        value: new Float32Array([1, 1, 1])
      };
    }
  }
  var defaultProps10 = {
    pbrMaterial: {
      type: "object",
      value: null
    },
    featureIds: {
      type: "array",
      value: null,
      optional: true
    }
  };
  var MeshLayer = class extends import_mesh_layers.SimpleMeshLayer {
    getShaders() {
      const shaders = super.getShaders();
      const modules = shaders.modules;
      modules.push(import_core18.pbr);
      return {
        ...shaders,
        vs: mesh_layer_vertex_glsl_default,
        fs: mesh_layer_fragment_glsl_default
      };
    }
    initializeState() {
      const {
        featureIds
      } = this.props;
      super.initializeState();
      const attributeManager = this.getAttributeManager();
      if (featureIds) {
        attributeManager.add({
          featureIdsPickingColors: {
            type: esm_default.UNSIGNED_BYTE,
            size: 3,
            noAlloc: true,
            update: this.calculateFeatureIdsPickingColors
          }
        });
      }
    }
    updateState(params) {
      super.updateState(params);
      const {
        props,
        oldProps
      } = params;
      if (props.pbrMaterial !== oldProps.pbrMaterial) {
        this.updatePbrMaterialUniforms(props.pbrMaterial);
      }
    }
    draw(opts) {
      const {
        featureIds
      } = this.props;
      if (!this.state.model) {
        return;
      }
      this.state.model.setUniforms({
        u_Camera: this.state.model.getUniforms().project_uCameraPosition,
        pickFeatureIds: Boolean(featureIds)
      });
      super.draw(opts);
    }
    getModel(mesh) {
      const {
        id,
        pbrMaterial
      } = this.props;
      const materialParser = this.parseMaterial(pbrMaterial, mesh);
      this.setState({
        materialParser
      });
      const shaders = this.getShaders();
      validateGeometryAttributes(mesh.attributes);
      const model = new import_core18.Model(this.context.gl, {
        ...this.getShaders(),
        id,
        geometry: mesh,
        defines: {
          ...shaders.defines,
          ...materialParser?.defines,
          HAS_UV_REGIONS: mesh.attributes.uvRegions
        },
        parameters: materialParser?.parameters,
        isInstanced: true
      });
      return model;
    }
    updatePbrMaterialUniforms(pbrMaterial) {
      const {
        model
      } = this.state;
      if (model) {
        const {
          mesh
        } = this.props;
        const materialParser = this.parseMaterial(pbrMaterial, mesh);
        this.setState({
          materialParser
        });
        model.setUniforms(materialParser.uniforms);
      }
    }
    parseMaterial(pbrMaterial, mesh) {
      const unlit = Boolean(pbrMaterial.pbrMetallicRoughness && pbrMaterial.pbrMetallicRoughness.baseColorTexture);
      this.state.materialParser?.delete();
      return new GLTFMaterialParser(this.context.gl, {
        attributes: {
          NORMAL: mesh.attributes.normals,
          TEXCOORD_0: mesh.attributes.texCoords
        },
        material: {
          unlit,
          ...pbrMaterial
        },
        pbrDebug: false,
        imageBasedLightingEnvironment: null,
        lights: true,
        useTangents: false
      });
    }
    calculateFeatureIdsPickingColors(attribute) {
      const featureIds = this.props.featureIds;
      const value = new Uint8ClampedArray(featureIds.length * attribute.size);
      const pickingColor = [];
      for (let index = 0; index < featureIds.length; index++) {
        this.encodePickingColor(featureIds[index], pickingColor);
        value[index * 3] = pickingColor[0];
        value[index * 3 + 1] = pickingColor[1];
        value[index * 3 + 2] = pickingColor[2];
      }
      attribute.value = value;
    }
    finalizeState(context) {
      super.finalizeState(context);
      this.state.materialParser?.delete();
      this.setState({
        materialParser: null
      });
    }
  };
  __publicField(MeshLayer, "layerName", "MeshLayer");
  __publicField(MeshLayer, "defaultProps", defaultProps10);

  // src/tile-3d-layer/tile-3d-layer.ts
  var import_core43 = __toESM(require_core3());

  // ../../node_modules/@math.gl/geospatial/node_modules/@babel/runtime/helpers/esm/defineProperty.js
  function _defineProperty4(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }

  // ../../node_modules/@math.gl/geospatial/dist/esm/constants.js
  var WGS84_RADIUS_X = 6378137;
  var WGS84_RADIUS_Y = 6378137;
  var WGS84_RADIUS_Z = 6356752314245179e-9;
  var WGS84_CONSTANTS = {
    radii: [WGS84_RADIUS_X, WGS84_RADIUS_Y, WGS84_RADIUS_Z],
    radiiSquared: [WGS84_RADIUS_X * WGS84_RADIUS_X, WGS84_RADIUS_Y * WGS84_RADIUS_Y, WGS84_RADIUS_Z * WGS84_RADIUS_Z],
    oneOverRadii: [1 / WGS84_RADIUS_X, 1 / WGS84_RADIUS_Y, 1 / WGS84_RADIUS_Z],
    oneOverRadiiSquared: [1 / (WGS84_RADIUS_X * WGS84_RADIUS_X), 1 / (WGS84_RADIUS_Y * WGS84_RADIUS_Y), 1 / (WGS84_RADIUS_Z * WGS84_RADIUS_Z)],
    maximumRadius: Math.max(WGS84_RADIUS_X, WGS84_RADIUS_Y, WGS84_RADIUS_Z),
    centerToleranceSquared: 0.1
  };

  // ../../node_modules/@math.gl/geospatial/dist/esm/type-utils.js
  function identity3(x2) {
    return x2;
  }
  var scratchVector7 = new Vector3();
  function fromCartographic(cartographic, result = [], map2 = identity3) {
    if ("longitude" in cartographic) {
      result[0] = map2(cartographic.longitude);
      result[1] = map2(cartographic.latitude);
      result[2] = cartographic.height;
    } else if ("x" in cartographic) {
      result[0] = map2(cartographic.x);
      result[1] = map2(cartographic.y);
      result[2] = cartographic.z;
    } else {
      result[0] = map2(cartographic[0]);
      result[1] = map2(cartographic[1]);
      result[2] = cartographic[2];
    }
    return result;
  }
  function fromCartographicToRadians(cartographic, vector = []) {
    return fromCartographic(cartographic, vector, config._cartographicRadians ? identity3 : toRadians);
  }
  function toCartographic(vector, cartographic, map2 = identity3) {
    if ("longitude" in cartographic) {
      cartographic.longitude = map2(vector[0]);
      cartographic.latitude = map2(vector[1]);
      cartographic.height = vector[2];
    } else if ("x" in cartographic) {
      cartographic.x = map2(vector[0]);
      cartographic.y = map2(vector[1]);
      cartographic.z = vector[2];
    } else {
      cartographic[0] = map2(vector[0]);
      cartographic[1] = map2(vector[1]);
      cartographic[2] = vector[2];
    }
    return cartographic;
  }
  function toCartographicFromRadians(vector, cartographic) {
    return toCartographic(vector, cartographic, config._cartographicRadians ? identity3 : toDegrees);
  }

  // ../../node_modules/@math.gl/geospatial/dist/esm/ellipsoid/helpers/scale-to-geodetic-surface.js
  var scratchVector8 = new Vector3();
  var scaleToGeodeticSurfaceIntersection = new Vector3();
  var scaleToGeodeticSurfaceGradient = new Vector3();
  function scaleToGeodeticSurface(cartesian, ellipsoid, result = []) {
    const {
      oneOverRadii,
      oneOverRadiiSquared,
      centerToleranceSquared
    } = ellipsoid;
    scratchVector8.from(cartesian);
    const positionX = scratchVector8.x;
    const positionY = scratchVector8.y;
    const positionZ = scratchVector8.z;
    const oneOverRadiiX = oneOverRadii.x;
    const oneOverRadiiY = oneOverRadii.y;
    const oneOverRadiiZ = oneOverRadii.z;
    const x2 = positionX * positionX * oneOverRadiiX * oneOverRadiiX;
    const y2 = positionY * positionY * oneOverRadiiY * oneOverRadiiY;
    const z2 = positionZ * positionZ * oneOverRadiiZ * oneOverRadiiZ;
    const squaredNorm = x2 + y2 + z2;
    const ratio = Math.sqrt(1 / squaredNorm);
    if (!Number.isFinite(ratio)) {
      return void 0;
    }
    const intersection = scaleToGeodeticSurfaceIntersection;
    intersection.copy(cartesian).scale(ratio);
    if (squaredNorm < centerToleranceSquared) {
      return intersection.to(result);
    }
    const oneOverRadiiSquaredX = oneOverRadiiSquared.x;
    const oneOverRadiiSquaredY = oneOverRadiiSquared.y;
    const oneOverRadiiSquaredZ = oneOverRadiiSquared.z;
    const gradient = scaleToGeodeticSurfaceGradient;
    gradient.set(intersection.x * oneOverRadiiSquaredX * 2, intersection.y * oneOverRadiiSquaredY * 2, intersection.z * oneOverRadiiSquaredZ * 2);
    let lambda = (1 - ratio) * scratchVector8.len() / (0.5 * gradient.len());
    let correction = 0;
    let xMultiplier;
    let yMultiplier;
    let zMultiplier;
    let func;
    do {
      lambda -= correction;
      xMultiplier = 1 / (1 + lambda * oneOverRadiiSquaredX);
      yMultiplier = 1 / (1 + lambda * oneOverRadiiSquaredY);
      zMultiplier = 1 / (1 + lambda * oneOverRadiiSquaredZ);
      const xMultiplier2 = xMultiplier * xMultiplier;
      const yMultiplier2 = yMultiplier * yMultiplier;
      const zMultiplier2 = zMultiplier * zMultiplier;
      const xMultiplier3 = xMultiplier2 * xMultiplier;
      const yMultiplier3 = yMultiplier2 * yMultiplier;
      const zMultiplier3 = zMultiplier2 * zMultiplier;
      func = x2 * xMultiplier2 + y2 * yMultiplier2 + z2 * zMultiplier2 - 1;
      const denominator = x2 * xMultiplier3 * oneOverRadiiSquaredX + y2 * yMultiplier3 * oneOverRadiiSquaredY + z2 * zMultiplier3 * oneOverRadiiSquaredZ;
      const derivative = -2 * denominator;
      correction = func / derivative;
    } while (Math.abs(func) > math_utils_default.EPSILON12);
    return scratchVector8.scale([xMultiplier, yMultiplier, zMultiplier]).to(result);
  }

  // ../../node_modules/@math.gl/geospatial/dist/esm/ellipsoid/helpers/ellipsoid-transform.js
  var EPSILON14 = 1e-14;
  var scratchOrigin = new Vector3();
  var VECTOR_PRODUCT_LOCAL_FRAME = {
    up: {
      south: "east",
      north: "west",
      west: "south",
      east: "north"
    },
    down: {
      south: "west",
      north: "east",
      west: "north",
      east: "south"
    },
    south: {
      up: "west",
      down: "east",
      west: "down",
      east: "up"
    },
    north: {
      up: "east",
      down: "west",
      west: "up",
      east: "down"
    },
    west: {
      up: "north",
      down: "south",
      north: "down",
      south: "up"
    },
    east: {
      up: "south",
      down: "north",
      north: "up",
      south: "down"
    }
  };
  var degeneratePositionLocalFrame = {
    north: [-1, 0, 0],
    east: [0, 1, 0],
    up: [0, 0, 1],
    south: [1, 0, 0],
    west: [0, -1, 0],
    down: [0, 0, -1]
  };
  var scratchAxisVectors = {
    east: new Vector3(),
    north: new Vector3(),
    up: new Vector3(),
    west: new Vector3(),
    south: new Vector3(),
    down: new Vector3()
  };
  var scratchVector1 = new Vector3();
  var scratchVector24 = new Vector3();
  var scratchVector33 = new Vector3();
  function localFrameToFixedFrame(ellipsoid, firstAxis, secondAxis, thirdAxis, cartesianOrigin, result) {
    const thirdAxisInferred = VECTOR_PRODUCT_LOCAL_FRAME[firstAxis] && VECTOR_PRODUCT_LOCAL_FRAME[firstAxis][secondAxis];
    assert5(thirdAxisInferred && (!thirdAxis || thirdAxis === thirdAxisInferred));
    let firstAxisVector;
    let secondAxisVector;
    let thirdAxisVector;
    const origin = scratchOrigin.copy(cartesianOrigin);
    const atPole = equals(origin.x, 0, EPSILON14) && equals(origin.y, 0, EPSILON14);
    if (atPole) {
      const sign2 = Math.sign(origin.z);
      firstAxisVector = scratchVector1.fromArray(degeneratePositionLocalFrame[firstAxis]);
      if (firstAxis !== "east" && firstAxis !== "west") {
        firstAxisVector.scale(sign2);
      }
      secondAxisVector = scratchVector24.fromArray(degeneratePositionLocalFrame[secondAxis]);
      if (secondAxis !== "east" && secondAxis !== "west") {
        secondAxisVector.scale(sign2);
      }
      thirdAxisVector = scratchVector33.fromArray(degeneratePositionLocalFrame[thirdAxis]);
      if (thirdAxis !== "east" && thirdAxis !== "west") {
        thirdAxisVector.scale(sign2);
      }
    } else {
      const {
        up,
        east,
        north
      } = scratchAxisVectors;
      east.set(-origin.y, origin.x, 0).normalize();
      ellipsoid.geodeticSurfaceNormal(origin, up);
      north.copy(up).cross(east);
      const {
        down,
        west,
        south
      } = scratchAxisVectors;
      down.copy(up).scale(-1);
      west.copy(east).scale(-1);
      south.copy(north).scale(-1);
      firstAxisVector = scratchAxisVectors[firstAxis];
      secondAxisVector = scratchAxisVectors[secondAxis];
      thirdAxisVector = scratchAxisVectors[thirdAxis];
    }
    result[0] = firstAxisVector.x;
    result[1] = firstAxisVector.y;
    result[2] = firstAxisVector.z;
    result[3] = 0;
    result[4] = secondAxisVector.x;
    result[5] = secondAxisVector.y;
    result[6] = secondAxisVector.z;
    result[7] = 0;
    result[8] = thirdAxisVector.x;
    result[9] = thirdAxisVector.y;
    result[10] = thirdAxisVector.z;
    result[11] = 0;
    result[12] = origin.x;
    result[13] = origin.y;
    result[14] = origin.z;
    result[15] = 1;
    return result;
  }

  // ../../node_modules/@math.gl/geospatial/dist/esm/ellipsoid/ellipsoid.js
  var scratchVector9 = new Vector3();
  var scratchNormal3 = new Vector3();
  var scratchK = new Vector3();
  var scratchPosition2 = new Vector3();
  var scratchHeight = new Vector3();
  var scratchCartesian = new Vector3();
  var Ellipsoid = class {
    constructor(x2 = 0, y2 = 0, z = 0) {
      _defineProperty4(this, "radii", void 0);
      _defineProperty4(this, "radiiSquared", void 0);
      _defineProperty4(this, "radiiToTheFourth", void 0);
      _defineProperty4(this, "oneOverRadii", void 0);
      _defineProperty4(this, "oneOverRadiiSquared", void 0);
      _defineProperty4(this, "minimumRadius", void 0);
      _defineProperty4(this, "maximumRadius", void 0);
      _defineProperty4(this, "centerToleranceSquared", math_utils_default.EPSILON1);
      _defineProperty4(this, "squaredXOverSquaredZ", void 0);
      assert5(x2 >= 0);
      assert5(y2 >= 0);
      assert5(z >= 0);
      this.radii = new Vector3(x2, y2, z);
      this.radiiSquared = new Vector3(x2 * x2, y2 * y2, z * z);
      this.radiiToTheFourth = new Vector3(x2 * x2 * x2 * x2, y2 * y2 * y2 * y2, z * z * z * z);
      this.oneOverRadii = new Vector3(x2 === 0 ? 0 : 1 / x2, y2 === 0 ? 0 : 1 / y2, z === 0 ? 0 : 1 / z);
      this.oneOverRadiiSquared = new Vector3(x2 === 0 ? 0 : 1 / (x2 * x2), y2 === 0 ? 0 : 1 / (y2 * y2), z === 0 ? 0 : 1 / (z * z));
      this.minimumRadius = Math.min(x2, y2, z);
      this.maximumRadius = Math.max(x2, y2, z);
      if (this.radiiSquared.z !== 0) {
        this.squaredXOverSquaredZ = this.radiiSquared.x / this.radiiSquared.z;
      }
      Object.freeze(this);
    }
    equals(right) {
      return this === right || Boolean(right && this.radii.equals(right.radii));
    }
    toString() {
      return this.radii.toString();
    }
    cartographicToCartesian(cartographic, result = [0, 0, 0]) {
      const normal = scratchNormal3;
      const k = scratchK;
      const [, , height] = cartographic;
      this.geodeticSurfaceNormalCartographic(cartographic, normal);
      k.copy(this.radiiSquared).scale(normal);
      const gamma = Math.sqrt(normal.dot(k));
      k.scale(1 / gamma);
      normal.scale(height);
      k.add(normal);
      return k.to(result);
    }
    cartesianToCartographic(cartesian, result = [0, 0, 0]) {
      scratchCartesian.from(cartesian);
      const point = this.scaleToGeodeticSurface(scratchCartesian, scratchPosition2);
      if (!point) {
        return void 0;
      }
      const normal = this.geodeticSurfaceNormal(point, scratchNormal3);
      const h = scratchHeight;
      h.copy(scratchCartesian).subtract(point);
      const longitude = Math.atan2(normal.y, normal.x);
      const latitude = Math.asin(normal.z);
      const height = Math.sign(dot2(h, scratchCartesian)) * length2(h);
      return toCartographicFromRadians([longitude, latitude, height], result);
    }
    eastNorthUpToFixedFrame(origin, result = new Matrix4()) {
      return localFrameToFixedFrame(this, "east", "north", "up", origin, result);
    }
    localFrameToFixedFrame(firstAxis, secondAxis, thirdAxis, origin, result = new Matrix4()) {
      return localFrameToFixedFrame(this, firstAxis, secondAxis, thirdAxis, origin, result);
    }
    geocentricSurfaceNormal(cartesian, result = [0, 0, 0]) {
      return scratchVector9.from(cartesian).normalize().to(result);
    }
    geodeticSurfaceNormalCartographic(cartographic, result = [0, 0, 0]) {
      const cartographicVectorRadians = fromCartographicToRadians(cartographic);
      const longitude = cartographicVectorRadians[0];
      const latitude = cartographicVectorRadians[1];
      const cosLatitude = Math.cos(latitude);
      scratchVector9.set(cosLatitude * Math.cos(longitude), cosLatitude * Math.sin(longitude), Math.sin(latitude)).normalize();
      return scratchVector9.to(result);
    }
    geodeticSurfaceNormal(cartesian, result = [0, 0, 0]) {
      return scratchVector9.from(cartesian).scale(this.oneOverRadiiSquared).normalize().to(result);
    }
    scaleToGeodeticSurface(cartesian, result) {
      return scaleToGeodeticSurface(cartesian, this, result);
    }
    scaleToGeocentricSurface(cartesian, result = [0, 0, 0]) {
      scratchPosition2.from(cartesian);
      const positionX = scratchPosition2.x;
      const positionY = scratchPosition2.y;
      const positionZ = scratchPosition2.z;
      const oneOverRadiiSquared = this.oneOverRadiiSquared;
      const beta = 1 / Math.sqrt(positionX * positionX * oneOverRadiiSquared.x + positionY * positionY * oneOverRadiiSquared.y + positionZ * positionZ * oneOverRadiiSquared.z);
      return scratchPosition2.multiplyScalar(beta).to(result);
    }
    transformPositionToScaledSpace(position, result = [0, 0, 0]) {
      return scratchPosition2.from(position).scale(this.oneOverRadii).to(result);
    }
    transformPositionFromScaledSpace(position, result = [0, 0, 0]) {
      return scratchPosition2.from(position).scale(this.radii).to(result);
    }
    getSurfaceNormalIntersectionWithZAxis(position, buffer = 0, result = [0, 0, 0]) {
      assert5(equals(this.radii.x, this.radii.y, math_utils_default.EPSILON15));
      assert5(this.radii.z > 0);
      scratchPosition2.from(position);
      const z = scratchPosition2.z * (1 - this.squaredXOverSquaredZ);
      if (Math.abs(z) >= this.radii.z - buffer) {
        return void 0;
      }
      return scratchPosition2.set(0, 0, z).to(result);
    }
  };
  _defineProperty4(Ellipsoid, "WGS84", new Ellipsoid(WGS84_RADIUS_X, WGS84_RADIUS_Y, WGS84_RADIUS_Z));

  // ../../node_modules/@loaders.gl/tiles/dist/esm/utils/doubly-linked-list-node.js
  var DoublyLinkedListNode = class {
    constructor(item, previous, next) {
      _defineProperty(this, "item", void 0);
      _defineProperty(this, "previous", void 0);
      _defineProperty(this, "next", void 0);
      this.item = item;
      this.previous = previous;
      this.next = next;
    }
  };

  // ../../node_modules/@loaders.gl/tiles/dist/esm/utils/doubly-linked-list.js
  var DoublyLinkedList = class {
    constructor() {
      _defineProperty(this, "head", null);
      _defineProperty(this, "tail", null);
      _defineProperty(this, "_length", 0);
    }
    get length() {
      return this._length;
    }
    add(item) {
      const node2 = new DoublyLinkedListNode(item, this.tail, null);
      if (this.tail) {
        this.tail.next = node2;
        this.tail = node2;
      } else {
        this.head = node2;
        this.tail = node2;
      }
      ++this._length;
      return node2;
    }
    remove(node2) {
      if (!node2) {
        return;
      }
      if (node2.previous && node2.next) {
        node2.previous.next = node2.next;
        node2.next.previous = node2.previous;
      } else if (node2.previous) {
        node2.previous.next = null;
        this.tail = node2.previous;
      } else if (node2.next) {
        node2.next.previous = null;
        this.head = node2.next;
      } else {
        this.head = null;
        this.tail = null;
      }
      node2.next = null;
      node2.previous = null;
      --this._length;
    }
    splice(node2, nextNode) {
      if (node2 === nextNode) {
        return;
      }
      this.remove(nextNode);
      this._insert(node2, nextNode);
    }
    _insert(node2, nextNode) {
      const oldNodeNext = node2.next;
      node2.next = nextNode;
      if (this.tail === node2) {
        this.tail = nextNode;
      } else {
        oldNodeNext.previous = nextNode;
      }
      nextNode.next = oldNodeNext;
      nextNode.previous = node2;
      ++this._length;
    }
  };

  // ../../node_modules/@loaders.gl/tiles/dist/esm/tileset/tileset-cache.js
  function defined(x2) {
    return x2 !== void 0 && x2 !== null;
  }
  var TilesetCache = class {
    constructor() {
      _defineProperty(this, "_list", void 0);
      _defineProperty(this, "_sentinel", void 0);
      _defineProperty(this, "_trimTiles", void 0);
      this._list = new DoublyLinkedList();
      this._sentinel = this._list.add("sentinel");
      this._trimTiles = false;
    }
    reset() {
      this._list.splice(this._list.tail, this._sentinel);
    }
    touch(tile) {
      const node2 = tile._cacheNode;
      if (defined(node2)) {
        this._list.splice(this._sentinel, node2);
      }
    }
    add(tileset, tile, addCallback) {
      if (!defined(tile._cacheNode)) {
        tile._cacheNode = this._list.add(tile);
        if (addCallback) {
          addCallback(tileset, tile);
        }
      }
    }
    unloadTile(tileset, tile, unloadCallback) {
      const node2 = tile._cacheNode;
      if (!defined(node2)) {
        return;
      }
      this._list.remove(node2);
      tile._cacheNode = void 0;
      if (unloadCallback) {
        unloadCallback(tileset, tile);
      }
    }
    unloadTiles(tileset, unloadCallback) {
      const trimTiles = this._trimTiles;
      this._trimTiles = false;
      const list = this._list;
      const maximumMemoryUsageInBytes = tileset.maximumMemoryUsage * 1024 * 1024;
      const sentinel = this._sentinel;
      let node2 = list.head;
      while (node2 !== sentinel && (tileset.gpuMemoryUsageInBytes > maximumMemoryUsageInBytes || trimTiles)) {
        const tile = node2.item;
        node2 = node2.next;
        this.unloadTile(tileset, tile, unloadCallback);
      }
    }
    trim() {
      this._trimTiles = true;
    }
  };

  // ../../node_modules/@loaders.gl/tiles/dist/esm/tileset/helpers/transform-utils.js
  function calculateTransformProps(tileHeader, tile) {
    assert2(tileHeader);
    assert2(tile);
    const {
      rtcCenter,
      gltfUpAxis
    } = tile;
    const {
      computedTransform,
      boundingVolume: {
        center
      }
    } = tileHeader;
    let modelMatrix = new Matrix4(computedTransform);
    if (rtcCenter) {
      modelMatrix.translate(rtcCenter);
    }
    switch (gltfUpAxis) {
      case "Z":
        break;
      case "Y":
        const rotationY = new Matrix4().rotateX(Math.PI / 2);
        modelMatrix = modelMatrix.multiplyRight(rotationY);
        break;
      case "X":
        const rotationX = new Matrix4().rotateY(-Math.PI / 2);
        modelMatrix = modelMatrix.multiplyRight(rotationX);
        break;
      default:
        break;
    }
    if (tile.isQuantized) {
      modelMatrix.translate(tile.quantizedVolumeOffset).scale(tile.quantizedVolumeScale);
    }
    const cartesianOrigin = new Vector3(center);
    tile.cartesianModelMatrix = modelMatrix;
    tile.cartesianOrigin = cartesianOrigin;
    const cartographicOrigin = Ellipsoid.WGS84.cartesianToCartographic(cartesianOrigin, new Vector3());
    const fromFixedFrameMatrix = Ellipsoid.WGS84.eastNorthUpToFixedFrame(cartesianOrigin);
    const toFixedFrameMatrix = fromFixedFrameMatrix.invert();
    tile.cartographicModelMatrix = toFixedFrameMatrix.multiplyRight(modelMatrix);
    tile.cartographicOrigin = cartographicOrigin;
    if (!tile.coordinateSystem) {
      tile.modelMatrix = tile.cartographicModelMatrix;
    }
  }

  // ../../node_modules/@loaders.gl/tiles/dist/esm/tileset/helpers/frame-state.js
  var scratchVector10 = new Vector3();
  var scratchPosition3 = new Vector3();
  var cullingVolume = new CullingVolume([new Plane(), new Plane(), new Plane(), new Plane(), new Plane(), new Plane()]);
  function getFrameState(viewport, frameNumber) {
    const {
      cameraDirection,
      cameraUp,
      height
    } = viewport;
    const {
      metersPerUnit
    } = viewport.distanceScales;
    const viewportCenterCartesian = worldToCartesian(viewport, viewport.center);
    const enuToFixedTransform = Ellipsoid.WGS84.eastNorthUpToFixedFrame(viewportCenterCartesian);
    const cameraPositionCartographic = viewport.unprojectPosition(viewport.cameraPosition);
    const cameraPositionCartesian2 = Ellipsoid.WGS84.cartographicToCartesian(cameraPositionCartographic, new Vector3());
    const cameraDirectionCartesian = new Vector3(
      enuToFixedTransform.transformAsVector(new Vector3(cameraDirection).scale(metersPerUnit))
    ).normalize();
    const cameraUpCartesian = new Vector3(
      enuToFixedTransform.transformAsVector(new Vector3(cameraUp).scale(metersPerUnit))
    ).normalize();
    commonSpacePlanesToWGS84(viewport);
    const ViewportClass = viewport.constructor;
    const {
      longitude,
      latitude,
      width,
      bearing,
      zoom
    } = viewport;
    const topDownViewport = new ViewportClass({
      longitude,
      latitude,
      height,
      width,
      bearing,
      zoom,
      pitch: 0
    });
    return {
      camera: {
        position: cameraPositionCartesian2,
        direction: cameraDirectionCartesian,
        up: cameraUpCartesian
      },
      viewport,
      topDownViewport,
      height,
      cullingVolume,
      frameNumber,
      sseDenominator: 1.15
    };
  }
  function limitSelectedTiles(tiles, frameState, maximumTilesSelected) {
    if (maximumTilesSelected === 0 || tiles.length <= maximumTilesSelected) {
      return [tiles, []];
    }
    const tuples = [];
    const {
      longitude: viewportLongitude,
      latitude: viewportLatitude
    } = frameState.viewport;
    for (const [index, tile] of tiles.entries()) {
      const [longitude, latitude] = tile.header.mbs;
      const deltaLon = Math.abs(viewportLongitude - longitude);
      const deltaLat = Math.abs(viewportLatitude - latitude);
      const distance = Math.sqrt(deltaLat * deltaLat + deltaLon * deltaLon);
      tuples.push([index, distance]);
    }
    const tuplesSorted = tuples.sort((a2, b) => a2[1] - b[1]);
    const selectedTiles = [];
    for (let i3 = 0; i3 < maximumTilesSelected; i3++) {
      selectedTiles.push(tiles[tuplesSorted[i3][0]]);
    }
    const unselectedTiles = [];
    for (let i3 = maximumTilesSelected; i3 < tuplesSorted.length; i3++) {
      unselectedTiles.push(tiles[tuplesSorted[i3][0]]);
    }
    return [selectedTiles, unselectedTiles];
  }
  function commonSpacePlanesToWGS84(viewport) {
    const frustumPlanes = viewport.getFrustumPlanes();
    const nearCenterCommon = closestPointOnPlane(frustumPlanes.near, viewport.cameraPosition);
    const nearCenterCartesian = worldToCartesian(viewport, nearCenterCommon);
    const cameraCartesian = worldToCartesian(viewport, viewport.cameraPosition, scratchPosition3);
    let i3 = 0;
    cullingVolume.planes[i3++].fromPointNormal(nearCenterCartesian, scratchVector10.copy(nearCenterCartesian).subtract(cameraCartesian));
    for (const dir in frustumPlanes) {
      if (dir === "near") {
        continue;
      }
      const plane = frustumPlanes[dir];
      const posCommon = closestPointOnPlane(plane, nearCenterCommon, scratchPosition3);
      const cartesianPos = worldToCartesian(viewport, posCommon, scratchPosition3);
      cullingVolume.planes[i3++].fromPointNormal(
        cartesianPos,
        scratchVector10.copy(nearCenterCartesian).subtract(cartesianPos)
      );
    }
  }
  function closestPointOnPlane(plane, refPoint) {
    let out = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : new Vector3();
    const distanceToRef = plane.normal.dot(refPoint);
    out.copy(plane.normal).scale(plane.distance - distanceToRef).add(refPoint);
    return out;
  }
  function worldToCartesian(viewport, point) {
    let out = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : new Vector3();
    const cartographicPos = viewport.unprojectPosition(point);
    return Ellipsoid.WGS84.cartographicToCartesian(cartographicPos, out);
  }

  // ../../node_modules/@loaders.gl/tiles/dist/esm/tileset/helpers/zoom.js
  var WGS84_RADIUS_X2 = 6378137;
  var WGS84_RADIUS_Y2 = 6378137;
  var WGS84_RADIUS_Z2 = 6356752314245179e-9;
  var scratchVector11 = new Vector3();
  function getZoomFromBoundingVolume(boundingVolume, cartorgraphicCenter) {
    if (boundingVolume instanceof OrientedBoundingBox) {
      const {
        halfAxes
      } = boundingVolume;
      const obbSize = getObbSize(halfAxes);
      return Math.log2(WGS84_RADIUS_Z2 / (obbSize + cartorgraphicCenter[2]));
    } else if (boundingVolume instanceof BoundingSphere) {
      const {
        radius
      } = boundingVolume;
      return Math.log2(WGS84_RADIUS_Z2 / (radius + cartorgraphicCenter[2]));
    } else if (boundingVolume.width && boundingVolume.height) {
      const {
        width,
        height
      } = boundingVolume;
      const zoomX = Math.log2(WGS84_RADIUS_X2 / width);
      const zoomY = Math.log2(WGS84_RADIUS_Y2 / height);
      return (zoomX + zoomY) / 2;
    }
    return 1;
  }
  function getZoomFromFullExtent(fullExtent, cartorgraphicCenter, cartesianCenter) {
    const extentVertex = Ellipsoid.WGS84.cartographicToCartesian([fullExtent.xmax, fullExtent.ymax, fullExtent.zmax], new Vector3());
    const extentSize = Math.sqrt(Math.pow(extentVertex[0] - cartesianCenter[0], 2) + Math.pow(extentVertex[1] - cartesianCenter[1], 2) + Math.pow(extentVertex[2] - cartesianCenter[2], 2));
    return Math.log2(WGS84_RADIUS_Z2 / (extentSize + cartorgraphicCenter[2]));
  }
  function getZoomFromExtent(extent, cartorgraphicCenter, cartesianCenter) {
    const [xmin, ymin, xmax, ymax] = extent;
    return getZoomFromFullExtent({
      xmin,
      xmax,
      ymin,
      ymax,
      zmin: 0,
      zmax: 0
    }, cartorgraphicCenter, cartesianCenter);
  }
  function getObbSize(halfAxes) {
    halfAxes.getColumn(0, scratchVector11);
    const axeY = halfAxes.getColumn(1);
    const axeZ = halfAxes.getColumn(2);
    const farthestVertex = scratchVector11.add(axeY).add(axeZ);
    const size = farthestVertex.len();
    return size;
  }

  // ../../node_modules/@loaders.gl/tiles/dist/esm/tileset/tile-3d.js
  var import_core30 = __toESM(require_core3());

  // ../../node_modules/@loaders.gl/tiles/dist/esm/constants.js
  var TILE_CONTENT_STATE = {
    UNLOADED: 0,
    LOADING: 1,
    PROCESSING: 2,
    READY: 3,
    EXPIRED: 4,
    FAILED: 5
  };
  var TILE_REFINEMENT = {
    ADD: 1,
    REPLACE: 2
  };
  var TILE_TYPE = {
    EMPTY: "empty",
    SCENEGRAPH: "scenegraph",
    POINTCLOUD: "pointcloud",
    MESH: "mesh"
  };
  var TILESET_TYPE = {
    I3S: "I3S",
    TILES3D: "TILES3D"
  };
  var LOD_METRIC_TYPE = {
    GEOMETRIC_ERROR: "geometricError",
    MAX_SCREEN_THRESHOLD: "maxScreenThreshold"
  };
  var TILE3D_OPTIMIZATION_HINT = {
    NOT_COMPUTED: -1,
    USE_OPTIMIZATION: 1,
    SKIP_OPTIMIZATION: 0
  };

  // ../../node_modules/@loaders.gl/tiles/dist/esm/tileset/helpers/bounding-volume.js
  function defined2(x2) {
    return x2 !== void 0 && x2 !== null;
  }
  var scratchScale = new Vector3();
  var scratchNorthWest = new Vector3();
  var scratchSouthEast = new Vector3();
  function createBoundingVolume(boundingVolumeHeader, transform2, result) {
    assert2(boundingVolumeHeader, "3D Tile: boundingVolume must be defined");
    if (boundingVolumeHeader.box) {
      return createBox(boundingVolumeHeader.box, transform2, result);
    }
    if (boundingVolumeHeader.region) {
      const [west, south, east, north, minHeight, maxHeight] = boundingVolumeHeader.region;
      const northWest = Ellipsoid.WGS84.cartographicToCartesian([degrees(west), degrees(north), minHeight], scratchNorthWest);
      const southEast = Ellipsoid.WGS84.cartographicToCartesian([degrees(east), degrees(south), maxHeight], scratchSouthEast);
      const centerInCartesian = new Vector3().addVectors(northWest, southEast).multiplyScalar(0.5);
      const radius = new Vector3().subVectors(northWest, southEast).len() / 2;
      return createSphere([centerInCartesian[0], centerInCartesian[1], centerInCartesian[2], radius], new Matrix4());
    }
    if (boundingVolumeHeader.sphere) {
      return createSphere(boundingVolumeHeader.sphere, transform2, result);
    }
    throw new Error("3D Tile: boundingVolume must contain a sphere, region, or box");
  }
  function createBox(box, transform2, result) {
    const center = new Vector3(box[0], box[1], box[2]);
    transform2.transform(center, center);
    let origin = [];
    if (box.length === 10) {
      const halfSize = box.slice(3, 6);
      const quaternion = new Quaternion();
      quaternion.fromArray(box, 6);
      const x2 = new Vector3([1, 0, 0]);
      const y2 = new Vector3([0, 1, 0]);
      const z = new Vector3([0, 0, 1]);
      x2.transformByQuaternion(quaternion);
      x2.scale(halfSize[0]);
      y2.transformByQuaternion(quaternion);
      y2.scale(halfSize[1]);
      z.transformByQuaternion(quaternion);
      z.scale(halfSize[2]);
      origin = [...x2.toArray(), ...y2.toArray(), ...z.toArray()];
    } else {
      origin = [...box.slice(3, 6), ...box.slice(6, 9), ...box.slice(9, 12)];
    }
    const xAxis = transform2.transformAsVector(origin.slice(0, 3));
    const yAxis = transform2.transformAsVector(origin.slice(3, 6));
    const zAxis = transform2.transformAsVector(origin.slice(6, 9));
    const halfAxes = new Matrix3([xAxis[0], xAxis[1], xAxis[2], yAxis[0], yAxis[1], yAxis[2], zAxis[0], zAxis[1], zAxis[2]]);
    if (defined2(result)) {
      result.center = center;
      result.halfAxes = halfAxes;
      return result;
    }
    return new OrientedBoundingBox(center, halfAxes);
  }
  function createSphere(sphere, transform2, result) {
    const center = new Vector3(sphere[0], sphere[1], sphere[2]);
    transform2.transform(center, center);
    const scale5 = transform2.getScale(scratchScale);
    const uniformScale = Math.max(Math.max(scale5[0], scale5[1]), scale5[2]);
    const radius = sphere[3] * uniformScale;
    if (defined2(result)) {
      result.center = center;
      result.radius = radius;
      return result;
    }
    return new BoundingSphere(center, radius);
  }

  // ../../node_modules/@loaders.gl/tiles/dist/esm/tileset/helpers/tiles-3d-lod.js
  var scratchPositionNormal = new Vector3();
  var scratchCartographic = new Vector3();
  var scratchMatrix2 = new Matrix4();
  var scratchCenter = new Vector3();
  var scratchPosition4 = new Vector3();
  var scratchDirection = new Vector3();
  function fog(distanceToCamera, density) {
    const scalar = distanceToCamera * density;
    return 1 - Math.exp(-(scalar * scalar));
  }
  function getDynamicScreenSpaceError(tileset, distanceToCamera) {
    if (tileset.dynamicScreenSpaceError && tileset.dynamicScreenSpaceErrorComputedDensity) {
      const density = tileset.dynamicScreenSpaceErrorComputedDensity;
      const factor = tileset.dynamicScreenSpaceErrorFactor;
      const dynamicError = fog(distanceToCamera, density) * factor;
      return dynamicError;
    }
    return 0;
  }
  function getTiles3DScreenSpaceError(tile, frameState, useParentLodMetric) {
    const tileset = tile.tileset;
    const parentLodMetricValue = tile.parent && tile.parent.lodMetricValue || tile.lodMetricValue;
    const lodMetricValue = useParentLodMetric ? parentLodMetricValue : tile.lodMetricValue;
    if (lodMetricValue === 0) {
      return 0;
    }
    const distance = Math.max(tile._distanceToCamera, 1e-7);
    const {
      height,
      sseDenominator
    } = frameState;
    const {
      viewDistanceScale
    } = tileset.options;
    let error2 = lodMetricValue * height * (viewDistanceScale || 1) / (distance * sseDenominator);
    error2 -= getDynamicScreenSpaceError(tileset, distance);
    return error2;
  }

  // ../../node_modules/@loaders.gl/tiles/dist/esm/tileset/helpers/i3s-lod.js
  var cameraPositionCartesian = new Vector3();
  var toEye = new Vector3();
  var cameraPositionEnu = new Vector3();
  var extraVertexEnu = new Vector3();
  var projectedOriginVector = new Vector3();
  var enuToCartesianMatrix = new Matrix4();
  var cartesianToEnuMatrix = new Matrix4();
  function getLodStatus(tile, frameState) {
    if (tile.lodMetricValue === 0 || isNaN(tile.lodMetricValue)) {
      return "DIG";
    }
    const screenSize = 2 * getProjectedRadius(tile, frameState);
    if (screenSize < 2) {
      return "OUT";
    }
    if (!tile.header.children || screenSize <= tile.lodMetricValue) {
      return "DRAW";
    } else if (tile.header.children) {
      return "DIG";
    }
    return "OUT";
  }
  function getProjectedRadius(tile, frameState) {
    const {
      topDownViewport: viewport
    } = frameState;
    const mbsLat = tile.header.mbs[1];
    const mbsLon = tile.header.mbs[0];
    const mbsZ = tile.header.mbs[2];
    const mbsR = tile.header.mbs[3];
    const mbsCenterCartesian = [...tile.boundingVolume.center];
    const cameraPositionCartographic = viewport.unprojectPosition(viewport.cameraPosition);
    Ellipsoid.WGS84.cartographicToCartesian(cameraPositionCartographic, cameraPositionCartesian);
    toEye.copy(cameraPositionCartesian).subtract(mbsCenterCartesian).normalize();
    Ellipsoid.WGS84.eastNorthUpToFixedFrame(mbsCenterCartesian, enuToCartesianMatrix);
    cartesianToEnuMatrix.copy(enuToCartesianMatrix).invert();
    cameraPositionEnu.copy(cameraPositionCartesian).transform(cartesianToEnuMatrix);
    const projection = Math.sqrt(cameraPositionEnu[0] * cameraPositionEnu[0] + cameraPositionEnu[1] * cameraPositionEnu[1]);
    const extraZ = projection * projection / cameraPositionEnu[2];
    extraVertexEnu.copy([cameraPositionEnu[0], cameraPositionEnu[1], extraZ]);
    const extraVertexCartesian = extraVertexEnu.transform(enuToCartesianMatrix);
    const extraVectorCartesian = extraVertexCartesian.subtract(mbsCenterCartesian).normalize();
    const radiusVector = toEye.cross(extraVectorCartesian).normalize().scale(mbsR);
    const sphereMbsBorderVertexCartesian = radiusVector.add(mbsCenterCartesian);
    const sphereMbsBorderVertexCartographic = Ellipsoid.WGS84.cartesianToCartographic(sphereMbsBorderVertexCartesian);
    const projectedOrigin = viewport.project([mbsLon, mbsLat, mbsZ]);
    const projectedMbsBorderVertex = viewport.project(sphereMbsBorderVertexCartographic);
    const projectedRadius = projectedOriginVector.copy(projectedOrigin).subtract(projectedMbsBorderVertex).magnitude();
    return projectedRadius;
  }

  // ../../node_modules/@loaders.gl/tiles/dist/esm/tileset/helpers/3d-tiles-options.js
  function get3dTilesOptions(tileset) {
    return {
      assetGltfUpAxis: tileset.asset && tileset.asset.gltfUpAxis || "Y"
    };
  }

  // ../../node_modules/@loaders.gl/tiles/dist/esm/utils/managed-array.js
  var ManagedArray = class {
    constructor() {
      let length5 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      _defineProperty(this, "_map", /* @__PURE__ */ new Map());
      _defineProperty(this, "_array", void 0);
      _defineProperty(this, "_length", void 0);
      this._array = new Array(length5);
      this._length = length5;
    }
    get length() {
      return this._length;
    }
    set length(length5) {
      this._length = length5;
      if (length5 > this._array.length) {
        this._array.length = length5;
      }
    }
    get values() {
      return this._array;
    }
    get(index) {
      assert2(index < this._array.length);
      return this._array[index];
    }
    set(index, element) {
      assert2(index >= 0);
      if (index >= this.length) {
        this.length = index + 1;
      }
      if (this._map.has(this._array[index])) {
        this._map.delete(this._array[index]);
      }
      this._array[index] = element;
      this._map.set(element, index);
    }
    delete(element) {
      const index = this._map.get(element);
      if (index >= 0) {
        this._array.splice(index, 1);
        this._map.delete(element);
        this.length--;
      }
    }
    peek() {
      return this._array[this._length - 1];
    }
    push(element) {
      if (!this._map.has(element)) {
        const index = this.length++;
        this._array[index] = element;
        this._map.set(element, index);
      }
    }
    pop() {
      const element = this._array[--this.length];
      this._map.delete(element);
      return element;
    }
    reserve(length5) {
      assert2(length5 >= 0);
      if (length5 > this._array.length) {
        this._array.length = length5;
      }
    }
    resize(length5) {
      assert2(length5 >= 0);
      this.length = length5;
    }
    trim(length5) {
      if (length5 === null || length5 === void 0) {
        length5 = this.length;
      }
      this._array.length = length5;
    }
    reset() {
      this._array = [];
      this._map = /* @__PURE__ */ new Map();
      this._length = 0;
    }
    find(target) {
      return this._map.has(target);
    }
  };

  // ../../node_modules/@loaders.gl/tiles/dist/esm/tileset/tileset-traverser.js
  var DEFAULT_PROPS2 = {
    loadSiblings: false,
    skipLevelOfDetail: false,
    maximumScreenSpaceError: 2,
    updateTransforms: true,
    onTraversalEnd: () => {
    },
    viewportTraversersMap: {},
    basePath: ""
  };
  var TilesetTraverser = class {
    traversalFinished(frameState) {
      return true;
    }
    constructor(options) {
      _defineProperty(this, "options", void 0);
      _defineProperty(this, "root", void 0);
      _defineProperty(this, "requestedTiles", void 0);
      _defineProperty(this, "selectedTiles", void 0);
      _defineProperty(this, "emptyTiles", void 0);
      _defineProperty(this, "lastUpdate", new Date().getTime());
      _defineProperty(this, "updateDebounceTime", 1e3);
      _defineProperty(this, "_traversalStack", void 0);
      _defineProperty(this, "_emptyTraversalStack", void 0);
      _defineProperty(this, "_frameNumber", void 0);
      this.options = {
        ...DEFAULT_PROPS2,
        ...options
      };
      this._traversalStack = new ManagedArray();
      this._emptyTraversalStack = new ManagedArray();
      this._frameNumber = null;
      this.root = null;
      this.selectedTiles = {};
      this.requestedTiles = {};
      this.emptyTiles = {};
    }
    traverse(root, frameState, options) {
      this.root = root;
      this.options = {
        ...this.options,
        ...options
      };
      this.reset();
      this.updateTile(root, frameState);
      this._frameNumber = frameState.frameNumber;
      this.executeTraversal(root, frameState);
    }
    reset() {
      this.requestedTiles = {};
      this.selectedTiles = {};
      this.emptyTiles = {};
      this._traversalStack.reset();
      this._emptyTraversalStack.reset();
    }
    executeTraversal(root, frameState) {
      const stack2 = this._traversalStack;
      root._selectionDepth = 1;
      stack2.push(root);
      while (stack2.length > 0) {
        const tile = stack2.pop();
        let shouldRefine = false;
        if (this.canTraverse(tile, frameState)) {
          this.updateChildTiles(tile, frameState);
          shouldRefine = this.updateAndPushChildren(tile, frameState, stack2, tile.hasRenderContent ? tile._selectionDepth + 1 : tile._selectionDepth);
        }
        const parent = tile.parent;
        const parentRefines = Boolean(!parent || parent._shouldRefine);
        const stoppedRefining = !shouldRefine;
        if (!tile.hasRenderContent) {
          this.emptyTiles[tile.id] = tile;
          this.loadTile(tile, frameState);
          if (stoppedRefining) {
            this.selectTile(tile, frameState);
          }
        } else if (tile.refine === TILE_REFINEMENT.ADD) {
          this.loadTile(tile, frameState);
          this.selectTile(tile, frameState);
        } else if (tile.refine === TILE_REFINEMENT.REPLACE) {
          this.loadTile(tile, frameState);
          if (stoppedRefining) {
            this.selectTile(tile, frameState);
          }
        }
        this.touchTile(tile, frameState);
        tile._shouldRefine = shouldRefine && parentRefines;
      }
      const newTime = new Date().getTime();
      if (this.traversalFinished(frameState) || newTime - this.lastUpdate > this.updateDebounceTime) {
        this.lastUpdate = newTime;
        this.options.onTraversalEnd(frameState);
      }
    }
    updateChildTiles(tile, frameState) {
      const children = tile.children;
      for (const child of children) {
        this.updateTile(child, frameState);
      }
      return true;
    }
    updateAndPushChildren(tile, frameState, stack2, depth) {
      const {
        loadSiblings,
        skipLevelOfDetail
      } = this.options;
      const children = tile.children;
      children.sort(this.compareDistanceToCamera.bind(this));
      const checkRefines = tile.refine === TILE_REFINEMENT.REPLACE && tile.hasRenderContent && !skipLevelOfDetail;
      let hasVisibleChild = false;
      let refines = true;
      for (const child of children) {
        child._selectionDepth = depth;
        if (child.isVisibleAndInRequestVolume) {
          if (stack2.find(child)) {
            stack2.delete(child);
          }
          stack2.push(child);
          hasVisibleChild = true;
        } else if (checkRefines || loadSiblings) {
          this.loadTile(child, frameState);
          this.touchTile(child, frameState);
        }
        if (checkRefines) {
          let childRefines;
          if (!child._inRequestVolume) {
            childRefines = false;
          } else if (!child.hasRenderContent) {
            childRefines = this.executeEmptyTraversal(child, frameState);
          } else {
            childRefines = child.contentAvailable;
          }
          refines = refines && childRefines;
          if (!refines) {
            return false;
          }
        }
      }
      if (!hasVisibleChild) {
        refines = false;
      }
      return refines;
    }
    updateTile(tile, frameState) {
      this.updateTileVisibility(tile, frameState);
    }
    selectTile(tile, frameState) {
      if (this.shouldSelectTile(tile)) {
        tile._selectedFrame = frameState.frameNumber;
        this.selectedTiles[tile.id] = tile;
      }
    }
    loadTile(tile, frameState) {
      if (this.shouldLoadTile(tile)) {
        tile._requestedFrame = frameState.frameNumber;
        tile._priority = tile._getPriority();
        this.requestedTiles[tile.id] = tile;
      }
    }
    touchTile(tile, frameState) {
      tile.tileset._cache.touch(tile);
      tile._touchedFrame = frameState.frameNumber;
    }
    canTraverse(tile, frameState) {
      let useParentMetric = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      let ignoreVisibility = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
      if (!tile.hasChildren) {
        return false;
      }
      if (tile.hasTilesetContent) {
        return !tile.contentExpired;
      }
      if (!ignoreVisibility && !tile.isVisibleAndInRequestVolume) {
        return false;
      }
      return this.shouldRefine(tile, frameState, useParentMetric);
    }
    shouldLoadTile(tile) {
      return tile.hasUnloadedContent || tile.contentExpired;
    }
    shouldSelectTile(tile) {
      return tile.contentAvailable && !this.options.skipLevelOfDetail;
    }
    shouldRefine(tile, frameState, useParentMetric) {
      let screenSpaceError = tile._screenSpaceError;
      if (useParentMetric) {
        screenSpaceError = tile.getScreenSpaceError(frameState, true);
      }
      return screenSpaceError > this.options.maximumScreenSpaceError;
    }
    updateTileVisibility(tile, frameState) {
      const viewportIds = [];
      if (this.options.viewportTraversersMap) {
        for (const key in this.options.viewportTraversersMap) {
          const value = this.options.viewportTraversersMap[key];
          if (value === frameState.viewport.id) {
            viewportIds.push(key);
          }
        }
      } else {
        viewportIds.push(frameState.viewport.id);
      }
      tile.updateVisibility(frameState, viewportIds);
    }
    compareDistanceToCamera(b, a2) {
      return b._distanceToCamera - a2._distanceToCamera;
    }
    anyChildrenVisible(tile, frameState) {
      let anyVisible = false;
      for (const child of tile.children) {
        child.updateVisibility(frameState);
        anyVisible = anyVisible || child.isVisibleAndInRequestVolume;
      }
      return anyVisible;
    }
    executeEmptyTraversal(root, frameState) {
      let allDescendantsLoaded = true;
      const stack2 = this._emptyTraversalStack;
      stack2.push(root);
      while (stack2.length > 0 && allDescendantsLoaded) {
        const tile = stack2.pop();
        this.updateTile(tile, frameState);
        if (!tile.isVisibleAndInRequestVolume) {
          this.loadTile(tile, frameState);
        }
        this.touchTile(tile, frameState);
        const traverse = !tile.hasRenderContent && this.canTraverse(tile, frameState, false, true);
        if (traverse) {
          const children = tile.children;
          for (const child of children) {
            if (stack2.find(child)) {
              stack2.delete(child);
            }
            stack2.push(child);
          }
        } else if (!tile.contentAvailable) {
          allDescendantsLoaded = false;
        }
      }
      return allDescendantsLoaded;
    }
  };

  // ../../node_modules/@loaders.gl/tiles/dist/esm/tileset/tile-3d.js
  var scratchVector12 = new Vector3();
  function defined3(x2) {
    return x2 !== void 0 && x2 !== null;
  }
  var Tile3D = class {
    constructor(tileset, header, parentHeader) {
      let extendedId = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "";
      _defineProperty(this, "tileset", void 0);
      _defineProperty(this, "header", void 0);
      _defineProperty(this, "id", void 0);
      _defineProperty(this, "url", void 0);
      _defineProperty(this, "parent", void 0);
      _defineProperty(this, "refine", void 0);
      _defineProperty(this, "type", void 0);
      _defineProperty(this, "contentUrl", void 0);
      _defineProperty(this, "lodMetricType", void 0);
      _defineProperty(this, "lodMetricValue", void 0);
      _defineProperty(this, "boundingVolume", void 0);
      _defineProperty(this, "content", void 0);
      _defineProperty(this, "contentState", void 0);
      _defineProperty(this, "gpuMemoryUsageInBytes", void 0);
      _defineProperty(this, "children", void 0);
      _defineProperty(this, "depth", void 0);
      _defineProperty(this, "viewportIds", void 0);
      _defineProperty(this, "transform", void 0);
      _defineProperty(this, "extensions", void 0);
      _defineProperty(this, "implicitTiling", void 0);
      _defineProperty(this, "userData", void 0);
      _defineProperty(this, "computedTransform", void 0);
      _defineProperty(this, "hasEmptyContent", void 0);
      _defineProperty(this, "hasTilesetContent", void 0);
      _defineProperty(this, "traverser", void 0);
      _defineProperty(this, "_cacheNode", void 0);
      _defineProperty(this, "_frameNumber", void 0);
      _defineProperty(this, "_lodJudge", void 0);
      _defineProperty(this, "_expireDate", void 0);
      _defineProperty(this, "_expiredContent", void 0);
      _defineProperty(this, "_shouldRefine", void 0);
      _defineProperty(this, "_distanceToCamera", void 0);
      _defineProperty(this, "_centerZDepth", void 0);
      _defineProperty(this, "_screenSpaceError", void 0);
      _defineProperty(this, "_visibilityPlaneMask", void 0);
      _defineProperty(this, "_visible", void 0);
      _defineProperty(this, "_inRequestVolume", void 0);
      _defineProperty(this, "_stackLength", void 0);
      _defineProperty(this, "_selectionDepth", void 0);
      _defineProperty(this, "_touchedFrame", void 0);
      _defineProperty(this, "_visitedFrame", void 0);
      _defineProperty(this, "_selectedFrame", void 0);
      _defineProperty(this, "_requestedFrame", void 0);
      _defineProperty(this, "_priority", void 0);
      _defineProperty(this, "_contentBoundingVolume", void 0);
      _defineProperty(this, "_viewerRequestVolume", void 0);
      _defineProperty(this, "_initialTransform", void 0);
      this.header = header;
      this.tileset = tileset;
      this.id = extendedId || header.id;
      this.url = header.url;
      this.parent = parentHeader;
      this.refine = this._getRefine(header.refine);
      this.type = header.type;
      this.contentUrl = header.contentUrl;
      this.lodMetricType = "geometricError";
      this.lodMetricValue = 0;
      this.boundingVolume = null;
      this.content = null;
      this.contentState = TILE_CONTENT_STATE.UNLOADED;
      this.gpuMemoryUsageInBytes = 0;
      this.children = [];
      this.hasEmptyContent = false;
      this.hasTilesetContent = false;
      this.depth = 0;
      this.viewportIds = [];
      this.userData = {};
      this.extensions = null;
      this._priority = 0;
      this._touchedFrame = 0;
      this._visitedFrame = 0;
      this._selectedFrame = 0;
      this._requestedFrame = 0;
      this._screenSpaceError = 0;
      this._cacheNode = null;
      this._frameNumber = null;
      this._cacheNode = null;
      this.traverser = new TilesetTraverser({});
      this._shouldRefine = false;
      this._distanceToCamera = 0;
      this._centerZDepth = 0;
      this._visible = void 0;
      this._inRequestVolume = false;
      this._stackLength = 0;
      this._selectionDepth = 0;
      this._initialTransform = new Matrix4();
      this.transform = new Matrix4();
      this._initializeLodMetric(header);
      this._initializeTransforms(header);
      this._initializeBoundingVolumes(header);
      this._initializeContent(header);
      this._initializeRenderingState(header);
      this._lodJudge = null;
      this._expireDate = null;
      this._expiredContent = null;
      this.implicitTiling = null;
      Object.seal(this);
    }
    destroy() {
      this.header = null;
    }
    isDestroyed() {
      return this.header === null;
    }
    get selected() {
      return this._selectedFrame === this.tileset._frameNumber;
    }
    get isVisible() {
      return this._visible;
    }
    get isVisibleAndInRequestVolume() {
      return this._visible && this._inRequestVolume;
    }
    get hasRenderContent() {
      return !this.hasEmptyContent && !this.hasTilesetContent;
    }
    get hasChildren() {
      return this.children.length > 0 || this.header.children && this.header.children.length > 0;
    }
    get contentReady() {
      return this.contentState === TILE_CONTENT_STATE.READY || this.hasEmptyContent;
    }
    get contentAvailable() {
      return Boolean(this.contentReady && this.hasRenderContent || this._expiredContent && !this.contentFailed);
    }
    get hasUnloadedContent() {
      return this.hasRenderContent && this.contentUnloaded;
    }
    get contentUnloaded() {
      return this.contentState === TILE_CONTENT_STATE.UNLOADED;
    }
    get contentExpired() {
      return this.contentState === TILE_CONTENT_STATE.EXPIRED;
    }
    get contentFailed() {
      return this.contentState === TILE_CONTENT_STATE.FAILED;
    }
    get distanceToCamera() {
      return this._distanceToCamera;
    }
    get screenSpaceError() {
      return this._screenSpaceError;
    }
    getScreenSpaceError(frameState, useParentLodMetric) {
      switch (this.tileset.type) {
        case TILESET_TYPE.I3S:
          return getProjectedRadius(this, frameState);
        case TILESET_TYPE.TILES3D:
          return getTiles3DScreenSpaceError(this, frameState, useParentLodMetric);
        default:
          throw new Error("Unsupported tileset type");
      }
    }
    unselect() {
      this._selectedFrame = 0;
    }
    _getPriority() {
      const traverser = this.tileset._traverser;
      const {
        skipLevelOfDetail
      } = traverser.options;
      const maySkipTile = this.refine === TILE_REFINEMENT.ADD || skipLevelOfDetail;
      if (maySkipTile && !this.isVisible && this._visible !== void 0) {
        return -1;
      }
      if (this.tileset._frameNumber - this._touchedFrame >= 1) {
        return -1;
      }
      if (this.contentState === TILE_CONTENT_STATE.UNLOADED) {
        return -1;
      }
      const parent = this.parent;
      const useParentScreenSpaceError = parent && (!maySkipTile || this._screenSpaceError === 0 || parent.hasTilesetContent);
      const screenSpaceError = useParentScreenSpaceError ? parent._screenSpaceError : this._screenSpaceError;
      const rootScreenSpaceError = traverser.root ? traverser.root._screenSpaceError : 0;
      return Math.max(rootScreenSpaceError - screenSpaceError, 0);
    }
    async loadContent() {
      if (this.hasEmptyContent) {
        return false;
      }
      if (this.content) {
        return true;
      }
      const expired = this.contentExpired;
      if (expired) {
        this._expireDate = null;
      }
      this.contentState = TILE_CONTENT_STATE.LOADING;
      const requestToken = await this.tileset._requestScheduler.scheduleRequest(this.id, this._getPriority.bind(this));
      if (!requestToken) {
        this.contentState = TILE_CONTENT_STATE.UNLOADED;
        return false;
      }
      try {
        const contentUrl = this.tileset.getTileUrl(this.contentUrl);
        const loader = this.tileset.loader;
        const options = {
          ...this.tileset.loadOptions,
          [loader.id]: {
            ...this.tileset.loadOptions[loader.id],
            isTileset: this.type === "json",
            ...this._getLoaderSpecificOptions(loader.id)
          }
        };
        this.content = await (0, import_core30.load)(contentUrl, loader, options);
        if (this.tileset.options.contentLoader) {
          await this.tileset.options.contentLoader(this);
        }
        if (this._isTileset()) {
          this.tileset._initializeTileHeaders(this.content, this);
        }
        this.contentState = TILE_CONTENT_STATE.READY;
        this._onContentLoaded();
        return true;
      } catch (error2) {
        this.contentState = TILE_CONTENT_STATE.FAILED;
        throw error2;
      } finally {
        requestToken.done();
      }
    }
    unloadContent() {
      if (this.content && this.content.destroy) {
        this.content.destroy();
      }
      this.content = null;
      if (this.header.content && this.header.content.destroy) {
        this.header.content.destroy();
      }
      this.header.content = null;
      this.contentState = TILE_CONTENT_STATE.UNLOADED;
      return true;
    }
    updateVisibility(frameState, viewportIds) {
      if (this._frameNumber === frameState.frameNumber) {
        return;
      }
      const parent = this.parent;
      const parentVisibilityPlaneMask = parent ? parent._visibilityPlaneMask : CullingVolume.MASK_INDETERMINATE;
      if (this.tileset._traverser.options.updateTransforms) {
        const parentTransform = parent ? parent.computedTransform : this.tileset.modelMatrix;
        this._updateTransform(parentTransform);
      }
      this._distanceToCamera = this.distanceToTile(frameState);
      this._screenSpaceError = this.getScreenSpaceError(frameState, false);
      this._visibilityPlaneMask = this.visibility(frameState, parentVisibilityPlaneMask);
      this._visible = this._visibilityPlaneMask !== CullingVolume.MASK_OUTSIDE;
      this._inRequestVolume = this.insideViewerRequestVolume(frameState);
      this._frameNumber = frameState.frameNumber;
      this.viewportIds = viewportIds;
    }
    visibility(frameState, parentVisibilityPlaneMask) {
      const {
        cullingVolume: cullingVolume2
      } = frameState;
      const {
        boundingVolume
      } = this;
      return cullingVolume2.computeVisibilityWithPlaneMask(boundingVolume, parentVisibilityPlaneMask);
    }
    contentVisibility() {
      return true;
    }
    distanceToTile(frameState) {
      const boundingVolume = this.boundingVolume;
      return Math.sqrt(Math.max(boundingVolume.distanceSquaredTo(frameState.camera.position), 0));
    }
    cameraSpaceZDepth(_ref) {
      let {
        camera
      } = _ref;
      const boundingVolume = this.boundingVolume;
      scratchVector12.subVectors(boundingVolume.center, camera.position);
      return camera.direction.dot(scratchVector12);
    }
    insideViewerRequestVolume(frameState) {
      const viewerRequestVolume = this._viewerRequestVolume;
      return !viewerRequestVolume || viewerRequestVolume.distanceSquaredTo(frameState.camera.position) <= 0;
    }
    updateExpiration() {
      if (defined3(this._expireDate) && this.contentReady && !this.hasEmptyContent) {
        const now = Date.now();
        if (Date.lessThan(this._expireDate, now)) {
          this.contentState = TILE_CONTENT_STATE.EXPIRED;
          this._expiredContent = this.content;
        }
      }
    }
    get extras() {
      return this.header.extras;
    }
    _initializeLodMetric(header) {
      if ("lodMetricType" in header) {
        this.lodMetricType = header.lodMetricType;
      } else {
        this.lodMetricType = this.parent && this.parent.lodMetricType || this.tileset.lodMetricType;
        console.warn("3D Tile: Required prop lodMetricType is undefined. Using parent lodMetricType");
      }
      if ("lodMetricValue" in header) {
        this.lodMetricValue = header.lodMetricValue;
      } else {
        this.lodMetricValue = this.parent && this.parent.lodMetricValue || this.tileset.lodMetricValue;
        console.warn("3D Tile: Required prop lodMetricValue is undefined. Using parent lodMetricValue");
      }
    }
    _initializeTransforms(tileHeader) {
      this.transform = tileHeader.transform ? new Matrix4(tileHeader.transform) : new Matrix4();
      const parent = this.parent;
      const tileset = this.tileset;
      const parentTransform = parent && parent.computedTransform ? parent.computedTransform.clone() : tileset.modelMatrix.clone();
      this.computedTransform = new Matrix4(parentTransform).multiplyRight(this.transform);
      const parentInitialTransform = parent && parent._initialTransform ? parent._initialTransform.clone() : new Matrix4();
      this._initialTransform = new Matrix4(parentInitialTransform).multiplyRight(this.transform);
    }
    _initializeBoundingVolumes(tileHeader) {
      this._contentBoundingVolume = null;
      this._viewerRequestVolume = null;
      this._updateBoundingVolume(tileHeader);
    }
    _initializeContent(tileHeader) {
      this.content = {
        _tileset: this.tileset,
        _tile: this
      };
      this.hasEmptyContent = true;
      this.contentState = TILE_CONTENT_STATE.UNLOADED;
      this.hasTilesetContent = false;
      if (tileHeader.contentUrl) {
        this.content = null;
        this.hasEmptyContent = false;
      }
    }
    _initializeRenderingState(header) {
      this.depth = header.level || (this.parent ? this.parent.depth + 1 : 0);
      this._shouldRefine = false;
      this._distanceToCamera = 0;
      this._centerZDepth = 0;
      this._screenSpaceError = 0;
      this._visibilityPlaneMask = CullingVolume.MASK_INDETERMINATE;
      this._visible = void 0;
      this._inRequestVolume = false;
      this._stackLength = 0;
      this._selectionDepth = 0;
      this._frameNumber = 0;
      this._touchedFrame = 0;
      this._visitedFrame = 0;
      this._selectedFrame = 0;
      this._requestedFrame = 0;
      this._priority = 0;
    }
    _getRefine(refine) {
      return refine || this.parent && this.parent.refine || TILE_REFINEMENT.REPLACE;
    }
    _isTileset() {
      return this.contentUrl.indexOf(".json") !== -1;
    }
    _onContentLoaded() {
      switch (this.content && this.content.type) {
        case "vctr":
        case "geom":
          this.tileset._traverser.disableSkipLevelOfDetail = true;
          break;
        default:
      }
      if (this._isTileset()) {
        this.hasTilesetContent = true;
      }
    }
    _updateBoundingVolume(header) {
      this.boundingVolume = createBoundingVolume(header.boundingVolume, this.computedTransform, this.boundingVolume);
      const content = header.content;
      if (!content) {
        return;
      }
      if (content.boundingVolume) {
        this._contentBoundingVolume = createBoundingVolume(content.boundingVolume, this.computedTransform, this._contentBoundingVolume);
      }
      if (header.viewerRequestVolume) {
        this._viewerRequestVolume = createBoundingVolume(header.viewerRequestVolume, this.computedTransform, this._viewerRequestVolume);
      }
    }
    _updateTransform() {
      let parentTransform = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : new Matrix4();
      const computedTransform = parentTransform.clone().multiplyRight(this.transform);
      const didTransformChange = !computedTransform.equals(this.computedTransform);
      if (!didTransformChange) {
        return;
      }
      this.computedTransform = computedTransform;
      this._updateBoundingVolume(this.header);
    }
    _getLoaderSpecificOptions(loaderId) {
      switch (loaderId) {
        case "i3s":
          return {
            ...this.tileset.options.i3s,
            _tileOptions: {
              attributeUrls: this.header.attributeUrls,
              textureUrl: this.header.textureUrl,
              textureFormat: this.header.textureFormat,
              textureLoaderOptions: this.header.textureLoaderOptions,
              materialDefinition: this.header.materialDefinition,
              isDracoGeometry: this.header.isDracoGeometry,
              mbs: this.header.mbs
            },
            _tilesetOptions: {
              store: this.tileset.tileset.store,
              attributeStorageInfo: this.tileset.tileset.attributeStorageInfo,
              fields: this.tileset.tileset.fields
            },
            isTileHeader: false
          };
        case "3d-tiles":
        case "cesium-ion":
        default:
          return get3dTilesOptions(this.tileset.tileset);
      }
    }
  };

  // ../../node_modules/@loaders.gl/tiles/dist/esm/tileset/format-3d-tiles/tileset-3d-traverser.js
  var Tileset3DTraverser = class extends TilesetTraverser {
    compareDistanceToCamera(a2, b) {
      return b._distanceToCamera === 0 && a2._distanceToCamera === 0 ? b._centerZDepth - a2._centerZDepth : b._distanceToCamera - a2._distanceToCamera;
    }
    updateTileVisibility(tile, frameState) {
      super.updateTileVisibility(tile, frameState);
      if (!tile.isVisibleAndInRequestVolume) {
        return;
      }
      const hasChildren = tile.children.length > 0;
      if (tile.hasTilesetContent && hasChildren) {
        const firstChild = tile.children[0];
        this.updateTileVisibility(firstChild, frameState);
        tile._visible = firstChild._visible;
        return;
      }
      if (this.meetsScreenSpaceErrorEarly(tile, frameState)) {
        tile._visible = false;
        return;
      }
      const replace = tile.refine === TILE_REFINEMENT.REPLACE;
      const useOptimization = tile._optimChildrenWithinParent === TILE3D_OPTIMIZATION_HINT.USE_OPTIMIZATION;
      if (replace && useOptimization && hasChildren) {
        if (!this.anyChildrenVisible(tile, frameState)) {
          tile._visible = false;
          return;
        }
      }
    }
    meetsScreenSpaceErrorEarly(tile, frameState) {
      const {
        parent
      } = tile;
      if (!parent || parent.hasTilesetContent || parent.refine !== TILE_REFINEMENT.ADD) {
        return false;
      }
      return !this.shouldRefine(tile, frameState, true);
    }
  };

  // ../../node_modules/@loaders.gl/tiles/dist/esm/tileset/format-i3s/i3s-tileset-traverser.js
  var import_core31 = __toESM(require_core3());

  // ../../node_modules/@loaders.gl/tiles/dist/esm/tileset/format-i3s/i3s-pending-tiles-register.js
  var I3SPendingTilesRegister = class {
    constructor() {
      _defineProperty(this, "frameNumberMap", /* @__PURE__ */ new Map());
    }
    register(viewportId, frameNumber) {
      const viewportMap = this.frameNumberMap.get(viewportId) || /* @__PURE__ */ new Map();
      const oldCount = viewportMap.get(frameNumber) || 0;
      viewportMap.set(frameNumber, oldCount + 1);
      this.frameNumberMap.set(viewportId, viewportMap);
    }
    deregister(viewportId, frameNumber) {
      const viewportMap = this.frameNumberMap.get(viewportId);
      if (!viewportMap) {
        return;
      }
      const oldCount = viewportMap.get(frameNumber) || 1;
      viewportMap.set(frameNumber, oldCount - 1);
    }
    isZero(viewportId, frameNumber) {
      var _this$frameNumberMap$;
      const count = ((_this$frameNumberMap$ = this.frameNumberMap.get(viewportId)) === null || _this$frameNumberMap$ === void 0 ? void 0 : _this$frameNumberMap$.get(frameNumber)) || 0;
      return count === 0;
    }
  };

  // ../../node_modules/@loaders.gl/tiles/dist/esm/tileset/format-i3s/i3s-tile-manager.js
  var STATUS = {
    REQUESTED: "REQUESTED",
    COMPLETED: "COMPLETED",
    ERROR: "ERROR"
  };
  var I3STileManager = class {
    constructor() {
      _defineProperty(this, "_statusMap", void 0);
      _defineProperty(this, "pendingTilesRegister", new I3SPendingTilesRegister());
      this._statusMap = {};
    }
    add(request, key, callback, frameState) {
      if (!this._statusMap[key]) {
        const {
          frameNumber,
          viewport: {
            id
          }
        } = frameState;
        this._statusMap[key] = {
          request,
          callback,
          key,
          frameState,
          status: STATUS.REQUESTED
        };
        this.pendingTilesRegister.register(id, frameNumber);
        request().then((data) => {
          this._statusMap[key].status = STATUS.COMPLETED;
          const {
            frameNumber: actualFrameNumber,
            viewport: {
              id: id2
            }
          } = this._statusMap[key].frameState;
          this.pendingTilesRegister.deregister(id2, actualFrameNumber);
          this._statusMap[key].callback(data, frameState);
        }).catch((error2) => {
          this._statusMap[key].status = STATUS.ERROR;
          const {
            frameNumber: actualFrameNumber,
            viewport: {
              id: id2
            }
          } = this._statusMap[key].frameState;
          this.pendingTilesRegister.deregister(id2, actualFrameNumber);
          callback(error2);
        });
      }
    }
    update(key, frameState) {
      if (this._statusMap[key]) {
        const {
          frameNumber,
          viewport: {
            id
          }
        } = this._statusMap[key].frameState;
        this.pendingTilesRegister.deregister(id, frameNumber);
        const {
          frameNumber: newFrameNumber,
          viewport: {
            id: newViewportId
          }
        } = frameState;
        this.pendingTilesRegister.register(newViewportId, newFrameNumber);
        this._statusMap[key].frameState = frameState;
      }
    }
    find(key) {
      return this._statusMap[key];
    }
    hasPendingTiles(viewportId, frameNumber) {
      return !this.pendingTilesRegister.isZero(viewportId, frameNumber);
    }
  };

  // ../../node_modules/@loaders.gl/tiles/dist/esm/tileset/format-i3s/i3s-tileset-traverser.js
  var I3STilesetTraverser = class extends TilesetTraverser {
    constructor(options) {
      super(options);
      _defineProperty(this, "_tileManager", void 0);
      this._tileManager = new I3STileManager();
    }
    traversalFinished(frameState) {
      return !this._tileManager.hasPendingTiles(frameState.viewport.id, this._frameNumber || 0);
    }
    shouldRefine(tile, frameState) {
      tile._lodJudge = getLodStatus(tile, frameState);
      return tile._lodJudge === "DIG";
    }
    updateChildTiles(tile, frameState) {
      const children = tile.header.children || [];
      const childTiles = tile.children;
      const tileset = tile.tileset;
      for (const child of children) {
        const extendedId = "".concat(child.id, "-").concat(frameState.viewport.id);
        const childTile = childTiles && childTiles.find((t2) => t2.id === extendedId);
        if (!childTile) {
          let request = () => this._loadTile(child.id, tileset);
          const cachedRequest = this._tileManager.find(extendedId);
          if (!cachedRequest) {
            if (tileset.tileset.nodePages) {
              request = () => tileset.tileset.nodePagesTile.formTileFromNodePages(child.id);
            }
            this._tileManager.add(request, extendedId, (header) => this._onTileLoad(header, tile, extendedId), frameState);
          } else {
            this._tileManager.update(extendedId, frameState);
          }
        } else if (childTile) {
          this.updateTile(childTile, frameState);
        }
      }
      return false;
    }
    async _loadTile(nodeId, tileset) {
      const {
        loader
      } = tileset;
      const nodeUrl = tileset.getTileUrl("".concat(tileset.url, "/nodes/").concat(nodeId));
      const options = {
        ...tileset.loadOptions,
        i3s: {
          ...tileset.loadOptions.i3s,
          isTileHeader: true
        }
      };
      return await (0, import_core31.load)(nodeUrl, loader, options);
    }
    _onTileLoad(header, tile, extendedId) {
      const childTile = new Tile3D(tile.tileset, header, tile, extendedId);
      tile.children.push(childTile);
      const frameState = this._tileManager.find(childTile.id).frameState;
      this.updateTile(childTile, frameState);
      if (this._frameNumber === frameState.frameNumber && (this.traversalFinished(frameState) || new Date().getTime() - this.lastUpdate > this.updateDebounceTime)) {
        this.executeTraversal(childTile, frameState);
      }
    }
  };

  // ../../node_modules/@loaders.gl/tiles/dist/esm/tileset/tileset-3d.js
  var DEFAULT_PROPS3 = {
    description: "",
    ellipsoid: Ellipsoid.WGS84,
    modelMatrix: new Matrix4(),
    throttleRequests: true,
    maxRequests: 64,
    maximumMemoryUsage: 32,
    maximumTilesSelected: 0,
    debounceTime: 0,
    onTileLoad: () => {
    },
    onTileUnload: () => {
    },
    onTileError: () => {
    },
    onTraversalComplete: (selectedTiles) => selectedTiles,
    contentLoader: void 0,
    viewDistanceScale: 1,
    maximumScreenSpaceError: 8,
    loadTiles: true,
    updateTransforms: true,
    viewportTraversersMap: null,
    loadOptions: {
      fetch: {}
    },
    attributions: [],
    basePath: "",
    i3s: {}
  };
  var TILES_TOTAL = "Tiles In Tileset(s)";
  var TILES_IN_MEMORY = "Tiles In Memory";
  var TILES_IN_VIEW = "Tiles In View";
  var TILES_RENDERABLE = "Tiles To Render";
  var TILES_LOADED = "Tiles Loaded";
  var TILES_LOADING = "Tiles Loading";
  var TILES_UNLOADED = "Tiles Unloaded";
  var TILES_LOAD_FAILED = "Failed Tile Loads";
  var POINTS_COUNT = "Points/Vertices";
  var TILES_GPU_MEMORY = "Tile Memory Use";
  var Tileset3D = class {
    constructor(json, options) {
      _defineProperty(this, "options", void 0);
      _defineProperty(this, "loadOptions", void 0);
      _defineProperty(this, "type", void 0);
      _defineProperty(this, "tileset", void 0);
      _defineProperty(this, "loader", void 0);
      _defineProperty(this, "url", void 0);
      _defineProperty(this, "basePath", void 0);
      _defineProperty(this, "modelMatrix", void 0);
      _defineProperty(this, "ellipsoid", void 0);
      _defineProperty(this, "lodMetricType", void 0);
      _defineProperty(this, "lodMetricValue", void 0);
      _defineProperty(this, "refine", void 0);
      _defineProperty(this, "root", void 0);
      _defineProperty(this, "roots", void 0);
      _defineProperty(this, "asset", void 0);
      _defineProperty(this, "description", void 0);
      _defineProperty(this, "properties", void 0);
      _defineProperty(this, "extras", void 0);
      _defineProperty(this, "attributions", void 0);
      _defineProperty(this, "credits", void 0);
      _defineProperty(this, "stats", void 0);
      _defineProperty(this, "contentFormats", {
        draco: false,
        meshopt: false,
        dds: false,
        ktx2: false
      });
      _defineProperty(this, "traverseCounter", void 0);
      _defineProperty(this, "geometricError", void 0);
      _defineProperty(this, "selectedTiles", void 0);
      _defineProperty(this, "updatePromise", null);
      _defineProperty(this, "tilesetInitializationPromise", void 0);
      _defineProperty(this, "cartographicCenter", void 0);
      _defineProperty(this, "cartesianCenter", void 0);
      _defineProperty(this, "zoom", void 0);
      _defineProperty(this, "boundingVolume", void 0);
      _defineProperty(this, "gpuMemoryUsageInBytes", void 0);
      _defineProperty(this, "dynamicScreenSpaceErrorComputedDensity", void 0);
      _defineProperty(this, "_traverser", void 0);
      _defineProperty(this, "_cache", void 0);
      _defineProperty(this, "_requestScheduler", void 0);
      _defineProperty(this, "_frameNumber", void 0);
      _defineProperty(this, "_queryParamsString", void 0);
      _defineProperty(this, "_queryParams", void 0);
      _defineProperty(this, "_extensionsUsed", void 0);
      _defineProperty(this, "_tiles", void 0);
      _defineProperty(this, "_pendingCount", void 0);
      _defineProperty(this, "lastUpdatedVieports", void 0);
      _defineProperty(this, "_requestedTiles", void 0);
      _defineProperty(this, "_emptyTiles", void 0);
      _defineProperty(this, "frameStateData", void 0);
      _defineProperty(this, "maximumMemoryUsage", void 0);
      assert2(json);
      this.options = {
        ...DEFAULT_PROPS3,
        ...options
      };
      this.tileset = json;
      this.loader = json.loader;
      this.type = json.type;
      this.url = json.url;
      this.basePath = json.basePath || path_exports.dirname(this.url);
      this.modelMatrix = this.options.modelMatrix;
      this.ellipsoid = this.options.ellipsoid;
      this.lodMetricType = json.lodMetricType;
      this.lodMetricValue = json.lodMetricValue;
      this.refine = json.root.refine;
      this.loadOptions = this.options.loadOptions || {};
      this.root = null;
      this.roots = {};
      this.cartographicCenter = null;
      this.cartesianCenter = null;
      this.zoom = 1;
      this.boundingVolume = null;
      this.traverseCounter = 0;
      this.geometricError = 0;
      this._traverser = this._initializeTraverser();
      this._cache = new TilesetCache();
      this._requestScheduler = new RequestScheduler({
        throttleRequests: this.options.throttleRequests,
        maxRequests: this.options.maxRequests
      });
      this._frameNumber = 0;
      this._pendingCount = 0;
      this._tiles = {};
      this.selectedTiles = [];
      this._emptyTiles = [];
      this._requestedTiles = [];
      this.frameStateData = {};
      this.lastUpdatedVieports = null;
      this._queryParams = {};
      this._queryParamsString = "";
      this.maximumMemoryUsage = this.options.maximumMemoryUsage || 32;
      this.gpuMemoryUsageInBytes = 0;
      this.stats = new Stats({
        id: this.url
      });
      this._initializeStats();
      this._extensionsUsed = void 0;
      this.dynamicScreenSpaceErrorComputedDensity = 0;
      this.extras = null;
      this.asset = {};
      this.credits = {};
      this.description = this.options.description || "";
      this.tilesetInitializationPromise = this._initializeTileSet(json);
    }
    destroy() {
      this._destroy();
    }
    isLoaded() {
      return this._pendingCount === 0 && this._frameNumber !== 0 && this._requestedTiles.length === 0;
    }
    get tiles() {
      return Object.values(this._tiles);
    }
    get frameNumber() {
      return this._frameNumber;
    }
    get queryParams() {
      if (!this._queryParamsString) {
        this._queryParamsString = getQueryParamString(this._queryParams);
      }
      return this._queryParamsString;
    }
    setProps(props) {
      this.options = {
        ...this.options,
        ...props
      };
    }
    setOptions(options) {
      this.options = {
        ...this.options,
        ...options
      };
    }
    getTileUrl(tilePath) {
      const isDataUrl = tilePath.startsWith("data:");
      if (isDataUrl) {
        return tilePath;
      }
      return "".concat(tilePath).concat(this.queryParams);
    }
    hasExtension(extensionName) {
      return Boolean(this._extensionsUsed && this._extensionsUsed.indexOf(extensionName) > -1);
    }
    update() {
      let viewports = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
      this.tilesetInitializationPromise.then(() => {
        if (!viewports && this.lastUpdatedVieports) {
          viewports = this.lastUpdatedVieports;
        } else {
          this.lastUpdatedVieports = viewports;
        }
        if (viewports) {
          this.doUpdate(viewports);
        }
      });
    }
    async selectTiles() {
      let viewports = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
      await this.tilesetInitializationPromise;
      if (viewports) {
        this.lastUpdatedVieports = viewports;
      }
      if (!this.updatePromise) {
        this.updatePromise = new Promise((resolve) => {
          setTimeout(() => {
            if (this.lastUpdatedVieports) {
              this.doUpdate(this.lastUpdatedVieports);
            }
            resolve(this._frameNumber);
            this.updatePromise = null;
          }, this.options.debounceTime);
        });
      }
      return this.updatePromise;
    }
    doUpdate(viewports) {
      if ("loadTiles" in this.options && !this.options.loadTiles) {
        return;
      }
      if (this.traverseCounter > 0) {
        return;
      }
      const preparedViewports = viewports instanceof Array ? viewports : [viewports];
      this._cache.reset();
      this._frameNumber++;
      this.traverseCounter = preparedViewports.length;
      const viewportsToTraverse = [];
      for (const viewport of preparedViewports) {
        const id = viewport.id;
        if (this._needTraverse(id)) {
          viewportsToTraverse.push(id);
        } else {
          this.traverseCounter--;
        }
      }
      for (const viewport of preparedViewports) {
        const id = viewport.id;
        if (!this.roots[id]) {
          this.roots[id] = this._initializeTileHeaders(this.tileset, null);
        }
        if (!viewportsToTraverse.includes(id)) {
          continue;
        }
        const frameState = getFrameState(viewport, this._frameNumber);
        this._traverser.traverse(this.roots[id], frameState, this.options);
      }
    }
    _needTraverse(viewportId) {
      let traverserId = viewportId;
      if (this.options.viewportTraversersMap) {
        traverserId = this.options.viewportTraversersMap[viewportId];
      }
      if (traverserId !== viewportId) {
        return false;
      }
      return true;
    }
    _onTraversalEnd(frameState) {
      const id = frameState.viewport.id;
      if (!this.frameStateData[id]) {
        this.frameStateData[id] = {
          selectedTiles: [],
          _requestedTiles: [],
          _emptyTiles: []
        };
      }
      const currentFrameStateData = this.frameStateData[id];
      const selectedTiles = Object.values(this._traverser.selectedTiles);
      const [filteredSelectedTiles, unselectedTiles] = limitSelectedTiles(selectedTiles, frameState, this.options.maximumTilesSelected);
      currentFrameStateData.selectedTiles = filteredSelectedTiles;
      for (const tile of unselectedTiles) {
        tile.unselect();
      }
      currentFrameStateData._requestedTiles = Object.values(this._traverser.requestedTiles);
      currentFrameStateData._emptyTiles = Object.values(this._traverser.emptyTiles);
      this.traverseCounter--;
      if (this.traverseCounter > 0) {
        return;
      }
      this._updateTiles();
    }
    _updateTiles() {
      this.selectedTiles = [];
      this._requestedTiles = [];
      this._emptyTiles = [];
      for (const frameStateKey in this.frameStateData) {
        const frameStateDataValue = this.frameStateData[frameStateKey];
        this.selectedTiles = this.selectedTiles.concat(frameStateDataValue.selectedTiles);
        this._requestedTiles = this._requestedTiles.concat(frameStateDataValue._requestedTiles);
        this._emptyTiles = this._emptyTiles.concat(frameStateDataValue._emptyTiles);
      }
      this.selectedTiles = this.options.onTraversalComplete(this.selectedTiles);
      for (const tile of this.selectedTiles) {
        this._tiles[tile.id] = tile;
      }
      this._loadTiles();
      this._unloadTiles();
      this._updateStats();
    }
    _tilesChanged(oldSelectedTiles, selectedTiles) {
      if (oldSelectedTiles.length !== selectedTiles.length) {
        return true;
      }
      const set1 = new Set(oldSelectedTiles.map((t2) => t2.id));
      const set2 = new Set(selectedTiles.map((t2) => t2.id));
      let changed = oldSelectedTiles.filter((x2) => !set2.has(x2.id)).length > 0;
      changed = changed || selectedTiles.filter((x2) => !set1.has(x2.id)).length > 0;
      return changed;
    }
    _loadTiles() {
      for (const tile of this._requestedTiles) {
        if (tile.contentUnloaded) {
          this._loadTile(tile);
        }
      }
    }
    _unloadTiles() {
      this._cache.unloadTiles(this, (tileset, tile) => tileset._unloadTile(tile));
    }
    _updateStats() {
      let tilesRenderable = 0;
      let pointsRenderable = 0;
      for (const tile of this.selectedTiles) {
        if (tile.contentAvailable && tile.content) {
          tilesRenderable++;
          if (tile.content.pointCount) {
            pointsRenderable += tile.content.pointCount;
          } else {
            pointsRenderable += tile.content.vertexCount;
          }
        }
      }
      this.stats.get(TILES_IN_VIEW).count = this.selectedTiles.length;
      this.stats.get(TILES_RENDERABLE).count = tilesRenderable;
      this.stats.get(POINTS_COUNT).count = pointsRenderable;
    }
    async _initializeTileSet(tilesetJson) {
      if (this.type === TILESET_TYPE.I3S) {
        this.calculateViewPropsI3S();
        tilesetJson.root = await tilesetJson.root;
      }
      this.root = this._initializeTileHeaders(tilesetJson, null);
      if (this.type === TILESET_TYPE.TILES3D) {
        this._initializeTiles3DTileset(tilesetJson);
        this.calculateViewPropsTiles3D();
      }
      if (this.type === TILESET_TYPE.I3S) {
        this._initializeI3STileset();
      }
    }
    calculateViewPropsI3S() {
      var _this$tileset$store;
      const fullExtent = this.tileset.fullExtent;
      if (fullExtent) {
        const {
          xmin,
          xmax,
          ymin,
          ymax,
          zmin,
          zmax
        } = fullExtent;
        this.cartographicCenter = new Vector3(xmin + (xmax - xmin) / 2, ymin + (ymax - ymin) / 2, zmin + (zmax - zmin) / 2);
        this.cartesianCenter = Ellipsoid.WGS84.cartographicToCartesian(this.cartographicCenter, new Vector3());
        this.zoom = getZoomFromFullExtent(fullExtent, this.cartographicCenter, this.cartesianCenter);
        return;
      }
      const extent = (_this$tileset$store = this.tileset.store) === null || _this$tileset$store === void 0 ? void 0 : _this$tileset$store.extent;
      if (extent) {
        const [xmin, ymin, xmax, ymax] = extent;
        this.cartographicCenter = new Vector3(xmin + (xmax - xmin) / 2, ymin + (ymax - ymin) / 2, 0);
        this.cartesianCenter = Ellipsoid.WGS84.cartographicToCartesian(this.cartographicCenter, new Vector3());
        this.zoom = getZoomFromExtent(extent, this.cartographicCenter, this.cartesianCenter);
        return;
      }
      console.warn("Extent is not defined in the tileset header");
      this.cartographicCenter = new Vector3();
      this.zoom = 1;
      return;
    }
    calculateViewPropsTiles3D() {
      const root = this.root;
      assert2(root);
      const {
        center
      } = root.boundingVolume;
      if (!center) {
        console.warn("center was not pre-calculated for the root tile");
        this.cartographicCenter = new Vector3();
        this.zoom = 1;
        return;
      }
      if (center[0] !== 0 || center[1] !== 0 || center[2] !== 0) {
        this.cartographicCenter = Ellipsoid.WGS84.cartesianToCartographic(center, new Vector3());
      } else {
        this.cartographicCenter = new Vector3(0, 0, -Ellipsoid.WGS84.radii[0]);
      }
      this.cartesianCenter = center;
      this.zoom = getZoomFromBoundingVolume(root.boundingVolume, this.cartographicCenter);
    }
    _initializeStats() {
      this.stats.get(TILES_TOTAL);
      this.stats.get(TILES_LOADING);
      this.stats.get(TILES_IN_MEMORY);
      this.stats.get(TILES_IN_VIEW);
      this.stats.get(TILES_RENDERABLE);
      this.stats.get(TILES_LOADED);
      this.stats.get(TILES_UNLOADED);
      this.stats.get(TILES_LOAD_FAILED);
      this.stats.get(POINTS_COUNT);
      this.stats.get(TILES_GPU_MEMORY, "memory");
    }
    _initializeTileHeaders(tilesetJson, parentTileHeader) {
      const rootTile = new Tile3D(this, tilesetJson.root, parentTileHeader);
      if (parentTileHeader) {
        parentTileHeader.children.push(rootTile);
        rootTile.depth = parentTileHeader.depth + 1;
      }
      if (this.type === TILESET_TYPE.TILES3D) {
        const stack2 = [];
        stack2.push(rootTile);
        while (stack2.length > 0) {
          const tile = stack2.pop();
          this.stats.get(TILES_TOTAL).incrementCount();
          const children = tile.header.children || [];
          for (const childHeader of children) {
            const childTile = new Tile3D(this, childHeader, tile);
            tile.children.push(childTile);
            childTile.depth = tile.depth + 1;
            stack2.push(childTile);
          }
        }
      }
      return rootTile;
    }
    _initializeTraverser() {
      let TraverserClass;
      const type = this.type;
      switch (type) {
        case TILESET_TYPE.TILES3D:
          TraverserClass = Tileset3DTraverser;
          break;
        case TILESET_TYPE.I3S:
          TraverserClass = I3STilesetTraverser;
          break;
        default:
          TraverserClass = TilesetTraverser;
      }
      return new TraverserClass({
        basePath: this.basePath,
        onTraversalEnd: this._onTraversalEnd.bind(this)
      });
    }
    _destroyTileHeaders(parentTile) {
      this._destroySubtree(parentTile);
    }
    async _loadTile(tile) {
      let loaded;
      try {
        this._onStartTileLoading();
        loaded = await tile.loadContent();
      } catch (error2) {
        this._onTileLoadError(tile, error2);
      } finally {
        this._onEndTileLoading();
        this._onTileLoad(tile, loaded);
      }
    }
    _onTileLoadError(tile, error2) {
      this.stats.get(TILES_LOAD_FAILED).incrementCount();
      const message = error2.message || error2.toString();
      const url = tile.url;
      console.error("A 3D tile failed to load: ".concat(tile.url, " ").concat(message));
      this.options.onTileError(tile, message, url);
    }
    _onTileLoad(tile, loaded) {
      if (!loaded) {
        return;
      }
      if (this.type === TILESET_TYPE.I3S) {
        var _this$tileset, _this$tileset$nodePag;
        const nodesInNodePages = ((_this$tileset = this.tileset) === null || _this$tileset === void 0 ? void 0 : (_this$tileset$nodePag = _this$tileset.nodePagesTile) === null || _this$tileset$nodePag === void 0 ? void 0 : _this$tileset$nodePag.nodesInNodePages) || 0;
        this.stats.get(TILES_TOTAL).reset();
        this.stats.get(TILES_TOTAL).addCount(nodesInNodePages);
      }
      if (tile && tile.content) {
        calculateTransformProps(tile, tile.content);
      }
      this.updateContentTypes(tile);
      this._addTileToCache(tile);
      this.options.onTileLoad(tile);
    }
    updateContentTypes(tile) {
      if (this.type === TILESET_TYPE.I3S) {
        if (tile.header.isDracoGeometry) {
          this.contentFormats.draco = true;
        }
        switch (tile.header.textureFormat) {
          case "dds":
            this.contentFormats.dds = true;
            break;
          case "ktx2":
            this.contentFormats.ktx2 = true;
            break;
          default:
        }
      } else if (this.type === TILESET_TYPE.TILES3D) {
        var _tile$content;
        const {
          extensionsRemoved = []
        } = ((_tile$content = tile.content) === null || _tile$content === void 0 ? void 0 : _tile$content.gltf) || {};
        if (extensionsRemoved.includes("KHR_draco_mesh_compression")) {
          this.contentFormats.draco = true;
        }
        if (extensionsRemoved.includes("EXT_meshopt_compression")) {
          this.contentFormats.meshopt = true;
        }
        if (extensionsRemoved.includes("KHR_texture_basisu")) {
          this.contentFormats.ktx2 = true;
        }
      }
    }
    _onStartTileLoading() {
      this._pendingCount++;
      this.stats.get(TILES_LOADING).incrementCount();
    }
    _onEndTileLoading() {
      this._pendingCount--;
      this.stats.get(TILES_LOADING).decrementCount();
    }
    _addTileToCache(tile) {
      this._cache.add(this, tile, (tileset) => tileset._updateCacheStats(tile));
    }
    _updateCacheStats(tile) {
      this.stats.get(TILES_LOADED).incrementCount();
      this.stats.get(TILES_IN_MEMORY).incrementCount();
      this.gpuMemoryUsageInBytes += tile.content.byteLength || 0;
      this.stats.get(TILES_GPU_MEMORY).count = this.gpuMemoryUsageInBytes;
    }
    _unloadTile(tile) {
      this.gpuMemoryUsageInBytes -= tile.content && tile.content.byteLength || 0;
      this.stats.get(TILES_IN_MEMORY).decrementCount();
      this.stats.get(TILES_UNLOADED).incrementCount();
      this.stats.get(TILES_GPU_MEMORY).count = this.gpuMemoryUsageInBytes;
      this.options.onTileUnload(tile);
      tile.unloadContent();
    }
    _destroy() {
      const stack2 = [];
      if (this.root) {
        stack2.push(this.root);
      }
      while (stack2.length > 0) {
        const tile = stack2.pop();
        for (const child of tile.children) {
          stack2.push(child);
        }
        this._destroyTile(tile);
      }
      this.root = null;
    }
    _destroySubtree(tile) {
      const root = tile;
      const stack2 = [];
      stack2.push(root);
      while (stack2.length > 0) {
        tile = stack2.pop();
        for (const child of tile.children) {
          stack2.push(child);
        }
        if (tile !== root) {
          this._destroyTile(tile);
        }
      }
      root.children = [];
    }
    _destroyTile(tile) {
      this._cache.unloadTile(this, tile);
      this._unloadTile(tile);
      tile.destroy();
    }
    _initializeTiles3DTileset(tilesetJson) {
      this.asset = tilesetJson.asset;
      if (!this.asset) {
        throw new Error("Tileset must have an asset property.");
      }
      if (this.asset.version !== "0.0" && this.asset.version !== "1.0") {
        throw new Error("The tileset must be 3D Tiles version 0.0 or 1.0.");
      }
      if ("tilesetVersion" in this.asset) {
        this._queryParams.v = this.asset.tilesetVersion;
      }
      this.credits = {
        attributions: this.options.attributions || []
      };
      this.description = this.options.description || "";
      this.properties = tilesetJson.properties;
      this.geometricError = tilesetJson.geometricError;
      this._extensionsUsed = tilesetJson.extensionsUsed;
      this.extras = tilesetJson.extras;
    }
    _initializeI3STileset() {
      if (this.loadOptions.i3s && "token" in this.loadOptions.i3s) {
        this._queryParams.token = this.loadOptions.i3s.token;
      }
    }
  };
  function getQueryParamString(queryParams) {
    const queryParamStrings = [];
    for (const key of Object.keys(queryParams)) {
      queryParamStrings.push("".concat(key, "=").concat(queryParams[key]));
    }
    switch (queryParamStrings.length) {
      case 0:
        return "";
      case 1:
        return "?".concat(queryParamStrings[0]);
      default:
        return "?".concat(queryParamStrings.join("&"));
    }
  }

  // ../../node_modules/@loaders.gl/3d-tiles/dist/esm/lib/utils/version.js
  var VERSION8 = true ? "3.3.1" : "latest";

  // ../../node_modules/@loaders.gl/3d-tiles/dist/esm/lib/constants.js
  var TILE3D_TYPE = {
    COMPOSITE: "cmpt",
    POINT_CLOUD: "pnts",
    BATCHED_3D_MODEL: "b3dm",
    INSTANCED_3D_MODEL: "i3dm",
    GEOMETRY: "geom",
    VECTOR: "vect",
    GLTF: "glTF"
  };
  var TILE3D_TYPES = Object.keys(TILE3D_TYPE);

  // ../../node_modules/@loaders.gl/3d-tiles/dist/esm/lib/parsers/helpers/parse-utils.js
  function getStringFromArrayBuffer(arrayBuffer, byteOffset, byteLength) {
    assert2(arrayBuffer instanceof ArrayBuffer);
    const textDecoder = new TextDecoder("utf8");
    const typedArray = new Uint8Array(arrayBuffer, byteOffset, byteLength);
    const string = textDecoder.decode(typedArray);
    return string;
  }
  function getMagicString2(arrayBuffer) {
    let byteOffset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    const dataView = new DataView(arrayBuffer);
    return "".concat(String.fromCharCode(dataView.getUint8(byteOffset + 0))).concat(String.fromCharCode(dataView.getUint8(byteOffset + 1))).concat(String.fromCharCode(dataView.getUint8(byteOffset + 2))).concat(String.fromCharCode(dataView.getUint8(byteOffset + 3)));
  }

  // ../../node_modules/@loaders.gl/draco/dist/esm/lib/utils/version.js
  var VERSION9 = true ? "3.3.1" : "latest";

  // ../../node_modules/@loaders.gl/draco/dist/esm/draco-loader.js
  var DEFAULT_DRACO_OPTIONS = {
    draco: {
      decoderType: typeof WebAssembly === "object" ? "wasm" : "js",
      libraryPath: "libs/",
      extraAttributes: {},
      attributeNameEntry: void 0
    }
  };
  var DracoLoader = {
    name: "Draco",
    id: isBrowser2 ? "draco" : "draco-nodejs",
    module: "draco",
    shapes: ["mesh"],
    version: VERSION9,
    worker: true,
    extensions: ["drc"],
    mimeTypes: ["application/octet-stream"],
    binary: true,
    tests: ["DRACO"],
    options: DEFAULT_DRACO_OPTIONS
  };

  // ../../node_modules/@loaders.gl/schema/dist/esm/category/mesh/mesh-utils.js
  function getMeshBoundingBox(attributes) {
    let minX = Infinity;
    let minY = Infinity;
    let minZ = Infinity;
    let maxX = -Infinity;
    let maxY = -Infinity;
    let maxZ = -Infinity;
    const positions = attributes.POSITION ? attributes.POSITION.value : [];
    const len2 = positions && positions.length;
    for (let i3 = 0; i3 < len2; i3 += 3) {
      const x2 = positions[i3];
      const y2 = positions[i3 + 1];
      const z = positions[i3 + 2];
      minX = x2 < minX ? x2 : minX;
      minY = y2 < minY ? y2 : minY;
      minZ = z < minZ ? z : minZ;
      maxX = x2 > maxX ? x2 : maxX;
      maxY = y2 > maxY ? y2 : maxY;
      maxZ = z > maxZ ? z : maxZ;
    }
    return [[minX, minY, minZ], [maxX, maxY, maxZ]];
  }

  // ../../node_modules/@loaders.gl/schema/dist/esm/lib/utils/assert.js
  function assert9(condition, message) {
    if (!condition) {
      throw new Error(message || "loader assertion failed.");
    }
  }

  // ../../node_modules/@loaders.gl/schema/dist/esm/lib/schema/impl/schema.js
  var Schema = class {
    constructor(fields, metadata) {
      _defineProperty(this, "fields", void 0);
      _defineProperty(this, "metadata", void 0);
      assert9(Array.isArray(fields));
      checkNames(fields);
      this.fields = fields;
      this.metadata = metadata || /* @__PURE__ */ new Map();
    }
    compareTo(other) {
      if (this.metadata !== other.metadata) {
        return false;
      }
      if (this.fields.length !== other.fields.length) {
        return false;
      }
      for (let i3 = 0; i3 < this.fields.length; ++i3) {
        if (!this.fields[i3].compareTo(other.fields[i3])) {
          return false;
        }
      }
      return true;
    }
    select() {
      const nameMap = /* @__PURE__ */ Object.create(null);
      for (var _len = arguments.length, columnNames = new Array(_len), _key = 0; _key < _len; _key++) {
        columnNames[_key] = arguments[_key];
      }
      for (const name10 of columnNames) {
        nameMap[name10] = true;
      }
      const selectedFields = this.fields.filter((field) => nameMap[field.name]);
      return new Schema(selectedFields, this.metadata);
    }
    selectAt() {
      for (var _len2 = arguments.length, columnIndices = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        columnIndices[_key2] = arguments[_key2];
      }
      const selectedFields = columnIndices.map((index) => this.fields[index]).filter(Boolean);
      return new Schema(selectedFields, this.metadata);
    }
    assign(schemaOrFields) {
      let fields;
      let metadata = this.metadata;
      if (schemaOrFields instanceof Schema) {
        const otherSchema = schemaOrFields;
        fields = otherSchema.fields;
        metadata = mergeMaps(mergeMaps(/* @__PURE__ */ new Map(), this.metadata), otherSchema.metadata);
      } else {
        fields = schemaOrFields;
      }
      const fieldMap = /* @__PURE__ */ Object.create(null);
      for (const field of this.fields) {
        fieldMap[field.name] = field;
      }
      for (const field of fields) {
        fieldMap[field.name] = field;
      }
      const mergedFields = Object.values(fieldMap);
      return new Schema(mergedFields, metadata);
    }
  };
  function checkNames(fields) {
    const usedNames = {};
    for (const field of fields) {
      if (usedNames[field.name]) {
        console.warn("Schema: duplicated field name", field.name, field);
      }
      usedNames[field.name] = true;
    }
  }
  function mergeMaps(m1, m2) {
    return new Map([...m1 || /* @__PURE__ */ new Map(), ...m2 || /* @__PURE__ */ new Map()]);
  }

  // ../../node_modules/@loaders.gl/schema/dist/esm/lib/schema/impl/field.js
  var Field = class {
    constructor(name10, type) {
      let nullable = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      let metadata = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : /* @__PURE__ */ new Map();
      _defineProperty(this, "name", void 0);
      _defineProperty(this, "type", void 0);
      _defineProperty(this, "nullable", void 0);
      _defineProperty(this, "metadata", void 0);
      this.name = name10;
      this.type = type;
      this.nullable = nullable;
      this.metadata = metadata;
    }
    get typeId() {
      return this.type && this.type.typeId;
    }
    clone() {
      return new Field(this.name, this.type, this.nullable, this.metadata);
    }
    compareTo(other) {
      return this.name === other.name && this.type === other.type && this.nullable === other.nullable && this.metadata === other.metadata;
    }
    toString() {
      return "".concat(this.type).concat(this.nullable ? ", nullable" : "").concat(this.metadata ? ", metadata: ".concat(this.metadata) : "");
    }
  };

  // ../../node_modules/@loaders.gl/schema/dist/esm/lib/schema/impl/enum.js
  var Type;
  (function(Type2) {
    Type2[Type2["NONE"] = 0] = "NONE";
    Type2[Type2["Null"] = 1] = "Null";
    Type2[Type2["Int"] = 2] = "Int";
    Type2[Type2["Float"] = 3] = "Float";
    Type2[Type2["Binary"] = 4] = "Binary";
    Type2[Type2["Utf8"] = 5] = "Utf8";
    Type2[Type2["Bool"] = 6] = "Bool";
    Type2[Type2["Decimal"] = 7] = "Decimal";
    Type2[Type2["Date"] = 8] = "Date";
    Type2[Type2["Time"] = 9] = "Time";
    Type2[Type2["Timestamp"] = 10] = "Timestamp";
    Type2[Type2["Interval"] = 11] = "Interval";
    Type2[Type2["List"] = 12] = "List";
    Type2[Type2["Struct"] = 13] = "Struct";
    Type2[Type2["Union"] = 14] = "Union";
    Type2[Type2["FixedSizeBinary"] = 15] = "FixedSizeBinary";
    Type2[Type2["FixedSizeList"] = 16] = "FixedSizeList";
    Type2[Type2["Map"] = 17] = "Map";
    Type2[Type2["Dictionary"] = -1] = "Dictionary";
    Type2[Type2["Int8"] = -2] = "Int8";
    Type2[Type2["Int16"] = -3] = "Int16";
    Type2[Type2["Int32"] = -4] = "Int32";
    Type2[Type2["Int64"] = -5] = "Int64";
    Type2[Type2["Uint8"] = -6] = "Uint8";
    Type2[Type2["Uint16"] = -7] = "Uint16";
    Type2[Type2["Uint32"] = -8] = "Uint32";
    Type2[Type2["Uint64"] = -9] = "Uint64";
    Type2[Type2["Float16"] = -10] = "Float16";
    Type2[Type2["Float32"] = -11] = "Float32";
    Type2[Type2["Float64"] = -12] = "Float64";
    Type2[Type2["DateDay"] = -13] = "DateDay";
    Type2[Type2["DateMillisecond"] = -14] = "DateMillisecond";
    Type2[Type2["TimestampSecond"] = -15] = "TimestampSecond";
    Type2[Type2["TimestampMillisecond"] = -16] = "TimestampMillisecond";
    Type2[Type2["TimestampMicrosecond"] = -17] = "TimestampMicrosecond";
    Type2[Type2["TimestampNanosecond"] = -18] = "TimestampNanosecond";
    Type2[Type2["TimeSecond"] = -19] = "TimeSecond";
    Type2[Type2["TimeMillisecond"] = -20] = "TimeMillisecond";
    Type2[Type2["TimeMicrosecond"] = -21] = "TimeMicrosecond";
    Type2[Type2["TimeNanosecond"] = -22] = "TimeNanosecond";
    Type2[Type2["DenseUnion"] = -23] = "DenseUnion";
    Type2[Type2["SparseUnion"] = -24] = "SparseUnion";
    Type2[Type2["IntervalDayTime"] = -25] = "IntervalDayTime";
    Type2[Type2["IntervalYearMonth"] = -26] = "IntervalYearMonth";
  })(Type || (Type = {}));

  // ../../node_modules/@loaders.gl/schema/dist/esm/lib/schema/impl/type.js
  var _Symbol$toStringTag;
  var _Symbol$toStringTag2;
  var _Symbol$toStringTag3;
  var _Symbol$toStringTag4;
  var _Symbol$toStringTag5;
  var _Symbol$toStringTag6;
  var _Symbol$toStringTag7;
  var _Symbol$toStringTag8;
  var DataType = class {
    static isNull(x2) {
      return x2 && x2.typeId === Type.Null;
    }
    static isInt(x2) {
      return x2 && x2.typeId === Type.Int;
    }
    static isFloat(x2) {
      return x2 && x2.typeId === Type.Float;
    }
    static isBinary(x2) {
      return x2 && x2.typeId === Type.Binary;
    }
    static isUtf8(x2) {
      return x2 && x2.typeId === Type.Utf8;
    }
    static isBool(x2) {
      return x2 && x2.typeId === Type.Bool;
    }
    static isDecimal(x2) {
      return x2 && x2.typeId === Type.Decimal;
    }
    static isDate(x2) {
      return x2 && x2.typeId === Type.Date;
    }
    static isTime(x2) {
      return x2 && x2.typeId === Type.Time;
    }
    static isTimestamp(x2) {
      return x2 && x2.typeId === Type.Timestamp;
    }
    static isInterval(x2) {
      return x2 && x2.typeId === Type.Interval;
    }
    static isList(x2) {
      return x2 && x2.typeId === Type.List;
    }
    static isStruct(x2) {
      return x2 && x2.typeId === Type.Struct;
    }
    static isUnion(x2) {
      return x2 && x2.typeId === Type.Union;
    }
    static isFixedSizeBinary(x2) {
      return x2 && x2.typeId === Type.FixedSizeBinary;
    }
    static isFixedSizeList(x2) {
      return x2 && x2.typeId === Type.FixedSizeList;
    }
    static isMap(x2) {
      return x2 && x2.typeId === Type.Map;
    }
    static isDictionary(x2) {
      return x2 && x2.typeId === Type.Dictionary;
    }
    get typeId() {
      return Type.NONE;
    }
    compareTo(other) {
      return this === other;
    }
  };
  var Null = class extends DataType {
    get typeId() {
      return Type.Null;
    }
    get [Symbol.toStringTag]() {
      return "Null";
    }
    toString() {
      return "Null";
    }
  };
  var Bool = class extends DataType {
    get typeId() {
      return Type.Bool;
    }
    get [Symbol.toStringTag]() {
      return "Bool";
    }
    toString() {
      return "Bool";
    }
  };
  _Symbol$toStringTag = Symbol.toStringTag;
  var Int = class extends DataType {
    constructor(isSigned, bitWidth) {
      super();
      _defineProperty(this, "isSigned", void 0);
      _defineProperty(this, "bitWidth", void 0);
      this.isSigned = isSigned;
      this.bitWidth = bitWidth;
    }
    get typeId() {
      return Type.Int;
    }
    get [_Symbol$toStringTag]() {
      return "Int";
    }
    toString() {
      return "".concat(this.isSigned ? "I" : "Ui", "nt").concat(this.bitWidth);
    }
  };
  var Int8 = class extends Int {
    constructor() {
      super(true, 8);
    }
  };
  var Int16 = class extends Int {
    constructor() {
      super(true, 16);
    }
  };
  var Int32 = class extends Int {
    constructor() {
      super(true, 32);
    }
  };
  var Uint8 = class extends Int {
    constructor() {
      super(false, 8);
    }
  };
  var Uint16 = class extends Int {
    constructor() {
      super(false, 16);
    }
  };
  var Uint32 = class extends Int {
    constructor() {
      super(false, 32);
    }
  };
  var Precision = {
    HALF: 16,
    SINGLE: 32,
    DOUBLE: 64
  };
  _Symbol$toStringTag2 = Symbol.toStringTag;
  var Float = class extends DataType {
    constructor(precision) {
      super();
      _defineProperty(this, "precision", void 0);
      this.precision = precision;
    }
    get typeId() {
      return Type.Float;
    }
    get [_Symbol$toStringTag2]() {
      return "Float";
    }
    toString() {
      return "Float".concat(this.precision);
    }
  };
  var Float32 = class extends Float {
    constructor() {
      super(Precision.SINGLE);
    }
  };
  var Float64 = class extends Float {
    constructor() {
      super(Precision.DOUBLE);
    }
  };
  var Binary = class extends DataType {
    constructor() {
      super();
    }
    get typeId() {
      return Type.Binary;
    }
    toString() {
      return "Binary";
    }
    get [Symbol.toStringTag]() {
      return "Binary";
    }
  };
  var Utf8 = class extends DataType {
    get typeId() {
      return Type.Utf8;
    }
    get [Symbol.toStringTag]() {
      return "Utf8";
    }
    toString() {
      return "Utf8";
    }
  };
  var DateUnit = {
    DAY: 0,
    MILLISECOND: 1
  };
  _Symbol$toStringTag3 = Symbol.toStringTag;
  var Date2 = class extends DataType {
    constructor(unit) {
      super();
      _defineProperty(this, "unit", void 0);
      this.unit = unit;
    }
    get typeId() {
      return Type.Date;
    }
    get [_Symbol$toStringTag3]() {
      return "Date";
    }
    toString() {
      return "Date".concat((this.unit + 1) * 32, "<").concat(DateUnit[this.unit], ">");
    }
  };
  var TimeUnit = {
    SECOND: 1,
    MILLISECOND: 1e3,
    MICROSECOND: 1e6,
    NANOSECOND: 1e9
  };
  _Symbol$toStringTag4 = Symbol.toStringTag;
  var Time = class extends DataType {
    constructor(unit, bitWidth) {
      super();
      _defineProperty(this, "unit", void 0);
      _defineProperty(this, "bitWidth", void 0);
      this.unit = unit;
      this.bitWidth = bitWidth;
    }
    get typeId() {
      return Type.Time;
    }
    toString() {
      return "Time".concat(this.bitWidth, "<").concat(TimeUnit[this.unit], ">");
    }
    get [_Symbol$toStringTag4]() {
      return "Time";
    }
  };
  _Symbol$toStringTag5 = Symbol.toStringTag;
  var Timestamp = class extends DataType {
    constructor(unit) {
      let timezone = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
      super();
      _defineProperty(this, "unit", void 0);
      _defineProperty(this, "timezone", void 0);
      this.unit = unit;
      this.timezone = timezone;
    }
    get typeId() {
      return Type.Timestamp;
    }
    get [_Symbol$toStringTag5]() {
      return "Timestamp";
    }
    toString() {
      return "Timestamp<".concat(TimeUnit[this.unit]).concat(this.timezone ? ", ".concat(this.timezone) : "", ">");
    }
  };
  var IntervalUnit = {
    DAY_TIME: 0,
    YEAR_MONTH: 1
  };
  _Symbol$toStringTag6 = Symbol.toStringTag;
  var Interval = class extends DataType {
    constructor(unit) {
      super();
      _defineProperty(this, "unit", void 0);
      this.unit = unit;
    }
    get typeId() {
      return Type.Interval;
    }
    get [_Symbol$toStringTag6]() {
      return "Interval";
    }
    toString() {
      return "Interval<".concat(IntervalUnit[this.unit], ">");
    }
  };
  _Symbol$toStringTag7 = Symbol.toStringTag;
  var FixedSizeList = class extends DataType {
    constructor(listSize, child) {
      super();
      _defineProperty(this, "listSize", void 0);
      _defineProperty(this, "children", void 0);
      this.listSize = listSize;
      this.children = [child];
    }
    get typeId() {
      return Type.FixedSizeList;
    }
    get valueType() {
      return this.children[0].type;
    }
    get valueField() {
      return this.children[0];
    }
    get [_Symbol$toStringTag7]() {
      return "FixedSizeList";
    }
    toString() {
      return "FixedSizeList[".concat(this.listSize, "]<").concat(this.valueType, ">");
    }
  };
  _Symbol$toStringTag8 = Symbol.toStringTag;
  var Struct = class extends DataType {
    constructor(children) {
      super();
      _defineProperty(this, "children", void 0);
      this.children = children;
    }
    get typeId() {
      return Type.Struct;
    }
    toString() {
      return "Struct<{".concat(this.children.map((f2) => "".concat(f2.name, ":").concat(f2.type)).join(", "), "}>");
    }
    get [_Symbol$toStringTag8]() {
      return "Struct";
    }
  };

  // ../../node_modules/@loaders.gl/schema/dist/esm/lib/arrow/arrow-like-type-utils.js
  function getArrowTypeFromTypedArray(array) {
    switch (array.constructor) {
      case Int8Array:
        return new Int8();
      case Uint8Array:
        return new Uint8();
      case Int16Array:
        return new Int16();
      case Uint16Array:
        return new Uint16();
      case Int32Array:
        return new Int32();
      case Uint32Array:
        return new Uint32();
      case Float32Array:
        return new Float32();
      case Float64Array:
        return new Float64();
      default:
        throw new Error("array type not supported");
    }
  }

  // ../../node_modules/@loaders.gl/schema/dist/esm/category/mesh/deduce-mesh-schema.js
  function deduceMeshField(attributeName, attribute, optionalMetadata) {
    const type = getArrowTypeFromTypedArray(attribute.value);
    const metadata = optionalMetadata ? optionalMetadata : makeMeshAttributeMetadata(attribute);
    const field = new Field(attributeName, new FixedSizeList(attribute.size, new Field("value", type)), false, metadata);
    return field;
  }
  function makeMeshAttributeMetadata(attribute) {
    const result = /* @__PURE__ */ new Map();
    if ("byteOffset" in attribute) {
      result.set("byteOffset", attribute.byteOffset.toString(10));
    }
    if ("byteStride" in attribute) {
      result.set("byteStride", attribute.byteStride.toString(10));
    }
    if ("normalized" in attribute) {
      result.set("normalized", attribute.normalized.toString());
    }
    return result;
  }

  // ../../node_modules/@loaders.gl/draco/dist/esm/lib/utils/get-draco-schema.js
  function getDracoSchema(attributes, loaderData, indices) {
    const metadataMap = makeMetadata(loaderData.metadata);
    const fields = [];
    const namedLoaderDataAttributes = transformAttributesLoaderData(loaderData.attributes);
    for (const attributeName in attributes) {
      const attribute = attributes[attributeName];
      const field = getArrowFieldFromAttribute(attributeName, attribute, namedLoaderDataAttributes[attributeName]);
      fields.push(field);
    }
    if (indices) {
      const indicesField = getArrowFieldFromAttribute("indices", indices);
      fields.push(indicesField);
    }
    return new Schema(fields, metadataMap);
  }
  function transformAttributesLoaderData(loaderData) {
    const result = {};
    for (const key in loaderData) {
      const dracoAttribute = loaderData[key];
      result[dracoAttribute.name || "undefined"] = dracoAttribute;
    }
    return result;
  }
  function getArrowFieldFromAttribute(attributeName, attribute, loaderData) {
    const metadataMap = loaderData ? makeMetadata(loaderData.metadata) : void 0;
    const field = deduceMeshField(attributeName, attribute, metadataMap);
    return field;
  }
  function makeMetadata(metadata) {
    const metadataMap = /* @__PURE__ */ new Map();
    for (const key in metadata) {
      metadataMap.set("".concat(key, ".string"), JSON.stringify(metadata[key]));
    }
    return metadataMap;
  }

  // ../../node_modules/@loaders.gl/draco/dist/esm/lib/draco-parser.js
  var DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP = {
    POSITION: "POSITION",
    NORMAL: "NORMAL",
    COLOR: "COLOR_0",
    TEX_COORD: "TEXCOORD_0"
  };
  var DRACO_DATA_TYPE_TO_TYPED_ARRAY_MAP = {
    1: Int8Array,
    2: Uint8Array,
    3: Int16Array,
    4: Uint16Array,
    5: Int32Array,
    6: Uint32Array,
    9: Float32Array
  };
  var INDEX_ITEM_SIZE = 4;
  var DracoParser = class {
    constructor(draco) {
      _defineProperty(this, "draco", void 0);
      _defineProperty(this, "decoder", void 0);
      _defineProperty(this, "metadataQuerier", void 0);
      this.draco = draco;
      this.decoder = new this.draco.Decoder();
      this.metadataQuerier = new this.draco.MetadataQuerier();
    }
    destroy() {
      this.draco.destroy(this.decoder);
      this.draco.destroy(this.metadataQuerier);
    }
    parseSync(arrayBuffer) {
      let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      const buffer = new this.draco.DecoderBuffer();
      buffer.Init(new Int8Array(arrayBuffer), arrayBuffer.byteLength);
      this._disableAttributeTransforms(options);
      const geometry_type = this.decoder.GetEncodedGeometryType(buffer);
      const dracoGeometry = geometry_type === this.draco.TRIANGULAR_MESH ? new this.draco.Mesh() : new this.draco.PointCloud();
      try {
        let dracoStatus;
        switch (geometry_type) {
          case this.draco.TRIANGULAR_MESH:
            dracoStatus = this.decoder.DecodeBufferToMesh(buffer, dracoGeometry);
            break;
          case this.draco.POINT_CLOUD:
            dracoStatus = this.decoder.DecodeBufferToPointCloud(buffer, dracoGeometry);
            break;
          default:
            throw new Error("DRACO: Unknown geometry type.");
        }
        if (!dracoStatus.ok() || !dracoGeometry.ptr) {
          const message = "DRACO decompression failed: ".concat(dracoStatus.error_msg());
          throw new Error(message);
        }
        const loaderData = this._getDracoLoaderData(dracoGeometry, geometry_type, options);
        const geometry = this._getMeshData(dracoGeometry, loaderData, options);
        const boundingBox = getMeshBoundingBox(geometry.attributes);
        const schema = getDracoSchema(geometry.attributes, loaderData, geometry.indices);
        const data = {
          loader: "draco",
          loaderData,
          header: {
            vertexCount: dracoGeometry.num_points(),
            boundingBox
          },
          ...geometry,
          schema
        };
        return data;
      } finally {
        this.draco.destroy(buffer);
        if (dracoGeometry) {
          this.draco.destroy(dracoGeometry);
        }
      }
    }
    _getDracoLoaderData(dracoGeometry, geometry_type, options) {
      const metadata = this._getTopLevelMetadata(dracoGeometry);
      const attributes = this._getDracoAttributes(dracoGeometry, options);
      return {
        geometry_type,
        num_attributes: dracoGeometry.num_attributes(),
        num_points: dracoGeometry.num_points(),
        num_faces: dracoGeometry instanceof this.draco.Mesh ? dracoGeometry.num_faces() : 0,
        metadata,
        attributes
      };
    }
    _getDracoAttributes(dracoGeometry, options) {
      const dracoAttributes = {};
      for (let attributeId = 0; attributeId < dracoGeometry.num_attributes(); attributeId++) {
        const dracoAttribute = this.decoder.GetAttribute(dracoGeometry, attributeId);
        const metadata = this._getAttributeMetadata(dracoGeometry, attributeId);
        dracoAttributes[dracoAttribute.unique_id()] = {
          unique_id: dracoAttribute.unique_id(),
          attribute_type: dracoAttribute.attribute_type(),
          data_type: dracoAttribute.data_type(),
          num_components: dracoAttribute.num_components(),
          byte_offset: dracoAttribute.byte_offset(),
          byte_stride: dracoAttribute.byte_stride(),
          normalized: dracoAttribute.normalized(),
          attribute_index: attributeId,
          metadata
        };
        const quantization = this._getQuantizationTransform(dracoAttribute, options);
        if (quantization) {
          dracoAttributes[dracoAttribute.unique_id()].quantization_transform = quantization;
        }
        const octahedron = this._getOctahedronTransform(dracoAttribute, options);
        if (octahedron) {
          dracoAttributes[dracoAttribute.unique_id()].octahedron_transform = octahedron;
        }
      }
      return dracoAttributes;
    }
    _getMeshData(dracoGeometry, loaderData, options) {
      const attributes = this._getMeshAttributes(loaderData, dracoGeometry, options);
      const positionAttribute = attributes.POSITION;
      if (!positionAttribute) {
        throw new Error("DRACO: No position attribute found.");
      }
      if (dracoGeometry instanceof this.draco.Mesh) {
        switch (options.topology) {
          case "triangle-strip":
            return {
              topology: "triangle-strip",
              mode: 4,
              attributes,
              indices: {
                value: this._getTriangleStripIndices(dracoGeometry),
                size: 1
              }
            };
          case "triangle-list":
          default:
            return {
              topology: "triangle-list",
              mode: 5,
              attributes,
              indices: {
                value: this._getTriangleListIndices(dracoGeometry),
                size: 1
              }
            };
        }
      }
      return {
        topology: "point-list",
        mode: 0,
        attributes
      };
    }
    _getMeshAttributes(loaderData, dracoGeometry, options) {
      const attributes = {};
      for (const loaderAttribute of Object.values(loaderData.attributes)) {
        const attributeName = this._deduceAttributeName(loaderAttribute, options);
        loaderAttribute.name = attributeName;
        const {
          value,
          size
        } = this._getAttributeValues(dracoGeometry, loaderAttribute);
        attributes[attributeName] = {
          value,
          size,
          byteOffset: loaderAttribute.byte_offset,
          byteStride: loaderAttribute.byte_stride,
          normalized: loaderAttribute.normalized
        };
      }
      return attributes;
    }
    _getTriangleListIndices(dracoGeometry) {
      const numFaces = dracoGeometry.num_faces();
      const numIndices = numFaces * 3;
      const byteLength = numIndices * INDEX_ITEM_SIZE;
      const ptr = this.draco._malloc(byteLength);
      try {
        this.decoder.GetTrianglesUInt32Array(dracoGeometry, byteLength, ptr);
        return new Uint32Array(this.draco.HEAPF32.buffer, ptr, numIndices).slice();
      } finally {
        this.draco._free(ptr);
      }
    }
    _getTriangleStripIndices(dracoGeometry) {
      const dracoArray = new this.draco.DracoInt32Array();
      try {
        this.decoder.GetTriangleStripsFromMesh(dracoGeometry, dracoArray);
        return getUint32Array(dracoArray);
      } finally {
        this.draco.destroy(dracoArray);
      }
    }
    _getAttributeValues(dracoGeometry, attribute) {
      const TypedArrayCtor = DRACO_DATA_TYPE_TO_TYPED_ARRAY_MAP[attribute.data_type];
      const numComponents = attribute.num_components;
      const numPoints = dracoGeometry.num_points();
      const numValues = numPoints * numComponents;
      const byteLength = numValues * TypedArrayCtor.BYTES_PER_ELEMENT;
      const dataType = getDracoDataType(this.draco, TypedArrayCtor);
      let value;
      const ptr = this.draco._malloc(byteLength);
      try {
        const dracoAttribute = this.decoder.GetAttribute(dracoGeometry, attribute.attribute_index);
        this.decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, dracoAttribute, dataType, byteLength, ptr);
        value = new TypedArrayCtor(this.draco.HEAPF32.buffer, ptr, numValues).slice();
      } finally {
        this.draco._free(ptr);
      }
      return {
        value,
        size: numComponents
      };
    }
    _deduceAttributeName(attribute, options) {
      const uniqueId = attribute.unique_id;
      for (const [attributeName, attributeUniqueId] of Object.entries(options.extraAttributes || {})) {
        if (attributeUniqueId === uniqueId) {
          return attributeName;
        }
      }
      const thisAttributeType = attribute.attribute_type;
      for (const dracoAttributeConstant in DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP) {
        const attributeType = this.draco[dracoAttributeConstant];
        if (attributeType === thisAttributeType) {
          return DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP[dracoAttributeConstant];
        }
      }
      const entryName = options.attributeNameEntry || "name";
      if (attribute.metadata[entryName]) {
        return attribute.metadata[entryName].string;
      }
      return "CUSTOM_ATTRIBUTE_".concat(uniqueId);
    }
    _getTopLevelMetadata(dracoGeometry) {
      const dracoMetadata = this.decoder.GetMetadata(dracoGeometry);
      return this._getDracoMetadata(dracoMetadata);
    }
    _getAttributeMetadata(dracoGeometry, attributeId) {
      const dracoMetadata = this.decoder.GetAttributeMetadata(dracoGeometry, attributeId);
      return this._getDracoMetadata(dracoMetadata);
    }
    _getDracoMetadata(dracoMetadata) {
      if (!dracoMetadata || !dracoMetadata.ptr) {
        return {};
      }
      const result = {};
      const numEntries = this.metadataQuerier.NumEntries(dracoMetadata);
      for (let entryIndex = 0; entryIndex < numEntries; entryIndex++) {
        const entryName = this.metadataQuerier.GetEntryName(dracoMetadata, entryIndex);
        result[entryName] = this._getDracoMetadataField(dracoMetadata, entryName);
      }
      return result;
    }
    _getDracoMetadataField(dracoMetadata, entryName) {
      const dracoArray = new this.draco.DracoInt32Array();
      try {
        this.metadataQuerier.GetIntEntryArray(dracoMetadata, entryName, dracoArray);
        const intArray = getInt32Array(dracoArray);
        return {
          int: this.metadataQuerier.GetIntEntry(dracoMetadata, entryName),
          string: this.metadataQuerier.GetStringEntry(dracoMetadata, entryName),
          double: this.metadataQuerier.GetDoubleEntry(dracoMetadata, entryName),
          intArray
        };
      } finally {
        this.draco.destroy(dracoArray);
      }
    }
    _disableAttributeTransforms(options) {
      const {
        quantizedAttributes = [],
        octahedronAttributes = []
      } = options;
      const skipAttributes = [...quantizedAttributes, ...octahedronAttributes];
      for (const dracoAttributeName of skipAttributes) {
        this.decoder.SkipAttributeTransform(this.draco[dracoAttributeName]);
      }
    }
    _getQuantizationTransform(dracoAttribute, options) {
      const {
        quantizedAttributes = []
      } = options;
      const attribute_type = dracoAttribute.attribute_type();
      const skip = quantizedAttributes.map((type) => this.decoder[type]).includes(attribute_type);
      if (skip) {
        const transform2 = new this.draco.AttributeQuantizationTransform();
        try {
          if (transform2.InitFromAttribute(dracoAttribute)) {
            return {
              quantization_bits: transform2.quantization_bits(),
              range: transform2.range(),
              min_values: new Float32Array([1, 2, 3]).map((i3) => transform2.min_value(i3))
            };
          }
        } finally {
          this.draco.destroy(transform2);
        }
      }
      return null;
    }
    _getOctahedronTransform(dracoAttribute, options) {
      const {
        octahedronAttributes = []
      } = options;
      const attribute_type = dracoAttribute.attribute_type();
      const octahedron = octahedronAttributes.map((type) => this.decoder[type]).includes(attribute_type);
      if (octahedron) {
        const transform2 = new this.draco.AttributeQuantizationTransform();
        try {
          if (transform2.InitFromAttribute(dracoAttribute)) {
            return {
              quantization_bits: transform2.quantization_bits()
            };
          }
        } finally {
          this.draco.destroy(transform2);
        }
      }
      return null;
    }
  };
  function getDracoDataType(draco, attributeType) {
    switch (attributeType) {
      case Float32Array:
        return draco.DT_FLOAT32;
      case Int8Array:
        return draco.DT_INT8;
      case Int16Array:
        return draco.DT_INT16;
      case Int32Array:
        return draco.DT_INT32;
      case Uint8Array:
        return draco.DT_UINT8;
      case Uint16Array:
        return draco.DT_UINT16;
      case Uint32Array:
        return draco.DT_UINT32;
      default:
        return draco.DT_INVALID;
    }
  }
  function getInt32Array(dracoArray) {
    const numValues = dracoArray.size();
    const intArray = new Int32Array(numValues);
    for (let i3 = 0; i3 < numValues; i3++) {
      intArray[i3] = dracoArray.GetValue(i3);
    }
    return intArray;
  }
  function getUint32Array(dracoArray) {
    const numValues = dracoArray.size();
    const intArray = new Int32Array(numValues);
    for (let i3 = 0; i3 < numValues; i3++) {
      intArray[i3] = dracoArray.GetValue(i3);
    }
    return intArray;
  }

  // ../../node_modules/@loaders.gl/draco/dist/esm/lib/draco-module-loader.js
  var DRACO_DECODER_VERSION = "1.5.5";
  var DRACO_ENCODER_VERSION = "1.4.1";
  var STATIC_DECODER_URL = "https://www.gstatic.com/draco/versioned/decoders/".concat(DRACO_DECODER_VERSION);
  var DRACO_JS_DECODER_URL = "".concat(STATIC_DECODER_URL, "/draco_decoder.js");
  var DRACO_WASM_WRAPPER_URL = "".concat(STATIC_DECODER_URL, "/draco_wasm_wrapper.js");
  var DRACO_WASM_DECODER_URL = "".concat(STATIC_DECODER_URL, "/draco_decoder.wasm");
  var DRACO_ENCODER_URL = "https://raw.githubusercontent.com/google/draco/".concat(DRACO_ENCODER_VERSION, "/javascript/draco_encoder.js");
  var loadDecoderPromise;
  async function loadDracoDecoderModule(options) {
    const modules = options.modules || {};
    if (modules.draco3d) {
      loadDecoderPromise = loadDecoderPromise || modules.draco3d.createDecoderModule({}).then((draco) => {
        return {
          draco
        };
      });
    } else {
      loadDecoderPromise = loadDecoderPromise || loadDracoDecoder(options);
    }
    return await loadDecoderPromise;
  }
  async function loadDracoDecoder(options) {
    let DracoDecoderModule;
    let wasmBinary;
    switch (options.draco && options.draco.decoderType) {
      case "js":
        DracoDecoderModule = await loadLibrary(DRACO_JS_DECODER_URL, "draco", options);
        break;
      case "wasm":
      default:
        [DracoDecoderModule, wasmBinary] = await Promise.all([await loadLibrary(DRACO_WASM_WRAPPER_URL, "draco", options), await loadLibrary(DRACO_WASM_DECODER_URL, "draco", options)]);
    }
    DracoDecoderModule = DracoDecoderModule || globalThis.DracoDecoderModule;
    return await initializeDracoDecoder(DracoDecoderModule, wasmBinary);
  }
  function initializeDracoDecoder(DracoDecoderModule, wasmBinary) {
    const options = {};
    if (wasmBinary) {
      options.wasmBinary = wasmBinary;
    }
    return new Promise((resolve) => {
      DracoDecoderModule({
        ...options,
        onModuleLoaded: (draco) => resolve({
          draco
        })
      });
    });
  }

  // ../../node_modules/@loaders.gl/draco/dist/esm/index.js
  var DracoLoader2 = {
    ...DracoLoader,
    parse
  };
  async function parse(arrayBuffer, options) {
    const {
      draco
    } = await loadDracoDecoderModule(options);
    const dracoParser = new DracoParser(draco);
    try {
      return dracoParser.parseSync(arrayBuffer, options === null || options === void 0 ? void 0 : options.draco);
    } finally {
      dracoParser.destroy();
    }
  }

  // ../../node_modules/@loaders.gl/math/dist/esm/geometry/constants.js
  var GL_PRIMITIVE_MODE = {
    POINTS: 0,
    LINES: 1,
    LINE_LOOP: 2,
    LINE_STRIP: 3,
    TRIANGLES: 4,
    TRIANGLE_STRIP: 5,
    TRIANGLE_FAN: 6
  };
  var GL_TYPE = {
    BYTE: 5120,
    UNSIGNED_BYTE: 5121,
    SHORT: 5122,
    UNSIGNED_SHORT: 5123,
    INT: 5124,
    UNSIGNED_INT: 5125,
    FLOAT: 5126,
    DOUBLE: 5130
  };
  var GL2 = {
    ...GL_PRIMITIVE_MODE,
    ...GL_TYPE
  };

  // ../../node_modules/@loaders.gl/math/dist/esm/geometry/gl/gl-type.js
  var GL_TYPE_TO_ARRAY_TYPE = {
    [GL_TYPE.DOUBLE]: Float64Array,
    [GL_TYPE.FLOAT]: Float32Array,
    [GL_TYPE.UNSIGNED_SHORT]: Uint16Array,
    [GL_TYPE.UNSIGNED_INT]: Uint32Array,
    [GL_TYPE.UNSIGNED_BYTE]: Uint8Array,
    [GL_TYPE.BYTE]: Int8Array,
    [GL_TYPE.SHORT]: Int16Array,
    [GL_TYPE.INT]: Int32Array
  };
  var NAME_TO_GL_TYPE = {
    DOUBLE: GL_TYPE.DOUBLE,
    FLOAT: GL_TYPE.FLOAT,
    UNSIGNED_SHORT: GL_TYPE.UNSIGNED_SHORT,
    UNSIGNED_INT: GL_TYPE.UNSIGNED_INT,
    UNSIGNED_BYTE: GL_TYPE.UNSIGNED_BYTE,
    BYTE: GL_TYPE.BYTE,
    SHORT: GL_TYPE.SHORT,
    INT: GL_TYPE.INT
  };
  var ERR_TYPE_CONVERSION = "Failed to convert GL type";
  var GLType = class {
    static fromTypedArray(arrayOrType) {
      arrayOrType = ArrayBuffer.isView(arrayOrType) ? arrayOrType.constructor : arrayOrType;
      for (const glType in GL_TYPE_TO_ARRAY_TYPE) {
        const ArrayType = GL_TYPE_TO_ARRAY_TYPE[glType];
        if (ArrayType === arrayOrType) {
          return glType;
        }
      }
      throw new Error(ERR_TYPE_CONVERSION);
    }
    static fromName(name10) {
      const glType = NAME_TO_GL_TYPE[name10];
      if (!glType) {
        throw new Error(ERR_TYPE_CONVERSION);
      }
      return glType;
    }
    static getArrayType(glType) {
      switch (glType) {
        case GL_TYPE.UNSIGNED_SHORT_5_6_5:
        case GL_TYPE.UNSIGNED_SHORT_4_4_4_4:
        case GL_TYPE.UNSIGNED_SHORT_5_5_5_1:
          return Uint16Array;
        default:
          const ArrayType = GL_TYPE_TO_ARRAY_TYPE[glType];
          if (!ArrayType) {
            throw new Error(ERR_TYPE_CONVERSION);
          }
          return ArrayType;
      }
    }
    static getByteSize(glType) {
      const ArrayType = GLType.getArrayType(glType);
      return ArrayType.BYTES_PER_ELEMENT;
    }
    static validate(glType) {
      return Boolean(GLType.getArrayType(glType));
    }
    static createTypedArray(glType, buffer) {
      let byteOffset = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
      let length5 = arguments.length > 3 ? arguments[3] : void 0;
      if (length5 === void 0) {
        length5 = (buffer.byteLength - byteOffset) / GLType.getByteSize(glType);
      }
      const ArrayType = GLType.getArrayType(glType);
      return new ArrayType(buffer, byteOffset, length5);
    }
  };

  // ../../node_modules/@loaders.gl/math/dist/esm/geometry/utils/assert.js
  function assert10(condition, message) {
    if (!condition) {
      throw new Error("math.gl assertion failed. ".concat(message));
    }
  }

  // ../../node_modules/@loaders.gl/math/dist/esm/geometry/colors/rgb565.js
  function decodeRGB565(rgb565) {
    let target = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [0, 0, 0];
    const r5 = rgb565 >> 11 & 31;
    const g6 = rgb565 >> 5 & 63;
    const b5 = rgb565 & 31;
    target[0] = r5 << 3;
    target[1] = g6 << 2;
    target[2] = b5 << 3;
    return target;
  }

  // ../../node_modules/@loaders.gl/math/dist/esm/geometry/compression/attribute-compression.js
  var RIGHT_SHIFT = 1 / 256;
  var scratchVector25 = new Vector2();
  var scratchVector34 = new Vector3();
  var scratchEncodeVector2 = new Vector2();
  var octEncodeScratch = new Vector2();
  var uint8ForceArray = new Uint8Array(1);
  function fromSNorm(value) {
    let rangeMaximum = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 255;
    return clamp2(value, 0, rangeMaximum) / rangeMaximum * 2 - 1;
  }
  function signNotZero(value) {
    return value < 0 ? -1 : 1;
  }
  function octDecodeInRange(x2, y2, rangeMax, result) {
    assert10(result);
    if (x2 < 0 || x2 > rangeMax || y2 < 0 || y2 > rangeMax) {
      throw new Error("x and y must be unsigned normalized integers between 0 and ".concat(rangeMax));
    }
    result.x = fromSNorm(x2, rangeMax);
    result.y = fromSNorm(y2, rangeMax);
    result.z = 1 - (Math.abs(result.x) + Math.abs(result.y));
    if (result.z < 0) {
      const oldVX = result.x;
      result.x = (1 - Math.abs(result.y)) * signNotZero(oldVX);
      result.y = (1 - Math.abs(oldVX)) * signNotZero(result.y);
    }
    return result.normalize();
  }
  function octDecode(x2, y2, result) {
    return octDecodeInRange(x2, y2, 255, result);
  }

  // ../../node_modules/@loaders.gl/3d-tiles/dist/esm/lib/classes/tile-3d-feature-table.js
  var Tile3DFeatureTable = class {
    constructor(featureTableJson, featureTableBinary) {
      _defineProperty(this, "json", void 0);
      _defineProperty(this, "buffer", void 0);
      _defineProperty(this, "featuresLength", 0);
      _defineProperty(this, "_cachedTypedArrays", {});
      this.json = featureTableJson;
      this.buffer = featureTableBinary;
    }
    getExtension(extensionName) {
      return this.json.extensions && this.json.extensions[extensionName];
    }
    hasProperty(propertyName) {
      return Boolean(this.json[propertyName]);
    }
    getGlobalProperty(propertyName) {
      let componentType = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : GL2.UNSIGNED_INT;
      let componentLength = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
      const jsonValue = this.json[propertyName];
      if (jsonValue && Number.isFinite(jsonValue.byteOffset)) {
        return this._getTypedArrayFromBinary(propertyName, componentType, componentLength, 1, jsonValue.byteOffset);
      }
      return jsonValue;
    }
    getPropertyArray(propertyName, componentType, componentLength) {
      const jsonValue = this.json[propertyName];
      if (jsonValue && Number.isFinite(jsonValue.byteOffset)) {
        if ("componentType" in jsonValue) {
          componentType = GLType.fromName(jsonValue.componentType);
        }
        return this._getTypedArrayFromBinary(propertyName, componentType, componentLength, this.featuresLength, jsonValue.byteOffset);
      }
      return this._getTypedArrayFromArray(propertyName, componentType, jsonValue);
    }
    getProperty(propertyName, componentType, componentLength, featureId, result) {
      const jsonValue = this.json[propertyName];
      if (!jsonValue) {
        return jsonValue;
      }
      const typedArray = this.getPropertyArray(propertyName, componentType, componentLength);
      if (componentLength === 1) {
        return typedArray[featureId];
      }
      for (let i3 = 0; i3 < componentLength; ++i3) {
        result[i3] = typedArray[componentLength * featureId + i3];
      }
      return result;
    }
    _getTypedArrayFromBinary(propertyName, componentType, componentLength, count, byteOffset) {
      const cachedTypedArrays = this._cachedTypedArrays;
      let typedArray = cachedTypedArrays[propertyName];
      if (!typedArray) {
        typedArray = GLType.createTypedArray(componentType, this.buffer.buffer, this.buffer.byteOffset + byteOffset, count * componentLength);
        cachedTypedArrays[propertyName] = typedArray;
      }
      return typedArray;
    }
    _getTypedArrayFromArray(propertyName, componentType, array) {
      const cachedTypedArrays = this._cachedTypedArrays;
      let typedArray = cachedTypedArrays[propertyName];
      if (!typedArray) {
        typedArray = GLType.createTypedArray(componentType, array);
        cachedTypedArrays[propertyName] = typedArray;
      }
      return typedArray;
    }
  };

  // ../../node_modules/@loaders.gl/3d-tiles/dist/esm/lib/classes/helpers/tile-3d-accessor-utils.js
  var COMPONENTS_PER_ATTRIBUTE = {
    SCALAR: 1,
    VEC2: 2,
    VEC3: 3,
    VEC4: 4,
    MAT2: 4,
    MAT3: 9,
    MAT4: 16
  };
  var UNPACKER = {
    SCALAR: (values, i3) => values[i3],
    VEC2: (values, i3) => [values[2 * i3 + 0], values[2 * i3 + 1]],
    VEC3: (values, i3) => [values[3 * i3 + 0], values[3 * i3 + 1], values[3 * i3 + 2]],
    VEC4: (values, i3) => [values[4 * i3 + 0], values[4 * i3 + 1], values[4 * i3 + 2], values[4 * i3 + 3]],
    MAT2: (values, i3) => [values[4 * i3 + 0], values[4 * i3 + 1], values[4 * i3 + 2], values[4 * i3 + 3]],
    MAT3: (values, i3) => [values[9 * i3 + 0], values[9 * i3 + 1], values[9 * i3 + 2], values[9 * i3 + 3], values[9 * i3 + 4], values[9 * i3 + 5], values[9 * i3 + 6], values[9 * i3 + 7], values[9 * i3 + 8]],
    MAT4: (values, i3) => [values[16 * i3 + 0], values[16 * i3 + 1], values[16 * i3 + 2], values[16 * i3 + 3], values[16 * i3 + 4], values[16 * i3 + 5], values[16 * i3 + 6], values[16 * i3 + 7], values[16 * i3 + 8], values[16 * i3 + 9], values[16 * i3 + 10], values[16 * i3 + 11], values[16 * i3 + 12], values[16 * i3 + 13], values[16 * i3 + 14], values[16 * i3 + 15]]
  };
  var PACKER = {
    SCALAR: (x2, values, i3) => {
      values[i3] = x2;
    },
    VEC2: (x2, values, i3) => {
      values[2 * i3 + 0] = x2[0];
      values[2 * i3 + 1] = x2[1];
    },
    VEC3: (x2, values, i3) => {
      values[3 * i3 + 0] = x2[0];
      values[3 * i3 + 1] = x2[1];
      values[3 * i3 + 2] = x2[2];
    },
    VEC4: (x2, values, i3) => {
      values[4 * i3 + 0] = x2[0];
      values[4 * i3 + 1] = x2[1];
      values[4 * i3 + 2] = x2[2];
      values[4 * i3 + 3] = x2[3];
    },
    MAT2: (x2, values, i3) => {
      values[4 * i3 + 0] = x2[0];
      values[4 * i3 + 1] = x2[1];
      values[4 * i3 + 2] = x2[2];
      values[4 * i3 + 3] = x2[3];
    },
    MAT3: (x2, values, i3) => {
      values[9 * i3 + 0] = x2[0];
      values[9 * i3 + 1] = x2[1];
      values[9 * i3 + 2] = x2[2];
      values[9 * i3 + 3] = x2[3];
      values[9 * i3 + 4] = x2[4];
      values[9 * i3 + 5] = x2[5];
      values[9 * i3 + 6] = x2[6];
      values[9 * i3 + 7] = x2[7];
      values[9 * i3 + 8] = x2[8];
      values[9 * i3 + 9] = x2[9];
    },
    MAT4: (x2, values, i3) => {
      values[16 * i3 + 0] = x2[0];
      values[16 * i3 + 1] = x2[1];
      values[16 * i3 + 2] = x2[2];
      values[16 * i3 + 3] = x2[3];
      values[16 * i3 + 4] = x2[4];
      values[16 * i3 + 5] = x2[5];
      values[16 * i3 + 6] = x2[6];
      values[16 * i3 + 7] = x2[7];
      values[16 * i3 + 8] = x2[8];
      values[16 * i3 + 9] = x2[9];
      values[16 * i3 + 10] = x2[10];
      values[16 * i3 + 11] = x2[11];
      values[16 * i3 + 12] = x2[12];
      values[16 * i3 + 13] = x2[13];
      values[16 * i3 + 14] = x2[14];
      values[16 * i3 + 15] = x2[15];
    }
  };
  function createTypedArrayFromAccessor(tile3DAccessor, buffer, byteOffset, length5) {
    const {
      componentType
    } = tile3DAccessor;
    assert2(tile3DAccessor.componentType);
    const type = typeof componentType === "string" ? GLType.fromName(componentType) : componentType;
    const size = COMPONENTS_PER_ATTRIBUTE[tile3DAccessor.type];
    const unpacker = UNPACKER[tile3DAccessor.type];
    const packer = PACKER[tile3DAccessor.type];
    byteOffset += tile3DAccessor.byteOffset;
    const values = GLType.createTypedArray(type, buffer, byteOffset, size * length5);
    return {
      values,
      type,
      size,
      unpacker,
      packer
    };
  }

  // ../../node_modules/@loaders.gl/3d-tiles/dist/esm/lib/classes/tile-3d-batch-table-hierarchy.js
  var defined4 = (x2) => x2 !== void 0;
  function initializeHierarchy(batchTable, jsonHeader, binaryBody) {
    if (!jsonHeader) {
      return null;
    }
    let hierarchy = batchTable.getExtension("3DTILES_batch_table_hierarchy");
    const legacyHierarchy = jsonHeader.HIERARCHY;
    if (legacyHierarchy) {
      console.warn("3D Tile Parser: HIERARCHY is deprecated. Use 3DTILES_batch_table_hierarchy.");
      jsonHeader.extensions = jsonHeader.extensions || {};
      jsonHeader.extensions["3DTILES_batch_table_hierarchy"] = legacyHierarchy;
      hierarchy = legacyHierarchy;
    }
    if (!hierarchy) {
      return null;
    }
    return initializeHierarchyValues(hierarchy, binaryBody);
  }
  function initializeHierarchyValues(hierarchyJson, binaryBody) {
    let i3;
    let classId;
    let binaryAccessor;
    const instancesLength = hierarchyJson.instancesLength;
    const classes = hierarchyJson.classes;
    let classIds = hierarchyJson.classIds;
    let parentCounts = hierarchyJson.parentCounts;
    let parentIds = hierarchyJson.parentIds;
    let parentIdsLength = instancesLength;
    if (defined4(classIds.byteOffset)) {
      classIds.componentType = defaultValue(classIds.componentType, GL.UNSIGNED_SHORT);
      classIds.type = AttributeType.SCALAR;
      binaryAccessor = getBinaryAccessor(classIds);
      classIds = binaryAccessor.createArrayBufferView(binaryBody.buffer, binaryBody.byteOffset + classIds.byteOffset, instancesLength);
    }
    let parentIndexes;
    if (defined4(parentCounts)) {
      if (defined4(parentCounts.byteOffset)) {
        parentCounts.componentType = defaultValue(parentCounts.componentType, GL.UNSIGNED_SHORT);
        parentCounts.type = AttributeType.SCALAR;
        binaryAccessor = getBinaryAccessor(parentCounts);
        parentCounts = binaryAccessor.createArrayBufferView(binaryBody.buffer, binaryBody.byteOffset + parentCounts.byteOffset, instancesLength);
      }
      parentIndexes = new Uint16Array(instancesLength);
      parentIdsLength = 0;
      for (i3 = 0; i3 < instancesLength; ++i3) {
        parentIndexes[i3] = parentIdsLength;
        parentIdsLength += parentCounts[i3];
      }
    }
    if (defined4(parentIds) && defined4(parentIds.byteOffset)) {
      parentIds.componentType = defaultValue(parentIds.componentType, GL.UNSIGNED_SHORT);
      parentIds.type = AttributeType.SCALAR;
      binaryAccessor = getBinaryAccessor(parentIds);
      parentIds = binaryAccessor.createArrayBufferView(binaryBody.buffer, binaryBody.byteOffset + parentIds.byteOffset, parentIdsLength);
    }
    const classesLength = classes.length;
    for (i3 = 0; i3 < classesLength; ++i3) {
      const classInstancesLength = classes[i3].length;
      const properties = classes[i3].instances;
      const binaryProperties = getBinaryProperties(classInstancesLength, properties, binaryBody);
      classes[i3].instances = combine(binaryProperties, properties);
    }
    const classCounts = new Array(classesLength).fill(0);
    const classIndexes = new Uint16Array(instancesLength);
    for (i3 = 0; i3 < instancesLength; ++i3) {
      classId = classIds[i3];
      classIndexes[i3] = classCounts[classId];
      ++classCounts[classId];
    }
    const hierarchy = {
      classes,
      classIds,
      classIndexes,
      parentCounts,
      parentIndexes,
      parentIds
    };
    validateHierarchy(hierarchy);
    return hierarchy;
  }
  function traverseHierarchy(hierarchy, instanceIndex, endConditionCallback) {
    if (!hierarchy) {
      return;
    }
    const parentCounts = hierarchy.parentCounts;
    const parentIds = hierarchy.parentIds;
    if (parentIds) {
      return endConditionCallback(hierarchy, instanceIndex);
    }
    if (parentCounts > 0) {
      return traverseHierarchyMultipleParents(hierarchy, instanceIndex, endConditionCallback);
    }
    return traverseHierarchySingleParent(hierarchy, instanceIndex, endConditionCallback);
  }
  function traverseHierarchyMultipleParents(hierarchy, instanceIndex, endConditionCallback) {
    const classIds = hierarchy.classIds;
    const parentCounts = hierarchy.parentCounts;
    const parentIds = hierarchy.parentIds;
    const parentIndexes = hierarchy.parentIndexes;
    const instancesLength = classIds.length;
    const visited = scratchVisited;
    visited.length = Math.max(visited.length, instancesLength);
    const visitedMarker = ++marker;
    const stack2 = scratchStack;
    stack2.length = 0;
    stack2.push(instanceIndex);
    while (stack2.length > 0) {
      instanceIndex = stack2.pop();
      if (visited[instanceIndex] === visitedMarker) {
        continue;
      }
      visited[instanceIndex] = visitedMarker;
      const result = endConditionCallback(hierarchy, instanceIndex);
      if (defined4(result)) {
        return result;
      }
      const parentCount = parentCounts[instanceIndex];
      const parentIndex = parentIndexes[instanceIndex];
      for (let i3 = 0; i3 < parentCount; ++i3) {
        const parentId = parentIds[parentIndex + i3];
        if (parentId !== instanceIndex) {
          stack2.push(parentId);
        }
      }
    }
    return null;
  }
  function traverseHierarchySingleParent(hierarchy, instanceIndex, endConditionCallback) {
    let hasParent = true;
    while (hasParent) {
      const result = endConditionCallback(hierarchy, instanceIndex);
      if (defined4(result)) {
        return result;
      }
      const parentId = hierarchy.parentIds[instanceIndex];
      hasParent = parentId !== instanceIndex;
      instanceIndex = parentId;
    }
    throw new Error("traverseHierarchySingleParent");
  }
  function validateHierarchy(hierarchy) {
    const scratchValidateStack = [];
    const classIds = hierarchy.classIds;
    const instancesLength = classIds.length;
    for (let i3 = 0; i3 < instancesLength; ++i3) {
      validateInstance(hierarchy, i3, stack);
    }
  }
  function validateInstance(hierarchy, instanceIndex, stack2) {
    const parentCounts = hierarchy.parentCounts;
    const parentIds = hierarchy.parentIds;
    const parentIndexes = hierarchy.parentIndexes;
    const classIds = hierarchy.classIds;
    const instancesLength = classIds.length;
    if (!defined4(parentIds)) {
      return;
    }
    assert(instanceIndex < instancesLength, "Parent index ".concat(instanceIndex, " exceeds the total number of instances: ").concat(instancesLength));
    assert(stack2.indexOf(instanceIndex) === -1, "Circular dependency detected in the batch table hierarchy.");
    stack2.push(instanceIndex);
    const parentCount = defined4(parentCounts) ? parentCounts[instanceIndex] : 1;
    const parentIndex = defined4(parentCounts) ? parentIndexes[instanceIndex] : instanceIndex;
    for (let i3 = 0; i3 < parentCount; ++i3) {
      const parentId = parentIds[parentIndex + i3];
      if (parentId !== instanceIndex) {
        validateInstance(hierarchy, parentId, stack2);
      }
    }
    stack2.pop(instanceIndex);
  }

  // ../../node_modules/@loaders.gl/3d-tiles/dist/esm/lib/classes/tile-3d-batch-table.js
  function defined5(x2) {
    return x2 !== void 0 && x2 !== null;
  }
  var clone3 = (x2, y2) => x2;
  var IGNORED_PROPERTY_FIELDS = {
    HIERARCHY: true,
    extensions: true,
    extras: true
  };
  var Tile3DBatchTableParser = class {
    constructor(json, binary, featureCount) {
      var _this$json;
      let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
      _defineProperty(this, "json", void 0);
      _defineProperty(this, "binary", void 0);
      _defineProperty(this, "featureCount", void 0);
      _defineProperty(this, "_extensions", void 0);
      _defineProperty(this, "_properties", void 0);
      _defineProperty(this, "_binaryProperties", void 0);
      _defineProperty(this, "_hierarchy", void 0);
      assert2(featureCount >= 0);
      this.json = json || {};
      this.binary = binary;
      this.featureCount = featureCount;
      this._extensions = ((_this$json = this.json) === null || _this$json === void 0 ? void 0 : _this$json.extensions) || {};
      this._properties = {};
      for (const propertyName in this.json) {
        if (!IGNORED_PROPERTY_FIELDS[propertyName]) {
          this._properties[propertyName] = this.json[propertyName];
        }
      }
      this._binaryProperties = this._initializeBinaryProperties();
      if (options["3DTILES_batch_table_hierarchy"]) {
        this._hierarchy = initializeHierarchy(this, this.json, this.binary);
      }
    }
    getExtension(extensionName) {
      return this.json && this.json.extensions && this.json.extensions[extensionName];
    }
    memorySizeInBytes() {
      return 0;
    }
    isClass(batchId, className) {
      this._checkBatchId(batchId);
      assert2(typeof className === "string", className);
      if (this._hierarchy) {
        const result = traverseHierarchy(this._hierarchy, batchId, (hierarchy, instanceIndex) => {
          const classId = hierarchy.classIds[instanceIndex];
          const instanceClass = hierarchy.classes[classId];
          return instanceClass.name === className;
        });
        return defined5(result);
      }
      return false;
    }
    isExactClass(batchId, className) {
      assert2(typeof className === "string", className);
      return this.getExactClassName(batchId) === className;
    }
    getExactClassName(batchId) {
      this._checkBatchId(batchId);
      if (this._hierarchy) {
        const classId = this._hierarchy.classIds[batchId];
        const instanceClass = this._hierarchy.classes[classId];
        return instanceClass.name;
      }
      return void 0;
    }
    hasProperty(batchId, name10) {
      this._checkBatchId(batchId);
      assert2(typeof name10 === "string", name10);
      return defined5(this._properties[name10]) || this._hasPropertyInHierarchy(batchId, name10);
    }
    getPropertyNames(batchId, results) {
      this._checkBatchId(batchId);
      results = defined5(results) ? results : [];
      results.length = 0;
      const propertyNames = Object.keys(this._properties);
      results.push(...propertyNames);
      if (this._hierarchy) {
        this._getPropertyNamesInHierarchy(batchId, results);
      }
      return results;
    }
    getProperty(batchId, name10) {
      this._checkBatchId(batchId);
      assert2(typeof name10 === "string", name10);
      if (this._binaryProperties) {
        const binaryProperty = this._binaryProperties[name10];
        if (defined5(binaryProperty)) {
          return this._getBinaryProperty(binaryProperty, batchId);
        }
      }
      const propertyValues = this._properties[name10];
      if (defined5(propertyValues)) {
        return clone3(propertyValues[batchId], true);
      }
      if (this._hierarchy) {
        const hierarchyProperty = this._getHierarchyProperty(batchId, name10);
        if (defined5(hierarchyProperty)) {
          return hierarchyProperty;
        }
      }
      return void 0;
    }
    setProperty(batchId, name10, value) {
      const featureCount = this.featureCount;
      this._checkBatchId(batchId);
      assert2(typeof name10 === "string", name10);
      if (this._binaryProperties) {
        const binaryProperty = this._binaryProperties[name10];
        if (binaryProperty) {
          this._setBinaryProperty(binaryProperty, batchId, value);
          return;
        }
      }
      if (this._hierarchy) {
        if (this._setHierarchyProperty(this, batchId, name10, value)) {
          return;
        }
      }
      let propertyValues = this._properties[name10];
      if (!defined5(propertyValues)) {
        this._properties[name10] = new Array(featureCount);
        propertyValues = this._properties[name10];
      }
      propertyValues[batchId] = clone3(value, true);
    }
    _checkBatchId(batchId) {
      const valid = batchId >= 0 && batchId < this.featureCount;
      if (!valid) {
        throw new Error("batchId not in range [0, featureCount - 1].");
      }
    }
    _getBinaryProperty(binaryProperty, index) {
      return binaryProperty.unpack(binaryProperty.typedArray, index);
    }
    _setBinaryProperty(binaryProperty, index, value) {
      binaryProperty.pack(value, binaryProperty.typedArray, index);
    }
    _initializeBinaryProperties() {
      let binaryProperties = null;
      for (const name10 in this._properties) {
        const property = this._properties[name10];
        const binaryProperty = this._initializeBinaryProperty(name10, property);
        if (binaryProperty) {
          binaryProperties = binaryProperties || {};
          binaryProperties[name10] = binaryProperty;
        }
      }
      return binaryProperties;
    }
    _initializeBinaryProperty(name10, property) {
      if ("byteOffset" in property) {
        const tile3DAccessor = property;
        assert2(this.binary, "Property ".concat(name10, " requires a batch table binary."));
        assert2(tile3DAccessor.type, "Property ".concat(name10, " requires a type."));
        const accessor = createTypedArrayFromAccessor(tile3DAccessor, this.binary.buffer, this.binary.byteOffset | 0, this.featureCount);
        return {
          typedArray: accessor.values,
          componentCount: accessor.size,
          unpack: accessor.unpacker,
          pack: accessor.packer
        };
      }
      return null;
    }
    _hasPropertyInHierarchy(batchId, name10) {
      if (!this._hierarchy) {
        return false;
      }
      const result = traverseHierarchy(this._hierarchy, batchId, (hierarchy, instanceIndex) => {
        const classId = hierarchy.classIds[instanceIndex];
        const instances = hierarchy.classes[classId].instances;
        return defined5(instances[name10]);
      });
      return defined5(result);
    }
    _getPropertyNamesInHierarchy(batchId, results) {
      traverseHierarchy(this._hierarchy, batchId, (hierarchy, instanceIndex) => {
        const classId = hierarchy.classIds[instanceIndex];
        const instances = hierarchy.classes[classId].instances;
        for (const name10 in instances) {
          if (instances.hasOwnProperty(name10)) {
            if (results.indexOf(name10) === -1) {
              results.push(name10);
            }
          }
        }
      });
    }
    _getHierarchyProperty(batchId, name10) {
      return traverseHierarchy(this._hierarchy, batchId, (hierarchy, instanceIndex) => {
        const classId = hierarchy.classIds[instanceIndex];
        const instanceClass = hierarchy.classes[classId];
        const indexInClass = hierarchy.classIndexes[instanceIndex];
        const propertyValues = instanceClass.instances[name10];
        if (defined5(propertyValues)) {
          if (defined5(propertyValues.typedArray)) {
            return this._getBinaryProperty(propertyValues, indexInClass);
          }
          return clone3(propertyValues[indexInClass], true);
        }
        return null;
      });
    }
    _setHierarchyProperty(batchTable, batchId, name10, value) {
      const result = traverseHierarchy(this._hierarchy, batchId, (hierarchy, instanceIndex) => {
        const classId = hierarchy.classIds[instanceIndex];
        const instanceClass = hierarchy.classes[classId];
        const indexInClass = hierarchy.classIndexes[instanceIndex];
        const propertyValues = instanceClass.instances[name10];
        if (defined5(propertyValues)) {
          assert2(instanceIndex === batchId, 'Inherited property "'.concat(name10, '" is read-only.'));
          if (defined5(propertyValues.typedArray)) {
            this._setBinaryProperty(propertyValues, indexInClass, value);
          } else {
            propertyValues[indexInClass] = clone3(value, true);
          }
          return true;
        }
        return false;
      });
      return defined5(result);
    }
  };

  // ../../node_modules/@loaders.gl/3d-tiles/dist/esm/lib/parsers/helpers/parse-3d-tile-header.js
  var SIZEOF_UINT32 = 4;
  function parse3DTileHeaderSync(tile, arrayBuffer) {
    let byteOffset = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
    const view = new DataView(arrayBuffer);
    tile.magic = view.getUint32(byteOffset, true);
    byteOffset += SIZEOF_UINT32;
    tile.version = view.getUint32(byteOffset, true);
    byteOffset += SIZEOF_UINT32;
    tile.byteLength = view.getUint32(byteOffset, true);
    byteOffset += SIZEOF_UINT32;
    if (tile.version !== 1) {
      throw new Error("3D Tile Version ".concat(tile.version, " not supported"));
    }
    return byteOffset;
  }

  // ../../node_modules/@loaders.gl/3d-tiles/dist/esm/lib/parsers/helpers/parse-3d-tile-tables.js
  var SIZEOF_UINT322 = 4;
  var DEPRECATION_WARNING = "b3dm tile in legacy format.";
  function parse3DTileTablesHeaderSync(tile, arrayBuffer, byteOffset) {
    const view = new DataView(arrayBuffer);
    let batchLength;
    tile.header = tile.header || {};
    let featureTableJsonByteLength = view.getUint32(byteOffset, true);
    byteOffset += SIZEOF_UINT322;
    let featureTableBinaryByteLength = view.getUint32(byteOffset, true);
    byteOffset += SIZEOF_UINT322;
    let batchTableJsonByteLength = view.getUint32(byteOffset, true);
    byteOffset += SIZEOF_UINT322;
    let batchTableBinaryByteLength = view.getUint32(byteOffset, true);
    byteOffset += SIZEOF_UINT322;
    if (batchTableJsonByteLength >= 570425344) {
      byteOffset -= SIZEOF_UINT322 * 2;
      batchLength = featureTableJsonByteLength;
      batchTableJsonByteLength = featureTableBinaryByteLength;
      batchTableBinaryByteLength = 0;
      featureTableJsonByteLength = 0;
      featureTableBinaryByteLength = 0;
      console.warn(DEPRECATION_WARNING);
    } else if (batchTableBinaryByteLength >= 570425344) {
      byteOffset -= SIZEOF_UINT322;
      batchLength = batchTableJsonByteLength;
      batchTableJsonByteLength = featureTableJsonByteLength;
      batchTableBinaryByteLength = featureTableBinaryByteLength;
      featureTableJsonByteLength = 0;
      featureTableBinaryByteLength = 0;
      console.warn(DEPRECATION_WARNING);
    }
    tile.header.featureTableJsonByteLength = featureTableJsonByteLength;
    tile.header.featureTableBinaryByteLength = featureTableBinaryByteLength;
    tile.header.batchTableJsonByteLength = batchTableJsonByteLength;
    tile.header.batchTableBinaryByteLength = batchTableBinaryByteLength;
    tile.header.batchLength = batchLength;
    return byteOffset;
  }
  function parse3DTileTablesSync(tile, arrayBuffer, byteOffset, options) {
    byteOffset = parse3DTileFeatureTable(tile, arrayBuffer, byteOffset, options);
    byteOffset = parse3DTileBatchTable(tile, arrayBuffer, byteOffset, options);
    return byteOffset;
  }
  function parse3DTileFeatureTable(tile, arrayBuffer, byteOffset, options) {
    const {
      featureTableJsonByteLength,
      featureTableBinaryByteLength,
      batchLength
    } = tile.header;
    tile.featureTableJson = {
      BATCH_LENGTH: batchLength || 0
    };
    if (featureTableJsonByteLength > 0) {
      const featureTableString = getStringFromArrayBuffer(arrayBuffer, byteOffset, featureTableJsonByteLength);
      tile.featureTableJson = JSON.parse(featureTableString);
    }
    byteOffset += featureTableJsonByteLength;
    tile.featureTableBinary = new Uint8Array(arrayBuffer, byteOffset, featureTableBinaryByteLength);
    byteOffset += featureTableBinaryByteLength;
    return byteOffset;
  }
  function parse3DTileBatchTable(tile, arrayBuffer, byteOffset, options) {
    const {
      batchTableJsonByteLength,
      batchTableBinaryByteLength
    } = tile.header;
    if (batchTableJsonByteLength > 0) {
      const batchTableString = getStringFromArrayBuffer(arrayBuffer, byteOffset, batchTableJsonByteLength);
      tile.batchTableJson = JSON.parse(batchTableString);
      byteOffset += batchTableJsonByteLength;
      if (batchTableBinaryByteLength > 0) {
        tile.batchTableBinary = new Uint8Array(arrayBuffer, byteOffset, batchTableBinaryByteLength);
        tile.batchTableBinary = new Uint8Array(tile.batchTableBinary);
        byteOffset += batchTableBinaryByteLength;
      }
    }
    return byteOffset;
  }

  // ../../node_modules/@loaders.gl/3d-tiles/dist/esm/lib/parsers/helpers/normalize-3d-tile-colors.js
  function normalize3DTileColorAttribute(tile, colors, batchTable) {
    if (!colors && (!tile || !tile.batchIds || !batchTable)) {
      return null;
    }
    const {
      batchIds,
      isRGB565,
      pointCount
    } = tile;
    if (batchIds && batchTable) {
      const colorArray = new Uint8ClampedArray(pointCount * 3);
      for (let i3 = 0; i3 < pointCount; i3++) {
        const batchId = batchIds[i3];
        const dimensions = batchTable.getProperty(batchId, "dimensions");
        const color = dimensions.map((d) => d * 255);
        colorArray[i3 * 3] = color[0];
        colorArray[i3 * 3 + 1] = color[1];
        colorArray[i3 * 3 + 2] = color[2];
      }
      return {
        type: GL2.UNSIGNED_BYTE,
        value: colorArray,
        size: 3,
        normalized: true
      };
    }
    if (isRGB565) {
      const colorArray = new Uint8ClampedArray(pointCount * 3);
      for (let i3 = 0; i3 < pointCount; i3++) {
        const color = decodeRGB565(colors[i3]);
        colorArray[i3 * 3] = color[0];
        colorArray[i3 * 3 + 1] = color[1];
        colorArray[i3 * 3 + 2] = color[2];
      }
      return {
        type: GL2.UNSIGNED_BYTE,
        value: colorArray,
        size: 3,
        normalized: true
      };
    }
    if (colors && colors.length === pointCount * 3) {
      return {
        type: GL2.UNSIGNED_BYTE,
        value: colors,
        size: 3,
        normalized: true
      };
    }
    return {
      type: GL2.UNSIGNED_BYTE,
      value: colors,
      size: 4,
      normalized: true
    };
  }

  // ../../node_modules/@loaders.gl/3d-tiles/dist/esm/lib/parsers/helpers/normalize-3d-tile-normals.js
  var scratchNormal4 = new Vector3();
  function normalize3DTileNormalAttribute(tile, normals) {
    if (!normals) {
      return null;
    }
    if (tile.isOctEncoded16P) {
      const decodedArray = new Float32Array(tile.pointsLength * 3);
      for (let i3 = 0; i3 < tile.pointsLength; i3++) {
        octDecode(normals[i3 * 2], normals[i3 * 2 + 1], scratchNormal4);
        scratchNormal4.toArray(decodedArray, i3 * 3);
      }
      return {
        type: GL2.FLOAT,
        size: 2,
        value: decodedArray
      };
    }
    return {
      type: GL2.FLOAT,
      size: 2,
      value: normals
    };
  }

  // ../../node_modules/@loaders.gl/3d-tiles/dist/esm/lib/parsers/helpers/normalize-3d-tile-positions.js
  function normalize3DTilePositionAttribute(tile, positions, options) {
    if (!tile.isQuantized) {
      return positions;
    }
    if (options["3d-tiles"] && options["3d-tiles"].decodeQuantizedPositions) {
      tile.isQuantized = false;
      return decodeQuantizedPositions(tile, positions);
    }
    return {
      type: GL2.UNSIGNED_SHORT,
      value: positions,
      size: 3,
      normalized: true
    };
  }
  function decodeQuantizedPositions(tile, positions) {
    const scratchPosition5 = new Vector3();
    const decodedArray = new Float32Array(tile.pointCount * 3);
    for (let i3 = 0; i3 < tile.pointCount; i3++) {
      scratchPosition5.set(positions[i3 * 3], positions[i3 * 3 + 1], positions[i3 * 3 + 2]).scale(1 / tile.quantizedRange).multiply(tile.quantizedVolumeScale).add(tile.quantizedVolumeOffset).toArray(decodedArray, i3 * 3);
    }
    return decodedArray;
  }

  // ../../node_modules/@loaders.gl/3d-tiles/dist/esm/lib/parsers/parse-3d-tile-point-cloud.js
  async function parsePointCloud3DTile(tile, arrayBuffer, byteOffset, options, context) {
    byteOffset = parse3DTileHeaderSync(tile, arrayBuffer, byteOffset);
    byteOffset = parse3DTileTablesHeaderSync(tile, arrayBuffer, byteOffset);
    byteOffset = parse3DTileTablesSync(tile, arrayBuffer, byteOffset, options);
    initializeTile(tile);
    const {
      featureTable,
      batchTable
    } = parsePointCloudTables(tile);
    await parseDraco(tile, featureTable, batchTable, options, context);
    parsePositions(tile, featureTable, options);
    parseColors(tile, featureTable, batchTable);
    parseNormals(tile, featureTable);
    return byteOffset;
  }
  function initializeTile(tile) {
    tile.attributes = {
      positions: null,
      colors: null,
      normals: null,
      batchIds: null
    };
    tile.isQuantized = false;
    tile.isTranslucent = false;
    tile.isRGB565 = false;
    tile.isOctEncoded16P = false;
  }
  function parsePointCloudTables(tile) {
    const featureTable = new Tile3DFeatureTable(tile.featureTableJson, tile.featureTableBinary);
    const pointsLength = featureTable.getGlobalProperty("POINTS_LENGTH");
    if (!Number.isFinite(pointsLength)) {
      throw new Error("POINTS_LENGTH must be defined");
    }
    featureTable.featuresLength = pointsLength;
    tile.featuresLength = pointsLength;
    tile.pointsLength = pointsLength;
    tile.pointCount = pointsLength;
    tile.rtcCenter = featureTable.getGlobalProperty("RTC_CENTER", GL2.FLOAT, 3);
    const batchTable = parseBatchIds(tile, featureTable);
    return {
      featureTable,
      batchTable
    };
  }
  function parsePositions(tile, featureTable, options) {
    if (!tile.attributes.positions) {
      if (featureTable.hasProperty("POSITION")) {
        tile.attributes.positions = featureTable.getPropertyArray("POSITION", GL2.FLOAT, 3);
      } else if (featureTable.hasProperty("POSITION_QUANTIZED")) {
        const positions = featureTable.getPropertyArray("POSITION_QUANTIZED", GL2.UNSIGNED_SHORT, 3);
        tile.isQuantized = true;
        tile.quantizedRange = (1 << 16) - 1;
        tile.quantizedVolumeScale = featureTable.getGlobalProperty("QUANTIZED_VOLUME_SCALE", GL2.FLOAT, 3);
        if (!tile.quantizedVolumeScale) {
          throw new Error("QUANTIZED_VOLUME_SCALE must be defined for quantized positions.");
        }
        tile.quantizedVolumeOffset = featureTable.getGlobalProperty("QUANTIZED_VOLUME_OFFSET", GL2.FLOAT, 3);
        if (!tile.quantizedVolumeOffset) {
          throw new Error("QUANTIZED_VOLUME_OFFSET must be defined for quantized positions.");
        }
        tile.attributes.positions = normalize3DTilePositionAttribute(tile, positions, options);
      }
    }
    if (!tile.attributes.positions) {
      throw new Error("Either POSITION or POSITION_QUANTIZED must be defined.");
    }
  }
  function parseColors(tile, featureTable, batchTable) {
    if (!tile.attributes.colors) {
      let colors = null;
      if (featureTable.hasProperty("RGBA")) {
        colors = featureTable.getPropertyArray("RGBA", GL2.UNSIGNED_BYTE, 4);
        tile.isTranslucent = true;
      } else if (featureTable.hasProperty("RGB")) {
        colors = featureTable.getPropertyArray("RGB", GL2.UNSIGNED_BYTE, 3);
      } else if (featureTable.hasProperty("RGB565")) {
        colors = featureTable.getPropertyArray("RGB565", GL2.UNSIGNED_SHORT, 1);
        tile.isRGB565 = true;
      }
      tile.attributes.colors = normalize3DTileColorAttribute(tile, colors, batchTable);
    }
    if (featureTable.hasProperty("CONSTANT_RGBA")) {
      tile.constantRGBA = featureTable.getGlobalProperty("CONSTANT_RGBA", GL2.UNSIGNED_BYTE, 4);
    }
  }
  function parseNormals(tile, featureTable) {
    if (!tile.attributes.normals) {
      let normals = null;
      if (featureTable.hasProperty("NORMAL")) {
        normals = featureTable.getPropertyArray("NORMAL", GL2.FLOAT, 3);
      } else if (featureTable.hasProperty("NORMAL_OCT16P")) {
        normals = featureTable.getPropertyArray("NORMAL_OCT16P", GL2.UNSIGNED_BYTE, 2);
        tile.isOctEncoded16P = true;
      }
      tile.attributes.normals = normalize3DTileNormalAttribute(tile, normals);
    }
  }
  function parseBatchIds(tile, featureTable) {
    let batchTable = null;
    if (!tile.batchIds && featureTable.hasProperty("BATCH_ID")) {
      tile.batchIds = featureTable.getPropertyArray("BATCH_ID", GL2.UNSIGNED_SHORT, 1);
      if (tile.batchIds) {
        const batchFeatureLength = featureTable.getGlobalProperty("BATCH_LENGTH");
        if (!batchFeatureLength) {
          throw new Error("Global property: BATCH_LENGTH must be defined when BATCH_ID is defined.");
        }
        const {
          batchTableJson,
          batchTableBinary
        } = tile;
        batchTable = new Tile3DBatchTableParser(batchTableJson, batchTableBinary, batchFeatureLength);
      }
    }
    return batchTable;
  }
  async function parseDraco(tile, featureTable, batchTable, options, context) {
    let dracoBuffer;
    let dracoFeatureTableProperties;
    let dracoBatchTableProperties;
    const batchTableDraco = tile.batchTableJson && tile.batchTableJson.extensions && tile.batchTableJson.extensions["3DTILES_draco_point_compression"];
    if (batchTableDraco) {
      dracoBatchTableProperties = batchTableDraco.properties;
    }
    const featureTableDraco = featureTable.getExtension("3DTILES_draco_point_compression");
    if (featureTableDraco) {
      dracoFeatureTableProperties = featureTableDraco.properties;
      const dracoByteOffset = featureTableDraco.byteOffset;
      const dracoByteLength = featureTableDraco.byteLength;
      if (!dracoFeatureTableProperties || !Number.isFinite(dracoByteOffset) || !dracoByteLength) {
        throw new Error("Draco properties, byteOffset, and byteLength must be defined");
      }
      dracoBuffer = tile.featureTableBinary.slice(dracoByteOffset, dracoByteOffset + dracoByteLength);
      tile.hasPositions = Number.isFinite(dracoFeatureTableProperties.POSITION);
      tile.hasColors = Number.isFinite(dracoFeatureTableProperties.RGB) || Number.isFinite(dracoFeatureTableProperties.RGBA);
      tile.hasNormals = Number.isFinite(dracoFeatureTableProperties.NORMAL);
      tile.hasBatchIds = Number.isFinite(dracoFeatureTableProperties.BATCH_ID);
      tile.isTranslucent = Number.isFinite(dracoFeatureTableProperties.RGBA);
    }
    if (!dracoBuffer) {
      return true;
    }
    const dracoData = {
      buffer: dracoBuffer,
      properties: {
        ...dracoFeatureTableProperties,
        ...dracoBatchTableProperties
      },
      featureTableProperties: dracoFeatureTableProperties,
      batchTableProperties: dracoBatchTableProperties,
      dequantizeInShader: false
    };
    return await loadDraco(tile, dracoData, options, context);
  }
  async function loadDraco(tile, dracoData, options, context) {
    const {
      parse: parse4
    } = context;
    const dracoOptions = {
      ...options,
      draco: {
        ...options.draco,
        extraAttributes: dracoData.batchTableProperties || {}
      }
    };
    delete dracoOptions["3d-tiles"];
    const data = await parse4(dracoData.buffer, DracoLoader2, dracoOptions);
    const decodedPositions = data.attributes.POSITION && data.attributes.POSITION.value;
    const decodedColors = data.attributes.COLOR_0 && data.attributes.COLOR_0.value;
    const decodedNormals = data.attributes.NORMAL && data.attributes.NORMAL.value;
    const decodedBatchIds = data.attributes.BATCH_ID && data.attributes.BATCH_ID.value;
    const isQuantizedDraco = decodedPositions && data.attributes.POSITION.value.quantization;
    const isOctEncodedDraco = decodedNormals && data.attributes.NORMAL.value.quantization;
    if (isQuantizedDraco) {
      const quantization = data.POSITION.data.quantization;
      const range = quantization.range;
      tile.quantizedVolumeScale = new Vector3(range, range, range);
      tile.quantizedVolumeOffset = new Vector3(quantization.minValues);
      tile.quantizedRange = (1 << quantization.quantizationBits) - 1;
      tile.isQuantizedDraco = true;
    }
    if (isOctEncodedDraco) {
      tile.octEncodedRange = (1 << data.NORMAL.data.quantization.quantizationBits) - 1;
      tile.isOctEncodedDraco = true;
    }
    const batchTableAttributes = {};
    if (dracoData.batchTableProperties) {
      for (const attributeName of Object.keys(dracoData.batchTableProperties)) {
        if (data.attributes[attributeName] && data.attributes[attributeName].value) {
          batchTableAttributes[attributeName.toLowerCase()] = data.attributes[attributeName].value;
        }
      }
    }
    tile.attributes = {
      positions: decodedPositions,
      colors: normalize3DTileColorAttribute(tile, decodedColors, void 0),
      normals: decodedNormals,
      batchIds: decodedBatchIds,
      ...batchTableAttributes
    };
  }

  // ../../node_modules/@loaders.gl/gltf/dist/esm/lib/utils/version.js
  var VERSION10 = true ? "3.3.1" : "latest";

  // ../../node_modules/@loaders.gl/textures/dist/esm/lib/utils/version.js
  var VERSION11 = true ? "3.3.1" : "beta";

  // ../../node_modules/@loaders.gl/textures/dist/esm/lib/parsers/basis-module-loader.js
  var VERSION12 = true ? "3.3.1" : "beta";
  var BASIS_CDN_ENCODER_WASM = "https://unpkg.com/@loaders.gl/textures@".concat(VERSION12, "/dist/libs/basis_encoder.wasm");
  var BASIS_CDN_ENCODER_JS = "https://unpkg.com/@loaders.gl/textures@".concat(VERSION12, "/dist/libs/basis_encoder.js");
  var loadBasisTranscoderPromise;
  async function loadBasisTrascoderModule(options) {
    const modules = options.modules || {};
    if (modules.basis) {
      return modules.basis;
    }
    loadBasisTranscoderPromise = loadBasisTranscoderPromise || loadBasisTrascoder(options);
    return await loadBasisTranscoderPromise;
  }
  async function loadBasisTrascoder(options) {
    let BASIS = null;
    let wasmBinary = null;
    [BASIS, wasmBinary] = await Promise.all([await loadLibrary("basis_transcoder.js", "textures", options), await loadLibrary("basis_transcoder.wasm", "textures", options)]);
    BASIS = BASIS || globalThis.BASIS;
    return await initializeBasisTrascoderModule(BASIS, wasmBinary);
  }
  function initializeBasisTrascoderModule(BasisModule, wasmBinary) {
    const options = {};
    if (wasmBinary) {
      options.wasmBinary = wasmBinary;
    }
    return new Promise((resolve) => {
      BasisModule(options).then((module2) => {
        const {
          BasisFile,
          initializeBasis
        } = module2;
        initializeBasis();
        resolve({
          BasisFile
        });
      });
    });
  }
  var loadBasisEncoderPromise;
  async function loadBasisEncoderModule(options) {
    const modules = options.modules || {};
    if (modules.basisEncoder) {
      return modules.basisEncoder;
    }
    loadBasisEncoderPromise = loadBasisEncoderPromise || loadBasisEncoder(options);
    return await loadBasisEncoderPromise;
  }
  async function loadBasisEncoder(options) {
    let BASIS_ENCODER = null;
    let wasmBinary = null;
    [BASIS_ENCODER, wasmBinary] = await Promise.all([await loadLibrary(BASIS_CDN_ENCODER_JS, "textures", options), await loadLibrary(BASIS_CDN_ENCODER_WASM, "textures", options)]);
    BASIS_ENCODER = BASIS_ENCODER || globalThis.BASIS;
    return await initializeBasisEncoderModule(BASIS_ENCODER, wasmBinary);
  }
  function initializeBasisEncoderModule(BasisEncoderModule, wasmBinary) {
    const options = {};
    if (wasmBinary) {
      options.wasmBinary = wasmBinary;
    }
    return new Promise((resolve) => {
      BasisEncoderModule(options).then((module2) => {
        const {
          BasisFile,
          KTX2File,
          initializeBasis,
          BasisEncoder
        } = module2;
        initializeBasis();
        resolve({
          BasisFile,
          KTX2File,
          BasisEncoder
        });
      });
    });
  }

  // ../../node_modules/@loaders.gl/textures/dist/esm/lib/gl-extensions.js
  var GL_EXTENSIONS_CONSTANTS = {
    COMPRESSED_RGB_S3TC_DXT1_EXT: 33776,
    COMPRESSED_RGBA_S3TC_DXT1_EXT: 33777,
    COMPRESSED_RGBA_S3TC_DXT3_EXT: 33778,
    COMPRESSED_RGBA_S3TC_DXT5_EXT: 33779,
    COMPRESSED_R11_EAC: 37488,
    COMPRESSED_SIGNED_R11_EAC: 37489,
    COMPRESSED_RG11_EAC: 37490,
    COMPRESSED_SIGNED_RG11_EAC: 37491,
    COMPRESSED_RGB8_ETC2: 37492,
    COMPRESSED_RGBA8_ETC2_EAC: 37493,
    COMPRESSED_SRGB8_ETC2: 37494,
    COMPRESSED_SRGB8_ALPHA8_ETC2_EAC: 37495,
    COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2: 37496,
    COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2: 37497,
    COMPRESSED_RGB_PVRTC_4BPPV1_IMG: 35840,
    COMPRESSED_RGBA_PVRTC_4BPPV1_IMG: 35842,
    COMPRESSED_RGB_PVRTC_2BPPV1_IMG: 35841,
    COMPRESSED_RGBA_PVRTC_2BPPV1_IMG: 35843,
    COMPRESSED_RGB_ETC1_WEBGL: 36196,
    COMPRESSED_RGB_ATC_WEBGL: 35986,
    COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL: 35987,
    COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL: 34798,
    COMPRESSED_RGBA_ASTC_4X4_KHR: 37808,
    COMPRESSED_RGBA_ASTC_5X4_KHR: 37809,
    COMPRESSED_RGBA_ASTC_5X5_KHR: 37810,
    COMPRESSED_RGBA_ASTC_6X5_KHR: 37811,
    COMPRESSED_RGBA_ASTC_6X6_KHR: 37812,
    COMPRESSED_RGBA_ASTC_8X5_KHR: 37813,
    COMPRESSED_RGBA_ASTC_8X6_KHR: 37814,
    COMPRESSED_RGBA_ASTC_8X8_KHR: 37815,
    COMPRESSED_RGBA_ASTC_10X5_KHR: 37816,
    COMPRESSED_RGBA_ASTC_10X6_KHR: 37817,
    COMPRESSED_RGBA_ASTC_10X8_KHR: 37818,
    COMPRESSED_RGBA_ASTC_10X10_KHR: 37819,
    COMPRESSED_RGBA_ASTC_12X10_KHR: 37820,
    COMPRESSED_RGBA_ASTC_12X12_KHR: 37821,
    COMPRESSED_SRGB8_ALPHA8_ASTC_4X4_KHR: 37840,
    COMPRESSED_SRGB8_ALPHA8_ASTC_5X4_KHR: 37841,
    COMPRESSED_SRGB8_ALPHA8_ASTC_5X5_KHR: 37842,
    COMPRESSED_SRGB8_ALPHA8_ASTC_6X5_KHR: 37843,
    COMPRESSED_SRGB8_ALPHA8_ASTC_6X6_KHR: 37844,
    COMPRESSED_SRGB8_ALPHA8_ASTC_8X5_KHR: 37845,
    COMPRESSED_SRGB8_ALPHA8_ASTC_8X6_KHR: 37846,
    COMPRESSED_SRGB8_ALPHA8_ASTC_8X8_KHR: 37847,
    COMPRESSED_SRGB8_ALPHA8_ASTC_10X5_KHR: 37848,
    COMPRESSED_SRGB8_ALPHA8_ASTC_10X6_KHR: 37849,
    COMPRESSED_SRGB8_ALPHA8_ASTC_10X8_KHR: 37850,
    COMPRESSED_SRGB8_ALPHA8_ASTC_10X10_KHR: 37851,
    COMPRESSED_SRGB8_ALPHA8_ASTC_12X10_KHR: 37852,
    COMPRESSED_SRGB8_ALPHA8_ASTC_12X12_KHR: 37853,
    COMPRESSED_RED_RGTC1_EXT: 36283,
    COMPRESSED_SIGNED_RED_RGTC1_EXT: 36284,
    COMPRESSED_RED_GREEN_RGTC2_EXT: 36285,
    COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT: 36286,
    COMPRESSED_SRGB_S3TC_DXT1_EXT: 35916,
    COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT: 35917,
    COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT: 35918,
    COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT: 35919
  };

  // ../../node_modules/@loaders.gl/textures/dist/esm/lib/utils/texture-formats.js
  var BROWSER_PREFIXES = ["", "WEBKIT_", "MOZ_"];
  var WEBGL_EXTENSIONS = {
    WEBGL_compressed_texture_s3tc: "dxt",
    WEBGL_compressed_texture_s3tc_srgb: "dxt-srgb",
    WEBGL_compressed_texture_etc1: "etc1",
    WEBGL_compressed_texture_etc: "etc2",
    WEBGL_compressed_texture_pvrtc: "pvrtc",
    WEBGL_compressed_texture_atc: "atc",
    WEBGL_compressed_texture_astc: "astc",
    EXT_texture_compression_rgtc: "rgtc"
  };
  var formats = null;
  function getSupportedGPUTextureFormats(gl) {
    if (!formats) {
      gl = gl || getWebGLContext() || void 0;
      formats = /* @__PURE__ */ new Set();
      for (const prefix of BROWSER_PREFIXES) {
        for (const extension in WEBGL_EXTENSIONS) {
          if (gl && gl.getExtension("".concat(prefix).concat(extension))) {
            const gpuTextureFormat = WEBGL_EXTENSIONS[extension];
            formats.add(gpuTextureFormat);
          }
        }
      }
    }
    return formats;
  }
  function getWebGLContext() {
    try {
      const canvas = document.createElement("canvas");
      return canvas.getContext("webgl");
    } catch (error2) {
      return null;
    }
  }

  // ../../node_modules/ktx-parse/dist/ktx-parse.modern.js
  var t = new Uint8Array([0]);
  var n;
  var i;
  var s;
  var a;
  var r;
  var o;
  var l;
  var f;
  !function(t2) {
    t2[t2.NONE = 0] = "NONE", t2[t2.BASISLZ = 1] = "BASISLZ", t2[t2.ZSTD = 2] = "ZSTD", t2[t2.ZLIB = 3] = "ZLIB";
  }(n || (n = {})), function(t2) {
    t2[t2.BASICFORMAT = 0] = "BASICFORMAT";
  }(i || (i = {})), function(t2) {
    t2[t2.UNSPECIFIED = 0] = "UNSPECIFIED", t2[t2.ETC1S = 163] = "ETC1S", t2[t2.UASTC = 166] = "UASTC";
  }(s || (s = {})), function(t2) {
    t2[t2.UNSPECIFIED = 0] = "UNSPECIFIED", t2[t2.SRGB = 1] = "SRGB";
  }(a || (a = {})), function(t2) {
    t2[t2.UNSPECIFIED = 0] = "UNSPECIFIED", t2[t2.LINEAR = 1] = "LINEAR", t2[t2.SRGB = 2] = "SRGB", t2[t2.ITU = 3] = "ITU", t2[t2.NTSC = 4] = "NTSC", t2[t2.SLOG = 5] = "SLOG", t2[t2.SLOG2 = 6] = "SLOG2";
  }(r || (r = {})), function(t2) {
    t2[t2.ALPHA_STRAIGHT = 0] = "ALPHA_STRAIGHT", t2[t2.ALPHA_PREMULTIPLIED = 1] = "ALPHA_PREMULTIPLIED";
  }(o || (o = {})), function(t2) {
    t2[t2.RGB = 0] = "RGB", t2[t2.RRR = 3] = "RRR", t2[t2.GGG = 4] = "GGG", t2[t2.AAA = 15] = "AAA";
  }(l || (l = {})), function(t2) {
    t2[t2.RGB = 0] = "RGB", t2[t2.RGBA = 3] = "RGBA", t2[t2.RRR = 4] = "RRR", t2[t2.RRRG = 5] = "RRRG";
  }(f || (f = {}));

  // ../../node_modules/@loaders.gl/textures/dist/esm/lib/parsers/parse-ktx.js
  var KTX2_ID = [
    171,
    75,
    84,
    88,
    32,
    50,
    48,
    187,
    13,
    10,
    26,
    10
  ];
  function isKTX(data) {
    const id = new Uint8Array(data);
    const notKTX = id.byteLength < KTX2_ID.length || id[0] !== KTX2_ID[0] || id[1] !== KTX2_ID[1] || id[2] !== KTX2_ID[2] || id[3] !== KTX2_ID[3] || id[4] !== KTX2_ID[4] || id[5] !== KTX2_ID[5] || id[6] !== KTX2_ID[6] || id[7] !== KTX2_ID[7] || id[8] !== KTX2_ID[8] || id[9] !== KTX2_ID[9] || id[10] !== KTX2_ID[10] || id[11] !== KTX2_ID[11];
    return !notKTX;
  }

  // ../../node_modules/@loaders.gl/textures/dist/esm/lib/parsers/parse-basis.js
  var OutputFormat = {
    etc1: {
      basisFormat: 0,
      compressed: true,
      format: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_ETC1_WEBGL
    },
    etc2: {
      basisFormat: 1,
      compressed: true
    },
    bc1: {
      basisFormat: 2,
      compressed: true,
      format: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_S3TC_DXT1_EXT
    },
    bc3: {
      basisFormat: 3,
      compressed: true,
      format: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_S3TC_DXT5_EXT
    },
    bc4: {
      basisFormat: 4,
      compressed: true
    },
    bc5: {
      basisFormat: 5,
      compressed: true
    },
    "bc7-m6-opaque-only": {
      basisFormat: 6,
      compressed: true
    },
    "bc7-m5": {
      basisFormat: 7,
      compressed: true
    },
    "pvrtc1-4-rgb": {
      basisFormat: 8,
      compressed: true,
      format: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_PVRTC_4BPPV1_IMG
    },
    "pvrtc1-4-rgba": {
      basisFormat: 9,
      compressed: true,
      format: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG
    },
    "astc-4x4": {
      basisFormat: 10,
      compressed: true,
      format: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_4X4_KHR
    },
    "atc-rgb": {
      basisFormat: 11,
      compressed: true
    },
    "atc-rgba-interpolated-alpha": {
      basisFormat: 12,
      compressed: true
    },
    rgba32: {
      basisFormat: 13,
      compressed: false
    },
    rgb565: {
      basisFormat: 14,
      compressed: false
    },
    bgr565: {
      basisFormat: 15,
      compressed: false
    },
    rgba4444: {
      basisFormat: 16,
      compressed: false
    }
  };
  async function parseBasis(data, options) {
    if (options.basis.containerFormat === "auto") {
      if (isKTX(data)) {
        const fileConstructors = await loadBasisEncoderModule(options);
        return parseKTX2File(fileConstructors.KTX2File, data, options);
      }
      const {
        BasisFile
      } = await loadBasisTrascoderModule(options);
      return parseBasisFile(BasisFile, data, options);
    }
    switch (options.basis.module) {
      case "encoder":
        const fileConstructors = await loadBasisEncoderModule(options);
        switch (options.basis.containerFormat) {
          case "ktx2":
            return parseKTX2File(fileConstructors.KTX2File, data, options);
          case "basis":
          default:
            return parseBasisFile(fileConstructors.BasisFile, data, options);
        }
      case "transcoder":
      default:
        const {
          BasisFile
        } = await loadBasisTrascoderModule(options);
        return parseBasisFile(BasisFile, data, options);
    }
  }
  function parseBasisFile(BasisFile, data, options) {
    const basisFile = new BasisFile(new Uint8Array(data));
    try {
      if (!basisFile.startTranscoding()) {
        throw new Error("Failed to start basis transcoding");
      }
      const imageCount = basisFile.getNumImages();
      const images = [];
      for (let imageIndex = 0; imageIndex < imageCount; imageIndex++) {
        const levelsCount = basisFile.getNumLevels(imageIndex);
        const levels = [];
        for (let levelIndex = 0; levelIndex < levelsCount; levelIndex++) {
          levels.push(transcodeImage(basisFile, imageIndex, levelIndex, options));
        }
        images.push(levels);
      }
      return images;
    } finally {
      basisFile.close();
      basisFile.delete();
    }
  }
  function transcodeImage(basisFile, imageIndex, levelIndex, options) {
    const width = basisFile.getImageWidth(imageIndex, levelIndex);
    const height = basisFile.getImageHeight(imageIndex, levelIndex);
    const hasAlpha = basisFile.getHasAlpha();
    const {
      compressed,
      format,
      basisFormat
    } = getBasisOptions(options, hasAlpha);
    const decodedSize = basisFile.getImageTranscodedSizeInBytes(imageIndex, levelIndex, basisFormat);
    const decodedData = new Uint8Array(decodedSize);
    if (!basisFile.transcodeImage(decodedData, imageIndex, levelIndex, basisFormat, 0, 0)) {
      throw new Error("failed to start Basis transcoding");
    }
    return {
      width,
      height,
      data: decodedData,
      compressed,
      format,
      hasAlpha
    };
  }
  function parseKTX2File(KTX2File, data, options) {
    const ktx2File = new KTX2File(new Uint8Array(data));
    try {
      if (!ktx2File.startTranscoding()) {
        throw new Error("failed to start KTX2 transcoding");
      }
      const levelsCount = ktx2File.getLevels();
      const levels = [];
      for (let levelIndex = 0; levelIndex < levelsCount; levelIndex++) {
        levels.push(transcodeKTX2Image(ktx2File, levelIndex, options));
        break;
      }
      return [levels];
    } finally {
      ktx2File.close();
      ktx2File.delete();
    }
  }
  function transcodeKTX2Image(ktx2File, levelIndex, options) {
    const {
      alphaFlag,
      height,
      width
    } = ktx2File.getImageLevelInfo(levelIndex, 0, 0);
    const {
      compressed,
      format,
      basisFormat
    } = getBasisOptions(options, alphaFlag);
    const decodedSize = ktx2File.getImageTranscodedSizeInBytes(levelIndex, 0, 0, basisFormat);
    const decodedData = new Uint8Array(decodedSize);
    if (!ktx2File.transcodeImage(decodedData, levelIndex, 0, 0, basisFormat, 0, -1, -1)) {
      throw new Error("Failed to transcode KTX2 image");
    }
    return {
      width,
      height,
      data: decodedData,
      compressed,
      levelSize: decodedSize,
      hasAlpha: alphaFlag,
      format
    };
  }
  function getBasisOptions(options, hasAlpha) {
    let format = options && options.basis && options.basis.format;
    if (format === "auto") {
      format = selectSupportedBasisFormat();
    }
    if (typeof format === "object") {
      format = hasAlpha ? format.alpha : format.noAlpha;
    }
    format = format.toLowerCase();
    return OutputFormat[format];
  }
  function selectSupportedBasisFormat() {
    const supportedFormats = getSupportedGPUTextureFormats();
    if (supportedFormats.has("astc")) {
      return "astc-4x4";
    } else if (supportedFormats.has("dxt")) {
      return {
        alpha: "bc3",
        noAlpha: "bc1"
      };
    } else if (supportedFormats.has("pvrtc")) {
      return {
        alpha: "pvrtc1-4-rgba",
        noAlpha: "pvrtc1-4-rgb"
      };
    } else if (supportedFormats.has("etc1")) {
      return "etc1";
    } else if (supportedFormats.has("etc2")) {
      return "etc2";
    }
    return "rgb565";
  }

  // ../../node_modules/@loaders.gl/textures/dist/esm/basis-loader.js
  var BasisWorkerLoader = {
    name: "Basis",
    id: isBrowser2 ? "basis" : "basis-nodejs",
    module: "textures",
    version: VERSION11,
    worker: true,
    extensions: ["basis", "ktx2"],
    mimeTypes: ["application/octet-stream", "image/ktx2"],
    tests: ["sB"],
    binary: true,
    options: {
      basis: {
        format: "auto",
        libraryPath: "libs/",
        containerFormat: "auto",
        module: "transcoder"
      }
    }
  };
  var BasisLoader = {
    ...BasisWorkerLoader,
    parse: parseBasis
  };

  // ../../node_modules/@loaders.gl/gltf/dist/esm/lib/utils/assert.js
  function assert11(condition, message) {
    if (!condition) {
      throw new Error(message || "assert failed: gltf");
    }
  }

  // ../../node_modules/@loaders.gl/gltf/dist/esm/lib/gltf-utils/resolve-url.js
  function resolveUrl(url, options) {
    const absolute = url.startsWith("data:") || url.startsWith("http:") || url.startsWith("https:");
    if (absolute) {
      return url;
    }
    const baseUrl = options.baseUri || options.uri;
    if (!baseUrl) {
      throw new Error("'baseUri' must be provided to resolve relative url ".concat(url));
    }
    return baseUrl.substr(0, baseUrl.lastIndexOf("/") + 1) + url;
  }

  // ../../node_modules/@loaders.gl/gltf/dist/esm/lib/gltf-utils/get-typed-array.js
  function getTypedArrayForBufferView(json, buffers, bufferViewIndex) {
    const bufferView = json.bufferViews[bufferViewIndex];
    assert11(bufferView);
    const bufferIndex = bufferView.buffer;
    const binChunk = buffers[bufferIndex];
    assert11(binChunk);
    const byteOffset = (bufferView.byteOffset || 0) + binChunk.byteOffset;
    return new Uint8Array(binChunk.arrayBuffer, byteOffset, bufferView.byteLength);
  }

  // ../../node_modules/@loaders.gl/gltf/dist/esm/lib/extensions/EXT_meshopt_compression.js
  var EXT_meshopt_compression_exports = {};
  __export(EXT_meshopt_compression_exports, {
    decode: () => decode2,
    name: () => name
  });

  // ../../node_modules/@loaders.gl/gltf/dist/esm/lib/gltf-utils/gltf-utils.js
  var TYPES = ["SCALAR", "VEC2", "VEC3", "VEC4"];
  var ARRAY_CONSTRUCTOR_TO_WEBGL_CONSTANT = [[Int8Array, 5120], [Uint8Array, 5121], [Int16Array, 5122], [Uint16Array, 5123], [Uint32Array, 5125], [Float32Array, 5126], [Float64Array, 5130]];
  var ARRAY_TO_COMPONENT_TYPE = new Map(ARRAY_CONSTRUCTOR_TO_WEBGL_CONSTANT);
  var ATTRIBUTE_TYPE_TO_COMPONENTS = {
    SCALAR: 1,
    VEC2: 2,
    VEC3: 3,
    VEC4: 4,
    MAT2: 4,
    MAT3: 9,
    MAT4: 16
  };
  var ATTRIBUTE_COMPONENT_TYPE_TO_BYTE_SIZE = {
    5120: 1,
    5121: 1,
    5122: 2,
    5123: 2,
    5125: 4,
    5126: 4
  };
  var ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY = {
    5120: Int8Array,
    5121: Uint8Array,
    5122: Int16Array,
    5123: Uint16Array,
    5125: Uint32Array,
    5126: Float32Array
  };
  function getAccessorTypeFromSize(size) {
    const type = TYPES[size - 1];
    return type || TYPES[0];
  }
  function getComponentTypeFromArray(typedArray) {
    const componentType = ARRAY_TO_COMPONENT_TYPE.get(typedArray.constructor);
    if (!componentType) {
      throw new Error("Illegal typed array");
    }
    return componentType;
  }
  function getAccessorArrayTypeAndLength(accessor, bufferView) {
    const ArrayType = ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY[accessor.componentType];
    const components = ATTRIBUTE_TYPE_TO_COMPONENTS[accessor.type];
    const bytesPerComponent = ATTRIBUTE_COMPONENT_TYPE_TO_BYTE_SIZE[accessor.componentType];
    const length5 = accessor.count * components;
    const byteLength = accessor.count * components * bytesPerComponent;
    assert11(byteLength >= 0 && byteLength <= bufferView.byteLength);
    return {
      ArrayType,
      length: length5,
      byteLength
    };
  }

  // ../../node_modules/@loaders.gl/gltf/dist/esm/lib/api/gltf-scenegraph.js
  var DEFAULT_GLTF_JSON = {
    asset: {
      version: "2.0",
      generator: "loaders.gl"
    },
    buffers: []
  };
  var GLTFScenegraph = class {
    constructor(gltf) {
      _defineProperty(this, "gltf", void 0);
      _defineProperty(this, "sourceBuffers", void 0);
      _defineProperty(this, "byteLength", void 0);
      this.gltf = gltf || {
        json: {
          ...DEFAULT_GLTF_JSON
        },
        buffers: []
      };
      this.sourceBuffers = [];
      this.byteLength = 0;
      if (this.gltf.buffers && this.gltf.buffers[0]) {
        this.byteLength = this.gltf.buffers[0].byteLength;
        this.sourceBuffers = [this.gltf.buffers[0]];
      }
    }
    get json() {
      return this.gltf.json;
    }
    getApplicationData(key) {
      const data = this.json[key];
      return data;
    }
    getExtraData(key) {
      const extras = this.json.extras || {};
      return extras[key];
    }
    getExtension(extensionName) {
      const isExtension = this.getUsedExtensions().find((name10) => name10 === extensionName);
      const extensions = this.json.extensions || {};
      return isExtension ? extensions[extensionName] || true : null;
    }
    getRequiredExtension(extensionName) {
      const isRequired = this.getRequiredExtensions().find((name10) => name10 === extensionName);
      return isRequired ? this.getExtension(extensionName) : null;
    }
    getRequiredExtensions() {
      return this.json.extensionsRequired || [];
    }
    getUsedExtensions() {
      return this.json.extensionsUsed || [];
    }
    getRemovedExtensions() {
      return this.json.extensionsRemoved || [];
    }
    getObjectExtension(object, extensionName) {
      const extensions = object.extensions || {};
      return extensions[extensionName];
    }
    getScene(index) {
      return this.getObject("scenes", index);
    }
    getNode(index) {
      return this.getObject("nodes", index);
    }
    getSkin(index) {
      return this.getObject("skins", index);
    }
    getMesh(index) {
      return this.getObject("meshes", index);
    }
    getMaterial(index) {
      return this.getObject("materials", index);
    }
    getAccessor(index) {
      return this.getObject("accessors", index);
    }
    getTexture(index) {
      return this.getObject("textures", index);
    }
    getSampler(index) {
      return this.getObject("samplers", index);
    }
    getImage(index) {
      return this.getObject("images", index);
    }
    getBufferView(index) {
      return this.getObject("bufferViews", index);
    }
    getBuffer(index) {
      return this.getObject("buffers", index);
    }
    getObject(array, index) {
      if (typeof index === "object") {
        return index;
      }
      const object = this.json[array] && this.json[array][index];
      if (!object) {
        throw new Error("glTF file error: Could not find ".concat(array, "[").concat(index, "]"));
      }
      return object;
    }
    getTypedArrayForBufferView(bufferView) {
      bufferView = this.getBufferView(bufferView);
      const bufferIndex = bufferView.buffer;
      const binChunk = this.gltf.buffers[bufferIndex];
      assert11(binChunk);
      const byteOffset = (bufferView.byteOffset || 0) + binChunk.byteOffset;
      return new Uint8Array(binChunk.arrayBuffer, byteOffset, bufferView.byteLength);
    }
    getTypedArrayForAccessor(accessor) {
      accessor = this.getAccessor(accessor);
      const bufferView = this.getBufferView(accessor.bufferView);
      const buffer = this.getBuffer(bufferView.buffer);
      const arrayBuffer = buffer.data;
      const {
        ArrayType,
        length: length5
      } = getAccessorArrayTypeAndLength(accessor, bufferView);
      const byteOffset = bufferView.byteOffset + accessor.byteOffset;
      return new ArrayType(arrayBuffer, byteOffset, length5);
    }
    getTypedArrayForImageData(image) {
      image = this.getAccessor(image);
      const bufferView = this.getBufferView(image.bufferView);
      const buffer = this.getBuffer(bufferView.buffer);
      const arrayBuffer = buffer.data;
      const byteOffset = bufferView.byteOffset || 0;
      return new Uint8Array(arrayBuffer, byteOffset, bufferView.byteLength);
    }
    addApplicationData(key, data) {
      this.json[key] = data;
      return this;
    }
    addExtraData(key, data) {
      this.json.extras = this.json.extras || {};
      this.json.extras[key] = data;
      return this;
    }
    addObjectExtension(object, extensionName, data) {
      object.extensions = object.extensions || {};
      object.extensions[extensionName] = data;
      this.registerUsedExtension(extensionName);
      return this;
    }
    setObjectExtension(object, extensionName, data) {
      const extensions = object.extensions || {};
      extensions[extensionName] = data;
    }
    removeObjectExtension(object, extensionName) {
      const extensions = object.extensions || {};
      const extension = extensions[extensionName];
      delete extensions[extensionName];
      return extension;
    }
    addExtension(extensionName) {
      let extensionData = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      assert11(extensionData);
      this.json.extensions = this.json.extensions || {};
      this.json.extensions[extensionName] = extensionData;
      this.registerUsedExtension(extensionName);
      return extensionData;
    }
    addRequiredExtension(extensionName) {
      let extensionData = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      assert11(extensionData);
      this.addExtension(extensionName, extensionData);
      this.registerRequiredExtension(extensionName);
      return extensionData;
    }
    registerUsedExtension(extensionName) {
      this.json.extensionsUsed = this.json.extensionsUsed || [];
      if (!this.json.extensionsUsed.find((ext) => ext === extensionName)) {
        this.json.extensionsUsed.push(extensionName);
      }
    }
    registerRequiredExtension(extensionName) {
      this.registerUsedExtension(extensionName);
      this.json.extensionsRequired = this.json.extensionsRequired || [];
      if (!this.json.extensionsRequired.find((ext) => ext === extensionName)) {
        this.json.extensionsRequired.push(extensionName);
      }
    }
    removeExtension(extensionName) {
      if (!this.getExtension(extensionName)) {
        return;
      }
      if (this.json.extensionsRequired) {
        this._removeStringFromArray(this.json.extensionsRequired, extensionName);
      }
      if (this.json.extensionsUsed) {
        this._removeStringFromArray(this.json.extensionsUsed, extensionName);
      }
      if (this.json.extensions) {
        delete this.json.extensions[extensionName];
      }
      if (!Array.isArray(this.json.extensionsRemoved)) {
        this.json.extensionsRemoved = [];
      }
      const extensionsRemoved = this.json.extensionsRemoved;
      if (!extensionsRemoved.includes(extensionName)) {
        extensionsRemoved.push(extensionName);
      }
    }
    setDefaultScene(sceneIndex) {
      this.json.scene = sceneIndex;
    }
    addScene(scene) {
      const {
        nodeIndices
      } = scene;
      this.json.scenes = this.json.scenes || [];
      this.json.scenes.push({
        nodes: nodeIndices
      });
      return this.json.scenes.length - 1;
    }
    addNode(node2) {
      const {
        meshIndex,
        matrix
      } = node2;
      this.json.nodes = this.json.nodes || [];
      const nodeData = {
        mesh: meshIndex
      };
      if (matrix) {
        nodeData.matrix = matrix;
      }
      this.json.nodes.push(nodeData);
      return this.json.nodes.length - 1;
    }
    addMesh(mesh) {
      const {
        attributes,
        indices,
        material,
        mode = 4
      } = mesh;
      const accessors = this._addAttributes(attributes);
      const glTFMesh = {
        primitives: [{
          attributes: accessors,
          mode
        }]
      };
      if (indices) {
        const indicesAccessor = this._addIndices(indices);
        glTFMesh.primitives[0].indices = indicesAccessor;
      }
      if (Number.isFinite(material)) {
        glTFMesh.primitives[0].material = material;
      }
      this.json.meshes = this.json.meshes || [];
      this.json.meshes.push(glTFMesh);
      return this.json.meshes.length - 1;
    }
    addPointCloud(attributes) {
      const accessorIndices = this._addAttributes(attributes);
      const glTFMesh = {
        primitives: [{
          attributes: accessorIndices,
          mode: 0
        }]
      };
      this.json.meshes = this.json.meshes || [];
      this.json.meshes.push(glTFMesh);
      return this.json.meshes.length - 1;
    }
    addImage(imageData, mimeTypeOpt) {
      const metadata = getBinaryImageMetadata(imageData);
      const mimeType = mimeTypeOpt || (metadata === null || metadata === void 0 ? void 0 : metadata.mimeType);
      const bufferViewIndex = this.addBufferView(imageData);
      const glTFImage = {
        bufferView: bufferViewIndex,
        mimeType
      };
      this.json.images = this.json.images || [];
      this.json.images.push(glTFImage);
      return this.json.images.length - 1;
    }
    addBufferView(buffer) {
      const byteLength = buffer.byteLength;
      assert11(Number.isFinite(byteLength));
      this.sourceBuffers = this.sourceBuffers || [];
      this.sourceBuffers.push(buffer);
      const glTFBufferView = {
        buffer: 0,
        byteOffset: this.byteLength,
        byteLength
      };
      this.byteLength += padToNBytes(byteLength, 4);
      this.json.bufferViews = this.json.bufferViews || [];
      this.json.bufferViews.push(glTFBufferView);
      return this.json.bufferViews.length - 1;
    }
    addAccessor(bufferViewIndex, accessor) {
      const glTFAccessor = {
        bufferView: bufferViewIndex,
        type: getAccessorTypeFromSize(accessor.size),
        componentType: accessor.componentType,
        count: accessor.count,
        max: accessor.max,
        min: accessor.min
      };
      this.json.accessors = this.json.accessors || [];
      this.json.accessors.push(glTFAccessor);
      return this.json.accessors.length - 1;
    }
    addBinaryBuffer(sourceBuffer) {
      let accessor = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
        size: 3
      };
      const bufferViewIndex = this.addBufferView(sourceBuffer);
      let minMax = {
        min: accessor.min,
        max: accessor.max
      };
      if (!minMax.min || !minMax.max) {
        minMax = this._getAccessorMinMax(sourceBuffer, accessor.size);
      }
      const accessorDefaults = {
        size: accessor.size,
        componentType: getComponentTypeFromArray(sourceBuffer),
        count: Math.round(sourceBuffer.length / accessor.size),
        min: minMax.min,
        max: minMax.max
      };
      return this.addAccessor(bufferViewIndex, Object.assign(accessorDefaults, accessor));
    }
    addTexture(texture) {
      const {
        imageIndex
      } = texture;
      const glTFTexture = {
        source: imageIndex
      };
      this.json.textures = this.json.textures || [];
      this.json.textures.push(glTFTexture);
      return this.json.textures.length - 1;
    }
    addMaterial(pbrMaterialInfo) {
      this.json.materials = this.json.materials || [];
      this.json.materials.push(pbrMaterialInfo);
      return this.json.materials.length - 1;
    }
    createBinaryChunk() {
      var _this$json, _this$json$buffers;
      this.gltf.buffers = [];
      const totalByteLength = this.byteLength;
      const arrayBuffer = new ArrayBuffer(totalByteLength);
      const targetArray = new Uint8Array(arrayBuffer);
      let dstByteOffset = 0;
      for (const sourceBuffer of this.sourceBuffers || []) {
        dstByteOffset = copyToArray(sourceBuffer, targetArray, dstByteOffset);
      }
      if ((_this$json = this.json) !== null && _this$json !== void 0 && (_this$json$buffers = _this$json.buffers) !== null && _this$json$buffers !== void 0 && _this$json$buffers[0]) {
        this.json.buffers[0].byteLength = totalByteLength;
      } else {
        this.json.buffers = [{
          byteLength: totalByteLength
        }];
      }
      this.gltf.binary = arrayBuffer;
      this.sourceBuffers = [arrayBuffer];
    }
    _removeStringFromArray(array, string) {
      let found = true;
      while (found) {
        const index = array.indexOf(string);
        if (index > -1) {
          array.splice(index, 1);
        } else {
          found = false;
        }
      }
    }
    _addAttributes() {
      let attributes = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const result = {};
      for (const attributeKey in attributes) {
        const attributeData = attributes[attributeKey];
        const attrName = this._getGltfAttributeName(attributeKey);
        const accessor = this.addBinaryBuffer(attributeData.value, attributeData);
        result[attrName] = accessor;
      }
      return result;
    }
    _addIndices(indices) {
      return this.addBinaryBuffer(indices, {
        size: 1
      });
    }
    _getGltfAttributeName(attributeName) {
      switch (attributeName.toLowerCase()) {
        case "position":
        case "positions":
        case "vertices":
          return "POSITION";
        case "normal":
        case "normals":
          return "NORMAL";
        case "color":
        case "colors":
          return "COLOR_0";
        case "texcoord":
        case "texcoords":
          return "TEXCOORD_0";
        default:
          return attributeName;
      }
    }
    _getAccessorMinMax(buffer, size) {
      const result = {
        min: null,
        max: null
      };
      if (buffer.length < size) {
        return result;
      }
      result.min = [];
      result.max = [];
      const initValues = buffer.subarray(0, size);
      for (const value of initValues) {
        result.min.push(value);
        result.max.push(value);
      }
      for (let index = size; index < buffer.length; index += size) {
        for (let componentIndex = 0; componentIndex < size; componentIndex++) {
          result.min[0 + componentIndex] = Math.min(
            result.min[0 + componentIndex],
            buffer[index + componentIndex]
          );
          result.max[0 + componentIndex] = Math.max(
            result.max[0 + componentIndex],
            buffer[index + componentIndex]
          );
        }
      }
      return result;
    }
  };

  // ../../node_modules/@loaders.gl/gltf/dist/esm/meshopt/meshopt-decoder.js
  var wasm_base = "B9h9z9tFBBBF8fL9gBB9gLaaaaaFa9gEaaaB9gFaFa9gEaaaFaEMcBFFFGGGEIIILF9wFFFLEFBFKNFaFCx/IFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBF8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBGy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBEn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBIi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBKI9z9iqlBOc+x8ycGBM/qQFTa8jUUUUBCU/EBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAGTkUUUBRNCUoBAG9uC/wgBZHKCUGAKCUG9JyRVAECFJRICBRcGXEXAcAF9PQFAVAFAclAcAVJAF9JyRMGXGXAG9FQBAMCbJHKC9wZRSAKCIrCEJCGrRQANCUGJRfCBRbAIRTEXGXAOATlAQ9PQBCBRISEMATAQJRIGXAS9FQBCBRtCBREEXGXAOAIlCi9PQBCBRISLMANCU/CBJAEJRKGXGXGXGXGXATAECKrJ2BBAtCKZrCEZfIBFGEBMAKhB83EBAKCNJhB83EBSEMAKAI2BIAI2BBHmCKrHYAYCE6HYy86BBAKCFJAICIJAYJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCGJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCEJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCIJAYAmJHY2BBAI2BFHmCKrHPAPCE6HPy86BBAKCLJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCKJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCOJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCNJAYAmJHY2BBAI2BGHmCKrHPAPCE6HPy86BBAKCVJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCcJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCMJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCSJAYAmJHm2BBAI2BEHICKrHYAYCE6HYy86BBAKCQJAmAYJHm2BBAICIrCEZHYAYCE6HYy86BBAKCfJAmAYJHm2BBAICGrCEZHYAYCE6HYy86BBAKCbJAmAYJHK2BBAICEZHIAICE6HIy86BBAKAIJRISGMAKAI2BNAI2BBHmCIrHYAYCb6HYy86BBAKCFJAICNJAYJHY2BBAmCbZHmAmCb6Hmy86BBAKCGJAYAmJHm2BBAI2BFHYCIrHPAPCb6HPy86BBAKCEJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCIJAmAYJHm2BBAI2BGHYCIrHPAPCb6HPy86BBAKCLJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCKJAmAYJHm2BBAI2BEHYCIrHPAPCb6HPy86BBAKCOJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCNJAmAYJHm2BBAI2BIHYCIrHPAPCb6HPy86BBAKCVJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCcJAmAYJHm2BBAI2BLHYCIrHPAPCb6HPy86BBAKCMJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCSJAmAYJHm2BBAI2BKHYCIrHPAPCb6HPy86BBAKCQJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCfJAmAYJHm2BBAI2BOHICIrHYAYCb6HYy86BBAKCbJAmAYJHK2BBAICbZHIAICb6HIy86BBAKAIJRISFMAKAI8pBB83BBAKCNJAICNJ8pBB83BBAICTJRIMAtCGJRtAECTJHEAS9JQBMMGXAIQBCBRISEMGXAM9FQBANAbJ2BBRtCBRKAfREEXAEANCU/CBJAKJ2BBHTCFrCBATCFZl9zAtJHt86BBAEAGJREAKCFJHKAM9HQBMMAfCFJRfAIRTAbCFJHbAG9HQBMMABAcAG9sJANCUGJAMAG9sTkUUUBpANANCUGJAMCaJAG9sJAGTkUUUBpMAMCBAIyAcJRcAIQBMC9+RKSFMCBC99AOAIlAGCAAGCA9Ly6yRKMALCU/EBJ8kUUUUBAKM+OmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUFT+JUUUBpALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM+lLKFaF99GaG99FaG99GXGXAGCI9HQBAF9FQFEXGXGX9DBBB8/9DBBB+/ABCGJHG1BB+yAB1BBHE+yHI+L+TABCFJHL1BBHK+yHO+L+THN9DBBBB9gHVyAN9DBB/+hANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE86BBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG86BBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG86BBABCIJRBAFCaJHFQBSGMMAF9FQBEXGXGX9DBBB8/9DBBB+/ABCIJHG8uFB+yAB8uFBHE+yHI+L+TABCGJHL8uFBHK+yHO+L+THN9DBBBB9gHVyAN9DB/+g6ANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE87FBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG87FBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG87FBABCNJRBAFCaJHFQBMMM/SEIEaE99EaF99GXAF9FQBCBREABRIEXGXGX9D/zI818/AICKJ8uFBHLCEq+y+VHKAI8uFB+y+UHO9DB/+g6+U9DBBB8/9DBBB+/AO9DBBBB9gy+SHN+L9DBBB9P9d9FQBAN+oRVSFMCUUUU94RVMAICIJ8uFBRcAICGJ8uFBRMABALCFJCEZAEqCFWJAV87FBGXGXAKAM+y+UHN9DB/+g6+U9DBBB8/9DBBB+/AN9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRMSFMCUUUU94RMMABALCGJCEZAEqCFWJAM87FBGXGXAKAc+y+UHK9DB/+g6+U9DBBB8/9DBBB+/AK9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRcSFMCUUUU94RcMABALCaJCEZAEqCFWJAc87FBGXGX9DBBU8/AOAO+U+TANAN+U+TAKAK+U+THO9DBBBBAO9DBBBB9gy+R9DB/+g6+U9DBBB8/+SHO+L9DBBB9P9d9FQBAO+oRcSFMCUUUU94RcMABALCEZAEqCFWJAc87FBAICNJRIAECIJREAFCaJHFQBMMM9JBGXAGCGrAF9sHF9FQBEXABAB8oGBHGCNWCN91+yAGCi91CnWCUUU/8EJ+++U84GBABCIJRBAFCaJHFQBMMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEM/lFFFaGXGXAFABqCEZ9FQBABRESFMGXGXAGCT9PQBABRESFMABREEXAEAF8oGBjGBAECIJAFCIJ8oGBjGBAECNJAFCNJ8oGBjGBAECSJAFCSJ8oGBjGBAECTJREAFCTJRFAGC9wJHGCb9LQBMMAGCI9JQBEXAEAF8oGBjGBAFCIJRFAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF2BB86BBAECFJREAFCFJRFAGCaJHGQBMMABMoFFGaGXGXABCEZ9FQBABRESFMAFCgFZC+BwsN9sRIGXGXAGCT9PQBABRESFMABREEXAEAIjGBAECSJAIjGBAECNJAIjGBAECIJAIjGBAECTJREAGC9wJHGCb9LQBMMAGCI9JQBEXAEAIjGBAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF86BBAECFJREAGCaJHGQBMMABMMMFBCUNMIT9kBB";
  var wasm_simd = "B9h9z9tFBBBF8dL9gBB9gLaaaaaFa9gEaaaB9gGaaB9gFaFaEQSBBFBFFGEGEGIILF9wFFFLEFBFKNFaFCx/aFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBG8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBIy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBKi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBNn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBcI9z9iqlBMc/j9JSIBTEM9+FLa8jUUUUBCTlRBCBRFEXCBRGCBREEXABCNJAGJAECUaAFAGrCFZHIy86BBAEAIJREAGCFJHGCN9HQBMAFCx+YUUBJAE86BBAFCEWCxkUUBJAB8pEN83EBAFCFJHFCUG9HQBMMkRIbaG97FaK978jUUUUBCU/KBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAG/8cBBCUoBAG9uC/wgBZHKCUGAKCUG9JyRNAECFJRKCBRVGXEXAVAF9PQFANAFAVlAVANJAF9JyRcGXGXAG9FQBAcCbJHIC9wZHMCE9sRSAMCFWRQAICIrCEJCGrRfCBRbEXAKRTCBRtGXEXGXAOATlAf9PQBCBRKSLMALCU/CBJAtAM9sJRmATAfJRKCBREGXAMCoB9JQBAOAKlC/gB9JQBCBRIEXAmAIJREGXGXGXGXGXATAICKrJ2BBHYCEZfIBFGEBMAECBDtDMIBSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAnDeBJAeCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAnDeBJAeCx+YUUBJ2BBJRKSFMAEAKDBBBDMIBAKCTJRKMGXGXGXGXGXAYCGrCEZfIBFGEBMAECBDtDMITSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCIJAnDeBJAeCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCNJAnDeBJAeCx+YUUBJ2BBJRKSFMAEAKDBBBDMITAKCTJRKMGXGXGXGXGXAYCIrCEZfIBFGEBMAECBDtDMIASEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCIJAnDeBJAeCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCNJAnDeBJAeCx+YUUBJ2BBJRKSFMAEAKDBBBDMIAAKCTJRKMGXGXGXGXGXAYCKrfIBFGEBMAECBDtDMI8wSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCIJAnDeBJAYCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCNJAnDeBJAYCx+YUUBJ2BBJRKSFMAEAKDBBBDMI8wAKCTJRKMAICoBJREAICUFJAM9LQFAERIAOAKlC/fB9LQBMMGXAEAM9PQBAECErRIEXGXAOAKlCi9PQBCBRKSOMAmAEJRYGXGXGXGXGXATAECKrJ2BBAICKZrCEZfIBFGEBMAYCBDtDMIBSEMAYAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAnDeBJAeCx+YUUBJ2BBJRKSGMAYAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAnDeBJAeCx+YUUBJ2BBJRKSFMAYAKDBBBDMIBAKCTJRKMAICGJRIAECTJHEAM9JQBMMGXAK9FQBAKRTAtCFJHtCI6QGSFMMCBRKSEMGXAM9FQBALCUGJAbJREALAbJDBGBRnCBRYEXAEALCU/CBJAYJHIDBIBHdCFD9tAdCFDbHPD9OD9hD9RHdAIAMJDBIBHiCFD9tAiAPD9OD9hD9RHiDQBTFtGmEYIPLdKeOnH8ZAIAQJDBIBHpCFD9tApAPD9OD9hD9RHpAIASJDBIBHyCFD9tAyAPD9OD9hD9RHyDQBTFtGmEYIPLdKeOnH8cDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGEAnD9uHnDyBjGBAEAGJHIAnAPAPDQILKOILKOILKOILKOD9uHnDyBjGBAIAGJHIAnAPAPDQNVcMNVcMNVcMNVcMD9uHnDyBjGBAIAGJHIAnAPAPDQSQfbSQfbSQfbSQfbD9uHnDyBjGBAIAGJHIAnA8ZA8cDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHnDyBjGBAIAGJHIAnAPAPDQILKOILKOILKOILKOD9uHnDyBjGBAIAGJHIAnAPAPDQNVcMNVcMNVcMNVcMD9uHnDyBjGBAIAGJHIAnAPAPDQSQfbSQfbSQfbSQfbD9uHnDyBjGBAIAGJHIAnAdAiDQNiV8ZcpMyS8cQ8df8eb8fHdApAyDQNiV8ZcpMyS8cQ8df8eb8fHiDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGED9uHnDyBjGBAIAGJHIAnAPAPDQILKOILKOILKOILKOD9uHnDyBjGBAIAGJHIAnAPAPDQNVcMNVcMNVcMNVcMD9uHnDyBjGBAIAGJHIAnAPAPDQSQfbSQfbSQfbSQfbD9uHnDyBjGBAIAGJHIAnAdAiDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHnDyBjGBAIAGJHIAnAPAPDQILKOILKOILKOILKOD9uHnDyBjGBAIAGJHIAnAPAPDQNVcMNVcMNVcMNVcMD9uHnDyBjGBAIAGJHIAnAPAPDQSQfbSQfbSQfbSQfbD9uHnDyBjGBAIAGJREAYCTJHYAM9JQBMMAbCIJHbAG9JQBMMABAVAG9sJALCUGJAcAG9s/8cBBALALCUGJAcCaJAG9sJAG/8cBBMAcCBAKyAVJRVAKQBMC9+RKSFMCBC99AOAKlAGCAAGCA9Ly6yRKMALCU/KBJ8kUUUUBAKMNBT+BUUUBM+KmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUF/8MBALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM/xLGEaK978jUUUUBCAlHE8kUUUUBGXGXAGCI9HQBGXAFC98ZHI9FQBABRGCBRLEXAGAGDBBBHKCiD+rFCiD+sFD/6FHOAKCND+rFCiD+sFD/6FAOD/gFAKCTD+rFCiD+sFD/6FHND/gFD/kFD/lFHVCBDtD+2FHcAOCUUUU94DtHMD9OD9RD/kFHO9DBB/+hDYAOAOD/mFAVAVD/mFANAcANAMD9OD9RD/kFHOAOD/mFD/kFD/kFD/jFD/nFHND/mF9DBBX9LDYHcD/kFCgFDtD9OAKCUUU94DtD9OD9QAOAND/mFAcD/kFCND+rFCU/+EDtD9OD9QAVAND/mFAcD/kFCTD+rFCUU/8ODtD9OD9QDMBBAGCTJRGALCIJHLAI9JQBMMAIAF9PQFAEAFCEZHLCGWHGqCBCTAGl/8MBAEABAICGWJHIAG/8cBBGXAL9FQBAEAEDBIBHKCiD+rFCiD+sFD/6FHOAKCND+rFCiD+sFD/6FAOD/gFAKCTD+rFCiD+sFD/6FHND/gFD/kFD/lFHVCBDtD+2FHcAOCUUUU94DtHMD9OD9RD/kFHO9DBB/+hDYAOAOD/mFAVAVD/mFANAcANAMD9OD9RD/kFHOAOD/mFD/kFD/kFD/jFD/nFHND/mF9DBBX9LDYHcD/kFCgFDtD9OAKCUUU94DtD9OD9QAOAND/mFAcD/kFCND+rFCU/+EDtD9OD9QAVAND/mFAcD/kFCTD+rFCUU/8ODtD9OD9QDMIBMAIAEAG/8cBBSFMABAFC98ZHGT+HUUUBAGAF9PQBAEAFCEZHICEWHLJCBCAALl/8MBAEABAGCEWJHGAL/8cBBAEAIT+HUUUBAGAEAL/8cBBMAECAJ8kUUUUBM+yEGGaO97GXAF9FQBCBRGEXABCTJHEAEDBBBHICBDtHLCUU98D8cFCUU98D8cEHKD9OABDBBBHOAIDQILKOSQfbPden8c8d8e8fCggFDtD9OD/6FAOAIDQBFGENVcMTtmYi8ZpyHICTD+sFD/6FHND/gFAICTD+rFCTD+sFD/6FHVD/gFD/kFD/lFHI9DB/+g6DYAVAIALD+2FHLAVCUUUU94DtHcD9OD9RD/kFHVAVD/mFAIAID/mFANALANAcD9OD9RD/kFHIAID/mFD/kFD/kFD/jFD/nFHND/mF9DBBX9LDYHLD/kFCTD+rFAVAND/mFALD/kFCggEDtD9OD9QHVAIAND/mFALD/kFCaDbCBDnGCBDnECBDnKCBDnOCBDncCBDnMCBDnfCBDnbD9OHIDQNVi8ZcMpySQ8c8dfb8e8fD9QDMBBABAOAKD9OAVAIDQBFTtGEmYILPdKOenD9QDMBBABCAJRBAGCIJHGAF9JQBMMM94FEa8jUUUUBCAlHE8kUUUUBABAFC98ZHIT+JUUUBGXAIAF9PQBAEAFCEZHLCEWHFJCBCAAFl/8MBAEABAICEWJHBAF/8cBBAEALT+JUUUBABAEAF/8cBBMAECAJ8kUUUUBM/hEIGaF97FaL978jUUUUBCTlRGGXAF9FQBCBREEXAGABDBBBHIABCTJHLDBBBHKDQILKOSQfbPden8c8d8e8fHOCTD+sFHNCID+rFDMIBAB9DBBU8/DY9D/zI818/DYANCEDtD9QD/6FD/nFHNAIAKDQBFGENVcMTtmYi8ZpyHICTD+rFCTD+sFD/6FD/mFHKAKD/mFANAICTD+sFD/6FD/mFHVAVD/mFANAOCTD+rFCTD+sFD/6FD/mFHOAOD/mFD/kFD/kFD/lFCBDtD+4FD/jF9DB/+g6DYHND/mF9DBBX9LDYHID/kFCggEDtHcD9OAVAND/mFAID/kFCTD+rFD9QHVAOAND/mFAID/kFCTD+rFAKAND/mFAID/kFAcD9OD9QHNDQBFTtGEmYILPdKOenHID8dBAGDBIBDyB+t+J83EBABCNJAID8dFAGDBIBDyF+t+J83EBALAVANDQNVi8ZcMpySQ8c8dfb8e8fHND8dBAGDBIBDyG+t+J83EBABCiJAND8dFAGDBIBDyE+t+J83EBABCAJRBAECIJHEAF9JQBMMM/3FGEaF978jUUUUBCoBlREGXAGCGrAF9sHIC98ZHL9FQBCBRGABRFEXAFAFDBBBHKCND+rFCND+sFD/6FAKCiD+sFCnD+rFCUUU/8EDtD+uFD/mFDMBBAFCTJRFAGCIJHGAL9JQBMMGXALAI9PQBAEAICEZHGCGWHFqCBCoBAFl/8MBAEABALCGWJHLAF/8cBBGXAG9FQBAEAEDBIBHKCND+rFCND+sFD/6FAKCiD+sFCnD+rFCUUU/8EDtD+uFD/mFDMIBMALAEAF/8cBBMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEMMMFBCUNMIT9tBB";
  var detector = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 3, 2, 0, 0, 5, 3, 1, 0, 1, 12, 1, 0, 10, 22, 2, 12, 0, 65, 0, 65, 0, 65, 0, 252, 10, 0, 0, 11, 7, 0, 65, 0, 253, 15, 26, 11]);
  var wasmpack = new Uint8Array([32, 0, 65, 253, 3, 1, 2, 34, 4, 106, 6, 5, 11, 8, 7, 20, 13, 33, 12, 16, 128, 9, 116, 64, 19, 113, 127, 15, 10, 21, 22, 14, 255, 66, 24, 54, 136, 107, 18, 23, 192, 26, 114, 118, 132, 17, 77, 101, 130, 144, 27, 87, 131, 44, 45, 74, 156, 154, 70, 167]);
  var FILTERS = {
    0: "",
    1: "meshopt_decodeFilterOct",
    2: "meshopt_decodeFilterQuat",
    3: "meshopt_decodeFilterExp",
    NONE: "",
    OCTAHEDRAL: "meshopt_decodeFilterOct",
    QUATERNION: "meshopt_decodeFilterQuat",
    EXPONENTIAL: "meshopt_decodeFilterExp"
  };
  var DECODERS = {
    0: "meshopt_decodeVertexBuffer",
    1: "meshopt_decodeIndexBuffer",
    2: "meshopt_decodeIndexSequence",
    ATTRIBUTES: "meshopt_decodeVertexBuffer",
    TRIANGLES: "meshopt_decodeIndexBuffer",
    INDICES: "meshopt_decodeIndexSequence"
  };
  async function meshoptDecodeGltfBuffer(target, count, size, source, mode) {
    let filter = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : "NONE";
    const instance = await loadWasmInstance();
    decode(instance, instance.exports[DECODERS[mode]], target, count, size, source, instance.exports[FILTERS[filter || "NONE"]]);
  }
  var wasmPromise;
  async function loadWasmInstance() {
    if (!wasmPromise) {
      wasmPromise = loadWasmModule();
    }
    return wasmPromise;
  }
  async function loadWasmModule() {
    let wasm = wasm_base;
    if (WebAssembly.validate(detector)) {
      wasm = wasm_simd;
      console.log("Warning: meshopt_decoder is using experimental SIMD support");
    }
    const result = await WebAssembly.instantiate(unpack(wasm), {});
    await result.instance.exports.__wasm_call_ctors();
    return result.instance;
  }
  function unpack(data) {
    const result = new Uint8Array(data.length);
    for (let i3 = 0; i3 < data.length; ++i3) {
      const ch = data.charCodeAt(i3);
      result[i3] = ch > 96 ? ch - 71 : ch > 64 ? ch - 65 : ch > 47 ? ch + 4 : ch > 46 ? 63 : 62;
    }
    let write = 0;
    for (let i3 = 0; i3 < data.length; ++i3) {
      result[write++] = result[i3] < 60 ? wasmpack[result[i3]] : (result[i3] - 60) * 64 + result[++i3];
    }
    return result.buffer.slice(0, write);
  }
  function decode(instance, fun, target, count, size, source, filter) {
    const sbrk = instance.exports.sbrk;
    const count4 = count + 3 & ~3;
    const tp = sbrk(count4 * size);
    const sp = sbrk(source.length);
    const heap = new Uint8Array(instance.exports.memory.buffer);
    heap.set(source, sp);
    const res = fun(tp, count, size, sp, source.length);
    if (res === 0 && filter) {
      filter(tp, count4, size);
    }
    target.set(heap.subarray(tp, tp + count * size));
    sbrk(tp - sbrk(0));
    if (res !== 0) {
      throw new Error("Malformed buffer data: ".concat(res));
    }
  }

  // ../../node_modules/@loaders.gl/gltf/dist/esm/lib/extensions/EXT_meshopt_compression.js
  var EXT_MESHOPT_COMPRESSION = "EXT_meshopt_compression";
  var name = EXT_MESHOPT_COMPRESSION;
  async function decode2(gltfData, options) {
    var _options$gltf;
    const scenegraph = new GLTFScenegraph(gltfData);
    if (!(options !== null && options !== void 0 && (_options$gltf = options.gltf) !== null && _options$gltf !== void 0 && _options$gltf.decompressMeshes)) {
      return;
    }
    const promises = [];
    for (const bufferViewIndex of gltfData.json.bufferViews || []) {
      promises.push(decodeMeshoptBufferView(scenegraph, bufferViewIndex));
    }
    await Promise.all(promises);
    scenegraph.removeExtension(EXT_MESHOPT_COMPRESSION);
  }
  async function decodeMeshoptBufferView(scenegraph, bufferView) {
    const meshoptExtension = scenegraph.getObjectExtension(bufferView, EXT_MESHOPT_COMPRESSION);
    if (meshoptExtension) {
      const {
        byteOffset = 0,
        byteLength = 0,
        byteStride,
        count,
        mode,
        filter = "NONE",
        buffer: bufferIndex
      } = meshoptExtension;
      const buffer = scenegraph.gltf.buffers[bufferIndex];
      const source = new Uint8Array(buffer.arrayBuffer, buffer.byteOffset + byteOffset, byteLength);
      const result = new Uint8Array(scenegraph.gltf.buffers[bufferView.buffer].arrayBuffer, bufferView.byteOffset, bufferView.byteLength);
      await meshoptDecodeGltfBuffer(result, count, byteStride, source, mode, filter);
      return result;
    }
    return null;
  }

  // ../../node_modules/@loaders.gl/gltf/dist/esm/lib/extensions/EXT_texture_webp.js
  var EXT_texture_webp_exports = {};
  __export(EXT_texture_webp_exports, {
    name: () => name2,
    preprocess: () => preprocess
  });
  var EXT_TEXTURE_WEBP = "EXT_texture_webp";
  var name2 = EXT_TEXTURE_WEBP;
  function preprocess(gltfData, options) {
    const scenegraph = new GLTFScenegraph(gltfData);
    if (!_isImageFormatSupported("image/webp")) {
      if (scenegraph.getRequiredExtensions().includes(EXT_TEXTURE_WEBP)) {
        throw new Error("gltf: Required extension ".concat(EXT_TEXTURE_WEBP, " not supported by browser"));
      }
      return;
    }
    const {
      json
    } = scenegraph;
    for (const texture of json.textures || []) {
      const extension = scenegraph.getObjectExtension(texture, EXT_TEXTURE_WEBP);
      if (extension) {
        texture.source = extension.source;
      }
      scenegraph.removeObjectExtension(texture, EXT_TEXTURE_WEBP);
    }
    scenegraph.removeExtension(EXT_TEXTURE_WEBP);
  }

  // ../../node_modules/@loaders.gl/gltf/dist/esm/lib/extensions/KHR_texture_basisu.js
  var KHR_texture_basisu_exports = {};
  __export(KHR_texture_basisu_exports, {
    name: () => name3,
    preprocess: () => preprocess2
  });
  var KHR_TEXTURE_BASISU = "KHR_texture_basisu";
  var name3 = KHR_TEXTURE_BASISU;
  function preprocess2(gltfData, options) {
    const scene = new GLTFScenegraph(gltfData);
    const {
      json
    } = scene;
    for (const texture of json.textures || []) {
      const extension = scene.getObjectExtension(texture, KHR_TEXTURE_BASISU);
      if (extension) {
        texture.source = extension.source;
      }
      scene.removeObjectExtension(texture, KHR_TEXTURE_BASISU);
    }
    scene.removeExtension(KHR_TEXTURE_BASISU);
  }

  // ../../node_modules/@loaders.gl/gltf/dist/esm/lib/extensions/KHR_draco_mesh_compression.js
  var KHR_draco_mesh_compression_exports = {};
  __export(KHR_draco_mesh_compression_exports, {
    decode: () => decode3,
    encode: () => encode,
    name: () => name4,
    preprocess: () => preprocess3
  });

  // ../../node_modules/@loaders.gl/gltf/dist/esm/lib/gltf-utils/gltf-attribute-utils.js
  function getGLTFAccessors(attributes) {
    const accessors = {};
    for (const name10 in attributes) {
      const attribute = attributes[name10];
      if (name10 !== "indices") {
        const glTFAccessor = getGLTFAccessor(attribute);
        accessors[name10] = glTFAccessor;
      }
    }
    return accessors;
  }
  function getGLTFAccessor(attribute) {
    const {
      buffer,
      size,
      count
    } = getAccessorData(attribute);
    const glTFAccessor = {
      value: buffer,
      size,
      byteOffset: 0,
      count,
      type: getAccessorTypeFromSize(size),
      componentType: getComponentTypeFromArray(buffer)
    };
    return glTFAccessor;
  }
  function getAccessorData(attribute) {
    let buffer = attribute;
    let size = 1;
    let count = 0;
    if (attribute && attribute.value) {
      buffer = attribute.value;
      size = attribute.size || 1;
    }
    if (buffer) {
      if (!ArrayBuffer.isView(buffer)) {
        buffer = toTypedArray(buffer, Float32Array);
      }
      count = buffer.length / size;
    }
    return {
      buffer,
      size,
      count
    };
  }
  function toTypedArray(array, ArrayType) {
    let convertTypedArrays = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    if (!array) {
      return null;
    }
    if (Array.isArray(array)) {
      return new ArrayType(array);
    }
    if (convertTypedArrays && !(array instanceof ArrayType)) {
      return new ArrayType(array);
    }
    return array;
  }

  // ../../node_modules/@loaders.gl/gltf/dist/esm/lib/extensions/KHR_draco_mesh_compression.js
  var KHR_DRACO_MESH_COMPRESSION = "KHR_draco_mesh_compression";
  var name4 = KHR_DRACO_MESH_COMPRESSION;
  function preprocess3(gltfData, options, context) {
    const scenegraph = new GLTFScenegraph(gltfData);
    for (const primitive of makeMeshPrimitiveIterator(scenegraph)) {
      if (scenegraph.getObjectExtension(primitive, KHR_DRACO_MESH_COMPRESSION)) {
      }
    }
  }
  async function decode3(gltfData, options, context) {
    var _options$gltf;
    if (!(options !== null && options !== void 0 && (_options$gltf = options.gltf) !== null && _options$gltf !== void 0 && _options$gltf.decompressMeshes)) {
      return;
    }
    const scenegraph = new GLTFScenegraph(gltfData);
    const promises = [];
    for (const primitive of makeMeshPrimitiveIterator(scenegraph)) {
      if (scenegraph.getObjectExtension(primitive, KHR_DRACO_MESH_COMPRESSION)) {
        promises.push(decompressPrimitive(scenegraph, primitive, options, context));
      }
    }
    await Promise.all(promises);
    scenegraph.removeExtension(KHR_DRACO_MESH_COMPRESSION);
  }
  function encode(gltfData) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const scenegraph = new GLTFScenegraph(gltfData);
    for (const mesh of scenegraph.json.meshes || []) {
      compressMesh(mesh, options);
      scenegraph.addRequiredExtension(KHR_DRACO_MESH_COMPRESSION);
    }
  }
  async function decompressPrimitive(scenegraph, primitive, options, context) {
    const dracoExtension = scenegraph.getObjectExtension(primitive, KHR_DRACO_MESH_COMPRESSION);
    if (!dracoExtension) {
      return;
    }
    const buffer = scenegraph.getTypedArrayForBufferView(dracoExtension.bufferView);
    const bufferCopy = sliceArrayBuffer(buffer.buffer, buffer.byteOffset);
    const {
      parse: parse4
    } = context;
    const dracoOptions = {
      ...options
    };
    delete dracoOptions["3d-tiles"];
    const decodedData = await parse4(bufferCopy, DracoLoader2, dracoOptions, context);
    const decodedAttributes = getGLTFAccessors(decodedData.attributes);
    for (const [attributeName, decodedAttribute] of Object.entries(decodedAttributes)) {
      if (attributeName in primitive.attributes) {
        const accessorIndex = primitive.attributes[attributeName];
        const accessor = scenegraph.getAccessor(accessorIndex);
        if (accessor !== null && accessor !== void 0 && accessor.min && accessor !== null && accessor !== void 0 && accessor.max) {
          decodedAttribute.min = accessor.min;
          decodedAttribute.max = accessor.max;
        }
      }
    }
    primitive.attributes = decodedAttributes;
    if (decodedData.indices) {
      primitive.indices = getGLTFAccessor(decodedData.indices);
    }
    checkPrimitive(primitive);
  }
  function compressMesh(attributes, indices) {
    var _context$parseSync;
    let mode = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 4;
    let options = arguments.length > 3 ? arguments[3] : void 0;
    let context = arguments.length > 4 ? arguments[4] : void 0;
    if (!options.DracoWriter) {
      throw new Error("options.gltf.DracoWriter not provided");
    }
    const compressedData = options.DracoWriter.encodeSync({
      attributes
    });
    const decodedData = context === null || context === void 0 ? void 0 : (_context$parseSync = context.parseSync) === null || _context$parseSync === void 0 ? void 0 : _context$parseSync.call(context, {
      attributes
    });
    const fauxAccessors = options._addFauxAttributes(decodedData.attributes);
    const bufferViewIndex = options.addBufferView(compressedData);
    const glTFMesh = {
      primitives: [{
        attributes: fauxAccessors,
        mode,
        extensions: {
          [KHR_DRACO_MESH_COMPRESSION]: {
            bufferView: bufferViewIndex,
            attributes: fauxAccessors
          }
        }
      }]
    };
    return glTFMesh;
  }
  function checkPrimitive(primitive) {
    if (!primitive.attributes && Object.keys(primitive.attributes).length > 0) {
      throw new Error("glTF: Empty primitive detected: Draco decompression failure?");
    }
  }
  function* makeMeshPrimitiveIterator(scenegraph) {
    for (const mesh of scenegraph.json.meshes || []) {
      for (const primitive of mesh.primitives) {
        yield primitive;
      }
    }
  }

  // ../../node_modules/@loaders.gl/gltf/dist/esm/lib/extensions/KHR_texture_transform.js
  var KHR_texture_transform_exports = {};
  __export(KHR_texture_transform_exports, {
    decode: () => decode4,
    name: () => name5
  });

  // ../../node_modules/@loaders.gl/gltf/dist/esm/lib/gltf-utils/gltf-constants.js
  var COMPONENTS = {
    SCALAR: 1,
    VEC2: 2,
    VEC3: 3,
    VEC4: 4,
    MAT2: 4,
    MAT3: 9,
    MAT4: 16
  };
  var BYTES = {
    5120: 1,
    5121: 1,
    5122: 2,
    5123: 2,
    5125: 4,
    5126: 4
  };

  // ../../node_modules/@loaders.gl/gltf/dist/esm/lib/extensions/KHR_texture_transform.js
  var EXT_MESHOPT_TRANSFORM = "KHR_texture_transform";
  var name5 = EXT_MESHOPT_TRANSFORM;
  var scratchVector13 = new Vector3();
  var scratchRotationMatrix = new Matrix3();
  var scratchScaleMatrix = new Matrix3();
  async function decode4(gltfData, options) {
    const gltfScenegraph = new GLTFScenegraph(gltfData);
    const extension = gltfScenegraph.getExtension(EXT_MESHOPT_TRANSFORM);
    if (!extension) {
      return;
    }
    const materials = gltfData.json.materials || [];
    for (let i3 = 0; i3 < materials.length; i3++) {
      transformTexCoords(i3, gltfData);
    }
  }
  function transformTexCoords(materialIndex, gltfData) {
    var _gltfData$json$materi, _material$pbrMetallic, _material$pbrMetallic2;
    const processedTexCoords = [];
    const material = (_gltfData$json$materi = gltfData.json.materials) === null || _gltfData$json$materi === void 0 ? void 0 : _gltfData$json$materi[materialIndex];
    const baseColorTexture = material === null || material === void 0 ? void 0 : (_material$pbrMetallic = material.pbrMetallicRoughness) === null || _material$pbrMetallic === void 0 ? void 0 : _material$pbrMetallic.baseColorTexture;
    if (baseColorTexture) {
      transformPrimitives(gltfData, materialIndex, baseColorTexture, processedTexCoords);
    }
    const emisiveTexture = material === null || material === void 0 ? void 0 : material.emissiveTexture;
    if (emisiveTexture) {
      transformPrimitives(gltfData, materialIndex, emisiveTexture, processedTexCoords);
    }
    const normalTexture = material === null || material === void 0 ? void 0 : material.normalTexture;
    if (normalTexture) {
      transformPrimitives(gltfData, materialIndex, normalTexture, processedTexCoords);
    }
    const occlusionTexture = material === null || material === void 0 ? void 0 : material.occlusionTexture;
    if (occlusionTexture) {
      transformPrimitives(gltfData, materialIndex, occlusionTexture, processedTexCoords);
    }
    const metallicRoughnessTexture = material === null || material === void 0 ? void 0 : (_material$pbrMetallic2 = material.pbrMetallicRoughness) === null || _material$pbrMetallic2 === void 0 ? void 0 : _material$pbrMetallic2.metallicRoughnessTexture;
    if (metallicRoughnessTexture) {
      transformPrimitives(gltfData, materialIndex, metallicRoughnessTexture, processedTexCoords);
    }
  }
  function transformPrimitives(gltfData, materialIndex, texture, processedTexCoords) {
    const transformParameters = getTransformParameters(texture, processedTexCoords);
    if (!transformParameters) {
      return;
    }
    const meshes = gltfData.json.meshes || [];
    for (const mesh of meshes) {
      for (const primitive of mesh.primitives) {
        const material = primitive.material;
        if (Number.isFinite(material) && materialIndex === material) {
          transformPrimitive(gltfData, primitive, transformParameters);
        }
      }
    }
  }
  function getTransformParameters(texture, processedTexCoords) {
    var _texture$extensions;
    const textureInfo = (_texture$extensions = texture.extensions) === null || _texture$extensions === void 0 ? void 0 : _texture$extensions[EXT_MESHOPT_TRANSFORM];
    const {
      texCoord: originalTexCoord = 0
    } = texture;
    const {
      texCoord = originalTexCoord
    } = textureInfo;
    const isProcessed = processedTexCoords.findIndex((_ref) => {
      let [original, newTexCoord] = _ref;
      return original === originalTexCoord && newTexCoord === texCoord;
    }) !== -1;
    if (!isProcessed) {
      const matrix = makeTransformationMatrix(textureInfo);
      if (originalTexCoord !== texCoord) {
        texture.texCoord = texCoord;
      }
      processedTexCoords.push([originalTexCoord, texCoord]);
      return {
        originalTexCoord,
        texCoord,
        matrix
      };
    }
    return null;
  }
  function transformPrimitive(gltfData, primitive, transformParameters) {
    const {
      originalTexCoord,
      texCoord,
      matrix
    } = transformParameters;
    const texCoordAccessor = primitive.attributes["TEXCOORD_".concat(originalTexCoord)];
    if (Number.isFinite(texCoordAccessor)) {
      var _gltfData$json$access;
      const accessor = (_gltfData$json$access = gltfData.json.accessors) === null || _gltfData$json$access === void 0 ? void 0 : _gltfData$json$access[texCoordAccessor];
      if (accessor && accessor.bufferView) {
        var _gltfData$json$buffer;
        const bufferView = (_gltfData$json$buffer = gltfData.json.bufferViews) === null || _gltfData$json$buffer === void 0 ? void 0 : _gltfData$json$buffer[accessor.bufferView];
        if (bufferView) {
          const {
            arrayBuffer,
            byteOffset: bufferByteOffset
          } = gltfData.buffers[bufferView.buffer];
          const byteOffset = (bufferByteOffset || 0) + (accessor.byteOffset || 0) + (bufferView.byteOffset || 0);
          const {
            ArrayType,
            length: length5
          } = getAccessorArrayTypeAndLength(accessor, bufferView);
          const bytes = BYTES[accessor.componentType];
          const components = COMPONENTS[accessor.type];
          const elementAddressScale = bufferView.byteStride || bytes * components;
          const result = new Float32Array(length5);
          for (let i3 = 0; i3 < accessor.count; i3++) {
            const uv = new ArrayType(arrayBuffer, byteOffset + i3 * elementAddressScale, 2);
            scratchVector13.set(uv[0], uv[1], 1);
            scratchVector13.transformByMatrix3(matrix);
            result.set([scratchVector13[0], scratchVector13[1]], i3 * components);
          }
          if (originalTexCoord === texCoord) {
            updateGltf(accessor, bufferView, gltfData.buffers, result);
          } else {
            createAttribute(texCoord, accessor, primitive, gltfData, result);
          }
        }
      }
    }
  }
  function updateGltf(accessor, bufferView, buffers, newTexCoordArray) {
    accessor.componentType = 5126;
    buffers.push({
      arrayBuffer: newTexCoordArray.buffer,
      byteOffset: 0,
      byteLength: newTexCoordArray.buffer.byteLength
    });
    bufferView.buffer = buffers.length - 1;
    bufferView.byteLength = newTexCoordArray.buffer.byteLength;
    bufferView.byteOffset = 0;
    delete bufferView.byteStride;
  }
  function createAttribute(newTexCoord, originalAccessor, primitive, gltfData, newTexCoordArray) {
    gltfData.buffers.push({
      arrayBuffer: newTexCoordArray.buffer,
      byteOffset: 0,
      byteLength: newTexCoordArray.buffer.byteLength
    });
    const bufferViews = gltfData.json.bufferViews;
    if (!bufferViews) {
      return;
    }
    bufferViews.push({
      buffer: gltfData.buffers.length - 1,
      byteLength: newTexCoordArray.buffer.byteLength,
      byteOffset: 0
    });
    const accessors = gltfData.json.accessors;
    if (!accessors) {
      return;
    }
    accessors.push({
      bufferView: (bufferViews === null || bufferViews === void 0 ? void 0 : bufferViews.length) - 1,
      byteOffset: 0,
      componentType: 5126,
      count: originalAccessor.count,
      type: "VEC2"
    });
    primitive.attributes["TEXCOORD_".concat(newTexCoord)] = accessors.length - 1;
  }
  function makeTransformationMatrix(extensionData) {
    const {
      offset = [0, 0],
      rotation = 0,
      scale: scale5 = [1, 1]
    } = extensionData;
    const translationMatirx = new Matrix3().set(1, 0, 0, 0, 1, 0, offset[0], offset[1], 1);
    const rotationMatirx = scratchRotationMatrix.set(Math.cos(rotation), Math.sin(rotation), 0, -Math.sin(rotation), Math.cos(rotation), 0, 0, 0, 1);
    const scaleMatrix = scratchScaleMatrix.set(scale5[0], 0, 0, 0, scale5[1], 0, 0, 0, 1);
    return translationMatirx.multiplyRight(rotationMatirx).multiplyRight(scaleMatrix);
  }

  // ../../node_modules/@loaders.gl/gltf/dist/esm/lib/extensions/deprecated/KHR_lights_punctual.js
  var KHR_lights_punctual_exports = {};
  __export(KHR_lights_punctual_exports, {
    decode: () => decode5,
    encode: () => encode2,
    name: () => name6
  });
  var KHR_LIGHTS_PUNCTUAL = "KHR_lights_punctual";
  var name6 = KHR_LIGHTS_PUNCTUAL;
  async function decode5(gltfData) {
    const gltfScenegraph = new GLTFScenegraph(gltfData);
    const {
      json
    } = gltfScenegraph;
    const extension = gltfScenegraph.getExtension(KHR_LIGHTS_PUNCTUAL);
    if (extension) {
      gltfScenegraph.json.lights = extension.lights;
      gltfScenegraph.removeExtension(KHR_LIGHTS_PUNCTUAL);
    }
    for (const node2 of json.nodes || []) {
      const nodeExtension = gltfScenegraph.getObjectExtension(node2, KHR_LIGHTS_PUNCTUAL);
      if (nodeExtension) {
        node2.light = nodeExtension.light;
      }
      gltfScenegraph.removeObjectExtension(node2, KHR_LIGHTS_PUNCTUAL);
    }
  }
  async function encode2(gltfData) {
    const gltfScenegraph = new GLTFScenegraph(gltfData);
    const {
      json
    } = gltfScenegraph;
    if (json.lights) {
      const extension = gltfScenegraph.addExtension(KHR_LIGHTS_PUNCTUAL);
      assert11(!extension.lights);
      extension.lights = json.lights;
      delete json.lights;
    }
    if (gltfScenegraph.json.lights) {
      for (const light of gltfScenegraph.json.lights) {
        const node2 = light.node;
        gltfScenegraph.addObjectExtension(node2, KHR_LIGHTS_PUNCTUAL, light);
      }
      delete gltfScenegraph.json.lights;
    }
  }

  // ../../node_modules/@loaders.gl/gltf/dist/esm/lib/extensions/deprecated/KHR_materials_unlit.js
  var KHR_materials_unlit_exports = {};
  __export(KHR_materials_unlit_exports, {
    decode: () => decode6,
    encode: () => encode3,
    name: () => name7
  });
  var KHR_MATERIALS_UNLIT = "KHR_materials_unlit";
  var name7 = KHR_MATERIALS_UNLIT;
  async function decode6(gltfData) {
    const gltfScenegraph = new GLTFScenegraph(gltfData);
    const {
      json
    } = gltfScenegraph;
    for (const material of json.materials || []) {
      const extension = material.extensions && material.extensions.KHR_materials_unlit;
      if (extension) {
        material.unlit = true;
      }
      gltfScenegraph.removeObjectExtension(material, KHR_MATERIALS_UNLIT);
    }
    gltfScenegraph.removeExtension(KHR_MATERIALS_UNLIT);
  }
  function encode3(gltfData) {
    const gltfScenegraph = new GLTFScenegraph(gltfData);
    const {
      json
    } = gltfScenegraph;
    if (gltfScenegraph.materials) {
      for (const material of json.materials || []) {
        if (material.unlit) {
          delete material.unlit;
          gltfScenegraph.addObjectExtension(material, KHR_MATERIALS_UNLIT, {});
          gltfScenegraph.addExtension(KHR_MATERIALS_UNLIT);
        }
      }
    }
  }

  // ../../node_modules/@loaders.gl/gltf/dist/esm/lib/extensions/deprecated/KHR_techniques_webgl.js
  var KHR_techniques_webgl_exports = {};
  __export(KHR_techniques_webgl_exports, {
    decode: () => decode7,
    encode: () => encode4,
    name: () => name8
  });
  var KHR_TECHNIQUES_WEBGL = "KHR_techniques_webgl";
  var name8 = KHR_TECHNIQUES_WEBGL;
  async function decode7(gltfData) {
    const gltfScenegraph = new GLTFScenegraph(gltfData);
    const {
      json
    } = gltfScenegraph;
    const extension = gltfScenegraph.getExtension(KHR_TECHNIQUES_WEBGL);
    if (extension) {
      const techniques = resolveTechniques(extension, gltfScenegraph);
      for (const material of json.materials || []) {
        const materialExtension = gltfScenegraph.getObjectExtension(material, KHR_TECHNIQUES_WEBGL);
        if (materialExtension) {
          material.technique = Object.assign(
            {},
            materialExtension,
            techniques[materialExtension.technique]
          );
          material.technique.values = resolveValues(material.technique, gltfScenegraph);
        }
        gltfScenegraph.removeObjectExtension(material, KHR_TECHNIQUES_WEBGL);
      }
      gltfScenegraph.removeExtension(KHR_TECHNIQUES_WEBGL);
    }
  }
  async function encode4(gltfData, options) {
  }
  function resolveTechniques(techniquesExtension, gltfScenegraph) {
    const {
      programs = [],
      shaders = [],
      techniques = []
    } = techniquesExtension;
    const textDecoder = new TextDecoder();
    shaders.forEach((shader) => {
      if (Number.isFinite(shader.bufferView)) {
        shader.code = textDecoder.decode(gltfScenegraph.getTypedArrayForBufferView(shader.bufferView));
      } else {
        throw new Error("KHR_techniques_webgl: no shader code");
      }
    });
    programs.forEach((program) => {
      program.fragmentShader = shaders[program.fragmentShader];
      program.vertexShader = shaders[program.vertexShader];
    });
    techniques.forEach((technique) => {
      technique.program = programs[technique.program];
    });
    return techniques;
  }
  function resolveValues(technique, gltfScenegraph) {
    const values = Object.assign({}, technique.values);
    Object.keys(technique.uniforms || {}).forEach((uniform) => {
      if (technique.uniforms[uniform].value && !(uniform in values)) {
        values[uniform] = technique.uniforms[uniform].value;
      }
    });
    Object.keys(values).forEach((uniform) => {
      if (typeof values[uniform] === "object" && values[uniform].index !== void 0) {
        values[uniform].texture = gltfScenegraph.getTexture(values[uniform].index);
      }
    });
    return values;
  }

  // ../../node_modules/@loaders.gl/gltf/dist/esm/lib/extensions/deprecated/EXT_feature_metadata.js
  var EXT_feature_metadata_exports = {};
  __export(EXT_feature_metadata_exports, {
    decode: () => decode8,
    name: () => name9
  });
  var EXT_FEATURE_METADATA = "EXT_feature_metadata";
  var name9 = EXT_FEATURE_METADATA;
  async function decode8(gltfData) {
    const scenegraph = new GLTFScenegraph(gltfData);
    decodeExtFeatureMetadata(scenegraph);
  }
  function decodeExtFeatureMetadata(scenegraph) {
    var _extension$schema;
    const extension = scenegraph.getExtension(EXT_FEATURE_METADATA);
    const schemaClasses = extension === null || extension === void 0 ? void 0 : (_extension$schema = extension.schema) === null || _extension$schema === void 0 ? void 0 : _extension$schema.classes;
    const featureTables = extension === null || extension === void 0 ? void 0 : extension.featureTables;
    const featureTextures = extension === null || extension === void 0 ? void 0 : extension.featureTextures;
    if (featureTextures) {
      console.warn('featureTextures is not yet supported in the "EXT_feature_metadata" extension.');
    }
    if (schemaClasses && featureTables) {
      for (const schemaName in schemaClasses) {
        const schemaClass = schemaClasses[schemaName];
        const featureTable = findFeatureTableByName(featureTables, schemaName);
        if (featureTable) {
          handleFeatureTableProperties(scenegraph, featureTable, schemaClass);
        }
      }
    }
  }
  function handleFeatureTableProperties(scenegraph, featureTable, schemaClass) {
    for (const propertyName in schemaClass.properties) {
      var _featureTable$propert;
      const schemaProperty = schemaClass.properties[propertyName];
      const featureTableProperty = featureTable === null || featureTable === void 0 ? void 0 : (_featureTable$propert = featureTable.properties) === null || _featureTable$propert === void 0 ? void 0 : _featureTable$propert[propertyName];
      const numberOfFeatures = featureTable.count;
      if (featureTableProperty) {
        const data = getPropertyDataFromBinarySource(scenegraph, schemaProperty, numberOfFeatures, featureTableProperty);
        featureTableProperty.data = data;
      }
    }
  }
  function getPropertyDataFromBinarySource(scenegraph, schemaProperty, numberOfFeatures, featureTableProperty) {
    const bufferView = featureTableProperty.bufferView;
    let data = scenegraph.getTypedArrayForBufferView(bufferView);
    switch (schemaProperty.type) {
      case "STRING": {
        const stringOffsetBufferView = featureTableProperty.stringOffsetBufferView;
        const offsetsData = scenegraph.getTypedArrayForBufferView(stringOffsetBufferView);
        data = getStringAttributes(data, offsetsData, numberOfFeatures);
        break;
      }
      default:
    }
    return data;
  }
  function findFeatureTableByName(featureTables, schemaClassName) {
    for (const featureTableName in featureTables) {
      const featureTable = featureTables[featureTableName];
      if (featureTable.class === schemaClassName) {
        return featureTable;
      }
    }
    return null;
  }
  function getStringAttributes(data, offsetsData, stringsCount) {
    const stringsArray = [];
    const textDecoder = new TextDecoder("utf8");
    let stringOffset = 0;
    const bytesPerStringSize = 4;
    for (let index = 0; index < stringsCount; index++) {
      const stringByteSize = offsetsData[(index + 1) * bytesPerStringSize] - offsetsData[index * bytesPerStringSize];
      const stringData = data.subarray(stringOffset, stringByteSize + stringOffset);
      const stringAttribute = textDecoder.decode(stringData);
      stringsArray.push(stringAttribute);
      stringOffset += stringByteSize;
    }
    return stringsArray;
  }

  // ../../node_modules/@loaders.gl/gltf/dist/esm/lib/api/gltf-extensions.js
  var EXTENSIONS2 = [
    EXT_meshopt_compression_exports,
    EXT_texture_webp_exports,
    KHR_texture_basisu_exports,
    KHR_draco_mesh_compression_exports,
    KHR_lights_punctual_exports,
    KHR_materials_unlit_exports,
    KHR_techniques_webgl_exports,
    KHR_texture_transform_exports,
    EXT_feature_metadata_exports
  ];
  function preprocessExtensions(gltf) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    let context = arguments.length > 2 ? arguments[2] : void 0;
    const extensions = EXTENSIONS2.filter((extension) => useExtension(extension.name, options));
    for (const extension of extensions) {
      var _extension$preprocess;
      (_extension$preprocess = extension.preprocess) === null || _extension$preprocess === void 0 ? void 0 : _extension$preprocess.call(extension, gltf, options, context);
    }
  }
  async function decodeExtensions(gltf) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    let context = arguments.length > 2 ? arguments[2] : void 0;
    const extensions = EXTENSIONS2.filter((extension) => useExtension(extension.name, options));
    for (const extension of extensions) {
      var _extension$decode;
      await ((_extension$decode = extension.decode) === null || _extension$decode === void 0 ? void 0 : _extension$decode.call(extension, gltf, options, context));
    }
  }
  function useExtension(extensionName, options) {
    var _options$gltf;
    const excludes = (options === null || options === void 0 ? void 0 : (_options$gltf = options.gltf) === null || _options$gltf === void 0 ? void 0 : _options$gltf.excludeExtensions) || {};
    const exclude = extensionName in excludes && !excludes[extensionName];
    return !exclude;
  }

  // ../../node_modules/@loaders.gl/gltf/dist/esm/lib/extensions/KHR_binary_gltf.js
  var KHR_BINARY_GLTF = "KHR_binary_glTF";
  function preprocess4(gltfData) {
    const gltfScenegraph = new GLTFScenegraph(gltfData);
    const {
      json
    } = gltfScenegraph;
    for (const image of json.images || []) {
      const extension = gltfScenegraph.getObjectExtension(image, KHR_BINARY_GLTF);
      if (extension) {
        Object.assign(image, extension);
      }
      gltfScenegraph.removeObjectExtension(image, KHR_BINARY_GLTF);
    }
    if (json.buffers && json.buffers[0]) {
      delete json.buffers[0].uri;
    }
    gltfScenegraph.removeExtension(KHR_BINARY_GLTF);
  }

  // ../../node_modules/@loaders.gl/gltf/dist/esm/lib/api/normalize-gltf-v1.js
  var GLTF_ARRAYS = {
    accessors: "accessor",
    animations: "animation",
    buffers: "buffer",
    bufferViews: "bufferView",
    images: "image",
    materials: "material",
    meshes: "mesh",
    nodes: "node",
    samplers: "sampler",
    scenes: "scene",
    skins: "skin",
    textures: "texture"
  };
  var GLTF_KEYS = {
    accessor: "accessors",
    animations: "animation",
    buffer: "buffers",
    bufferView: "bufferViews",
    image: "images",
    material: "materials",
    mesh: "meshes",
    node: "nodes",
    sampler: "samplers",
    scene: "scenes",
    skin: "skins",
    texture: "textures"
  };
  var GLTFV1Normalizer = class {
    constructor() {
      _defineProperty(this, "idToIndexMap", {
        animations: {},
        accessors: {},
        buffers: {},
        bufferViews: {},
        images: {},
        materials: {},
        meshes: {},
        nodes: {},
        samplers: {},
        scenes: {},
        skins: {},
        textures: {}
      });
      _defineProperty(this, "json", void 0);
    }
    normalize(gltf, options) {
      this.json = gltf.json;
      const json = gltf.json;
      switch (json.asset && json.asset.version) {
        case "2.0":
          return;
        case void 0:
        case "1.0":
          break;
        default:
          console.warn("glTF: Unknown version ".concat(json.asset.version));
          return;
      }
      if (!options.normalize) {
        throw new Error("glTF v1 is not supported.");
      }
      console.warn("Converting glTF v1 to glTF v2 format. This is experimental and may fail.");
      this._addAsset(json);
      this._convertTopLevelObjectsToArrays(json);
      preprocess4(gltf);
      this._convertObjectIdsToArrayIndices(json);
      this._updateObjects(json);
      this._updateMaterial(json);
    }
    _addAsset(json) {
      json.asset = json.asset || {};
      json.asset.version = "2.0";
      json.asset.generator = json.asset.generator || "Normalized to glTF 2.0 by loaders.gl";
    }
    _convertTopLevelObjectsToArrays(json) {
      for (const arrayName in GLTF_ARRAYS) {
        this._convertTopLevelObjectToArray(json, arrayName);
      }
    }
    _convertTopLevelObjectToArray(json, mapName) {
      const objectMap = json[mapName];
      if (!objectMap || Array.isArray(objectMap)) {
        return;
      }
      json[mapName] = [];
      for (const id in objectMap) {
        const object = objectMap[id];
        object.id = object.id || id;
        const index = json[mapName].length;
        json[mapName].push(object);
        this.idToIndexMap[mapName][id] = index;
      }
    }
    _convertObjectIdsToArrayIndices(json) {
      for (const arrayName in GLTF_ARRAYS) {
        this._convertIdsToIndices(json, arrayName);
      }
      if ("scene" in json) {
        json.scene = this._convertIdToIndex(json.scene, "scene");
      }
      for (const texture of json.textures) {
        this._convertTextureIds(texture);
      }
      for (const mesh of json.meshes) {
        this._convertMeshIds(mesh);
      }
      for (const node2 of json.nodes) {
        this._convertNodeIds(node2);
      }
      for (const node2 of json.scenes) {
        this._convertSceneIds(node2);
      }
    }
    _convertTextureIds(texture) {
      if (texture.source) {
        texture.source = this._convertIdToIndex(texture.source, "image");
      }
    }
    _convertMeshIds(mesh) {
      for (const primitive of mesh.primitives) {
        const {
          attributes,
          indices,
          material
        } = primitive;
        for (const attributeName in attributes) {
          attributes[attributeName] = this._convertIdToIndex(attributes[attributeName], "accessor");
        }
        if (indices) {
          primitive.indices = this._convertIdToIndex(indices, "accessor");
        }
        if (material) {
          primitive.material = this._convertIdToIndex(material, "material");
        }
      }
    }
    _convertNodeIds(node2) {
      if (node2.children) {
        node2.children = node2.children.map((child) => this._convertIdToIndex(child, "node"));
      }
      if (node2.meshes) {
        node2.meshes = node2.meshes.map((mesh) => this._convertIdToIndex(mesh, "mesh"));
      }
    }
    _convertSceneIds(scene) {
      if (scene.nodes) {
        scene.nodes = scene.nodes.map((node2) => this._convertIdToIndex(node2, "node"));
      }
    }
    _convertIdsToIndices(json, topLevelArrayName) {
      if (!json[topLevelArrayName]) {
        console.warn("gltf v1: json doesn't contain attribute ".concat(topLevelArrayName));
        json[topLevelArrayName] = [];
      }
      for (const object of json[topLevelArrayName]) {
        for (const key in object) {
          const id = object[key];
          const index = this._convertIdToIndex(id, key);
          object[key] = index;
        }
      }
    }
    _convertIdToIndex(id, key) {
      const arrayName = GLTF_KEYS[key];
      if (arrayName in this.idToIndexMap) {
        const index = this.idToIndexMap[arrayName][id];
        if (!Number.isFinite(index)) {
          throw new Error("gltf v1: failed to resolve ".concat(key, " with id ").concat(id));
        }
        return index;
      }
      return id;
    }
    _updateObjects(json) {
      for (const buffer of this.json.buffers) {
        delete buffer.type;
      }
    }
    _updateMaterial(json) {
      for (const material of json.materials) {
        var _material$values, _material$values2, _material$values3;
        material.pbrMetallicRoughness = {
          baseColorFactor: [1, 1, 1, 1],
          metallicFactor: 1,
          roughnessFactor: 1
        };
        const textureId = ((_material$values = material.values) === null || _material$values === void 0 ? void 0 : _material$values.tex) || ((_material$values2 = material.values) === null || _material$values2 === void 0 ? void 0 : _material$values2.texture2d_0) || ((_material$values3 = material.values) === null || _material$values3 === void 0 ? void 0 : _material$values3.diffuseTex);
        const textureIndex = json.textures.findIndex((texture) => texture.id === textureId);
        if (textureIndex !== -1) {
          material.pbrMetallicRoughness.baseColorTexture = {
            index: textureIndex
          };
        }
      }
    }
  };
  function normalizeGLTFV1(gltf) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return new GLTFV1Normalizer().normalize(gltf, options);
  }

  // ../../node_modules/@loaders.gl/gltf/dist/esm/lib/api/post-process-gltf.js
  var COMPONENTS2 = {
    SCALAR: 1,
    VEC2: 2,
    VEC3: 3,
    VEC4: 4,
    MAT2: 4,
    MAT3: 9,
    MAT4: 16
  };
  var BYTES2 = {
    5120: 1,
    5121: 1,
    5122: 2,
    5123: 2,
    5125: 4,
    5126: 4
  };
  var GL_SAMPLER = {
    TEXTURE_MAG_FILTER: 10240,
    TEXTURE_MIN_FILTER: 10241,
    TEXTURE_WRAP_S: 10242,
    TEXTURE_WRAP_T: 10243,
    REPEAT: 10497,
    LINEAR: 9729,
    NEAREST_MIPMAP_LINEAR: 9986
  };
  var SAMPLER_PARAMETER_GLTF_TO_GL = {
    magFilter: GL_SAMPLER.TEXTURE_MAG_FILTER,
    minFilter: GL_SAMPLER.TEXTURE_MIN_FILTER,
    wrapS: GL_SAMPLER.TEXTURE_WRAP_S,
    wrapT: GL_SAMPLER.TEXTURE_WRAP_T
  };
  var DEFAULT_SAMPLER = {
    [GL_SAMPLER.TEXTURE_MAG_FILTER]: GL_SAMPLER.LINEAR,
    [GL_SAMPLER.TEXTURE_MIN_FILTER]: GL_SAMPLER.NEAREST_MIPMAP_LINEAR,
    [GL_SAMPLER.TEXTURE_WRAP_S]: GL_SAMPLER.REPEAT,
    [GL_SAMPLER.TEXTURE_WRAP_T]: GL_SAMPLER.REPEAT
  };
  function getBytesFromComponentType(componentType) {
    return BYTES2[componentType];
  }
  function getSizeFromAccessorType(type) {
    return COMPONENTS2[type];
  }
  var GLTFPostProcessor = class {
    constructor() {
      _defineProperty(this, "baseUri", "");
      _defineProperty(this, "json", {});
      _defineProperty(this, "buffers", []);
      _defineProperty(this, "images", []);
    }
    postProcess(gltf) {
      let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      const {
        json,
        buffers = [],
        images = [],
        baseUri = ""
      } = gltf;
      assert11(json);
      this.baseUri = baseUri;
      this.json = json;
      this.buffers = buffers;
      this.images = images;
      this._resolveTree(this.json, options);
      return this.json;
    }
    _resolveTree(json) {
      let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (json.bufferViews) {
        json.bufferViews = json.bufferViews.map((bufView, i3) => this._resolveBufferView(bufView, i3));
      }
      if (json.images) {
        json.images = json.images.map((image, i3) => this._resolveImage(image, i3));
      }
      if (json.samplers) {
        json.samplers = json.samplers.map((sampler, i3) => this._resolveSampler(sampler, i3));
      }
      if (json.textures) {
        json.textures = json.textures.map((texture, i3) => this._resolveTexture(texture, i3));
      }
      if (json.accessors) {
        json.accessors = json.accessors.map((accessor, i3) => this._resolveAccessor(accessor, i3));
      }
      if (json.materials) {
        json.materials = json.materials.map((material, i3) => this._resolveMaterial(material, i3));
      }
      if (json.meshes) {
        json.meshes = json.meshes.map((mesh, i3) => this._resolveMesh(mesh, i3));
      }
      if (json.nodes) {
        json.nodes = json.nodes.map((node2, i3) => this._resolveNode(node2, i3));
      }
      if (json.skins) {
        json.skins = json.skins.map((skin, i3) => this._resolveSkin(skin, i3));
      }
      if (json.scenes) {
        json.scenes = json.scenes.map((scene, i3) => this._resolveScene(scene, i3));
      }
      if (json.scene !== void 0) {
        json.scene = json.scenes[this.json.scene];
      }
    }
    getScene(index) {
      return this._get("scenes", index);
    }
    getNode(index) {
      return this._get("nodes", index);
    }
    getSkin(index) {
      return this._get("skins", index);
    }
    getMesh(index) {
      return this._get("meshes", index);
    }
    getMaterial(index) {
      return this._get("materials", index);
    }
    getAccessor(index) {
      return this._get("accessors", index);
    }
    getCamera(index) {
      return null;
    }
    getTexture(index) {
      return this._get("textures", index);
    }
    getSampler(index) {
      return this._get("samplers", index);
    }
    getImage(index) {
      return this._get("images", index);
    }
    getBufferView(index) {
      return this._get("bufferViews", index);
    }
    getBuffer(index) {
      return this._get("buffers", index);
    }
    _get(array, index) {
      if (typeof index === "object") {
        return index;
      }
      const object = this.json[array] && this.json[array][index];
      if (!object) {
        console.warn("glTF file error: Could not find ".concat(array, "[").concat(index, "]"));
      }
      return object;
    }
    _resolveScene(scene, index) {
      scene.id = scene.id || "scene-".concat(index);
      scene.nodes = (scene.nodes || []).map((node2) => this.getNode(node2));
      return scene;
    }
    _resolveNode(node2, index) {
      node2.id = node2.id || "node-".concat(index);
      if (node2.children) {
        node2.children = node2.children.map((child) => this.getNode(child));
      }
      if (node2.mesh !== void 0) {
        node2.mesh = this.getMesh(node2.mesh);
      } else if (node2.meshes !== void 0 && node2.meshes.length) {
        node2.mesh = node2.meshes.reduce((accum, meshIndex) => {
          const mesh = this.getMesh(meshIndex);
          accum.id = mesh.id;
          accum.primitives = accum.primitives.concat(mesh.primitives);
          return accum;
        }, {
          primitives: []
        });
      }
      if (node2.camera !== void 0) {
        node2.camera = this.getCamera(node2.camera);
      }
      if (node2.skin !== void 0) {
        node2.skin = this.getSkin(node2.skin);
      }
      return node2;
    }
    _resolveSkin(skin, index) {
      skin.id = skin.id || "skin-".concat(index);
      skin.inverseBindMatrices = this.getAccessor(skin.inverseBindMatrices);
      return skin;
    }
    _resolveMesh(mesh, index) {
      mesh.id = mesh.id || "mesh-".concat(index);
      if (mesh.primitives) {
        mesh.primitives = mesh.primitives.map((primitive) => {
          primitive = {
            ...primitive
          };
          const attributes = primitive.attributes;
          primitive.attributes = {};
          for (const attribute in attributes) {
            primitive.attributes[attribute] = this.getAccessor(attributes[attribute]);
          }
          if (primitive.indices !== void 0) {
            primitive.indices = this.getAccessor(primitive.indices);
          }
          if (primitive.material !== void 0) {
            primitive.material = this.getMaterial(primitive.material);
          }
          return primitive;
        });
      }
      return mesh;
    }
    _resolveMaterial(material, index) {
      material.id = material.id || "material-".concat(index);
      if (material.normalTexture) {
        material.normalTexture = {
          ...material.normalTexture
        };
        material.normalTexture.texture = this.getTexture(material.normalTexture.index);
      }
      if (material.occlusionTexture) {
        material.occlustionTexture = {
          ...material.occlustionTexture
        };
        material.occlusionTexture.texture = this.getTexture(material.occlusionTexture.index);
      }
      if (material.emissiveTexture) {
        material.emmisiveTexture = {
          ...material.emmisiveTexture
        };
        material.emissiveTexture.texture = this.getTexture(material.emissiveTexture.index);
      }
      if (!material.emissiveFactor) {
        material.emissiveFactor = material.emmisiveTexture ? [1, 1, 1] : [0, 0, 0];
      }
      if (material.pbrMetallicRoughness) {
        material.pbrMetallicRoughness = {
          ...material.pbrMetallicRoughness
        };
        const mr = material.pbrMetallicRoughness;
        if (mr.baseColorTexture) {
          mr.baseColorTexture = {
            ...mr.baseColorTexture
          };
          mr.baseColorTexture.texture = this.getTexture(mr.baseColorTexture.index);
        }
        if (mr.metallicRoughnessTexture) {
          mr.metallicRoughnessTexture = {
            ...mr.metallicRoughnessTexture
          };
          mr.metallicRoughnessTexture.texture = this.getTexture(mr.metallicRoughnessTexture.index);
        }
      }
      return material;
    }
    _resolveAccessor(accessor, index) {
      accessor.id = accessor.id || "accessor-".concat(index);
      if (accessor.bufferView !== void 0) {
        accessor.bufferView = this.getBufferView(accessor.bufferView);
      }
      accessor.bytesPerComponent = getBytesFromComponentType(accessor.componentType);
      accessor.components = getSizeFromAccessorType(accessor.type);
      accessor.bytesPerElement = accessor.bytesPerComponent * accessor.components;
      if (accessor.bufferView) {
        const buffer = accessor.bufferView.buffer;
        const {
          ArrayType,
          byteLength
        } = getAccessorArrayTypeAndLength(accessor, accessor.bufferView);
        const byteOffset = (accessor.bufferView.byteOffset || 0) + (accessor.byteOffset || 0) + buffer.byteOffset;
        let cutBuffer = buffer.arrayBuffer.slice(byteOffset, byteOffset + byteLength);
        if (accessor.bufferView.byteStride) {
          cutBuffer = this._getValueFromInterleavedBuffer(buffer, byteOffset, accessor.bufferView.byteStride, accessor.bytesPerElement, accessor.count);
        }
        accessor.value = new ArrayType(cutBuffer);
      }
      return accessor;
    }
    _getValueFromInterleavedBuffer(buffer, byteOffset, byteStride, bytesPerElement, count) {
      const result = new Uint8Array(count * bytesPerElement);
      for (let i3 = 0; i3 < count; i3++) {
        const elementOffset = byteOffset + i3 * byteStride;
        result.set(new Uint8Array(buffer.arrayBuffer.slice(elementOffset, elementOffset + bytesPerElement)), i3 * bytesPerElement);
      }
      return result.buffer;
    }
    _resolveTexture(texture, index) {
      texture.id = texture.id || "texture-".concat(index);
      texture.sampler = "sampler" in texture ? this.getSampler(texture.sampler) : DEFAULT_SAMPLER;
      texture.source = this.getImage(texture.source);
      return texture;
    }
    _resolveSampler(sampler, index) {
      sampler.id = sampler.id || "sampler-".concat(index);
      sampler.parameters = {};
      for (const key in sampler) {
        const glEnum = this._enumSamplerParameter(key);
        if (glEnum !== void 0) {
          sampler.parameters[glEnum] = sampler[key];
        }
      }
      return sampler;
    }
    _enumSamplerParameter(key) {
      return SAMPLER_PARAMETER_GLTF_TO_GL[key];
    }
    _resolveImage(image, index) {
      image.id = image.id || "image-".concat(index);
      if (image.bufferView !== void 0) {
        image.bufferView = this.getBufferView(image.bufferView);
      }
      const preloadedImage = this.images[index];
      if (preloadedImage) {
        image.image = preloadedImage;
      }
      return image;
    }
    _resolveBufferView(bufferView, index) {
      const bufferIndex = bufferView.buffer;
      const result = {
        id: "bufferView-".concat(index),
        ...bufferView,
        buffer: this.buffers[bufferIndex]
      };
      const arrayBuffer = this.buffers[bufferIndex].arrayBuffer;
      let byteOffset = this.buffers[bufferIndex].byteOffset || 0;
      if ("byteOffset" in bufferView) {
        byteOffset += bufferView.byteOffset;
      }
      result.data = new Uint8Array(arrayBuffer, byteOffset, bufferView.byteLength);
      return result;
    }
    _resolveCamera(camera, index) {
      camera.id = camera.id || "camera-".concat(index);
      if (camera.perspective) {
      }
      if (camera.orthographic) {
      }
      return camera;
    }
  };
  function postProcessGLTF(gltf, options) {
    return new GLTFPostProcessor().postProcess(gltf, options);
  }

  // ../../node_modules/@loaders.gl/gltf/dist/esm/lib/parsers/parse-glb.js
  var MAGIC_glTF = 1735152710;
  var GLB_FILE_HEADER_SIZE = 12;
  var GLB_CHUNK_HEADER_SIZE = 8;
  var GLB_CHUNK_TYPE_JSON = 1313821514;
  var GLB_CHUNK_TYPE_BIN = 5130562;
  var GLB_CHUNK_TYPE_JSON_XVIZ_DEPRECATED = 0;
  var GLB_CHUNK_TYPE_BIX_XVIZ_DEPRECATED = 1;
  var GLB_V1_CONTENT_FORMAT_JSON = 0;
  var LE = true;
  function getMagicString3(dataView) {
    let byteOffset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    return "".concat(String.fromCharCode(dataView.getUint8(byteOffset + 0))).concat(String.fromCharCode(dataView.getUint8(byteOffset + 1))).concat(String.fromCharCode(dataView.getUint8(byteOffset + 2))).concat(String.fromCharCode(dataView.getUint8(byteOffset + 3)));
  }
  function isGLB(arrayBuffer) {
    let byteOffset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    const dataView = new DataView(arrayBuffer);
    const {
      magic = MAGIC_glTF
    } = options;
    const magic1 = dataView.getUint32(byteOffset, false);
    return magic1 === magic || magic1 === MAGIC_glTF;
  }
  function parseGLBSync(glb, arrayBuffer) {
    let byteOffset = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
    let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    const dataView = new DataView(arrayBuffer);
    const type = getMagicString3(dataView, byteOffset + 0);
    const version = dataView.getUint32(byteOffset + 4, LE);
    const byteLength = dataView.getUint32(byteOffset + 8, LE);
    Object.assign(glb, {
      header: {
        byteOffset,
        byteLength,
        hasBinChunk: false
      },
      type,
      version,
      json: {},
      binChunks: []
    });
    byteOffset += GLB_FILE_HEADER_SIZE;
    switch (glb.version) {
      case 1:
        return parseGLBV1(glb, dataView, byteOffset);
      case 2:
        return parseGLBV2(glb, dataView, byteOffset, options = {});
      default:
        throw new Error("Invalid GLB version ".concat(glb.version, ". Only supports v1 and v2."));
    }
  }
  function parseGLBV1(glb, dataView, byteOffset) {
    assert2(glb.header.byteLength > GLB_FILE_HEADER_SIZE + GLB_CHUNK_HEADER_SIZE);
    const contentLength = dataView.getUint32(byteOffset + 0, LE);
    const contentFormat = dataView.getUint32(byteOffset + 4, LE);
    byteOffset += GLB_CHUNK_HEADER_SIZE;
    assert2(contentFormat === GLB_V1_CONTENT_FORMAT_JSON);
    parseJSONChunk(glb, dataView, byteOffset, contentLength);
    byteOffset += contentLength;
    byteOffset += parseBINChunk(glb, dataView, byteOffset, glb.header.byteLength);
    return byteOffset;
  }
  function parseGLBV2(glb, dataView, byteOffset, options) {
    assert2(glb.header.byteLength > GLB_FILE_HEADER_SIZE + GLB_CHUNK_HEADER_SIZE);
    parseGLBChunksSync(glb, dataView, byteOffset, options);
    return byteOffset + glb.header.byteLength;
  }
  function parseGLBChunksSync(glb, dataView, byteOffset, options) {
    while (byteOffset + 8 <= glb.header.byteLength) {
      const chunkLength = dataView.getUint32(byteOffset + 0, LE);
      const chunkFormat = dataView.getUint32(byteOffset + 4, LE);
      byteOffset += GLB_CHUNK_HEADER_SIZE;
      switch (chunkFormat) {
        case GLB_CHUNK_TYPE_JSON:
          parseJSONChunk(glb, dataView, byteOffset, chunkLength);
          break;
        case GLB_CHUNK_TYPE_BIN:
          parseBINChunk(glb, dataView, byteOffset, chunkLength);
          break;
        case GLB_CHUNK_TYPE_JSON_XVIZ_DEPRECATED:
          if (!options.strict) {
            parseJSONChunk(glb, dataView, byteOffset, chunkLength);
          }
          break;
        case GLB_CHUNK_TYPE_BIX_XVIZ_DEPRECATED:
          if (!options.strict) {
            parseBINChunk(glb, dataView, byteOffset, chunkLength);
          }
          break;
        default:
          break;
      }
      byteOffset += padToNBytes(chunkLength, 4);
    }
    return byteOffset;
  }
  function parseJSONChunk(glb, dataView, byteOffset, chunkLength) {
    const jsonChunk = new Uint8Array(dataView.buffer, byteOffset, chunkLength);
    const textDecoder = new TextDecoder("utf8");
    const jsonText = textDecoder.decode(jsonChunk);
    glb.json = JSON.parse(jsonText);
    return padToNBytes(chunkLength, 4);
  }
  function parseBINChunk(glb, dataView, byteOffset, chunkLength) {
    glb.header.hasBinChunk = true;
    glb.binChunks.push({
      byteOffset,
      byteLength: chunkLength,
      arrayBuffer: dataView.buffer
    });
    return padToNBytes(chunkLength, 4);
  }

  // ../../node_modules/@loaders.gl/gltf/dist/esm/lib/parsers/parse-gltf.js
  async function parseGLTF(gltf, arrayBufferOrString) {
    var _options$gltf, _options$gltf2, _options$gltf3, _options$gltf4;
    let byteOffset = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
    let options = arguments.length > 3 ? arguments[3] : void 0;
    let context = arguments.length > 4 ? arguments[4] : void 0;
    parseGLTFContainerSync(gltf, arrayBufferOrString, byteOffset, options);
    normalizeGLTFV1(gltf, {
      normalize: options === null || options === void 0 ? void 0 : (_options$gltf = options.gltf) === null || _options$gltf === void 0 ? void 0 : _options$gltf.normalize
    });
    preprocessExtensions(gltf, options, context);
    const promises = [];
    if (options !== null && options !== void 0 && (_options$gltf2 = options.gltf) !== null && _options$gltf2 !== void 0 && _options$gltf2.loadBuffers && gltf.json.buffers) {
      await loadBuffers(gltf, options, context);
    }
    if (options !== null && options !== void 0 && (_options$gltf3 = options.gltf) !== null && _options$gltf3 !== void 0 && _options$gltf3.loadImages) {
      const promise2 = loadImages(gltf, options, context);
      promises.push(promise2);
    }
    const promise = decodeExtensions(gltf, options, context);
    promises.push(promise);
    await Promise.all(promises);
    return options !== null && options !== void 0 && (_options$gltf4 = options.gltf) !== null && _options$gltf4 !== void 0 && _options$gltf4.postProcess ? postProcessGLTF(gltf, options) : gltf;
  }
  function parseGLTFContainerSync(gltf, data, byteOffset, options) {
    if (options.uri) {
      gltf.baseUri = options.uri;
    }
    if (data instanceof ArrayBuffer && !isGLB(data, byteOffset, options)) {
      const textDecoder = new TextDecoder();
      data = textDecoder.decode(data);
    }
    if (typeof data === "string") {
      gltf.json = parseJSON(data);
    } else if (data instanceof ArrayBuffer) {
      const glb = {};
      byteOffset = parseGLBSync(glb, data, byteOffset, options.glb);
      assert11(glb.type === "glTF", "Invalid GLB magic string ".concat(glb.type));
      gltf._glb = glb;
      gltf.json = glb.json;
    } else {
      assert11(false, "GLTF: must be ArrayBuffer or string");
    }
    const buffers = gltf.json.buffers || [];
    gltf.buffers = new Array(buffers.length).fill(null);
    if (gltf._glb && gltf._glb.header.hasBinChunk) {
      const {
        binChunks
      } = gltf._glb;
      gltf.buffers[0] = {
        arrayBuffer: binChunks[0].arrayBuffer,
        byteOffset: binChunks[0].byteOffset,
        byteLength: binChunks[0].byteLength
      };
    }
    const images = gltf.json.images || [];
    gltf.images = new Array(images.length).fill({});
  }
  async function loadBuffers(gltf, options, context) {
    const buffers = gltf.json.buffers || [];
    for (let i3 = 0; i3 < buffers.length; ++i3) {
      const buffer = buffers[i3];
      if (buffer.uri) {
        var _context$fetch, _response$arrayBuffer;
        const {
          fetch: fetch2
        } = context;
        assert11(fetch2);
        const uri = resolveUrl(buffer.uri, options);
        const response = await (context === null || context === void 0 ? void 0 : (_context$fetch = context.fetch) === null || _context$fetch === void 0 ? void 0 : _context$fetch.call(context, uri));
        const arrayBuffer = await (response === null || response === void 0 ? void 0 : (_response$arrayBuffer = response.arrayBuffer) === null || _response$arrayBuffer === void 0 ? void 0 : _response$arrayBuffer.call(response));
        gltf.buffers[i3] = {
          arrayBuffer,
          byteOffset: 0,
          byteLength: arrayBuffer.byteLength
        };
        delete buffer.uri;
      } else if (gltf.buffers[i3] === null) {
        gltf.buffers[i3] = {
          arrayBuffer: new ArrayBuffer(buffer.byteLength),
          byteOffset: 0,
          byteLength: buffer.byteLength
        };
      }
    }
  }
  async function loadImages(gltf, options, context) {
    const imageIndices = getReferencesImageIndices(gltf);
    const images = gltf.json.images || [];
    const promises = [];
    for (const imageIndex of imageIndices) {
      promises.push(loadImage2(gltf, images[imageIndex], imageIndex, options, context));
    }
    return await Promise.all(promises);
  }
  function getReferencesImageIndices(gltf) {
    const imageIndices = /* @__PURE__ */ new Set();
    const textures = gltf.json.textures || [];
    for (const texture of textures) {
      if (texture.source !== void 0) {
        imageIndices.add(texture.source);
      }
    }
    return Array.from(imageIndices).sort();
  }
  async function loadImage2(gltf, image, index, options, context) {
    const {
      fetch: fetch2,
      parse: parse4
    } = context;
    let arrayBuffer;
    if (image.uri && !image.hasOwnProperty("bufferView")) {
      const uri = resolveUrl(image.uri, options);
      const response = await fetch2(uri);
      arrayBuffer = await response.arrayBuffer();
      image.bufferView = {
        data: arrayBuffer
      };
    }
    if (Number.isFinite(image.bufferView)) {
      const array = getTypedArrayForBufferView(gltf.json, gltf.buffers, image.bufferView);
      arrayBuffer = sliceArrayBuffer(array.buffer, array.byteOffset, array.byteLength);
    }
    assert11(arrayBuffer, "glTF image has no data");
    let parsedImage = await parse4(arrayBuffer, [ImageLoader, BasisLoader], {
      mimeType: image.mimeType,
      basis: options.basis || {
        format: selectSupportedBasisFormat()
      }
    }, context);
    if (parsedImage && parsedImage[0]) {
      parsedImage = {
        compressed: true,
        mipmaps: false,
        width: parsedImage[0].width,
        height: parsedImage[0].height,
        data: parsedImage[0]
      };
    }
    gltf.images = gltf.images || [];
    gltf.images[index] = parsedImage;
  }

  // ../../node_modules/@loaders.gl/gltf/dist/esm/gltf-loader.js
  var GLTFLoader = {
    name: "glTF",
    id: "gltf",
    module: "gltf",
    version: VERSION10,
    extensions: ["gltf", "glb"],
    mimeTypes: ["model/gltf+json", "model/gltf-binary"],
    text: true,
    binary: true,
    tests: ["glTF"],
    parse: parse2,
    options: {
      gltf: {
        normalize: true,
        loadBuffers: true,
        loadImages: true,
        decompressMeshes: true,
        postProcess: true
      },
      log: console
    },
    deprecatedOptions: {
      fetchImages: "gltf.loadImages",
      createImages: "gltf.loadImages",
      decompress: "gltf.decompressMeshes",
      postProcess: "gltf.postProcess",
      gltf: {
        decompress: "gltf.decompressMeshes"
      }
    }
  };
  async function parse2(arrayBuffer) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    let context = arguments.length > 2 ? arguments[2] : void 0;
    options = {
      ...GLTFLoader.options,
      ...options
    };
    options.gltf = {
      ...GLTFLoader.options.gltf,
      ...options.gltf
    };
    const {
      byteOffset = 0
    } = options;
    const gltf = {};
    return await parseGLTF(gltf, arrayBuffer, byteOffset, options, context);
  }

  // ../../node_modules/@loaders.gl/3d-tiles/dist/esm/lib/parsers/helpers/parse-3d-tile-gltf-view.js
  var GLTF_FORMAT = {
    URI: 0,
    EMBEDDED: 1
  };
  function parse3DTileGLTFViewSync(tile, arrayBuffer, byteOffset, options) {
    tile.rotateYtoZ = true;
    const gltfByteLength = tile.byteOffset + tile.byteLength - byteOffset;
    if (gltfByteLength === 0) {
      throw new Error("glTF byte length must be greater than 0.");
    }
    tile.gltfUpAxis = options["3d-tiles"] && options["3d-tiles"].assetGltfUpAxis ? options["3d-tiles"].assetGltfUpAxis : "Y";
    tile.gltfArrayBuffer = sliceArrayBuffer(arrayBuffer, byteOffset, gltfByteLength);
    tile.gltfByteOffset = 0;
    tile.gltfByteLength = gltfByteLength;
    if (byteOffset % 4 === 0) {
    } else {
      console.warn("".concat(tile.type, ": embedded glb is not aligned to a 4-byte boundary."));
    }
    return tile.byteOffset + tile.byteLength;
  }
  async function extractGLTF(tile, gltfFormat, options, context) {
    const tile3DOptions = options["3d-tiles"] || {};
    extractGLTFBufferOrURL(tile, gltfFormat, options);
    if (tile3DOptions.loadGLTF) {
      const {
        parse: parse4,
        fetch: fetch2
      } = context;
      if (tile.gltfUrl) {
        tile.gltfArrayBuffer = await fetch2(tile.gltfUrl, options);
        tile.gltfByteOffset = 0;
      }
      if (tile.gltfArrayBuffer) {
        tile.gltf = await parse4(tile.gltfArrayBuffer, GLTFLoader, options, context);
        delete tile.gltfArrayBuffer;
        delete tile.gltfByteOffset;
        delete tile.gltfByteLength;
      }
    }
  }
  function extractGLTFBufferOrURL(tile, gltfFormat, options) {
    switch (gltfFormat) {
      case GLTF_FORMAT.URI:
        const gltfUrlBytes = new Uint8Array(tile.gltfArrayBuffer, tile.gltfByteOffset);
        const textDecoder = new TextDecoder();
        const gltfUrl = textDecoder.decode(gltfUrlBytes);
        tile.gltfUrl = gltfUrl.replace(/[\s\0]+$/, "");
        delete tile.gltfArrayBuffer;
        delete tile.gltfByteOffset;
        delete tile.gltfByteLength;
        break;
      case GLTF_FORMAT.EMBEDDED:
        break;
      default:
        throw new Error("b3dm: Illegal glTF format field");
    }
  }

  // ../../node_modules/@loaders.gl/3d-tiles/dist/esm/lib/parsers/parse-3d-tile-batched-model.js
  async function parseBatchedModel3DTile(tile, arrayBuffer, byteOffset, options, context) {
    var _tile$gltf;
    byteOffset = parseBatchedModel(tile, arrayBuffer, byteOffset, options, context);
    await extractGLTF(tile, GLTF_FORMAT.EMBEDDED, options, context);
    const extensions = tile === null || tile === void 0 ? void 0 : (_tile$gltf = tile.gltf) === null || _tile$gltf === void 0 ? void 0 : _tile$gltf.extensions;
    if (extensions && extensions.CESIUM_RTC) {
      tile.rtcCenter = extensions.CESIUM_RTC.center;
    }
    return byteOffset;
  }
  function parseBatchedModel(tile, arrayBuffer, byteOffset, options, context) {
    byteOffset = parse3DTileHeaderSync(tile, arrayBuffer, byteOffset);
    byteOffset = parse3DTileTablesHeaderSync(tile, arrayBuffer, byteOffset);
    byteOffset = parse3DTileTablesSync(tile, arrayBuffer, byteOffset, options);
    byteOffset = parse3DTileGLTFViewSync(tile, arrayBuffer, byteOffset, options);
    const featureTable = new Tile3DFeatureTable(tile.featureTableJson, tile.featureTableBinary);
    tile.rtcCenter = featureTable.getGlobalProperty("RTC_CENTER", GL2.FLOAT, 3);
    return byteOffset;
  }

  // ../../node_modules/@loaders.gl/3d-tiles/dist/esm/lib/parsers/parse-3d-tile-instanced-model.js
  async function parseInstancedModel3DTile(tile, arrayBuffer, byteOffset, options, context) {
    byteOffset = parseInstancedModel(tile, arrayBuffer, byteOffset, options, context);
    await extractGLTF(tile, tile.gltfFormat, options, context);
    return byteOffset;
  }
  function parseInstancedModel(tile, arrayBuffer, byteOffset, options, context) {
    byteOffset = parse3DTileHeaderSync(tile, arrayBuffer, byteOffset);
    if (tile.version !== 1) {
      throw new Error("Instanced 3D Model version ".concat(tile.version, " is not supported"));
    }
    byteOffset = parse3DTileTablesHeaderSync(tile, arrayBuffer, byteOffset);
    const view = new DataView(arrayBuffer);
    tile.gltfFormat = view.getUint32(byteOffset, true);
    byteOffset += 4;
    byteOffset = parse3DTileTablesSync(tile, arrayBuffer, byteOffset, options);
    byteOffset = parse3DTileGLTFViewSync(tile, arrayBuffer, byteOffset, options);
    if (tile.featureTableJsonByteLength === 0) {
      throw new Error("i3dm parser: featureTableJsonByteLength is zero.");
    }
    const featureTable = new Tile3DFeatureTable(tile.featureTableJson, tile.featureTableBinary);
    const instancesLength = featureTable.getGlobalProperty("INSTANCES_LENGTH");
    featureTable.featuresLength = instancesLength;
    if (!Number.isFinite(instancesLength)) {
      throw new Error("i3dm parser: INSTANCES_LENGTH must be defined");
    }
    tile.eastNorthUp = featureTable.getGlobalProperty("EAST_NORTH_UP");
    tile.rtcCenter = featureTable.getGlobalProperty("RTC_CENTER", GL2.FLOAT, 3);
    const batchTable = new Tile3DBatchTableParser(tile.batchTableJson, tile.batchTableBinary, instancesLength);
    extractInstancedAttributes(tile, featureTable, batchTable, instancesLength);
    return byteOffset;
  }
  function extractInstancedAttributes(tile, featureTable, batchTable, instancesLength) {
    const collectionOptions = {
      instances: new Array(instancesLength),
      batchTable: tile._batchTable,
      cull: false,
      url: void 0,
      gltf: void 0,
      basePath: void 0,
      incrementallyLoadTextures: false,
      forwardAxis: [1, 0, 0]
    };
    const instances = collectionOptions.instances;
    const instancePosition = new Vector3();
    const instanceNormalRight = new Vector3();
    const instanceNormalUp = new Vector3();
    const instanceNormalForward = new Vector3();
    const instanceRotation = new Matrix3();
    const instanceQuaternion = new Quaternion();
    const instanceScale = new Vector3();
    const instanceTranslationRotationScale = {};
    const instanceTransform = new Matrix4();
    const scratch1 = [];
    const scratch2 = [];
    const scratchVector14 = new Vector3();
    const scratchVector26 = new Vector3();
    for (let i3 = 0; i3 < instancesLength; i3++) {
      let position;
      if (featureTable.hasProperty("POSITION")) {
        position = featureTable.getProperty("POSITION", GL2.FLOAT, 3, i3, instancePosition);
      } else if (featureTable.hasProperty("POSITION_QUANTIZED")) {
        position = featureTable.getProperty("POSITION_QUANTIZED", GL2.UNSIGNED_SHORT, 3, i3, instancePosition);
        const quantizedVolumeOffset = featureTable.getGlobalProperty("QUANTIZED_VOLUME_OFFSET", GL2.FLOAT, 3, scratchVector14);
        if (!quantizedVolumeOffset) {
          throw new Error("i3dm parser: QUANTIZED_VOLUME_OFFSET must be defined for quantized positions.");
        }
        const quantizedVolumeScale = featureTable.getGlobalProperty("QUANTIZED_VOLUME_SCALE", GL2.FLOAT, 3, scratchVector26);
        if (!quantizedVolumeScale) {
          throw new Error("i3dm parser: QUANTIZED_VOLUME_SCALE must be defined for quantized positions.");
        }
        const MAX_UNSIGNED_SHORT = 65535;
        for (let j = 0; j < 3; j++) {
          position[j] = position[j] / MAX_UNSIGNED_SHORT * quantizedVolumeScale[j] + quantizedVolumeOffset[j];
        }
      }
      if (!position) {
        throw new Error("i3dm: POSITION or POSITION_QUANTIZED must be defined for each instance.");
      }
      instancePosition.copy(position);
      instanceTranslationRotationScale.translation = instancePosition;
      tile.normalUp = featureTable.getProperty("NORMAL_UP", GL2.FLOAT, 3, i3, scratch1);
      tile.normalRight = featureTable.getProperty("NORMAL_RIGHT", GL2.FLOAT, 3, i3, scratch2);
      const hasCustomOrientation = false;
      if (tile.normalUp) {
        if (!tile.normalRight) {
          throw new Error("i3dm: Custom orientation requires both NORMAL_UP and NORMAL_RIGHT.");
        }
        tile.hasCustomOrientation = true;
      } else {
        tile.octNormalUp = featureTable.getProperty("NORMAL_UP_OCT32P", GL2.UNSIGNED_SHORT, 2, scratch1);
        tile.octNormalRight = featureTable.getProperty("NORMAL_RIGHT_OCT32P", GL2.UNSIGNED_SHORT, 2, scratch2);
        if (tile.octNormalUp) {
          if (!tile.octNormalRight) {
            throw new Error("i3dm: oct-encoded orientation requires NORMAL_UP_OCT32P and NORMAL_RIGHT_OCT32P");
          }
          throw new Error("i3dm: oct-encoded orientation not implemented");
        } else if (tile.eastNorthUp) {
          Ellipsoid.WGS84.eastNorthUpToFixedFrame(instancePosition, instanceTransform);
          instanceTransform.getRotationMatrix3(instanceRotation);
        } else {
          instanceRotation.identity();
        }
      }
      if (hasCustomOrientation) {
        instanceNormalForward.copy(instanceNormalRight).cross(instanceNormalUp).normalize();
        instanceRotation.setColumn(0, instanceNormalRight);
        instanceRotation.setColumn(1, instanceNormalUp);
        instanceRotation.setColumn(2, instanceNormalForward);
      }
      instanceQuaternion.fromMatrix3(instanceRotation);
      instanceTranslationRotationScale.rotation = instanceQuaternion;
      instanceScale.set(1, 1, 1);
      const scale5 = featureTable.getProperty("SCALE", GL2.FLOAT, 1, i3);
      if (Number.isFinite(scale5)) {
        instanceScale.multiplyByScalar(scale5);
      }
      const nonUniformScale = featureTable.getProperty("SCALE_NON_UNIFORM", GL2.FLOAT, 3, i3, scratch1);
      if (nonUniformScale) {
        instanceScale.scale(nonUniformScale);
      }
      instanceTranslationRotationScale.scale = instanceScale;
      let batchId = featureTable.getProperty("BATCH_ID", GL2.UNSIGNED_SHORT, 1, i3);
      if (batchId === void 0) {
        batchId = i3;
      }
      const rotationMatrix = new Matrix4().fromQuaternion(instanceTranslationRotationScale.rotation);
      instanceTransform.identity();
      instanceTransform.translate(instanceTranslationRotationScale.translation);
      instanceTransform.multiplyRight(rotationMatrix);
      instanceTransform.scale(instanceTranslationRotationScale.scale);
      const modelMatrix = instanceTransform.clone();
      instances[i3] = {
        modelMatrix,
        batchId
      };
    }
    tile.instances = instances;
  }

  // ../../node_modules/@loaders.gl/3d-tiles/dist/esm/lib/parsers/parse-3d-tile-composite.js
  async function parseComposite3DTile(tile, arrayBuffer, byteOffset, options, context, parse3DTile2) {
    byteOffset = parse3DTileHeaderSync(tile, arrayBuffer, byteOffset);
    const view = new DataView(arrayBuffer);
    tile.tilesLength = view.getUint32(byteOffset, true);
    byteOffset += 4;
    tile.tiles = [];
    while (tile.tiles.length < tile.tilesLength && tile.byteLength - byteOffset > 12) {
      const subtile = {};
      tile.tiles.push(subtile);
      byteOffset = await parse3DTile2(arrayBuffer, byteOffset, options, context, subtile);
    }
    return byteOffset;
  }

  // ../../node_modules/@loaders.gl/3d-tiles/dist/esm/lib/parsers/parse-3d-tile-gltf.js
  async function parseGltf3DTile(tile, arrayBuffer, options, context) {
    tile.rotateYtoZ = true;
    tile.gltfUpAxis = options["3d-tiles"] && options["3d-tiles"].assetGltfUpAxis ? options["3d-tiles"].assetGltfUpAxis : "Y";
    const {
      parse: parse4
    } = context;
    tile.gltf = await parse4(arrayBuffer, GLTFLoader, options, context);
  }

  // ../../node_modules/@loaders.gl/3d-tiles/dist/esm/lib/parsers/parse-3d-tile.js
  async function parse3DTile(arrayBuffer) {
    let byteOffset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    let options = arguments.length > 2 ? arguments[2] : void 0;
    let context = arguments.length > 3 ? arguments[3] : void 0;
    let tile = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {};
    tile.byteOffset = byteOffset;
    tile.type = getMagicString2(arrayBuffer, byteOffset);
    switch (tile.type) {
      case TILE3D_TYPE.COMPOSITE:
        return await parseComposite3DTile(tile, arrayBuffer, byteOffset, options, context, parse3DTile);
      case TILE3D_TYPE.BATCHED_3D_MODEL:
        return await parseBatchedModel3DTile(tile, arrayBuffer, byteOffset, options, context);
      case TILE3D_TYPE.GLTF:
        return await parseGltf3DTile(tile, arrayBuffer, options, context);
      case TILE3D_TYPE.INSTANCED_3D_MODEL:
        return await parseInstancedModel3DTile(tile, arrayBuffer, byteOffset, options, context);
      case TILE3D_TYPE.POINT_CLOUD:
        return await parsePointCloud3DTile(tile, arrayBuffer, byteOffset, options, context);
      default:
        throw new Error("3DTileLoader: unknown type ".concat(tile.type));
    }
  }

  // ../../node_modules/@loaders.gl/3d-tiles/dist/esm/lib/parsers/helpers/parse-3d-tile-subtree.js
  var SUBTREE_FILE_MAGIC = 1952609651;
  var SUBTREE_FILE_VERSION = 1;
  async function parse3DTilesSubtree(data, options, context) {
    const magic = new Uint32Array(data.slice(0, 4));
    if (magic[0] !== SUBTREE_FILE_MAGIC) {
      throw new Error("Wrong subtree file magic number");
    }
    const version = new Uint32Array(data.slice(4, 8));
    if (version[0] !== SUBTREE_FILE_VERSION) {
      throw new Error("Wrong subtree file verson, must be 1");
    }
    const jsonByteLength = parseUint64Value(data.slice(8, 16));
    const stringAttribute = new Uint8Array(data, 24, jsonByteLength);
    const textDecoder = new TextDecoder("utf8");
    const string = textDecoder.decode(stringAttribute);
    const subtree = JSON.parse(string);
    const binaryByteLength = parseUint64Value(data.slice(16, 24));
    let internalBinaryBuffer = new ArrayBuffer(0);
    if (binaryByteLength) {
      internalBinaryBuffer = data.slice(24 + jsonByteLength);
    }
    if ("bufferView" in subtree.tileAvailability) {
      subtree.tileAvailability.explicitBitstream = await getExplicitBitstream(subtree, "tileAvailability", internalBinaryBuffer, context);
    }
    if ("bufferView" in subtree.contentAvailability) {
      subtree.contentAvailability.explicitBitstream = await getExplicitBitstream(subtree, "contentAvailability", internalBinaryBuffer, context);
    }
    if ("bufferView" in subtree.childSubtreeAvailability) {
      subtree.childSubtreeAvailability.explicitBitstream = await getExplicitBitstream(subtree, "childSubtreeAvailability", internalBinaryBuffer, context);
    }
    return subtree;
  }
  function resolveBufferUri(bitstreamRelativeUri, basePath) {
    const hasProtocol = basePath.startsWith("http");
    if (hasProtocol) {
      const resolvedUri2 = new URL(bitstreamRelativeUri, basePath);
      return decodeURI(resolvedUri2.toString());
    }
    const basePathWithProtocol = "http://".concat(basePath);
    const resolvedUri = new URL(bitstreamRelativeUri, basePathWithProtocol);
    return "/".concat(resolvedUri.host).concat(resolvedUri.pathname);
  }
  async function getExplicitBitstream(subtree, name10, internalBinaryBuffer, context) {
    const bufferViewIndex = subtree[name10].bufferView;
    const bufferView = subtree.bufferViews[bufferViewIndex];
    const buffer = subtree.buffers[bufferView.buffer];
    if (!(context !== null && context !== void 0 && context.url) || !context.fetch) {
      throw new Error("Url is not provided");
    }
    if (!context.fetch) {
      throw new Error("fetch is not provided");
    }
    if (buffer.uri) {
      const bufferUri = resolveBufferUri(buffer.uri, context === null || context === void 0 ? void 0 : context.url);
      const response = await context.fetch(bufferUri);
      const data = await response.arrayBuffer();
      return new Uint8Array(data, bufferView.byteOffset, bufferView.byteLength);
    }
    return new Uint8Array(internalBinaryBuffer, bufferView.byteOffset, bufferView.byteLength);
  }
  function parseUint64Value(buffer) {
    const dataView = new DataView(buffer);
    const left = dataView.getUint32(0, true);
    const right = dataView.getUint32(4, true);
    return left + 2 ** 32 * right;
  }

  // ../../node_modules/@loaders.gl/3d-tiles/dist/esm/tile-3d-subtree-loader.js
  var Tile3DSubtreeLoader = {
    id: "3d-tiles-subtree",
    name: "3D Tiles Subtree",
    module: "3d-tiles",
    version: VERSION8,
    extensions: ["subtree"],
    mimeTypes: ["application/octet-stream"],
    tests: ["subtree"],
    parse: parse3DTilesSubtree,
    options: {}
  };

  // ../../node_modules/@loaders.gl/3d-tiles/dist/esm/lib/parsers/parse-3d-tile-header.js
  var import_core40 = __toESM(require_core3());

  // ../../node_modules/@loaders.gl/3d-tiles/dist/esm/lib/parsers/helpers/parse-3d-implicit-tiles.js
  var import_core39 = __toESM(require_core3());
  var QUADTREE_DEVISION_COUNT = 4;
  var OCTREE_DEVISION_COUNT = 8;
  var SUBDIVISION_COUNT_MAP = {
    QUADTREE: QUADTREE_DEVISION_COUNT,
    OCTREE: OCTREE_DEVISION_COUNT
  };
  async function parseImplicitTiles(params) {
    const {
      options,
      parentData = {
        mortonIndex: 0,
        x: 0,
        y: 0,
        z: 0
      },
      childIndex = 0,
      globalData = {
        level: 0,
        mortonIndex: 0,
        x: 0,
        y: 0,
        z: 0
      }
    } = params;
    let {
      subtree,
      level = 0
    } = params;
    const {
      subdivisionScheme,
      subtreeLevels,
      maximumLevel,
      contentUrlTemplate,
      subtreesUriTemplate,
      basePath
    } = options;
    const tile = {
      children: [],
      lodMetricValue: 0,
      contentUrl: ""
    };
    const childrenPerTile = SUBDIVISION_COUNT_MAP[subdivisionScheme];
    const childX = childIndex & 1;
    const childY = childIndex >> 1 & 1;
    const childZ = childIndex >> 2 & 1;
    const levelOffset = (childrenPerTile ** level - 1) / (childrenPerTile - 1);
    let childTileMortonIndex = concatBits(parentData.mortonIndex, childIndex);
    let tileAvailabilityIndex = levelOffset + childTileMortonIndex;
    let childTileX = concatBits(parentData.x, childX);
    let childTileY = concatBits(parentData.y, childY);
    let childTileZ = concatBits(parentData.z, childZ);
    let isChildSubtreeAvailable = false;
    if (level + 1 > subtreeLevels) {
      isChildSubtreeAvailable = getAvailabilityResult(subtree.childSubtreeAvailability, childTileMortonIndex);
    }
    const x2 = concatBits(globalData.x, childTileX);
    const y2 = concatBits(globalData.y, childTileY);
    const z = concatBits(globalData.z, childTileZ);
    const lev = level + globalData.level;
    if (isChildSubtreeAvailable) {
      const subtreePath = "".concat(basePath, "/").concat(subtreesUriTemplate);
      const childSubtreeUrl = replaceContentUrlTemplate(subtreePath, lev, x2, y2, z);
      const childSubtree = await (0, import_core39.load)(childSubtreeUrl, Tile3DSubtreeLoader);
      subtree = childSubtree;
      globalData.mortonIndex = childTileMortonIndex;
      globalData.x = childTileX;
      globalData.y = childTileY;
      globalData.z = childTileZ;
      globalData.level = level;
      childTileMortonIndex = 0;
      tileAvailabilityIndex = 0;
      childTileX = 0;
      childTileY = 0;
      childTileZ = 0;
      level = 0;
    }
    const isTileAvailable = getAvailabilityResult(subtree.tileAvailability, tileAvailabilityIndex);
    if (!isTileAvailable || level > maximumLevel) {
      return tile;
    }
    const isContentAvailable = getAvailabilityResult(subtree.contentAvailability, tileAvailabilityIndex);
    if (isContentAvailable) {
      tile.contentUrl = replaceContentUrlTemplate(contentUrlTemplate, lev, x2, y2, z);
    }
    const childTileLevel = level + 1;
    const pData = {
      mortonIndex: childTileMortonIndex,
      x: childTileX,
      y: childTileY,
      z: childTileZ
    };
    for (let index = 0; index < childrenPerTile; index++) {
      const currentTile = await parseImplicitTiles({
        subtree,
        options,
        parentData: pData,
        childIndex: index,
        level: childTileLevel,
        globalData
      });
      if (currentTile.contentUrl || currentTile.children.length) {
        const globalLevel = lev + 1;
        const childCoordinates = {
          childTileX,
          childTileY,
          childTileZ
        };
        const formattedTile = formatTileData(currentTile, globalLevel, childCoordinates, options);
        tile.children.push(formattedTile);
      }
    }
    return tile;
  }
  function getAvailabilityResult(availabilityData, index) {
    if ("constant" in availabilityData) {
      return Boolean(availabilityData.constant);
    }
    if (availabilityData.explicitBitstream) {
      return getBooleanValueFromBitstream(index, availabilityData.explicitBitstream);
    }
    return false;
  }
  function formatTileData(tile, level, childCoordinates, options) {
    const {
      basePath,
      refine,
      getRefine: getRefine2,
      lodMetricType,
      getTileType: getTileType2,
      rootLodMetricValue,
      rootBoundingVolume
    } = options;
    const uri = tile.contentUrl && tile.contentUrl.replace("".concat(basePath, "/"), "");
    const lodMetricValue = rootLodMetricValue / 2 ** level;
    const boundingVolume = calculateBoundingVolumeForChildTile(level, rootBoundingVolume, childCoordinates);
    return {
      children: tile.children,
      contentUrl: tile.contentUrl,
      content: {
        uri
      },
      id: tile.contentUrl,
      refine: getRefine2(refine),
      type: getTileType2(tile),
      lodMetricType,
      lodMetricValue,
      geometricError: lodMetricValue,
      transform: tile.transform,
      boundingVolume
    };
  }
  function calculateBoundingVolumeForChildTile(level, rootBoundingVolume, childCoordinates) {
    if (rootBoundingVolume.region) {
      const {
        childTileX,
        childTileY,
        childTileZ
      } = childCoordinates;
      const [west, south, east, north, minimumHeight, maximumHeight] = rootBoundingVolume.region;
      const boundingVolumesCount = 2 ** level;
      const sizeX = (east - west) / boundingVolumesCount;
      const sizeY = (north - south) / boundingVolumesCount;
      const sizeZ = (maximumHeight - minimumHeight) / boundingVolumesCount;
      const [childWest, childEast] = [west + sizeX * childTileX, west + sizeX * (childTileX + 1)];
      const [childSouth, childNorth] = [south + sizeY * childTileY, south + sizeY * (childTileY + 1)];
      const [childMinimumHeight, childMaximumHeight] = [minimumHeight + sizeZ * childTileZ, minimumHeight + sizeZ * (childTileZ + 1)];
      return {
        region: [childWest, childSouth, childEast, childNorth, childMinimumHeight, childMaximumHeight]
      };
    }
    console.warn("Unsupported bounding volume type: ", rootBoundingVolume);
    return null;
  }
  function concatBits(first, second) {
    return parseInt(first.toString(2) + second.toString(2), 2);
  }
  function replaceContentUrlTemplate(templateUrl, level, x2, y2, z) {
    const mapUrl = generateMapUrl({
      level,
      x: x2,
      y: y2,
      z
    });
    return templateUrl.replace(/{level}|{x}|{y}|{z}/gi, (matched) => mapUrl[matched]);
  }
  function generateMapUrl(items) {
    const mapUrl = {};
    for (const key in items) {
      mapUrl["{".concat(key, "}")] = items[key];
    }
    return mapUrl;
  }
  function getBooleanValueFromBitstream(availabilityIndex, availabilityBuffer) {
    const byteIndex = Math.floor(availabilityIndex / 8);
    const bitIndex = availabilityIndex % 8;
    const bitValue = availabilityBuffer[byteIndex] >> bitIndex & 1;
    return bitValue === 1;
  }

  // ../../node_modules/@loaders.gl/3d-tiles/dist/esm/lib/parsers/parse-3d-tile-header.js
  function getTileType(tile) {
    if (!tile.contentUrl) {
      return TILE_TYPE.EMPTY;
    }
    const contentUrl = tile.contentUrl;
    const fileExtension = contentUrl.split(".").pop();
    switch (fileExtension) {
      case "pnts":
        return TILE_TYPE.POINTCLOUD;
      case "i3dm":
      case "b3dm":
      case "glb":
      case "gltf":
        return TILE_TYPE.SCENEGRAPH;
      default:
        return fileExtension;
    }
  }
  function getRefine(refine) {
    switch (refine) {
      case "REPLACE":
      case "replace":
        return TILE_REFINEMENT.REPLACE;
      case "ADD":
      case "add":
        return TILE_REFINEMENT.ADD;
      default:
        return refine;
    }
  }
  function resolveUri(uri, basePath) {
    const urlSchemeRegex = /^[a-z][0-9a-z+.-]*:/i;
    if (urlSchemeRegex.test(basePath)) {
      const url = new URL(uri, "".concat(basePath, "/"));
      return decodeURI(url.toString());
    } else if (uri.startsWith("/")) {
      return uri;
    }
    return "".concat(basePath, "/").concat(uri);
  }
  function normalizeTileData(tile, options) {
    if (!tile) {
      return null;
    }
    if (tile.content) {
      const contentUri = tile.content.uri || tile.content.url;
      tile.contentUrl = resolveUri(contentUri, options.basePath);
    }
    tile.id = tile.contentUrl;
    tile.lodMetricType = LOD_METRIC_TYPE.GEOMETRIC_ERROR;
    tile.lodMetricValue = tile.geometricError;
    tile.transformMatrix = tile.transform;
    tile.type = getTileType(tile);
    tile.refine = getRefine(tile.refine);
    return tile;
  }
  async function normalizeTileHeaders(tileset, options) {
    const basePath = tileset.basePath;
    let root;
    const rootImplicitTilingExtension = getImplicitTilingExtensionData(tileset === null || tileset === void 0 ? void 0 : tileset.root);
    if (rootImplicitTilingExtension && tileset.root) {
      root = await normalizeImplicitTileHeaders(tileset.root, tileset, rootImplicitTilingExtension, options);
    } else {
      root = normalizeTileData(tileset.root, tileset);
    }
    const stack2 = [];
    stack2.push(root);
    while (stack2.length > 0) {
      const tile = stack2.pop() || {};
      const children = tile.children || [];
      for (let childHeader of children) {
        const childImplicitTilingExtension = getImplicitTilingExtensionData(childHeader);
        if (childImplicitTilingExtension) {
          childHeader = await normalizeImplicitTileHeaders(childHeader, tileset, childImplicitTilingExtension, options);
        } else {
          normalizeTileData(childHeader, {
            basePath
          });
        }
        stack2.push(childHeader);
      }
    }
    return root;
  }
  async function normalizeImplicitTileHeaders(tile, tileset, implicitTilingExtension, options) {
    var _tileset$root;
    const basePath = tileset.basePath;
    const {
      subdivisionScheme,
      maximumLevel,
      subtreeLevels,
      subtrees: {
        uri: subtreesUriTemplate
      }
    } = implicitTilingExtension;
    const replacedUrlTemplate = replaceContentUrlTemplate(subtreesUriTemplate, 0, 0, 0, 0);
    const subtreeUrl = resolveUri(replacedUrlTemplate, basePath);
    const subtree = await (0, import_core40.load)(subtreeUrl, Tile3DSubtreeLoader, options);
    const contentUrlTemplate = resolveUri(tile.content.uri, basePath);
    const refine = tileset === null || tileset === void 0 ? void 0 : (_tileset$root = tileset.root) === null || _tileset$root === void 0 ? void 0 : _tileset$root.refine;
    const rootLodMetricValue = tile.geometricError;
    const rootBoundingVolume = tile.boundingVolume;
    const implicitOptions = {
      contentUrlTemplate,
      subtreesUriTemplate,
      subdivisionScheme,
      subtreeLevels,
      maximumLevel,
      refine,
      basePath,
      lodMetricType: LOD_METRIC_TYPE.GEOMETRIC_ERROR,
      rootLodMetricValue,
      rootBoundingVolume,
      getTileType,
      getRefine
    };
    return await normalizeImplicitTileData(tile, subtree, implicitOptions);
  }
  async function normalizeImplicitTileData(tile, rootSubtree, options) {
    if (!tile) {
      return null;
    }
    tile.lodMetricType = LOD_METRIC_TYPE.GEOMETRIC_ERROR;
    tile.lodMetricValue = tile.geometricError;
    tile.transformMatrix = tile.transform;
    const {
      children,
      contentUrl
    } = await parseImplicitTiles({
      subtree: rootSubtree,
      options
    });
    if (contentUrl) {
      tile.contentUrl = contentUrl;
      tile.content = {
        uri: contentUrl.replace("".concat(options.basePath, "/"), "")
      };
    }
    tile.refine = getRefine(tile.refine);
    tile.type = getTileType(tile);
    tile.children = children;
    tile.id = tile.contentUrl;
    return tile;
  }
  function getImplicitTilingExtensionData(tile) {
    var _tile$extensions;
    return (tile === null || tile === void 0 ? void 0 : (_tile$extensions = tile.extensions) === null || _tile$extensions === void 0 ? void 0 : _tile$extensions["3DTILES_implicit_tiling"]) || (tile === null || tile === void 0 ? void 0 : tile.implicitTiling);
  }

  // ../../node_modules/@loaders.gl/3d-tiles/dist/esm/tiles-3d-loader.js
  var Tiles3DLoader = {
    id: "3d-tiles",
    name: "3D Tiles",
    module: "3d-tiles",
    version: VERSION8,
    extensions: ["cmpt", "pnts", "b3dm", "i3dm"],
    mimeTypes: ["application/octet-stream"],
    tests: ["cmpt", "pnts", "b3dm", "i3dm"],
    parse: parse3,
    options: {
      "3d-tiles": {
        loadGLTF: true,
        decodeQuantizedPositions: false,
        isTileset: "auto",
        assetGltfUpAxis: null
      }
    }
  };
  function getBaseUri(tileset) {
    return path_exports.dirname(tileset.url);
  }
  async function parseTile(arrayBuffer, options, context) {
    const tile = {
      content: {
        featureIds: null
      }
    };
    const byteOffset = 0;
    await parse3DTile(arrayBuffer, byteOffset, options, context, tile.content);
    return tile.content;
  }
  async function parseTileset(data, options, context) {
    var _tilesetJson$root;
    const tilesetJson = JSON.parse(new TextDecoder().decode(data));
    tilesetJson.loader = options.loader || Tiles3DLoader;
    tilesetJson.url = context.url;
    tilesetJson.basePath = getBaseUri(tilesetJson);
    tilesetJson.root = await normalizeTileHeaders(tilesetJson, options);
    tilesetJson.type = TILESET_TYPE.TILES3D;
    tilesetJson.lodMetricType = LOD_METRIC_TYPE.GEOMETRIC_ERROR;
    tilesetJson.lodMetricValue = ((_tilesetJson$root = tilesetJson.root) === null || _tilesetJson$root === void 0 ? void 0 : _tilesetJson$root.lodMetricValue) || 0;
    return tilesetJson;
  }
  async function parse3(data, options, context) {
    const loaderOptions = options["3d-tiles"] || {};
    let isTileset;
    if (loaderOptions.isTileset === "auto") {
      isTileset = context.url && context.url.indexOf(".json") !== -1;
    } else {
      isTileset = loaderOptions.isTileset;
    }
    if (isTileset) {
      data = await parseTileset(data, options, context);
    } else {
      data = await parseTile(data, options, context);
    }
    return data;
  }

  // src/tile-3d-layer/tile-3d-layer.ts
  var SINGLE_DATA = [0];
  var defaultProps11 = {
    getPointColor: {
      type: "accessor",
      value: [0, 0, 0, 255]
    },
    pointSize: 1,
    data: "",
    loader: Tiles3DLoader,
    onTilesetLoad: {
      type: "function",
      value: (tileset3d) => {
      }
    },
    onTileLoad: {
      type: "function",
      value: (tileHeader) => {
      }
    },
    onTileUnload: {
      type: "function",
      value: (tileHeader) => {
      }
    },
    onTileError: {
      type: "function",
      value: (tile, message, url) => {
      }
    },
    _getMeshColor: {
      type: "function",
      value: (tileHeader) => [255, 255, 255]
    }
  };
  var Tile3DLayer = class extends import_core42.CompositeLayer {
    initializeState() {
      if ("onTileLoadFail" in this.props) {
        import_core42.log.removed("onTileLoadFail", "onTileError")();
      }
      this.state = {
        layerMap: {},
        tileset3d: null,
        activeViewports: {},
        lastUpdatedViewports: null
      };
    }
    get isLoaded() {
      const {
        tileset3d
      } = this.state;
      return tileset3d !== null && tileset3d.isLoaded();
    }
    shouldUpdateState({
      changeFlags
    }) {
      return changeFlags.somethingChanged;
    }
    updateState({
      props,
      oldProps,
      changeFlags
    }) {
      if (props.data && props.data !== oldProps.data) {
        this._loadTileset(props.data);
      }
      if (changeFlags.viewportChanged) {
        const {
          activeViewports
        } = this.state;
        const viewportsNumber = Object.keys(activeViewports).length;
        if (viewportsNumber) {
          this._updateTileset(activeViewports);
          this.state.lastUpdatedViewports = activeViewports;
          this.state.activeViewports = {};
        }
      }
      if (changeFlags.propsChanged) {
        const {
          layerMap
        } = this.state;
        for (const key in layerMap) {
          layerMap[key].needsUpdate = true;
        }
      }
    }
    activateViewport(viewport) {
      const {
        activeViewports,
        lastUpdatedViewports
      } = this.state;
      this.internalState.viewport = viewport;
      activeViewports[viewport.id] = viewport;
      const lastViewport = lastUpdatedViewports?.[viewport.id];
      if (!lastViewport || !viewport.equals(lastViewport)) {
        this.setChangeFlags({
          viewportChanged: true
        });
        this.setNeedsUpdate();
      }
    }
    getPickingInfo({
      info,
      sourceLayer
    }) {
      const sourceTile = sourceLayer && sourceLayer.props.tile;
      if (info.picked) {
        info.object = sourceTile;
      }
      info.sourceTile = sourceTile;
      return info;
    }
    filterSubLayer({
      layer,
      viewport
    }) {
      const {
        tile
      } = layer.props;
      const {
        id: viewportId
      } = viewport;
      return tile.selected && tile.viewportIds.includes(viewportId);
    }
    _updateAutoHighlight(info) {
      const sourceTile = info.sourceTile;
      const layerCache = this.state.layerMap[sourceTile?.id];
      if (layerCache && layerCache.layer) {
        layerCache.layer.updateAutoHighlight(info);
      }
    }
    async _loadTileset(tilesetUrl) {
      const {
        loadOptions = {}
      } = this.props;
      let loader = this.props.loader || this.props.loaders;
      if (Array.isArray(loader)) {
        loader = loader[0];
      }
      const options = {
        loadOptions: {
          ...loadOptions
        }
      };
      if (loader.preload) {
        const preloadOptions = await loader.preload(tilesetUrl, loadOptions);
        if (preloadOptions.headers) {
          options.loadOptions.fetch = {
            ...options.loadOptions.fetch,
            headers: preloadOptions.headers
          };
        }
        Object.assign(options, preloadOptions);
      }
      const tilesetJson = await (0, import_core43.load)(tilesetUrl, loader, options.loadOptions);
      const tileset3d = new Tileset3D(tilesetJson, {
        onTileLoad: this._onTileLoad.bind(this),
        onTileUnload: this._onTileUnload.bind(this),
        onTileError: this.props.onTileError,
        ...options
      });
      this.setState({
        tileset3d,
        layerMap: {}
      });
      this._updateTileset(this.state.activeViewports);
      this.props.onTilesetLoad(tileset3d);
    }
    _onTileLoad(tileHeader) {
      const {
        lastUpdatedViewports
      } = this.state;
      this.props.onTileLoad(tileHeader);
      this._updateTileset(lastUpdatedViewports);
      this.setNeedsUpdate();
    }
    _onTileUnload(tileHeader) {
      delete this.state.layerMap[tileHeader.id];
      this.props.onTileUnload(tileHeader);
    }
    _updateTileset(viewports) {
      if (!viewports) {
        return;
      }
      const {
        tileset3d
      } = this.state;
      const {
        timeline
      } = this.context;
      const viewportsNumber = Object.keys(viewports).length;
      if (!timeline || !viewportsNumber || !tileset3d) {
        return;
      }
      tileset3d.selectTiles(Object.values(viewports)).then((frameNumber) => {
        const tilesetChanged = this.state.frameNumber !== frameNumber;
        if (tilesetChanged) {
          this.setState({
            frameNumber
          });
        }
      });
    }
    _getSubLayer(tileHeader, oldLayer) {
      if (!tileHeader.content) {
        return null;
      }
      switch (tileHeader.type) {
        case TILE_TYPE.POINTCLOUD:
          return this._makePointCloudLayer(tileHeader, oldLayer);
        case TILE_TYPE.SCENEGRAPH:
          return this._make3DModelLayer(tileHeader);
        case TILE_TYPE.MESH:
          return this._makeSimpleMeshLayer(tileHeader, oldLayer);
        default:
          throw new Error(`Tile3DLayer: Failed to render layer of type ${tileHeader.content.type}`);
      }
    }
    _makePointCloudLayer(tileHeader, oldLayer) {
      const {
        attributes,
        pointCount,
        constantRGBA,
        cartographicOrigin,
        modelMatrix
      } = tileHeader.content;
      const {
        positions,
        normals,
        colors
      } = attributes;
      if (!positions) {
        return null;
      }
      const data = oldLayer && oldLayer.props.data || {
        header: {
          vertexCount: pointCount
        },
        attributes: {
          POSITION: positions,
          NORMAL: normals,
          COLOR_0: colors
        }
      };
      const {
        pointSize,
        getPointColor
      } = this.props;
      const SubLayerClass = this.getSubLayerClass("pointcloud", import_layers8.PointCloudLayer);
      return new SubLayerClass({
        pointSize
      }, this.getSubLayerProps({
        id: "pointcloud"
      }), {
        id: `${this.id}-pointcloud-${tileHeader.id}`,
        tile: tileHeader,
        data,
        coordinateSystem: import_core42.COORDINATE_SYSTEM.METER_OFFSETS,
        coordinateOrigin: cartographicOrigin,
        modelMatrix,
        getColor: constantRGBA || getPointColor,
        _offset: 0
      });
    }
    _make3DModelLayer(tileHeader) {
      const {
        gltf,
        instances,
        cartographicOrigin,
        modelMatrix
      } = tileHeader.content;
      const SubLayerClass = this.getSubLayerClass("scenegraph", import_mesh_layers2.ScenegraphLayer);
      return new SubLayerClass({
        _lighting: "pbr"
      }, this.getSubLayerProps({
        id: "scenegraph"
      }), {
        id: `${this.id}-scenegraph-${tileHeader.id}`,
        tile: tileHeader,
        data: instances || SINGLE_DATA,
        scenegraph: gltf,
        coordinateSystem: import_core42.COORDINATE_SYSTEM.METER_OFFSETS,
        coordinateOrigin: cartographicOrigin,
        modelMatrix,
        getTransformMatrix: (instance) => instance.modelMatrix,
        getPosition: [0, 0, 0],
        _offset: 0
      });
    }
    _makeSimpleMeshLayer(tileHeader, oldLayer) {
      const content = tileHeader.content;
      const {
        attributes,
        indices,
        modelMatrix,
        cartographicOrigin,
        coordinateSystem = import_core42.COORDINATE_SYSTEM.METER_OFFSETS,
        material,
        featureIds
      } = content;
      const {
        _getMeshColor
      } = this.props;
      const geometry = oldLayer && oldLayer.props.mesh || new import_core41.Geometry({
        drawMode: esm_default.TRIANGLES,
        attributes: getMeshGeometry(attributes),
        indices
      });
      const SubLayerClass = this.getSubLayerClass("mesh", MeshLayer);
      return new SubLayerClass(this.getSubLayerProps({
        id: "mesh"
      }), {
        id: `${this.id}-mesh-${tileHeader.id}`,
        tile: tileHeader,
        mesh: geometry,
        data: SINGLE_DATA,
        getColor: _getMeshColor(tileHeader),
        pbrMaterial: material,
        modelMatrix,
        coordinateOrigin: cartographicOrigin,
        coordinateSystem,
        featureIds,
        _offset: 0
      });
    }
    renderLayers() {
      const {
        tileset3d,
        layerMap
      } = this.state;
      if (!tileset3d) {
        return null;
      }
      return tileset3d.tiles.map((tile) => {
        const layerCache = layerMap[tile.id] = layerMap[tile.id] || {
          tile
        };
        let {
          layer
        } = layerCache;
        if (tile.selected) {
          if (!layer) {
            layer = this._getSubLayer(tile);
          } else if (layerCache.needsUpdate) {
            layer = this._getSubLayer(tile, layer);
            layerCache.needsUpdate = false;
          }
        }
        layerCache.layer = layer;
        return layer;
      }).filter(Boolean);
    }
  };
  __publicField(Tile3DLayer, "defaultProps", defaultProps11);
  __publicField(Tile3DLayer, "layerName", "Tile3DLayer");
  function getMeshGeometry(contentAttributes) {
    const attributes = {};
    attributes.positions = {
      ...contentAttributes.positions,
      value: new Float32Array(contentAttributes.positions.value)
    };
    if (contentAttributes.normals) {
      attributes.normals = contentAttributes.normals;
    }
    if (contentAttributes.texCoords) {
      attributes.texCoords = contentAttributes.texCoords;
    }
    if (contentAttributes.colors) {
      attributes.colors = contentAttributes.colors;
    }
    if (contentAttributes.uvRegions) {
      attributes.uvRegions = contentAttributes.uvRegions;
    }
    return attributes;
  }

  // src/terrain-layer/terrain-layer.ts
  var import_core44 = __toESM(require_core());
  var import_mesh_layers3 = __toESM(require_mesh_layers());
  var import_core45 = __toESM(require_core());

  // ../../node_modules/@loaders.gl/terrain/dist/esm/lib/decode-quantized-mesh.js
  var QUANTIZED_MESH_HEADER = /* @__PURE__ */ new Map([["centerX", Float64Array.BYTES_PER_ELEMENT], ["centerY", Float64Array.BYTES_PER_ELEMENT], ["centerZ", Float64Array.BYTES_PER_ELEMENT], ["minHeight", Float32Array.BYTES_PER_ELEMENT], ["maxHeight", Float32Array.BYTES_PER_ELEMENT], ["boundingSphereCenterX", Float64Array.BYTES_PER_ELEMENT], ["boundingSphereCenterY", Float64Array.BYTES_PER_ELEMENT], ["boundingSphereCenterZ", Float64Array.BYTES_PER_ELEMENT], ["boundingSphereRadius", Float64Array.BYTES_PER_ELEMENT], ["horizonOcclusionPointX", Float64Array.BYTES_PER_ELEMENT], ["horizonOcclusionPointY", Float64Array.BYTES_PER_ELEMENT], ["horizonOcclusionPointZ", Float64Array.BYTES_PER_ELEMENT]]);
  function decodeZigZag(value) {
    return value >> 1 ^ -(value & 1);
  }
  function decodeHeader(dataView) {
    let position = 0;
    const header = {};
    for (const [key, bytesCount] of QUANTIZED_MESH_HEADER) {
      const getter = bytesCount === 8 ? dataView.getFloat64 : dataView.getFloat32;
      header[key] = getter.call(dataView, position, true);
      position += bytesCount;
    }
    return {
      header,
      headerEndPosition: position
    };
  }
  function decodeVertexData(dataView, headerEndPosition) {
    let position = headerEndPosition;
    const elementsPerVertex = 3;
    const vertexCount = dataView.getUint32(position, true);
    const vertexData = new Uint16Array(vertexCount * elementsPerVertex);
    position += Uint32Array.BYTES_PER_ELEMENT;
    const bytesPerArrayElement = Uint16Array.BYTES_PER_ELEMENT;
    const elementArrayLength = vertexCount * bytesPerArrayElement;
    const uArrayStartPosition = position;
    const vArrayStartPosition = uArrayStartPosition + elementArrayLength;
    const heightArrayStartPosition = vArrayStartPosition + elementArrayLength;
    let u = 0;
    let v = 0;
    let height = 0;
    for (let i3 = 0; i3 < vertexCount; i3++) {
      u += decodeZigZag(dataView.getUint16(uArrayStartPosition + bytesPerArrayElement * i3, true));
      v += decodeZigZag(dataView.getUint16(vArrayStartPosition + bytesPerArrayElement * i3, true));
      height += decodeZigZag(dataView.getUint16(heightArrayStartPosition + bytesPerArrayElement * i3, true));
      vertexData[i3] = u;
      vertexData[i3 + vertexCount] = v;
      vertexData[i3 + vertexCount * 2] = height;
    }
    position += elementArrayLength * 3;
    return {
      vertexData,
      vertexDataEndPosition: position
    };
  }
  function decodeIndex(buffer, position, indicesCount, bytesPerIndex) {
    let encoded = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : true;
    let indices;
    if (bytesPerIndex === 2) {
      indices = new Uint16Array(buffer, position, indicesCount);
    } else {
      indices = new Uint32Array(buffer, position, indicesCount);
    }
    if (!encoded) {
      return indices;
    }
    let highest = 0;
    for (let i3 = 0; i3 < indices.length; ++i3) {
      const code = indices[i3];
      indices[i3] = highest - code;
      if (code === 0) {
        ++highest;
      }
    }
    return indices;
  }
  function decodeTriangleIndices(dataView, vertexData, vertexDataEndPosition) {
    let position = vertexDataEndPosition;
    const elementsPerVertex = 3;
    const vertexCount = vertexData.length / elementsPerVertex;
    const bytesPerIndex = vertexCount > 65536 ? Uint32Array.BYTES_PER_ELEMENT : Uint16Array.BYTES_PER_ELEMENT;
    if (position % bytesPerIndex !== 0) {
      position += bytesPerIndex - position % bytesPerIndex;
    }
    const triangleCount = dataView.getUint32(position, true);
    position += Uint32Array.BYTES_PER_ELEMENT;
    const triangleIndicesCount = triangleCount * 3;
    const triangleIndices = decodeIndex(dataView.buffer, position, triangleIndicesCount, bytesPerIndex);
    position += triangleIndicesCount * bytesPerIndex;
    return {
      triangleIndicesEndPosition: position,
      triangleIndices
    };
  }
  function decodeEdgeIndices(dataView, vertexData, triangleIndicesEndPosition) {
    let position = triangleIndicesEndPosition;
    const elementsPerVertex = 3;
    const vertexCount = vertexData.length / elementsPerVertex;
    const bytesPerIndex = vertexCount > 65536 ? Uint32Array.BYTES_PER_ELEMENT : Uint16Array.BYTES_PER_ELEMENT;
    const westVertexCount = dataView.getUint32(position, true);
    position += Uint32Array.BYTES_PER_ELEMENT;
    const westIndices = decodeIndex(dataView.buffer, position, westVertexCount, bytesPerIndex, false);
    position += westVertexCount * bytesPerIndex;
    const southVertexCount = dataView.getUint32(position, true);
    position += Uint32Array.BYTES_PER_ELEMENT;
    const southIndices = decodeIndex(dataView.buffer, position, southVertexCount, bytesPerIndex, false);
    position += southVertexCount * bytesPerIndex;
    const eastVertexCount = dataView.getUint32(position, true);
    position += Uint32Array.BYTES_PER_ELEMENT;
    const eastIndices = decodeIndex(dataView.buffer, position, eastVertexCount, bytesPerIndex, false);
    position += eastVertexCount * bytesPerIndex;
    const northVertexCount = dataView.getUint32(position, true);
    position += Uint32Array.BYTES_PER_ELEMENT;
    const northIndices = decodeIndex(dataView.buffer, position, northVertexCount, bytesPerIndex, false);
    position += northVertexCount * bytesPerIndex;
    return {
      edgeIndicesEndPosition: position,
      westIndices,
      southIndices,
      eastIndices,
      northIndices
    };
  }
  function decodeVertexNormalsExtension(extensionDataView) {
    return new Uint8Array(extensionDataView.buffer, extensionDataView.byteOffset, extensionDataView.byteLength);
  }
  function decodeWaterMaskExtension(extensionDataView) {
    return extensionDataView.buffer.slice(extensionDataView.byteOffset, extensionDataView.byteOffset + extensionDataView.byteLength);
  }
  function decodeExtensions2(dataView, indicesEndPosition) {
    const extensions = {};
    if (dataView.byteLength <= indicesEndPosition) {
      return {
        extensions,
        extensionsEndPosition: indicesEndPosition
      };
    }
    let position = indicesEndPosition;
    while (position < dataView.byteLength) {
      const extensionId = dataView.getUint8(position, true);
      position += Uint8Array.BYTES_PER_ELEMENT;
      const extensionLength = dataView.getUint32(position, true);
      position += Uint32Array.BYTES_PER_ELEMENT;
      const extensionView = new DataView(dataView.buffer, position, extensionLength);
      switch (extensionId) {
        case 1: {
          extensions.vertexNormals = decodeVertexNormalsExtension(extensionView);
          break;
        }
        case 2: {
          extensions.waterMask = decodeWaterMaskExtension(extensionView);
          break;
        }
        default: {
        }
      }
      position += extensionLength;
    }
    return {
      extensions,
      extensionsEndPosition: position
    };
  }
  var DECODING_STEPS = {
    header: 0,
    vertices: 1,
    triangleIndices: 2,
    edgeIndices: 3,
    extensions: 4
  };
  var DEFAULT_OPTIONS = {
    maxDecodingStep: DECODING_STEPS.extensions
  };
  function decode9(data, userOptions) {
    const options = Object.assign({}, DEFAULT_OPTIONS, userOptions);
    const view = new DataView(data);
    const {
      header,
      headerEndPosition
    } = decodeHeader(view);
    if (options.maxDecodingStep < DECODING_STEPS.vertices) {
      return {
        header
      };
    }
    const {
      vertexData,
      vertexDataEndPosition
    } = decodeVertexData(view, headerEndPosition);
    if (options.maxDecodingStep < DECODING_STEPS.triangleIndices) {
      return {
        header,
        vertexData
      };
    }
    const {
      triangleIndices,
      triangleIndicesEndPosition
    } = decodeTriangleIndices(view, vertexData, vertexDataEndPosition);
    if (options.maxDecodingStep < DECODING_STEPS.edgeIndices) {
      return {
        header,
        vertexData,
        triangleIndices
      };
    }
    const {
      westIndices,
      southIndices,
      eastIndices,
      northIndices,
      edgeIndicesEndPosition
    } = decodeEdgeIndices(view, vertexData, triangleIndicesEndPosition);
    if (options.maxDecodingStep < DECODING_STEPS.extensions) {
      return {
        header,
        vertexData,
        triangleIndices,
        westIndices,
        northIndices,
        eastIndices,
        southIndices
      };
    }
    const {
      extensions
    } = decodeExtensions2(view, edgeIndicesEndPosition);
    return {
      header,
      vertexData,
      triangleIndices,
      westIndices,
      northIndices,
      eastIndices,
      southIndices,
      extensions
    };
  }

  // ../../node_modules/@loaders.gl/terrain/dist/esm/lib/helpers/skirt.js
  function addSkirt(attributes, triangles, skirtHeight, outsideIndices) {
    const outsideEdges = outsideIndices ? getOutsideEdgesFromIndices(outsideIndices, attributes.POSITION.value) : getOutsideEdgesFromTriangles(triangles);
    const newPosition = new attributes.POSITION.value.constructor(outsideEdges.length * 6);
    const newTexcoord0 = new attributes.TEXCOORD_0.value.constructor(outsideEdges.length * 4);
    const newTriangles = new triangles.constructor(outsideEdges.length * 6);
    for (let i3 = 0; i3 < outsideEdges.length; i3++) {
      const edge = outsideEdges[i3];
      updateAttributesForNewEdge({
        edge,
        edgeIndex: i3,
        attributes,
        skirtHeight,
        newPosition,
        newTexcoord0,
        newTriangles
      });
    }
    attributes.POSITION.value = concatenateTypedArrays(attributes.POSITION.value, newPosition);
    attributes.TEXCOORD_0.value = concatenateTypedArrays(attributes.TEXCOORD_0.value, newTexcoord0);
    const resultTriangles = triangles instanceof Array ? triangles.concat(newTriangles) : concatenateTypedArrays(triangles, newTriangles);
    return {
      attributes,
      triangles: resultTriangles
    };
  }
  function getOutsideEdgesFromTriangles(triangles) {
    const edges = [];
    for (let i3 = 0; i3 < triangles.length; i3 += 3) {
      edges.push([triangles[i3], triangles[i3 + 1]]);
      edges.push([triangles[i3 + 1], triangles[i3 + 2]]);
      edges.push([triangles[i3 + 2], triangles[i3]]);
    }
    edges.sort((a2, b) => Math.min(...a2) - Math.min(...b) || Math.max(...a2) - Math.max(...b));
    const outsideEdges = [];
    let index = 0;
    while (index < edges.length) {
      var _edges, _edges2;
      if (edges[index][0] === ((_edges = edges[index + 1]) === null || _edges === void 0 ? void 0 : _edges[1]) && edges[index][1] === ((_edges2 = edges[index + 1]) === null || _edges2 === void 0 ? void 0 : _edges2[0])) {
        index += 2;
      } else {
        outsideEdges.push(edges[index]);
        index++;
      }
    }
    return outsideEdges;
  }
  function getOutsideEdgesFromIndices(indices, position) {
    indices.westIndices.sort((a2, b) => position[3 * a2 + 1] - position[3 * b + 1]);
    indices.eastIndices.sort((a2, b) => position[3 * b + 1] - position[3 * a2 + 1]);
    indices.southIndices.sort((a2, b) => position[3 * b] - position[3 * a2]);
    indices.northIndices.sort((a2, b) => position[3 * a2] - position[3 * b]);
    const edges = [];
    for (const index in indices) {
      const indexGroup = indices[index];
      for (let i3 = 0; i3 < indexGroup.length - 1; i3++) {
        edges.push([indexGroup[i3], indexGroup[i3 + 1]]);
      }
    }
    return edges;
  }
  function updateAttributesForNewEdge(_ref) {
    let {
      edge,
      edgeIndex,
      attributes,
      skirtHeight,
      newPosition,
      newTexcoord0,
      newTriangles
    } = _ref;
    const positionsLength = attributes.POSITION.value.length;
    const vertex1Offset = edgeIndex * 2;
    const vertex2Offset = edgeIndex * 2 + 1;
    newPosition.set(attributes.POSITION.value.subarray(edge[0] * 3, edge[0] * 3 + 3), vertex1Offset * 3);
    newPosition[vertex1Offset * 3 + 2] = newPosition[vertex1Offset * 3 + 2] - skirtHeight;
    newPosition.set(attributes.POSITION.value.subarray(edge[1] * 3, edge[1] * 3 + 3), vertex2Offset * 3);
    newPosition[vertex2Offset * 3 + 2] = newPosition[vertex2Offset * 3 + 2] - skirtHeight;
    newTexcoord0.set(attributes.TEXCOORD_0.value.subarray(edge[0] * 2, edge[0] * 2 + 2), vertex1Offset * 2);
    newTexcoord0.set(attributes.TEXCOORD_0.value.subarray(edge[1] * 2, edge[1] * 2 + 2), vertex2Offset * 2);
    const triangle1Offset = edgeIndex * 2 * 3;
    newTriangles[triangle1Offset] = edge[0];
    newTriangles[triangle1Offset + 1] = positionsLength / 3 + vertex2Offset;
    newTriangles[triangle1Offset + 2] = edge[1];
    newTriangles[triangle1Offset + 3] = positionsLength / 3 + vertex2Offset;
    newTriangles[triangle1Offset + 4] = edge[0];
    newTriangles[triangle1Offset + 5] = positionsLength / 3 + vertex1Offset;
  }

  // ../../node_modules/@loaders.gl/terrain/dist/esm/lib/parse-quantized-mesh.js
  function getMeshAttributes(vertexData, header, bounds) {
    const {
      minHeight,
      maxHeight
    } = header;
    const [minX, minY, maxX, maxY] = bounds || [0, 0, 1, 1];
    const xScale = maxX - minX;
    const yScale = maxY - minY;
    const zScale = maxHeight - minHeight;
    const nCoords = vertexData.length / 3;
    const positions = new Float32Array(nCoords * 3);
    const texCoords = new Float32Array(nCoords * 2);
    for (let i3 = 0; i3 < nCoords; i3++) {
      const x2 = vertexData[i3] / 32767;
      const y2 = vertexData[i3 + nCoords] / 32767;
      const z = vertexData[i3 + nCoords * 2] / 32767;
      positions[3 * i3 + 0] = x2 * xScale + minX;
      positions[3 * i3 + 1] = y2 * yScale + minY;
      positions[3 * i3 + 2] = z * zScale + minHeight;
      texCoords[2 * i3 + 0] = x2;
      texCoords[2 * i3 + 1] = y2;
    }
    return {
      POSITION: {
        value: positions,
        size: 3
      },
      TEXCOORD_0: {
        value: texCoords,
        size: 2
      }
    };
  }
  function getTileMesh(arrayBuffer, options) {
    if (!arrayBuffer) {
      return null;
    }
    const {
      bounds
    } = options;
    const {
      header,
      vertexData,
      triangleIndices: originalTriangleIndices,
      westIndices,
      northIndices,
      eastIndices,
      southIndices
    } = decode9(arrayBuffer, DECODING_STEPS.triangleIndices);
    let triangleIndices = originalTriangleIndices;
    let attributes = getMeshAttributes(vertexData, header, bounds);
    const boundingBox = getMeshBoundingBox(attributes);
    if (options.skirtHeight) {
      const {
        attributes: newAttributes,
        triangles: newTriangles
      } = addSkirt(attributes, triangleIndices, options.skirtHeight, {
        westIndices,
        northIndices,
        eastIndices,
        southIndices
      });
      attributes = newAttributes;
      triangleIndices = newTriangles;
    }
    return {
      loaderData: {
        header: {}
      },
      header: {
        vertexCount: triangleIndices.length,
        boundingBox
      },
      mode: 4,
      indices: {
        value: triangleIndices,
        size: 1
      },
      attributes
    };
  }
  function loadQuantizedMesh(arrayBuffer, options) {
    return getTileMesh(arrayBuffer, options["quantized-mesh"]);
  }

  // ../../node_modules/@mapbox/martini/index.js
  var Martini = class {
    constructor(gridSize = 257) {
      this.gridSize = gridSize;
      const tileSize = gridSize - 1;
      if (tileSize & tileSize - 1)
        throw new Error(
          `Expected grid size to be 2^n+1, got ${gridSize}.`
        );
      this.numTriangles = tileSize * tileSize * 2 - 2;
      this.numParentTriangles = this.numTriangles - tileSize * tileSize;
      this.indices = new Uint32Array(this.gridSize * this.gridSize);
      this.coords = new Uint16Array(this.numTriangles * 4);
      for (let i3 = 0; i3 < this.numTriangles; i3++) {
        let id = i3 + 2;
        let ax = 0, ay = 0, bx = 0, by = 0, cx = 0, cy = 0;
        if (id & 1) {
          bx = by = cx = tileSize;
        } else {
          ax = ay = cy = tileSize;
        }
        while ((id >>= 1) > 1) {
          const mx = ax + bx >> 1;
          const my = ay + by >> 1;
          if (id & 1) {
            bx = ax;
            by = ay;
            ax = cx;
            ay = cy;
          } else {
            ax = bx;
            ay = by;
            bx = cx;
            by = cy;
          }
          cx = mx;
          cy = my;
        }
        const k = i3 * 4;
        this.coords[k + 0] = ax;
        this.coords[k + 1] = ay;
        this.coords[k + 2] = bx;
        this.coords[k + 3] = by;
      }
    }
    createTile(terrain) {
      return new Tile(terrain, this);
    }
  };
  var Tile = class {
    constructor(terrain, martini) {
      const size = martini.gridSize;
      if (terrain.length !== size * size)
        throw new Error(
          `Expected terrain data of length ${size * size} (${size} x ${size}), got ${terrain.length}.`
        );
      this.terrain = terrain;
      this.martini = martini;
      this.errors = new Float32Array(terrain.length);
      this.update();
    }
    update() {
      const { numTriangles, numParentTriangles, coords, gridSize: size } = this.martini;
      const { terrain, errors } = this;
      for (let i3 = numTriangles - 1; i3 >= 0; i3--) {
        const k = i3 * 4;
        const ax = coords[k + 0];
        const ay = coords[k + 1];
        const bx = coords[k + 2];
        const by = coords[k + 3];
        const mx = ax + bx >> 1;
        const my = ay + by >> 1;
        const cx = mx + my - ay;
        const cy = my + ax - mx;
        const interpolatedHeight = (terrain[ay * size + ax] + terrain[by * size + bx]) / 2;
        const middleIndex = my * size + mx;
        const middleError = Math.abs(interpolatedHeight - terrain[middleIndex]);
        errors[middleIndex] = Math.max(errors[middleIndex], middleError);
        if (i3 < numParentTriangles) {
          const leftChildIndex = (ay + cy >> 1) * size + (ax + cx >> 1);
          const rightChildIndex = (by + cy >> 1) * size + (bx + cx >> 1);
          errors[middleIndex] = Math.max(errors[middleIndex], errors[leftChildIndex], errors[rightChildIndex]);
        }
      }
    }
    getMesh(maxError = 0) {
      const { gridSize: size, indices } = this.martini;
      const { errors } = this;
      let numVertices = 0;
      let numTriangles = 0;
      const max = size - 1;
      indices.fill(0);
      function countElements(ax, ay, bx, by, cx, cy) {
        const mx = ax + bx >> 1;
        const my = ay + by >> 1;
        if (Math.abs(ax - cx) + Math.abs(ay - cy) > 1 && errors[my * size + mx] > maxError) {
          countElements(cx, cy, ax, ay, mx, my);
          countElements(bx, by, cx, cy, mx, my);
        } else {
          indices[ay * size + ax] = indices[ay * size + ax] || ++numVertices;
          indices[by * size + bx] = indices[by * size + bx] || ++numVertices;
          indices[cy * size + cx] = indices[cy * size + cx] || ++numVertices;
          numTriangles++;
        }
      }
      countElements(0, 0, max, max, max, 0);
      countElements(max, max, 0, 0, 0, max);
      const vertices = new Uint16Array(numVertices * 2);
      const triangles = new Uint32Array(numTriangles * 3);
      let triIndex = 0;
      function processTriangle(ax, ay, bx, by, cx, cy) {
        const mx = ax + bx >> 1;
        const my = ay + by >> 1;
        if (Math.abs(ax - cx) + Math.abs(ay - cy) > 1 && errors[my * size + mx] > maxError) {
          processTriangle(cx, cy, ax, ay, mx, my);
          processTriangle(bx, by, cx, cy, mx, my);
        } else {
          const a2 = indices[ay * size + ax] - 1;
          const b = indices[by * size + bx] - 1;
          const c = indices[cy * size + cx] - 1;
          vertices[2 * a2] = ax;
          vertices[2 * a2 + 1] = ay;
          vertices[2 * b] = bx;
          vertices[2 * b + 1] = by;
          vertices[2 * c] = cx;
          vertices[2 * c + 1] = cy;
          triangles[triIndex++] = a2;
          triangles[triIndex++] = b;
          triangles[triIndex++] = c;
        }
      }
      processTriangle(0, 0, max, max, max, 0);
      processTriangle(max, max, 0, 0, 0, max);
      return { vertices, triangles };
    }
  };

  // ../../node_modules/@loaders.gl/terrain/dist/esm/lib/delatin/index.js
  var Delatin = class {
    constructor(data, width) {
      let height = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : width;
      this.data = data;
      this.width = width;
      this.height = height;
      this.coords = [];
      this.triangles = [];
      this._halfedges = [];
      this._candidates = [];
      this._queueIndices = [];
      this._queue = [];
      this._errors = [];
      this._rms = [];
      this._pending = [];
      this._pendingLen = 0;
      this._rmsSum = 0;
      const x1 = width - 1;
      const y1 = height - 1;
      const p0 = this._addPoint(0, 0);
      const p1 = this._addPoint(x1, 0);
      const p2 = this._addPoint(0, y1);
      const p3 = this._addPoint(x1, y1);
      const t0 = this._addTriangle(p3, p0, p2, -1, -1, -1);
      this._addTriangle(p0, p3, p1, t0, -1, -1);
      this._flush();
    }
    run() {
      let maxError = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1;
      while (this.getMaxError() > maxError) {
        this.refine();
      }
    }
    refine() {
      this._step();
      this._flush();
    }
    getMaxError() {
      return this._errors[0];
    }
    getRMSD() {
      return this._rmsSum > 0 ? Math.sqrt(this._rmsSum / (this.width * this.height)) : 0;
    }
    heightAt(x2, y2) {
      return this.data[this.width * y2 + x2];
    }
    _flush() {
      const coords = this.coords;
      for (let i3 = 0; i3 < this._pendingLen; i3++) {
        const t2 = this._pending[i3];
        const a2 = 2 * this.triangles[t2 * 3 + 0];
        const b = 2 * this.triangles[t2 * 3 + 1];
        const c = 2 * this.triangles[t2 * 3 + 2];
        this._findCandidate(coords[a2], coords[a2 + 1], coords[b], coords[b + 1], coords[c], coords[c + 1], t2);
      }
      this._pendingLen = 0;
    }
    _findCandidate(p0x, p0y, p1x, p1y, p2x, p2y, t2) {
      const minX = Math.min(p0x, p1x, p2x);
      const minY = Math.min(p0y, p1y, p2y);
      const maxX = Math.max(p0x, p1x, p2x);
      const maxY = Math.max(p0y, p1y, p2y);
      let w00 = orient(p1x, p1y, p2x, p2y, minX, minY);
      let w01 = orient(p2x, p2y, p0x, p0y, minX, minY);
      let w02 = orient(p0x, p0y, p1x, p1y, minX, minY);
      const a01 = p1y - p0y;
      const b01 = p0x - p1x;
      const a12 = p2y - p1y;
      const b12 = p1x - p2x;
      const a20 = p0y - p2y;
      const b20 = p2x - p0x;
      const a2 = orient(p0x, p0y, p1x, p1y, p2x, p2y);
      const z0 = this.heightAt(p0x, p0y) / a2;
      const z1 = this.heightAt(p1x, p1y) / a2;
      const z2 = this.heightAt(p2x, p2y) / a2;
      let maxError = 0;
      let mx = 0;
      let my = 0;
      let rms = 0;
      for (let y2 = minY; y2 <= maxY; y2++) {
        let dx = 0;
        if (w00 < 0 && a12 !== 0) {
          dx = Math.max(dx, Math.floor(-w00 / a12));
        }
        if (w01 < 0 && a20 !== 0) {
          dx = Math.max(dx, Math.floor(-w01 / a20));
        }
        if (w02 < 0 && a01 !== 0) {
          dx = Math.max(dx, Math.floor(-w02 / a01));
        }
        let w0 = w00 + a12 * dx;
        let w1 = w01 + a20 * dx;
        let w2 = w02 + a01 * dx;
        let wasInside = false;
        for (let x2 = minX + dx; x2 <= maxX; x2++) {
          if (w0 >= 0 && w1 >= 0 && w2 >= 0) {
            wasInside = true;
            const z = z0 * w0 + z1 * w1 + z2 * w2;
            const dz = Math.abs(z - this.heightAt(x2, y2));
            rms += dz * dz;
            if (dz > maxError) {
              maxError = dz;
              mx = x2;
              my = y2;
            }
          } else if (wasInside) {
            break;
          }
          w0 += a12;
          w1 += a20;
          w2 += a01;
        }
        w00 += b12;
        w01 += b20;
        w02 += b01;
      }
      if (mx === p0x && my === p0y || mx === p1x && my === p1y || mx === p2x && my === p2y) {
        maxError = 0;
      }
      this._candidates[2 * t2] = mx;
      this._candidates[2 * t2 + 1] = my;
      this._rms[t2] = rms;
      this._queuePush(t2, maxError, rms);
    }
    _step() {
      const t2 = this._queuePop();
      const e0 = t2 * 3 + 0;
      const e1 = t2 * 3 + 1;
      const e2 = t2 * 3 + 2;
      const p0 = this.triangles[e0];
      const p1 = this.triangles[e1];
      const p2 = this.triangles[e2];
      const ax = this.coords[2 * p0];
      const ay = this.coords[2 * p0 + 1];
      const bx = this.coords[2 * p1];
      const by = this.coords[2 * p1 + 1];
      const cx = this.coords[2 * p2];
      const cy = this.coords[2 * p2 + 1];
      const px = this._candidates[2 * t2];
      const py = this._candidates[2 * t2 + 1];
      const pn = this._addPoint(px, py);
      if (orient(ax, ay, bx, by, px, py) === 0) {
        this._handleCollinear(pn, e0);
      } else if (orient(bx, by, cx, cy, px, py) === 0) {
        this._handleCollinear(pn, e1);
      } else if (orient(cx, cy, ax, ay, px, py) === 0) {
        this._handleCollinear(pn, e2);
      } else {
        const h0 = this._halfedges[e0];
        const h1 = this._halfedges[e1];
        const h2 = this._halfedges[e2];
        const t0 = this._addTriangle(p0, p1, pn, h0, -1, -1, e0);
        const t1 = this._addTriangle(p1, p2, pn, h1, -1, t0 + 1);
        const t22 = this._addTriangle(p2, p0, pn, h2, t0 + 2, t1 + 1);
        this._legalize(t0);
        this._legalize(t1);
        this._legalize(t22);
      }
    }
    _addPoint(x2, y2) {
      const i3 = this.coords.length >> 1;
      this.coords.push(x2, y2);
      return i3;
    }
    _addTriangle(a2, b, c, ab, bc, ca) {
      let e = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : this.triangles.length;
      const t2 = e / 3;
      this.triangles[e + 0] = a2;
      this.triangles[e + 1] = b;
      this.triangles[e + 2] = c;
      this._halfedges[e + 0] = ab;
      this._halfedges[e + 1] = bc;
      this._halfedges[e + 2] = ca;
      if (ab >= 0) {
        this._halfedges[ab] = e + 0;
      }
      if (bc >= 0) {
        this._halfedges[bc] = e + 1;
      }
      if (ca >= 0) {
        this._halfedges[ca] = e + 2;
      }
      this._candidates[2 * t2 + 0] = 0;
      this._candidates[2 * t2 + 1] = 0;
      this._queueIndices[t2] = -1;
      this._rms[t2] = 0;
      this._pending[this._pendingLen++] = t2;
      return e;
    }
    _legalize(a2) {
      const b = this._halfedges[a2];
      if (b < 0) {
        return;
      }
      const a0 = a2 - a2 % 3;
      const b0 = b - b % 3;
      const al = a0 + (a2 + 1) % 3;
      const ar = a0 + (a2 + 2) % 3;
      const bl = b0 + (b + 2) % 3;
      const br = b0 + (b + 1) % 3;
      const p0 = this.triangles[ar];
      const pr = this.triangles[a2];
      const pl = this.triangles[al];
      const p1 = this.triangles[bl];
      const coords = this.coords;
      if (!inCircle(coords[2 * p0], coords[2 * p0 + 1], coords[2 * pr], coords[2 * pr + 1], coords[2 * pl], coords[2 * pl + 1], coords[2 * p1], coords[2 * p1 + 1])) {
        return;
      }
      const hal = this._halfedges[al];
      const har = this._halfedges[ar];
      const hbl = this._halfedges[bl];
      const hbr = this._halfedges[br];
      this._queueRemove(a0 / 3);
      this._queueRemove(b0 / 3);
      const t0 = this._addTriangle(p0, p1, pl, -1, hbl, hal, a0);
      const t1 = this._addTriangle(p1, p0, pr, t0, har, hbr, b0);
      this._legalize(t0 + 1);
      this._legalize(t1 + 2);
    }
    _handleCollinear(pn, a2) {
      const a0 = a2 - a2 % 3;
      const al = a0 + (a2 + 1) % 3;
      const ar = a0 + (a2 + 2) % 3;
      const p0 = this.triangles[ar];
      const pr = this.triangles[a2];
      const pl = this.triangles[al];
      const hal = this._halfedges[al];
      const har = this._halfedges[ar];
      const b = this._halfedges[a2];
      if (b < 0) {
        const t02 = this._addTriangle(pn, p0, pr, -1, har, -1, a0);
        const t12 = this._addTriangle(p0, pn, pl, t02, -1, hal);
        this._legalize(t02 + 1);
        this._legalize(t12 + 2);
        return;
      }
      const b0 = b - b % 3;
      const bl = b0 + (b + 2) % 3;
      const br = b0 + (b + 1) % 3;
      const p1 = this.triangles[bl];
      const hbl = this._halfedges[bl];
      const hbr = this._halfedges[br];
      this._queueRemove(b0 / 3);
      const t0 = this._addTriangle(p0, pr, pn, har, -1, -1, a0);
      const t1 = this._addTriangle(pr, p1, pn, hbr, -1, t0 + 1, b0);
      const t2 = this._addTriangle(p1, pl, pn, hbl, -1, t1 + 1);
      const t3 = this._addTriangle(pl, p0, pn, hal, t0 + 2, t2 + 1);
      this._legalize(t0);
      this._legalize(t1);
      this._legalize(t2);
      this._legalize(t3);
    }
    _queuePush(t2, error2, rms) {
      const i3 = this._queue.length;
      this._queueIndices[t2] = i3;
      this._queue.push(t2);
      this._errors.push(error2);
      this._rmsSum += rms;
      this._queueUp(i3);
    }
    _queuePop() {
      const n2 = this._queue.length - 1;
      this._queueSwap(0, n2);
      this._queueDown(0, n2);
      return this._queuePopBack();
    }
    _queuePopBack() {
      const t2 = this._queue.pop();
      this._errors.pop();
      this._rmsSum -= this._rms[t2];
      this._queueIndices[t2] = -1;
      return t2;
    }
    _queueRemove(t2) {
      const i3 = this._queueIndices[t2];
      if (i3 < 0) {
        const it = this._pending.indexOf(t2);
        if (it !== -1) {
          this._pending[it] = this._pending[--this._pendingLen];
        } else {
          throw new Error("Broken triangulation (something went wrong).");
        }
        return;
      }
      const n2 = this._queue.length - 1;
      if (n2 !== i3) {
        this._queueSwap(i3, n2);
        if (!this._queueDown(i3, n2)) {
          this._queueUp(i3);
        }
      }
      this._queuePopBack();
    }
    _queueLess(i3, j) {
      return this._errors[i3] > this._errors[j];
    }
    _queueSwap(i3, j) {
      const pi = this._queue[i3];
      const pj = this._queue[j];
      this._queue[i3] = pj;
      this._queue[j] = pi;
      this._queueIndices[pi] = j;
      this._queueIndices[pj] = i3;
      const e = this._errors[i3];
      this._errors[i3] = this._errors[j];
      this._errors[j] = e;
    }
    _queueUp(j0) {
      let j = j0;
      while (true) {
        const i3 = j - 1 >> 1;
        if (i3 === j || !this._queueLess(j, i3)) {
          break;
        }
        this._queueSwap(i3, j);
        j = i3;
      }
    }
    _queueDown(i0, n2) {
      let i3 = i0;
      while (true) {
        const j1 = 2 * i3 + 1;
        if (j1 >= n2 || j1 < 0) {
          break;
        }
        const j2 = j1 + 1;
        let j = j1;
        if (j2 < n2 && this._queueLess(j2, j1)) {
          j = j2;
        }
        if (!this._queueLess(j, i3)) {
          break;
        }
        this._queueSwap(i3, j);
        i3 = j;
      }
      return i3 > i0;
    }
  };
  function orient(ax, ay, bx, by, cx, cy) {
    return (bx - cx) * (ay - cy) - (by - cy) * (ax - cx);
  }
  function inCircle(ax, ay, bx, by, cx, cy, px, py) {
    const dx = ax - px;
    const dy = ay - py;
    const ex = bx - px;
    const ey = by - py;
    const fx = cx - px;
    const fy = cy - py;
    const ap = dx * dx + dy * dy;
    const bp = ex * ex + ey * ey;
    const cp = fx * fx + fy * fy;
    return dx * (ey * cp - bp * fy) - dy * (ex * cp - bp * fx) + ap * (ex * fy - ey * fx) < 0;
  }

  // ../../node_modules/@loaders.gl/terrain/dist/esm/lib/parse-terrain.js
  function getTerrain(imageData, width, height, elevationDecoder, tesselator) {
    const {
      rScaler,
      bScaler,
      gScaler,
      offset
    } = elevationDecoder;
    const terrain = new Float32Array((width + 1) * (height + 1));
    for (let i3 = 0, y2 = 0; y2 < height; y2++) {
      for (let x2 = 0; x2 < width; x2++, i3++) {
        const k = i3 * 4;
        const r2 = imageData[k + 0];
        const g = imageData[k + 1];
        const b = imageData[k + 2];
        terrain[i3 + y2] = r2 * rScaler + g * gScaler + b * bScaler + offset;
      }
    }
    if (tesselator === "martini") {
      for (let i3 = (width + 1) * width, x2 = 0; x2 < width; x2++, i3++) {
        terrain[i3] = terrain[i3 - width - 1];
      }
      for (let i3 = height, y2 = 0; y2 < height + 1; y2++, i3 += height + 1) {
        terrain[i3] = terrain[i3 - 1];
      }
    }
    return terrain;
  }
  function getMeshAttributes2(vertices, terrain, width, height, bounds) {
    const gridSize = width + 1;
    const numOfVerticies = vertices.length / 2;
    const positions = new Float32Array(numOfVerticies * 3);
    const texCoords = new Float32Array(numOfVerticies * 2);
    const [minX, minY, maxX, maxY] = bounds || [0, 0, width, height];
    const xScale = (maxX - minX) / width;
    const yScale = (maxY - minY) / height;
    for (let i3 = 0; i3 < numOfVerticies; i3++) {
      const x2 = vertices[i3 * 2];
      const y2 = vertices[i3 * 2 + 1];
      const pixelIdx = y2 * gridSize + x2;
      positions[3 * i3 + 0] = x2 * xScale + minX;
      positions[3 * i3 + 1] = -y2 * yScale + maxY;
      positions[3 * i3 + 2] = terrain[pixelIdx];
      texCoords[2 * i3 + 0] = x2 / width;
      texCoords[2 * i3 + 1] = y2 / height;
    }
    return {
      POSITION: {
        value: positions,
        size: 3
      },
      TEXCOORD_0: {
        value: texCoords,
        size: 2
      }
    };
  }
  function getMesh(terrainImage, terrainOptions) {
    if (terrainImage === null) {
      return null;
    }
    const {
      meshMaxError,
      bounds,
      elevationDecoder
    } = terrainOptions;
    const {
      data,
      width,
      height
    } = terrainImage;
    let terrain;
    let mesh;
    switch (terrainOptions.tesselator) {
      case "martini":
        terrain = getTerrain(data, width, height, elevationDecoder, terrainOptions.tesselator);
        mesh = getMartiniTileMesh(meshMaxError, width, terrain);
        break;
      case "delatin":
        terrain = getTerrain(data, width, height, elevationDecoder, terrainOptions.tesselator);
        mesh = getDelatinTileMesh(meshMaxError, width, height, terrain);
        break;
      default:
        if (width === height && !(height & width - 1)) {
          terrain = getTerrain(data, width, height, elevationDecoder, "martini");
          mesh = getMartiniTileMesh(meshMaxError, width, terrain);
        } else {
          terrain = getTerrain(data, width, height, elevationDecoder, "delatin");
          mesh = getDelatinTileMesh(meshMaxError, width, height, terrain);
        }
        break;
    }
    const {
      vertices
    } = mesh;
    let {
      triangles
    } = mesh;
    let attributes = getMeshAttributes2(vertices, terrain, width, height, bounds);
    const boundingBox = getMeshBoundingBox(attributes);
    if (terrainOptions.skirtHeight) {
      const {
        attributes: newAttributes,
        triangles: newTriangles
      } = addSkirt(attributes, triangles, terrainOptions.skirtHeight);
      attributes = newAttributes;
      triangles = newTriangles;
    }
    return {
      loaderData: {
        header: {}
      },
      header: {
        vertexCount: triangles.length,
        boundingBox
      },
      mode: 4,
      indices: {
        value: Uint32Array.from(triangles),
        size: 1
      },
      attributes
    };
  }
  function getMartiniTileMesh(meshMaxError, width, terrain) {
    const gridSize = width + 1;
    const martini = new Martini(gridSize);
    const tile = martini.createTile(terrain);
    const {
      vertices,
      triangles
    } = tile.getMesh(meshMaxError);
    return {
      vertices,
      triangles
    };
  }
  function getDelatinTileMesh(meshMaxError, width, height, terrain) {
    const tin = new Delatin(terrain, width + 1, height + 1);
    tin.run(meshMaxError);
    const {
      coords,
      triangles
    } = tin;
    const vertices = coords;
    return {
      vertices,
      triangles
    };
  }
  async function loadTerrain(arrayBuffer, options, context) {
    const loadImageOptions = {
      ...options,
      mimeType: "application/x.image",
      image: {
        ...options.image,
        type: "data"
      }
    };
    const image = await context.parse(arrayBuffer, loadImageOptions);
    return getMesh(image, options.terrain);
  }

  // ../../node_modules/@loaders.gl/terrain/dist/esm/lib/utils/version.js
  var VERSION13 = true ? "3.3.1" : "latest";

  // ../../node_modules/@loaders.gl/terrain/dist/esm/terrain-loader.js
  var TerrainLoader = {
    name: "Terrain",
    id: "terrain",
    module: "terrain",
    version: VERSION13,
    worker: true,
    extensions: ["png", "pngraw", "jpg", "jpeg", "gif", "webp", "bmp"],
    mimeTypes: ["image/png", "image/jpeg", "image/gif", "image/webp", "image/bmp"],
    options: {
      terrain: {
        tesselator: "auto",
        bounds: null,
        meshMaxError: 10,
        elevationDecoder: {
          rScaler: 1,
          gScaler: 0,
          bScaler: 0,
          offset: 0
        },
        skirtHeight: null
      }
    }
  };

  // ../../node_modules/@loaders.gl/terrain/dist/esm/quantized-mesh-loader.js
  var QuantizedMeshLoader = {
    name: "Quantized Mesh",
    id: "quantized-mesh",
    module: "terrain",
    version: VERSION13,
    worker: true,
    extensions: ["terrain"],
    mimeTypes: ["application/vnd.quantized-mesh"],
    options: {
      "quantized-mesh": {
        bounds: [0, 0, 1, 1],
        skirtHeight: null
      }
    }
  };

  // ../../node_modules/@loaders.gl/terrain/dist/esm/index.js
  var TerrainLoader2 = {
    ...TerrainLoader,
    parse: loadTerrain
  };
  var QuantizedMeshLoader2 = {
    ...QuantizedMeshLoader,
    parseSync: loadQuantizedMesh,
    parse: async (arrayBuffer, options) => loadQuantizedMesh(arrayBuffer, options)
  };

  // src/terrain-layer/terrain-layer.ts
  var DUMMY_DATA = [1];
  var defaultProps12 = {
    ...TileLayer.defaultProps,
    elevationData: urlType,
    texture: {
      ...urlType,
      optional: true
    },
    meshMaxError: {
      type: "number",
      value: 4
    },
    bounds: {
      type: "array",
      value: null,
      optional: true,
      compare: true
    },
    color: {
      type: "color",
      value: [255, 255, 255]
    },
    elevationDecoder: {
      type: "object",
      value: {
        rScaler: 1,
        gScaler: 0,
        bScaler: 0,
        offset: 0
      }
    },
    workerUrl: "",
    wireframe: false,
    material: true,
    loaders: [TerrainLoader]
  };
  function urlTemplateToUpdateTrigger(template) {
    if (Array.isArray(template)) {
      return template.join(";");
    }
    return template || "";
  }
  var TerrainLayer = class extends import_core44.CompositeLayer {
    updateState({
      props,
      oldProps
    }) {
      const elevationDataChanged = props.elevationData !== oldProps.elevationData;
      if (elevationDataChanged) {
        const {
          elevationData
        } = props;
        const isTiled = elevationData && (Array.isArray(elevationData) || elevationData.includes("{x}") && elevationData.includes("{y}"));
        this.setState({
          isTiled
        });
      }
      const shouldReload = elevationDataChanged || props.meshMaxError !== oldProps.meshMaxError || props.elevationDecoder !== oldProps.elevationDecoder || props.bounds !== oldProps.bounds;
      if (!this.state.isTiled && shouldReload) {
        const terrain = this.loadTerrain(props);
        this.setState({
          terrain
        });
      }
      if (props.workerUrl) {
        import_core44.log.removed("workerUrl", "loadOptions.terrain.workerUrl")();
      }
    }
    loadTerrain({
      elevationData,
      bounds,
      elevationDecoder,
      meshMaxError,
      signal
    }) {
      if (!elevationData) {
        return null;
      }
      let loadOptions = this.getLoadOptions();
      loadOptions = {
        ...loadOptions,
        terrain: {
          skirtHeight: this.state.isTiled ? meshMaxError * 2 : 0,
          ...loadOptions?.terrain,
          bounds,
          meshMaxError,
          elevationDecoder
        }
      };
      const {
        fetch: fetch2
      } = this.props;
      return fetch2(elevationData, {
        propName: "elevationData",
        layer: this,
        loadOptions,
        signal
      });
    }
    getTiledTerrainData(tile) {
      const {
        elevationData,
        fetch: fetch2,
        texture,
        elevationDecoder,
        meshMaxError
      } = this.props;
      const {
        viewport
      } = this.context;
      const dataUrl = getURLFromTemplate(elevationData, tile);
      const textureUrl = texture && getURLFromTemplate(texture, tile);
      const {
        signal
      } = tile;
      let bottomLeft = [0, 0];
      let topRight = [0, 0];
      if (viewport.isGeospatial) {
        const bbox = tile.bbox;
        bottomLeft = viewport.projectFlat([bbox.west, bbox.south]);
        topRight = viewport.projectFlat([bbox.east, bbox.north]);
      } else {
        const bbox = tile.bbox;
        bottomLeft = [bbox.left, bbox.bottom];
        topRight = [bbox.right, bbox.top];
      }
      const bounds = [bottomLeft[0], bottomLeft[1], topRight[0], topRight[1]];
      const terrain = this.loadTerrain({
        elevationData: dataUrl,
        bounds,
        elevationDecoder,
        meshMaxError,
        signal
      });
      const surface = textureUrl ? fetch2(textureUrl, {
        propName: "texture",
        layer: this,
        loaders: [],
        signal
      }).catch((_) => null) : Promise.resolve(null);
      return Promise.all([terrain, surface]);
    }
    renderSubLayers(props) {
      const SubLayerClass = this.getSubLayerClass("mesh", import_mesh_layers3.SimpleMeshLayer);
      const {
        color,
        wireframe,
        material
      } = this.props;
      const {
        data
      } = props;
      if (!data) {
        return null;
      }
      const [mesh, texture] = data;
      return new SubLayerClass(props, {
        data: DUMMY_DATA,
        mesh,
        texture,
        _instanced: false,
        coordinateSystem: import_core45.COORDINATE_SYSTEM.CARTESIAN,
        getPosition: (d) => [0, 0, 0],
        getColor: color,
        wireframe,
        material
      });
    }
    onViewportLoad(tiles) {
      if (!tiles) {
        return;
      }
      const {
        zRange
      } = this.state;
      const ranges = tiles.map((tile) => tile.content).filter(Boolean).map((arr) => {
        const bounds = arr[0].header.boundingBox;
        return bounds.map((bound) => bound[2]);
      });
      if (ranges.length === 0) {
        return;
      }
      const minZ = Math.min(...ranges.map((x2) => x2[0]));
      const maxZ = Math.max(...ranges.map((x2) => x2[1]));
      if (!zRange || minZ < zRange[0] || maxZ > zRange[1]) {
        this.setState({
          zRange: [minZ, maxZ]
        });
      }
    }
    renderLayers() {
      const {
        color,
        material,
        elevationData,
        texture,
        wireframe,
        meshMaxError,
        elevationDecoder,
        tileSize,
        maxZoom,
        minZoom,
        extent,
        maxRequests,
        onTileLoad,
        onTileUnload,
        onTileError,
        maxCacheSize,
        maxCacheByteSize,
        refinementStrategy
      } = this.props;
      if (this.state.isTiled) {
        return new TileLayer(this.getSubLayerProps({
          id: "tiles"
        }), {
          getTileData: this.getTiledTerrainData.bind(this),
          renderSubLayers: this.renderSubLayers.bind(this),
          updateTriggers: {
            getTileData: {
              elevationData: urlTemplateToUpdateTrigger(elevationData),
              texture: urlTemplateToUpdateTrigger(texture),
              meshMaxError,
              elevationDecoder
            }
          },
          onViewportLoad: this.onViewportLoad.bind(this),
          zRange: this.state.zRange || null,
          tileSize,
          maxZoom,
          minZoom,
          extent,
          maxRequests,
          onTileLoad,
          onTileUnload,
          onTileError,
          maxCacheSize,
          maxCacheByteSize,
          refinementStrategy
        });
      }
      const SubLayerClass = this.getSubLayerClass("mesh", import_mesh_layers3.SimpleMeshLayer);
      return new SubLayerClass(this.getSubLayerProps({
        id: "mesh"
      }), {
        data: DUMMY_DATA,
        mesh: this.state.terrain,
        texture,
        _instanced: false,
        getPosition: (d) => [0, 0, 0],
        getColor: color,
        material,
        wireframe
      });
    }
  };
  __publicField(TerrainLayer, "defaultProps", defaultProps12);
  __publicField(TerrainLayer, "layerName", "TerrainLayer");

  // src/mvt-layer/mvt-layer.ts
  var import_core47 = __toESM(require_core());
  var import_layers9 = __toESM(require_layers());
  var import_extensions = __toESM(require_extensions());

  // ../../node_modules/@math.gl/polygon/dist/esm/polygon-utils.js
  function getPolygonSignedArea(points, options = {}) {
    const {
      start = 0,
      end = points.length
    } = options;
    const dim = options.size || 2;
    let area2 = 0;
    for (let i3 = start, j = end - dim; i3 < end; i3 += dim) {
      area2 += (points[i3] - points[j]) * (points[i3 + 1] + points[j + 1]);
      j = i3;
    }
    return area2 / 2;
  }

  // ../../node_modules/@math.gl/polygon/dist/esm/earcut.js
  function earcut(positions, holeIndices, dim = 2, areas) {
    const hasHoles = holeIndices && holeIndices.length;
    const outerLen = hasHoles ? holeIndices[0] * dim : positions.length;
    let outerNode = linkedList(positions, 0, outerLen, dim, true, areas && areas[0]);
    const triangles = [];
    if (!outerNode || outerNode.next === outerNode.prev)
      return triangles;
    let invSize;
    let maxX;
    let maxY;
    let minX;
    let minY;
    let x2;
    let y2;
    if (hasHoles)
      outerNode = eliminateHoles(positions, holeIndices, outerNode, dim, areas);
    if (positions.length > 80 * dim) {
      minX = maxX = positions[0];
      minY = maxY = positions[1];
      for (let i3 = dim; i3 < outerLen; i3 += dim) {
        x2 = positions[i3];
        y2 = positions[i3 + 1];
        if (x2 < minX)
          minX = x2;
        if (y2 < minY)
          minY = y2;
        if (x2 > maxX)
          maxX = x2;
        if (y2 > maxY)
          maxY = y2;
      }
      invSize = Math.max(maxX - minX, maxY - minY);
      invSize = invSize !== 0 ? 1 / invSize : 0;
    }
    earcutLinked(outerNode, triangles, dim, minX, minY, invSize);
    return triangles;
  }
  function linkedList(data, start, end, dim, clockwise, area2) {
    let i3;
    let last;
    if (area2 === void 0) {
      area2 = getPolygonSignedArea(data, {
        start,
        end,
        size: dim
      });
    }
    if (clockwise === area2 < 0) {
      for (i3 = start; i3 < end; i3 += dim)
        last = insertNode(i3, data[i3], data[i3 + 1], last);
    } else {
      for (i3 = end - dim; i3 >= start; i3 -= dim)
        last = insertNode(i3, data[i3], data[i3 + 1], last);
    }
    if (last && equals3(last, last.next)) {
      removeNode(last);
      last = last.next;
    }
    return last;
  }
  function filterPoints(start, end) {
    if (!start)
      return start;
    if (!end)
      end = start;
    let p2 = start;
    let again;
    do {
      again = false;
      if (!p2.steiner && (equals3(p2, p2.next) || area(p2.prev, p2, p2.next) === 0)) {
        removeNode(p2);
        p2 = end = p2.prev;
        if (p2 === p2.next)
          break;
        again = true;
      } else {
        p2 = p2.next;
      }
    } while (again || p2 !== end);
    return end;
  }
  function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
    if (!ear)
      return;
    if (!pass && invSize)
      indexCurve(ear, minX, minY, invSize);
    let stop = ear;
    let prev;
    let next;
    while (ear.prev !== ear.next) {
      prev = ear.prev;
      next = ear.next;
      if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
        triangles.push(prev.i / dim);
        triangles.push(ear.i / dim);
        triangles.push(next.i / dim);
        removeNode(ear);
        ear = next.next;
        stop = next.next;
        continue;
      }
      ear = next;
      if (ear === stop) {
        if (!pass) {
          earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
        } else if (pass === 1) {
          ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
          earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
        } else if (pass === 2) {
          splitEarcut(ear, triangles, dim, minX, minY, invSize);
        }
        break;
      }
    }
  }
  function isEar(ear) {
    const a2 = ear.prev;
    const b = ear;
    const c = ear.next;
    if (area(a2, b, c) >= 0)
      return false;
    let p2 = ear.next.next;
    while (p2 !== ear.prev) {
      if (pointInTriangle(a2.x, a2.y, b.x, b.y, c.x, c.y, p2.x, p2.y) && area(p2.prev, p2, p2.next) >= 0)
        return false;
      p2 = p2.next;
    }
    return true;
  }
  function isEarHashed(ear, minX, minY, invSize) {
    const a2 = ear.prev;
    const b = ear;
    const c = ear.next;
    if (area(a2, b, c) >= 0)
      return false;
    const minTX = a2.x < b.x ? a2.x < c.x ? a2.x : c.x : b.x < c.x ? b.x : c.x;
    const minTY = a2.y < b.y ? a2.y < c.y ? a2.y : c.y : b.y < c.y ? b.y : c.y;
    const maxTX = a2.x > b.x ? a2.x > c.x ? a2.x : c.x : b.x > c.x ? b.x : c.x;
    const maxTY = a2.y > b.y ? a2.y > c.y ? a2.y : c.y : b.y > c.y ? b.y : c.y;
    const minZ = zOrder(minTX, minTY, minX, minY, invSize);
    const maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);
    let p2 = ear.prevZ;
    let n2 = ear.nextZ;
    while (p2 && p2.z >= minZ && n2 && n2.z <= maxZ) {
      if (p2 !== ear.prev && p2 !== ear.next && pointInTriangle(a2.x, a2.y, b.x, b.y, c.x, c.y, p2.x, p2.y) && area(p2.prev, p2, p2.next) >= 0)
        return false;
      p2 = p2.prevZ;
      if (n2 !== ear.prev && n2 !== ear.next && pointInTriangle(a2.x, a2.y, b.x, b.y, c.x, c.y, n2.x, n2.y) && area(n2.prev, n2, n2.next) >= 0)
        return false;
      n2 = n2.nextZ;
    }
    while (p2 && p2.z >= minZ) {
      if (p2 !== ear.prev && p2 !== ear.next && pointInTriangle(a2.x, a2.y, b.x, b.y, c.x, c.y, p2.x, p2.y) && area(p2.prev, p2, p2.next) >= 0)
        return false;
      p2 = p2.prevZ;
    }
    while (n2 && n2.z <= maxZ) {
      if (n2 !== ear.prev && n2 !== ear.next && pointInTriangle(a2.x, a2.y, b.x, b.y, c.x, c.y, n2.x, n2.y) && area(n2.prev, n2, n2.next) >= 0)
        return false;
      n2 = n2.nextZ;
    }
    return true;
  }
  function cureLocalIntersections(start, triangles, dim) {
    let p2 = start;
    do {
      const a2 = p2.prev;
      const b = p2.next.next;
      if (!equals3(a2, b) && intersects(a2, p2, p2.next, b) && locallyInside(a2, b) && locallyInside(b, a2)) {
        triangles.push(a2.i / dim);
        triangles.push(p2.i / dim);
        triangles.push(b.i / dim);
        removeNode(p2);
        removeNode(p2.next);
        p2 = start = b;
      }
      p2 = p2.next;
    } while (p2 !== start);
    return filterPoints(p2);
  }
  function splitEarcut(start, triangles, dim, minX, minY, invSize) {
    let a2 = start;
    do {
      let b = a2.next.next;
      while (b !== a2.prev) {
        if (a2.i !== b.i && isValidDiagonal(a2, b)) {
          let c = splitPolygon(a2, b);
          a2 = filterPoints(a2, a2.next);
          c = filterPoints(c, c.next);
          earcutLinked(a2, triangles, dim, minX, minY, invSize);
          earcutLinked(c, triangles, dim, minX, minY, invSize);
          return;
        }
        b = b.next;
      }
      a2 = a2.next;
    } while (a2 !== start);
  }
  function eliminateHoles(data, holeIndices, outerNode, dim, areas) {
    const queue = [];
    let i3;
    let len2;
    let start;
    let end;
    let list;
    for (i3 = 0, len2 = holeIndices.length; i3 < len2; i3++) {
      start = holeIndices[i3] * dim;
      end = i3 < len2 - 1 ? holeIndices[i3 + 1] * dim : data.length;
      list = linkedList(data, start, end, dim, false, areas && areas[i3 + 1]);
      if (list === list.next)
        list.steiner = true;
      queue.push(getLeftmost(list));
    }
    queue.sort(compareX);
    for (i3 = 0; i3 < queue.length; i3++) {
      eliminateHole(queue[i3], outerNode);
      outerNode = filterPoints(outerNode, outerNode.next);
    }
    return outerNode;
  }
  function compareX(a2, b) {
    return a2.x - b.x;
  }
  function eliminateHole(hole, outerNode) {
    outerNode = findHoleBridge(hole, outerNode);
    if (outerNode) {
      const b = splitPolygon(outerNode, hole);
      filterPoints(outerNode, outerNode.next);
      filterPoints(b, b.next);
    }
  }
  function findHoleBridge(hole, outerNode) {
    let p2 = outerNode;
    const hx = hole.x;
    const hy = hole.y;
    let qx = -Infinity;
    let m;
    do {
      if (hy <= p2.y && hy >= p2.next.y && p2.next.y !== p2.y) {
        const x2 = p2.x + (hy - p2.y) * (p2.next.x - p2.x) / (p2.next.y - p2.y);
        if (x2 <= hx && x2 > qx) {
          qx = x2;
          if (x2 === hx) {
            if (hy === p2.y)
              return p2;
            if (hy === p2.next.y)
              return p2.next;
          }
          m = p2.x < p2.next.x ? p2 : p2.next;
        }
      }
      p2 = p2.next;
    } while (p2 !== outerNode);
    if (!m)
      return null;
    if (hx === qx)
      return m;
    const stop = m;
    const mx = m.x;
    const my = m.y;
    let tanMin = Infinity;
    let tan2;
    p2 = m;
    do {
      if (hx >= p2.x && p2.x >= mx && hx !== p2.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p2.x, p2.y)) {
        tan2 = Math.abs(hy - p2.y) / (hx - p2.x);
        if (locallyInside(p2, hole) && (tan2 < tanMin || tan2 === tanMin && (p2.x > m.x || p2.x === m.x && sectorContainsSector(m, p2)))) {
          m = p2;
          tanMin = tan2;
        }
      }
      p2 = p2.next;
    } while (p2 !== stop);
    return m;
  }
  function sectorContainsSector(m, p2) {
    return area(m.prev, m, p2.prev) < 0 && area(p2.next, m, m.next) < 0;
  }
  function indexCurve(start, minX, minY, invSize) {
    let p2 = start;
    do {
      if (p2.z === null)
        p2.z = zOrder(p2.x, p2.y, minX, minY, invSize);
      p2.prevZ = p2.prev;
      p2.nextZ = p2.next;
      p2 = p2.next;
    } while (p2 !== start);
    p2.prevZ.nextZ = null;
    p2.prevZ = null;
    sortLinked(p2);
  }
  function sortLinked(list) {
    let e;
    let i3;
    let inSize = 1;
    let numMerges;
    let p2;
    let pSize;
    let q;
    let qSize;
    let tail;
    do {
      p2 = list;
      list = null;
      tail = null;
      numMerges = 0;
      while (p2) {
        numMerges++;
        q = p2;
        pSize = 0;
        for (i3 = 0; i3 < inSize; i3++) {
          pSize++;
          q = q.nextZ;
          if (!q)
            break;
        }
        qSize = inSize;
        while (pSize > 0 || qSize > 0 && q) {
          if (pSize !== 0 && (qSize === 0 || !q || p2.z <= q.z)) {
            e = p2;
            p2 = p2.nextZ;
            pSize--;
          } else {
            e = q;
            q = q.nextZ;
            qSize--;
          }
          if (tail)
            tail.nextZ = e;
          else
            list = e;
          e.prevZ = tail;
          tail = e;
        }
        p2 = q;
      }
      tail.nextZ = null;
      inSize *= 2;
    } while (numMerges > 1);
    return list;
  }
  function zOrder(x2, y2, minX, minY, invSize) {
    x2 = 32767 * (x2 - minX) * invSize;
    y2 = 32767 * (y2 - minY) * invSize;
    x2 = (x2 | x2 << 8) & 16711935;
    x2 = (x2 | x2 << 4) & 252645135;
    x2 = (x2 | x2 << 2) & 858993459;
    x2 = (x2 | x2 << 1) & 1431655765;
    y2 = (y2 | y2 << 8) & 16711935;
    y2 = (y2 | y2 << 4) & 252645135;
    y2 = (y2 | y2 << 2) & 858993459;
    y2 = (y2 | y2 << 1) & 1431655765;
    return x2 | y2 << 1;
  }
  function getLeftmost(start) {
    let p2 = start;
    let leftmost = start;
    do {
      if (p2.x < leftmost.x || p2.x === leftmost.x && p2.y < leftmost.y)
        leftmost = p2;
      p2 = p2.next;
    } while (p2 !== start);
    return leftmost;
  }
  function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
    return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 && (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 && (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
  }
  function isValidDiagonal(a2, b) {
    return a2.next.i !== b.i && a2.prev.i !== b.i && !intersectsPolygon(a2, b) && (locallyInside(a2, b) && locallyInside(b, a2) && middleInside(a2, b) && (area(a2.prev, a2, b.prev) || area(a2, b.prev, b)) || equals3(a2, b) && area(a2.prev, a2, a2.next) > 0 && area(b.prev, b, b.next) > 0);
  }
  function area(p2, q, r2) {
    return (q.y - p2.y) * (r2.x - q.x) - (q.x - p2.x) * (r2.y - q.y);
  }
  function equals3(p1, p2) {
    return p1.x === p2.x && p1.y === p2.y;
  }
  function intersects(p1, q1, p2, q2) {
    const o1 = sign(area(p1, q1, p2));
    const o2 = sign(area(p1, q1, q2));
    const o3 = sign(area(p2, q2, p1));
    const o4 = sign(area(p2, q2, q1));
    if (o1 !== o2 && o3 !== o4)
      return true;
    if (o1 === 0 && onSegment(p1, p2, q1))
      return true;
    if (o2 === 0 && onSegment(p1, q2, q1))
      return true;
    if (o3 === 0 && onSegment(p2, p1, q2))
      return true;
    if (o4 === 0 && onSegment(p2, q1, q2))
      return true;
    return false;
  }
  function onSegment(p2, q, r2) {
    return q.x <= Math.max(p2.x, r2.x) && q.x >= Math.min(p2.x, r2.x) && q.y <= Math.max(p2.y, r2.y) && q.y >= Math.min(p2.y, r2.y);
  }
  function sign(num) {
    return num > 0 ? 1 : num < 0 ? -1 : 0;
  }
  function intersectsPolygon(a2, b) {
    let p2 = a2;
    do {
      if (p2.i !== a2.i && p2.next.i !== a2.i && p2.i !== b.i && p2.next.i !== b.i && intersects(p2, p2.next, a2, b))
        return true;
      p2 = p2.next;
    } while (p2 !== a2);
    return false;
  }
  function locallyInside(a2, b) {
    return area(a2.prev, a2, a2.next) < 0 ? area(a2, b, a2.next) >= 0 && area(a2, a2.prev, b) >= 0 : area(a2, b, a2.prev) < 0 || area(a2, a2.next, b) < 0;
  }
  function middleInside(a2, b) {
    let p2 = a2;
    let inside = false;
    const px = (a2.x + b.x) / 2;
    const py = (a2.y + b.y) / 2;
    do {
      if (p2.y > py !== p2.next.y > py && p2.next.y !== p2.y && px < (p2.next.x - p2.x) * (py - p2.y) / (p2.next.y - p2.y) + p2.x)
        inside = !inside;
      p2 = p2.next;
    } while (p2 !== a2);
    return inside;
  }
  function splitPolygon(a2, b) {
    const a22 = new Node(a2.i, a2.x, a2.y);
    const b2 = new Node(b.i, b.x, b.y);
    const an = a2.next;
    const bp = b.prev;
    a2.next = b;
    b.prev = a2;
    a22.next = an;
    an.prev = a22;
    b2.next = a22;
    a22.prev = b2;
    bp.next = b2;
    b2.prev = bp;
    return b2;
  }
  function insertNode(i3, x2, y2, last) {
    const p2 = new Node(i3, x2, y2);
    if (!last) {
      p2.prev = p2;
      p2.next = p2;
    } else {
      p2.next = last.next;
      p2.prev = last;
      last.next.prev = p2;
      last.next = p2;
    }
    return p2;
  }
  function removeNode(p2) {
    p2.next.prev = p2.prev;
    p2.prev.next = p2.next;
    if (p2.prevZ)
      p2.prevZ.nextZ = p2.nextZ;
    if (p2.nextZ)
      p2.nextZ.prevZ = p2.prevZ;
  }
  function Node(i3, x2, y2) {
    this.i = i3;
    this.x = x2;
    this.y = y2;
    this.prev = null;
    this.next = null;
    this.z = null;
    this.prevZ = null;
    this.nextZ = null;
    this.steiner = false;
  }

  // ../../node_modules/@loaders.gl/gis/dist/esm/lib/flat-geojson-to-binary.js
  function flatGeojsonToBinary(features, geometryInfo, options) {
    const propArrayTypes = extractNumericPropTypes(features);
    const numericPropKeys = Object.keys(propArrayTypes).filter((k) => propArrayTypes[k] !== Array);
    return fillArrays(features, {
      propArrayTypes,
      ...geometryInfo
    }, {
      numericPropKeys: options && options.numericPropKeys || numericPropKeys,
      PositionDataType: options ? options.PositionDataType : Float32Array
    });
  }
  function extractNumericPropTypes(features) {
    const propArrayTypes = {};
    for (const feature of features) {
      if (feature.properties) {
        for (const key in feature.properties) {
          const val = feature.properties[key];
          propArrayTypes[key] = deduceArrayType(val, propArrayTypes[key]);
        }
      }
    }
    return propArrayTypes;
  }
  function fillArrays(features, geometryInfo, options) {
    const {
      pointPositionsCount,
      pointFeaturesCount,
      linePositionsCount,
      linePathsCount,
      lineFeaturesCount,
      polygonPositionsCount,
      polygonObjectsCount,
      polygonRingsCount,
      polygonFeaturesCount,
      propArrayTypes,
      coordLength
    } = geometryInfo;
    const {
      numericPropKeys = [],
      PositionDataType = Float32Array
    } = options;
    const hasGlobalId = features[0] && "id" in features[0];
    const GlobalFeatureIdsDataType = features.length > 65535 ? Uint32Array : Uint16Array;
    const points = {
      type: "Point",
      positions: new PositionDataType(pointPositionsCount * coordLength),
      globalFeatureIds: new GlobalFeatureIdsDataType(pointPositionsCount),
      featureIds: pointFeaturesCount > 65535 ? new Uint32Array(pointPositionsCount) : new Uint16Array(pointPositionsCount),
      numericProps: {},
      properties: [],
      fields: []
    };
    const lines = {
      type: "LineString",
      pathIndices: linePositionsCount > 65535 ? new Uint32Array(linePathsCount + 1) : new Uint16Array(linePathsCount + 1),
      positions: new PositionDataType(linePositionsCount * coordLength),
      globalFeatureIds: new GlobalFeatureIdsDataType(linePositionsCount),
      featureIds: lineFeaturesCount > 65535 ? new Uint32Array(linePositionsCount) : new Uint16Array(linePositionsCount),
      numericProps: {},
      properties: [],
      fields: []
    };
    const polygons = {
      type: "Polygon",
      polygonIndices: polygonPositionsCount > 65535 ? new Uint32Array(polygonObjectsCount + 1) : new Uint16Array(polygonObjectsCount + 1),
      primitivePolygonIndices: polygonPositionsCount > 65535 ? new Uint32Array(polygonRingsCount + 1) : new Uint16Array(polygonRingsCount + 1),
      positions: new PositionDataType(polygonPositionsCount * coordLength),
      triangles: [],
      globalFeatureIds: new GlobalFeatureIdsDataType(polygonPositionsCount),
      featureIds: polygonFeaturesCount > 65535 ? new Uint32Array(polygonPositionsCount) : new Uint16Array(polygonPositionsCount),
      numericProps: {},
      properties: [],
      fields: []
    };
    for (const object of [points, lines, polygons]) {
      for (const propName of numericPropKeys) {
        const T = propArrayTypes[propName];
        object.numericProps[propName] = new T(object.positions.length / coordLength);
      }
    }
    lines.pathIndices[linePathsCount] = linePositionsCount;
    polygons.polygonIndices[polygonObjectsCount] = polygonPositionsCount;
    polygons.primitivePolygonIndices[polygonRingsCount] = polygonPositionsCount;
    const indexMap = {
      pointPosition: 0,
      pointFeature: 0,
      linePosition: 0,
      linePath: 0,
      lineFeature: 0,
      polygonPosition: 0,
      polygonObject: 0,
      polygonRing: 0,
      polygonFeature: 0,
      feature: 0
    };
    for (const feature of features) {
      const geometry = feature.geometry;
      const properties = feature.properties || {};
      switch (geometry.type) {
        case "Point":
          handlePoint(geometry, points, indexMap, coordLength, properties);
          points.properties.push(keepStringProperties(properties, numericPropKeys));
          if (hasGlobalId) {
            points.fields.push({
              id: feature.id
            });
          }
          indexMap.pointFeature++;
          break;
        case "LineString":
          handleLineString(geometry, lines, indexMap, coordLength, properties);
          lines.properties.push(keepStringProperties(properties, numericPropKeys));
          if (hasGlobalId) {
            lines.fields.push({
              id: feature.id
            });
          }
          indexMap.lineFeature++;
          break;
        case "Polygon":
          handlePolygon(geometry, polygons, indexMap, coordLength, properties);
          polygons.properties.push(keepStringProperties(properties, numericPropKeys));
          if (hasGlobalId) {
            polygons.fields.push({
              id: feature.id
            });
          }
          indexMap.polygonFeature++;
          break;
        default:
          throw new Error("Invalid geometry type");
      }
      indexMap.feature++;
    }
    return makeAccessorObjects(points, lines, polygons, coordLength);
  }
  function handlePoint(geometry, points, indexMap, coordLength, properties) {
    points.positions.set(geometry.data, indexMap.pointPosition * coordLength);
    const nPositions = geometry.data.length / coordLength;
    fillNumericProperties(points, properties, indexMap.pointPosition, nPositions);
    points.globalFeatureIds.fill(indexMap.feature, indexMap.pointPosition, indexMap.pointPosition + nPositions);
    points.featureIds.fill(indexMap.pointFeature, indexMap.pointPosition, indexMap.pointPosition + nPositions);
    indexMap.pointPosition += nPositions;
  }
  function handleLineString(geometry, lines, indexMap, coordLength, properties) {
    lines.positions.set(geometry.data, indexMap.linePosition * coordLength);
    const nPositions = geometry.data.length / coordLength;
    fillNumericProperties(lines, properties, indexMap.linePosition, nPositions);
    lines.globalFeatureIds.fill(indexMap.feature, indexMap.linePosition, indexMap.linePosition + nPositions);
    lines.featureIds.fill(indexMap.lineFeature, indexMap.linePosition, indexMap.linePosition + nPositions);
    for (let i3 = 0, il = geometry.indices.length; i3 < il; ++i3) {
      const start = geometry.indices[i3];
      const end = i3 === il - 1 ? geometry.data.length : geometry.indices[i3 + 1];
      lines.pathIndices[indexMap.linePath++] = indexMap.linePosition;
      indexMap.linePosition += (end - start) / coordLength;
    }
  }
  function handlePolygon(geometry, polygons, indexMap, coordLength, properties) {
    polygons.positions.set(geometry.data, indexMap.polygonPosition * coordLength);
    const nPositions = geometry.data.length / coordLength;
    fillNumericProperties(polygons, properties, indexMap.polygonPosition, nPositions);
    polygons.globalFeatureIds.fill(indexMap.feature, indexMap.polygonPosition, indexMap.polygonPosition + nPositions);
    polygons.featureIds.fill(indexMap.polygonFeature, indexMap.polygonPosition, indexMap.polygonPosition + nPositions);
    for (let l2 = 0, ll = geometry.indices.length; l2 < ll; ++l2) {
      const startPosition = indexMap.polygonPosition;
      polygons.polygonIndices[indexMap.polygonObject++] = startPosition;
      const areas = geometry.areas[l2];
      const indices = geometry.indices[l2];
      const nextIndices = geometry.indices[l2 + 1];
      for (let i3 = 0, il = indices.length; i3 < il; ++i3) {
        const start = indices[i3];
        const end = i3 === il - 1 ? nextIndices === void 0 ? geometry.data.length : nextIndices[0] : indices[i3 + 1];
        polygons.primitivePolygonIndices[indexMap.polygonRing++] = indexMap.polygonPosition;
        indexMap.polygonPosition += (end - start) / coordLength;
      }
      const endPosition = indexMap.polygonPosition;
      triangulatePolygon(polygons, areas, indices, {
        startPosition,
        endPosition,
        coordLength
      });
    }
  }
  function triangulatePolygon(polygons, areas, indices, _ref) {
    let {
      startPosition,
      endPosition,
      coordLength
    } = _ref;
    const start = startPosition * coordLength;
    const end = endPosition * coordLength;
    const polygonPositions = polygons.positions.subarray(start, end);
    const offset = indices[0];
    const holes = indices.slice(1).map((n2) => (n2 - offset) / coordLength);
    const triangles = earcut(polygonPositions, holes, coordLength, areas);
    for (let t2 = 0, tl = triangles.length; t2 < tl; ++t2) {
      polygons.triangles.push(startPosition + triangles[t2]);
    }
  }
  function wrapProps(obj, size) {
    const returnObj = {};
    for (const key in obj) {
      returnObj[key] = {
        value: obj[key],
        size
      };
    }
    return returnObj;
  }
  function makeAccessorObjects(points, lines, polygons, coordLength) {
    return {
      points: {
        ...points,
        positions: {
          value: points.positions,
          size: coordLength
        },
        globalFeatureIds: {
          value: points.globalFeatureIds,
          size: 1
        },
        featureIds: {
          value: points.featureIds,
          size: 1
        },
        numericProps: wrapProps(points.numericProps, 1)
      },
      lines: {
        ...lines,
        positions: {
          value: lines.positions,
          size: coordLength
        },
        pathIndices: {
          value: lines.pathIndices,
          size: 1
        },
        globalFeatureIds: {
          value: lines.globalFeatureIds,
          size: 1
        },
        featureIds: {
          value: lines.featureIds,
          size: 1
        },
        numericProps: wrapProps(lines.numericProps, 1)
      },
      polygons: {
        ...polygons,
        positions: {
          value: polygons.positions,
          size: coordLength
        },
        polygonIndices: {
          value: polygons.polygonIndices,
          size: 1
        },
        primitivePolygonIndices: {
          value: polygons.primitivePolygonIndices,
          size: 1
        },
        triangles: {
          value: new Uint32Array(polygons.triangles),
          size: 1
        },
        globalFeatureIds: {
          value: polygons.globalFeatureIds,
          size: 1
        },
        featureIds: {
          value: polygons.featureIds,
          size: 1
        },
        numericProps: wrapProps(polygons.numericProps, 1)
      }
    };
  }
  function fillNumericProperties(object, properties, index, length5) {
    for (const numericPropName in object.numericProps) {
      if (numericPropName in properties) {
        const value = properties[numericPropName];
        object.numericProps[numericPropName].fill(value, index, index + length5);
      }
    }
  }
  function keepStringProperties(properties, numericKeys) {
    const props = {};
    for (const key in properties) {
      if (!numericKeys.includes(key)) {
        props[key] = properties[key];
      }
    }
    return props;
  }
  function deduceArrayType(x2, constructor) {
    if (constructor === Array || !Number.isFinite(x2)) {
      return Array;
    }
    return constructor === Float64Array || Math.fround(x2) !== x2 ? Float64Array : Float32Array;
  }

  // ../../node_modules/@loaders.gl/gis/dist/esm/lib/binary-to-geojson.js
  function binaryToGeojson(data, options) {
    const globalFeatureId = options === null || options === void 0 ? void 0 : options.globalFeatureId;
    if (globalFeatureId !== void 0) {
      return getSingleFeature(data, globalFeatureId);
    }
    return parseFeatures(data, options === null || options === void 0 ? void 0 : options.type);
  }
  function getSingleFeature(data, globalFeatureId) {
    const dataArray = normalizeInput(data);
    for (const data2 of dataArray) {
      let lastIndex = 0;
      let lastValue = data2.featureIds.value[0];
      for (let i3 = 0; i3 < data2.featureIds.value.length; i3++) {
        const currValue = data2.featureIds.value[i3];
        if (currValue === lastValue) {
          continue;
        }
        if (globalFeatureId === data2.globalFeatureIds.value[lastIndex]) {
          return parseFeature(data2, lastIndex, i3);
        }
        lastIndex = i3;
        lastValue = currValue;
      }
      if (globalFeatureId === data2.globalFeatureIds.value[lastIndex]) {
        return parseFeature(data2, lastIndex, data2.featureIds.value.length);
      }
    }
    throw new Error("featureId:".concat(globalFeatureId, " not found"));
  }
  function parseFeatures(data, type) {
    const dataArray = normalizeInput(data, type);
    return parseFeatureCollection(dataArray);
  }
  function binaryToGeometry(data, startIndex, endIndex) {
    switch (data.type) {
      case "Point":
        return pointToGeoJson(data, startIndex, endIndex);
      case "LineString":
        return lineStringToGeoJson(data, startIndex, endIndex);
      case "Polygon":
        return polygonToGeoJson(data, startIndex, endIndex);
      default:
        const unexpectedInput = data;
        throw new Error("Unsupported geometry type: ".concat(unexpectedInput === null || unexpectedInput === void 0 ? void 0 : unexpectedInput.type));
    }
  }
  function normalizeInput(data, type) {
    const isHeterogeneousType = Boolean(data.points || data.lines || data.polygons);
    if (!isHeterogeneousType) {
      data.type = type || parseType(data);
      return [data];
    }
    const features = [];
    if (data.points) {
      data.points.type = "Point";
      features.push(data.points);
    }
    if (data.lines) {
      data.lines.type = "LineString";
      features.push(data.lines);
    }
    if (data.polygons) {
      data.polygons.type = "Polygon";
      features.push(data.polygons);
    }
    return features;
  }
  function parseFeatureCollection(dataArray) {
    const features = [];
    for (const data of dataArray) {
      if (data.featureIds.value.length === 0) {
        continue;
      }
      let lastIndex = 0;
      let lastValue = data.featureIds.value[0];
      for (let i3 = 0; i3 < data.featureIds.value.length; i3++) {
        const currValue = data.featureIds.value[i3];
        if (currValue === lastValue) {
          continue;
        }
        features.push(parseFeature(data, lastIndex, i3));
        lastIndex = i3;
        lastValue = currValue;
      }
      features.push(parseFeature(data, lastIndex, data.featureIds.value.length));
    }
    return features;
  }
  function parseFeature(data, startIndex, endIndex) {
    const geometry = binaryToGeometry(data, startIndex, endIndex);
    const properties = parseProperties(data, startIndex, endIndex);
    const fields = parseFields(data, startIndex, endIndex);
    return {
      type: "Feature",
      geometry,
      properties,
      ...fields
    };
  }
  function parseFields(data) {
    let startIndex = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    let endIndex = arguments.length > 2 ? arguments[2] : void 0;
    return data.fields && data.fields[data.featureIds.value[startIndex]];
  }
  function parseProperties(data) {
    let startIndex = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    let endIndex = arguments.length > 2 ? arguments[2] : void 0;
    const properties = Object.assign({}, data.properties[data.featureIds.value[startIndex]]);
    for (const key in data.numericProps) {
      properties[key] = data.numericProps[key].value[startIndex];
    }
    return properties;
  }
  function polygonToGeoJson(data) {
    let startIndex = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : -Infinity;
    let endIndex = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Infinity;
    const {
      positions
    } = data;
    const polygonIndices = data.polygonIndices.value.filter((x2) => x2 >= startIndex && x2 <= endIndex);
    const primitivePolygonIndices = data.primitivePolygonIndices.value.filter((x2) => x2 >= startIndex && x2 <= endIndex);
    const multi = polygonIndices.length > 2;
    if (!multi) {
      const coordinates2 = [];
      for (let i3 = 0; i3 < primitivePolygonIndices.length - 1; i3++) {
        const startRingIndex = primitivePolygonIndices[i3];
        const endRingIndex = primitivePolygonIndices[i3 + 1];
        const ringCoordinates = ringToGeoJson(positions, startRingIndex, endRingIndex);
        coordinates2.push(ringCoordinates);
      }
      return {
        type: "Polygon",
        coordinates: coordinates2
      };
    }
    const coordinates = [];
    for (let i3 = 0; i3 < polygonIndices.length - 1; i3++) {
      const startPolygonIndex = polygonIndices[i3];
      const endPolygonIndex = polygonIndices[i3 + 1];
      const polygonCoordinates = polygonToGeoJson(data, startPolygonIndex, endPolygonIndex).coordinates;
      coordinates.push(polygonCoordinates);
    }
    return {
      type: "MultiPolygon",
      coordinates
    };
  }
  function lineStringToGeoJson(data) {
    let startIndex = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : -Infinity;
    let endIndex = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Infinity;
    const {
      positions
    } = data;
    const pathIndices = data.pathIndices.value.filter((x2) => x2 >= startIndex && x2 <= endIndex);
    const multi = pathIndices.length > 2;
    if (!multi) {
      const coordinates2 = ringToGeoJson(positions, pathIndices[0], pathIndices[1]);
      return {
        type: "LineString",
        coordinates: coordinates2
      };
    }
    const coordinates = [];
    for (let i3 = 0; i3 < pathIndices.length - 1; i3++) {
      const ringCoordinates = ringToGeoJson(positions, pathIndices[i3], pathIndices[i3 + 1]);
      coordinates.push(ringCoordinates);
    }
    return {
      type: "MultiLineString",
      coordinates
    };
  }
  function pointToGeoJson(data, startIndex, endIndex) {
    const {
      positions
    } = data;
    const coordinates = ringToGeoJson(positions, startIndex, endIndex);
    const multi = coordinates.length > 1;
    if (multi) {
      return {
        type: "MultiPoint",
        coordinates
      };
    }
    return {
      type: "Point",
      coordinates: coordinates[0]
    };
  }
  function ringToGeoJson(positions, startIndex, endIndex) {
    startIndex = startIndex || 0;
    endIndex = endIndex || positions.value.length / positions.size;
    const ringCoordinates = [];
    for (let j = startIndex; j < endIndex; j++) {
      const coord = Array();
      for (let k = j * positions.size; k < (j + 1) * positions.size; k++) {
        coord.push(Number(positions.value[k]));
      }
      ringCoordinates.push(coord);
    }
    return ringCoordinates;
  }
  function parseType(data) {
    if (data.pathIndices) {
      return "LineString";
    }
    if (data.polygonIndices) {
      return "Polygon";
    }
    return "Point";
  }

  // ../../node_modules/@loaders.gl/mvt/dist/esm/lib/parse-mvt.js
  var import_pbf = __toESM(require_pbf());

  // ../../node_modules/@loaders.gl/mvt/dist/esm/helpers/mapbox-util-functions.js
  function classifyRings(rings) {
    const len2 = rings.length;
    if (len2 <= 1)
      return [rings];
    const polygons = [];
    let polygon;
    let ccw;
    for (let i3 = 0; i3 < len2; i3++) {
      const area2 = signedArea(rings[i3]);
      if (area2 === 0)
        continue;
      if (ccw === void 0)
        ccw = area2 < 0;
      if (ccw === area2 < 0) {
        if (polygon)
          polygons.push(polygon);
        polygon = [rings[i3]];
      } else if (polygon)
        polygon.push(rings[i3]);
    }
    if (polygon)
      polygons.push(polygon);
    return polygons;
  }
  function signedArea(ring) {
    let sum = 0;
    for (let i3 = 0, j = ring.length - 1, p1, p2; i3 < ring.length; j = i3++) {
      p1 = ring[i3];
      p2 = ring[j];
      sum += (p2[0] - p1[0]) * (p1[1] + p2[1]);
    }
    return sum;
  }
  function readFeature(tag, feature, pbf) {
    if (feature && pbf) {
      if (tag === 1)
        feature.id = pbf.readVarint();
      else if (tag === 2)
        readTag(pbf, feature);
      else if (tag === 3)
        feature.type = pbf.readVarint();
      else if (tag === 4)
        feature._geometry = pbf.pos;
    }
  }
  function readTag(pbf, feature) {
    const end = pbf.readVarint() + pbf.pos;
    while (pbf.pos < end) {
      const key = feature._keys[pbf.readVarint()];
      const value = feature._values[pbf.readVarint()];
      feature.properties[key] = value;
    }
  }

  // ../../node_modules/@loaders.gl/mvt/dist/esm/lib/mapbox-vector-tile/vector-tile-feature.js
  var VectorTileFeature = class {
    static get types() {
      return ["Unknown", "Point", "LineString", "Polygon"];
    }
    constructor(pbf, end, extent, keys, values) {
      _defineProperty(this, "properties", void 0);
      _defineProperty(this, "extent", void 0);
      _defineProperty(this, "type", void 0);
      _defineProperty(this, "id", void 0);
      _defineProperty(this, "_pbf", void 0);
      _defineProperty(this, "_geometry", void 0);
      _defineProperty(this, "_keys", void 0);
      _defineProperty(this, "_values", void 0);
      this.properties = {};
      this.extent = extent;
      this.type = 0;
      this.id = null;
      this._pbf = pbf;
      this._geometry = -1;
      this._keys = keys;
      this._values = values;
      pbf.readFields(readFeature, this, end);
    }
    loadGeometry() {
      const pbf = this._pbf;
      pbf.pos = this._geometry;
      const end = pbf.readVarint() + pbf.pos;
      let cmd2 = 1;
      let length5 = 0;
      let x2 = 0;
      let y2 = 0;
      const lines = [];
      let line;
      while (pbf.pos < end) {
        if (length5 <= 0) {
          const cmdLen2 = pbf.readVarint();
          cmd2 = cmdLen2 & 7;
          length5 = cmdLen2 >> 3;
        }
        length5--;
        if (cmd2 === 1 || cmd2 === 2) {
          x2 += pbf.readSVarint();
          y2 += pbf.readSVarint();
          if (cmd2 === 1) {
            if (line)
              lines.push(line);
            line = [];
          }
          if (line)
            line.push([x2, y2]);
        } else if (cmd2 === 7) {
          if (line) {
            line.push(line[0].slice());
          }
        } else {
          throw new Error("unknown command ".concat(cmd2));
        }
      }
      if (line)
        lines.push(line);
      return lines;
    }
    bbox() {
      const pbf = this._pbf;
      pbf.pos = this._geometry;
      const end = pbf.readVarint() + pbf.pos;
      let cmd2 = 1;
      let length5 = 0;
      let x2 = 0;
      let y2 = 0;
      let x1 = Infinity;
      let x22 = -Infinity;
      let y1 = Infinity;
      let y22 = -Infinity;
      while (pbf.pos < end) {
        if (length5 <= 0) {
          const cmdLen2 = pbf.readVarint();
          cmd2 = cmdLen2 & 7;
          length5 = cmdLen2 >> 3;
        }
        length5--;
        if (cmd2 === 1 || cmd2 === 2) {
          x2 += pbf.readSVarint();
          y2 += pbf.readSVarint();
          if (x2 < x1)
            x1 = x2;
          if (x2 > x22)
            x22 = x2;
          if (y2 < y1)
            y1 = y2;
          if (y2 > y22)
            y22 = y2;
        } else if (cmd2 !== 7) {
          throw new Error("unknown command ".concat(cmd2));
        }
      }
      return [x1, y1, x22, y22];
    }
    _toGeoJSON(transform2) {
      let coords = this.loadGeometry();
      let type = VectorTileFeature.types[this.type];
      let i3;
      let j;
      switch (this.type) {
        case 1:
          const points = [];
          for (i3 = 0; i3 < coords.length; i3++) {
            points[i3] = coords[i3][0];
          }
          coords = points;
          transform2(coords, this);
          break;
        case 2:
          for (i3 = 0; i3 < coords.length; i3++) {
            transform2(coords[i3], this);
          }
          break;
        case 3:
          coords = classifyRings(coords);
          for (i3 = 0; i3 < coords.length; i3++) {
            for (j = 0; j < coords[i3].length; j++) {
              transform2(coords[i3][j], this);
            }
          }
          break;
      }
      if (coords.length === 1) {
        coords = coords[0];
      } else {
        type = "Multi".concat(type);
      }
      const result = {
        type: "Feature",
        geometry: {
          type,
          coordinates: coords
        },
        properties: this.properties
      };
      if (this.id !== null) {
        result.id = this.id;
      }
      return result;
    }
    toGeoJSON(options) {
      if (typeof options === "function") {
        return this._toGeoJSON(options);
      }
      const {
        x: x2,
        y: y2,
        z
      } = options;
      const size = this.extent * Math.pow(2, z);
      const x0 = this.extent * x2;
      const y0 = this.extent * y2;
      function project2(line) {
        for (let j = 0; j < line.length; j++) {
          const p2 = line[j];
          p2[0] = (p2[0] + x0) * 360 / size - 180;
          const y22 = 180 - (p2[1] + y0) * 360 / size;
          p2[1] = 360 / Math.PI * Math.atan(Math.exp(y22 * Math.PI / 180)) - 90;
        }
      }
      return this._toGeoJSON(project2);
    }
  };

  // ../../node_modules/@loaders.gl/mvt/dist/esm/lib/mapbox-vector-tile/vector-tile-layer.js
  var VectorTileLayer = class {
    constructor(pbf, end) {
      _defineProperty(this, "version", void 0);
      _defineProperty(this, "name", void 0);
      _defineProperty(this, "extent", void 0);
      _defineProperty(this, "length", void 0);
      _defineProperty(this, "_pbf", void 0);
      _defineProperty(this, "_keys", void 0);
      _defineProperty(this, "_values", void 0);
      _defineProperty(this, "_features", void 0);
      this.version = 1;
      this.name = "";
      this.extent = 4096;
      this.length = 0;
      this._pbf = pbf;
      this._keys = [];
      this._values = [];
      this._features = [];
      pbf.readFields(readLayer, this, end);
      this.length = this._features.length;
    }
    feature(i3) {
      if (i3 < 0 || i3 >= this._features.length) {
        throw new Error("feature index out of bounds");
      }
      this._pbf.pos = this._features[i3];
      const end = this._pbf.readVarint() + this._pbf.pos;
      return new VectorTileFeature(this._pbf, end, this.extent, this._keys, this._values);
    }
  };
  function readLayer(tag, layer, pbf) {
    if (layer && pbf) {
      if (tag === 15)
        layer.version = pbf.readVarint();
      else if (tag === 1)
        layer.name = pbf.readString();
      else if (tag === 5)
        layer.extent = pbf.readVarint();
      else if (tag === 2)
        layer._features.push(pbf.pos);
      else if (tag === 3)
        layer._keys.push(pbf.readString());
      else if (tag === 4)
        layer._values.push(readValueMessage(pbf));
    }
  }
  function readValueMessage(pbf) {
    let value = null;
    const end = pbf.readVarint() + pbf.pos;
    while (pbf.pos < end) {
      const tag = pbf.readVarint() >> 3;
      value = tag === 1 ? pbf.readString() : tag === 2 ? pbf.readFloat() : tag === 3 ? pbf.readDouble() : tag === 4 ? pbf.readVarint64() : tag === 5 ? pbf.readVarint() : tag === 6 ? pbf.readSVarint() : tag === 7 ? pbf.readBoolean() : null;
    }
    return value;
  }

  // ../../node_modules/@loaders.gl/mvt/dist/esm/lib/mapbox-vector-tile/vector-tile.js
  var VectorTile = class {
    constructor(pbf, end) {
      _defineProperty(this, "layers", void 0);
      this.layers = pbf.readFields(readTile, {}, end);
    }
  };
  function readTile(tag, layers, pbf) {
    if (tag === 3) {
      if (pbf) {
        const layer = new VectorTileLayer(pbf, pbf.readVarint() + pbf.pos);
        if (layer.length && layers) {
          layers[layer.name] = layer;
        }
      }
    }
  }

  // ../../node_modules/@loaders.gl/mvt/dist/esm/helpers/binary-util-functions.js
  function classifyRings2(geom) {
    const len2 = geom.indices.length;
    const type = "Polygon";
    if (len2 <= 1) {
      return {
        type,
        data: geom.data,
        areas: [[getPolygonSignedArea(geom.data)]],
        indices: [geom.indices]
      };
    }
    const areas = [];
    const polygons = [];
    let ringAreas = [];
    let polygon = [];
    let ccw;
    let offset = 0;
    for (let endIndex, i3 = 0, startIndex; i3 < len2; i3++) {
      startIndex = geom.indices[i3] - offset;
      endIndex = geom.indices[i3 + 1] - offset || geom.data.length;
      const shape = geom.data.slice(startIndex, endIndex);
      const area2 = getPolygonSignedArea(shape);
      if (area2 === 0) {
        const before = geom.data.slice(0, startIndex);
        const after = geom.data.slice(endIndex);
        geom.data = before.concat(after);
        offset += endIndex - startIndex;
        continue;
      }
      if (ccw === void 0)
        ccw = area2 < 0;
      if (ccw === area2 < 0) {
        if (polygon.length) {
          areas.push(ringAreas);
          polygons.push(polygon);
        }
        polygon = [startIndex];
        ringAreas = [area2];
      } else {
        ringAreas.push(area2);
        polygon.push(startIndex);
      }
    }
    if (ringAreas)
      areas.push(ringAreas);
    if (polygon.length)
      polygons.push(polygon);
    return {
      type,
      areas,
      indices: polygons,
      data: geom.data
    };
  }
  function project(data, x0, y0, size) {
    for (let j = 0, jl = data.length; j < jl; j += 2) {
      data[j] = (data[j] + x0) * 360 / size - 180;
      const y2 = 180 - (data[j + 1] + y0) * 360 / size;
      data[j + 1] = 360 / Math.PI * Math.atan(Math.exp(y2 * Math.PI / 180)) - 90;
    }
  }
  function readFeature2(tag, feature, pbf) {
    if (feature && pbf) {
      if (tag === 1)
        feature.id = pbf.readVarint();
      else if (tag === 2)
        readTag2(pbf, feature);
      else if (tag === 3)
        feature.type = pbf.readVarint();
      else if (tag === 4)
        feature._geometry = pbf.pos;
    }
  }
  function readTag2(pbf, feature) {
    const end = pbf.readVarint() + pbf.pos;
    while (pbf.pos < end) {
      const key = feature._keys[pbf.readVarint()];
      const value = feature._values[pbf.readVarint()];
      feature.properties[key] = value;
    }
  }

  // ../../node_modules/@loaders.gl/mvt/dist/esm/lib/binary-vector-tile/vector-tile-feature.js
  var endPos;
  var cmd;
  var cmdLen;
  var length4;
  var x;
  var y;
  var i2;
  var VectorTileFeature2 = class {
    constructor(pbf, end, extent, keys, values, geometryInfo) {
      _defineProperty(this, "properties", void 0);
      _defineProperty(this, "extent", void 0);
      _defineProperty(this, "type", void 0);
      _defineProperty(this, "id", void 0);
      _defineProperty(this, "_pbf", void 0);
      _defineProperty(this, "_geometry", void 0);
      _defineProperty(this, "_keys", void 0);
      _defineProperty(this, "_values", void 0);
      _defineProperty(this, "_geometryInfo", void 0);
      this.properties = {};
      this.extent = extent;
      this.type = 0;
      this.id = null;
      this._pbf = pbf;
      this._geometry = -1;
      this._keys = keys;
      this._values = values;
      this._geometryInfo = geometryInfo;
      pbf.readFields(readFeature2, this, end);
    }
    loadGeometry() {
      const pbf = this._pbf;
      pbf.pos = this._geometry;
      endPos = pbf.readVarint() + pbf.pos;
      cmd = 1;
      length4 = 0;
      x = 0;
      y = 0;
      i2 = 0;
      const indices = [];
      const data = [];
      while (pbf.pos < endPos) {
        if (length4 <= 0) {
          cmdLen = pbf.readVarint();
          cmd = cmdLen & 7;
          length4 = cmdLen >> 3;
        }
        length4--;
        if (cmd === 1 || cmd === 2) {
          x += pbf.readSVarint();
          y += pbf.readSVarint();
          if (cmd === 1) {
            indices.push(i2);
          }
          data.push(x, y);
          i2 += 2;
        } else if (cmd === 7) {
          if (i2 > 0) {
            const start = indices[indices.length - 1];
            data.push(data[start], data[start + 1]);
            i2 += 2;
          }
        } else {
          throw new Error("unknown command ".concat(cmd));
        }
      }
      return {
        data,
        indices
      };
    }
    _toBinaryCoordinates(transform2) {
      const geom = this.loadGeometry();
      let geometry;
      transform2(geom.data, this);
      const coordLength = 2;
      switch (this.type) {
        case 1:
          this._geometryInfo.pointFeaturesCount++;
          this._geometryInfo.pointPositionsCount += geom.indices.length;
          geometry = {
            type: "Point",
            ...geom
          };
          break;
        case 2:
          this._geometryInfo.lineFeaturesCount++;
          this._geometryInfo.linePathsCount += geom.indices.length;
          this._geometryInfo.linePositionsCount += geom.data.length / coordLength;
          geometry = {
            type: "LineString",
            ...geom
          };
          break;
        case 3:
          geometry = classifyRings2(geom);
          this._geometryInfo.polygonFeaturesCount++;
          this._geometryInfo.polygonObjectsCount += geometry.indices.length;
          for (const indices of geometry.indices) {
            this._geometryInfo.polygonRingsCount += indices.length;
          }
          this._geometryInfo.polygonPositionsCount += geometry.data.length / coordLength;
          break;
        default:
          throw new Error("Invalid geometry type: ".concat(this.type));
      }
      const result = {
        type: "Feature",
        geometry,
        properties: this.properties
      };
      if (this.id !== null) {
        result.id = this.id;
      }
      return result;
    }
    toBinaryCoordinates(options) {
      if (typeof options === "function") {
        return this._toBinaryCoordinates(options);
      }
      const {
        x: x2,
        y: y2,
        z
      } = options;
      const size = this.extent * Math.pow(2, z);
      const x0 = this.extent * x2;
      const y0 = this.extent * y2;
      return this._toBinaryCoordinates((data) => project(data, x0, y0, size));
    }
  };

  // ../../node_modules/@loaders.gl/mvt/dist/esm/lib/binary-vector-tile/vector-tile-layer.js
  var VectorTileLayer2 = class {
    constructor(pbf, end) {
      _defineProperty(this, "version", void 0);
      _defineProperty(this, "name", void 0);
      _defineProperty(this, "extent", void 0);
      _defineProperty(this, "length", void 0);
      _defineProperty(this, "_pbf", void 0);
      _defineProperty(this, "_keys", void 0);
      _defineProperty(this, "_values", void 0);
      _defineProperty(this, "_features", void 0);
      this.version = 1;
      this.name = "";
      this.extent = 4096;
      this.length = 0;
      this._pbf = pbf;
      this._keys = [];
      this._values = [];
      this._features = [];
      pbf.readFields(readLayer2, this, end);
      this.length = this._features.length;
    }
    feature(i3, geometryInfo) {
      if (i3 < 0 || i3 >= this._features.length) {
        throw new Error("feature index out of bounds");
      }
      this._pbf.pos = this._features[i3];
      const end = this._pbf.readVarint() + this._pbf.pos;
      return new VectorTileFeature2(this._pbf, end, this.extent, this._keys, this._values, geometryInfo);
    }
  };
  function readLayer2(tag, layer, pbf) {
    if (layer && pbf) {
      if (tag === 15)
        layer.version = pbf.readVarint();
      else if (tag === 1)
        layer.name = pbf.readString();
      else if (tag === 5)
        layer.extent = pbf.readVarint();
      else if (tag === 2)
        layer._features.push(pbf.pos);
      else if (tag === 3)
        layer._keys.push(pbf.readString());
      else if (tag === 4)
        layer._values.push(readValueMessage2(pbf));
    }
  }
  function readValueMessage2(pbf) {
    let value = null;
    const end = pbf.readVarint() + pbf.pos;
    while (pbf.pos < end) {
      const tag = pbf.readVarint() >> 3;
      value = tag === 1 ? pbf.readString() : tag === 2 ? pbf.readFloat() : tag === 3 ? pbf.readDouble() : tag === 4 ? pbf.readVarint64() : tag === 5 ? pbf.readVarint() : tag === 6 ? pbf.readSVarint() : tag === 7 ? pbf.readBoolean() : null;
    }
    return value;
  }

  // ../../node_modules/@loaders.gl/mvt/dist/esm/lib/binary-vector-tile/vector-tile.js
  var VectorTile2 = class {
    constructor(pbf, end) {
      _defineProperty(this, "layers", void 0);
      this.layers = pbf.readFields(readTile2, {}, end);
    }
  };
  function readTile2(tag, layers, pbf) {
    if (tag === 3) {
      if (pbf) {
        const layer = new VectorTileLayer2(pbf, pbf.readVarint() + pbf.pos);
        if (layer.length && layers) {
          layers[layer.name] = layer;
        }
      }
    }
  }

  // ../../node_modules/@loaders.gl/mvt/dist/esm/lib/parse-mvt.js
  function parseMVT(arrayBuffer, options) {
    var _options$gis, _options$mvt;
    const mvtOptions = normalizeOptions(options);
    const shape = (options === null || options === void 0 ? void 0 : (_options$gis = options.gis) === null || _options$gis === void 0 ? void 0 : _options$gis.format) || (options === null || options === void 0 ? void 0 : (_options$mvt = options.mvt) === null || _options$mvt === void 0 ? void 0 : _options$mvt.shape);
    switch (shape) {
      case "columnar-table":
        return {
          shape: "columnar-table",
          data: parseToBinary(arrayBuffer, mvtOptions)
        };
      case "geojson-row-table": {
        const table = {
          shape: "geojson-row-table",
          data: parseToGeojson(arrayBuffer, mvtOptions)
        };
        return table;
      }
      case "geojson":
        return parseToGeojson(arrayBuffer, mvtOptions);
      case "binary-geometry":
        return parseToBinary(arrayBuffer, mvtOptions);
      case "binary":
        return parseToBinary(arrayBuffer, mvtOptions);
      default:
        throw new Error(shape);
    }
  }
  function parseToBinary(arrayBuffer, options) {
    const [flatGeoJsonFeatures, geometryInfo] = parseToFlatGeoJson(arrayBuffer, options);
    const binaryData = flatGeojsonToBinary(flatGeoJsonFeatures, geometryInfo);
    binaryData.byteLength = arrayBuffer.byteLength;
    return binaryData;
  }
  function parseToFlatGeoJson(arrayBuffer, options) {
    const features = [];
    const geometryInfo = {
      coordLength: 2,
      pointPositionsCount: 0,
      pointFeaturesCount: 0,
      linePositionsCount: 0,
      linePathsCount: 0,
      lineFeaturesCount: 0,
      polygonPositionsCount: 0,
      polygonObjectsCount: 0,
      polygonRingsCount: 0,
      polygonFeaturesCount: 0
    };
    if (arrayBuffer.byteLength <= 0) {
      return [features, geometryInfo];
    }
    const tile = new VectorTile2(new import_pbf.default(arrayBuffer));
    const selectedLayers = options && Array.isArray(options.layers) ? options.layers : Object.keys(tile.layers);
    selectedLayers.forEach((layerName) => {
      const vectorTileLayer = tile.layers[layerName];
      if (!vectorTileLayer) {
        return;
      }
      for (let i3 = 0; i3 < vectorTileLayer.length; i3++) {
        const vectorTileFeature = vectorTileLayer.feature(i3, geometryInfo);
        const decodedFeature = getDecodedFeatureBinary(vectorTileFeature, options, layerName);
        features.push(decodedFeature);
      }
    });
    return [features, geometryInfo];
  }
  function parseToGeojson(arrayBuffer, options) {
    if (arrayBuffer.byteLength <= 0) {
      return [];
    }
    const features = [];
    const tile = new VectorTile(new import_pbf.default(arrayBuffer));
    const selectedLayers = Array.isArray(options.layers) ? options.layers : Object.keys(tile.layers);
    selectedLayers.forEach((layerName) => {
      const vectorTileLayer = tile.layers[layerName];
      if (!vectorTileLayer) {
        return;
      }
      for (let i3 = 0; i3 < vectorTileLayer.length; i3++) {
        const vectorTileFeature = vectorTileLayer.feature(i3);
        const decodedFeature = getDecodedFeature(vectorTileFeature, options, layerName);
        features.push(decodedFeature);
      }
    });
    return features;
  }
  function normalizeOptions(options) {
    var _options$mvt2;
    if (!(options !== null && options !== void 0 && options.mvt)) {
      throw new Error("mvt options required");
    }
    const wgs84Coordinates = ((_options$mvt2 = options.mvt) === null || _options$mvt2 === void 0 ? void 0 : _options$mvt2.coordinates) === "wgs84";
    const {
      tileIndex
    } = options.mvt;
    const hasTileIndex = tileIndex && Number.isFinite(tileIndex.x) && Number.isFinite(tileIndex.y) && Number.isFinite(tileIndex.z);
    if (wgs84Coordinates && !hasTileIndex) {
      throw new Error("MVT Loader: WGS84 coordinates need tileIndex property");
    }
    return options.mvt;
  }
  function getDecodedFeature(feature, options, layerName) {
    const decodedFeature = feature.toGeoJSON(options.coordinates === "wgs84" ? options.tileIndex : transformToLocalCoordinates);
    if (options.layerProperty) {
      decodedFeature.properties[options.layerProperty] = layerName;
    }
    return decodedFeature;
  }
  function getDecodedFeatureBinary(feature, options, layerName) {
    const decodedFeature = feature.toBinaryCoordinates(options.coordinates === "wgs84" ? options.tileIndex : transformToLocalCoordinatesBinary);
    if (options.layerProperty && decodedFeature.properties) {
      decodedFeature.properties[options.layerProperty] = layerName;
    }
    return decodedFeature;
  }
  function transformToLocalCoordinates(line, feature) {
    const {
      extent
    } = feature;
    for (let i3 = 0; i3 < line.length; i3++) {
      const p2 = line[i3];
      p2[0] /= extent;
      p2[1] /= extent;
    }
  }
  function transformToLocalCoordinatesBinary(data, feature) {
    const {
      extent
    } = feature;
    for (let i3 = 0, il = data.length; i3 < il; ++i3) {
      data[i3] /= extent;
    }
  }

  // ../../node_modules/@loaders.gl/mvt/dist/esm/mvt-loader.js
  var VERSION14 = true ? "3.3.1" : "latest";
  var DEFAULT_MVT_LOADER_OPTIONS = {
    mvt: {
      shape: "geojson",
      coordinates: "local",
      layerProperty: "layerName",
      layers: void 0,
      tileIndex: null
    }
  };
  var MVTWorkerLoader = {
    name: "Mapbox Vector Tile",
    id: "mvt",
    module: "mvt",
    version: VERSION14,
    extensions: ["mvt", "pbf"],
    mimeTypes: [
      "application/vnd.mapbox-vector-tile",
      "application/x-protobuf"
    ],
    worker: true,
    category: "geometry",
    options: DEFAULT_MVT_LOADER_OPTIONS
  };
  var MVTLoader = {
    ...MVTWorkerLoader,
    parse: async (arrayBuffer, options) => parseMVT(arrayBuffer, options),
    parseSync: parseMVT,
    binary: true
  };

  // src/mvt-layer/coordinate-transform.ts
  var availableTransformations = {
    Point,
    MultiPoint,
    LineString,
    MultiLineString,
    Polygon: Polygon2,
    MultiPolygon
  };
  function Point([pointX, pointY], [nw, se], viewport) {
    const x2 = lerp3(nw[0], se[0], pointX);
    const y2 = lerp3(nw[1], se[1], pointY);
    return viewport.unprojectFlat([x2, y2]);
  }
  function getPoints(geometry, bbox, viewport) {
    return geometry.map((g) => Point(g, bbox, viewport));
  }
  function MultiPoint(multiPoint, bbox, viewport) {
    return getPoints(multiPoint, bbox, viewport);
  }
  function LineString(line, bbox, viewport) {
    return getPoints(line, bbox, viewport);
  }
  function MultiLineString(multiLineString, bbox, viewport) {
    return multiLineString.map((lineString) => LineString(lineString, bbox, viewport));
  }
  function Polygon2(polygon, bbox, viewport) {
    return polygon.map((polygonRing) => getPoints(polygonRing, bbox, viewport));
  }
  function MultiPolygon(multiPolygon, bbox, viewport) {
    return multiPolygon.map((polygon) => Polygon2(polygon, bbox, viewport));
  }
  function transform(geometry, bbox, viewport) {
    const nw = viewport.projectFlat([bbox.west, bbox.north]);
    const se = viewport.projectFlat([bbox.east, bbox.south]);
    const projectedBbox = [nw, se];
    return {
      ...geometry,
      coordinates: availableTransformations[geometry.type](geometry.coordinates, projectedBbox, viewport)
    };
  }

  // src/mvt-layer/find-index-binary.ts
  var GEOM_TYPES = ["points", "lines", "polygons"];
  function findIndexBinary(data, uniqueIdProperty, featureId, layerName) {
    for (const gt of GEOM_TYPES) {
      const index = data[gt] && findIndexByType(data[gt], uniqueIdProperty, featureId, layerName);
      if (index >= 0) {
        return index;
      }
    }
    return -1;
  }
  function findIndexByType(geomData, uniqueIdProperty, featureId, layerName) {
    const featureIds = geomData.featureIds.value;
    if (!featureIds.length) {
      return -1;
    }
    let startFeatureIndex = 0;
    let endFeatureIndex = featureIds[featureIds.length - 1] + 1;
    if (layerName) {
      const layerRange = getLayerRange(geomData, layerName);
      if (layerRange) {
        startFeatureIndex = layerRange[0];
        endFeatureIndex = layerRange[1] + 1;
      } else {
        return -1;
      }
    }
    let featureIndex = -1;
    if (uniqueIdProperty in geomData.numericProps) {
      const vertexIndex = geomData.numericProps[uniqueIdProperty].value.findIndex((x2, i3) => x2 === featureId && featureIds[i3] >= startFeatureIndex && featureIds[i3] < endFeatureIndex);
      return vertexIndex >= 0 ? geomData.globalFeatureIds.value[vertexIndex] : -1;
    } else if (uniqueIdProperty) {
      featureIndex = findIndex(geomData.properties, (elem) => elem[uniqueIdProperty] === featureId, startFeatureIndex, endFeatureIndex);
    } else if (geomData.fields) {
      featureIndex = findIndex(geomData.fields, (elem) => elem.id === featureId, startFeatureIndex, endFeatureIndex);
    }
    return featureIndex >= 0 ? getGlobalFeatureId(geomData, featureIndex) : -1;
  }
  function getLayerRange(geomData, layerName) {
    if (!geomData.__layers) {
      const layerNames = {};
      const {
        properties
      } = geomData;
      for (let i3 = 0; i3 < properties.length; i3++) {
        const {
          layerName: key
        } = properties[i3];
        if (!key) {
        } else if (layerNames[key]) {
          layerNames[key][1] = i3;
        } else {
          layerNames[key] = [i3, i3];
        }
      }
      geomData.__layers = layerNames;
    }
    return geomData.__layers[layerName];
  }
  function getGlobalFeatureId(geomData, featureIndex) {
    if (!geomData.__ids) {
      const result = [];
      const featureIds = geomData.featureIds.value;
      const globalFeatureIds = geomData.globalFeatureIds.value;
      for (let i3 = 0; i3 < featureIds.length; i3++) {
        result[featureIds[i3]] = globalFeatureIds[i3];
      }
      geomData.__ids = result;
    }
    return geomData.__ids[featureIndex];
  }
  function findIndex(array, predicate, startIndex, endIndex) {
    for (let i3 = startIndex; i3 < endIndex; i3++) {
      if (predicate(array[i3], i3)) {
        return i3;
      }
    }
    return -1;
  }

  // src/mvt-layer/mvt-layer.ts
  var WORLD_SIZE = 512;
  var defaultProps13 = {
    ...import_layers9.GeoJsonLayer.defaultProps,
    data: urlType,
    onDataLoad: {
      type: "function",
      value: null,
      optional: true,
      compare: false
    },
    uniqueIdProperty: "",
    highlightedFeatureId: null,
    loaders: [MVTWorkerLoader],
    binary: true
  };
  var MVTLayer = class extends TileLayer {
    initializeState() {
      super.initializeState();
      const binary = this.context.viewport.resolution !== void 0 ? false : this.props.binary;
      this.setState({
        binary,
        data: null,
        tileJSON: null
      });
    }
    get isLoaded() {
      return this.state && this.state.data && this.state.tileset && super.isLoaded;
    }
    updateState({
      props,
      oldProps,
      context,
      changeFlags
    }) {
      if (changeFlags.dataChanged) {
        this._updateTileData();
      }
      if (this.state?.data) {
        super.updateState({
          props,
          oldProps,
          context,
          changeFlags
        });
        this._setWGS84PropertyForTiles();
      }
      const {
        highlightColor
      } = props;
      if (highlightColor !== oldProps.highlightColor && Array.isArray(highlightColor)) {
        this.setState({
          highlightColor
        });
      }
    }
    async _updateTileData() {
      let data = this.props.data;
      let tileJSON = null;
      if (typeof data === "string" && !isURLTemplate(data)) {
        const {
          onDataLoad,
          fetch: fetch2
        } = this.props;
        this.setState({
          data: null,
          tileJSON: null
        });
        try {
          tileJSON = await fetch2(data, {
            propName: "data",
            layer: this,
            loaders: []
          });
        } catch (error2) {
          this.raiseError(error2, "loading TileJSON");
          data = null;
        }
        if (onDataLoad) {
          onDataLoad(tileJSON, {
            propName: "data",
            layer: this
          });
        }
      } else if (data.tilejson) {
        tileJSON = data;
      }
      if (tileJSON) {
        data = tileJSON.tiles;
      }
      this.setState({
        data,
        tileJSON
      });
    }
    _getTilesetOptions() {
      const opts = super._getTilesetOptions();
      const tileJSON = this.state.tileJSON;
      const {
        minZoom,
        maxZoom
      } = this.props;
      if (tileJSON) {
        if (Number.isFinite(tileJSON.minzoom) && tileJSON.minzoom > minZoom) {
          opts.minZoom = tileJSON.minzoom;
        }
        if (Number.isFinite(tileJSON.maxzoom) && (!Number.isFinite(maxZoom) || tileJSON.maxzoom < maxZoom)) {
          opts.maxZoom = tileJSON.maxzoom;
        }
      }
      return opts;
    }
    renderLayers() {
      if (!this.state?.data)
        return null;
      return super.renderLayers();
    }
    getTileData(loadProps) {
      const {
        data,
        binary
      } = this.state;
      const {
        index,
        signal
      } = loadProps;
      const url = getURLFromTemplate(data, loadProps);
      if (!url) {
        return Promise.reject("Invalid URL");
      }
      let loadOptions = this.getLoadOptions();
      const {
        fetch: fetch2
      } = this.props;
      loadOptions = {
        ...loadOptions,
        mimeType: "application/x-protobuf",
        mvt: {
          ...loadOptions?.mvt,
          coordinates: this.context.viewport.resolution ? "wgs84" : "local",
          tileIndex: index
        },
        gis: binary ? {
          format: "binary"
        } : {}
      };
      return fetch2(url, {
        propName: "data",
        layer: this,
        loadOptions,
        signal
      });
    }
    renderSubLayers(props) {
      const {
        x: x2,
        y: y2,
        z
      } = props.tile.index;
      const worldScale = Math.pow(2, z);
      const xScale = WORLD_SIZE / worldScale;
      const yScale = -xScale;
      const xOffset = WORLD_SIZE * x2 / worldScale;
      const yOffset = WORLD_SIZE * (1 - y2 / worldScale);
      const modelMatrix = new Matrix4().scale([xScale, yScale, 1]);
      props.autoHighlight = false;
      if (!this.context.viewport.resolution) {
        props.modelMatrix = modelMatrix;
        props.coordinateOrigin = [xOffset, yOffset, 0];
        props.coordinateSystem = import_core47.COORDINATE_SYSTEM.CARTESIAN;
        props.extensions = [...props.extensions || [], new import_extensions.ClipExtension()];
      }
      const subLayers = super.renderSubLayers(props);
      if (this.state.binary && !(subLayers instanceof import_layers9.GeoJsonLayer)) {
        import_core47.log.warn("renderSubLayers() must return GeoJsonLayer when using binary:true")();
      }
      return subLayers;
    }
    _updateAutoHighlight(info) {
      const {
        uniqueIdProperty
      } = this.props;
      const {
        hoveredFeatureId,
        hoveredFeatureLayerName
      } = this.state;
      const hoveredFeature = info.object;
      let newHoveredFeatureId;
      let newHoveredFeatureLayerName;
      if (hoveredFeature) {
        newHoveredFeatureId = getFeatureUniqueId(hoveredFeature, uniqueIdProperty);
        newHoveredFeatureLayerName = getFeatureLayerName(hoveredFeature);
      }
      let {
        highlightColor
      } = this.props;
      if (typeof highlightColor === "function") {
        highlightColor = highlightColor(info);
      }
      if (hoveredFeatureId !== newHoveredFeatureId || hoveredFeatureLayerName !== newHoveredFeatureLayerName) {
        this.setState({
          highlightColor,
          hoveredFeatureId: newHoveredFeatureId,
          hoveredFeatureLayerName: newHoveredFeatureLayerName
        });
      }
    }
    getPickingInfo(params) {
      const info = super.getPickingInfo(params);
      const isWGS842 = Boolean(this.context.viewport.resolution);
      if (this.state.binary && info.index !== -1) {
        const {
          data
        } = params.sourceLayer.props;
        info.object = binaryToGeojson(data, {
          globalFeatureId: info.index
        });
      }
      if (info.object && !isWGS842) {
        info.object = transformTileCoordsToWGS84(
          info.object,
          info.tile.bbox,
          this.context.viewport
        );
      }
      return info;
    }
    getSubLayerPropsByTile(tile) {
      return {
        highlightedObjectIndex: this.getHighlightedObjectIndex(tile),
        highlightColor: this.state.highlightColor
      };
    }
    getHighlightedObjectIndex(tile) {
      const {
        hoveredFeatureId,
        hoveredFeatureLayerName,
        binary
      } = this.state;
      const {
        uniqueIdProperty,
        highlightedFeatureId
      } = this.props;
      const data = tile.content;
      const isHighlighted = isFeatureIdDefined(highlightedFeatureId);
      const isFeatureIdPresent = isFeatureIdDefined(hoveredFeatureId) || isHighlighted;
      if (!isFeatureIdPresent) {
        return -1;
      }
      const featureIdToHighlight = isHighlighted ? highlightedFeatureId : hoveredFeatureId;
      if (Array.isArray(data)) {
        return data.findIndex((feature) => {
          const isMatchingId = getFeatureUniqueId(feature, uniqueIdProperty) === featureIdToHighlight;
          const isMatchingLayer = isHighlighted || getFeatureLayerName(feature) === hoveredFeatureLayerName;
          return isMatchingId && isMatchingLayer;
        });
      } else if (data && binary) {
        return findIndexBinary(data, uniqueIdProperty, featureIdToHighlight, isHighlighted ? "" : hoveredFeatureLayerName);
      }
      return -1;
    }
    _pickObjects(maxObjects) {
      const {
        deck,
        viewport
      } = this.context;
      const width = viewport.width;
      const height = viewport.height;
      const x2 = viewport.x;
      const y2 = viewport.y;
      const layerIds = [this.id];
      return deck.pickObjects({
        x: x2,
        y: y2,
        width,
        height,
        layerIds,
        maxObjects
      });
    }
    getRenderedFeatures(maxFeatures = null) {
      const features = this._pickObjects(maxFeatures);
      const featureCache = /* @__PURE__ */ new Set();
      const renderedFeatures = [];
      for (const f2 of features) {
        const featureId = getFeatureUniqueId(f2.object, this.props.uniqueIdProperty);
        if (featureId === void 0) {
          renderedFeatures.push(f2.object);
        } else if (!featureCache.has(featureId)) {
          featureCache.add(featureId);
          renderedFeatures.push(f2.object);
        }
      }
      return renderedFeatures;
    }
    _setWGS84PropertyForTiles() {
      const propName = "dataInWGS84";
      const tileset = this.state.tileset;
      tileset.selectedTiles.forEach((tile) => {
        if (!tile.hasOwnProperty(propName)) {
          Object.defineProperty(tile, propName, {
            get: () => {
              if (!tile.content) {
                return null;
              }
              if (this.state.binary && Array.isArray(tile.content) && !tile.content.length) {
                return [];
              }
              const {
                bbox
              } = tile;
              if (tile._contentWGS84 === void 0 && isGeoBoundingBox(bbox)) {
                const content = this.state.binary ? binaryToGeojson(tile.content) : tile.content;
                tile._contentWGS84 = content.map((feature) => transformTileCoordsToWGS84(feature, bbox, this.context.viewport));
              }
              return tile._contentWGS84;
            }
          });
        }
      });
    }
  };
  __publicField(MVTLayer, "layerName", "MVTLayer");
  __publicField(MVTLayer, "defaultProps", defaultProps13);
  function getFeatureUniqueId(feature, uniqueIdProperty) {
    if (feature.properties && uniqueIdProperty) {
      return feature.properties[uniqueIdProperty];
    }
    if ("id" in feature) {
      return feature.id;
    }
    return void 0;
  }
  function getFeatureLayerName(feature) {
    return feature.properties?.layerName || null;
  }
  function isFeatureIdDefined(value) {
    return value !== void 0 && value !== null && value !== "";
  }
  function transformTileCoordsToWGS84(object, bbox, viewport) {
    const feature = {
      ...object,
      geometry: {
        type: object.geometry.type
      }
    };
    Object.defineProperty(feature.geometry, "coordinates", {
      get: () => {
        const wgs84Geom = transform(object.geometry, bbox, viewport);
        return wgs84Geom.coordinates;
      }
    });
    return feature;
  }

  // src/geohash-layer/geohash-utils.ts
  var BASE32_CODES = "0123456789bcdefghjkmnpqrstuvwxyz";
  var BASE32_CODES_DICT = {};
  for (let i3 = 0; i3 < BASE32_CODES.length; i3++) {
    BASE32_CODES_DICT[BASE32_CODES.charAt(i3)] = i3;
  }
  var MIN_LAT = -90;
  var MAX_LAT = 90;
  var MIN_LON = -180;
  var MAX_LON = 180;
  function getGeohashBounds(geohash) {
    let isLon = true;
    let maxLat = MAX_LAT;
    let minLat = MIN_LAT;
    let maxLon = MAX_LON;
    let minLon = MIN_LON;
    let mid;
    let hashValue = 0;
    for (let i3 = 0, l2 = geohash.length; i3 < l2; i3++) {
      const code = geohash[i3].toLowerCase();
      hashValue = BASE32_CODES_DICT[code];
      for (let bits = 4; bits >= 0; bits--) {
        const bit = hashValue >> bits & 1;
        if (isLon) {
          mid = (maxLon + minLon) / 2;
          if (bit === 1) {
            minLon = mid;
          } else {
            maxLon = mid;
          }
        } else {
          mid = (maxLat + minLat) / 2;
          if (bit === 1) {
            minLat = mid;
          } else {
            maxLat = mid;
          }
        }
        isLon = !isLon;
      }
    }
    return [minLat, minLon, maxLat, maxLon];
  }
  function getGeohashPolygon(geohash) {
    const [s2, w, n2, e] = getGeohashBounds(geohash);
    return [e, n2, e, s2, w, s2, w, n2, e, n2];
  }

  // src/geohash-layer/geohash-layer.ts
  var defaultProps14 = {
    getGeohash: {
      type: "accessor",
      value: (d) => d.geohash
    }
  };
  var GeohashLayer = class extends GeoCellLayer {
    indexToBounds() {
      const {
        data,
        getGeohash
      } = this.props;
      return {
        data,
        _normalize: false,
        positionFormat: "XY",
        getPolygon: (x2, objectInfo) => getGeohashPolygon(getGeohash(x2, objectInfo))
      };
    }
  };
  __publicField(GeohashLayer, "layerName", "GeohashLayer");
  __publicField(GeohashLayer, "defaultProps", defaultProps14);
  return __toCommonJS(bundle_exports);
})();
      return __exports__;
      });
