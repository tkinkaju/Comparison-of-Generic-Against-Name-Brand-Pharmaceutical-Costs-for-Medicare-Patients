"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _mapbox = _interopRequireDefault(require("react-map-gl/dist/esm/mapbox/mapbox"));

var _deck = _interopRequireDefault(require("../lib/deck"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var CANVAS_STYLE = {
  position: 'absolute',
  left: 0,
  top: 0,
  width: '100%',
  height: '100%'
};

function createCanvas(props) {
  var _props$container = props.container,
      container = _props$container === void 0 ? document.body : _props$container;

  if (typeof container === 'string') {
    container = document.getElementById(container);
  }

  if (!container) {
    throw Error('Deck: container not found');
  }

  var containerStyle = window.getComputedStyle(container);

  if (containerStyle.position === 'static') {
    container.style.position = 'relative';
  }

  var mapCanvas = document.createElement('div');
  container.appendChild(mapCanvas);
  Object.assign(mapCanvas.style, CANVAS_STYLE);
  var deckCanvas = document.createElement('canvas');
  container.appendChild(deckCanvas);
  Object.assign(deckCanvas.style, CANVAS_STYLE);
  return {
    container: container,
    mapCanvas: mapCanvas,
    deckCanvas: deckCanvas
  };
}

var DeckGL = function (_Deck) {
  (0, _inherits2.default)(DeckGL, _Deck);

  var _super = _createSuper(DeckGL);

  function DeckGL(props) {
    var _this;

    (0, _classCallCheck2.default)(this, DeckGL);

    if (typeof document === 'undefined') {
      throw Error('Deck can only be used in the browser');
    }

    var _createCanvas = createCanvas(props),
        mapCanvas = _createCanvas.mapCanvas,
        deckCanvas = _createCanvas.deckCanvas;

    var viewState = props.viewState || props.initialViewState;
    var isMap = Number.isFinite(viewState && viewState.latitude);
    var _props$map = props.map,
        map = _props$map === void 0 ? globalThis.mapboxgl || globalThis.maplibregl : _props$map;
    _this = _super.call(this, _objectSpread({
      canvas: deckCanvas
    }, props));
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_map", void 0);

    if (map && map.Map) {
      _this._map = isMap && new _mapbox.default(_objectSpread(_objectSpread({}, props), {}, {
        viewState: viewState,
        container: mapCanvas,
        mapboxgl: map
      }));
    } else {
      _this._map = map;
    }

    return _this;
  }

  (0, _createClass2.default)(DeckGL, [{
    key: "getMapboxMap",
    value: function getMapboxMap() {
      return this._map && this._map.getMap();
    }
  }, {
    key: "finalize",
    value: function finalize() {
      if (this._map) {
        this._map.finalize();
      }

      (0, _get2.default)((0, _getPrototypeOf2.default)(DeckGL.prototype), "finalize", this).call(this);
    }
  }, {
    key: "setProps",
    value: function setProps(props) {
      if ('mapStyle' in props && this._map) {
        this._map._map.setStyle(props.mapStyle);
      }

      (0, _get2.default)((0, _getPrototypeOf2.default)(DeckGL.prototype), "setProps", this).call(this, props);
    }
  }, {
    key: "_drawLayers",
    value: function _drawLayers(redrawReason, options) {
      if (this._map) {
        var viewport = this.getViewports()[0];

        this._map.setProps({
          width: viewport.width,
          height: viewport.height,
          viewState: viewport
        });
      }

      (0, _get2.default)((0, _getPrototypeOf2.default)(DeckGL.prototype), "_drawLayers", this).call(this, redrawReason, options);
    }
  }]);
  return DeckGL;
}(_deck.default);

exports.default = DeckGL;
//# sourceMappingURL=deckgl.js.map