{"version":3,"sources":["../../../src/mask/mask-effect.ts"],"names":["log","Texture2D","equals","MaskPass","joinLayerBounds","getRenderBounds","makeViewport","MaskEffect","preRender","gl","layers","layerFilter","viewports","onViewportActive","views","isPicking","didRender","dummyMaskMap","width","height","maskLayers","filter","l","props","visible","operation","includes","length","masks","channels","maskPass","id","maskMap","channelMap","_sortMaskChannels","viewport","viewportChanged","lastViewport","resolution","undefined","warn","maskId","result","_renderChannel","channelInfo","oldChannelInfo","index","maskChanged","some","layer","i","transitions","layerBounds","b","bounds","maskBounds","maskViewport","border","getBounds","render","pass","channel","moduleParameters","devicePixelRatio","coordinateOrigin","coordinateSystem","channelCount","root","findIndex","c","push","getModuleParameters","maskChannels","cleanup","delete"],"mappings":"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","sourcesContent":["import {Layer, Viewport, Effect, PreRenderOptions, CoordinateSystem, log} from '@deck.gl/core';\nimport {Texture2D} from '@luma.gl/core';\nimport {equals} from '@math.gl/core';\nimport MaskPass from './mask-pass';\nimport {joinLayerBounds, getRenderBounds, makeViewport, Bounds} from '../utils/projection-utils';\n// import {debugFBO} from '../utils/debug';\n\ntype Mask = {\n  /** The channel index */\n  index: number;\n  bounds: Bounds;\n  coordinateOrigin: [number, number, number];\n  coordinateSystem: CoordinateSystem;\n};\n\ntype Channel = {\n  id: string;\n  index: number;\n  layers: Layer[];\n  bounds: Bounds | null;\n  maskBounds: Bounds;\n  layerBounds: Bounds[];\n  coordinateOrigin: [number, number, number];\n  coordinateSystem: CoordinateSystem;\n};\n\nexport type MaskPreRenderStats = {\n  didRender: boolean;\n};\n\n// Class to manage mask effect\nexport default class MaskEffect implements Effect {\n  id = 'mask-effect';\n  props = null;\n  useInPicking = true;\n  order = 0;\n\n  private dummyMaskMap?: Texture2D;\n  private channels: (Channel | null)[] = [];\n  private masks: Record<string, Mask> | null = null;\n  private maskPass?: MaskPass;\n  private maskMap?: Texture2D;\n  private lastViewport?: Viewport;\n\n  preRender(\n    gl: WebGLRenderingContext,\n    {layers, layerFilter, viewports, onViewportActive, views, isPicking}: PreRenderOptions\n  ): MaskPreRenderStats {\n    let didRender = false;\n    if (!this.dummyMaskMap) {\n      this.dummyMaskMap = new Texture2D(gl, {\n        width: 1,\n        height: 1\n      });\n    }\n\n    if (isPicking) {\n      // Do not update on picking pass\n      return {didRender};\n    }\n\n    const maskLayers = layers.filter(l => l.props.visible && l.props.operation.includes('mask'));\n    if (maskLayers.length === 0) {\n      this.masks = null;\n      this.channels.length = 0;\n      return {didRender};\n    }\n    this.masks = {};\n\n    if (!this.maskPass) {\n      this.maskPass = new MaskPass(gl, {id: 'default-mask'});\n      this.maskMap = this.maskPass.maskMap;\n    }\n\n    // Map layers to channels\n    const channelMap = this._sortMaskChannels(maskLayers);\n    // TODO - support multiple views\n    const viewport = viewports[0];\n    const viewportChanged = !this.lastViewport || !this.lastViewport.equals(viewport);\n\n    if (viewport.resolution !== undefined) {\n      log.warn('MaskExtension is not supported in GlobeView')();\n      return {didRender};\n    }\n\n    for (const maskId in channelMap) {\n      const result = this._renderChannel(channelMap[maskId], {\n        layerFilter,\n        onViewportActive,\n        views,\n        viewport,\n        viewportChanged\n      });\n      didRender ||= result;\n    }\n\n    // debugFBO(this.maskMap, {opaque: true});\n    return {didRender};\n  }\n\n  private _renderChannel(\n    channelInfo: Channel,\n    {\n      layerFilter,\n      onViewportActive,\n      views,\n      viewport,\n      viewportChanged\n    }: {\n      layerFilter: PreRenderOptions['layerFilter'];\n      onViewportActive: PreRenderOptions['onViewportActive'];\n      views: PreRenderOptions['views'];\n      viewport: Viewport;\n      viewportChanged: boolean;\n    }\n  ): boolean {\n    let didRender = false;\n    const oldChannelInfo = this.channels[channelInfo.index];\n    if (!oldChannelInfo) {\n      return didRender;\n    }\n\n    const maskChanged =\n      // If a channel is new\n      channelInfo === oldChannelInfo ||\n      // If sublayers have changed\n      channelInfo.layers.length !== oldChannelInfo.layers.length ||\n      channelInfo.layers.some(\n        (layer, i) =>\n          // Layer instance is updated\n          // Layer props might have changed\n          // Undetermined props could have an effect on the output geometry of a mask layer,\n          // for example getRadius+updateTriggers, radiusScale, modelMatrix\n          layer !== oldChannelInfo.layers[i] ||\n          // Some prop is in transition\n          layer.props.transitions\n      ) ||\n      // If a sublayer's positions have been updated, the cached bounds will change shallowly\n      channelInfo.layerBounds.some((b, i) => b !== oldChannelInfo.layerBounds[i]);\n\n    channelInfo.bounds = oldChannelInfo.bounds;\n    channelInfo.maskBounds = oldChannelInfo.maskBounds;\n    this.channels[channelInfo.index] = channelInfo;\n\n    if (maskChanged || viewportChanged) {\n      // Recalculate mask bounds\n      this.lastViewport = viewport;\n\n      const layerBounds = joinLayerBounds(channelInfo.layers, viewport);\n      channelInfo.bounds = layerBounds && getRenderBounds(layerBounds, viewport);\n\n      if (maskChanged || !equals(channelInfo.bounds, oldChannelInfo.bounds)) {\n        // Rerender mask FBO\n        const {maskPass, maskMap} = this;\n\n        const maskViewport =\n          layerBounds &&\n          makeViewport({\n            bounds: channelInfo.bounds!,\n            viewport,\n            width: maskMap.width,\n            height: maskMap.height,\n            border: 1\n          });\n\n        channelInfo.maskBounds = maskViewport ? maskViewport.getBounds() : [0, 0, 1, 1];\n\n        // @ts-ignore (2532) This method is only called from preRender where maskPass is defined\n        maskPass.render({\n          pass: 'mask',\n          channel: channelInfo.index,\n          layers: channelInfo.layers,\n          layerFilter,\n          viewports: maskViewport ? [maskViewport] : [],\n          onViewportActive,\n          views,\n          moduleParameters: {\n            devicePixelRatio: 1\n          }\n        });\n\n        didRender = true;\n      }\n    }\n\n    // @ts-ignore (2532) This method is only called from preRender where masks is defined\n    this.masks[channelInfo.id] = {\n      index: channelInfo.index,\n      bounds: channelInfo.maskBounds,\n      coordinateOrigin: channelInfo.coordinateOrigin,\n      coordinateSystem: channelInfo.coordinateSystem\n    };\n\n    return didRender;\n  }\n\n  /**\n   * Find a channel to render each mask into\n   * If a maskId already exists, diff and update the existing channel\n   * Otherwise replace a removed mask\n   * Otherwise create a new channel\n   * Returns a map from mask layer id to channel info\n   */\n  private _sortMaskChannels(maskLayers: Layer[]): Record<string, Channel> {\n    const channelMap = {};\n    let channelCount = 0;\n    for (const layer of maskLayers) {\n      const {id} = layer.root;\n      let channelInfo = channelMap[id];\n      if (!channelInfo) {\n        if (++channelCount > 4) {\n          log.warn('Too many mask layers. The max supported is 4')();\n          continue; // eslint-disable-line no-continue\n        }\n        channelInfo = {\n          id,\n          index: this.channels.findIndex(c => c?.id === id),\n          layers: [],\n          layerBounds: [],\n          coordinateOrigin: layer.root.props.coordinateOrigin,\n          coordinateSystem: layer.root.props.coordinateSystem\n        };\n        channelMap[id] = channelInfo;\n      }\n      channelInfo.layers.push(layer);\n      channelInfo.layerBounds.push(layer.getBounds());\n    }\n\n    for (let i = 0; i < 4; i++) {\n      const channelInfo = this.channels[i];\n      if (!channelInfo || !(channelInfo.id in channelMap)) {\n        // The mask id at this channel no longer exists\n        this.channels[i] = null;\n      }\n    }\n\n    for (const maskId in channelMap) {\n      const channelInfo = channelMap[maskId];\n\n      if (channelInfo.index < 0) {\n        channelInfo.index = this.channels.findIndex(c => !c);\n        this.channels[channelInfo.index] = channelInfo;\n      }\n    }\n    return channelMap;\n  }\n\n  getModuleParameters(): {\n    maskMap: Texture2D;\n    maskChannels: Record<string, Mask> | null;\n  } {\n    return {\n      maskMap: this.masks ? this.maskMap : this.dummyMaskMap,\n      maskChannels: this.masks\n    };\n  }\n\n  cleanup(): void {\n    if (this.dummyMaskMap) {\n      this.dummyMaskMap.delete();\n      this.dummyMaskMap = undefined;\n    }\n\n    if (this.maskPass) {\n      this.maskPass.delete();\n      this.maskPass = undefined;\n      this.maskMap = undefined;\n    }\n\n    this.lastViewport = undefined;\n    this.masks = null;\n    this.channels.length = 0;\n  }\n}\n"],"file":"mask-effect.js"}