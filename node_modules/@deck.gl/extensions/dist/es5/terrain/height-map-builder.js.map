{"version":3,"sources":["../../../src/terrain/height-map-builder.ts"],"names":["MAP_MAX_SIZE","HeightMapBuilder","gl","renderViewport","fbo","id","float","layers","viewport","layersChanged","length","some","layer","i","props","transitions","getBounds","layersBounds","map","layersBoundsCommon","viewportChanged","lastViewport","equals","bounds","scale","pixelWidth","pixelHeight","center","zoom","width","Math","min","height","color","delete","Framebuffer","isSupported","colorBufferFloat"],"mappings":"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","sourcesContent":["import {Framebuffer} from '@luma.gl/core';\nimport {joinLayerBounds, getRenderBounds, makeViewport, Bounds} from '../utils/projection-utils';\nimport {createRenderTarget} from './utils';\n\nimport type {Viewport, Layer} from '@deck.gl/core';\n\nconst MAP_MAX_SIZE = 2048;\n\n/**\n * Manages the lifecycle of the height map (a framebuffer that encodes elevation).\n * One instance of height map is is shared across all layers. It is updated when the viewport changes\n * or when some terrain source layer's data changes.\n * During the draw call of any terrainDrawMode:offset layers,\n * the vertex shader reads from this framebuffer to retrieve its z offset.\n */\nexport class HeightMapBuilder {\n  /** Viewport used to draw into the texture */\n  renderViewport: Viewport | null = null;\n  /** Bounds of the height map texture, in cartesian space */\n  bounds: Bounds | null = null;\n\n  protected fbo?: Framebuffer;\n  protected gl: WebGLRenderingContext;\n  /** Last rendered layers */\n  private layers: Layer[] = [];\n  /** Last layer.getBounds() */\n  private layersBounds: ([number[], number[]] | null)[] = [];\n  /** The union of layersBounds in cartesian space */\n  private layersBoundsCommon: Bounds | null = null;\n  private lastViewport: Viewport | null = null;\n\n  static isSupported(gl: WebGLRenderingContext): boolean {\n    return Framebuffer.isSupported(gl, {colorBufferFloat: true});\n  }\n\n  constructor(gl: WebGLRenderingContext) {\n    this.gl = gl;\n  }\n\n  /** Returns the height map framebuffer for read/write access.\n   * Returns null when the texture is invalid.\n   */\n  getRenderFramebuffer(): Framebuffer | null {\n    if (!this.renderViewport) {\n      return null;\n    }\n    if (!this.fbo) {\n      this.fbo = createRenderTarget(this.gl, {id: 'height-map', float: true});\n    }\n    return this.fbo;\n  }\n\n  /** Called every render cycle to check if the framebuffer needs update */\n  shouldUpdate({layers, viewport}: {layers: Layer[]; viewport: Viewport}): boolean {\n    const layersChanged =\n      layers.length !== this.layers.length ||\n      layers.some(\n        (layer, i) =>\n          // Layer instance is updated\n          // Layer props might have changed\n          // Undetermined props could have an effect on the output geometry of a terrain source,\n          // for example getElevation+updateTriggers, elevationScale, modelMatrix\n          layer !== this.layers[i] ||\n          // Some prop is in transition\n          layer.props.transitions ||\n          // Layer's geometry bounds have changed\n          layer.getBounds() !== this.layersBounds[i]\n      );\n\n    if (layersChanged) {\n      // Recalculate cached bounds\n      this.layers = layers;\n      this.layersBounds = layers.map(layer => layer.getBounds());\n      this.layersBoundsCommon = joinLayerBounds(layers, viewport);\n    }\n\n    const viewportChanged = !this.lastViewport || !viewport.equals(this.lastViewport);\n\n    if (!this.layersBoundsCommon) {\n      this.renderViewport = null;\n    } else if (layersChanged || viewportChanged) {\n      const bounds = getRenderBounds(this.layersBoundsCommon, viewport);\n      if (bounds[2] <= bounds[0] || bounds[3] <= bounds[1]) {\n        this.renderViewport = null;\n        return false;\n      }\n\n      this.bounds = bounds;\n      this.lastViewport = viewport;\n\n      const scale = viewport.scale;\n      const pixelWidth = (bounds[2] - bounds[0]) * scale;\n      const pixelHeight = (bounds[3] - bounds[1]) * scale;\n\n      this.renderViewport =\n        pixelWidth > 0 || pixelHeight > 0\n          ? makeViewport({\n              // It's not important whether the geometry is visible in this viewport, because\n              // vertices will not use the standard project_to_clipspace in the DRAW_TO_HEIGHT_MAP shader\n              // However the viewport must have the same center and zoom as the screen viewport\n              // So that projection uniforms used for calculating z are the same\n              bounds: [\n                viewport.center[0] - 1,\n                viewport.center[1] - 1,\n                viewport.center[0] + 1,\n                viewport.center[1] + 1\n              ],\n              zoom: viewport.zoom,\n              width: Math.min(pixelWidth, MAP_MAX_SIZE),\n              height: Math.min(pixelHeight, MAP_MAX_SIZE),\n              viewport\n            })\n          : null;\n      return true;\n    }\n    return false;\n  }\n\n  delete() {\n    if (this.fbo) {\n      this.fbo.color.delete();\n      this.fbo.delete();\n    }\n  }\n}\n"],"file":"height-map-builder.js"}