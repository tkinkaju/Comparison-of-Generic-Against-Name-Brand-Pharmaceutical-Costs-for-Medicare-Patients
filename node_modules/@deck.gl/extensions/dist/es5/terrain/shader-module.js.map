{"version":3,"sources":["../../../src/terrain/shader-module.ts"],"names":["TERRAIN_MODE","NONE","WRITE_HEIGHT_MAP","USE_HEIGHT_MAP","USE_COVER","USE_COVER_ONLY","SKIP","TERRAIN_MODE_CONSTANTS","Object","keys","map","key","join","terrainModule","name","dependencies","project","inject","getUniforms","opts","uniforms","drawToTerrainHeightMap","heightMap","heightMapBounds","dummyHeightMap","terrainCover","useTerrainHeightMap","terrainSkipRender","project_uCommonOrigin","mode","sampler","bounds","isPicking","pickingActive","getPickingFramebuffer","getRenderFramebuffer","terrain_mode","terrain_map","terrain_bounds"],"mappings":"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","sourcesContent":["/* eslint-disable camelcase */\n\nimport {project} from '@deck.gl/core';\nimport type {_ShaderModule as ShaderModule} from '@deck.gl/core';\n\nimport type {Texture2D} from '@luma.gl/core';\nimport type {Bounds} from '../utils/projection-utils';\nimport type {TerrainCover} from './terrain-cover';\n\n/** Module parameters expected by the terrain shader module */\nexport type TerrainModuleSettings = {\n  pickingActive?: boolean;\n  heightMap: Texture2D | null;\n  heightMapBounds?: Bounds | null;\n  dummyHeightMap: Texture2D;\n  terrainCover?: TerrainCover | null;\n  drawToTerrainHeightMap?: boolean;\n  useTerrainHeightMap?: boolean;\n  terrainSkipRender?: boolean;\n};\n\n/** A model can have one of the following modes */\nexport const TERRAIN_MODE = {\n  NONE: 0,\n  /** A terrain layer rendering encoded ground elevation into the height map */\n  WRITE_HEIGHT_MAP: 1,\n  /** An offset layer reading encoded ground elevation from the height map */\n  USE_HEIGHT_MAP: 2,\n  /** A terrain layer rendering to screen, using the cover fbo overlaid with its own texture */\n  USE_COVER: 3,\n  /** A terrain layer rendering to screen, using the cover fbo as texture */\n  USE_COVER_ONLY: 4,\n  /** Draped layer is rendered into a texture, and never to screen */\n  SKIP: 5\n};\n\nconst TERRAIN_MODE_CONSTANTS = Object.keys(TERRAIN_MODE)\n  .map(key => `const float TERRAIN_MODE_${key} = ${TERRAIN_MODE[key]}.0;`)\n  .join('\\n');\n\nexport const terrainModule = {\n  name: 'terrain',\n  dependencies: [project],\n  inject: {\n    'vs:#decl': `\nuniform float terrain_mode;\nuniform sampler2D terrain_map;\nuniform vec4 terrain_bounds;\nvarying vec3 commonPos;\n${TERRAIN_MODE_CONSTANTS}\n    `,\n    'vs:#main-start': `\nif (terrain_mode == TERRAIN_MODE_SKIP) {\n  gl_Position = vec4(0.0);\n  return;\n}\n`,\n    'vs:DECKGL_FILTER_GL_POSITION': `\ncommonPos = geometry.position.xyz;\nif (terrain_mode == TERRAIN_MODE_WRITE_HEIGHT_MAP) {\n  vec2 texCoords = (commonPos.xy - terrain_bounds.xy) / terrain_bounds.zw;\n  position = vec4(texCoords * 2.0 - 1.0, 0.0, 1.0);\n  commonPos.z += project_uCommonOrigin.z;\n}\nif (terrain_mode == TERRAIN_MODE_USE_HEIGHT_MAP) {\n  vec3 anchor = geometry.worldPosition;\n  anchor.z = 0.0;\n  vec3 anchorCommon = project_position(anchor);\n  vec2 texCoords = (anchorCommon.xy - terrain_bounds.xy) / terrain_bounds.zw;\n  if (texCoords.x >= 0.0 && texCoords.y >= 0.0 && texCoords.x <= 1.0 && texCoords.y <= 1.0) {\n    float terrainZ = texture2D(terrain_map, texCoords).r;\n    geometry.position.z += terrainZ;\n    position = project_common_position_to_clipspace(geometry.position);\n  }\n}\n    `,\n    'fs:#decl': `\nuniform float terrain_mode;\nuniform sampler2D terrain_map;\nuniform vec4 terrain_bounds;\nvarying vec3 commonPos;\n${TERRAIN_MODE_CONSTANTS}\n    `,\n    'fs:#main-start': `\nif (terrain_mode == TERRAIN_MODE_WRITE_HEIGHT_MAP) {\n  gl_FragColor = vec4(commonPos.z, 0.0, 0.0, 1.0);\n  return;\n}\n    `,\n    'fs:DECKGL_FILTER_COLOR': `\nif ((terrain_mode == TERRAIN_MODE_USE_COVER) || (terrain_mode == TERRAIN_MODE_USE_COVER_ONLY)) {\n  vec2 texCoords = (commonPos.xy - terrain_bounds.xy) / terrain_bounds.zw;\n  vec4 pixel = texture2D(terrain_map, texCoords);\n  if (terrain_mode == TERRAIN_MODE_USE_COVER_ONLY) {\n    color = pixel;\n  } else {\n    // pixel is premultiplied\n    color = pixel + color * (1.0 - pixel.a);\n  }\n  return;\n}\n    `\n  },\n  // eslint-disable-next-line complexity\n  getUniforms: (opts = {}, uniforms) => {\n    if ('dummyHeightMap' in opts) {\n      const {\n        drawToTerrainHeightMap,\n        heightMap,\n        heightMapBounds,\n        dummyHeightMap,\n        terrainCover,\n        useTerrainHeightMap,\n        terrainSkipRender\n      } = opts;\n      const {project_uCommonOrigin} = uniforms;\n\n      let mode: number = terrainSkipRender ? TERRAIN_MODE.SKIP : TERRAIN_MODE.NONE;\n      // height map if case USE_HEIGHT_MAP, terrain cover if USE_COVER, otherwise empty\n      let sampler: Texture2D = dummyHeightMap;\n      // height map bounds if case USE_HEIGHT_MAP, terrain cover bounds if USE_COVER, otherwise null\n      let bounds: number[] | null = null;\n      if (drawToTerrainHeightMap) {\n        mode = TERRAIN_MODE.WRITE_HEIGHT_MAP;\n        bounds = heightMapBounds!;\n      } else if (useTerrainHeightMap && heightMap) {\n        mode = TERRAIN_MODE.USE_HEIGHT_MAP;\n        sampler = heightMap;\n        bounds = heightMapBounds!;\n      } else if (terrainCover) {\n        // This is a terrain layer\n        const isPicking = opts.pickingActive;\n        sampler = isPicking\n          ? terrainCover.getPickingFramebuffer()\n          : terrainCover.getRenderFramebuffer();\n        if (isPicking) {\n          // Never render the layer itself in picking pass\n          mode = TERRAIN_MODE.SKIP;\n        }\n        if (sampler) {\n          mode = mode === TERRAIN_MODE.SKIP ? TERRAIN_MODE.USE_COVER_ONLY : TERRAIN_MODE.USE_COVER;\n          bounds = terrainCover.bounds;\n        } else {\n          sampler = dummyHeightMap;\n        }\n      }\n\n      /* eslint-disable camelcase */\n      return {\n        terrain_mode: mode,\n        terrain_map: sampler,\n        // Convert bounds to the common space, as [minX, minY, width, height]\n        terrain_bounds: bounds\n          ? [\n              bounds[0] - project_uCommonOrigin[0],\n              bounds[1] - project_uCommonOrigin[1],\n              bounds[2] - bounds[0],\n              bounds[3] - bounds[1]\n            ]\n          : [0, 0, 0, 0]\n      };\n    }\n    return null;\n  }\n} as ShaderModule<TerrainModuleSettings>;\n"],"file":"shader-module.js"}