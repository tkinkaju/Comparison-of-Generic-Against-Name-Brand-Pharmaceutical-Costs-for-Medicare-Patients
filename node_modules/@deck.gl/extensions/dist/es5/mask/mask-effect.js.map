{"version":3,"sources":["../../../src/mask/mask-effect.ts"],"names":["MaskEffect","gl","layers","layerFilter","viewports","onViewportActive","views","isPicking","didRender","dummyMaskMap","Texture2D","width","height","maskLayers","filter","l","props","visible","operation","includes","length","masks","channels","maskPass","MaskPass","id","maskMap","channelMap","_sortMaskChannels","viewport","viewportChanged","lastViewport","equals","resolution","undefined","log","warn","maskId","result","_renderChannel","channelInfo","oldChannelInfo","index","maskChanged","some","layer","i","transitions","layerBounds","b","bounds","maskBounds","maskViewport","border","getBounds","render","pass","channel","moduleParameters","devicePixelRatio","coordinateOrigin","coordinateSystem","channelCount","root","findIndex","c","push","maskChannels","delete"],"mappings":"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","sourcesContent":["import {Layer, Viewport, Effect, PreRenderOptions, CoordinateSystem, log} from '@deck.gl/core';\nimport {Texture2D} from '@luma.gl/core';\nimport {equals} from '@math.gl/core';\nimport MaskPass from './mask-pass';\nimport {joinLayerBounds, getRenderBounds, makeViewport, Bounds} from '../utils/projection-utils';\n// import {debugFBO} from '../utils/debug';\n\ntype Mask = {\n  /** The channel index */\n  index: number;\n  bounds: Bounds;\n  coordinateOrigin: [number, number, number];\n  coordinateSystem: CoordinateSystem;\n};\n\ntype Channel = {\n  id: string;\n  index: number;\n  layers: Layer[];\n  bounds: Bounds | null;\n  maskBounds: Bounds;\n  layerBounds: Bounds[];\n  coordinateOrigin: [number, number, number];\n  coordinateSystem: CoordinateSystem;\n};\n\nexport type MaskPreRenderStats = {\n  didRender: boolean;\n};\n\n// Class to manage mask effect\nexport default class MaskEffect implements Effect {\n  id = 'mask-effect';\n  props = null;\n  useInPicking = true;\n  order = 0;\n\n  private dummyMaskMap?: Texture2D;\n  private channels: (Channel | null)[] = [];\n  private masks: Record<string, Mask> | null = null;\n  private maskPass?: MaskPass;\n  private maskMap?: Texture2D;\n  private lastViewport?: Viewport;\n\n  preRender(\n    gl: WebGLRenderingContext,\n    {layers, layerFilter, viewports, onViewportActive, views, isPicking}: PreRenderOptions\n  ): MaskPreRenderStats {\n    let didRender = false;\n    if (!this.dummyMaskMap) {\n      this.dummyMaskMap = new Texture2D(gl, {\n        width: 1,\n        height: 1\n      });\n    }\n\n    if (isPicking) {\n      // Do not update on picking pass\n      return {didRender};\n    }\n\n    const maskLayers = layers.filter(l => l.props.visible && l.props.operation.includes('mask'));\n    if (maskLayers.length === 0) {\n      this.masks = null;\n      this.channels.length = 0;\n      return {didRender};\n    }\n    this.masks = {};\n\n    if (!this.maskPass) {\n      this.maskPass = new MaskPass(gl, {id: 'default-mask'});\n      this.maskMap = this.maskPass.maskMap;\n    }\n\n    // Map layers to channels\n    const channelMap = this._sortMaskChannels(maskLayers);\n    // TODO - support multiple views\n    const viewport = viewports[0];\n    const viewportChanged = !this.lastViewport || !this.lastViewport.equals(viewport);\n\n    if (viewport.resolution !== undefined) {\n      log.warn('MaskExtension is not supported in GlobeView')();\n      return {didRender};\n    }\n\n    for (const maskId in channelMap) {\n      const result = this._renderChannel(channelMap[maskId], {\n        layerFilter,\n        onViewportActive,\n        views,\n        viewport,\n        viewportChanged\n      });\n      didRender ||= result;\n    }\n\n    // debugFBO(this.maskMap, {opaque: true});\n    return {didRender};\n  }\n\n  private _renderChannel(\n    channelInfo: Channel,\n    {\n      layerFilter,\n      onViewportActive,\n      views,\n      viewport,\n      viewportChanged\n    }: {\n      layerFilter: PreRenderOptions['layerFilter'];\n      onViewportActive: PreRenderOptions['onViewportActive'];\n      views: PreRenderOptions['views'];\n      viewport: Viewport;\n      viewportChanged: boolean;\n    }\n  ): boolean {\n    let didRender = false;\n    const oldChannelInfo = this.channels[channelInfo.index];\n    if (!oldChannelInfo) {\n      return didRender;\n    }\n\n    const maskChanged =\n      // If a channel is new\n      channelInfo === oldChannelInfo ||\n      // If sublayers have changed\n      channelInfo.layers.length !== oldChannelInfo.layers.length ||\n      channelInfo.layers.some(\n        (layer, i) =>\n          // Layer instance is updated\n          // Layer props might have changed\n          // Undetermined props could have an effect on the output geometry of a mask layer,\n          // for example getRadius+updateTriggers, radiusScale, modelMatrix\n          layer !== oldChannelInfo.layers[i] ||\n          // Some prop is in transition\n          layer.props.transitions\n      ) ||\n      // If a sublayer's positions have been updated, the cached bounds will change shallowly\n      channelInfo.layerBounds.some((b, i) => b !== oldChannelInfo.layerBounds[i]);\n\n    channelInfo.bounds = oldChannelInfo.bounds;\n    channelInfo.maskBounds = oldChannelInfo.maskBounds;\n    this.channels[channelInfo.index] = channelInfo;\n\n    if (maskChanged || viewportChanged) {\n      // Recalculate mask bounds\n      this.lastViewport = viewport;\n\n      const layerBounds = joinLayerBounds(channelInfo.layers, viewport);\n      channelInfo.bounds = layerBounds && getRenderBounds(layerBounds, viewport);\n\n      if (maskChanged || !equals(channelInfo.bounds, oldChannelInfo.bounds)) {\n        // Rerender mask FBO\n        const {maskPass, maskMap} = this;\n\n        const maskViewport =\n          layerBounds &&\n          makeViewport({\n            bounds: channelInfo.bounds!,\n            viewport,\n            width: maskMap.width,\n            height: maskMap.height,\n            border: 1\n          });\n\n        channelInfo.maskBounds = maskViewport ? maskViewport.getBounds() : [0, 0, 1, 1];\n\n        // @ts-ignore (2532) This method is only called from preRender where maskPass is defined\n        maskPass.render({\n          pass: 'mask',\n          channel: channelInfo.index,\n          layers: channelInfo.layers,\n          layerFilter,\n          viewports: maskViewport ? [maskViewport] : [],\n          onViewportActive,\n          views,\n          moduleParameters: {\n            devicePixelRatio: 1\n          }\n        });\n\n        didRender = true;\n      }\n    }\n\n    // @ts-ignore (2532) This method is only called from preRender where masks is defined\n    this.masks[channelInfo.id] = {\n      index: channelInfo.index,\n      bounds: channelInfo.maskBounds,\n      coordinateOrigin: channelInfo.coordinateOrigin,\n      coordinateSystem: channelInfo.coordinateSystem\n    };\n\n    return didRender;\n  }\n\n  /**\n   * Find a channel to render each mask into\n   * If a maskId already exists, diff and update the existing channel\n   * Otherwise replace a removed mask\n   * Otherwise create a new channel\n   * Returns a map from mask layer id to channel info\n   */\n  private _sortMaskChannels(maskLayers: Layer[]): Record<string, Channel> {\n    const channelMap = {};\n    let channelCount = 0;\n    for (const layer of maskLayers) {\n      const {id} = layer.root;\n      let channelInfo = channelMap[id];\n      if (!channelInfo) {\n        if (++channelCount > 4) {\n          log.warn('Too many mask layers. The max supported is 4')();\n          continue; // eslint-disable-line no-continue\n        }\n        channelInfo = {\n          id,\n          index: this.channels.findIndex(c => c?.id === id),\n          layers: [],\n          layerBounds: [],\n          coordinateOrigin: layer.root.props.coordinateOrigin,\n          coordinateSystem: layer.root.props.coordinateSystem\n        };\n        channelMap[id] = channelInfo;\n      }\n      channelInfo.layers.push(layer);\n      channelInfo.layerBounds.push(layer.getBounds());\n    }\n\n    for (let i = 0; i < 4; i++) {\n      const channelInfo = this.channels[i];\n      if (!channelInfo || !(channelInfo.id in channelMap)) {\n        // The mask id at this channel no longer exists\n        this.channels[i] = null;\n      }\n    }\n\n    for (const maskId in channelMap) {\n      const channelInfo = channelMap[maskId];\n\n      if (channelInfo.index < 0) {\n        channelInfo.index = this.channels.findIndex(c => !c);\n        this.channels[channelInfo.index] = channelInfo;\n      }\n    }\n    return channelMap;\n  }\n\n  getModuleParameters(): {\n    maskMap: Texture2D;\n    maskChannels: Record<string, Mask> | null;\n  } {\n    return {\n      maskMap: this.masks ? this.maskMap : this.dummyMaskMap,\n      maskChannels: this.masks\n    };\n  }\n\n  cleanup(): void {\n    if (this.dummyMaskMap) {\n      this.dummyMaskMap.delete();\n      this.dummyMaskMap = undefined;\n    }\n\n    if (this.maskPass) {\n      this.maskPass.delete();\n      this.maskPass = undefined;\n      this.maskMap = undefined;\n    }\n\n    this.lastViewport = undefined;\n    this.masks = null;\n    this.channels.length = 0;\n  }\n}\n"],"file":"mask-effect.js"}