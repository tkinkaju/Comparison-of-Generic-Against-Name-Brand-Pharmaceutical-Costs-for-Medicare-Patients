(function webpackUniversalModuleDefinition(root, factory) {
  if (typeof exports === 'object' && typeof module === 'object')
    module.exports = factory();
  else if (typeof define === 'function' && define.amd) define([], factory);
        else if (typeof exports === 'object') exports['deck'] = factory();
  else root['deck'] = factory();})(globalThis, function () {
"use strict";
var __exports__ = (() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name10 in all)
      __defProp(target, name10, { get: all[name10], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
  var __publicField = (obj, key, value) => {
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };

  // external-global-plugin:@deck.gl/core
  var require_core = __commonJS({
    "external-global-plugin:@deck.gl/core"(exports, module2) {
      module2.exports = globalThis.deck;
    }
  });

  // external-global-plugin:@luma.gl/core
  var require_core2 = __commonJS({
    "external-global-plugin:@luma.gl/core"(exports, module2) {
      module2.exports = globalThis.luma;
    }
  });

  // (disabled):../../node_modules/@loaders.gl/worker-utils/dist/esm/lib/node/require-utils.node
  var require_require_utils = __commonJS({
    "(disabled):../../node_modules/@loaders.gl/worker-utils/dist/esm/lib/node/require-utils.node"() {
    }
  });

  // bundle.ts
  var bundle_exports = {};
  __export(bundle_exports, {
    ScenegraphLayer: () => ScenegraphLayer,
    SimpleMeshLayer: () => SimpleMeshLayer
  });

  // ../core/bundle/peer-dependency.ts
  var peer_dependency_exports = {};
  var import_core = __toESM(require_core());
  __reExport(peer_dependency_exports, __toESM(require_core()));
  if (!import_core.Layer) {
    throw new Error("@deck.gl/core is not found");
  }

  // bundle.ts
  __reExport(bundle_exports, peer_dependency_exports);

  // src/simple-mesh-layer/simple-mesh-layer.ts
  var import_core3 = __toESM(require_core());

  // ../../node_modules/@luma.gl/constants/dist/esm/index.js
  var esm_default = {
    DEPTH_BUFFER_BIT: 256,
    STENCIL_BUFFER_BIT: 1024,
    COLOR_BUFFER_BIT: 16384,
    POINTS: 0,
    LINES: 1,
    LINE_LOOP: 2,
    LINE_STRIP: 3,
    TRIANGLES: 4,
    TRIANGLE_STRIP: 5,
    TRIANGLE_FAN: 6,
    ZERO: 0,
    ONE: 1,
    SRC_COLOR: 768,
    ONE_MINUS_SRC_COLOR: 769,
    SRC_ALPHA: 770,
    ONE_MINUS_SRC_ALPHA: 771,
    DST_ALPHA: 772,
    ONE_MINUS_DST_ALPHA: 773,
    DST_COLOR: 774,
    ONE_MINUS_DST_COLOR: 775,
    SRC_ALPHA_SATURATE: 776,
    CONSTANT_COLOR: 32769,
    ONE_MINUS_CONSTANT_COLOR: 32770,
    CONSTANT_ALPHA: 32771,
    ONE_MINUS_CONSTANT_ALPHA: 32772,
    FUNC_ADD: 32774,
    FUNC_SUBTRACT: 32778,
    FUNC_REVERSE_SUBTRACT: 32779,
    BLEND_EQUATION: 32777,
    BLEND_EQUATION_RGB: 32777,
    BLEND_EQUATION_ALPHA: 34877,
    BLEND_DST_RGB: 32968,
    BLEND_SRC_RGB: 32969,
    BLEND_DST_ALPHA: 32970,
    BLEND_SRC_ALPHA: 32971,
    BLEND_COLOR: 32773,
    ARRAY_BUFFER_BINDING: 34964,
    ELEMENT_ARRAY_BUFFER_BINDING: 34965,
    LINE_WIDTH: 2849,
    ALIASED_POINT_SIZE_RANGE: 33901,
    ALIASED_LINE_WIDTH_RANGE: 33902,
    CULL_FACE_MODE: 2885,
    FRONT_FACE: 2886,
    DEPTH_RANGE: 2928,
    DEPTH_WRITEMASK: 2930,
    DEPTH_CLEAR_VALUE: 2931,
    DEPTH_FUNC: 2932,
    STENCIL_CLEAR_VALUE: 2961,
    STENCIL_FUNC: 2962,
    STENCIL_FAIL: 2964,
    STENCIL_PASS_DEPTH_FAIL: 2965,
    STENCIL_PASS_DEPTH_PASS: 2966,
    STENCIL_REF: 2967,
    STENCIL_VALUE_MASK: 2963,
    STENCIL_WRITEMASK: 2968,
    STENCIL_BACK_FUNC: 34816,
    STENCIL_BACK_FAIL: 34817,
    STENCIL_BACK_PASS_DEPTH_FAIL: 34818,
    STENCIL_BACK_PASS_DEPTH_PASS: 34819,
    STENCIL_BACK_REF: 36003,
    STENCIL_BACK_VALUE_MASK: 36004,
    STENCIL_BACK_WRITEMASK: 36005,
    VIEWPORT: 2978,
    SCISSOR_BOX: 3088,
    COLOR_CLEAR_VALUE: 3106,
    COLOR_WRITEMASK: 3107,
    UNPACK_ALIGNMENT: 3317,
    PACK_ALIGNMENT: 3333,
    MAX_TEXTURE_SIZE: 3379,
    MAX_VIEWPORT_DIMS: 3386,
    SUBPIXEL_BITS: 3408,
    RED_BITS: 3410,
    GREEN_BITS: 3411,
    BLUE_BITS: 3412,
    ALPHA_BITS: 3413,
    DEPTH_BITS: 3414,
    STENCIL_BITS: 3415,
    POLYGON_OFFSET_UNITS: 10752,
    POLYGON_OFFSET_FACTOR: 32824,
    TEXTURE_BINDING_2D: 32873,
    SAMPLE_BUFFERS: 32936,
    SAMPLES: 32937,
    SAMPLE_COVERAGE_VALUE: 32938,
    SAMPLE_COVERAGE_INVERT: 32939,
    COMPRESSED_TEXTURE_FORMATS: 34467,
    VENDOR: 7936,
    RENDERER: 7937,
    VERSION: 7938,
    IMPLEMENTATION_COLOR_READ_TYPE: 35738,
    IMPLEMENTATION_COLOR_READ_FORMAT: 35739,
    BROWSER_DEFAULT_WEBGL: 37444,
    STATIC_DRAW: 35044,
    STREAM_DRAW: 35040,
    DYNAMIC_DRAW: 35048,
    ARRAY_BUFFER: 34962,
    ELEMENT_ARRAY_BUFFER: 34963,
    BUFFER_SIZE: 34660,
    BUFFER_USAGE: 34661,
    CURRENT_VERTEX_ATTRIB: 34342,
    VERTEX_ATTRIB_ARRAY_ENABLED: 34338,
    VERTEX_ATTRIB_ARRAY_SIZE: 34339,
    VERTEX_ATTRIB_ARRAY_STRIDE: 34340,
    VERTEX_ATTRIB_ARRAY_TYPE: 34341,
    VERTEX_ATTRIB_ARRAY_NORMALIZED: 34922,
    VERTEX_ATTRIB_ARRAY_POINTER: 34373,
    VERTEX_ATTRIB_ARRAY_BUFFER_BINDING: 34975,
    CULL_FACE: 2884,
    FRONT: 1028,
    BACK: 1029,
    FRONT_AND_BACK: 1032,
    BLEND: 3042,
    DEPTH_TEST: 2929,
    DITHER: 3024,
    POLYGON_OFFSET_FILL: 32823,
    SAMPLE_ALPHA_TO_COVERAGE: 32926,
    SAMPLE_COVERAGE: 32928,
    SCISSOR_TEST: 3089,
    STENCIL_TEST: 2960,
    NO_ERROR: 0,
    INVALID_ENUM: 1280,
    INVALID_VALUE: 1281,
    INVALID_OPERATION: 1282,
    OUT_OF_MEMORY: 1285,
    CONTEXT_LOST_WEBGL: 37442,
    CW: 2304,
    CCW: 2305,
    DONT_CARE: 4352,
    FASTEST: 4353,
    NICEST: 4354,
    GENERATE_MIPMAP_HINT: 33170,
    BYTE: 5120,
    UNSIGNED_BYTE: 5121,
    SHORT: 5122,
    UNSIGNED_SHORT: 5123,
    INT: 5124,
    UNSIGNED_INT: 5125,
    FLOAT: 5126,
    DOUBLE: 5130,
    DEPTH_COMPONENT: 6402,
    ALPHA: 6406,
    RGB: 6407,
    RGBA: 6408,
    LUMINANCE: 6409,
    LUMINANCE_ALPHA: 6410,
    UNSIGNED_SHORT_4_4_4_4: 32819,
    UNSIGNED_SHORT_5_5_5_1: 32820,
    UNSIGNED_SHORT_5_6_5: 33635,
    FRAGMENT_SHADER: 35632,
    VERTEX_SHADER: 35633,
    COMPILE_STATUS: 35713,
    DELETE_STATUS: 35712,
    LINK_STATUS: 35714,
    VALIDATE_STATUS: 35715,
    ATTACHED_SHADERS: 35717,
    ACTIVE_ATTRIBUTES: 35721,
    ACTIVE_UNIFORMS: 35718,
    MAX_VERTEX_ATTRIBS: 34921,
    MAX_VERTEX_UNIFORM_VECTORS: 36347,
    MAX_VARYING_VECTORS: 36348,
    MAX_COMBINED_TEXTURE_IMAGE_UNITS: 35661,
    MAX_VERTEX_TEXTURE_IMAGE_UNITS: 35660,
    MAX_TEXTURE_IMAGE_UNITS: 34930,
    MAX_FRAGMENT_UNIFORM_VECTORS: 36349,
    SHADER_TYPE: 35663,
    SHADING_LANGUAGE_VERSION: 35724,
    CURRENT_PROGRAM: 35725,
    NEVER: 512,
    ALWAYS: 519,
    LESS: 513,
    EQUAL: 514,
    LEQUAL: 515,
    GREATER: 516,
    GEQUAL: 518,
    NOTEQUAL: 517,
    KEEP: 7680,
    REPLACE: 7681,
    INCR: 7682,
    DECR: 7683,
    INVERT: 5386,
    INCR_WRAP: 34055,
    DECR_WRAP: 34056,
    NEAREST: 9728,
    LINEAR: 9729,
    NEAREST_MIPMAP_NEAREST: 9984,
    LINEAR_MIPMAP_NEAREST: 9985,
    NEAREST_MIPMAP_LINEAR: 9986,
    LINEAR_MIPMAP_LINEAR: 9987,
    TEXTURE_MAG_FILTER: 10240,
    TEXTURE_MIN_FILTER: 10241,
    TEXTURE_WRAP_S: 10242,
    TEXTURE_WRAP_T: 10243,
    TEXTURE_2D: 3553,
    TEXTURE: 5890,
    TEXTURE_CUBE_MAP: 34067,
    TEXTURE_BINDING_CUBE_MAP: 34068,
    TEXTURE_CUBE_MAP_POSITIVE_X: 34069,
    TEXTURE_CUBE_MAP_NEGATIVE_X: 34070,
    TEXTURE_CUBE_MAP_POSITIVE_Y: 34071,
    TEXTURE_CUBE_MAP_NEGATIVE_Y: 34072,
    TEXTURE_CUBE_MAP_POSITIVE_Z: 34073,
    TEXTURE_CUBE_MAP_NEGATIVE_Z: 34074,
    MAX_CUBE_MAP_TEXTURE_SIZE: 34076,
    TEXTURE0: 33984,
    ACTIVE_TEXTURE: 34016,
    REPEAT: 10497,
    CLAMP_TO_EDGE: 33071,
    MIRRORED_REPEAT: 33648,
    TEXTURE_WIDTH: 4096,
    TEXTURE_HEIGHT: 4097,
    FLOAT_VEC2: 35664,
    FLOAT_VEC3: 35665,
    FLOAT_VEC4: 35666,
    INT_VEC2: 35667,
    INT_VEC3: 35668,
    INT_VEC4: 35669,
    BOOL: 35670,
    BOOL_VEC2: 35671,
    BOOL_VEC3: 35672,
    BOOL_VEC4: 35673,
    FLOAT_MAT2: 35674,
    FLOAT_MAT3: 35675,
    FLOAT_MAT4: 35676,
    SAMPLER_2D: 35678,
    SAMPLER_CUBE: 35680,
    LOW_FLOAT: 36336,
    MEDIUM_FLOAT: 36337,
    HIGH_FLOAT: 36338,
    LOW_INT: 36339,
    MEDIUM_INT: 36340,
    HIGH_INT: 36341,
    FRAMEBUFFER: 36160,
    RENDERBUFFER: 36161,
    RGBA4: 32854,
    RGB5_A1: 32855,
    RGB565: 36194,
    DEPTH_COMPONENT16: 33189,
    STENCIL_INDEX: 6401,
    STENCIL_INDEX8: 36168,
    DEPTH_STENCIL: 34041,
    RENDERBUFFER_WIDTH: 36162,
    RENDERBUFFER_HEIGHT: 36163,
    RENDERBUFFER_INTERNAL_FORMAT: 36164,
    RENDERBUFFER_RED_SIZE: 36176,
    RENDERBUFFER_GREEN_SIZE: 36177,
    RENDERBUFFER_BLUE_SIZE: 36178,
    RENDERBUFFER_ALPHA_SIZE: 36179,
    RENDERBUFFER_DEPTH_SIZE: 36180,
    RENDERBUFFER_STENCIL_SIZE: 36181,
    FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE: 36048,
    FRAMEBUFFER_ATTACHMENT_OBJECT_NAME: 36049,
    FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL: 36050,
    FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE: 36051,
    COLOR_ATTACHMENT0: 36064,
    DEPTH_ATTACHMENT: 36096,
    STENCIL_ATTACHMENT: 36128,
    DEPTH_STENCIL_ATTACHMENT: 33306,
    NONE: 0,
    FRAMEBUFFER_COMPLETE: 36053,
    FRAMEBUFFER_INCOMPLETE_ATTACHMENT: 36054,
    FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT: 36055,
    FRAMEBUFFER_INCOMPLETE_DIMENSIONS: 36057,
    FRAMEBUFFER_UNSUPPORTED: 36061,
    FRAMEBUFFER_BINDING: 36006,
    RENDERBUFFER_BINDING: 36007,
    READ_FRAMEBUFFER: 36008,
    DRAW_FRAMEBUFFER: 36009,
    MAX_RENDERBUFFER_SIZE: 34024,
    INVALID_FRAMEBUFFER_OPERATION: 1286,
    UNPACK_FLIP_Y_WEBGL: 37440,
    UNPACK_PREMULTIPLY_ALPHA_WEBGL: 37441,
    UNPACK_COLORSPACE_CONVERSION_WEBGL: 37443,
    READ_BUFFER: 3074,
    UNPACK_ROW_LENGTH: 3314,
    UNPACK_SKIP_ROWS: 3315,
    UNPACK_SKIP_PIXELS: 3316,
    PACK_ROW_LENGTH: 3330,
    PACK_SKIP_ROWS: 3331,
    PACK_SKIP_PIXELS: 3332,
    TEXTURE_BINDING_3D: 32874,
    UNPACK_SKIP_IMAGES: 32877,
    UNPACK_IMAGE_HEIGHT: 32878,
    MAX_3D_TEXTURE_SIZE: 32883,
    MAX_ELEMENTS_VERTICES: 33e3,
    MAX_ELEMENTS_INDICES: 33001,
    MAX_TEXTURE_LOD_BIAS: 34045,
    MAX_FRAGMENT_UNIFORM_COMPONENTS: 35657,
    MAX_VERTEX_UNIFORM_COMPONENTS: 35658,
    MAX_ARRAY_TEXTURE_LAYERS: 35071,
    MIN_PROGRAM_TEXEL_OFFSET: 35076,
    MAX_PROGRAM_TEXEL_OFFSET: 35077,
    MAX_VARYING_COMPONENTS: 35659,
    FRAGMENT_SHADER_DERIVATIVE_HINT: 35723,
    RASTERIZER_DISCARD: 35977,
    VERTEX_ARRAY_BINDING: 34229,
    MAX_VERTEX_OUTPUT_COMPONENTS: 37154,
    MAX_FRAGMENT_INPUT_COMPONENTS: 37157,
    MAX_SERVER_WAIT_TIMEOUT: 37137,
    MAX_ELEMENT_INDEX: 36203,
    RED: 6403,
    RGB8: 32849,
    RGBA8: 32856,
    RGB10_A2: 32857,
    TEXTURE_3D: 32879,
    TEXTURE_WRAP_R: 32882,
    TEXTURE_MIN_LOD: 33082,
    TEXTURE_MAX_LOD: 33083,
    TEXTURE_BASE_LEVEL: 33084,
    TEXTURE_MAX_LEVEL: 33085,
    TEXTURE_COMPARE_MODE: 34892,
    TEXTURE_COMPARE_FUNC: 34893,
    SRGB: 35904,
    SRGB8: 35905,
    SRGB8_ALPHA8: 35907,
    COMPARE_REF_TO_TEXTURE: 34894,
    RGBA32F: 34836,
    RGB32F: 34837,
    RGBA16F: 34842,
    RGB16F: 34843,
    TEXTURE_2D_ARRAY: 35866,
    TEXTURE_BINDING_2D_ARRAY: 35869,
    R11F_G11F_B10F: 35898,
    RGB9_E5: 35901,
    RGBA32UI: 36208,
    RGB32UI: 36209,
    RGBA16UI: 36214,
    RGB16UI: 36215,
    RGBA8UI: 36220,
    RGB8UI: 36221,
    RGBA32I: 36226,
    RGB32I: 36227,
    RGBA16I: 36232,
    RGB16I: 36233,
    RGBA8I: 36238,
    RGB8I: 36239,
    RED_INTEGER: 36244,
    RGB_INTEGER: 36248,
    RGBA_INTEGER: 36249,
    R8: 33321,
    RG8: 33323,
    R16F: 33325,
    R32F: 33326,
    RG16F: 33327,
    RG32F: 33328,
    R8I: 33329,
    R8UI: 33330,
    R16I: 33331,
    R16UI: 33332,
    R32I: 33333,
    R32UI: 33334,
    RG8I: 33335,
    RG8UI: 33336,
    RG16I: 33337,
    RG16UI: 33338,
    RG32I: 33339,
    RG32UI: 33340,
    R8_SNORM: 36756,
    RG8_SNORM: 36757,
    RGB8_SNORM: 36758,
    RGBA8_SNORM: 36759,
    RGB10_A2UI: 36975,
    TEXTURE_IMMUTABLE_FORMAT: 37167,
    TEXTURE_IMMUTABLE_LEVELS: 33503,
    UNSIGNED_INT_2_10_10_10_REV: 33640,
    UNSIGNED_INT_10F_11F_11F_REV: 35899,
    UNSIGNED_INT_5_9_9_9_REV: 35902,
    FLOAT_32_UNSIGNED_INT_24_8_REV: 36269,
    UNSIGNED_INT_24_8: 34042,
    HALF_FLOAT: 5131,
    RG: 33319,
    RG_INTEGER: 33320,
    INT_2_10_10_10_REV: 36255,
    CURRENT_QUERY: 34917,
    QUERY_RESULT: 34918,
    QUERY_RESULT_AVAILABLE: 34919,
    ANY_SAMPLES_PASSED: 35887,
    ANY_SAMPLES_PASSED_CONSERVATIVE: 36202,
    MAX_DRAW_BUFFERS: 34852,
    DRAW_BUFFER0: 34853,
    DRAW_BUFFER1: 34854,
    DRAW_BUFFER2: 34855,
    DRAW_BUFFER3: 34856,
    DRAW_BUFFER4: 34857,
    DRAW_BUFFER5: 34858,
    DRAW_BUFFER6: 34859,
    DRAW_BUFFER7: 34860,
    DRAW_BUFFER8: 34861,
    DRAW_BUFFER9: 34862,
    DRAW_BUFFER10: 34863,
    DRAW_BUFFER11: 34864,
    DRAW_BUFFER12: 34865,
    DRAW_BUFFER13: 34866,
    DRAW_BUFFER14: 34867,
    DRAW_BUFFER15: 34868,
    MAX_COLOR_ATTACHMENTS: 36063,
    COLOR_ATTACHMENT1: 36065,
    COLOR_ATTACHMENT2: 36066,
    COLOR_ATTACHMENT3: 36067,
    COLOR_ATTACHMENT4: 36068,
    COLOR_ATTACHMENT5: 36069,
    COLOR_ATTACHMENT6: 36070,
    COLOR_ATTACHMENT7: 36071,
    COLOR_ATTACHMENT8: 36072,
    COLOR_ATTACHMENT9: 36073,
    COLOR_ATTACHMENT10: 36074,
    COLOR_ATTACHMENT11: 36075,
    COLOR_ATTACHMENT12: 36076,
    COLOR_ATTACHMENT13: 36077,
    COLOR_ATTACHMENT14: 36078,
    COLOR_ATTACHMENT15: 36079,
    SAMPLER_3D: 35679,
    SAMPLER_2D_SHADOW: 35682,
    SAMPLER_2D_ARRAY: 36289,
    SAMPLER_2D_ARRAY_SHADOW: 36292,
    SAMPLER_CUBE_SHADOW: 36293,
    INT_SAMPLER_2D: 36298,
    INT_SAMPLER_3D: 36299,
    INT_SAMPLER_CUBE: 36300,
    INT_SAMPLER_2D_ARRAY: 36303,
    UNSIGNED_INT_SAMPLER_2D: 36306,
    UNSIGNED_INT_SAMPLER_3D: 36307,
    UNSIGNED_INT_SAMPLER_CUBE: 36308,
    UNSIGNED_INT_SAMPLER_2D_ARRAY: 36311,
    MAX_SAMPLES: 36183,
    SAMPLER_BINDING: 35097,
    PIXEL_PACK_BUFFER: 35051,
    PIXEL_UNPACK_BUFFER: 35052,
    PIXEL_PACK_BUFFER_BINDING: 35053,
    PIXEL_UNPACK_BUFFER_BINDING: 35055,
    COPY_READ_BUFFER: 36662,
    COPY_WRITE_BUFFER: 36663,
    COPY_READ_BUFFER_BINDING: 36662,
    COPY_WRITE_BUFFER_BINDING: 36663,
    FLOAT_MAT2x3: 35685,
    FLOAT_MAT2x4: 35686,
    FLOAT_MAT3x2: 35687,
    FLOAT_MAT3x4: 35688,
    FLOAT_MAT4x2: 35689,
    FLOAT_MAT4x3: 35690,
    UNSIGNED_INT_VEC2: 36294,
    UNSIGNED_INT_VEC3: 36295,
    UNSIGNED_INT_VEC4: 36296,
    UNSIGNED_NORMALIZED: 35863,
    SIGNED_NORMALIZED: 36764,
    VERTEX_ATTRIB_ARRAY_INTEGER: 35069,
    VERTEX_ATTRIB_ARRAY_DIVISOR: 35070,
    TRANSFORM_FEEDBACK_BUFFER_MODE: 35967,
    MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS: 35968,
    TRANSFORM_FEEDBACK_VARYINGS: 35971,
    TRANSFORM_FEEDBACK_BUFFER_START: 35972,
    TRANSFORM_FEEDBACK_BUFFER_SIZE: 35973,
    TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN: 35976,
    MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS: 35978,
    MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS: 35979,
    INTERLEAVED_ATTRIBS: 35980,
    SEPARATE_ATTRIBS: 35981,
    TRANSFORM_FEEDBACK_BUFFER: 35982,
    TRANSFORM_FEEDBACK_BUFFER_BINDING: 35983,
    TRANSFORM_FEEDBACK: 36386,
    TRANSFORM_FEEDBACK_PAUSED: 36387,
    TRANSFORM_FEEDBACK_ACTIVE: 36388,
    TRANSFORM_FEEDBACK_BINDING: 36389,
    FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING: 33296,
    FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE: 33297,
    FRAMEBUFFER_ATTACHMENT_RED_SIZE: 33298,
    FRAMEBUFFER_ATTACHMENT_GREEN_SIZE: 33299,
    FRAMEBUFFER_ATTACHMENT_BLUE_SIZE: 33300,
    FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE: 33301,
    FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE: 33302,
    FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE: 33303,
    FRAMEBUFFER_DEFAULT: 33304,
    DEPTH24_STENCIL8: 35056,
    DRAW_FRAMEBUFFER_BINDING: 36006,
    READ_FRAMEBUFFER_BINDING: 36010,
    RENDERBUFFER_SAMPLES: 36011,
    FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER: 36052,
    FRAMEBUFFER_INCOMPLETE_MULTISAMPLE: 36182,
    UNIFORM_BUFFER: 35345,
    UNIFORM_BUFFER_BINDING: 35368,
    UNIFORM_BUFFER_START: 35369,
    UNIFORM_BUFFER_SIZE: 35370,
    MAX_VERTEX_UNIFORM_BLOCKS: 35371,
    MAX_FRAGMENT_UNIFORM_BLOCKS: 35373,
    MAX_COMBINED_UNIFORM_BLOCKS: 35374,
    MAX_UNIFORM_BUFFER_BINDINGS: 35375,
    MAX_UNIFORM_BLOCK_SIZE: 35376,
    MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS: 35377,
    MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS: 35379,
    UNIFORM_BUFFER_OFFSET_ALIGNMENT: 35380,
    ACTIVE_UNIFORM_BLOCKS: 35382,
    UNIFORM_TYPE: 35383,
    UNIFORM_SIZE: 35384,
    UNIFORM_BLOCK_INDEX: 35386,
    UNIFORM_OFFSET: 35387,
    UNIFORM_ARRAY_STRIDE: 35388,
    UNIFORM_MATRIX_STRIDE: 35389,
    UNIFORM_IS_ROW_MAJOR: 35390,
    UNIFORM_BLOCK_BINDING: 35391,
    UNIFORM_BLOCK_DATA_SIZE: 35392,
    UNIFORM_BLOCK_ACTIVE_UNIFORMS: 35394,
    UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES: 35395,
    UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER: 35396,
    UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER: 35398,
    OBJECT_TYPE: 37138,
    SYNC_CONDITION: 37139,
    SYNC_STATUS: 37140,
    SYNC_FLAGS: 37141,
    SYNC_FENCE: 37142,
    SYNC_GPU_COMMANDS_COMPLETE: 37143,
    UNSIGNALED: 37144,
    SIGNALED: 37145,
    ALREADY_SIGNALED: 37146,
    TIMEOUT_EXPIRED: 37147,
    CONDITION_SATISFIED: 37148,
    WAIT_FAILED: 37149,
    SYNC_FLUSH_COMMANDS_BIT: 1,
    COLOR: 6144,
    DEPTH: 6145,
    STENCIL: 6146,
    MIN: 32775,
    MAX: 32776,
    DEPTH_COMPONENT24: 33190,
    STREAM_READ: 35041,
    STREAM_COPY: 35042,
    STATIC_READ: 35045,
    STATIC_COPY: 35046,
    DYNAMIC_READ: 35049,
    DYNAMIC_COPY: 35050,
    DEPTH_COMPONENT32F: 36012,
    DEPTH32F_STENCIL8: 36013,
    INVALID_INDEX: 4294967295,
    TIMEOUT_IGNORED: -1,
    MAX_CLIENT_WAIT_TIMEOUT_WEBGL: 37447,
    VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE: 35070,
    UNMASKED_VENDOR_WEBGL: 37445,
    UNMASKED_RENDERER_WEBGL: 37446,
    MAX_TEXTURE_MAX_ANISOTROPY_EXT: 34047,
    TEXTURE_MAX_ANISOTROPY_EXT: 34046,
    COMPRESSED_RGB_S3TC_DXT1_EXT: 33776,
    COMPRESSED_RGBA_S3TC_DXT1_EXT: 33777,
    COMPRESSED_RGBA_S3TC_DXT3_EXT: 33778,
    COMPRESSED_RGBA_S3TC_DXT5_EXT: 33779,
    COMPRESSED_R11_EAC: 37488,
    COMPRESSED_SIGNED_R11_EAC: 37489,
    COMPRESSED_RG11_EAC: 37490,
    COMPRESSED_SIGNED_RG11_EAC: 37491,
    COMPRESSED_RGB8_ETC2: 37492,
    COMPRESSED_RGBA8_ETC2_EAC: 37493,
    COMPRESSED_SRGB8_ETC2: 37494,
    COMPRESSED_SRGB8_ALPHA8_ETC2_EAC: 37495,
    COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2: 37496,
    COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2: 37497,
    COMPRESSED_RGB_PVRTC_4BPPV1_IMG: 35840,
    COMPRESSED_RGBA_PVRTC_4BPPV1_IMG: 35842,
    COMPRESSED_RGB_PVRTC_2BPPV1_IMG: 35841,
    COMPRESSED_RGBA_PVRTC_2BPPV1_IMG: 35843,
    COMPRESSED_RGB_ETC1_WEBGL: 36196,
    COMPRESSED_RGB_ATC_WEBGL: 35986,
    COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL: 35986,
    COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL: 34798,
    UNSIGNED_INT_24_8_WEBGL: 34042,
    HALF_FLOAT_OES: 36193,
    RGBA32F_EXT: 34836,
    RGB32F_EXT: 34837,
    FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE_EXT: 33297,
    UNSIGNED_NORMALIZED_EXT: 35863,
    MIN_EXT: 32775,
    MAX_EXT: 32776,
    SRGB_EXT: 35904,
    SRGB_ALPHA_EXT: 35906,
    SRGB8_ALPHA8_EXT: 35907,
    FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING_EXT: 33296,
    FRAGMENT_SHADER_DERIVATIVE_HINT_OES: 35723,
    COLOR_ATTACHMENT0_WEBGL: 36064,
    COLOR_ATTACHMENT1_WEBGL: 36065,
    COLOR_ATTACHMENT2_WEBGL: 36066,
    COLOR_ATTACHMENT3_WEBGL: 36067,
    COLOR_ATTACHMENT4_WEBGL: 36068,
    COLOR_ATTACHMENT5_WEBGL: 36069,
    COLOR_ATTACHMENT6_WEBGL: 36070,
    COLOR_ATTACHMENT7_WEBGL: 36071,
    COLOR_ATTACHMENT8_WEBGL: 36072,
    COLOR_ATTACHMENT9_WEBGL: 36073,
    COLOR_ATTACHMENT10_WEBGL: 36074,
    COLOR_ATTACHMENT11_WEBGL: 36075,
    COLOR_ATTACHMENT12_WEBGL: 36076,
    COLOR_ATTACHMENT13_WEBGL: 36077,
    COLOR_ATTACHMENT14_WEBGL: 36078,
    COLOR_ATTACHMENT15_WEBGL: 36079,
    DRAW_BUFFER0_WEBGL: 34853,
    DRAW_BUFFER1_WEBGL: 34854,
    DRAW_BUFFER2_WEBGL: 34855,
    DRAW_BUFFER3_WEBGL: 34856,
    DRAW_BUFFER4_WEBGL: 34857,
    DRAW_BUFFER5_WEBGL: 34858,
    DRAW_BUFFER6_WEBGL: 34859,
    DRAW_BUFFER7_WEBGL: 34860,
    DRAW_BUFFER8_WEBGL: 34861,
    DRAW_BUFFER9_WEBGL: 34862,
    DRAW_BUFFER10_WEBGL: 34863,
    DRAW_BUFFER11_WEBGL: 34864,
    DRAW_BUFFER12_WEBGL: 34865,
    DRAW_BUFFER13_WEBGL: 34866,
    DRAW_BUFFER14_WEBGL: 34867,
    DRAW_BUFFER15_WEBGL: 34868,
    MAX_COLOR_ATTACHMENTS_WEBGL: 36063,
    MAX_DRAW_BUFFERS_WEBGL: 34852,
    VERTEX_ARRAY_BINDING_OES: 34229,
    QUERY_COUNTER_BITS_EXT: 34916,
    CURRENT_QUERY_EXT: 34917,
    QUERY_RESULT_EXT: 34918,
    QUERY_RESULT_AVAILABLE_EXT: 34919,
    TIME_ELAPSED_EXT: 35007,
    TIMESTAMP_EXT: 36392,
    GPU_DISJOINT_EXT: 36795
  };

  // src/simple-mesh-layer/simple-mesh-layer.ts
  var import_core4 = __toESM(require_core2());

  // ../../node_modules/@babel/runtime/helpers/esm/defineProperty.js
  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }

  // ../../node_modules/@probe.gl/env/dist/esm/lib/is-electron.js
  function isElectron(mockUserAgent) {
    if (typeof window !== "undefined" && typeof window.process === "object" && window.process.type === "renderer") {
      return true;
    }
    if (typeof process !== "undefined" && typeof process.versions === "object" && Boolean(process.versions.electron)) {
      return true;
    }
    const realUserAgent = typeof navigator === "object" && typeof navigator.userAgent === "string" && navigator.userAgent;
    const userAgent = mockUserAgent || realUserAgent;
    if (userAgent && userAgent.indexOf("Electron") >= 0) {
      return true;
    }
    return false;
  }

  // ../../node_modules/@probe.gl/env/dist/esm/lib/is-browser.js
  function isBrowser() {
    const isNode = typeof process === "object" && String(process) === "[object process]" && !process.browser;
    return !isNode || isElectron();
  }

  // ../../node_modules/@probe.gl/env/dist/esm/lib/globals.js
  var globals = {
    self: typeof self !== "undefined" && self,
    window: typeof window !== "undefined" && window,
    global: typeof global !== "undefined" && global,
    document: typeof document !== "undefined" && document,
    process: typeof process === "object" && process
  };
  var self_ = globals.self || globals.window || globals.global;
  var window_ = globals.window || globals.self || globals.global;
  var document_ = globals.document || {};
  var process_ = globals.process || {};

  // ../../node_modules/@probe.gl/env/dist/esm/utils/globals.js
  var VERSION = typeof __VERSION__ !== "undefined" ? __VERSION__ : "untranspiled source";
  var isBrowser2 = isBrowser();

  // ../../node_modules/@probe.gl/env/dist/esm/lib/get-browser.js
  var window2 = globalThis;
  function getBrowser(mockUserAgent) {
    if (!mockUserAgent && !isBrowser()) {
      return "Node";
    }
    if (isElectron(mockUserAgent)) {
      return "Electron";
    }
    const navigator_ = typeof navigator !== "undefined" ? navigator : {};
    const userAgent = mockUserAgent || navigator_.userAgent || "";
    if (userAgent.indexOf("Edge") > -1) {
      return "Edge";
    }
    const isMSIE = userAgent.indexOf("MSIE ") !== -1;
    const isTrident = userAgent.indexOf("Trident/") !== -1;
    if (isMSIE || isTrident) {
      return "IE";
    }
    if (window2.chrome) {
      return "Chrome";
    }
    if (window2.safari) {
      return "Safari";
    }
    if (window2.mozInnerScreenX) {
      return "Firefox";
    }
    return "Unknown";
  }

  // ../../node_modules/@probe.gl/log/dist/esm/utils/local-storage.js
  function getStorage(type) {
    try {
      const storage = window[type];
      const x = "__storage_test__";
      storage.setItem(x, x);
      storage.removeItem(x);
      return storage;
    } catch (e) {
      return null;
    }
  }
  var LocalStorage = class {
    constructor(id) {
      let defaultSettings = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      let type = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "sessionStorage";
      _defineProperty(this, "storage", void 0);
      _defineProperty(this, "id", void 0);
      _defineProperty(this, "config", {});
      this.storage = getStorage(type);
      this.id = id;
      this.config = {};
      Object.assign(this.config, defaultSettings);
      this._loadConfiguration();
    }
    getConfiguration() {
      return this.config;
    }
    setConfiguration(configuration) {
      this.config = {};
      return this.updateConfiguration(configuration);
    }
    updateConfiguration(configuration) {
      Object.assign(this.config, configuration);
      if (this.storage) {
        const serialized = JSON.stringify(this.config);
        this.storage.setItem(this.id, serialized);
      }
      return this;
    }
    _loadConfiguration() {
      let configuration = {};
      if (this.storage) {
        const serializedConfiguration = this.storage.getItem(this.id);
        configuration = serializedConfiguration ? JSON.parse(serializedConfiguration) : {};
      }
      Object.assign(this.config, configuration);
      return this;
    }
  };

  // ../../node_modules/@probe.gl/log/dist/esm/utils/formatters.js
  function formatTime(ms) {
    let formatted;
    if (ms < 10) {
      formatted = "".concat(ms.toFixed(2), "ms");
    } else if (ms < 100) {
      formatted = "".concat(ms.toFixed(1), "ms");
    } else if (ms < 1e3) {
      formatted = "".concat(ms.toFixed(0), "ms");
    } else {
      formatted = "".concat((ms / 1e3).toFixed(2), "s");
    }
    return formatted;
  }
  function leftPad(string) {
    let length4 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 8;
    const padLength = Math.max(length4 - string.length, 0);
    return "".concat(" ".repeat(padLength)).concat(string);
  }
  function formatImage(image, message, scale5) {
    let maxWidth = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 600;
    const imageUrl = image.src.replace(/\(/g, "%28").replace(/\)/g, "%29");
    if (image.width > maxWidth) {
      scale5 = Math.min(scale5, maxWidth / image.width);
    }
    const width = image.width * scale5;
    const height = image.height * scale5;
    const style = ["font-size:1px;", "padding:".concat(Math.floor(height / 2), "px ").concat(Math.floor(width / 2), "px;"), "line-height:".concat(height, "px;"), "background:url(".concat(imageUrl, ");"), "background-size:".concat(width, "px ").concat(height, "px;"), "color:transparent;"].join("");
    return ["".concat(message, " %c+"), style];
  }

  // ../../node_modules/@probe.gl/log/dist/esm/utils/color.js
  var COLOR;
  (function(COLOR2) {
    COLOR2[COLOR2["BLACK"] = 30] = "BLACK";
    COLOR2[COLOR2["RED"] = 31] = "RED";
    COLOR2[COLOR2["GREEN"] = 32] = "GREEN";
    COLOR2[COLOR2["YELLOW"] = 33] = "YELLOW";
    COLOR2[COLOR2["BLUE"] = 34] = "BLUE";
    COLOR2[COLOR2["MAGENTA"] = 35] = "MAGENTA";
    COLOR2[COLOR2["CYAN"] = 36] = "CYAN";
    COLOR2[COLOR2["WHITE"] = 37] = "WHITE";
    COLOR2[COLOR2["BRIGHT_BLACK"] = 90] = "BRIGHT_BLACK";
    COLOR2[COLOR2["BRIGHT_RED"] = 91] = "BRIGHT_RED";
    COLOR2[COLOR2["BRIGHT_GREEN"] = 92] = "BRIGHT_GREEN";
    COLOR2[COLOR2["BRIGHT_YELLOW"] = 93] = "BRIGHT_YELLOW";
    COLOR2[COLOR2["BRIGHT_BLUE"] = 94] = "BRIGHT_BLUE";
    COLOR2[COLOR2["BRIGHT_MAGENTA"] = 95] = "BRIGHT_MAGENTA";
    COLOR2[COLOR2["BRIGHT_CYAN"] = 96] = "BRIGHT_CYAN";
    COLOR2[COLOR2["BRIGHT_WHITE"] = 97] = "BRIGHT_WHITE";
  })(COLOR || (COLOR = {}));
  function getColor(color) {
    return typeof color === "string" ? COLOR[color.toUpperCase()] || COLOR.WHITE : color;
  }
  function addColor(string, color, background) {
    if (!isBrowser && typeof string === "string") {
      if (color) {
        color = getColor(color);
        string = "\x1B[".concat(color, "m").concat(string, "\x1B[39m");
      }
      if (background) {
        color = getColor(background);
        string = "\x1B[".concat(background + 10, "m").concat(string, "\x1B[49m");
      }
    }
    return string;
  }

  // ../../node_modules/@probe.gl/log/dist/esm/utils/autobind.js
  function autobind(obj) {
    let predefined = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ["constructor"];
    const proto = Object.getPrototypeOf(obj);
    const propNames = Object.getOwnPropertyNames(proto);
    for (const key of propNames) {
      if (typeof obj[key] === "function") {
        if (!predefined.find((name10) => key === name10)) {
          obj[key] = obj[key].bind(obj);
        }
      }
    }
  }

  // ../../node_modules/@probe.gl/log/dist/esm/utils/assert.js
  function assert(condition, message) {
    if (!condition) {
      throw new Error(message || "Assertion failed");
    }
  }

  // ../../node_modules/@probe.gl/log/dist/esm/utils/hi-res-timestamp.js
  function getHiResTimestamp() {
    let timestamp;
    if (isBrowser && "performance" in window_) {
      var _window$performance, _window$performance$n;
      timestamp = window_ === null || window_ === void 0 ? void 0 : (_window$performance = window_.performance) === null || _window$performance === void 0 ? void 0 : (_window$performance$n = _window$performance.now) === null || _window$performance$n === void 0 ? void 0 : _window$performance$n.call(_window$performance);
    } else if ("hrtime" in process_) {
      var _process$hrtime;
      const timeParts = process_ === null || process_ === void 0 ? void 0 : (_process$hrtime = process_.hrtime) === null || _process$hrtime === void 0 ? void 0 : _process$hrtime.call(process_);
      timestamp = timeParts[0] * 1e3 + timeParts[1] / 1e6;
    } else {
      timestamp = Date.now();
    }
    return timestamp;
  }

  // ../../node_modules/@probe.gl/log/dist/esm/log.js
  var originalConsole = {
    debug: isBrowser ? console.debug || console.log : console.log,
    log: console.log,
    info: console.info,
    warn: console.warn,
    error: console.error
  };
  var DEFAULT_SETTINGS = {
    enabled: true,
    level: 0
  };
  function noop() {
  }
  var cache = {};
  var ONCE = {
    once: true
  };
  var Log = class {
    constructor() {
      let {
        id
      } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
        id: ""
      };
      _defineProperty(this, "id", void 0);
      _defineProperty(this, "VERSION", VERSION);
      _defineProperty(this, "_startTs", getHiResTimestamp());
      _defineProperty(this, "_deltaTs", getHiResTimestamp());
      _defineProperty(this, "_storage", void 0);
      _defineProperty(this, "userData", {});
      _defineProperty(this, "LOG_THROTTLE_TIMEOUT", 0);
      this.id = id;
      this._storage = new LocalStorage("__probe-".concat(this.id, "__"), DEFAULT_SETTINGS);
      this.userData = {};
      this.timeStamp("".concat(this.id, " started"));
      autobind(this);
      Object.seal(this);
    }
    set level(newLevel) {
      this.setLevel(newLevel);
    }
    get level() {
      return this.getLevel();
    }
    isEnabled() {
      return this._storage.config.enabled;
    }
    getLevel() {
      return this._storage.config.level;
    }
    getTotal() {
      return Number((getHiResTimestamp() - this._startTs).toPrecision(10));
    }
    getDelta() {
      return Number((getHiResTimestamp() - this._deltaTs).toPrecision(10));
    }
    set priority(newPriority) {
      this.level = newPriority;
    }
    get priority() {
      return this.level;
    }
    getPriority() {
      return this.level;
    }
    enable() {
      let enabled = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
      this._storage.updateConfiguration({
        enabled
      });
      return this;
    }
    setLevel(level) {
      this._storage.updateConfiguration({
        level
      });
      return this;
    }
    get(setting) {
      return this._storage.config[setting];
    }
    set(setting, value) {
      this._storage.updateConfiguration({
        [setting]: value
      });
    }
    settings() {
      if (console.table) {
        console.table(this._storage.config);
      } else {
        console.log(this._storage.config);
      }
    }
    assert(condition, message) {
      assert(condition, message);
    }
    warn(message) {
      return this._getLogFunction(0, message, originalConsole.warn, arguments, ONCE);
    }
    error(message) {
      return this._getLogFunction(0, message, originalConsole.error, arguments);
    }
    deprecated(oldUsage, newUsage) {
      return this.warn("`".concat(oldUsage, "` is deprecated and will be removed in a later version. Use `").concat(newUsage, "` instead"));
    }
    removed(oldUsage, newUsage) {
      return this.error("`".concat(oldUsage, "` has been removed. Use `").concat(newUsage, "` instead"));
    }
    probe(logLevel, message) {
      return this._getLogFunction(logLevel, message, originalConsole.log, arguments, {
        time: true,
        once: true
      });
    }
    log(logLevel, message) {
      return this._getLogFunction(logLevel, message, originalConsole.debug, arguments);
    }
    info(logLevel, message) {
      return this._getLogFunction(logLevel, message, console.info, arguments);
    }
    once(logLevel, message) {
      for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
        args[_key - 2] = arguments[_key];
      }
      return this._getLogFunction(logLevel, message, originalConsole.debug || originalConsole.info, arguments, ONCE);
    }
    table(logLevel, table, columns) {
      if (table) {
        return this._getLogFunction(logLevel, table, console.table || noop, columns && [columns], {
          tag: getTableHeader(table)
        });
      }
      return noop;
    }
    image(_ref) {
      let {
        logLevel,
        priority,
        image,
        message = "",
        scale: scale5 = 1
      } = _ref;
      if (!this._shouldLog(logLevel || priority)) {
        return noop;
      }
      return isBrowser ? logImageInBrowser({
        image,
        message,
        scale: scale5
      }) : logImageInNode({
        image,
        message,
        scale: scale5
      });
    }
    time(logLevel, message) {
      return this._getLogFunction(logLevel, message, console.time ? console.time : console.info);
    }
    timeEnd(logLevel, message) {
      return this._getLogFunction(logLevel, message, console.timeEnd ? console.timeEnd : console.info);
    }
    timeStamp(logLevel, message) {
      return this._getLogFunction(logLevel, message, console.timeStamp || noop);
    }
    group(logLevel, message) {
      let opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
        collapsed: false
      };
      const options = normalizeArguments({
        logLevel,
        message,
        opts
      });
      const {
        collapsed
      } = opts;
      options.method = (collapsed ? console.groupCollapsed : console.group) || console.info;
      return this._getLogFunction(options);
    }
    groupCollapsed(logLevel, message) {
      let opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      return this.group(logLevel, message, Object.assign({}, opts, {
        collapsed: true
      }));
    }
    groupEnd(logLevel) {
      return this._getLogFunction(logLevel, "", console.groupEnd || noop);
    }
    withGroup(logLevel, message, func) {
      this.group(logLevel, message)();
      try {
        func();
      } finally {
        this.groupEnd(logLevel)();
      }
    }
    trace() {
      if (console.trace) {
        console.trace();
      }
    }
    _shouldLog(logLevel) {
      return this.isEnabled() && this.getLevel() >= normalizeLogLevel(logLevel);
    }
    _getLogFunction(logLevel, message, method, args, opts) {
      if (this._shouldLog(logLevel)) {
        opts = normalizeArguments({
          logLevel,
          message,
          args,
          opts
        });
        method = method || opts.method;
        assert(method);
        opts.total = this.getTotal();
        opts.delta = this.getDelta();
        this._deltaTs = getHiResTimestamp();
        const tag = opts.tag || opts.message;
        if (opts.once) {
          if (!cache[tag]) {
            cache[tag] = getHiResTimestamp();
          } else {
            return noop;
          }
        }
        message = decorateMessage(this.id, opts.message, opts);
        return method.bind(console, message, ...opts.args);
      }
      return noop;
    }
  };
  _defineProperty(Log, "VERSION", VERSION);
  function normalizeLogLevel(logLevel) {
    if (!logLevel) {
      return 0;
    }
    let resolvedLevel;
    switch (typeof logLevel) {
      case "number":
        resolvedLevel = logLevel;
        break;
      case "object":
        resolvedLevel = logLevel.logLevel || logLevel.priority || 0;
        break;
      default:
        return 0;
    }
    assert(Number.isFinite(resolvedLevel) && resolvedLevel >= 0);
    return resolvedLevel;
  }
  function normalizeArguments(opts) {
    const {
      logLevel,
      message
    } = opts;
    opts.logLevel = normalizeLogLevel(logLevel);
    const args = opts.args ? Array.from(opts.args) : [];
    while (args.length && args.shift() !== message) {
    }
    switch (typeof logLevel) {
      case "string":
      case "function":
        if (message !== void 0) {
          args.unshift(message);
        }
        opts.message = logLevel;
        break;
      case "object":
        Object.assign(opts, logLevel);
        break;
      default:
    }
    if (typeof opts.message === "function") {
      opts.message = opts.message();
    }
    const messageType = typeof opts.message;
    assert(messageType === "string" || messageType === "object");
    return Object.assign(opts, {
      args
    }, opts.opts);
  }
  function decorateMessage(id, message, opts) {
    if (typeof message === "string") {
      const time = opts.time ? leftPad(formatTime(opts.total)) : "";
      message = opts.time ? "".concat(id, ": ").concat(time, "  ").concat(message) : "".concat(id, ": ").concat(message);
      message = addColor(message, opts.color, opts.background);
    }
    return message;
  }
  function logImageInNode(_ref2) {
    let {
      image,
      message = "",
      scale: scale5 = 1
    } = _ref2;
    let asciify = null;
    try {
      asciify = module.require("asciify-image");
    } catch (error2) {
    }
    if (asciify) {
      return () => asciify(image, {
        fit: "box",
        width: "".concat(Math.round(80 * scale5), "%")
      }).then((data) => console.log(data));
    }
    return noop;
  }
  function logImageInBrowser(_ref3) {
    let {
      image,
      message = "",
      scale: scale5 = 1
    } = _ref3;
    if (typeof image === "string") {
      const img = new Image();
      img.onload = () => {
        const args = formatImage(img, message, scale5);
        console.log(...args);
      };
      img.src = image;
      return noop;
    }
    const element = image.nodeName || "";
    if (element.toLowerCase() === "img") {
      console.log(...formatImage(image, message, scale5));
      return noop;
    }
    if (element.toLowerCase() === "canvas") {
      const img = new Image();
      img.onload = () => console.log(...formatImage(img, message, scale5));
      img.src = image.toDataURL();
      return noop;
    }
    return noop;
  }
  function getTableHeader(table) {
    for (const key in table) {
      for (const title in table[key]) {
        return title || "untitled";
      }
    }
    return "empty";
  }

  // ../../node_modules/@probe.gl/log/dist/esm/index.js
  var esm_default2 = new Log({
    id: "@probe.gl/log"
  });

  // ../../node_modules/@luma.gl/gltools/dist/esm/utils/log.js
  var log = new Log({
    id: "luma.gl"
  });

  // ../../node_modules/@luma.gl/gltools/dist/esm/utils/assert.js
  function assert2(condition, message) {
    if (!condition) {
      throw new Error(message || "luma.gl: assertion failed.");
    }
  }

  // ../../node_modules/@luma.gl/gltools/dist/esm/utils/webgl-checks.js
  var ERR_CONTEXT = "Invalid WebGLRenderingContext";
  var ERR_WEBGL2 = "Requires WebGL2";
  function isWebGL(gl) {
    if (typeof WebGLRenderingContext !== "undefined" && gl instanceof WebGLRenderingContext) {
      return true;
    }
    if (typeof WebGL2RenderingContext !== "undefined" && gl instanceof WebGL2RenderingContext) {
      return true;
    }
    return Boolean(gl && Number.isFinite(gl._version));
  }
  function isWebGL2(gl) {
    if (typeof WebGL2RenderingContext !== "undefined" && gl instanceof WebGL2RenderingContext) {
      return true;
    }
    return Boolean(gl && gl._version === 2);
  }
  function getWebGL2Context(gl) {
    return isWebGL2(gl) ? gl : null;
  }
  function assertWebGLContext(gl) {
    assert2(isWebGL(gl), ERR_CONTEXT);
    return gl;
  }
  function assertWebGL2Context(gl) {
    assert2(isWebGL2(gl), ERR_WEBGL2);
    return gl;
  }

  // ../../node_modules/@luma.gl/gltools/dist/esm/polyfill/polyfill-vertex-array-object.js
  var glErrorShadow = {};
  function error(msg) {
    if (globalThis.console && globalThis.console.error) {
      globalThis.console.error(msg);
    }
  }
  function log2(msg) {
    if (globalThis.console && globalThis.console.log) {
      globalThis.console.log(msg);
    }
  }
  function synthesizeGLError(err, opt_msg) {
    glErrorShadow[err] = true;
    if (opt_msg !== void 0) {
      error(opt_msg);
    }
  }
  function wrapGLError(gl) {
    const f2 = gl.getError;
    gl.getError = function getError() {
      let err;
      do {
        err = f2.apply(gl);
        if (err !== 0) {
          glErrorShadow[err] = true;
        }
      } while (err !== 0);
      for (err in glErrorShadow) {
        if (glErrorShadow[err]) {
          delete glErrorShadow[err];
          return parseInt(err, 10);
        }
      }
      return 0;
    };
  }
  var WebGLVertexArrayObjectOES = function WebGLVertexArrayObjectOES2(ext) {
    const gl = ext.gl;
    this.ext = ext;
    this.isAlive = true;
    this.hasBeenBound = false;
    this.elementArrayBuffer = null;
    this.attribs = new Array(ext.maxVertexAttribs);
    for (let n2 = 0; n2 < this.attribs.length; n2++) {
      const attrib = new WebGLVertexArrayObjectOES2.VertexAttrib(gl);
      this.attribs[n2] = attrib;
    }
    this.maxAttrib = 0;
  };
  WebGLVertexArrayObjectOES.VertexAttrib = function VertexAttrib(gl) {
    this.enabled = false;
    this.buffer = null;
    this.size = 4;
    this.type = 5126;
    this.normalized = false;
    this.stride = 16;
    this.offset = 0;
    this.cached = "";
    this.recache();
  };
  WebGLVertexArrayObjectOES.VertexAttrib.prototype.recache = function recache() {
    this.cached = [this.size, this.type, this.normalized, this.stride, this.offset].join(":");
  };
  var OESVertexArrayObject = function OESVertexArrayObject2(gl) {
    const self2 = this;
    this.gl = gl;
    wrapGLError(gl);
    const original = this.original = {
      getParameter: gl.getParameter,
      enableVertexAttribArray: gl.enableVertexAttribArray,
      disableVertexAttribArray: gl.disableVertexAttribArray,
      bindBuffer: gl.bindBuffer,
      getVertexAttrib: gl.getVertexAttrib,
      vertexAttribPointer: gl.vertexAttribPointer
    };
    gl.getParameter = function getParameter(pname) {
      if (pname === self2.VERTEX_ARRAY_BINDING_OES) {
        if (self2.currentVertexArrayObject === self2.defaultVertexArrayObject) {
          return null;
        }
        return self2.currentVertexArrayObject;
      }
      return original.getParameter.apply(this, arguments);
    };
    gl.enableVertexAttribArray = function enableVertexAttribArray(index) {
      const vao = self2.currentVertexArrayObject;
      vao.maxAttrib = Math.max(vao.maxAttrib, index);
      const attrib = vao.attribs[index];
      attrib.enabled = true;
      return original.enableVertexAttribArray.apply(this, arguments);
    };
    gl.disableVertexAttribArray = function disableVertexAttribArray(index) {
      const vao = self2.currentVertexArrayObject;
      vao.maxAttrib = Math.max(vao.maxAttrib, index);
      const attrib = vao.attribs[index];
      attrib.enabled = false;
      return original.disableVertexAttribArray.apply(this, arguments);
    };
    gl.bindBuffer = function bindBuffer(target, buffer) {
      switch (target) {
        case 34962:
          self2.currentArrayBuffer = buffer;
          break;
        case 34963:
          self2.currentVertexArrayObject.elementArrayBuffer = buffer;
          break;
        default:
      }
      return original.bindBuffer.apply(this, arguments);
    };
    gl.getVertexAttrib = function getVertexAttrib(index, pname) {
      const vao = self2.currentVertexArrayObject;
      const attrib = vao.attribs[index];
      switch (pname) {
        case 34975:
          return attrib.buffer;
        case 34338:
          return attrib.enabled;
        case 34339:
          return attrib.size;
        case 34340:
          return attrib.stride;
        case 34341:
          return attrib.type;
        case 34922:
          return attrib.normalized;
        default:
          return original.getVertexAttrib.apply(this, arguments);
      }
    };
    gl.vertexAttribPointer = function vertexAttribPointer(indx, size, type, normalized, stride, offset) {
      const vao = self2.currentVertexArrayObject;
      vao.maxAttrib = Math.max(vao.maxAttrib, indx);
      const attrib = vao.attribs[indx];
      attrib.buffer = self2.currentArrayBuffer;
      attrib.size = size;
      attrib.type = type;
      attrib.normalized = normalized;
      attrib.stride = stride;
      attrib.offset = offset;
      attrib.recache();
      return original.vertexAttribPointer.apply(this, arguments);
    };
    if (gl.instrumentExtension) {
      gl.instrumentExtension(this, "OES_vertex_array_object");
    }
    if (gl.canvas) {
      gl.canvas.addEventListener("webglcontextrestored", () => {
        log2("OESVertexArrayObject emulation library context restored");
        self2.reset_();
      }, true);
    }
    this.reset_();
  };
  OESVertexArrayObject.prototype.VERTEX_ARRAY_BINDING_OES = 34229;
  OESVertexArrayObject.prototype.reset_ = function reset_() {
    const contextWasLost = this.vertexArrayObjects !== void 0;
    if (contextWasLost) {
      for (let ii = 0; ii < this.vertexArrayObjects.length; ++ii) {
        this.vertexArrayObjects.isAlive = false;
      }
    }
    const gl = this.gl;
    this.maxVertexAttribs = gl.getParameter(34921);
    this.defaultVertexArrayObject = new WebGLVertexArrayObjectOES(this);
    this.currentVertexArrayObject = null;
    this.currentArrayBuffer = null;
    this.vertexArrayObjects = [this.defaultVertexArrayObject];
    this.bindVertexArrayOES(null);
  };
  OESVertexArrayObject.prototype.createVertexArrayOES = function createVertexArrayOES() {
    const arrayObject = new WebGLVertexArrayObjectOES(this);
    this.vertexArrayObjects.push(arrayObject);
    return arrayObject;
  };
  OESVertexArrayObject.prototype.deleteVertexArrayOES = function deleteVertexArrayOES(arrayObject) {
    arrayObject.isAlive = false;
    this.vertexArrayObjects.splice(this.vertexArrayObjects.indexOf(arrayObject), 1);
    if (this.currentVertexArrayObject === arrayObject) {
      this.bindVertexArrayOES(null);
    }
  };
  OESVertexArrayObject.prototype.isVertexArrayOES = function isVertexArrayOES(arrayObject) {
    if (arrayObject && arrayObject instanceof WebGLVertexArrayObjectOES) {
      if (arrayObject.hasBeenBound && arrayObject.ext === this) {
        return true;
      }
    }
    return false;
  };
  OESVertexArrayObject.prototype.bindVertexArrayOES = function bindVertexArrayOES(arrayObject) {
    const gl = this.gl;
    if (arrayObject && !arrayObject.isAlive) {
      synthesizeGLError(1282, "bindVertexArrayOES: attempt to bind deleted arrayObject");
      return;
    }
    const original = this.original;
    const oldVAO = this.currentVertexArrayObject;
    this.currentVertexArrayObject = arrayObject || this.defaultVertexArrayObject;
    this.currentVertexArrayObject.hasBeenBound = true;
    const newVAO = this.currentVertexArrayObject;
    if (oldVAO === newVAO) {
      return;
    }
    if (!oldVAO || newVAO.elementArrayBuffer !== oldVAO.elementArrayBuffer) {
      original.bindBuffer.call(gl, 34963, newVAO.elementArrayBuffer);
    }
    let currentBinding = this.currentArrayBuffer;
    const maxAttrib = Math.max(oldVAO ? oldVAO.maxAttrib : 0, newVAO.maxAttrib);
    for (let n2 = 0; n2 <= maxAttrib; n2++) {
      const attrib = newVAO.attribs[n2];
      const oldAttrib = oldVAO ? oldVAO.attribs[n2] : null;
      if (!oldVAO || attrib.enabled !== oldAttrib.enabled) {
        if (attrib.enabled) {
          original.enableVertexAttribArray.call(gl, n2);
        } else {
          original.disableVertexAttribArray.call(gl, n2);
        }
      }
      if (attrib.enabled) {
        let bufferChanged = false;
        if (!oldVAO || attrib.buffer !== oldAttrib.buffer) {
          if (currentBinding !== attrib.buffer) {
            original.bindBuffer.call(gl, 34962, attrib.buffer);
            currentBinding = attrib.buffer;
          }
          bufferChanged = true;
        }
        if (bufferChanged || attrib.cached !== oldAttrib.cached) {
          original.vertexAttribPointer.call(gl, n2, attrib.size, attrib.type, attrib.normalized, attrib.stride, attrib.offset);
        }
      }
    }
    if (this.currentArrayBuffer !== currentBinding) {
      original.bindBuffer.call(gl, 34962, this.currentArrayBuffer);
    }
  };
  function polyfillVertexArrayObject(gl) {
    if (typeof gl.createVertexArray === "function") {
      return;
    }
    const original_getSupportedExtensions = gl.getSupportedExtensions;
    gl.getSupportedExtensions = function getSupportedExtensions() {
      const list = original_getSupportedExtensions.call(this) || [];
      if (list.indexOf("OES_vertex_array_object") < 0) {
        list.push("OES_vertex_array_object");
      }
      return list;
    };
    const original_getExtension = gl.getExtension;
    gl.getExtension = function getExtension(name10) {
      const ext = original_getExtension.call(this, name10);
      if (ext) {
        return ext;
      }
      if (name10 !== "OES_vertex_array_object") {
        return null;
      }
      if (!gl.__OESVertexArrayObject) {
        this.__OESVertexArrayObject = new OESVertexArrayObject(this);
      }
      return this.__OESVertexArrayObject;
    };
  }

  // ../../node_modules/@luma.gl/gltools/dist/esm/polyfill/get-parameter-polyfill.js
  var OES_element_index = "OES_element_index";
  var WEBGL_draw_buffers = "WEBGL_draw_buffers";
  var EXT_disjoint_timer_query = "EXT_disjoint_timer_query";
  var EXT_disjoint_timer_query_webgl2 = "EXT_disjoint_timer_query_webgl2";
  var EXT_texture_filter_anisotropic = "EXT_texture_filter_anisotropic";
  var WEBGL_debug_renderer_info = "WEBGL_debug_renderer_info";
  var GL_FRAGMENT_SHADER_DERIVATIVE_HINT = 35723;
  var GL_DONT_CARE = 4352;
  var GL_GPU_DISJOINT_EXT = 36795;
  var GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT = 34047;
  var GL_UNMASKED_VENDOR_WEBGL = 37445;
  var GL_UNMASKED_RENDERER_WEBGL = 37446;
  var getWebGL2ValueOrZero = (gl) => !isWebGL2(gl) ? 0 : void 0;
  var WEBGL_PARAMETERS = {
    [3074]: (gl) => !isWebGL2(gl) ? 36064 : void 0,
    [GL_FRAGMENT_SHADER_DERIVATIVE_HINT]: (gl) => !isWebGL2(gl) ? GL_DONT_CARE : void 0,
    [35977]: getWebGL2ValueOrZero,
    [32937]: getWebGL2ValueOrZero,
    [GL_GPU_DISJOINT_EXT]: (gl, getParameter) => {
      const ext = isWebGL2(gl) ? gl.getExtension(EXT_disjoint_timer_query_webgl2) : gl.getExtension(EXT_disjoint_timer_query);
      return ext && ext.GPU_DISJOINT_EXT ? getParameter(ext.GPU_DISJOINT_EXT) : 0;
    },
    [GL_UNMASKED_VENDOR_WEBGL]: (gl, getParameter) => {
      const ext = gl.getExtension(WEBGL_debug_renderer_info);
      return getParameter(ext && ext.UNMASKED_VENDOR_WEBGL || 7936);
    },
    [GL_UNMASKED_RENDERER_WEBGL]: (gl, getParameter) => {
      const ext = gl.getExtension(WEBGL_debug_renderer_info);
      return getParameter(ext && ext.UNMASKED_RENDERER_WEBGL || 7937);
    },
    [GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT]: (gl, getParameter) => {
      const ext = gl.luma.extensions[EXT_texture_filter_anisotropic];
      return ext ? getParameter(ext.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 1;
    },
    [32883]: getWebGL2ValueOrZero,
    [35071]: getWebGL2ValueOrZero,
    [37447]: getWebGL2ValueOrZero,
    [36063]: (gl, getParameter) => {
      if (!isWebGL2(gl)) {
        const ext = gl.getExtension(WEBGL_draw_buffers);
        return ext ? getParameter(ext.MAX_COLOR_ATTACHMENTS_WEBGL) : 0;
      }
      return void 0;
    },
    [35379]: getWebGL2ValueOrZero,
    [35374]: getWebGL2ValueOrZero,
    [35377]: getWebGL2ValueOrZero,
    [34852]: (gl) => {
      if (!isWebGL2(gl)) {
        const ext = gl.getExtension(WEBGL_draw_buffers);
        return ext ? ext.MAX_DRAW_BUFFERS_WEBGL : 0;
      }
      return void 0;
    },
    [36203]: (gl) => gl.getExtension(OES_element_index) ? 2147483647 : 65535,
    [33001]: (gl) => gl.getExtension(OES_element_index) ? 16777216 : 65535,
    [33e3]: (gl) => 16777216,
    [37157]: getWebGL2ValueOrZero,
    [35373]: getWebGL2ValueOrZero,
    [35657]: getWebGL2ValueOrZero,
    [36183]: getWebGL2ValueOrZero,
    [37137]: getWebGL2ValueOrZero,
    [34045]: getWebGL2ValueOrZero,
    [35978]: getWebGL2ValueOrZero,
    [35979]: getWebGL2ValueOrZero,
    [35968]: getWebGL2ValueOrZero,
    [35376]: getWebGL2ValueOrZero,
    [35375]: getWebGL2ValueOrZero,
    [35659]: getWebGL2ValueOrZero,
    [37154]: getWebGL2ValueOrZero,
    [35371]: getWebGL2ValueOrZero,
    [35658]: getWebGL2ValueOrZero,
    [35076]: getWebGL2ValueOrZero,
    [35077]: getWebGL2ValueOrZero,
    [35380]: getWebGL2ValueOrZero
  };
  function getParameterPolyfill(gl, originalGetParameter, pname) {
    const limit = WEBGL_PARAMETERS[pname];
    const value = typeof limit === "function" ? limit(gl, originalGetParameter, pname) : limit;
    const result = value !== void 0 ? value : originalGetParameter(pname);
    return result;
  }

  // ../../node_modules/@luma.gl/gltools/dist/esm/polyfill/polyfill-table.js
  var OES_vertex_array_object = "OES_vertex_array_object";
  var ANGLE_instanced_arrays = "ANGLE_instanced_arrays";
  var WEBGL_draw_buffers2 = "WEBGL_draw_buffers";
  var EXT_disjoint_timer_query2 = "EXT_disjoint_timer_query";
  var EXT_texture_filter_anisotropic2 = "EXT_texture_filter_anisotropic";
  var ERR_VAO_NOT_SUPPORTED = "VertexArray requires WebGL2 or OES_vertex_array_object extension";
  function getExtensionData(gl, extension) {
    return {
      webgl2: isWebGL2(gl),
      ext: gl.getExtension(extension)
    };
  }
  var WEBGL2_CONTEXT_POLYFILLS = {
    [OES_vertex_array_object]: {
      meta: {
        suffix: "OES"
      },
      createVertexArray: () => {
        assert2(false, ERR_VAO_NOT_SUPPORTED);
      },
      deleteVertexArray: () => {
      },
      bindVertexArray: () => {
      },
      isVertexArray: () => false
    },
    [ANGLE_instanced_arrays]: {
      meta: {
        suffix: "ANGLE"
      },
      vertexAttribDivisor(location, divisor) {
        assert2(divisor === 0, "WebGL instanced rendering not supported");
      },
      drawElementsInstanced: () => {
      },
      drawArraysInstanced: () => {
      }
    },
    [WEBGL_draw_buffers2]: {
      meta: {
        suffix: "WEBGL"
      },
      drawBuffers: () => {
        assert2(false);
      }
    },
    [EXT_disjoint_timer_query2]: {
      meta: {
        suffix: "EXT"
      },
      createQuery: () => {
        assert2(false);
      },
      deleteQuery: () => {
        assert2(false);
      },
      beginQuery: () => {
        assert2(false);
      },
      endQuery: () => {
      },
      getQuery(handle, pname) {
        return this.getQueryObject(handle, pname);
      },
      getQueryParameter(handle, pname) {
        return this.getQueryObject(handle, pname);
      },
      getQueryObject: () => {
      }
    }
  };
  var WEBGL2_CONTEXT_OVERRIDES = {
    readBuffer: (gl, originalFunc, attachment) => {
      if (isWebGL2(gl)) {
        originalFunc(attachment);
      } else {
      }
    },
    getVertexAttrib: (gl, originalFunc, location, pname) => {
      const {
        webgl2,
        ext
      } = getExtensionData(gl, ANGLE_instanced_arrays);
      let result;
      switch (pname) {
        case 35069:
          result = !webgl2 ? false : void 0;
          break;
        case 35070:
          result = !webgl2 && !ext ? 0 : void 0;
          break;
        default:
      }
      return result !== void 0 ? result : originalFunc(location, pname);
    },
    getProgramParameter: (gl, originalFunc, program, pname) => {
      if (!isWebGL2(gl)) {
        switch (pname) {
          case 35967:
            return 35981;
          case 35971:
            return 0;
          case 35382:
            return 0;
          default:
        }
      }
      return originalFunc(program, pname);
    },
    getInternalformatParameter: (gl, originalFunc, target, format, pname) => {
      if (!isWebGL2(gl)) {
        switch (pname) {
          case 32937:
            return new Int32Array([0]);
          default:
        }
      }
      return gl.getInternalformatParameter(target, format, pname);
    },
    getTexParameter(gl, originalFunc, target, pname) {
      switch (pname) {
        case 34046:
          const {
            extensions
          } = gl.luma;
          const ext = extensions[EXT_texture_filter_anisotropic2];
          pname = ext && ext.TEXTURE_MAX_ANISOTROPY_EXT || 34046;
          break;
        default:
      }
      return originalFunc(target, pname);
    },
    getParameter: getParameterPolyfill,
    hint(gl, originalFunc, pname, value) {
      return originalFunc(pname, value);
    }
  };

  // ../../node_modules/@luma.gl/gltools/dist/esm/polyfill/polyfill-context.js
  function polyfillContext(gl) {
    gl.luma = gl.luma || {};
    const {
      luma
    } = gl;
    if (!luma.polyfilled) {
      polyfillVertexArrayObject(gl);
      initializeExtensions(gl);
      installPolyfills(gl, WEBGL2_CONTEXT_POLYFILLS);
      installOverrides(gl, {
        target: luma,
        target2: gl
      });
      luma.polyfilled = true;
    }
    return gl;
  }
  globalThis.polyfillContext = polyfillContext;
  function initializeExtensions(gl) {
    gl.luma.extensions = {};
    const EXTENSIONS3 = gl.getSupportedExtensions() || [];
    for (const extension of EXTENSIONS3) {
      gl.luma[extension] = gl.getExtension(extension);
    }
  }
  function installOverrides(gl, _ref) {
    let {
      target,
      target2
    } = _ref;
    Object.keys(WEBGL2_CONTEXT_OVERRIDES).forEach((key) => {
      if (typeof WEBGL2_CONTEXT_OVERRIDES[key] === "function") {
        const originalFunc = gl[key] ? gl[key].bind(gl) : () => {
        };
        const polyfill = WEBGL2_CONTEXT_OVERRIDES[key].bind(null, gl, originalFunc);
        target[key] = polyfill;
        target2[key] = polyfill;
      }
    });
  }
  function installPolyfills(gl, polyfills) {
    for (const extension of Object.getOwnPropertyNames(polyfills)) {
      if (extension !== "overrides") {
        polyfillExtension(gl, {
          extension,
          target: gl.luma,
          target2: gl
        });
      }
    }
  }
  function polyfillExtension(gl, _ref2) {
    let {
      extension,
      target,
      target2
    } = _ref2;
    const defaults = WEBGL2_CONTEXT_POLYFILLS[extension];
    assert2(defaults);
    const {
      meta = {}
    } = defaults;
    const {
      suffix = ""
    } = meta;
    const ext = gl.getExtension(extension);
    for (const key of Object.keys(defaults)) {
      const extKey = "".concat(key).concat(suffix);
      let polyfill = null;
      if (key === "meta") {
      } else if (typeof gl[key] === "function") {
      } else if (ext && typeof ext[extKey] === "function") {
        polyfill = function() {
          return ext[extKey](...arguments);
        };
      } else if (typeof defaults[key] === "function") {
        polyfill = defaults[key].bind(target);
      }
      if (polyfill) {
        target[key] = polyfill;
        target2[key] = polyfill;
      }
    }
  }

  // ../../node_modules/@luma.gl/gltools/dist/esm/state-tracker/webgl-parameter-tables.js
  var GL_PARAMETER_DEFAULTS = {
    [3042]: false,
    [32773]: new Float32Array([0, 0, 0, 0]),
    [32777]: 32774,
    [34877]: 32774,
    [32969]: 1,
    [32968]: 0,
    [32971]: 1,
    [32970]: 0,
    [3106]: new Float32Array([0, 0, 0, 0]),
    [3107]: [true, true, true, true],
    [2884]: false,
    [2885]: 1029,
    [2929]: false,
    [2931]: 1,
    [2932]: 513,
    [2928]: new Float32Array([0, 1]),
    [2930]: true,
    [3024]: true,
    [36006]: null,
    [2886]: 2305,
    [33170]: 4352,
    [2849]: 1,
    [32823]: false,
    [32824]: 0,
    [10752]: 0,
    [32938]: 1,
    [32939]: false,
    [3089]: false,
    [3088]: new Int32Array([0, 0, 1024, 1024]),
    [2960]: false,
    [2961]: 0,
    [2968]: 4294967295,
    [36005]: 4294967295,
    [2962]: 519,
    [2967]: 0,
    [2963]: 4294967295,
    [34816]: 519,
    [36003]: 0,
    [36004]: 4294967295,
    [2964]: 7680,
    [2965]: 7680,
    [2966]: 7680,
    [34817]: 7680,
    [34818]: 7680,
    [34819]: 7680,
    [2978]: [0, 0, 1024, 1024],
    [3333]: 4,
    [3317]: 4,
    [37440]: false,
    [37441]: false,
    [37443]: 37444,
    [35723]: 4352,
    [36010]: null,
    [35977]: false,
    [3330]: 0,
    [3332]: 0,
    [3331]: 0,
    [3314]: 0,
    [32878]: 0,
    [3316]: 0,
    [3315]: 0,
    [32877]: 0
  };
  var enable = (gl, value, key) => value ? gl.enable(key) : gl.disable(key);
  var hint = (gl, value, key) => gl.hint(key, value);
  var pixelStorei = (gl, value, key) => gl.pixelStorei(key, value);
  var drawFramebuffer = (gl, value) => {
    const target = isWebGL2(gl) ? 36009 : 36160;
    return gl.bindFramebuffer(target, value);
  };
  var readFramebuffer = (gl, value) => {
    return gl.bindFramebuffer(36008, value);
  };
  function isArray(array) {
    return Array.isArray(array) || ArrayBuffer.isView(array);
  }
  var GL_PARAMETER_SETTERS = {
    [3042]: enable,
    [32773]: (gl, value) => gl.blendColor(...value),
    [32777]: "blendEquation",
    [34877]: "blendEquation",
    [32969]: "blendFunc",
    [32968]: "blendFunc",
    [32971]: "blendFunc",
    [32970]: "blendFunc",
    [3106]: (gl, value) => gl.clearColor(...value),
    [3107]: (gl, value) => gl.colorMask(...value),
    [2884]: enable,
    [2885]: (gl, value) => gl.cullFace(value),
    [2929]: enable,
    [2931]: (gl, value) => gl.clearDepth(value),
    [2932]: (gl, value) => gl.depthFunc(value),
    [2928]: (gl, value) => gl.depthRange(...value),
    [2930]: (gl, value) => gl.depthMask(value),
    [3024]: enable,
    [35723]: hint,
    [36006]: drawFramebuffer,
    [2886]: (gl, value) => gl.frontFace(value),
    [33170]: hint,
    [2849]: (gl, value) => gl.lineWidth(value),
    [32823]: enable,
    [32824]: "polygonOffset",
    [10752]: "polygonOffset",
    [35977]: enable,
    [32938]: "sampleCoverage",
    [32939]: "sampleCoverage",
    [3089]: enable,
    [3088]: (gl, value) => gl.scissor(...value),
    [2960]: enable,
    [2961]: (gl, value) => gl.clearStencil(value),
    [2968]: (gl, value) => gl.stencilMaskSeparate(1028, value),
    [36005]: (gl, value) => gl.stencilMaskSeparate(1029, value),
    [2962]: "stencilFuncFront",
    [2967]: "stencilFuncFront",
    [2963]: "stencilFuncFront",
    [34816]: "stencilFuncBack",
    [36003]: "stencilFuncBack",
    [36004]: "stencilFuncBack",
    [2964]: "stencilOpFront",
    [2965]: "stencilOpFront",
    [2966]: "stencilOpFront",
    [34817]: "stencilOpBack",
    [34818]: "stencilOpBack",
    [34819]: "stencilOpBack",
    [2978]: (gl, value) => gl.viewport(...value),
    [3333]: pixelStorei,
    [3317]: pixelStorei,
    [37440]: pixelStorei,
    [37441]: pixelStorei,
    [37443]: pixelStorei,
    [3330]: pixelStorei,
    [3332]: pixelStorei,
    [3331]: pixelStorei,
    [36010]: readFramebuffer,
    [3314]: pixelStorei,
    [32878]: pixelStorei,
    [3316]: pixelStorei,
    [3315]: pixelStorei,
    [32877]: pixelStorei,
    framebuffer: (gl, framebuffer) => {
      const handle = framebuffer && "handle" in framebuffer ? framebuffer.handle : framebuffer;
      return gl.bindFramebuffer(36160, handle);
    },
    blend: (gl, value) => value ? gl.enable(3042) : gl.disable(3042),
    blendColor: (gl, value) => gl.blendColor(...value),
    blendEquation: (gl, args) => {
      args = isArray(args) ? args : [args, args];
      gl.blendEquationSeparate(...args);
    },
    blendFunc: (gl, args) => {
      args = isArray(args) && args.length === 2 ? [...args, ...args] : args;
      gl.blendFuncSeparate(...args);
    },
    clearColor: (gl, value) => gl.clearColor(...value),
    clearDepth: (gl, value) => gl.clearDepth(value),
    clearStencil: (gl, value) => gl.clearStencil(value),
    colorMask: (gl, value) => gl.colorMask(...value),
    cull: (gl, value) => value ? gl.enable(2884) : gl.disable(2884),
    cullFace: (gl, value) => gl.cullFace(value),
    depthTest: (gl, value) => value ? gl.enable(2929) : gl.disable(2929),
    depthFunc: (gl, value) => gl.depthFunc(value),
    depthMask: (gl, value) => gl.depthMask(value),
    depthRange: (gl, value) => gl.depthRange(...value),
    dither: (gl, value) => value ? gl.enable(3024) : gl.disable(3024),
    derivativeHint: (gl, value) => {
      gl.hint(35723, value);
    },
    frontFace: (gl, value) => gl.frontFace(value),
    mipmapHint: (gl, value) => gl.hint(33170, value),
    lineWidth: (gl, value) => gl.lineWidth(value),
    polygonOffsetFill: (gl, value) => value ? gl.enable(32823) : gl.disable(32823),
    polygonOffset: (gl, value) => gl.polygonOffset(...value),
    sampleCoverage: (gl, value) => gl.sampleCoverage(...value),
    scissorTest: (gl, value) => value ? gl.enable(3089) : gl.disable(3089),
    scissor: (gl, value) => gl.scissor(...value),
    stencilTest: (gl, value) => value ? gl.enable(2960) : gl.disable(2960),
    stencilMask: (gl, value) => {
      value = isArray(value) ? value : [value, value];
      const [mask, backMask] = value;
      gl.stencilMaskSeparate(1028, mask);
      gl.stencilMaskSeparate(1029, backMask);
    },
    stencilFunc: (gl, args) => {
      args = isArray(args) && args.length === 3 ? [...args, ...args] : args;
      const [func, ref, mask, backFunc, backRef, backMask] = args;
      gl.stencilFuncSeparate(1028, func, ref, mask);
      gl.stencilFuncSeparate(1029, backFunc, backRef, backMask);
    },
    stencilOp: (gl, args) => {
      args = isArray(args) && args.length === 3 ? [...args, ...args] : args;
      const [sfail, dpfail, dppass, backSfail, backDpfail, backDppass] = args;
      gl.stencilOpSeparate(1028, sfail, dpfail, dppass);
      gl.stencilOpSeparate(1029, backSfail, backDpfail, backDppass);
    },
    viewport: (gl, value) => gl.viewport(...value)
  };
  function getValue(glEnum, values, cache2) {
    return values[glEnum] !== void 0 ? values[glEnum] : cache2[glEnum];
  }
  var GL_COMPOSITE_PARAMETER_SETTERS = {
    blendEquation: (gl, values, cache2) => gl.blendEquationSeparate(getValue(32777, values, cache2), getValue(34877, values, cache2)),
    blendFunc: (gl, values, cache2) => gl.blendFuncSeparate(getValue(32969, values, cache2), getValue(32968, values, cache2), getValue(32971, values, cache2), getValue(32970, values, cache2)),
    polygonOffset: (gl, values, cache2) => gl.polygonOffset(getValue(32824, values, cache2), getValue(10752, values, cache2)),
    sampleCoverage: (gl, values, cache2) => gl.sampleCoverage(getValue(32938, values, cache2), getValue(32939, values, cache2)),
    stencilFuncFront: (gl, values, cache2) => gl.stencilFuncSeparate(1028, getValue(2962, values, cache2), getValue(2967, values, cache2), getValue(2963, values, cache2)),
    stencilFuncBack: (gl, values, cache2) => gl.stencilFuncSeparate(1029, getValue(34816, values, cache2), getValue(36003, values, cache2), getValue(36004, values, cache2)),
    stencilOpFront: (gl, values, cache2) => gl.stencilOpSeparate(1028, getValue(2964, values, cache2), getValue(2965, values, cache2), getValue(2966, values, cache2)),
    stencilOpBack: (gl, values, cache2) => gl.stencilOpSeparate(1029, getValue(34817, values, cache2), getValue(34818, values, cache2), getValue(34819, values, cache2))
  };
  var GL_HOOKED_SETTERS = {
    enable: (update, capability) => update({
      [capability]: true
    }),
    disable: (update, capability) => update({
      [capability]: false
    }),
    pixelStorei: (update, pname, value) => update({
      [pname]: value
    }),
    hint: (update, pname, hint2) => update({
      [pname]: hint2
    }),
    bindFramebuffer: (update, target, framebuffer) => {
      switch (target) {
        case 36160:
          return update({
            [36006]: framebuffer,
            [36010]: framebuffer
          });
        case 36009:
          return update({
            [36006]: framebuffer
          });
        case 36008:
          return update({
            [36010]: framebuffer
          });
        default:
          return null;
      }
    },
    blendColor: (update, r2, g, b, a2) => update({
      [32773]: new Float32Array([r2, g, b, a2])
    }),
    blendEquation: (update, mode) => update({
      [32777]: mode,
      [34877]: mode
    }),
    blendEquationSeparate: (update, modeRGB, modeAlpha) => update({
      [32777]: modeRGB,
      [34877]: modeAlpha
    }),
    blendFunc: (update, src, dst) => update({
      [32969]: src,
      [32968]: dst,
      [32971]: src,
      [32970]: dst
    }),
    blendFuncSeparate: (update, srcRGB, dstRGB, srcAlpha, dstAlpha) => update({
      [32969]: srcRGB,
      [32968]: dstRGB,
      [32971]: srcAlpha,
      [32970]: dstAlpha
    }),
    clearColor: (update, r2, g, b, a2) => update({
      [3106]: new Float32Array([r2, g, b, a2])
    }),
    clearDepth: (update, depth) => update({
      [2931]: depth
    }),
    clearStencil: (update, s2) => update({
      [2961]: s2
    }),
    colorMask: (update, r2, g, b, a2) => update({
      [3107]: [r2, g, b, a2]
    }),
    cullFace: (update, mode) => update({
      [2885]: mode
    }),
    depthFunc: (update, func) => update({
      [2932]: func
    }),
    depthRange: (update, zNear, zFar) => update({
      [2928]: new Float32Array([zNear, zFar])
    }),
    depthMask: (update, mask) => update({
      [2930]: mask
    }),
    frontFace: (update, face) => update({
      [2886]: face
    }),
    lineWidth: (update, width) => update({
      [2849]: width
    }),
    polygonOffset: (update, factor, units) => update({
      [32824]: factor,
      [10752]: units
    }),
    sampleCoverage: (update, value, invert4) => update({
      [32938]: value,
      [32939]: invert4
    }),
    scissor: (update, x, y, width, height) => update({
      [3088]: new Int32Array([x, y, width, height])
    }),
    stencilMask: (update, mask) => update({
      [2968]: mask,
      [36005]: mask
    }),
    stencilMaskSeparate: (update, face, mask) => update({
      [face === 1028 ? 2968 : 36005]: mask
    }),
    stencilFunc: (update, func, ref, mask) => update({
      [2962]: func,
      [2967]: ref,
      [2963]: mask,
      [34816]: func,
      [36003]: ref,
      [36004]: mask
    }),
    stencilFuncSeparate: (update, face, func, ref, mask) => update({
      [face === 1028 ? 2962 : 34816]: func,
      [face === 1028 ? 2967 : 36003]: ref,
      [face === 1028 ? 2963 : 36004]: mask
    }),
    stencilOp: (update, fail, zfail, zpass) => update({
      [2964]: fail,
      [2965]: zfail,
      [2966]: zpass,
      [34817]: fail,
      [34818]: zfail,
      [34819]: zpass
    }),
    stencilOpSeparate: (update, face, fail, zfail, zpass) => update({
      [face === 1028 ? 2964 : 34817]: fail,
      [face === 1028 ? 2965 : 34818]: zfail,
      [face === 1028 ? 2966 : 34819]: zpass
    }),
    viewport: (update, x, y, width, height) => update({
      [2978]: [x, y, width, height]
    })
  };
  var isEnabled = (gl, key) => gl.isEnabled(key);
  var GL_PARAMETER_GETTERS = {
    [3042]: isEnabled,
    [2884]: isEnabled,
    [2929]: isEnabled,
    [3024]: isEnabled,
    [32823]: isEnabled,
    [32926]: isEnabled,
    [32928]: isEnabled,
    [3089]: isEnabled,
    [2960]: isEnabled,
    [35977]: isEnabled
  };

  // ../../node_modules/@luma.gl/gltools/dist/esm/utils/utils.js
  function isObjectEmpty(object) {
    for (const key in object) {
      return false;
    }
    return true;
  }
  function deepArrayEqual(x, y) {
    if (x === y) {
      return true;
    }
    const isArrayX = Array.isArray(x) || ArrayBuffer.isView(x);
    const isArrayY = Array.isArray(y) || ArrayBuffer.isView(y);
    if (isArrayX && isArrayY && x.length === y.length) {
      for (let i2 = 0; i2 < x.length; ++i2) {
        if (x[i2] !== y[i2]) {
          return false;
        }
      }
      return true;
    }
    return false;
  }

  // ../../node_modules/@luma.gl/gltools/dist/esm/state-tracker/track-context-state.js
  function installGetterOverride(gl, functionName) {
    const originalGetterFunc = gl[functionName].bind(gl);
    gl[functionName] = function get() {
      const pname = arguments.length <= 0 ? void 0 : arguments[0];
      if (!(pname in gl.state.cache)) {
        return originalGetterFunc(...arguments);
      }
      return gl.state.enable ? gl.state.cache[pname] : originalGetterFunc(...arguments);
    };
    Object.defineProperty(gl[functionName], "name", {
      value: "".concat(functionName, "-from-cache"),
      configurable: false
    });
  }
  function installSetterSpy(gl, functionName, setter) {
    const originalSetterFunc = gl[functionName].bind(gl);
    gl[functionName] = function set2() {
      for (var _len = arguments.length, params = new Array(_len), _key = 0; _key < _len; _key++) {
        params[_key] = arguments[_key];
      }
      const {
        valueChanged,
        oldValue
      } = setter(gl.state._updateCache, ...params);
      if (valueChanged) {
        originalSetterFunc(...params);
      }
      return oldValue;
    };
    Object.defineProperty(gl[functionName], "name", {
      value: "".concat(functionName, "-to-cache"),
      configurable: false
    });
  }
  function installProgramSpy(gl) {
    const originalUseProgram = gl.useProgram.bind(gl);
    gl.useProgram = function useProgramLuma(handle) {
      if (gl.state.program !== handle) {
        originalUseProgram(handle);
        gl.state.program = handle;
      }
    };
  }
  var GLState = class {
    constructor(gl) {
      let {
        copyState = false,
        log: log5 = () => {
        }
      } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      this.gl = gl;
      this.program = null;
      this.stateStack = [];
      this.enable = true;
      this.cache = copyState ? getParameters(gl) : Object.assign({}, GL_PARAMETER_DEFAULTS);
      this.log = log5;
      this._updateCache = this._updateCache.bind(this);
      Object.seal(this);
    }
    push() {
      let values = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      this.stateStack.push({});
    }
    pop() {
      assert2(this.stateStack.length > 0);
      const oldValues = this.stateStack[this.stateStack.length - 1];
      setParameters(this.gl, oldValues);
      this.stateStack.pop();
    }
    _updateCache(values) {
      let valueChanged = false;
      let oldValue;
      const oldValues = this.stateStack.length > 0 && this.stateStack[this.stateStack.length - 1];
      for (const key in values) {
        assert2(key !== void 0);
        const value = values[key];
        const cached = this.cache[key];
        if (!deepArrayEqual(value, cached)) {
          valueChanged = true;
          oldValue = cached;
          if (oldValues && !(key in oldValues)) {
            oldValues[key] = cached;
          }
          this.cache[key] = value;
        }
      }
      return {
        valueChanged,
        oldValue
      };
    }
  };
  function trackContextState(gl) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const {
      enable: enable2 = true,
      copyState
    } = options;
    assert2(copyState !== void 0);
    if (!gl.state) {
      const {
        polyfillContext: polyfillContext2
      } = globalThis;
      if (polyfillContext2) {
        polyfillContext2(gl);
      }
      gl.state = new GLState(gl, {
        copyState
      });
      installProgramSpy(gl);
      for (const key in GL_HOOKED_SETTERS) {
        const setter = GL_HOOKED_SETTERS[key];
        installSetterSpy(gl, key, setter);
      }
      installGetterOverride(gl, "getParameter");
      installGetterOverride(gl, "isEnabled");
    }
    gl.state.enable = enable2;
    return gl;
  }
  function pushContextState(gl) {
    if (!gl.state) {
      trackContextState(gl, {
        copyState: false
      });
    }
    gl.state.push();
  }
  function popContextState(gl) {
    assert2(gl.state);
    gl.state.pop();
  }

  // ../../node_modules/@luma.gl/gltools/dist/esm/state-tracker/unified-parameter-api.js
  function setParameters(gl, values) {
    assert2(isWebGL(gl), "setParameters requires a WebGL context");
    if (isObjectEmpty(values)) {
      return;
    }
    const compositeSetters = {};
    for (const key in values) {
      const glConstant = Number(key);
      const setter = GL_PARAMETER_SETTERS[key];
      if (setter) {
        if (typeof setter === "string") {
          compositeSetters[setter] = true;
        } else {
          setter(gl, values[key], glConstant);
        }
      }
    }
    const cache2 = gl.state && gl.state.cache;
    if (cache2) {
      for (const key in compositeSetters) {
        const compositeSetter = GL_COMPOSITE_PARAMETER_SETTERS[key];
        compositeSetter(gl, values, cache2);
      }
    }
  }
  function getParameters(gl, parameters) {
    parameters = parameters || GL_PARAMETER_DEFAULTS;
    if (typeof parameters === "number") {
      const key = parameters;
      const getter = GL_PARAMETER_GETTERS[key];
      return getter ? getter(gl, key) : gl.getParameter(key);
    }
    const parameterKeys = Array.isArray(parameters) ? parameters : Object.keys(parameters);
    const state = {};
    for (const key of parameterKeys) {
      const getter = GL_PARAMETER_GETTERS[key];
      state[key] = getter ? getter(gl, Number(key)) : gl.getParameter(Number(key));
    }
    return state;
  }
  function withParameters(gl, parameters, func) {
    if (isObjectEmpty(parameters)) {
      return func(gl);
    }
    const {
      nocatch = true
    } = parameters;
    pushContextState(gl);
    setParameters(gl, parameters);
    let value;
    if (nocatch) {
      value = func(gl);
      popContextState(gl);
    } else {
      try {
        value = func(gl);
      } finally {
        popContextState(gl);
      }
    }
    return value;
  }

  // ../../node_modules/@luma.gl/gltools/dist/esm/context/context.js
  var isBrowser3 = isBrowser();

  // ../../node_modules/@probe.gl/stats/dist/esm/utils/hi-res-timestamp.js
  function getHiResTimestamp2() {
    let timestamp;
    if (typeof window !== "undefined" && window.performance) {
      timestamp = window.performance.now();
    } else if (typeof process !== "undefined" && process.hrtime) {
      const timeParts = process.hrtime();
      timestamp = timeParts[0] * 1e3 + timeParts[1] / 1e6;
    } else {
      timestamp = Date.now();
    }
    return timestamp;
  }

  // ../../node_modules/@probe.gl/stats/dist/esm/lib/stat.js
  var Stat = class {
    constructor(name10, type) {
      _defineProperty(this, "name", void 0);
      _defineProperty(this, "type", void 0);
      _defineProperty(this, "sampleSize", 1);
      _defineProperty(this, "time", void 0);
      _defineProperty(this, "count", void 0);
      _defineProperty(this, "samples", void 0);
      _defineProperty(this, "lastTiming", void 0);
      _defineProperty(this, "lastSampleTime", void 0);
      _defineProperty(this, "lastSampleCount", void 0);
      _defineProperty(this, "_count", 0);
      _defineProperty(this, "_time", 0);
      _defineProperty(this, "_samples", 0);
      _defineProperty(this, "_startTime", 0);
      _defineProperty(this, "_timerPending", false);
      this.name = name10;
      this.type = type;
      this.reset();
    }
    setSampleSize(samples) {
      this.sampleSize = samples;
      return this;
    }
    incrementCount() {
      this.addCount(1);
      return this;
    }
    decrementCount() {
      this.subtractCount(1);
      return this;
    }
    addCount(value) {
      this._count += value;
      this._samples++;
      this._checkSampling();
      return this;
    }
    subtractCount(value) {
      this._count -= value;
      this._samples++;
      this._checkSampling();
      return this;
    }
    addTime(time) {
      this._time += time;
      this.lastTiming = time;
      this._samples++;
      this._checkSampling();
      return this;
    }
    timeStart() {
      this._startTime = getHiResTimestamp2();
      this._timerPending = true;
      return this;
    }
    timeEnd() {
      if (!this._timerPending) {
        return this;
      }
      this.addTime(getHiResTimestamp2() - this._startTime);
      this._timerPending = false;
      this._checkSampling();
      return this;
    }
    getSampleAverageCount() {
      return this.sampleSize > 0 ? this.lastSampleCount / this.sampleSize : 0;
    }
    getSampleAverageTime() {
      return this.sampleSize > 0 ? this.lastSampleTime / this.sampleSize : 0;
    }
    getSampleHz() {
      return this.lastSampleTime > 0 ? this.sampleSize / (this.lastSampleTime / 1e3) : 0;
    }
    getAverageCount() {
      return this.samples > 0 ? this.count / this.samples : 0;
    }
    getAverageTime() {
      return this.samples > 0 ? this.time / this.samples : 0;
    }
    getHz() {
      return this.time > 0 ? this.samples / (this.time / 1e3) : 0;
    }
    reset() {
      this.time = 0;
      this.count = 0;
      this.samples = 0;
      this.lastTiming = 0;
      this.lastSampleTime = 0;
      this.lastSampleCount = 0;
      this._count = 0;
      this._time = 0;
      this._samples = 0;
      this._startTime = 0;
      this._timerPending = false;
      return this;
    }
    _checkSampling() {
      if (this._samples === this.sampleSize) {
        this.lastSampleTime = this._time;
        this.lastSampleCount = this._count;
        this.count += this._count;
        this.time += this._time;
        this.samples += this._samples;
        this._time = 0;
        this._count = 0;
        this._samples = 0;
      }
    }
  };

  // ../../node_modules/@probe.gl/stats/dist/esm/lib/stats.js
  var Stats = class {
    constructor(options) {
      _defineProperty(this, "id", void 0);
      _defineProperty(this, "stats", {});
      this.id = options.id;
      this.stats = {};
      this._initializeStats(options.stats);
      Object.seal(this);
    }
    get(name10) {
      let type = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "count";
      return this._getOrCreate({
        name: name10,
        type
      });
    }
    get size() {
      return Object.keys(this.stats).length;
    }
    reset() {
      for (const key in this.stats) {
        this.stats[key].reset();
      }
      return this;
    }
    forEach(fn) {
      for (const key in this.stats) {
        fn(this.stats[key]);
      }
    }
    getTable() {
      const table = {};
      this.forEach((stat) => {
        table[stat.name] = {
          time: stat.time || 0,
          count: stat.count || 0,
          average: stat.getAverageTime() || 0,
          hz: stat.getHz() || 0
        };
      });
      return table;
    }
    _initializeStats() {
      let stats = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      stats.forEach((stat) => this._getOrCreate(stat));
    }
    _getOrCreate(stat) {
      if (!stat || !stat.name) {
        return null;
      }
      const {
        name: name10,
        type
      } = stat;
      if (!this.stats[name10]) {
        if (stat instanceof Stat) {
          this.stats[name10] = stat;
        } else {
          this.stats[name10] = new Stat(name10, type);
        }
      }
      return this.stats[name10];
    }
  };

  // ../../node_modules/@luma.gl/webgl/dist/esm/init.js
  var VERSION2 = true ? "8.5.16" : "untranspiled source";
  var STARTUP_MESSAGE = "set luma.log.level=1 (or higher) to trace rendering";
  var StatsManager = class {
    constructor() {
      this.stats = /* @__PURE__ */ new Map();
    }
    get(name10) {
      if (!this.stats.has(name10)) {
        this.stats.set(name10, new Stats({
          id: name10
        }));
      }
      return this.stats.get(name10);
    }
  };
  var lumaStats = new StatsManager();
  if (globalThis.luma && globalThis.luma.VERSION !== VERSION2) {
    throw new Error("luma.gl - multiple VERSIONs detected: ".concat(globalThis.luma.VERSION, " vs ").concat(VERSION2));
  }
  if (!globalThis.luma) {
    if (isBrowser()) {
      log.log(1, "luma.gl ".concat(VERSION2, " - ").concat(STARTUP_MESSAGE))();
    }
    globalThis.luma = globalThis.luma || {
      VERSION: VERSION2,
      version: VERSION2,
      log,
      stats: lumaStats,
      globals: {
        modules: {},
        nodeIO: {}
      }
    };
  }
  var init_default = globalThis.luma;

  // ../../node_modules/@luma.gl/webgl/dist/esm/utils/assert.js
  function assert3(condition, message) {
    if (!condition) {
      throw new Error(message || "luma.gl: assertion failed.");
    }
  }

  // ../../node_modules/@luma.gl/webgl/dist/esm/webgl-utils/constants-to-keys.js
  function getKeyValue(gl, name10) {
    if (typeof name10 !== "string") {
      return name10;
    }
    const number = Number(name10);
    if (!isNaN(number)) {
      return number;
    }
    name10 = name10.replace(/^.*\./, "");
    const value = gl[name10];
    assert3(value !== void 0, "Accessing undefined constant GL.".concat(name10));
    return value;
  }
  function getKey(gl, value) {
    value = Number(value);
    for (const key in gl) {
      if (gl[key] === value) {
        return "GL.".concat(key);
      }
    }
    return String(value);
  }

  // ../../node_modules/@luma.gl/webgl/dist/esm/utils/utils.js
  var uidCounters = {};
  function uid() {
    let id = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "id";
    uidCounters[id] = uidCounters[id] || 1;
    const count = uidCounters[id]++;
    return "".concat(id, "-").concat(count);
  }
  function isPowerOfTwo(n2) {
    assert3(typeof n2 === "number", "Input must be a number");
    return n2 && (n2 & n2 - 1) === 0;
  }
  function isObjectEmpty2(obj) {
    let isEmpty = true;
    for (const key in obj) {
      isEmpty = false;
      break;
    }
    return isEmpty;
  }

  // ../../node_modules/@luma.gl/webgl/dist/esm/utils/stub-methods.js
  function stubRemovedMethods(instance, className, version, methodNames) {
    const upgradeMessage = "See luma.gl ".concat(version, " Upgrade Guide at https://luma.gl/docs/upgrade-guide");
    const prototype = Object.getPrototypeOf(instance);
    methodNames.forEach((methodName) => {
      if (prototype.methodName) {
        return;
      }
      prototype[methodName] = () => {
        log.removed("Calling removed method ".concat(className, ".").concat(methodName, ": "), upgradeMessage)();
        throw new Error(methodName);
      };
    });
  }

  // ../../node_modules/@luma.gl/webgl/dist/esm/classes/resource.js
  var ERR_RESOURCE_METHOD_UNDEFINED = "Resource subclass must define virtual methods";
  var Resource = class {
    get [Symbol.toStringTag]() {
      return "Resource";
    }
    constructor(gl) {
      let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      assertWebGLContext(gl);
      const {
        id,
        userData = {}
      } = opts;
      this.gl = gl;
      this.gl2 = gl;
      this.id = id || uid(this[Symbol.toStringTag]);
      this.userData = userData;
      this._bound = false;
      this._handle = opts.handle;
      if (this._handle === void 0) {
        this._handle = this._createHandle();
      }
      this.byteLength = 0;
      this._initStats();
      this._addStats();
    }
    toString() {
      return "".concat(this[Symbol.toStringTag] || this.constructor.name, "(").concat(this.id, ")");
    }
    get handle() {
      return this._handle;
    }
    delete() {
      let {
        deleteChildren = false
      } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const children = this._handle && this._deleteHandle(this._handle);
      if (this._handle) {
        this._removeStats();
      }
      this._handle = null;
      if (children && deleteChildren) {
        children.filter(Boolean).forEach((child) => child.delete());
      }
      return this;
    }
    bind() {
      let funcOrHandle = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.handle;
      if (typeof funcOrHandle !== "function") {
        this._bindHandle(funcOrHandle);
        return this;
      }
      let value;
      if (!this._bound) {
        this._bindHandle(this.handle);
        this._bound = true;
        value = funcOrHandle();
        this._bound = false;
        this._bindHandle(null);
      } else {
        value = funcOrHandle();
      }
      return value;
    }
    unbind() {
      this.bind(null);
    }
    getParameter(pname) {
      let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      pname = getKeyValue(this.gl, pname);
      assert3(pname);
      const parameters = this.constructor.PARAMETERS || {};
      const parameter = parameters[pname];
      if (parameter) {
        const isWebgl2 = isWebGL2(this.gl);
        const parameterAvailable = (!("webgl2" in parameter) || isWebgl2) && (!("extension" in parameter) || this.gl.getExtension(parameter.extension));
        if (!parameterAvailable) {
          const webgl1Default = parameter.webgl1;
          const webgl2Default = "webgl2" in parameter ? parameter.webgl2 : parameter.webgl1;
          const defaultValue = isWebgl2 ? webgl2Default : webgl1Default;
          return defaultValue;
        }
      }
      return this._getParameter(pname, opts);
    }
    getParameters() {
      let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const {
        parameters,
        keys
      } = options;
      const PARAMETERS = this.constructor.PARAMETERS || {};
      const isWebgl2 = isWebGL2(this.gl);
      const values = {};
      const parameterKeys = parameters || Object.keys(PARAMETERS);
      for (const pname of parameterKeys) {
        const parameter = PARAMETERS[pname];
        const parameterAvailable = parameter && (!("webgl2" in parameter) || isWebgl2) && (!("extension" in parameter) || this.gl.getExtension(parameter.extension));
        if (parameterAvailable) {
          const key = keys ? getKey(this.gl, pname) : pname;
          values[key] = this.getParameter(pname, options);
          if (keys && parameter.type === "GLenum") {
            values[key] = getKey(this.gl, values[key]);
          }
        }
      }
      return values;
    }
    setParameter(pname, value) {
      pname = getKeyValue(this.gl, pname);
      assert3(pname);
      const parameters = this.constructor.PARAMETERS || {};
      const parameter = parameters[pname];
      if (parameter) {
        const isWebgl2 = isWebGL2(this.gl);
        const parameterAvailable = (!("webgl2" in parameter) || isWebgl2) && (!("extension" in parameter) || this.gl.getExtension(parameter.extension));
        if (!parameterAvailable) {
          throw new Error("Parameter not available on this platform");
        }
        if (parameter.type === "GLenum") {
          value = getKeyValue(value);
        }
      }
      this._setParameter(pname, value);
      return this;
    }
    setParameters(parameters) {
      for (const pname in parameters) {
        this.setParameter(pname, parameters[pname]);
      }
      return this;
    }
    stubRemovedMethods(className, version, methodNames) {
      return stubRemovedMethods(this, className, version, methodNames);
    }
    initialize(opts) {
    }
    _createHandle() {
      throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
    }
    _deleteHandle() {
      throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
    }
    _bindHandle(handle) {
      throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
    }
    _getOptsFromHandle() {
      throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
    }
    _getParameter(pname, opts) {
      throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
    }
    _setParameter(pname, value) {
      throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
    }
    _context() {
      this.gl.luma = this.gl.luma || {};
      return this.gl.luma;
    }
    _initStats() {
      this.gl.stats = this.gl.stats || new StatsManager();
    }
    _addStats() {
      const name10 = this[Symbol.toStringTag];
      const stats = lumaStats.get("Resource Counts");
      stats.get("Resources Created").incrementCount();
      stats.get("".concat(name10, "s Created")).incrementCount();
      stats.get("".concat(name10, "s Active")).incrementCount();
    }
    _removeStats() {
      const name10 = this[Symbol.toStringTag];
      const stats = lumaStats.get("Resource Counts");
      stats.get("".concat(name10, "s Active")).decrementCount();
    }
    _trackAllocatedMemory(bytes) {
      let name10 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this[Symbol.toStringTag];
      this._doTrackAllocatedMemory(bytes, name10);
      this._doTrackAllocatedMemory(bytes, name10, this.gl.stats.get("Memory Usage"));
    }
    _doTrackAllocatedMemory(bytes) {
      let name10 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this[Symbol.toStringTag];
      let stats = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : lumaStats.get("Memory Usage");
      stats.get("GPU Memory").addCount(bytes);
      stats.get("".concat(name10, " Memory")).addCount(bytes);
      this.byteLength = bytes;
    }
    _trackDeallocatedMemory() {
      let name10 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this[Symbol.toStringTag];
      this._doTrackDeallocatedMemory(name10);
      this._doTrackDeallocatedMemory(name10, this.gl.stats.get("Memory Usage"));
    }
    _doTrackDeallocatedMemory() {
      let name10 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this[Symbol.toStringTag];
      let stats = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : lumaStats.get("Memory Usage");
      stats.get("GPU Memory").subtractCount(this.byteLength);
      stats.get("".concat(name10, " Memory")).subtractCount(this.byteLength);
      this.byteLength = 0;
    }
  };

  // ../../node_modules/@luma.gl/webgl/dist/esm/webgl-utils/typed-array-utils.js
  var ERR_TYPE_DEDUCTION = "Failed to deduce GL constant from typed array";
  function getGLTypeFromTypedArray(arrayOrType) {
    const type = ArrayBuffer.isView(arrayOrType) ? arrayOrType.constructor : arrayOrType;
    switch (type) {
      case Float32Array:
        return 5126;
      case Uint16Array:
        return 5123;
      case Uint32Array:
        return 5125;
      case Uint8Array:
        return 5121;
      case Uint8ClampedArray:
        return 5121;
      case Int8Array:
        return 5120;
      case Int16Array:
        return 5122;
      case Int32Array:
        return 5124;
      default:
        throw new Error(ERR_TYPE_DEDUCTION);
    }
  }
  function getTypedArrayFromGLType(glType) {
    let {
      clamped = true
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    switch (glType) {
      case 5126:
        return Float32Array;
      case 5123:
      case 33635:
      case 32819:
      case 32820:
        return Uint16Array;
      case 5125:
        return Uint32Array;
      case 5121:
        return clamped ? Uint8ClampedArray : Uint8Array;
      case 5120:
        return Int8Array;
      case 5122:
        return Int16Array;
      case 5124:
        return Int32Array;
      default:
        throw new Error("Failed to deduce typed array type from GL constant");
    }
  }
  function flipRows(_ref) {
    let {
      data,
      width,
      height,
      bytesPerPixel = 4,
      temp
    } = _ref;
    const bytesPerRow = width * bytesPerPixel;
    temp = temp || new Uint8Array(bytesPerRow);
    for (let y = 0; y < height / 2; ++y) {
      const topOffset = y * bytesPerRow;
      const bottomOffset = (height - y - 1) * bytesPerRow;
      temp.set(data.subarray(topOffset, topOffset + bytesPerRow));
      data.copyWithin(topOffset, bottomOffset, bottomOffset + bytesPerRow);
      data.set(temp, bottomOffset);
    }
  }
  function scalePixels(_ref2) {
    let {
      data,
      width,
      height
    } = _ref2;
    const newWidth = Math.round(width / 2);
    const newHeight = Math.round(height / 2);
    const newData = new Uint8Array(newWidth * newHeight * 4);
    for (let y = 0; y < newHeight; y++) {
      for (let x = 0; x < newWidth; x++) {
        for (let c = 0; c < 4; c++) {
          newData[(y * newWidth + x) * 4 + c] = data[(y * 2 * width + x * 2) * 4 + c];
        }
      }
    }
    return {
      data: newData,
      width: newWidth,
      height: newHeight
    };
  }

  // ../../node_modules/@luma.gl/webgl/dist/esm/utils/check-props.js
  function checkProps(className, props, propChecks) {
    const {
      removedProps = {},
      deprecatedProps = {},
      replacedProps = {}
    } = propChecks;
    for (const propName in removedProps) {
      if (propName in props) {
        const replacementProp = removedProps[propName];
        const replacement = replacementProp ? "".concat(className, ".").concat(removedProps[propName]) : "N/A";
        log.removed("".concat(className, ".").concat(propName), replacement)();
      }
    }
    for (const propName in deprecatedProps) {
      if (propName in props) {
        const replacementProp = deprecatedProps[propName];
        log.deprecated("".concat(className, ".").concat(propName), "".concat(className, ".").concat(replacementProp))();
      }
    }
    let newProps = null;
    for (const propName in replacedProps) {
      if (propName in props) {
        const replacementProp = replacedProps[propName];
        log.deprecated("".concat(className, ".").concat(propName), "".concat(className, ".").concat(replacementProp))();
        newProps = newProps || Object.assign({}, props);
        newProps[replacementProp] = props[propName];
        delete newProps[propName];
      }
    }
    return newProps || props;
  }

  // ../../node_modules/@luma.gl/webgl/dist/esm/classes/accessor.js
  var DEFAULT_ACCESSOR_VALUES = {
    offset: 0,
    stride: 0,
    type: 5126,
    size: 1,
    divisor: 0,
    normalized: false,
    integer: false
  };
  var PROP_CHECKS = {
    deprecatedProps: {
      instanced: "divisor",
      isInstanced: "divisor"
    }
  };
  var Accessor = class {
    static getBytesPerElement(accessor) {
      const ArrayType = getTypedArrayFromGLType(accessor.type || 5126);
      return ArrayType.BYTES_PER_ELEMENT;
    }
    static getBytesPerVertex(accessor) {
      assert3(accessor.size);
      const ArrayType = getTypedArrayFromGLType(accessor.type || 5126);
      return ArrayType.BYTES_PER_ELEMENT * accessor.size;
    }
    static resolve() {
      for (var _len = arguments.length, accessors = new Array(_len), _key = 0; _key < _len; _key++) {
        accessors[_key] = arguments[_key];
      }
      return new Accessor(...[DEFAULT_ACCESSOR_VALUES, ...accessors]);
    }
    constructor() {
      for (var _len2 = arguments.length, accessors = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        accessors[_key2] = arguments[_key2];
      }
      accessors.forEach((accessor) => this._assign(accessor));
      Object.freeze(this);
    }
    toString() {
      return JSON.stringify(this);
    }
    get BYTES_PER_ELEMENT() {
      return Accessor.getBytesPerElement(this);
    }
    get BYTES_PER_VERTEX() {
      return Accessor.getBytesPerVertex(this);
    }
    _assign() {
      let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      props = checkProps("Accessor", props, PROP_CHECKS);
      if (props.type !== void 0) {
        this.type = props.type;
        if (props.type === 5124 || props.type === 5125) {
          this.integer = true;
        }
      }
      if (props.size !== void 0) {
        this.size = props.size;
      }
      if (props.offset !== void 0) {
        this.offset = props.offset;
      }
      if (props.stride !== void 0) {
        this.stride = props.stride;
      }
      if (props.normalized !== void 0) {
        this.normalized = props.normalized;
      }
      if (props.integer !== void 0) {
        this.integer = props.integer;
      }
      if (props.divisor !== void 0) {
        this.divisor = props.divisor;
      }
      if (props.buffer !== void 0) {
        this.buffer = props.buffer;
      }
      if (props.index !== void 0) {
        if (typeof props.index === "boolean") {
          this.index = props.index ? 1 : 0;
        } else {
          this.index = props.index;
        }
      }
      if (props.instanced !== void 0) {
        this.divisor = props.instanced ? 1 : 0;
      }
      if (props.isInstanced !== void 0) {
        this.divisor = props.isInstanced ? 1 : 0;
      }
      return this;
    }
  };

  // ../../node_modules/@luma.gl/webgl/dist/esm/classes/buffer.js
  var DEBUG_DATA_LENGTH = 10;
  var DEPRECATED_PROPS = {
    offset: "accessor.offset",
    stride: "accessor.stride",
    type: "accessor.type",
    size: "accessor.size",
    divisor: "accessor.divisor",
    normalized: "accessor.normalized",
    integer: "accessor.integer",
    instanced: "accessor.divisor",
    isInstanced: "accessor.divisor"
  };
  var PROP_CHECKS_INITIALIZE = {
    removedProps: {},
    replacedProps: {
      bytes: "byteLength"
    },
    deprecatedProps: DEPRECATED_PROPS
  };
  var PROP_CHECKS_SET_PROPS = {
    removedProps: DEPRECATED_PROPS
  };
  var Buffer2 = class extends Resource {
    get [Symbol.toStringTag]() {
      return "Buffer";
    }
    constructor(gl) {
      let props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      super(gl, props);
      this.stubRemovedMethods("Buffer", "v6.0", ["layout", "setLayout", "getIndexedParameter"]);
      this.target = props.target || (this.gl.webgl2 ? 36662 : 34962);
      this.initialize(props);
      Object.seal(this);
    }
    getElementCount() {
      let accessor = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.accessor;
      return Math.round(this.byteLength / Accessor.getBytesPerElement(accessor));
    }
    getVertexCount() {
      let accessor = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.accessor;
      return Math.round(this.byteLength / Accessor.getBytesPerVertex(accessor));
    }
    initialize() {
      let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      if (ArrayBuffer.isView(props)) {
        props = {
          data: props
        };
      }
      if (Number.isFinite(props)) {
        props = {
          byteLength: props
        };
      }
      props = checkProps("Buffer", props, PROP_CHECKS_INITIALIZE);
      this.usage = props.usage || 35044;
      this.debugData = null;
      this.setAccessor(Object.assign({}, props, props.accessor));
      if (props.data) {
        this._setData(props.data, props.offset, props.byteLength);
      } else {
        this._setByteLength(props.byteLength || 0);
      }
      return this;
    }
    setProps(props) {
      props = checkProps("Buffer", props, PROP_CHECKS_SET_PROPS);
      if ("accessor" in props) {
        this.setAccessor(props.accessor);
      }
      return this;
    }
    setAccessor(accessor) {
      accessor = Object.assign({}, accessor);
      delete accessor.buffer;
      this.accessor = new Accessor(accessor);
      return this;
    }
    reallocate(byteLength) {
      if (byteLength > this.byteLength) {
        this._setByteLength(byteLength);
        return true;
      }
      this.bytesUsed = byteLength;
      return false;
    }
    setData(props) {
      return this.initialize(props);
    }
    subData(props) {
      if (ArrayBuffer.isView(props)) {
        props = {
          data: props
        };
      }
      const {
        data,
        offset = 0,
        srcOffset = 0
      } = props;
      const byteLength = props.byteLength || props.length;
      assert3(data);
      const target = this.gl.webgl2 ? 36663 : this.target;
      this.gl.bindBuffer(target, this.handle);
      if (srcOffset !== 0 || byteLength !== void 0) {
        assertWebGL2Context(this.gl);
        this.gl.bufferSubData(this.target, offset, data, srcOffset, byteLength);
      } else {
        this.gl.bufferSubData(target, offset, data);
      }
      this.gl.bindBuffer(target, null);
      this.debugData = null;
      this._inferType(data);
      return this;
    }
    copyData(_ref) {
      let {
        sourceBuffer,
        readOffset = 0,
        writeOffset = 0,
        size
      } = _ref;
      const {
        gl
      } = this;
      assertWebGL2Context(gl);
      gl.bindBuffer(36662, sourceBuffer.handle);
      gl.bindBuffer(36663, this.handle);
      gl.copyBufferSubData(36662, 36663, readOffset, writeOffset, size);
      gl.bindBuffer(36662, null);
      gl.bindBuffer(36663, null);
      this.debugData = null;
      return this;
    }
    getData() {
      let {
        dstData = null,
        srcByteOffset = 0,
        dstOffset = 0,
        length: length4 = 0
      } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      assertWebGL2Context(this.gl);
      const ArrayType = getTypedArrayFromGLType(this.accessor.type || 5126, {
        clamped: false
      });
      const sourceAvailableElementCount = this._getAvailableElementCount(srcByteOffset);
      const dstElementOffset = dstOffset;
      let dstAvailableElementCount;
      let dstElementCount;
      if (dstData) {
        dstElementCount = dstData.length;
        dstAvailableElementCount = dstElementCount - dstElementOffset;
      } else {
        dstAvailableElementCount = Math.min(sourceAvailableElementCount, length4 || sourceAvailableElementCount);
        dstElementCount = dstElementOffset + dstAvailableElementCount;
      }
      const copyElementCount = Math.min(sourceAvailableElementCount, dstAvailableElementCount);
      length4 = length4 || copyElementCount;
      assert3(length4 <= copyElementCount);
      dstData = dstData || new ArrayType(dstElementCount);
      this.gl.bindBuffer(36662, this.handle);
      this.gl.getBufferSubData(36662, srcByteOffset, dstData, dstOffset, length4);
      this.gl.bindBuffer(36662, null);
      return dstData;
    }
    bind() {
      let {
        target = this.target,
        index = this.accessor && this.accessor.index,
        offset = 0,
        size
      } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      if (target === 35345 || target === 35982) {
        if (size !== void 0) {
          this.gl.bindBufferRange(target, index, this.handle, offset, size);
        } else {
          assert3(offset === 0);
          this.gl.bindBufferBase(target, index, this.handle);
        }
      } else {
        this.gl.bindBuffer(target, this.handle);
      }
      return this;
    }
    unbind() {
      let {
        target = this.target,
        index = this.accessor && this.accessor.index
      } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const isIndexedBuffer = target === 35345 || target === 35982;
      if (isIndexedBuffer) {
        this.gl.bindBufferBase(target, index, null);
      } else {
        this.gl.bindBuffer(target, null);
      }
      return this;
    }
    getDebugData() {
      if (!this.debugData) {
        this.debugData = this.getData({
          length: Math.min(DEBUG_DATA_LENGTH, this.byteLength)
        });
        return {
          data: this.debugData,
          changed: true
        };
      }
      return {
        data: this.debugData,
        changed: false
      };
    }
    invalidateDebugData() {
      this.debugData = null;
    }
    _setData(data) {
      let offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      let byteLength = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : data.byteLength + offset;
      assert3(ArrayBuffer.isView(data));
      this._trackDeallocatedMemory();
      const target = this._getTarget();
      this.gl.bindBuffer(target, this.handle);
      this.gl.bufferData(target, byteLength, this.usage);
      this.gl.bufferSubData(target, offset, data);
      this.gl.bindBuffer(target, null);
      this.debugData = data.slice(0, DEBUG_DATA_LENGTH);
      this.bytesUsed = byteLength;
      this._trackAllocatedMemory(byteLength);
      const type = getGLTypeFromTypedArray(data);
      assert3(type);
      this.setAccessor(new Accessor(this.accessor, {
        type
      }));
      return this;
    }
    _setByteLength(byteLength) {
      let usage = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.usage;
      assert3(byteLength >= 0);
      this._trackDeallocatedMemory();
      let data = byteLength;
      if (byteLength === 0) {
        data = new Float32Array(0);
      }
      const target = this._getTarget();
      this.gl.bindBuffer(target, this.handle);
      this.gl.bufferData(target, data, usage);
      this.gl.bindBuffer(target, null);
      this.usage = usage;
      this.debugData = null;
      this.bytesUsed = byteLength;
      this._trackAllocatedMemory(byteLength);
      return this;
    }
    _getTarget() {
      return this.gl.webgl2 ? 36663 : this.target;
    }
    _getAvailableElementCount(srcByteOffset) {
      const ArrayType = getTypedArrayFromGLType(this.accessor.type || 5126, {
        clamped: false
      });
      const sourceElementOffset = srcByteOffset / ArrayType.BYTES_PER_ELEMENT;
      return this.getElementCount() - sourceElementOffset;
    }
    _inferType(data) {
      if (!this.accessor.type) {
        this.setAccessor(new Accessor(this.accessor, {
          type: getGLTypeFromTypedArray(data)
        }));
      }
    }
    _createHandle() {
      return this.gl.createBuffer();
    }
    _deleteHandle() {
      this.gl.deleteBuffer(this.handle);
      this._trackDeallocatedMemory();
    }
    _getParameter(pname) {
      this.gl.bindBuffer(this.target, this.handle);
      const value = this.gl.getBufferParameter(this.target, pname);
      this.gl.bindBuffer(this.target, null);
      return value;
    }
    get type() {
      log.deprecated("Buffer.type", "Buffer.accessor.type")();
      return this.accessor.type;
    }
    get bytes() {
      log.deprecated("Buffer.bytes", "Buffer.byteLength")();
      return this.byteLength;
    }
    setByteLength(byteLength) {
      log.deprecated("setByteLength", "reallocate")();
      return this.reallocate(byteLength);
    }
    updateAccessor(opts) {
      log.deprecated("updateAccessor(...)", "setAccessor(new Accessor(buffer.accessor, ...)")();
      this.accessor = new Accessor(this.accessor, opts);
      return this;
    }
  };

  // ../../node_modules/@luma.gl/webgl/dist/esm/classes/texture-formats.js
  var TEXTURE_FORMATS = {
    [6407]: {
      dataFormat: 6407,
      types: [5121, 33635]
    },
    [6408]: {
      dataFormat: 6408,
      types: [5121, 32819, 32820]
    },
    [6406]: {
      dataFormat: 6406,
      types: [5121]
    },
    [6409]: {
      dataFormat: 6409,
      types: [5121]
    },
    [6410]: {
      dataFormat: 6410,
      types: [5121]
    },
    [33326]: {
      dataFormat: 6403,
      types: [5126],
      gl2: true
    },
    [33328]: {
      dataFormat: 33319,
      types: [5126],
      gl2: true
    },
    [34837]: {
      dataFormat: 6407,
      types: [5126],
      gl2: true
    },
    [34836]: {
      dataFormat: 6408,
      types: [5126],
      gl2: true
    }
  };
  var DATA_FORMAT_CHANNELS = {
    [6403]: 1,
    [36244]: 1,
    [33319]: 2,
    [33320]: 2,
    [6407]: 3,
    [36248]: 3,
    [6408]: 4,
    [36249]: 4,
    [6402]: 1,
    [34041]: 1,
    [6406]: 1,
    [6409]: 1,
    [6410]: 2
  };
  var TYPE_SIZES = {
    [5126]: 4,
    [5125]: 4,
    [5124]: 4,
    [5123]: 2,
    [5122]: 2,
    [5131]: 2,
    [5120]: 1,
    [5121]: 1
  };
  function isFormatSupported(gl, format) {
    const info = TEXTURE_FORMATS[format];
    if (!info) {
      return false;
    }
    if (info.gl1 === void 0 && info.gl2 === void 0) {
      return true;
    }
    const value = isWebGL2(gl) ? info.gl2 || info.gl1 : info.gl1;
    return typeof value === "string" ? gl.getExtension(value) : value;
  }
  function isLinearFilteringSupported(gl, format) {
    const info = TEXTURE_FORMATS[format];
    switch (info && info.types[0]) {
      case 5126:
        return gl.getExtension("OES_texture_float_linear");
      case 5131:
        return gl.getExtension("OES_texture_half_float_linear");
      default:
        return true;
    }
  }

  // ../../node_modules/@luma.gl/webgl/dist/esm/classes/texture.js
  var NPOT_MIN_FILTERS = [9729, 9728];
  var WebGLBuffer = globalThis.WebGLBuffer || function WebGLBuffer2() {
  };
  var Texture = class extends Resource {
    get [Symbol.toStringTag]() {
      return "Texture";
    }
    static isSupported(gl) {
      let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      const {
        format,
        linearFiltering
      } = opts;
      let supported = true;
      if (format) {
        supported = supported && isFormatSupported(gl, format);
        supported = supported && (!linearFiltering || isLinearFilteringSupported(gl, format));
      }
      return supported;
    }
    constructor(gl, props) {
      const {
        id = uid("texture"),
        handle,
        target
      } = props;
      super(gl, {
        id,
        handle
      });
      this.target = target;
      this.textureUnit = void 0;
      this.loaded = false;
      this.width = void 0;
      this.height = void 0;
      this.depth = void 0;
      this.format = void 0;
      this.type = void 0;
      this.dataFormat = void 0;
      this.border = void 0;
      this.textureUnit = void 0;
      this.mipmaps = void 0;
    }
    toString() {
      return "Texture(".concat(this.id, ",").concat(this.width, "x").concat(this.height, ")");
    }
    initialize() {
      let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      let data = props.data;
      if (data instanceof Promise) {
        data.then((resolvedImageData) => this.initialize(Object.assign({}, props, {
          pixels: resolvedImageData,
          data: resolvedImageData
        })));
        return this;
      }
      const isVideo = typeof HTMLVideoElement !== "undefined" && data instanceof HTMLVideoElement;
      if (isVideo && data.readyState < HTMLVideoElement.HAVE_METADATA) {
        this._video = null;
        data.addEventListener("loadeddata", () => this.initialize(props));
        return this;
      }
      const {
        pixels = null,
        format = 6408,
        border = 0,
        recreate = false,
        parameters = {},
        pixelStore = {},
        textureUnit = void 0
      } = props;
      if (!data) {
        data = pixels;
      }
      let {
        width,
        height,
        dataFormat,
        type,
        compressed = false,
        mipmaps = true
      } = props;
      const {
        depth = 0
      } = props;
      ({
        width,
        height,
        compressed,
        dataFormat,
        type
      } = this._deduceParameters({
        format,
        type,
        dataFormat,
        compressed,
        data,
        width,
        height
      }));
      this.width = width;
      this.height = height;
      this.depth = depth;
      this.format = format;
      this.type = type;
      this.dataFormat = dataFormat;
      this.border = border;
      this.textureUnit = textureUnit;
      if (Number.isFinite(this.textureUnit)) {
        this.gl.activeTexture(33984 + this.textureUnit);
        this.gl.bindTexture(this.target, this.handle);
      }
      if (mipmaps && this._isNPOT()) {
        log.warn("texture: ".concat(this, " is Non-Power-Of-Two, disabling mipmaping"))();
        mipmaps = false;
        this._updateForNPOT(parameters);
      }
      this.mipmaps = mipmaps;
      this.setImageData({
        data,
        width,
        height,
        depth,
        format,
        type,
        dataFormat,
        border,
        mipmaps,
        parameters: pixelStore,
        compressed
      });
      if (mipmaps) {
        this.generateMipmap();
      }
      this.setParameters(parameters);
      if (recreate) {
        this.data = data;
      }
      if (isVideo) {
        this._video = {
          video: data,
          parameters,
          lastTime: data.readyState >= HTMLVideoElement.HAVE_CURRENT_DATA ? data.currentTime : -1
        };
      }
      return this;
    }
    update() {
      if (this._video) {
        const {
          video,
          parameters,
          lastTime
        } = this._video;
        if (lastTime === video.currentTime || video.readyState < HTMLVideoElement.HAVE_CURRENT_DATA) {
          return;
        }
        this.setSubImageData({
          data: video,
          parameters
        });
        if (this.mipmaps) {
          this.generateMipmap();
        }
        this._video.lastTime = video.currentTime;
      }
    }
    resize(_ref) {
      let {
        height,
        width,
        mipmaps = false
      } = _ref;
      if (width !== this.width || height !== this.height) {
        return this.initialize({
          width,
          height,
          format: this.format,
          type: this.type,
          dataFormat: this.dataFormat,
          border: this.border,
          mipmaps
        });
      }
      return this;
    }
    generateMipmap() {
      let params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      if (this._isNPOT()) {
        log.warn("texture: ".concat(this, " is Non-Power-Of-Two, disabling mipmaping"))();
        return this;
      }
      this.mipmaps = true;
      this.gl.bindTexture(this.target, this.handle);
      withParameters(this.gl, params, () => {
        this.gl.generateMipmap(this.target);
      });
      this.gl.bindTexture(this.target, null);
      return this;
    }
    setImageData(options) {
      this._trackDeallocatedMemory("Texture");
      const {
        target = this.target,
        pixels = null,
        level = 0,
        format = this.format,
        border = this.border,
        offset = 0,
        parameters = {}
      } = options;
      let {
        data = null,
        type = this.type,
        width = this.width,
        height = this.height,
        dataFormat = this.dataFormat,
        compressed = false
      } = options;
      if (!data) {
        data = pixels;
      }
      ({
        type,
        dataFormat,
        compressed,
        width,
        height
      } = this._deduceParameters({
        format,
        type,
        dataFormat,
        compressed,
        data,
        width,
        height
      }));
      const {
        gl
      } = this;
      gl.bindTexture(this.target, this.handle);
      let dataType = null;
      ({
        data,
        dataType
      } = this._getDataType({
        data,
        compressed
      }));
      let gl2;
      let compressedTextureSize = 0;
      withParameters(this.gl, parameters, () => {
        switch (dataType) {
          case "null":
            gl.texImage2D(target, level, format, width, height, border, dataFormat, type, data);
            break;
          case "typed-array":
            gl.texImage2D(target, level, format, width, height, border, dataFormat, type, data, offset);
            break;
          case "buffer":
            gl2 = assertWebGL2Context(gl);
            gl2.bindBuffer(35052, data.handle || data);
            gl2.texImage2D(target, level, format, width, height, border, dataFormat, type, offset);
            gl2.bindBuffer(35052, null);
            break;
          case "browser-object":
            if (isWebGL2(gl)) {
              gl.texImage2D(target, level, format, width, height, border, dataFormat, type, data);
            } else {
              gl.texImage2D(target, level, format, dataFormat, type, data);
            }
            break;
          case "compressed":
            for (const [levelIndex, levelData] of data.entries()) {
              gl.compressedTexImage2D(target, levelIndex, levelData.format, levelData.width, levelData.height, border, levelData.data);
              compressedTextureSize += levelData.levelSize;
            }
            break;
          default:
            assert3(false, "Unknown image data type");
        }
      });
      if (dataType === "compressed") {
        this._trackAllocatedMemory(compressedTextureSize, "Texture");
      } else if (data && data.byteLength) {
        this._trackAllocatedMemory(data.byteLength, "Texture");
      } else {
        const channels = DATA_FORMAT_CHANNELS[this.dataFormat] || 4;
        const channelSize = TYPE_SIZES[this.type] || 1;
        this._trackAllocatedMemory(this.width * this.height * channels * channelSize, "Texture");
      }
      this.loaded = true;
      return this;
    }
    setSubImageData(_ref2) {
      let {
        target = this.target,
        pixels = null,
        data = null,
        x = 0,
        y = 0,
        width = this.width,
        height = this.height,
        level = 0,
        format = this.format,
        type = this.type,
        dataFormat = this.dataFormat,
        compressed = false,
        offset = 0,
        border = this.border,
        parameters = {}
      } = _ref2;
      ({
        type,
        dataFormat,
        compressed,
        width,
        height
      } = this._deduceParameters({
        format,
        type,
        dataFormat,
        compressed,
        data,
        width,
        height
      }));
      assert3(this.depth === 0, "texSubImage not supported for 3D textures");
      if (!data) {
        data = pixels;
      }
      if (data && data.data) {
        const ndarray = data;
        data = ndarray.data;
        width = ndarray.shape[0];
        height = ndarray.shape[1];
      }
      if (data instanceof Buffer2) {
        data = data.handle;
      }
      this.gl.bindTexture(this.target, this.handle);
      withParameters(this.gl, parameters, () => {
        if (compressed) {
          this.gl.compressedTexSubImage2D(target, level, x, y, width, height, format, data);
        } else if (data === null) {
          this.gl.texSubImage2D(target, level, x, y, width, height, dataFormat, type, null);
        } else if (ArrayBuffer.isView(data)) {
          this.gl.texSubImage2D(target, level, x, y, width, height, dataFormat, type, data, offset);
        } else if (data instanceof WebGLBuffer) {
          const gl2 = assertWebGL2Context(this.gl);
          gl2.bindBuffer(35052, data);
          gl2.texSubImage2D(target, level, x, y, width, height, dataFormat, type, offset);
          gl2.bindBuffer(35052, null);
        } else if (isWebGL2(this.gl)) {
          const gl2 = assertWebGL2Context(this.gl);
          gl2.texSubImage2D(target, level, x, y, width, height, dataFormat, type, data);
        } else {
          this.gl.texSubImage2D(target, level, x, y, dataFormat, type, data);
        }
      });
      this.gl.bindTexture(this.target, null);
    }
    copyFramebuffer() {
      let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      log.error("Texture.copyFramebuffer({...}) is no logner supported, use copyToTexture(source, target, opts})")();
      return null;
    }
    getActiveUnit() {
      return this.gl.getParameter(34016) - 33984;
    }
    bind() {
      let textureUnit = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.textureUnit;
      const {
        gl
      } = this;
      if (textureUnit !== void 0) {
        this.textureUnit = textureUnit;
        gl.activeTexture(33984 + textureUnit);
      }
      gl.bindTexture(this.target, this.handle);
      return textureUnit;
    }
    unbind() {
      let textureUnit = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.textureUnit;
      const {
        gl
      } = this;
      if (textureUnit !== void 0) {
        this.textureUnit = textureUnit;
        gl.activeTexture(33984 + textureUnit);
      }
      gl.bindTexture(this.target, null);
      return textureUnit;
    }
    _getDataType(_ref3) {
      let {
        data,
        compressed = false
      } = _ref3;
      if (compressed) {
        return {
          data,
          dataType: "compressed"
        };
      }
      if (data === null) {
        return {
          data,
          dataType: "null"
        };
      }
      if (ArrayBuffer.isView(data)) {
        return {
          data,
          dataType: "typed-array"
        };
      }
      if (data instanceof Buffer2) {
        return {
          data: data.handle,
          dataType: "buffer"
        };
      }
      if (data instanceof WebGLBuffer) {
        return {
          data,
          dataType: "buffer"
        };
      }
      return {
        data,
        dataType: "browser-object"
      };
    }
    _deduceParameters(opts) {
      const {
        format,
        data
      } = opts;
      let {
        width,
        height,
        dataFormat,
        type,
        compressed
      } = opts;
      const textureFormat = TEXTURE_FORMATS[format];
      dataFormat = dataFormat || textureFormat && textureFormat.dataFormat;
      type = type || textureFormat && textureFormat.types[0];
      compressed = compressed || textureFormat && textureFormat.compressed;
      ({
        width,
        height
      } = this._deduceImageSize(data, width, height));
      return {
        dataFormat,
        type,
        compressed,
        width,
        height,
        format,
        data
      };
    }
    _deduceImageSize(data, width, height) {
      let size;
      if (typeof ImageData !== "undefined" && data instanceof ImageData) {
        size = {
          width: data.width,
          height: data.height
        };
      } else if (typeof HTMLImageElement !== "undefined" && data instanceof HTMLImageElement) {
        size = {
          width: data.naturalWidth,
          height: data.naturalHeight
        };
      } else if (typeof HTMLCanvasElement !== "undefined" && data instanceof HTMLCanvasElement) {
        size = {
          width: data.width,
          height: data.height
        };
      } else if (typeof ImageBitmap !== "undefined" && data instanceof ImageBitmap) {
        size = {
          width: data.width,
          height: data.height
        };
      } else if (typeof HTMLVideoElement !== "undefined" && data instanceof HTMLVideoElement) {
        size = {
          width: data.videoWidth,
          height: data.videoHeight
        };
      } else if (!data) {
        size = {
          width: width >= 0 ? width : 1,
          height: height >= 0 ? height : 1
        };
      } else {
        size = {
          width,
          height
        };
      }
      assert3(size, "Could not deduced texture size");
      assert3(width === void 0 || size.width === width, "Deduced texture width does not match supplied width");
      assert3(height === void 0 || size.height === height, "Deduced texture height does not match supplied height");
      return size;
    }
    _createHandle() {
      return this.gl.createTexture();
    }
    _deleteHandle() {
      this.gl.deleteTexture(this.handle);
      this._trackDeallocatedMemory("Texture");
    }
    _getParameter(pname) {
      switch (pname) {
        case 4096:
          return this.width;
        case 4097:
          return this.height;
        default:
          this.gl.bindTexture(this.target, this.handle);
          const value = this.gl.getTexParameter(this.target, pname);
          this.gl.bindTexture(this.target, null);
          return value;
      }
    }
    _setParameter(pname, param) {
      this.gl.bindTexture(this.target, this.handle);
      param = this._getNPOTParam(pname, param);
      switch (pname) {
        case 33082:
        case 33083:
          this.gl.texParameterf(this.handle, pname, param);
          break;
        case 4096:
        case 4097:
          assert3(false);
          break;
        default:
          this.gl.texParameteri(this.target, pname, param);
          break;
      }
      this.gl.bindTexture(this.target, null);
      return this;
    }
    _isNPOT() {
      if (isWebGL2(this.gl)) {
        return false;
      }
      if (!this.width || !this.height) {
        return false;
      }
      return !isPowerOfTwo(this.width) || !isPowerOfTwo(this.height);
    }
    _updateForNPOT(parameters) {
      if (parameters[this.gl.TEXTURE_MIN_FILTER] === void 0) {
        parameters[this.gl.TEXTURE_MIN_FILTER] = this.gl.LINEAR;
      }
      if (parameters[this.gl.TEXTURE_WRAP_S] === void 0) {
        parameters[this.gl.TEXTURE_WRAP_S] = this.gl.CLAMP_TO_EDGE;
      }
      if (parameters[this.gl.TEXTURE_WRAP_T] === void 0) {
        parameters[this.gl.TEXTURE_WRAP_T] = this.gl.CLAMP_TO_EDGE;
      }
    }
    _getNPOTParam(pname, param) {
      if (this._isNPOT()) {
        switch (pname) {
          case 10241:
            if (NPOT_MIN_FILTERS.indexOf(param) === -1) {
              param = 9729;
            }
            break;
          case 10242:
          case 10243:
            if (param !== 33071) {
              param = 33071;
            }
            break;
          default:
            break;
        }
      }
      return param;
    }
  };

  // ../../node_modules/@luma.gl/webgl/dist/esm/utils/load-file.js
  var pathPrefix = "";
  function loadImage(url, opts) {
    assert3(typeof url === "string");
    url = pathPrefix + url;
    return new Promise((resolve, reject) => {
      try {
        const image = new Image();
        image.onload = () => resolve(image);
        image.onerror = () => reject(new Error("Could not load image ".concat(url, ".")));
        image.crossOrigin = opts && opts.crossOrigin || "anonymous";
        image.src = url;
      } catch (error2) {
        reject(error2);
      }
    });
  }

  // ../../node_modules/@luma.gl/webgl/dist/esm/classes/texture-2d.js
  var Texture2D = class extends Texture {
    get [Symbol.toStringTag]() {
      return "Texture2D";
    }
    static isSupported(gl, opts) {
      return Texture.isSupported(gl, opts);
    }
    constructor(gl) {
      let props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      assertWebGLContext(gl);
      if (props instanceof Promise || typeof props === "string") {
        props = {
          data: props
        };
      }
      if (typeof props.data === "string") {
        props = Object.assign({}, props, {
          data: loadImage(props.data)
        });
      }
      super(gl, Object.assign({}, props, {
        target: 3553
      }));
      this.initialize(props);
      Object.seal(this);
    }
  };

  // ../../node_modules/@luma.gl/webgl/dist/esm/classes/renderbuffer-formats.js
  var EXT_FLOAT_WEBGL2 = "EXT_color_buffer_float";
  var renderbuffer_formats_default = {
    [33189]: {
      bpp: 2
    },
    [33190]: {
      gl2: true,
      bpp: 3
    },
    [36012]: {
      gl2: true,
      bpp: 4
    },
    [36168]: {
      bpp: 1
    },
    [34041]: {
      bpp: 4
    },
    [35056]: {
      gl2: true,
      bpp: 4
    },
    [36013]: {
      gl2: true,
      bpp: 5
    },
    [32854]: {
      bpp: 2
    },
    [36194]: {
      bpp: 2
    },
    [32855]: {
      bpp: 2
    },
    [33321]: {
      gl2: true,
      bpp: 1
    },
    [33330]: {
      gl2: true,
      bpp: 1
    },
    [33329]: {
      gl2: true,
      bpp: 1
    },
    [33332]: {
      gl2: true,
      bpp: 2
    },
    [33331]: {
      gl2: true,
      bpp: 2
    },
    [33334]: {
      gl2: true,
      bpp: 4
    },
    [33333]: {
      gl2: true,
      bpp: 4
    },
    [33323]: {
      gl2: true,
      bpp: 2
    },
    [33336]: {
      gl2: true,
      bpp: 2
    },
    [33335]: {
      gl2: true,
      bpp: 2
    },
    [33338]: {
      gl2: true,
      bpp: 4
    },
    [33337]: {
      gl2: true,
      bpp: 4
    },
    [33340]: {
      gl2: true,
      bpp: 8
    },
    [33339]: {
      gl2: true,
      bpp: 8
    },
    [32849]: {
      gl2: true,
      bpp: 3
    },
    [32856]: {
      gl2: true,
      bpp: 4
    },
    [32857]: {
      gl2: true,
      bpp: 4
    },
    [36220]: {
      gl2: true,
      bpp: 4
    },
    [36238]: {
      gl2: true,
      bpp: 4
    },
    [36975]: {
      gl2: true,
      bpp: 4
    },
    [36214]: {
      gl2: true,
      bpp: 8
    },
    [36232]: {
      gl2: true,
      bpp: 8
    },
    [36226]: {
      gl2: true,
      bpp: 16
    },
    [36208]: {
      gl2: true,
      bpp: 16
    },
    [33325]: {
      gl2: EXT_FLOAT_WEBGL2,
      bpp: 2
    },
    [33327]: {
      gl2: EXT_FLOAT_WEBGL2,
      bpp: 4
    },
    [34842]: {
      gl2: EXT_FLOAT_WEBGL2,
      bpp: 8
    },
    [33326]: {
      gl2: EXT_FLOAT_WEBGL2,
      bpp: 4
    },
    [33328]: {
      gl2: EXT_FLOAT_WEBGL2,
      bpp: 8
    },
    [34836]: {
      gl2: EXT_FLOAT_WEBGL2,
      bpp: 16
    },
    [35898]: {
      gl2: EXT_FLOAT_WEBGL2,
      bpp: 4
    }
  };

  // ../../node_modules/@luma.gl/webgl/dist/esm/classes/renderbuffer.js
  function isFormatSupported2(gl, format, formats2) {
    const info = formats2[format];
    if (!info) {
      return false;
    }
    const value = isWebGL2(gl) ? info.gl2 || info.gl1 : info.gl1;
    if (typeof value === "string") {
      return gl.getExtension(value);
    }
    return value;
  }
  var Renderbuffer = class extends Resource {
    get [Symbol.toStringTag]() {
      return "Renderbuffer";
    }
    static isSupported(gl) {
      let {
        format
      } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
        format: null
      };
      return !format || isFormatSupported2(gl, format, renderbuffer_formats_default);
    }
    static getSamplesForFormat(gl, _ref) {
      let {
        format
      } = _ref;
      return gl.getInternalformatParameter(36161, format, 32937);
    }
    constructor(gl) {
      let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      super(gl, opts);
      this.initialize(opts);
      Object.seal(this);
    }
    initialize(_ref2) {
      let {
        format,
        width = 1,
        height = 1,
        samples = 0
      } = _ref2;
      assert3(format, "Needs format");
      this._trackDeallocatedMemory();
      this.gl.bindRenderbuffer(36161, this.handle);
      if (samples !== 0 && isWebGL2(this.gl)) {
        this.gl.renderbufferStorageMultisample(36161, samples, format, width, height);
      } else {
        this.gl.renderbufferStorage(36161, format, width, height);
      }
      this.format = format;
      this.width = width;
      this.height = height;
      this.samples = samples;
      this._trackAllocatedMemory(this.width * this.height * (this.samples || 1) * renderbuffer_formats_default[this.format].bpp);
      return this;
    }
    resize(_ref3) {
      let {
        width,
        height
      } = _ref3;
      if (width !== this.width || height !== this.height) {
        return this.initialize({
          width,
          height,
          format: this.format,
          samples: this.samples
        });
      }
      return this;
    }
    _createHandle() {
      return this.gl.createRenderbuffer();
    }
    _deleteHandle() {
      this.gl.deleteRenderbuffer(this.handle);
      this._trackDeallocatedMemory();
    }
    _bindHandle(handle) {
      this.gl.bindRenderbuffer(36161, handle);
    }
    _syncHandle(handle) {
      this.format = this.getParameter(36164);
      this.width = this.getParameter(36162);
      this.height = this.getParameter(36163);
      this.samples = this.getParameter(36011);
    }
    _getParameter(pname) {
      this.gl.bindRenderbuffer(36161, this.handle);
      const value = this.gl.getRenderbufferParameter(36161, pname);
      return value;
    }
  };

  // ../../node_modules/@luma.gl/webgl/dist/esm/classes/clear.js
  var GL_DEPTH_BUFFER_BIT = 256;
  var GL_STENCIL_BUFFER_BIT = 1024;
  var GL_COLOR_BUFFER_BIT = 16384;
  var GL_COLOR = 6144;
  var GL_DEPTH = 6145;
  var GL_STENCIL = 6146;
  var GL_DEPTH_STENCIL = 34041;
  var ERR_ARGUMENTS = "clear: bad arguments";
  function clear(gl) {
    let {
      framebuffer = null,
      color = null,
      depth = null,
      stencil = null
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const parameters = {};
    if (framebuffer) {
      parameters.framebuffer = framebuffer;
    }
    let clearFlags = 0;
    if (color) {
      clearFlags |= GL_COLOR_BUFFER_BIT;
      if (color !== true) {
        parameters.clearColor = color;
      }
    }
    if (depth) {
      clearFlags |= GL_DEPTH_BUFFER_BIT;
      if (depth !== true) {
        parameters.clearDepth = depth;
      }
    }
    if (stencil) {
      clearFlags |= GL_STENCIL_BUFFER_BIT;
      if (depth !== true) {
        parameters.clearStencil = depth;
      }
    }
    assert3(clearFlags !== 0, ERR_ARGUMENTS);
    withParameters(gl, parameters, () => {
      gl.clear(clearFlags);
    });
  }
  function clearBuffer(gl) {
    let {
      framebuffer = null,
      buffer = GL_COLOR,
      drawBuffer = 0,
      value = [0, 0, 0, 0]
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    assertWebGL2Context(gl);
    withParameters(gl, {
      framebuffer
    }, () => {
      switch (buffer) {
        case GL_COLOR:
          switch (value.constructor) {
            case Int32Array:
              gl.clearBufferiv(buffer, drawBuffer, value);
              break;
            case Uint32Array:
              gl.clearBufferuiv(buffer, drawBuffer, value);
              break;
            case Float32Array:
            default:
              gl.clearBufferfv(buffer, drawBuffer, value);
          }
          break;
        case GL_DEPTH:
          gl.clearBufferfv(GL_DEPTH, 0, [value]);
          break;
        case GL_STENCIL:
          gl.clearBufferiv(GL_STENCIL, 0, [value]);
          break;
        case GL_DEPTH_STENCIL:
          const [depth, stencil] = value;
          gl.clearBufferfi(GL_DEPTH_STENCIL, 0, depth, stencil);
          break;
        default:
          assert3(false, ERR_ARGUMENTS);
      }
    });
  }

  // ../../node_modules/@luma.gl/webgl/dist/esm/webgl-utils/format-utils.js
  function glFormatToComponents(format) {
    switch (format) {
      case 6406:
      case 33326:
      case 6403:
        return 1;
      case 33328:
      case 33319:
        return 2;
      case 6407:
      case 34837:
        return 3;
      case 6408:
      case 34836:
        return 4;
      default:
        assert3(false);
        return 0;
    }
  }

  // ../../node_modules/@luma.gl/webgl/dist/esm/classes/copy-and-blit.js
  function readPixelsToArray(source) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const {
      sourceX = 0,
      sourceY = 0,
      sourceFormat = 6408
    } = options;
    let {
      sourceAttachment = 36064,
      target = null,
      sourceWidth,
      sourceHeight,
      sourceType
    } = options;
    const {
      framebuffer,
      deleteFramebuffer
    } = getFramebuffer(source);
    assert3(framebuffer);
    const {
      gl,
      handle,
      attachments
    } = framebuffer;
    sourceWidth = sourceWidth || framebuffer.width;
    sourceHeight = sourceHeight || framebuffer.height;
    if (sourceAttachment === 36064 && handle === null) {
      sourceAttachment = 1028;
    }
    assert3(attachments[sourceAttachment]);
    sourceType = sourceType || attachments[sourceAttachment].type;
    target = getPixelArray(target, sourceType, sourceFormat, sourceWidth, sourceHeight);
    sourceType = sourceType || getGLTypeFromTypedArray(target);
    const prevHandle = gl.bindFramebuffer(36160, handle);
    gl.readPixels(sourceX, sourceY, sourceWidth, sourceHeight, sourceFormat, sourceType, target);
    gl.bindFramebuffer(36160, prevHandle || null);
    if (deleteFramebuffer) {
      framebuffer.delete();
    }
    return target;
  }
  function copyToDataUrl(source) {
    let {
      sourceAttachment = 36064,
      targetMaxHeight = Number.MAX_SAFE_INTEGER
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    let data = readPixelsToArray(source, {
      sourceAttachment
    });
    let {
      width,
      height
    } = source;
    while (height > targetMaxHeight) {
      ({
        data,
        width,
        height
      } = scalePixels({
        data,
        width,
        height
      }));
    }
    flipRows({
      data,
      width,
      height
    });
    const canvas = document.createElement("canvas");
    canvas.width = width;
    canvas.height = height;
    const context = canvas.getContext("2d");
    const imageData = context.createImageData(width, height);
    imageData.data.set(data);
    context.putImageData(imageData, 0, 0);
    return canvas.toDataURL();
  }
  function getFramebuffer(source) {
    if (!(source instanceof Framebuffer)) {
      return {
        framebuffer: toFramebuffer(source),
        deleteFramebuffer: true
      };
    }
    return {
      framebuffer: source,
      deleteFramebuffer: false
    };
  }
  function getPixelArray(pixelArray, type, format, width, height) {
    if (pixelArray) {
      return pixelArray;
    }
    type = type || 5121;
    const ArrayType = getTypedArrayFromGLType(type, {
      clamped: false
    });
    const components = glFormatToComponents(format);
    return new ArrayType(width * height * components);
  }

  // ../../node_modules/@luma.gl/webgl/dist/esm/features/webgl-features-table.js
  var FEATURES = {
    WEBGL2: "WEBGL2",
    VERTEX_ARRAY_OBJECT: "VERTEX_ARRAY_OBJECT",
    TIMER_QUERY: "TIMER_QUERY",
    INSTANCED_RENDERING: "INSTANCED_RENDERING",
    MULTIPLE_RENDER_TARGETS: "MULTIPLE_RENDER_TARGETS",
    ELEMENT_INDEX_UINT32: "ELEMENT_INDEX_UINT32",
    BLEND_EQUATION_MINMAX: "BLEND_EQUATION_MINMAX",
    FLOAT_BLEND: "FLOAT_BLEND",
    COLOR_ENCODING_SRGB: "COLOR_ENCODING_SRGB",
    TEXTURE_DEPTH: "TEXTURE_DEPTH",
    TEXTURE_FLOAT: "TEXTURE_FLOAT",
    TEXTURE_HALF_FLOAT: "TEXTURE_HALF_FLOAT",
    TEXTURE_FILTER_LINEAR_FLOAT: "TEXTURE_FILTER_LINEAR_FLOAT",
    TEXTURE_FILTER_LINEAR_HALF_FLOAT: "TEXTURE_FILTER_LINEAR_HALF_FLOAT",
    TEXTURE_FILTER_ANISOTROPIC: "TEXTURE_FILTER_ANISOTROPIC",
    COLOR_ATTACHMENT_RGBA32F: "COLOR_ATTACHMENT_RGBA32F",
    COLOR_ATTACHMENT_FLOAT: "COLOR_ATTACHMENT_FLOAT",
    COLOR_ATTACHMENT_HALF_FLOAT: "COLOR_ATTACHMENT_HALF_FLOAT",
    GLSL_FRAG_DATA: "GLSL_FRAG_DATA",
    GLSL_FRAG_DEPTH: "GLSL_FRAG_DEPTH",
    GLSL_DERIVATIVES: "GLSL_DERIVATIVES",
    GLSL_TEXTURE_LOD: "GLSL_TEXTURE_LOD"
  };
  function checkFloat32ColorAttachment(gl) {
    const testTexture = new Texture2D(gl, {
      format: 6408,
      type: 5126,
      dataFormat: 6408
    });
    const testFb = new Framebuffer(gl, {
      id: "test-framebuffer",
      check: false,
      attachments: {
        [36064]: testTexture
      }
    });
    const status = testFb.getStatus();
    testTexture.delete();
    testFb.delete();
    return status === 36053;
  }
  var webgl_features_table_default = {
    [FEATURES.WEBGL2]: [false, true],
    [FEATURES.VERTEX_ARRAY_OBJECT]: ["OES_vertex_array_object", true],
    [FEATURES.TIMER_QUERY]: ["EXT_disjoint_timer_query", "EXT_disjoint_timer_query_webgl2"],
    [FEATURES.INSTANCED_RENDERING]: ["ANGLE_instanced_arrays", true],
    [FEATURES.MULTIPLE_RENDER_TARGETS]: ["WEBGL_draw_buffers", true],
    [FEATURES.ELEMENT_INDEX_UINT32]: ["OES_element_index_uint", true],
    [FEATURES.BLEND_EQUATION_MINMAX]: ["EXT_blend_minmax", true],
    [FEATURES.FLOAT_BLEND]: ["EXT_float_blend"],
    [FEATURES.COLOR_ENCODING_SRGB]: ["EXT_sRGB", true],
    [FEATURES.TEXTURE_DEPTH]: ["WEBGL_depth_texture", true],
    [FEATURES.TEXTURE_FLOAT]: ["OES_texture_float", true],
    [FEATURES.TEXTURE_HALF_FLOAT]: ["OES_texture_half_float", true],
    [FEATURES.TEXTURE_FILTER_LINEAR_FLOAT]: ["OES_texture_float_linear"],
    [FEATURES.TEXTURE_FILTER_LINEAR_HALF_FLOAT]: ["OES_texture_half_float_linear"],
    [FEATURES.TEXTURE_FILTER_ANISOTROPIC]: ["EXT_texture_filter_anisotropic"],
    [FEATURES.COLOR_ATTACHMENT_RGBA32F]: [checkFloat32ColorAttachment, "EXT_color_buffer_float"],
    [FEATURES.COLOR_ATTACHMENT_FLOAT]: [false, "EXT_color_buffer_float"],
    [FEATURES.COLOR_ATTACHMENT_HALF_FLOAT]: ["EXT_color_buffer_half_float"],
    [FEATURES.GLSL_FRAG_DATA]: ["WEBGL_draw_buffers", true],
    [FEATURES.GLSL_FRAG_DEPTH]: ["EXT_frag_depth", true],
    [FEATURES.GLSL_DERIVATIVES]: ["OES_standard_derivatives", true],
    [FEATURES.GLSL_TEXTURE_LOD]: ["EXT_shader_texture_lod", true]
  };

  // ../../node_modules/@luma.gl/webgl/dist/esm/features/features.js
  var LOG_UNSUPPORTED_FEATURE = 2;
  function hasFeature(gl, feature) {
    return hasFeatures(gl, feature);
  }
  function hasFeatures(gl, features) {
    features = Array.isArray(features) ? features : [features];
    return features.every((feature) => {
      return isFeatureSupported(gl, feature);
    });
  }
  function getFeatures(gl) {
    gl.luma = gl.luma || {};
    gl.luma.caps = gl.luma.caps || {};
    for (const cap in webgl_features_table_default) {
      if (gl.luma.caps[cap] === void 0) {
        gl.luma.caps[cap] = isFeatureSupported(gl, cap);
      }
    }
    return gl.luma.caps;
  }
  function isFeatureSupported(gl, cap) {
    gl.luma = gl.luma || {};
    gl.luma.caps = gl.luma.caps || {};
    if (gl.luma.caps[cap] === void 0) {
      gl.luma.caps[cap] = queryFeature(gl, cap);
    }
    if (!gl.luma.caps[cap]) {
      log.log(LOG_UNSUPPORTED_FEATURE, "Feature: ".concat(cap, " not supported"))();
    }
    return gl.luma.caps[cap];
  }
  function queryFeature(gl, cap) {
    const feature = webgl_features_table_default[cap];
    assert3(feature, cap);
    let isSupported;
    const featureDefinition = isWebGL2(gl) ? feature[1] || feature[0] : feature[0];
    if (typeof featureDefinition === "function") {
      isSupported = featureDefinition(gl);
    } else if (Array.isArray(featureDefinition)) {
      isSupported = true;
      for (const extension of featureDefinition) {
        isSupported = isSupported && Boolean(gl.getExtension(extension));
      }
    } else if (typeof featureDefinition === "string") {
      isSupported = Boolean(gl.getExtension(featureDefinition));
    } else if (typeof featureDefinition === "boolean") {
      isSupported = featureDefinition;
    } else {
      assert3(false);
    }
    return isSupported;
  }

  // ../../node_modules/@luma.gl/webgl/dist/esm/classes/framebuffer.js
  var ERR_MULTIPLE_RENDERTARGETS = "Multiple render targets not supported";
  var Framebuffer = class extends Resource {
    get [Symbol.toStringTag]() {
      return "Framebuffer";
    }
    static isSupported(gl) {
      let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      const {
        colorBufferFloat,
        colorBufferHalfFloat
      } = options;
      let supported = true;
      if (colorBufferFloat) {
        supported = Boolean(gl.getExtension("EXT_color_buffer_float") || gl.getExtension("WEBGL_color_buffer_float") || gl.getExtension("OES_texture_float"));
      }
      if (colorBufferHalfFloat) {
        supported = supported && Boolean(gl.getExtension("EXT_color_buffer_float") || gl.getExtension("EXT_color_buffer_half_float"));
      }
      return supported;
    }
    static getDefaultFramebuffer(gl) {
      gl.luma = gl.luma || {};
      gl.luma.defaultFramebuffer = gl.luma.defaultFramebuffer || new Framebuffer(gl, {
        id: "default-framebuffer",
        handle: null,
        attachments: {}
      });
      return gl.luma.defaultFramebuffer;
    }
    get MAX_COLOR_ATTACHMENTS() {
      const gl2 = assertWebGL2Context(this.gl);
      return gl2.getParameter(gl2.MAX_COLOR_ATTACHMENTS);
    }
    get MAX_DRAW_BUFFERS() {
      const gl2 = assertWebGL2Context(this.gl);
      return gl2.getParameter(gl2.MAX_DRAW_BUFFERS);
    }
    constructor(gl) {
      let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      super(gl, opts);
      this.width = null;
      this.height = null;
      this.attachments = {};
      this.readBuffer = 36064;
      this.drawBuffers = [36064];
      this.ownResources = [];
      this.initialize(opts);
      Object.seal(this);
    }
    get color() {
      return this.attachments[36064] || null;
    }
    get texture() {
      return this.attachments[36064] || null;
    }
    get depth() {
      return this.attachments[36096] || this.attachments[33306] || null;
    }
    get stencil() {
      return this.attachments[36128] || this.attachments[33306] || null;
    }
    initialize(_ref) {
      let {
        width = 1,
        height = 1,
        attachments = null,
        color = true,
        depth = true,
        stencil = false,
        check = true,
        readBuffer = void 0,
        drawBuffers = void 0
      } = _ref;
      assert3(width >= 0 && height >= 0, "Width and height need to be integers");
      this.width = width;
      this.height = height;
      if (attachments) {
        for (const attachment in attachments) {
          const target = attachments[attachment];
          const object = Array.isArray(target) ? target[0] : target;
          object.resize({
            width,
            height
          });
        }
      } else {
        attachments = this._createDefaultAttachments(color, depth, stencil, width, height);
      }
      this.update({
        clearAttachments: true,
        attachments,
        readBuffer,
        drawBuffers
      });
      if (attachments && check) {
        this.checkStatus();
      }
    }
    delete() {
      for (const resource of this.ownResources) {
        resource.delete();
      }
      super.delete();
      return this;
    }
    update(_ref2) {
      let {
        attachments = {},
        readBuffer,
        drawBuffers,
        clearAttachments = false,
        resizeAttachments = true
      } = _ref2;
      this.attach(attachments, {
        clearAttachments,
        resizeAttachments
      });
      const {
        gl
      } = this;
      const prevHandle = gl.bindFramebuffer(36160, this.handle);
      if (readBuffer) {
        this._setReadBuffer(readBuffer);
      }
      if (drawBuffers) {
        this._setDrawBuffers(drawBuffers);
      }
      gl.bindFramebuffer(36160, prevHandle || null);
      return this;
    }
    resize() {
      let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      let {
        width,
        height
      } = options;
      if (this.handle === null) {
        assert3(width === void 0 && height === void 0);
        this.width = this.gl.drawingBufferWidth;
        this.height = this.gl.drawingBufferHeight;
        return this;
      }
      if (width === void 0) {
        width = this.gl.drawingBufferWidth;
      }
      if (height === void 0) {
        height = this.gl.drawingBufferHeight;
      }
      if (width !== this.width && height !== this.height) {
        log.log(2, "Resizing framebuffer ".concat(this.id, " to ").concat(width, "x").concat(height))();
      }
      for (const attachmentPoint in this.attachments) {
        this.attachments[attachmentPoint].resize({
          width,
          height
        });
      }
      this.width = width;
      this.height = height;
      return this;
    }
    attach(attachments) {
      let {
        clearAttachments = false,
        resizeAttachments = true
      } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      const newAttachments = {};
      if (clearAttachments) {
        Object.keys(this.attachments).forEach((key) => {
          newAttachments[key] = null;
        });
      }
      Object.assign(newAttachments, attachments);
      const prevHandle = this.gl.bindFramebuffer(36160, this.handle);
      for (const key in newAttachments) {
        assert3(key !== void 0, "Misspelled framebuffer binding point?");
        const attachment = Number(key);
        const descriptor = newAttachments[attachment];
        let object = descriptor;
        if (!object) {
          this._unattach(attachment);
        } else if (object instanceof Renderbuffer) {
          this._attachRenderbuffer({
            attachment,
            renderbuffer: object
          });
        } else if (Array.isArray(descriptor)) {
          const [texture, layer = 0, level = 0] = descriptor;
          object = texture;
          this._attachTexture({
            attachment,
            texture,
            layer,
            level
          });
        } else {
          this._attachTexture({
            attachment,
            texture: object,
            layer: 0,
            level: 0
          });
        }
        if (resizeAttachments && object) {
          object.resize({
            width: this.width,
            height: this.height
          });
        }
      }
      this.gl.bindFramebuffer(36160, prevHandle || null);
      Object.assign(this.attachments, attachments);
      Object.keys(this.attachments).filter((key) => !this.attachments[key]).forEach((key) => {
        delete this.attachments[key];
      });
    }
    checkStatus() {
      const {
        gl
      } = this;
      const status = this.getStatus();
      if (status !== 36053) {
        throw new Error(_getFrameBufferStatus(status));
      }
      return this;
    }
    getStatus() {
      const {
        gl
      } = this;
      const prevHandle = gl.bindFramebuffer(36160, this.handle);
      const status = gl.checkFramebufferStatus(36160);
      gl.bindFramebuffer(36160, prevHandle || null);
      return status;
    }
    clear() {
      let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const {
        color,
        depth,
        stencil,
        drawBuffers = []
      } = options;
      const prevHandle = this.gl.bindFramebuffer(36160, this.handle);
      if (color || depth || stencil) {
        clear(this.gl, {
          color,
          depth,
          stencil
        });
      }
      drawBuffers.forEach((value, drawBuffer) => {
        clearBuffer(this.gl, {
          drawBuffer,
          value
        });
      });
      this.gl.bindFramebuffer(36160, prevHandle || null);
      return this;
    }
    readPixels() {
      let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      log.error("Framebuffer.readPixels() is no logner supported, use readPixelsToArray(framebuffer)")();
      return null;
    }
    readPixelsToBuffer() {
      let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      log.error("Framebuffer.readPixelsToBuffer()is no logner supported, use readPixelsToBuffer(framebuffer)")();
      return null;
    }
    copyToDataUrl() {
      let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      log.error("Framebuffer.copyToDataUrl() is no logner supported, use copyToDataUrl(framebuffer)")();
      return null;
    }
    copyToImage() {
      let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      log.error("Framebuffer.copyToImage() is no logner supported, use copyToImage(framebuffer)")();
      return null;
    }
    copyToTexture() {
      let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      log.error("Framebuffer.copyToTexture({...}) is no logner supported, use copyToTexture(source, target, opts})")();
      return null;
    }
    blit() {
      let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      log.error("Framebuffer.blit({...}) is no logner supported, use blit(source, target, opts)")();
      return null;
    }
    invalidate(_ref3) {
      let {
        attachments = [],
        x = 0,
        y = 0,
        width,
        height
      } = _ref3;
      const gl2 = assertWebGL2Context(this.gl);
      const prevHandle = gl2.bindFramebuffer(36008, this.handle);
      const invalidateAll = x === 0 && y === 0 && width === void 0 && height === void 0;
      if (invalidateAll) {
        gl2.invalidateFramebuffer(36008, attachments);
      } else {
        gl2.invalidateFramebuffer(36008, attachments, x, y, width, height);
      }
      gl2.bindFramebuffer(36008, prevHandle);
      return this;
    }
    getAttachmentParameter(attachment, pname, keys) {
      let value = this._getAttachmentParameterFallback(pname);
      if (value === null) {
        this.gl.bindFramebuffer(36160, this.handle);
        value = this.gl.getFramebufferAttachmentParameter(36160, attachment, pname);
        this.gl.bindFramebuffer(36160, null);
      }
      if (keys && value > 1e3) {
        value = getKey(this.gl, value);
      }
      return value;
    }
    getAttachmentParameters() {
      let attachment = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 36064;
      let keys = arguments.length > 1 ? arguments[1] : void 0;
      let parameters = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.constructor.ATTACHMENT_PARAMETERS || [];
      const values = {};
      for (const pname of parameters) {
        const key = keys ? getKey(this.gl, pname) : pname;
        values[key] = this.getAttachmentParameter(attachment, pname, keys);
      }
      return values;
    }
    getParameters() {
      let keys = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
      const attachments = Object.keys(this.attachments);
      const parameters = {};
      for (const attachmentName of attachments) {
        const attachment = Number(attachmentName);
        const key = keys ? getKey(this.gl, attachment) : attachment;
        parameters[key] = this.getAttachmentParameters(attachment, keys);
      }
      return parameters;
    }
    show() {
      if (typeof window !== "undefined") {
        window.open(copyToDataUrl(this), "luma-debug-texture");
      }
      return this;
    }
    log() {
      let logLevel = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      let message = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
      if (logLevel > log.level || typeof window === "undefined") {
        return this;
      }
      message = message || "Framebuffer ".concat(this.id);
      const image = copyToDataUrl(this, {
        targetMaxHeight: 100
      });
      log.image({
        logLevel,
        message,
        image
      }, message)();
      return this;
    }
    bind() {
      let {
        target = 36160
      } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      this.gl.bindFramebuffer(target, this.handle);
      return this;
    }
    unbind() {
      let {
        target = 36160
      } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      this.gl.bindFramebuffer(target, null);
      return this;
    }
    _createDefaultAttachments(color, depth, stencil, width, height) {
      let defaultAttachments = null;
      if (color) {
        defaultAttachments = defaultAttachments || {};
        defaultAttachments[36064] = new Texture2D(this.gl, {
          id: "".concat(this.id, "-color0"),
          pixels: null,
          format: 6408,
          type: 5121,
          width,
          height,
          mipmaps: false,
          parameters: {
            [10241]: 9729,
            [10240]: 9729,
            [10242]: 33071,
            [10243]: 33071
          }
        });
        this.ownResources.push(defaultAttachments[36064]);
      }
      if (depth && stencil) {
        defaultAttachments = defaultAttachments || {};
        defaultAttachments[33306] = new Renderbuffer(this.gl, {
          id: "".concat(this.id, "-depth-stencil"),
          format: 35056,
          width,
          height: 111
        });
        this.ownResources.push(defaultAttachments[33306]);
      } else if (depth) {
        defaultAttachments = defaultAttachments || {};
        defaultAttachments[36096] = new Renderbuffer(this.gl, {
          id: "".concat(this.id, "-depth"),
          format: 33189,
          width,
          height
        });
        this.ownResources.push(defaultAttachments[36096]);
      } else if (stencil) {
        assert3(false);
      }
      return defaultAttachments;
    }
    _unattach(attachment) {
      const oldAttachment = this.attachments[attachment];
      if (!oldAttachment) {
        return;
      }
      if (oldAttachment instanceof Renderbuffer) {
        this.gl.framebufferRenderbuffer(36160, attachment, 36161, null);
      } else {
        this.gl.framebufferTexture2D(36160, attachment, 3553, null, 0);
      }
      delete this.attachments[attachment];
    }
    _attachRenderbuffer(_ref4) {
      let {
        attachment = 36064,
        renderbuffer
      } = _ref4;
      const {
        gl
      } = this;
      gl.framebufferRenderbuffer(36160, attachment, 36161, renderbuffer.handle);
      this.attachments[attachment] = renderbuffer;
    }
    _attachTexture(_ref5) {
      let {
        attachment = 36064,
        texture,
        layer,
        level
      } = _ref5;
      const {
        gl
      } = this;
      gl.bindTexture(texture.target, texture.handle);
      switch (texture.target) {
        case 35866:
        case 32879:
          const gl2 = assertWebGL2Context(gl);
          gl2.framebufferTextureLayer(36160, attachment, texture.target, level, layer);
          break;
        case 34067:
          const face = mapIndexToCubeMapFace(layer);
          gl.framebufferTexture2D(36160, attachment, face, texture.handle, level);
          break;
        case 3553:
          gl.framebufferTexture2D(36160, attachment, 3553, texture.handle, level);
          break;
        default:
          assert3(false, "Illegal texture type");
      }
      gl.bindTexture(texture.target, null);
      this.attachments[attachment] = texture;
    }
    _setReadBuffer(readBuffer) {
      const gl2 = getWebGL2Context(this.gl);
      if (gl2) {
        gl2.readBuffer(readBuffer);
      } else {
        assert3(readBuffer === 36064 || readBuffer === 1029, ERR_MULTIPLE_RENDERTARGETS);
      }
      this.readBuffer = readBuffer;
    }
    _setDrawBuffers(drawBuffers) {
      const {
        gl
      } = this;
      const gl2 = assertWebGL2Context(gl);
      if (gl2) {
        gl2.drawBuffers(drawBuffers);
      } else {
        const ext = gl.getExtension("WEBGL_draw_buffers");
        if (ext) {
          ext.drawBuffersWEBGL(drawBuffers);
        } else {
          assert3(drawBuffers.length === 1 && (drawBuffers[0] === 36064 || drawBuffers[0] === 1029), ERR_MULTIPLE_RENDERTARGETS);
        }
      }
      this.drawBuffers = drawBuffers;
    }
    _getAttachmentParameterFallback(pname) {
      const caps = getFeatures(this.gl);
      switch (pname) {
        case 36052:
          return !caps.WEBGL2 ? 0 : null;
        case 33298:
        case 33299:
        case 33300:
        case 33301:
        case 33302:
        case 33303:
          return !caps.WEBGL2 ? 8 : null;
        case 33297:
          return !caps.WEBGL2 ? 5125 : null;
        case 33296:
          return !caps.WEBGL2 && !caps.EXT_sRGB ? 9729 : null;
        default:
          return null;
      }
    }
    _createHandle() {
      return this.gl.createFramebuffer();
    }
    _deleteHandle() {
      this.gl.deleteFramebuffer(this.handle);
    }
    _bindHandle(handle) {
      return this.gl.bindFramebuffer(36160, handle);
    }
  };
  function mapIndexToCubeMapFace(layer) {
    return layer < 34069 ? layer + 34069 : layer;
  }
  function _getFrameBufferStatus(status) {
    const STATUS = Framebuffer.STATUS || {};
    return STATUS[status] || "Framebuffer error ".concat(status);
  }
  var FRAMEBUFFER_ATTACHMENT_PARAMETERS = [36049, 36048, 33296, 33298, 33299, 33300, 33301, 33302, 33303];
  Framebuffer.ATTACHMENT_PARAMETERS = FRAMEBUFFER_ATTACHMENT_PARAMETERS;

  // ../../node_modules/@luma.gl/webgl/dist/esm/webgl-utils/texture-utils.js
  function toFramebuffer(texture, opts) {
    const {
      gl,
      width,
      height,
      id
    } = texture;
    const framebuffer = new Framebuffer(gl, Object.assign({}, opts, {
      id: "framebuffer-for-".concat(id),
      width,
      height,
      attachments: {
        [36064]: texture
      }
    }));
    return framebuffer;
  }

  // ../../node_modules/@luma.gl/webgl/dist/esm/glsl-utils/get-shader-name.js
  function getShaderName(shader) {
    let defaultName = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "unnamed";
    const SHADER_NAME_REGEXP = /#define[\s*]SHADER_NAME[\s*]([A-Za-z0-9_-]+)[\s*]/;
    const match = shader.match(SHADER_NAME_REGEXP);
    return match ? match[1] : defaultName;
  }

  // ../../node_modules/@luma.gl/webgl/dist/esm/glsl-utils/get-shader-type-name.js
  var GL_FRAGMENT_SHADER = 35632;
  var GL_VERTEX_SHADER = 35633;
  function getShaderTypeName(type) {
    switch (type) {
      case GL_FRAGMENT_SHADER:
        return "fragment";
      case GL_VERTEX_SHADER:
        return "vertex";
      default:
        return "unknown type";
    }
  }

  // ../../node_modules/@luma.gl/webgl/dist/esm/glsl-utils/format-glsl-error.js
  function parseGLSLCompilerError(errLog, src, shaderType, shaderName) {
    const errorStrings = errLog.split(/\r?\n/);
    const errors = {};
    const warnings = {};
    const name10 = shaderName || getShaderName(src) || "(unnamed)";
    const shaderDescription = "".concat(getShaderTypeName(shaderType), " shader ").concat(name10);
    for (let i2 = 0; i2 < errorStrings.length; i2++) {
      const errorString = errorStrings[i2];
      if (errorString.length <= 1) {
        continue;
      }
      const segments = errorString.split(":");
      const type = segments[0];
      const line = parseInt(segments[2], 10);
      if (isNaN(line)) {
        throw new Error("GLSL compilation error in ".concat(shaderDescription, ": ").concat(errLog));
      }
      if (type !== "WARNING") {
        errors[line] = errorString;
      } else {
        warnings[line] = errorString;
      }
    }
    const lines = addLineNumbers(src);
    return {
      shaderName: shaderDescription,
      errors: formatErrors(errors, lines),
      warnings: formatErrors(warnings, lines)
    };
  }
  function formatErrors(errors, lines) {
    let message = "";
    for (let i2 = 0; i2 < lines.length; i2++) {
      const line = lines[i2];
      if (!errors[i2 + 3] && !errors[i2 + 2] && !errors[i2 + 1]) {
        continue;
      }
      message += "".concat(line, "\n");
      if (errors[i2 + 1]) {
        const error2 = errors[i2 + 1];
        const segments = error2.split(":", 3);
        const type = segments[0];
        const column = parseInt(segments[1], 10) || 0;
        const err = error2.substring(segments.join(":").length + 1).trim();
        message += padLeft("^^^ ".concat(type, ": ").concat(err, "\n\n"), column);
      }
    }
    return message;
  }
  function addLineNumbers(string) {
    let start = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
    let delim = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ": ";
    const lines = string.split(/\r?\n/);
    const maxDigits = String(lines.length + start - 1).length;
    return lines.map((line, i2) => {
      const lineNumber = String(i2 + start);
      const digits = lineNumber.length;
      const prefix = padLeft(lineNumber, maxDigits - digits);
      return prefix + delim + line;
    });
  }
  function padLeft(string, digits) {
    let result = "";
    for (let i2 = 0; i2 < digits; ++i2) {
      result += " ";
    }
    return "".concat(result).concat(string);
  }

  // ../../node_modules/@luma.gl/webgl/dist/esm/classes/shader.js
  var ERR_SOURCE = "Shader: GLSL source code must be a JavaScript string";
  var Shader = class extends Resource {
    get [Symbol.toStringTag]() {
      return "Shader";
    }
    static getTypeName(shaderType) {
      switch (shaderType) {
        case 35633:
          return "vertex-shader";
        case 35632:
          return "fragment-shader";
        default:
          assert3(false);
          return "unknown";
      }
    }
    constructor(gl, props) {
      assertWebGLContext(gl);
      assert3(typeof props.source === "string", ERR_SOURCE);
      const id = getShaderName(props.source, null) || props.id || uid("unnamed ".concat(Shader.getTypeName(props.shaderType)));
      super(gl, {
        id
      });
      this.shaderType = props.shaderType;
      this.source = props.source;
      this.initialize(props);
    }
    initialize(_ref) {
      let {
        source
      } = _ref;
      const shaderName = getShaderName(source, null);
      if (shaderName) {
        this.id = uid(shaderName);
      }
      this._compile(source);
    }
    getParameter(pname) {
      return this.gl.getShaderParameter(this.handle, pname);
    }
    toString() {
      return "".concat(Shader.getTypeName(this.shaderType), ":").concat(this.id);
    }
    getName() {
      return getShaderName(this.source) || "unnamed-shader";
    }
    getSource() {
      return this.gl.getShaderSource(this.handle);
    }
    getTranslatedSource() {
      const extension = this.gl.getExtension("WEBGL_debug_shaders");
      return extension ? extension.getTranslatedShaderSource(this.handle) : "No translated source available. WEBGL_debug_shaders not implemented";
    }
    _compile() {
      let source = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.source;
      if (!source.startsWith("#version ")) {
        source = "#version 100\n".concat(source);
      }
      this.source = source;
      this.gl.shaderSource(this.handle, this.source);
      this.gl.compileShader(this.handle);
      const compileStatus = this.getParameter(35713);
      if (!compileStatus) {
        const infoLog = this.gl.getShaderInfoLog(this.handle);
        const {
          shaderName,
          errors,
          warnings
        } = parseGLSLCompilerError(infoLog, this.source, this.shaderType, this.id);
        log.error("GLSL compilation errors in ".concat(shaderName, "\n").concat(errors))();
        log.warn("GLSL compilation warnings in ".concat(shaderName, "\n").concat(warnings))();
        throw new Error("GLSL compilation errors in ".concat(shaderName));
      }
    }
    _deleteHandle() {
      this.gl.deleteShader(this.handle);
    }
    _getOptsFromHandle() {
      return {
        type: this.getParameter(35663),
        source: this.getSource()
      };
    }
  };
  var VertexShader = class extends Shader {
    get [Symbol.toStringTag]() {
      return "VertexShader";
    }
    constructor(gl, props) {
      if (typeof props === "string") {
        props = {
          source: props
        };
      }
      super(gl, Object.assign({}, props, {
        shaderType: 35633
      }));
    }
    _createHandle() {
      return this.gl.createShader(35633);
    }
  };
  var FragmentShader = class extends Shader {
    get [Symbol.toStringTag]() {
      return "FragmentShader";
    }
    constructor(gl, props) {
      if (typeof props === "string") {
        props = {
          source: props
        };
      }
      super(gl, Object.assign({}, props, {
        shaderType: 35632
      }));
    }
    _createHandle() {
      return this.gl.createShader(35632);
    }
  };

  // ../../node_modules/@luma.gl/webgl/dist/esm/classes/uniforms.js
  var UNIFORM_SETTERS = {
    [5126]: getArraySetter.bind(null, "uniform1fv", toFloatArray, 1, setVectorUniform),
    [35664]: getArraySetter.bind(null, "uniform2fv", toFloatArray, 2, setVectorUniform),
    [35665]: getArraySetter.bind(null, "uniform3fv", toFloatArray, 3, setVectorUniform),
    [35666]: getArraySetter.bind(null, "uniform4fv", toFloatArray, 4, setVectorUniform),
    [5124]: getArraySetter.bind(null, "uniform1iv", toIntArray, 1, setVectorUniform),
    [35667]: getArraySetter.bind(null, "uniform2iv", toIntArray, 2, setVectorUniform),
    [35668]: getArraySetter.bind(null, "uniform3iv", toIntArray, 3, setVectorUniform),
    [35669]: getArraySetter.bind(null, "uniform4iv", toIntArray, 4, setVectorUniform),
    [35670]: getArraySetter.bind(null, "uniform1iv", toIntArray, 1, setVectorUniform),
    [35671]: getArraySetter.bind(null, "uniform2iv", toIntArray, 2, setVectorUniform),
    [35672]: getArraySetter.bind(null, "uniform3iv", toIntArray, 3, setVectorUniform),
    [35673]: getArraySetter.bind(null, "uniform4iv", toIntArray, 4, setVectorUniform),
    [35674]: getArraySetter.bind(null, "uniformMatrix2fv", toFloatArray, 4, setMatrixUniform),
    [35675]: getArraySetter.bind(null, "uniformMatrix3fv", toFloatArray, 9, setMatrixUniform),
    [35676]: getArraySetter.bind(null, "uniformMatrix4fv", toFloatArray, 16, setMatrixUniform),
    [35678]: getSamplerSetter,
    [35680]: getSamplerSetter,
    [5125]: getArraySetter.bind(null, "uniform1uiv", toUIntArray, 1, setVectorUniform),
    [36294]: getArraySetter.bind(null, "uniform2uiv", toUIntArray, 2, setVectorUniform),
    [36295]: getArraySetter.bind(null, "uniform3uiv", toUIntArray, 3, setVectorUniform),
    [36296]: getArraySetter.bind(null, "uniform4uiv", toUIntArray, 4, setVectorUniform),
    [35685]: getArraySetter.bind(null, "uniformMatrix2x3fv", toFloatArray, 6, setMatrixUniform),
    [35686]: getArraySetter.bind(null, "uniformMatrix2x4fv", toFloatArray, 8, setMatrixUniform),
    [35687]: getArraySetter.bind(null, "uniformMatrix3x2fv", toFloatArray, 6, setMatrixUniform),
    [35688]: getArraySetter.bind(null, "uniformMatrix3x4fv", toFloatArray, 12, setMatrixUniform),
    [35689]: getArraySetter.bind(null, "uniformMatrix4x2fv", toFloatArray, 8, setMatrixUniform),
    [35690]: getArraySetter.bind(null, "uniformMatrix4x3fv", toFloatArray, 12, setMatrixUniform),
    [35678]: getSamplerSetter,
    [35680]: getSamplerSetter,
    [35679]: getSamplerSetter,
    [35682]: getSamplerSetter,
    [36289]: getSamplerSetter,
    [36292]: getSamplerSetter,
    [36293]: getSamplerSetter,
    [36298]: getSamplerSetter,
    [36299]: getSamplerSetter,
    [36300]: getSamplerSetter,
    [36303]: getSamplerSetter,
    [36306]: getSamplerSetter,
    [36307]: getSamplerSetter,
    [36308]: getSamplerSetter,
    [36311]: getSamplerSetter
  };
  var FLOAT_ARRAY = {};
  var INT_ARRAY = {};
  var UINT_ARRAY = {};
  var array1 = [0];
  function toTypedArray(value, uniformLength, Type2, cache2) {
    if (uniformLength === 1 && typeof value === "boolean") {
      value = value ? 1 : 0;
    }
    if (Number.isFinite(value)) {
      array1[0] = value;
      value = array1;
    }
    const length4 = value.length;
    if (length4 % uniformLength) {
      log.warn("Uniform size should be multiples of ".concat(uniformLength), value)();
    }
    if (value instanceof Type2) {
      return value;
    }
    let result = cache2[length4];
    if (!result) {
      result = new Type2(length4);
      cache2[length4] = result;
    }
    for (let i2 = 0; i2 < length4; i2++) {
      result[i2] = value[i2];
    }
    return result;
  }
  function toFloatArray(value, uniformLength) {
    return toTypedArray(value, uniformLength, Float32Array, FLOAT_ARRAY);
  }
  function toIntArray(value, uniformLength) {
    return toTypedArray(value, uniformLength, Int32Array, INT_ARRAY);
  }
  function toUIntArray(value, uniformLength) {
    return toTypedArray(value, uniformLength, Uint32Array, UINT_ARRAY);
  }
  function getUniformSetter(gl, location, info) {
    const setter = UNIFORM_SETTERS[info.type];
    if (!setter) {
      throw new Error("Unknown GLSL uniform type ".concat(info.type));
    }
    return setter().bind(null, gl, location);
  }
  function parseUniformName(name10) {
    if (name10[name10.length - 1] !== "]") {
      return {
        name: name10,
        length: 1,
        isArray: false
      };
    }
    const UNIFORM_NAME_REGEXP = /([^[]*)(\[[0-9]+\])?/;
    const matches3 = name10.match(UNIFORM_NAME_REGEXP);
    if (!matches3 || matches3.length < 2) {
      throw new Error("Failed to parse GLSL uniform name ".concat(name10));
    }
    return {
      name: matches3[1],
      length: matches3[2] || 1,
      isArray: Boolean(matches3[2])
    };
  }
  function checkUniformValues(uniforms, source, uniformMap) {
    for (const uniformName in uniforms) {
      const value = uniforms[uniformName];
      const shouldCheck = !uniformMap || Boolean(uniformMap[uniformName]);
      if (shouldCheck && !checkUniformValue(value)) {
        source = source ? "".concat(source, " ") : "";
        console.error("".concat(source, " Bad uniform ").concat(uniformName), value);
        throw new Error("".concat(source, " Bad uniform ").concat(uniformName));
      }
    }
    return true;
  }
  function checkUniformValue(value) {
    if (Array.isArray(value) || ArrayBuffer.isView(value)) {
      return checkUniformArray(value);
    }
    if (isFinite(value)) {
      return true;
    } else if (value === true || value === false) {
      return true;
    } else if (value instanceof Texture) {
      return true;
    } else if (value instanceof Renderbuffer) {
      return true;
    } else if (value instanceof Framebuffer) {
      return Boolean(value.texture);
    }
    return false;
  }
  function copyUniform(uniforms, key, value) {
    if (Array.isArray(value) || ArrayBuffer.isView(value)) {
      if (uniforms[key]) {
        const dest = uniforms[key];
        for (let i2 = 0, len2 = value.length; i2 < len2; ++i2) {
          dest[i2] = value[i2];
        }
      } else {
        uniforms[key] = value.slice();
      }
    } else {
      uniforms[key] = value;
    }
  }
  function checkUniformArray(value) {
    if (value.length === 0) {
      return false;
    }
    const checkLength = Math.min(value.length, 16);
    for (let i2 = 0; i2 < checkLength; ++i2) {
      if (!Number.isFinite(value[i2])) {
        return false;
      }
    }
    return true;
  }
  function getSamplerSetter() {
    let cache2 = null;
    return (gl, location, value) => {
      const update = cache2 !== value;
      if (update) {
        gl.uniform1i(location, value);
        cache2 = value;
      }
      return update;
    };
  }
  function getArraySetter(functionName, toArray, size, uniformSetter) {
    let cache2 = null;
    let cacheLength = null;
    return (gl, location, value) => {
      const arrayValue = toArray(value, size);
      const length4 = arrayValue.length;
      let update = false;
      if (cache2 === null) {
        cache2 = new Float32Array(length4);
        cacheLength = length4;
        update = true;
      } else {
        assert3(cacheLength === length4, "Uniform length cannot change.");
        for (let i2 = 0; i2 < length4; ++i2) {
          if (arrayValue[i2] !== cache2[i2]) {
            update = true;
            break;
          }
        }
      }
      if (update) {
        uniformSetter(gl, functionName, location, arrayValue);
        cache2.set(arrayValue);
      }
      return update;
    };
  }
  function setVectorUniform(gl, functionName, location, value) {
    gl[functionName](location, value);
  }
  function setMatrixUniform(gl, functionName, location, value) {
    gl[functionName](location, false, value);
  }

  // ../../node_modules/@luma.gl/webgl/dist/esm/webgl-utils/attribute-utils.js
  var GL_BYTE = 5120;
  var GL_UNSIGNED_BYTE = 5121;
  var GL_SHORT = 5122;
  var GL_UNSIGNED_SHORT = 5123;
  var GL_POINTS = 0;
  var GL_LINES = 1;
  var GL_LINE_LOOP = 2;
  var GL_LINE_STRIP = 3;
  var GL_TRIANGLES = 4;
  var GL_TRIANGLE_STRIP = 5;
  var GL_TRIANGLE_FAN = 6;
  var GL_FLOAT = 5126;
  var GL_FLOAT_VEC2 = 35664;
  var GL_FLOAT_VEC3 = 35665;
  var GL_FLOAT_VEC4 = 35666;
  var GL_INT = 5124;
  var GL_INT_VEC2 = 35667;
  var GL_INT_VEC3 = 35668;
  var GL_INT_VEC4 = 35669;
  var GL_UNSIGNED_INT = 5125;
  var GL_UNSIGNED_INT_VEC2 = 36294;
  var GL_UNSIGNED_INT_VEC3 = 36295;
  var GL_UNSIGNED_INT_VEC4 = 36296;
  var GL_BOOL = 35670;
  var GL_BOOL_VEC2 = 35671;
  var GL_BOOL_VEC3 = 35672;
  var GL_BOOL_VEC4 = 35673;
  var GL_FLOAT_MAT2 = 35674;
  var GL_FLOAT_MAT3 = 35675;
  var GL_FLOAT_MAT4 = 35676;
  var GL_FLOAT_MAT2x3 = 35685;
  var GL_FLOAT_MAT2x4 = 35686;
  var GL_FLOAT_MAT3x2 = 35687;
  var GL_FLOAT_MAT3x4 = 35688;
  var GL_FLOAT_MAT4x2 = 35689;
  var GL_FLOAT_MAT4x3 = 35690;
  var COMPOSITE_GL_TYPES = {
    [GL_FLOAT]: [GL_FLOAT, 1, "float"],
    [GL_FLOAT_VEC2]: [GL_FLOAT, 2, "vec2"],
    [GL_FLOAT_VEC3]: [GL_FLOAT, 3, "vec3"],
    [GL_FLOAT_VEC4]: [GL_FLOAT, 4, "vec4"],
    [GL_INT]: [GL_INT, 1, "int"],
    [GL_INT_VEC2]: [GL_INT, 2, "ivec2"],
    [GL_INT_VEC3]: [GL_INT, 3, "ivec3"],
    [GL_INT_VEC4]: [GL_INT, 4, "ivec4"],
    [GL_UNSIGNED_INT]: [GL_UNSIGNED_INT, 1, "uint"],
    [GL_UNSIGNED_INT_VEC2]: [GL_UNSIGNED_INT, 2, "uvec2"],
    [GL_UNSIGNED_INT_VEC3]: [GL_UNSIGNED_INT, 3, "uvec3"],
    [GL_UNSIGNED_INT_VEC4]: [GL_UNSIGNED_INT, 4, "uvec4"],
    [GL_BOOL]: [GL_FLOAT, 1, "bool"],
    [GL_BOOL_VEC2]: [GL_FLOAT, 2, "bvec2"],
    [GL_BOOL_VEC3]: [GL_FLOAT, 3, "bvec3"],
    [GL_BOOL_VEC4]: [GL_FLOAT, 4, "bvec4"],
    [GL_FLOAT_MAT2]: [GL_FLOAT, 8, "mat2"],
    [GL_FLOAT_MAT2x3]: [GL_FLOAT, 8, "mat2x3"],
    [GL_FLOAT_MAT2x4]: [GL_FLOAT, 8, "mat2x4"],
    [GL_FLOAT_MAT3]: [GL_FLOAT, 12, "mat3"],
    [GL_FLOAT_MAT3x2]: [GL_FLOAT, 12, "mat3x2"],
    [GL_FLOAT_MAT3x4]: [GL_FLOAT, 12, "mat3x4"],
    [GL_FLOAT_MAT4]: [GL_FLOAT, 16, "mat4"],
    [GL_FLOAT_MAT4x2]: [GL_FLOAT, 16, "mat4x2"],
    [GL_FLOAT_MAT4x3]: [GL_FLOAT, 16, "mat4x3"]
  };
  function getPrimitiveDrawMode(drawMode) {
    switch (drawMode) {
      case GL_POINTS:
        return GL_POINTS;
      case GL_LINES:
        return GL_LINES;
      case GL_LINE_STRIP:
        return GL_LINES;
      case GL_LINE_LOOP:
        return GL_LINES;
      case GL_TRIANGLES:
        return GL_TRIANGLES;
      case GL_TRIANGLE_STRIP:
        return GL_TRIANGLES;
      case GL_TRIANGLE_FAN:
        return GL_TRIANGLES;
      default:
        assert3(false);
        return 0;
    }
  }
  function decomposeCompositeGLType(compositeGLType) {
    const typeAndSize = COMPOSITE_GL_TYPES[compositeGLType];
    if (!typeAndSize) {
      return null;
    }
    const [type, components] = typeAndSize;
    return {
      type,
      components
    };
  }
  function getCompositeGLType(type, components) {
    switch (type) {
      case GL_BYTE:
      case GL_UNSIGNED_BYTE:
      case GL_SHORT:
      case GL_UNSIGNED_SHORT:
        type = GL_FLOAT;
        break;
      default:
    }
    for (const glType in COMPOSITE_GL_TYPES) {
      const [compType, compComponents, name10] = COMPOSITE_GL_TYPES[glType];
      if (compType === type && compComponents === components) {
        return {
          glType,
          name: name10
        };
      }
    }
    return null;
  }

  // ../../node_modules/@luma.gl/webgl/dist/esm/classes/program-configuration.js
  var ProgramConfiguration = class {
    constructor(program) {
      this.id = program.id;
      this.attributeInfos = [];
      this.attributeInfosByName = {};
      this.attributeInfosByLocation = [];
      this.varyingInfos = [];
      this.varyingInfosByName = {};
      Object.seal(this);
      this._readAttributesFromProgram(program);
      this._readVaryingsFromProgram(program);
    }
    getAttributeInfo(locationOrName) {
      const location = Number(locationOrName);
      if (Number.isFinite(location)) {
        return this.attributeInfosByLocation[location];
      }
      return this.attributeInfosByName[locationOrName] || null;
    }
    getAttributeLocation(locationOrName) {
      const attributeInfo = this.getAttributeInfo(locationOrName);
      return attributeInfo ? attributeInfo.location : -1;
    }
    getAttributeAccessor(locationOrName) {
      const attributeInfo = this.getAttributeInfo(locationOrName);
      return attributeInfo ? attributeInfo.accessor : null;
    }
    getVaryingInfo(locationOrName) {
      const location = Number(locationOrName);
      if (Number.isFinite(location)) {
        return this.varyingInfos[location];
      }
      return this.varyingInfosByName[locationOrName] || null;
    }
    getVaryingIndex(locationOrName) {
      const varying = this.getVaryingInfo();
      return varying ? varying.location : -1;
    }
    getVaryingAccessor(locationOrName) {
      const varying = this.getVaryingInfo();
      return varying ? varying.accessor : null;
    }
    _readAttributesFromProgram(program) {
      const {
        gl
      } = program;
      const count = gl.getProgramParameter(program.handle, 35721);
      for (let index = 0; index < count; index++) {
        const {
          name: name10,
          type,
          size
        } = gl.getActiveAttrib(program.handle, index);
        const location = gl.getAttribLocation(program.handle, name10);
        if (location >= 0) {
          this._addAttribute(location, name10, type, size);
        }
      }
      this.attributeInfos.sort((a2, b) => a2.location - b.location);
    }
    _readVaryingsFromProgram(program) {
      const {
        gl
      } = program;
      if (!isWebGL2(gl)) {
        return;
      }
      const count = gl.getProgramParameter(program.handle, 35971);
      for (let location = 0; location < count; location++) {
        const {
          name: name10,
          type,
          size
        } = gl.getTransformFeedbackVarying(program.handle, location);
        this._addVarying(location, name10, type, size);
      }
      this.varyingInfos.sort((a2, b) => a2.location - b.location);
    }
    _addAttribute(location, name10, compositeType, size) {
      const {
        type,
        components
      } = decomposeCompositeGLType(compositeType);
      const accessor = {
        type,
        size: size * components
      };
      this._inferProperties(location, name10, accessor);
      const attributeInfo = {
        location,
        name: name10,
        accessor: new Accessor(accessor)
      };
      this.attributeInfos.push(attributeInfo);
      this.attributeInfosByLocation[location] = attributeInfo;
      this.attributeInfosByName[attributeInfo.name] = attributeInfo;
    }
    _inferProperties(location, name10, accessor) {
      if (/instance/i.test(name10)) {
        accessor.divisor = 1;
      }
    }
    _addVarying(location, name10, compositeType, size) {
      const {
        type,
        components
      } = decomposeCompositeGLType(compositeType);
      const accessor = new Accessor({
        type,
        size: size * components
      });
      const varying = {
        location,
        name: name10,
        accessor
      };
      this.varyingInfos.push(varying);
      this.varyingInfosByName[varying.name] = varying;
    }
  };

  // ../../node_modules/@luma.gl/webgl/dist/esm/classes/program.js
  var LOG_PROGRAM_PERF_PRIORITY = 4;
  var GL_SEPARATE_ATTRIBS = 35981;
  var V6_DEPRECATED_METHODS = ["setVertexArray", "setAttributes", "setBuffers", "unsetBuffers", "use", "getUniformCount", "getUniformInfo", "getUniformLocation", "getUniformValue", "getVarying", "getFragDataLocation", "getAttachedShaders", "getAttributeCount", "getAttributeLocation", "getAttributeInfo"];
  var Program = class extends Resource {
    get [Symbol.toStringTag]() {
      return "Program";
    }
    constructor(gl) {
      let props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      super(gl, props);
      this.stubRemovedMethods("Program", "v6.0", V6_DEPRECATED_METHODS);
      this._isCached = false;
      this.initialize(props);
      Object.seal(this);
      this._setId(props.id);
    }
    initialize() {
      let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const {
        hash,
        vs: vs2,
        fs: fs2,
        varyings,
        bufferMode = GL_SEPARATE_ATTRIBS
      } = props;
      this.hash = hash || "";
      this.vs = typeof vs2 === "string" ? new VertexShader(this.gl, {
        id: "".concat(props.id, "-vs"),
        source: vs2
      }) : vs2;
      this.fs = typeof fs2 === "string" ? new FragmentShader(this.gl, {
        id: "".concat(props.id, "-fs"),
        source: fs2
      }) : fs2;
      assert3(this.vs instanceof VertexShader);
      assert3(this.fs instanceof FragmentShader);
      this.uniforms = {};
      this._textureUniforms = {};
      if (varyings && varyings.length > 0) {
        assertWebGL2Context(this.gl);
        this.varyings = varyings;
        this.gl2.transformFeedbackVaryings(this.handle, varyings, bufferMode);
      }
      this._compileAndLink();
      this._readUniformLocationsFromLinkedProgram();
      this.configuration = new ProgramConfiguration(this);
      return this.setProps(props);
    }
    delete() {
      let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      if (this._isCached) {
        return this;
      }
      return super.delete(options);
    }
    setProps(props) {
      if ("uniforms" in props) {
        this.setUniforms(props.uniforms);
      }
      return this;
    }
    draw(_ref) {
      let {
        logPriority,
        drawMode = 4,
        vertexCount,
        offset = 0,
        start,
        end,
        isIndexed = false,
        indexType = 5123,
        instanceCount = 0,
        isInstanced = instanceCount > 0,
        vertexArray = null,
        transformFeedback,
        framebuffer,
        parameters = {},
        uniforms,
        samplers
      } = _ref;
      if (uniforms || samplers) {
        log.deprecated("Program.draw({uniforms})", "Program.setUniforms(uniforms)")();
        this.setUniforms(uniforms || {});
      }
      if (log.priority >= logPriority) {
        const fb = framebuffer ? framebuffer.id : "default";
        const message = "mode=".concat(getKey(this.gl, drawMode), " verts=").concat(vertexCount, " ") + "instances=".concat(instanceCount, " indexType=").concat(getKey(this.gl, indexType), " ") + "isInstanced=".concat(isInstanced, " isIndexed=").concat(isIndexed, " ") + "Framebuffer=".concat(fb);
        log.log(logPriority, message)();
      }
      assert3(vertexArray);
      this.gl.useProgram(this.handle);
      if (!this._areTexturesRenderable() || vertexCount === 0 || isInstanced && instanceCount === 0) {
        return false;
      }
      vertexArray.bindForDraw(vertexCount, instanceCount, () => {
        if (framebuffer !== void 0) {
          parameters = Object.assign({}, parameters, {
            framebuffer
          });
        }
        if (transformFeedback) {
          const primitiveMode = getPrimitiveDrawMode(drawMode);
          transformFeedback.begin(primitiveMode);
        }
        this._bindTextures();
        withParameters(this.gl, parameters, () => {
          if (isIndexed && isInstanced) {
            this.gl2.drawElementsInstanced(drawMode, vertexCount, indexType, offset, instanceCount);
          } else if (isIndexed && isWebGL2(this.gl) && !isNaN(start) && !isNaN(end)) {
            this.gl2.drawRangeElements(drawMode, start, end, vertexCount, indexType, offset);
          } else if (isIndexed) {
            this.gl.drawElements(drawMode, vertexCount, indexType, offset);
          } else if (isInstanced) {
            this.gl2.drawArraysInstanced(drawMode, offset, vertexCount, instanceCount);
          } else {
            this.gl.drawArrays(drawMode, offset, vertexCount);
          }
        });
        if (transformFeedback) {
          transformFeedback.end();
        }
      });
      return true;
    }
    setUniforms() {
      let uniforms = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      if (log.priority >= 2) {
        checkUniformValues(uniforms, this.id, this._uniformSetters);
      }
      this.gl.useProgram(this.handle);
      for (const uniformName in uniforms) {
        const uniform = uniforms[uniformName];
        const uniformSetter = this._uniformSetters[uniformName];
        if (uniformSetter) {
          let value = uniform;
          let textureUpdate = false;
          if (value instanceof Framebuffer) {
            value = value.texture;
          }
          if (value instanceof Texture) {
            textureUpdate = this.uniforms[uniformName] !== uniform;
            if (textureUpdate) {
              if (uniformSetter.textureIndex === void 0) {
                uniformSetter.textureIndex = this._textureIndexCounter++;
              }
              const texture = value;
              const {
                textureIndex
              } = uniformSetter;
              texture.bind(textureIndex);
              value = textureIndex;
              this._textureUniforms[uniformName] = texture;
            } else {
              value = uniformSetter.textureIndex;
            }
          } else if (this._textureUniforms[uniformName]) {
            delete this._textureUniforms[uniformName];
          }
          if (uniformSetter(value) || textureUpdate) {
            copyUniform(this.uniforms, uniformName, uniform);
          }
        }
      }
      return this;
    }
    _areTexturesRenderable() {
      let texturesRenderable = true;
      for (const uniformName in this._textureUniforms) {
        const texture = this._textureUniforms[uniformName];
        texture.update();
        texturesRenderable = texturesRenderable && texture.loaded;
      }
      return texturesRenderable;
    }
    _bindTextures() {
      for (const uniformName in this._textureUniforms) {
        const textureIndex = this._uniformSetters[uniformName].textureIndex;
        this._textureUniforms[uniformName].bind(textureIndex);
      }
    }
    _createHandle() {
      return this.gl.createProgram();
    }
    _deleteHandle() {
      this.gl.deleteProgram(this.handle);
    }
    _getOptionsFromHandle(handle) {
      const shaderHandles = this.gl.getAttachedShaders(handle);
      const opts = {};
      for (const shaderHandle of shaderHandles) {
        const type = this.gl.getShaderParameter(this.handle, 35663);
        switch (type) {
          case 35633:
            opts.vs = new VertexShader({
              handle: shaderHandle
            });
            break;
          case 35632:
            opts.fs = new FragmentShader({
              handle: shaderHandle
            });
            break;
          default:
        }
      }
      return opts;
    }
    _getParameter(pname) {
      return this.gl.getProgramParameter(this.handle, pname);
    }
    _setId(id) {
      if (!id) {
        const programName = this._getName();
        this.id = uid(programName);
      }
    }
    _getName() {
      let programName = this.vs.getName() || this.fs.getName();
      programName = programName.replace(/shader/i, "");
      programName = programName ? "".concat(programName, "-program") : "program";
      return programName;
    }
    _compileAndLink() {
      const {
        gl
      } = this;
      gl.attachShader(this.handle, this.vs.handle);
      gl.attachShader(this.handle, this.fs.handle);
      log.time(LOG_PROGRAM_PERF_PRIORITY, "linkProgram for ".concat(this._getName()))();
      gl.linkProgram(this.handle);
      log.timeEnd(LOG_PROGRAM_PERF_PRIORITY, "linkProgram for ".concat(this._getName()))();
      if (gl.debug || log.level > 0) {
        const linked = gl.getProgramParameter(this.handle, 35714);
        if (!linked) {
          throw new Error("Error linking: ".concat(gl.getProgramInfoLog(this.handle)));
        }
        gl.validateProgram(this.handle);
        const validated = gl.getProgramParameter(this.handle, 35715);
        if (!validated) {
          throw new Error("Error validating: ".concat(gl.getProgramInfoLog(this.handle)));
        }
      }
    }
    _readUniformLocationsFromLinkedProgram() {
      const {
        gl
      } = this;
      this._uniformSetters = {};
      this._uniformCount = this._getParameter(35718);
      for (let i2 = 0; i2 < this._uniformCount; i2++) {
        const info = this.gl.getActiveUniform(this.handle, i2);
        const {
          name: name10
        } = parseUniformName(info.name);
        let location = gl.getUniformLocation(this.handle, name10);
        this._uniformSetters[name10] = getUniformSetter(gl, location, info);
        if (info.size > 1) {
          for (let l2 = 0; l2 < info.size; l2++) {
            location = gl.getUniformLocation(this.handle, "".concat(name10, "[").concat(l2, "]"));
            this._uniformSetters["".concat(name10, "[").concat(l2, "]")] = getUniformSetter(gl, location, info);
          }
        }
      }
      this._textureIndexCounter = 0;
    }
    getActiveUniforms(uniformIndices, pname) {
      return this.gl2.getActiveUniforms(this.handle, uniformIndices, pname);
    }
    getUniformBlockIndex(blockName) {
      return this.gl2.getUniformBlockIndex(this.handle, blockName);
    }
    getActiveUniformBlockParameter(blockIndex, pname) {
      return this.gl2.getActiveUniformBlockParameter(this.handle, blockIndex, pname);
    }
    uniformBlockBinding(blockIndex, blockBinding) {
      this.gl2.uniformBlockBinding(this.handle, blockIndex, blockBinding);
    }
  };

  // ../../node_modules/@luma.gl/webgl/dist/esm/classes/transform-feedback.js
  var TransformFeedback = class extends Resource {
    get [Symbol.toStringTag]() {
      return "TransformFeedback";
    }
    static isSupported(gl) {
      return isWebGL2(gl);
    }
    constructor(gl) {
      let props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      assertWebGL2Context(gl);
      super(gl, props);
      this.initialize(props);
      this.stubRemovedMethods("TransformFeedback", "v6.0", ["pause", "resume"]);
      Object.seal(this);
    }
    initialize() {
      let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      this.buffers = {};
      this.unused = {};
      this.configuration = null;
      this.bindOnUse = true;
      if (!isObjectEmpty2(this.buffers)) {
        this.bind(() => this._unbindBuffers());
      }
      this.setProps(props);
      return this;
    }
    setProps(props) {
      if ("program" in props) {
        this.configuration = props.program && props.program.configuration;
      }
      if ("configuration" in props) {
        this.configuration = props.configuration;
      }
      if ("bindOnUse" in props) {
        props = props.bindOnUse;
      }
      if ("buffers" in props) {
        this.setBuffers(props.buffers);
      }
    }
    setBuffers() {
      let buffers = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      this.bind(() => {
        for (const bufferName in buffers) {
          this.setBuffer(bufferName, buffers[bufferName]);
        }
      });
      return this;
    }
    setBuffer(locationOrName, bufferOrParams) {
      const location = this._getVaryingIndex(locationOrName);
      const {
        buffer,
        byteSize,
        byteOffset
      } = this._getBufferParams(bufferOrParams);
      if (location < 0) {
        this.unused[locationOrName] = buffer;
        log.warn("".concat(this.id, " unused varying buffer ").concat(locationOrName))();
        return this;
      }
      this.buffers[location] = bufferOrParams;
      if (!this.bindOnUse) {
        this._bindBuffer(location, buffer, byteOffset, byteSize);
      }
      return this;
    }
    begin() {
      let primitiveMode = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      this.gl.bindTransformFeedback(36386, this.handle);
      this._bindBuffers();
      this.gl.beginTransformFeedback(primitiveMode);
      return this;
    }
    end() {
      this.gl.endTransformFeedback();
      this._unbindBuffers();
      this.gl.bindTransformFeedback(36386, null);
      return this;
    }
    _getBufferParams(bufferOrParams) {
      let byteOffset;
      let byteSize;
      let buffer;
      if (bufferOrParams instanceof Buffer2 === false) {
        buffer = bufferOrParams.buffer;
        byteSize = bufferOrParams.byteSize;
        byteOffset = bufferOrParams.byteOffset;
      } else {
        buffer = bufferOrParams;
      }
      if (byteOffset !== void 0 || byteSize !== void 0) {
        byteOffset = byteOffset || 0;
        byteSize = byteSize || buffer.byteLength - byteOffset;
      }
      return {
        buffer,
        byteOffset,
        byteSize
      };
    }
    _getVaryingInfo(locationOrName) {
      return this.configuration && this.configuration.getVaryingInfo(locationOrName);
    }
    _getVaryingIndex(locationOrName) {
      if (this.configuration) {
        return this.configuration.getVaryingInfo(locationOrName).location;
      }
      const location = Number(locationOrName);
      return Number.isFinite(location) ? location : -1;
    }
    _bindBuffers() {
      if (this.bindOnUse) {
        for (const bufferIndex in this.buffers) {
          const {
            buffer,
            byteSize,
            byteOffset
          } = this._getBufferParams(this.buffers[bufferIndex]);
          this._bindBuffer(bufferIndex, buffer, byteOffset, byteSize);
        }
      }
    }
    _unbindBuffers() {
      if (this.bindOnUse) {
        for (const bufferIndex in this.buffers) {
          this._bindBuffer(bufferIndex, null);
        }
      }
    }
    _bindBuffer(index, buffer) {
      let byteOffset = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
      let byteSize = arguments.length > 3 ? arguments[3] : void 0;
      const handle = buffer && buffer.handle;
      if (!handle || byteSize === void 0) {
        this.gl.bindBufferBase(35982, index, handle);
      } else {
        this.gl.bindBufferRange(35982, index, handle, byteOffset, byteSize);
      }
      return this;
    }
    _createHandle() {
      return this.gl.createTransformFeedback();
    }
    _deleteHandle() {
      this.gl.deleteTransformFeedback(this.handle);
    }
    _bindHandle(handle) {
      this.gl.bindTransformFeedback(36386, this.handle);
    }
  };

  // ../../node_modules/@luma.gl/webgl/dist/esm/utils/array-utils-flat.js
  var arrayBuffer = null;
  function getScratchArrayBuffer(byteLength) {
    if (!arrayBuffer || arrayBuffer.byteLength < byteLength) {
      arrayBuffer = new ArrayBuffer(byteLength);
    }
    return arrayBuffer;
  }
  function getScratchArray(Type2, length4) {
    const scratchArrayBuffer = getScratchArrayBuffer(Type2.BYTES_PER_ELEMENT * length4);
    return new Type2(scratchArrayBuffer, 0, length4);
  }
  function fillArray(_ref) {
    let {
      target,
      source,
      start = 0,
      count = 1
    } = _ref;
    const length4 = source.length;
    const total = count * length4;
    let copied = 0;
    for (let i2 = start; copied < length4; copied++) {
      target[i2++] = source[copied];
    }
    while (copied < total) {
      if (copied < total - copied) {
        target.copyWithin(start + copied, start, start + copied);
        copied *= 2;
      } else {
        target.copyWithin(start + copied, start, start + total - copied);
        copied = total;
      }
    }
    return target;
  }

  // ../../node_modules/@luma.gl/webgl/dist/esm/classes/vertex-array-object.js
  var ERR_ELEMENTS = "elements must be GL.ELEMENT_ARRAY_BUFFER";
  var VertexArrayObject = class extends Resource {
    get [Symbol.toStringTag]() {
      return "VertexArrayObject";
    }
    static isSupported(gl) {
      let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (options.constantAttributeZero) {
        return isWebGL2(gl) || getBrowser() === "Chrome";
      }
      return true;
    }
    static getDefaultArray(gl) {
      gl.luma = gl.luma || {};
      if (!gl.luma.defaultVertexArray) {
        gl.luma.defaultVertexArray = new VertexArrayObject(gl, {
          handle: null,
          isDefaultArray: true
        });
      }
      return gl.luma.defaultVertexArray;
    }
    static getMaxAttributes(gl) {
      VertexArrayObject.MAX_ATTRIBUTES = VertexArrayObject.MAX_ATTRIBUTES || gl.getParameter(34921);
      return VertexArrayObject.MAX_ATTRIBUTES;
    }
    static setConstant(gl, location, array) {
      switch (array.constructor) {
        case Float32Array:
          VertexArrayObject._setConstantFloatArray(gl, location, array);
          break;
        case Int32Array:
          VertexArrayObject._setConstantIntArray(gl, location, array);
          break;
        case Uint32Array:
          VertexArrayObject._setConstantUintArray(gl, location, array);
          break;
        default:
          assert3(false);
      }
    }
    constructor(gl) {
      let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      const id = opts.id || opts.program && opts.program.id;
      super(gl, Object.assign({}, opts, {
        id
      }));
      this.buffer = null;
      this.bufferValue = null;
      this.isDefaultArray = opts.isDefaultArray || false;
      this.gl2 = gl;
      this.initialize(opts);
      Object.seal(this);
    }
    delete() {
      super.delete();
      if (this.buffer) {
        this.buffer.delete();
      }
      return this;
    }
    get MAX_ATTRIBUTES() {
      return VertexArrayObject.getMaxAttributes(this.gl);
    }
    initialize() {
      let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      return this.setProps(props);
    }
    setProps(props) {
      return this;
    }
    setElementBuffer() {
      let elementBuffer = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
      let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      assert3(!elementBuffer || elementBuffer.target === 34963, ERR_ELEMENTS);
      this.bind(() => {
        this.gl.bindBuffer(34963, elementBuffer ? elementBuffer.handle : null);
      });
      return this;
    }
    setBuffer(location, buffer, accessor) {
      if (buffer.target === 34963) {
        return this.setElementBuffer(buffer, accessor);
      }
      const {
        size,
        type,
        stride,
        offset,
        normalized,
        integer,
        divisor
      } = accessor;
      const {
        gl,
        gl2
      } = this;
      location = Number(location);
      this.bind(() => {
        gl.bindBuffer(34962, buffer.handle);
        if (integer) {
          assert3(isWebGL2(gl));
          gl2.vertexAttribIPointer(location, size, type, stride, offset);
        } else {
          gl.vertexAttribPointer(location, size, type, normalized, stride, offset);
        }
        gl.enableVertexAttribArray(location);
        gl2.vertexAttribDivisor(location, divisor || 0);
      });
      return this;
    }
    enable(location) {
      let enable2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      const disablingAttributeZero = !enable2 && location === 0 && !VertexArrayObject.isSupported(this.gl, {
        constantAttributeZero: true
      });
      if (!disablingAttributeZero) {
        location = Number(location);
        this.bind(() => enable2 ? this.gl.enableVertexAttribArray(location) : this.gl.disableVertexAttribArray(location));
      }
      return this;
    }
    getConstantBuffer(elementCount, value) {
      const constantValue = this._normalizeConstantArrayValue(value);
      const byteLength = constantValue.byteLength * elementCount;
      const length4 = constantValue.length * elementCount;
      let updateNeeded = !this.buffer;
      this.buffer = this.buffer || new Buffer2(this.gl, byteLength);
      updateNeeded = updateNeeded || this.buffer.reallocate(byteLength);
      updateNeeded = updateNeeded || !this._compareConstantArrayValues(constantValue, this.bufferValue);
      if (updateNeeded) {
        const typedArray = getScratchArray(value.constructor, length4);
        fillArray({
          target: typedArray,
          source: constantValue,
          start: 0,
          count: length4
        });
        this.buffer.subData(typedArray);
        this.bufferValue = value;
      }
      return this.buffer;
    }
    _normalizeConstantArrayValue(arrayValue) {
      if (Array.isArray(arrayValue)) {
        return new Float32Array(arrayValue);
      }
      return arrayValue;
    }
    _compareConstantArrayValues(v1, v2) {
      if (!v1 || !v2 || v1.length !== v2.length || v1.constructor !== v2.constructor) {
        return false;
      }
      for (let i2 = 0; i2 < v1.length; ++i2) {
        if (v1[i2] !== v2[i2]) {
          return false;
        }
      }
      return true;
    }
    static _setConstantFloatArray(gl, location, array) {
      switch (array.length) {
        case 1:
          gl.vertexAttrib1fv(location, array);
          break;
        case 2:
          gl.vertexAttrib2fv(location, array);
          break;
        case 3:
          gl.vertexAttrib3fv(location, array);
          break;
        case 4:
          gl.vertexAttrib4fv(location, array);
          break;
        default:
          assert3(false);
      }
    }
    static _setConstantIntArray(gl, location, array) {
      assert3(isWebGL2(gl));
      switch (array.length) {
        case 1:
          gl.vertexAttribI1iv(location, array);
          break;
        case 2:
          gl.vertexAttribI2iv(location, array);
          break;
        case 3:
          gl.vertexAttribI3iv(location, array);
          break;
        case 4:
          gl.vertexAttribI4iv(location, array);
          break;
        default:
          assert3(false);
      }
    }
    static _setConstantUintArray(gl, location, array) {
      assert3(isWebGL2(gl));
      switch (array.length) {
        case 1:
          gl.vertexAttribI1uiv(location, array);
          break;
        case 2:
          gl.vertexAttribI2uiv(location, array);
          break;
        case 3:
          gl.vertexAttribI3uiv(location, array);
          break;
        case 4:
          gl.vertexAttribI4uiv(location, array);
          break;
        default:
          assert3(false);
      }
    }
    _createHandle() {
      const gl2 = this.gl;
      return gl2.createVertexArray();
    }
    _deleteHandle(handle) {
      this.gl2.deleteVertexArray(handle);
      return [this.elements];
    }
    _bindHandle(handle) {
      this.gl2.bindVertexArray(handle);
    }
    _getParameter(pname, _ref) {
      let {
        location
      } = _ref;
      assert3(Number.isFinite(location));
      return this.bind(() => {
        switch (pname) {
          case 34373:
            return this.gl.getVertexAttribOffset(location, pname);
          default:
            return this.gl.getVertexAttrib(location, pname);
        }
      });
    }
  };

  // ../../node_modules/@luma.gl/webgl/dist/esm/classes/vertex-array.js
  var ERR_ATTRIBUTE_TYPE = "VertexArray: attributes must be Buffers or constants (i.e. typed array)";
  var MULTI_LOCATION_ATTRIBUTE_REGEXP = /^(.+)__LOCATION_([0-9]+)$/;
  var DEPRECATIONS_V6 = ["setBuffers", "setGeneric", "clearBindings", "setLocations", "setGenericValues", "setDivisor", "enable", "disable"];
  var VertexArray = class {
    constructor(gl) {
      let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      const id = opts.id || opts.program && opts.program.id;
      this.id = id;
      this.gl = gl;
      this.configuration = null;
      this.elements = null;
      this.elementsAccessor = null;
      this.values = null;
      this.accessors = null;
      this.unused = null;
      this.drawParams = null;
      this.buffer = null;
      this.attributes = {};
      this.vertexArrayObject = new VertexArrayObject(gl);
      stubRemovedMethods(this, "VertexArray", "v6.0", DEPRECATIONS_V6);
      this.initialize(opts);
      Object.seal(this);
    }
    delete() {
      if (this.buffer) {
        this.buffer.delete();
      }
      this.vertexArrayObject.delete();
    }
    initialize() {
      let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      this.reset();
      this.configuration = null;
      this.bindOnUse = false;
      return this.setProps(props);
    }
    reset() {
      this.elements = null;
      this.elementsAccessor = null;
      const {
        MAX_ATTRIBUTES
      } = this.vertexArrayObject;
      this.values = new Array(MAX_ATTRIBUTES).fill(null);
      this.accessors = new Array(MAX_ATTRIBUTES).fill(null);
      this.unused = {};
      this.drawParams = null;
      return this;
    }
    setProps(props) {
      if ("program" in props) {
        this.configuration = props.program && props.program.configuration;
      }
      if ("configuration" in props) {
        this.configuration = props.configuration;
      }
      if ("attributes" in props) {
        this.setAttributes(props.attributes);
      }
      if ("elements" in props) {
        this.setElementBuffer(props.elements);
      }
      if ("bindOnUse" in props) {
        props = props.bindOnUse;
      }
      return this;
    }
    clearDrawParams() {
      this.drawParams = null;
    }
    getDrawParams() {
      this.drawParams = this.drawParams || this._updateDrawParams();
      return this.drawParams;
    }
    setAttributes(attributes) {
      Object.assign(this.attributes, attributes);
      this.vertexArrayObject.bind(() => {
        for (const locationOrName in attributes) {
          const value = attributes[locationOrName];
          this._setAttribute(locationOrName, value);
        }
        this.gl.bindBuffer(34962, null);
      });
      return this;
    }
    setElementBuffer() {
      let elementBuffer = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
      let accessor = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      this.elements = elementBuffer;
      this.elementsAccessor = accessor;
      this.clearDrawParams();
      this.vertexArrayObject.setElementBuffer(elementBuffer, accessor);
      return this;
    }
    setBuffer(locationOrName, buffer) {
      let appAccessor = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      if (buffer.target === 34963) {
        return this.setElementBuffer(buffer, appAccessor);
      }
      const {
        location,
        accessor
      } = this._resolveLocationAndAccessor(locationOrName, buffer, buffer.accessor, appAccessor);
      if (location >= 0) {
        this.values[location] = buffer;
        this.accessors[location] = accessor;
        this.clearDrawParams();
        this.vertexArrayObject.setBuffer(location, buffer, accessor);
      }
      return this;
    }
    setConstant(locationOrName, arrayValue) {
      let appAccessor = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      const {
        location,
        accessor
      } = this._resolveLocationAndAccessor(locationOrName, arrayValue, Object.assign({
        size: arrayValue.length
      }, appAccessor));
      if (location >= 0) {
        arrayValue = this.vertexArrayObject._normalizeConstantArrayValue(arrayValue);
        this.values[location] = arrayValue;
        this.accessors[location] = accessor;
        this.clearDrawParams();
        this.vertexArrayObject.enable(location, false);
      }
      return this;
    }
    unbindBuffers() {
      this.vertexArrayObject.bind(() => {
        if (this.elements) {
          this.vertexArrayObject.setElementBuffer(null);
        }
        this.buffer = this.buffer || new Buffer2(this.gl, {
          accessor: {
            size: 4
          }
        });
        for (let location = 0; location < this.vertexArrayObject.MAX_ATTRIBUTES; location++) {
          if (this.values[location] instanceof Buffer2) {
            this.gl.disableVertexAttribArray(location);
            this.gl.bindBuffer(34962, this.buffer.handle);
            this.gl.vertexAttribPointer(location, 1, 5126, false, 0, 0);
          }
        }
      });
      return this;
    }
    bindBuffers() {
      this.vertexArrayObject.bind(() => {
        if (this.elements) {
          this.setElementBuffer(this.elements);
        }
        for (let location = 0; location < this.vertexArrayObject.MAX_ATTRIBUTES; location++) {
          const buffer = this.values[location];
          if (buffer instanceof Buffer2) {
            this.setBuffer(location, buffer);
          }
        }
      });
      return this;
    }
    bindForDraw(vertexCount, instanceCount, func) {
      let value;
      this.vertexArrayObject.bind(() => {
        this._setConstantAttributes(vertexCount, instanceCount);
        value = func();
      });
      return value;
    }
    _resolveLocationAndAccessor(locationOrName, value, valueAccessor, appAccessor) {
      const INVALID_RESULT = {
        location: -1,
        accessor: null
      };
      const {
        location,
        name: name10
      } = this._getAttributeIndex(locationOrName);
      if (!Number.isFinite(location) || location < 0) {
        this.unused[locationOrName] = value;
        log.once(3, () => "unused value ".concat(locationOrName, " in ").concat(this.id))();
        return INVALID_RESULT;
      }
      const accessInfo = this._getAttributeInfo(name10 || location);
      if (!accessInfo) {
        return INVALID_RESULT;
      }
      const currentAccessor = this.accessors[location] || {};
      const accessor = Accessor.resolve(accessInfo.accessor, currentAccessor, valueAccessor, appAccessor);
      const {
        size,
        type
      } = accessor;
      assert3(Number.isFinite(size) && Number.isFinite(type));
      return {
        location,
        accessor
      };
    }
    _getAttributeInfo(attributeName) {
      return this.configuration && this.configuration.getAttributeInfo(attributeName);
    }
    _getAttributeIndex(locationOrName) {
      const location = Number(locationOrName);
      if (Number.isFinite(location)) {
        return {
          location
        };
      }
      const multiLocation = MULTI_LOCATION_ATTRIBUTE_REGEXP.exec(locationOrName);
      const name10 = multiLocation ? multiLocation[1] : locationOrName;
      const locationOffset = multiLocation ? Number(multiLocation[2]) : 0;
      if (this.configuration) {
        return {
          location: this.configuration.getAttributeLocation(name10) + locationOffset,
          name: name10
        };
      }
      return {
        location: -1
      };
    }
    _setAttribute(locationOrName, value) {
      if (value instanceof Buffer2) {
        this.setBuffer(locationOrName, value);
      } else if (Array.isArray(value) && value.length && value[0] instanceof Buffer2) {
        const buffer = value[0];
        const accessor = value[1];
        this.setBuffer(locationOrName, buffer, accessor);
      } else if (ArrayBuffer.isView(value) || Array.isArray(value)) {
        const constant = value;
        this.setConstant(locationOrName, constant);
      } else if (value.buffer instanceof Buffer2) {
        const accessor = value;
        this.setBuffer(locationOrName, accessor.buffer, accessor);
      } else {
        throw new Error(ERR_ATTRIBUTE_TYPE);
      }
    }
    _setConstantAttributes(vertexCount, instanceCount) {
      const elementCount = Math.max(vertexCount | 0, instanceCount | 0);
      let constant = this.values[0];
      if (ArrayBuffer.isView(constant)) {
        this._setConstantAttributeZero(constant, elementCount);
      }
      for (let location = 1; location < this.vertexArrayObject.MAX_ATTRIBUTES; location++) {
        constant = this.values[location];
        if (ArrayBuffer.isView(constant)) {
          this._setConstantAttribute(location, constant);
        }
      }
    }
    _setConstantAttributeZero(constant, elementCount) {
      if (VertexArrayObject.isSupported(this.gl, {
        constantAttributeZero: true
      })) {
        this._setConstantAttribute(0, constant);
        return;
      }
      const buffer = this.vertexArrayObject.getConstantBuffer(elementCount, constant);
      this.vertexArrayObject.setBuffer(0, buffer, this.accessors[0]);
    }
    _setConstantAttribute(location, constant) {
      VertexArrayObject.setConstant(this.gl, location, constant);
    }
    _updateDrawParams() {
      const drawParams = {
        isIndexed: false,
        isInstanced: false,
        indexCount: Infinity,
        vertexCount: Infinity,
        instanceCount: Infinity
      };
      for (let location = 0; location < this.vertexArrayObject.MAX_ATTRIBUTES; location++) {
        this._updateDrawParamsForLocation(drawParams, location);
      }
      if (this.elements) {
        drawParams.elementCount = this.elements.getElementCount(this.elements.accessor);
        drawParams.isIndexed = true;
        drawParams.indexType = this.elementsAccessor.type || this.elements.accessor.type;
        drawParams.indexOffset = this.elementsAccessor.offset || 0;
      }
      if (drawParams.indexCount === Infinity) {
        drawParams.indexCount = 0;
      }
      if (drawParams.vertexCount === Infinity) {
        drawParams.vertexCount = 0;
      }
      if (drawParams.instanceCount === Infinity) {
        drawParams.instanceCount = 0;
      }
      return drawParams;
    }
    _updateDrawParamsForLocation(drawParams, location) {
      const value = this.values[location];
      const accessor = this.accessors[location];
      if (!value) {
        return;
      }
      const {
        divisor
      } = accessor;
      const isInstanced = divisor > 0;
      drawParams.isInstanced = drawParams.isInstanced || isInstanced;
      if (value instanceof Buffer2) {
        const buffer = value;
        if (isInstanced) {
          const instanceCount = buffer.getVertexCount(accessor);
          drawParams.instanceCount = Math.min(drawParams.instanceCount, instanceCount);
        } else {
          const vertexCount = buffer.getVertexCount(accessor);
          drawParams.vertexCount = Math.min(drawParams.vertexCount, vertexCount);
        }
      }
    }
    setElements() {
      let elementBuffer = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
      let accessor = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      log.deprecated("setElements", "setElementBuffer")();
      return this.setElementBuffer(elementBuffer, accessor);
    }
  };

  // ../../node_modules/@luma.gl/webgl/dist/esm/utils/format-value.js
  function formatArrayValue(v, opts) {
    const {
      maxElts = 16,
      size = 1
    } = opts;
    let string = "[";
    for (let i2 = 0; i2 < v.length && i2 < maxElts; ++i2) {
      if (i2 > 0) {
        string += ",".concat(i2 % size === 0 ? " " : "");
      }
      string += formatValue(v[i2], opts);
    }
    const terminator = v.length > maxElts ? "..." : "]";
    return "".concat(string).concat(terminator);
  }
  function formatValue(v) {
    let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const EPSILON2 = 1e-16;
    const {
      isInteger = false
    } = opts;
    if (Array.isArray(v) || ArrayBuffer.isView(v)) {
      return formatArrayValue(v, opts);
    }
    if (!Number.isFinite(v)) {
      return String(v);
    }
    if (Math.abs(v) < EPSILON2) {
      return isInteger ? "0" : "0.";
    }
    if (isInteger) {
      return v.toFixed(0);
    }
    if (Math.abs(v) > 100 && Math.abs(v) < 1e4) {
      return v.toFixed(0);
    }
    const string = v.toPrecision(2);
    const decimal = string.indexOf(".0");
    return decimal === string.length - 2 ? string.slice(0, -1) : string;
  }

  // ../../node_modules/@luma.gl/webgl/dist/esm/debug/debug-uniforms.js
  function getDebugTableForUniforms(_ref) {
    let {
      header = "Uniforms",
      program,
      uniforms,
      undefinedOnly = false
    } = _ref;
    assert3(program);
    const SHADER_MODULE_UNIFORM_REGEXP = ".*_.*";
    const PROJECT_MODULE_UNIFORM_REGEXP = ".*Matrix";
    const uniformLocations = program._uniformSetters;
    const table = {};
    const uniformNames = Object.keys(uniformLocations).sort();
    let count = 0;
    for (const uniformName of uniformNames) {
      if (!uniformName.match(SHADER_MODULE_UNIFORM_REGEXP) && !uniformName.match(PROJECT_MODULE_UNIFORM_REGEXP)) {
        if (addUniformToTable({
          table,
          header,
          uniforms,
          uniformName,
          undefinedOnly
        })) {
          count++;
        }
      }
    }
    for (const uniformName of uniformNames) {
      if (uniformName.match(PROJECT_MODULE_UNIFORM_REGEXP)) {
        if (addUniformToTable({
          table,
          header,
          uniforms,
          uniformName,
          undefinedOnly
        })) {
          count++;
        }
      }
    }
    for (const uniformName of uniformNames) {
      if (!table[uniformName]) {
        if (addUniformToTable({
          table,
          header,
          uniforms,
          uniformName,
          undefinedOnly
        })) {
          count++;
        }
      }
    }
    let unusedCount = 0;
    const unusedTable = {};
    if (!undefinedOnly) {
      for (const uniformName in uniforms) {
        const uniform = uniforms[uniformName];
        if (!table[uniformName]) {
          unusedCount++;
          unusedTable[uniformName] = {
            Type: "NOT USED: ".concat(uniform),
            [header]: formatValue(uniform)
          };
        }
      }
    }
    return {
      table,
      count,
      unusedTable,
      unusedCount
    };
  }
  function addUniformToTable(_ref2) {
    let {
      table,
      header,
      uniforms,
      uniformName,
      undefinedOnly
    } = _ref2;
    const value = uniforms[uniformName];
    const isDefined = isUniformDefined(value);
    if (!undefinedOnly || !isDefined) {
      table[uniformName] = {
        [header]: isDefined ? formatValue(value) : "N/A",
        "Uniform Type": isDefined ? value : "NOT PROVIDED"
      };
      return true;
    }
    return false;
  }
  function isUniformDefined(value) {
    return value !== void 0 && value !== null;
  }

  // ../../node_modules/@luma.gl/webgl/dist/esm/debug/debug-vertex-array.js
  function getDebugTableForVertexArray(_ref) {
    let {
      vertexArray,
      header = "Attributes"
    } = _ref;
    if (!vertexArray.configuration) {
      return {};
    }
    const table = {};
    if (vertexArray.elements) {
      table.ELEMENT_ARRAY_BUFFER = getDebugTableRow(vertexArray, vertexArray.elements, null, header);
    }
    const attributes = vertexArray.values;
    for (const attributeLocation in attributes) {
      const info = vertexArray._getAttributeInfo(attributeLocation);
      if (info) {
        let rowHeader = "".concat(attributeLocation, ": ").concat(info.name);
        const accessor = vertexArray.accessors[info.location];
        if (accessor) {
          rowHeader = "".concat(attributeLocation, ": ").concat(getGLSLDeclaration(info.name, accessor));
        }
        table[rowHeader] = getDebugTableRow(vertexArray, attributes[attributeLocation], accessor, header);
      }
    }
    return table;
  }
  function getDebugTableRow(vertexArray, attribute, accessor, header) {
    const {
      gl
    } = vertexArray;
    if (!attribute) {
      return {
        [header]: "null",
        "Format ": "N/A"
      };
    }
    let type = "NOT PROVIDED";
    let size = 1;
    let verts = 0;
    let bytes = 0;
    let isInteger;
    let marker;
    let value;
    if (accessor) {
      type = accessor.type;
      size = accessor.size;
      type = String(type).replace("Array", "");
      isInteger = type.indexOf("nt") !== -1;
    }
    if (attribute instanceof Buffer2) {
      const buffer = attribute;
      const {
        data,
        changed
      } = buffer.getDebugData();
      marker = changed ? "*" : "";
      value = data;
      bytes = buffer.byteLength;
      verts = bytes / data.BYTES_PER_ELEMENT / size;
      let format;
      if (accessor) {
        const instanced = accessor.divisor > 0;
        format = "".concat(instanced ? "I " : "P ", " ").concat(verts, " (x").concat(size, "=").concat(bytes, " bytes ").concat(getKey(gl, type), ")");
      } else {
        isInteger = true;
        format = "".concat(bytes, " bytes");
      }
      return {
        [header]: "".concat(marker).concat(formatValue(value, {
          size,
          isInteger
        })),
        "Format ": format
      };
    }
    value = attribute;
    size = attribute.length;
    type = String(attribute.constructor.name).replace("Array", "");
    isInteger = type.indexOf("nt") !== -1;
    return {
      [header]: "".concat(formatValue(value, {
        size,
        isInteger
      }), " (constant)"),
      "Format ": "".concat(size, "x").concat(type, " (constant)")
    };
  }
  function getGLSLDeclaration(name10, accessor) {
    const {
      type,
      size
    } = accessor;
    const typeAndName = getCompositeGLType(type, size);
    return typeAndName ? "".concat(name10, " (").concat(typeAndName.name, ")") : name10;
  }

  // ../../node_modules/@luma.gl/webgl/dist/esm/debug/debug-program-configuration.js
  function getDebugTableForProgramConfiguration(config2) {
    const table = {};
    const header = "Accessors for ".concat(config2.id);
    for (const attributeInfo of config2.attributeInfos) {
      if (attributeInfo) {
        const glslDeclaration = getGLSLDeclaration2(attributeInfo);
        table["in ".concat(glslDeclaration)] = {
          [header]: JSON.stringify(attributeInfo.accessor)
        };
      }
    }
    for (const varyingInfo of config2.varyingInfos) {
      if (varyingInfo) {
        const glslDeclaration = getGLSLDeclaration2(varyingInfo);
        table["out ".concat(glslDeclaration)] = {
          [header]: JSON.stringify(varyingInfo.accessor)
        };
      }
    }
    return table;
  }
  function getGLSLDeclaration2(attributeInfo) {
    const {
      type,
      size
    } = attributeInfo.accessor;
    const typeAndName = getCompositeGLType(type, size);
    if (typeAndName) {
      return "".concat(typeAndName.name, " ").concat(attributeInfo.name);
    }
    return attributeInfo.name;
  }

  // src/utils/matrix.ts
  var import_core2 = __toESM(require_core());
  var RADIAN_PER_DEGREE = Math.PI / 180;
  var modelMatrix = new Float32Array(16);
  var valueArray = new Float32Array(12);
  function calculateTransformMatrix(targetMatrix, orientation, scale5) {
    const pitch = orientation[0] * RADIAN_PER_DEGREE;
    const yaw = orientation[1] * RADIAN_PER_DEGREE;
    const roll = orientation[2] * RADIAN_PER_DEGREE;
    const sr = Math.sin(roll);
    const sp = Math.sin(pitch);
    const sw = Math.sin(yaw);
    const cr = Math.cos(roll);
    const cp = Math.cos(pitch);
    const cw = Math.cos(yaw);
    const scx = scale5[0];
    const scy = scale5[1];
    const scz = scale5[2];
    targetMatrix[0] = scx * cw * cp;
    targetMatrix[1] = scx * sw * cp;
    targetMatrix[2] = scx * -sp;
    targetMatrix[3] = scy * (-sw * cr + cw * sp * sr);
    targetMatrix[4] = scy * (cw * cr + sw * sp * sr);
    targetMatrix[5] = scy * cp * sr;
    targetMatrix[6] = scz * (sw * sr + cw * sp * cr);
    targetMatrix[7] = scz * (-cw * sr + sw * sp * cr);
    targetMatrix[8] = scz * cp * cr;
  }
  function getExtendedMat3FromMat4(mat4) {
    mat4[0] = mat4[0];
    mat4[1] = mat4[1];
    mat4[2] = mat4[2];
    mat4[3] = mat4[4];
    mat4[4] = mat4[5];
    mat4[5] = mat4[6];
    mat4[6] = mat4[8];
    mat4[7] = mat4[9];
    mat4[8] = mat4[10];
    mat4[9] = mat4[12];
    mat4[10] = mat4[13];
    mat4[11] = mat4[14];
    return mat4.subarray(0, 12);
  }
  var MATRIX_ATTRIBUTES = {
    size: 12,
    accessor: ["getOrientation", "getScale", "getTranslation", "getTransformMatrix"],
    shaderAttributes: {
      instanceModelMatrix__LOCATION_0: {
        size: 3,
        elementOffset: 0
      },
      instanceModelMatrix__LOCATION_1: {
        size: 3,
        elementOffset: 3
      },
      instanceModelMatrix__LOCATION_2: {
        size: 3,
        elementOffset: 6
      },
      instanceTranslation: {
        size: 3,
        elementOffset: 9
      }
    },
    update(attribute, {
      startRow,
      endRow
    }) {
      const {
        data,
        getOrientation,
        getScale,
        getTranslation,
        getTransformMatrix
      } = this.props;
      const arrayMatrix = Array.isArray(getTransformMatrix);
      const constantMatrix = arrayMatrix && getTransformMatrix.length === 16;
      const constantScale = Array.isArray(getScale);
      const constantOrientation = Array.isArray(getOrientation);
      const constantTranslation = Array.isArray(getTranslation);
      const hasMatrix = constantMatrix || !arrayMatrix && Boolean(getTransformMatrix(data[0]));
      if (hasMatrix) {
        attribute.constant = constantMatrix;
      } else {
        attribute.constant = constantOrientation && constantScale && constantTranslation;
      }
      const instanceModelMatrixData = attribute.value;
      if (attribute.constant) {
        let matrix;
        if (hasMatrix) {
          modelMatrix.set(getTransformMatrix);
          matrix = getExtendedMat3FromMat4(modelMatrix);
        } else {
          matrix = valueArray;
          const orientation = getOrientation;
          const scale5 = getScale;
          calculateTransformMatrix(matrix, orientation, scale5);
          matrix.set(getTranslation, 9);
        }
        attribute.value = new Float32Array(matrix);
      } else {
        let i2 = startRow * attribute.size;
        const {
          iterable,
          objectInfo
        } = (0, import_core2.createIterable)(data, startRow, endRow);
        for (const object of iterable) {
          objectInfo.index++;
          let matrix;
          if (hasMatrix) {
            modelMatrix.set(constantMatrix ? getTransformMatrix : getTransformMatrix(object, objectInfo));
            matrix = getExtendedMat3FromMat4(modelMatrix);
          } else {
            matrix = valueArray;
            const orientation = constantOrientation ? getOrientation : getOrientation(object, objectInfo);
            const scale5 = constantScale ? getScale : getScale(object, objectInfo);
            calculateTransformMatrix(matrix, orientation, scale5);
            matrix.set(constantTranslation ? getTranslation : getTranslation(object, objectInfo), 9);
          }
          instanceModelMatrixData[i2++] = matrix[0];
          instanceModelMatrixData[i2++] = matrix[1];
          instanceModelMatrixData[i2++] = matrix[2];
          instanceModelMatrixData[i2++] = matrix[3];
          instanceModelMatrixData[i2++] = matrix[4];
          instanceModelMatrixData[i2++] = matrix[5];
          instanceModelMatrixData[i2++] = matrix[6];
          instanceModelMatrixData[i2++] = matrix[7];
          instanceModelMatrixData[i2++] = matrix[8];
          instanceModelMatrixData[i2++] = matrix[9];
          instanceModelMatrixData[i2++] = matrix[10];
          instanceModelMatrixData[i2++] = matrix[11];
        }
      }
    }
  };
  function shouldComposeModelMatrix(viewport, coordinateSystem) {
    return coordinateSystem === import_core2.COORDINATE_SYSTEM.CARTESIAN || coordinateSystem === import_core2.COORDINATE_SYSTEM.METER_OFFSETS || coordinateSystem === import_core2.COORDINATE_SYSTEM.DEFAULT && !viewport.isGeospatial;
  }

  // src/simple-mesh-layer/simple-mesh-layer-vertex.glsl.ts
  var simple_mesh_layer_vertex_glsl_default = `#version 300 es
#define SHADER_NAME simple-mesh-layer-vs

// Scale the model
uniform float sizeScale;
uniform bool composeModelMatrix;

// Primitive attributes
in vec3 positions;
in vec3 normals;
in vec3 colors;
in vec2 texCoords;

// Instance attributes
in vec3 instancePositions;
in vec3 instancePositions64Low;
in vec4 instanceColors;
in vec3 instancePickingColors;
in mat3 instanceModelMatrix;
in vec3 instanceTranslation;

// Outputs to fragment shader
out vec2 vTexCoord;
out vec3 cameraPosition;
out vec3 normals_commonspace;
out vec4 position_commonspace;
out vec4 vColor;

void main(void) {
  geometry.worldPosition = instancePositions;
  geometry.uv = texCoords;
  geometry.pickingColor = instancePickingColors;

  vTexCoord = texCoords;
  cameraPosition = project_uCameraPosition;
  vColor = vec4(colors * instanceColors.rgb, instanceColors.a);

  vec3 pos = (instanceModelMatrix * positions) * sizeScale + instanceTranslation;

  if (composeModelMatrix) {
    DECKGL_FILTER_SIZE(pos, geometry);
    // using instancePositions as world coordinates
    // when using globe mode, this branch does not re-orient the model to align with the surface of the earth
    // call project_normal before setting position to avoid rotation
    normals_commonspace = project_normal(instanceModelMatrix * normals);
    geometry.worldPosition += pos;
    gl_Position = project_position_to_clipspace(pos + instancePositions, instancePositions64Low, vec3(0.0), position_commonspace);
    geometry.position = position_commonspace;
  }
  else {
    pos = project_size(pos);
    DECKGL_FILTER_SIZE(pos, geometry);
    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, pos, position_commonspace);
    geometry.position = position_commonspace;
    normals_commonspace = project_normal(instanceModelMatrix * normals);
  }

  geometry.normal = normals_commonspace;
  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);

  DECKGL_FILTER_COLOR(vColor, geometry);
}
`;

  // src/simple-mesh-layer/simple-mesh-layer-fragment.glsl.ts
  var simple_mesh_layer_fragment_glsl_default = `#version 300 es
#define SHADER_NAME simple-mesh-layer-fs

precision highp float;

uniform bool hasTexture;
uniform sampler2D sampler;
uniform bool flatShading;
uniform float opacity;

in vec2 vTexCoord;
in vec3 cameraPosition;
in vec3 normals_commonspace;
in vec4 position_commonspace;
in vec4 vColor;

out vec4 fragColor;

void main(void) {
  geometry.uv = vTexCoord;

  vec3 normal;
  if (flatShading) {

// NOTE(Tarek): This is necessary because
// headless.gl reports the extension as
// available but does not support it in
// the shader.
#ifdef DERIVATIVES_AVAILABLE
    normal = normalize(cross(dFdx(position_commonspace.xyz), dFdy(position_commonspace.xyz)));
#else
    normal = vec3(0.0, 0.0, 1.0);
#endif
  } else {
    normal = normals_commonspace;
  }

  vec4 color = hasTexture ? texture(sampler, vTexCoord) : vColor;
  DECKGL_FILTER_COLOR(color, geometry);

  vec3 lightColor = lighting_getLightColor(color.rgb, cameraPosition, position_commonspace.xyz, normal);
  fragColor = vec4(lightColor, color.a * opacity);
}
`;

  // ../../node_modules/@loaders.gl/schema/dist/esm/category/mesh/mesh-utils.js
  function getMeshBoundingBox(attributes) {
    let minX = Infinity;
    let minY = Infinity;
    let minZ = Infinity;
    let maxX = -Infinity;
    let maxY = -Infinity;
    let maxZ = -Infinity;
    const positions = attributes.POSITION ? attributes.POSITION.value : [];
    const len2 = positions && positions.length;
    for (let i2 = 0; i2 < len2; i2 += 3) {
      const x = positions[i2];
      const y = positions[i2 + 1];
      const z = positions[i2 + 2];
      minX = x < minX ? x : minX;
      minY = y < minY ? y : minY;
      minZ = z < minZ ? z : minZ;
      maxX = x > maxX ? x : maxX;
      maxY = y > maxY ? y : maxY;
      maxZ = z > maxZ ? z : maxZ;
    }
    return [[minX, minY, minZ], [maxX, maxY, maxZ]];
  }

  // ../../node_modules/@loaders.gl/schema/dist/esm/lib/utils/assert.js
  function assert4(condition, message) {
    if (!condition) {
      throw new Error(message || "loader assertion failed.");
    }
  }

  // ../../node_modules/@loaders.gl/schema/dist/esm/lib/schema/impl/schema.js
  var Schema = class {
    constructor(fields, metadata) {
      _defineProperty(this, "fields", void 0);
      _defineProperty(this, "metadata", void 0);
      assert4(Array.isArray(fields));
      checkNames(fields);
      this.fields = fields;
      this.metadata = metadata || /* @__PURE__ */ new Map();
    }
    compareTo(other) {
      if (this.metadata !== other.metadata) {
        return false;
      }
      if (this.fields.length !== other.fields.length) {
        return false;
      }
      for (let i2 = 0; i2 < this.fields.length; ++i2) {
        if (!this.fields[i2].compareTo(other.fields[i2])) {
          return false;
        }
      }
      return true;
    }
    select() {
      const nameMap = /* @__PURE__ */ Object.create(null);
      for (var _len = arguments.length, columnNames = new Array(_len), _key = 0; _key < _len; _key++) {
        columnNames[_key] = arguments[_key];
      }
      for (const name10 of columnNames) {
        nameMap[name10] = true;
      }
      const selectedFields = this.fields.filter((field) => nameMap[field.name]);
      return new Schema(selectedFields, this.metadata);
    }
    selectAt() {
      for (var _len2 = arguments.length, columnIndices = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        columnIndices[_key2] = arguments[_key2];
      }
      const selectedFields = columnIndices.map((index) => this.fields[index]).filter(Boolean);
      return new Schema(selectedFields, this.metadata);
    }
    assign(schemaOrFields) {
      let fields;
      let metadata = this.metadata;
      if (schemaOrFields instanceof Schema) {
        const otherSchema = schemaOrFields;
        fields = otherSchema.fields;
        metadata = mergeMaps(mergeMaps(/* @__PURE__ */ new Map(), this.metadata), otherSchema.metadata);
      } else {
        fields = schemaOrFields;
      }
      const fieldMap = /* @__PURE__ */ Object.create(null);
      for (const field of this.fields) {
        fieldMap[field.name] = field;
      }
      for (const field of fields) {
        fieldMap[field.name] = field;
      }
      const mergedFields = Object.values(fieldMap);
      return new Schema(mergedFields, metadata);
    }
  };
  function checkNames(fields) {
    const usedNames = {};
    for (const field of fields) {
      if (usedNames[field.name]) {
        console.warn("Schema: duplicated field name", field.name, field);
      }
      usedNames[field.name] = true;
    }
  }
  function mergeMaps(m1, m2) {
    return new Map([...m1 || /* @__PURE__ */ new Map(), ...m2 || /* @__PURE__ */ new Map()]);
  }

  // ../../node_modules/@loaders.gl/schema/dist/esm/lib/schema/impl/field.js
  var Field = class {
    constructor(name10, type) {
      let nullable = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      let metadata = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : /* @__PURE__ */ new Map();
      _defineProperty(this, "name", void 0);
      _defineProperty(this, "type", void 0);
      _defineProperty(this, "nullable", void 0);
      _defineProperty(this, "metadata", void 0);
      this.name = name10;
      this.type = type;
      this.nullable = nullable;
      this.metadata = metadata;
    }
    get typeId() {
      return this.type && this.type.typeId;
    }
    clone() {
      return new Field(this.name, this.type, this.nullable, this.metadata);
    }
    compareTo(other) {
      return this.name === other.name && this.type === other.type && this.nullable === other.nullable && this.metadata === other.metadata;
    }
    toString() {
      return "".concat(this.type).concat(this.nullable ? ", nullable" : "").concat(this.metadata ? ", metadata: ".concat(this.metadata) : "");
    }
  };

  // ../../node_modules/@loaders.gl/schema/dist/esm/lib/schema/impl/enum.js
  var Type;
  (function(Type2) {
    Type2[Type2["NONE"] = 0] = "NONE";
    Type2[Type2["Null"] = 1] = "Null";
    Type2[Type2["Int"] = 2] = "Int";
    Type2[Type2["Float"] = 3] = "Float";
    Type2[Type2["Binary"] = 4] = "Binary";
    Type2[Type2["Utf8"] = 5] = "Utf8";
    Type2[Type2["Bool"] = 6] = "Bool";
    Type2[Type2["Decimal"] = 7] = "Decimal";
    Type2[Type2["Date"] = 8] = "Date";
    Type2[Type2["Time"] = 9] = "Time";
    Type2[Type2["Timestamp"] = 10] = "Timestamp";
    Type2[Type2["Interval"] = 11] = "Interval";
    Type2[Type2["List"] = 12] = "List";
    Type2[Type2["Struct"] = 13] = "Struct";
    Type2[Type2["Union"] = 14] = "Union";
    Type2[Type2["FixedSizeBinary"] = 15] = "FixedSizeBinary";
    Type2[Type2["FixedSizeList"] = 16] = "FixedSizeList";
    Type2[Type2["Map"] = 17] = "Map";
    Type2[Type2["Dictionary"] = -1] = "Dictionary";
    Type2[Type2["Int8"] = -2] = "Int8";
    Type2[Type2["Int16"] = -3] = "Int16";
    Type2[Type2["Int32"] = -4] = "Int32";
    Type2[Type2["Int64"] = -5] = "Int64";
    Type2[Type2["Uint8"] = -6] = "Uint8";
    Type2[Type2["Uint16"] = -7] = "Uint16";
    Type2[Type2["Uint32"] = -8] = "Uint32";
    Type2[Type2["Uint64"] = -9] = "Uint64";
    Type2[Type2["Float16"] = -10] = "Float16";
    Type2[Type2["Float32"] = -11] = "Float32";
    Type2[Type2["Float64"] = -12] = "Float64";
    Type2[Type2["DateDay"] = -13] = "DateDay";
    Type2[Type2["DateMillisecond"] = -14] = "DateMillisecond";
    Type2[Type2["TimestampSecond"] = -15] = "TimestampSecond";
    Type2[Type2["TimestampMillisecond"] = -16] = "TimestampMillisecond";
    Type2[Type2["TimestampMicrosecond"] = -17] = "TimestampMicrosecond";
    Type2[Type2["TimestampNanosecond"] = -18] = "TimestampNanosecond";
    Type2[Type2["TimeSecond"] = -19] = "TimeSecond";
    Type2[Type2["TimeMillisecond"] = -20] = "TimeMillisecond";
    Type2[Type2["TimeMicrosecond"] = -21] = "TimeMicrosecond";
    Type2[Type2["TimeNanosecond"] = -22] = "TimeNanosecond";
    Type2[Type2["DenseUnion"] = -23] = "DenseUnion";
    Type2[Type2["SparseUnion"] = -24] = "SparseUnion";
    Type2[Type2["IntervalDayTime"] = -25] = "IntervalDayTime";
    Type2[Type2["IntervalYearMonth"] = -26] = "IntervalYearMonth";
  })(Type || (Type = {}));

  // ../../node_modules/@loaders.gl/schema/dist/esm/lib/schema/impl/type.js
  var _Symbol$toStringTag;
  var _Symbol$toStringTag2;
  var _Symbol$toStringTag3;
  var _Symbol$toStringTag4;
  var _Symbol$toStringTag5;
  var _Symbol$toStringTag6;
  var _Symbol$toStringTag7;
  var _Symbol$toStringTag8;
  var DataType = class {
    static isNull(x) {
      return x && x.typeId === Type.Null;
    }
    static isInt(x) {
      return x && x.typeId === Type.Int;
    }
    static isFloat(x) {
      return x && x.typeId === Type.Float;
    }
    static isBinary(x) {
      return x && x.typeId === Type.Binary;
    }
    static isUtf8(x) {
      return x && x.typeId === Type.Utf8;
    }
    static isBool(x) {
      return x && x.typeId === Type.Bool;
    }
    static isDecimal(x) {
      return x && x.typeId === Type.Decimal;
    }
    static isDate(x) {
      return x && x.typeId === Type.Date;
    }
    static isTime(x) {
      return x && x.typeId === Type.Time;
    }
    static isTimestamp(x) {
      return x && x.typeId === Type.Timestamp;
    }
    static isInterval(x) {
      return x && x.typeId === Type.Interval;
    }
    static isList(x) {
      return x && x.typeId === Type.List;
    }
    static isStruct(x) {
      return x && x.typeId === Type.Struct;
    }
    static isUnion(x) {
      return x && x.typeId === Type.Union;
    }
    static isFixedSizeBinary(x) {
      return x && x.typeId === Type.FixedSizeBinary;
    }
    static isFixedSizeList(x) {
      return x && x.typeId === Type.FixedSizeList;
    }
    static isMap(x) {
      return x && x.typeId === Type.Map;
    }
    static isDictionary(x) {
      return x && x.typeId === Type.Dictionary;
    }
    get typeId() {
      return Type.NONE;
    }
    compareTo(other) {
      return this === other;
    }
  };
  var Null = class extends DataType {
    get typeId() {
      return Type.Null;
    }
    get [Symbol.toStringTag]() {
      return "Null";
    }
    toString() {
      return "Null";
    }
  };
  var Bool = class extends DataType {
    get typeId() {
      return Type.Bool;
    }
    get [Symbol.toStringTag]() {
      return "Bool";
    }
    toString() {
      return "Bool";
    }
  };
  _Symbol$toStringTag = Symbol.toStringTag;
  var Int = class extends DataType {
    constructor(isSigned, bitWidth) {
      super();
      _defineProperty(this, "isSigned", void 0);
      _defineProperty(this, "bitWidth", void 0);
      this.isSigned = isSigned;
      this.bitWidth = bitWidth;
    }
    get typeId() {
      return Type.Int;
    }
    get [_Symbol$toStringTag]() {
      return "Int";
    }
    toString() {
      return "".concat(this.isSigned ? "I" : "Ui", "nt").concat(this.bitWidth);
    }
  };
  var Int8 = class extends Int {
    constructor() {
      super(true, 8);
    }
  };
  var Int16 = class extends Int {
    constructor() {
      super(true, 16);
    }
  };
  var Int32 = class extends Int {
    constructor() {
      super(true, 32);
    }
  };
  var Uint8 = class extends Int {
    constructor() {
      super(false, 8);
    }
  };
  var Uint16 = class extends Int {
    constructor() {
      super(false, 16);
    }
  };
  var Uint32 = class extends Int {
    constructor() {
      super(false, 32);
    }
  };
  var Precision = {
    HALF: 16,
    SINGLE: 32,
    DOUBLE: 64
  };
  _Symbol$toStringTag2 = Symbol.toStringTag;
  var Float = class extends DataType {
    constructor(precision) {
      super();
      _defineProperty(this, "precision", void 0);
      this.precision = precision;
    }
    get typeId() {
      return Type.Float;
    }
    get [_Symbol$toStringTag2]() {
      return "Float";
    }
    toString() {
      return "Float".concat(this.precision);
    }
  };
  var Float32 = class extends Float {
    constructor() {
      super(Precision.SINGLE);
    }
  };
  var Float64 = class extends Float {
    constructor() {
      super(Precision.DOUBLE);
    }
  };
  var Binary = class extends DataType {
    constructor() {
      super();
    }
    get typeId() {
      return Type.Binary;
    }
    toString() {
      return "Binary";
    }
    get [Symbol.toStringTag]() {
      return "Binary";
    }
  };
  var Utf8 = class extends DataType {
    get typeId() {
      return Type.Utf8;
    }
    get [Symbol.toStringTag]() {
      return "Utf8";
    }
    toString() {
      return "Utf8";
    }
  };
  var DateUnit = {
    DAY: 0,
    MILLISECOND: 1
  };
  _Symbol$toStringTag3 = Symbol.toStringTag;
  var Date2 = class extends DataType {
    constructor(unit) {
      super();
      _defineProperty(this, "unit", void 0);
      this.unit = unit;
    }
    get typeId() {
      return Type.Date;
    }
    get [_Symbol$toStringTag3]() {
      return "Date";
    }
    toString() {
      return "Date".concat((this.unit + 1) * 32, "<").concat(DateUnit[this.unit], ">");
    }
  };
  var TimeUnit = {
    SECOND: 1,
    MILLISECOND: 1e3,
    MICROSECOND: 1e6,
    NANOSECOND: 1e9
  };
  _Symbol$toStringTag4 = Symbol.toStringTag;
  var Time = class extends DataType {
    constructor(unit, bitWidth) {
      super();
      _defineProperty(this, "unit", void 0);
      _defineProperty(this, "bitWidth", void 0);
      this.unit = unit;
      this.bitWidth = bitWidth;
    }
    get typeId() {
      return Type.Time;
    }
    toString() {
      return "Time".concat(this.bitWidth, "<").concat(TimeUnit[this.unit], ">");
    }
    get [_Symbol$toStringTag4]() {
      return "Time";
    }
  };
  _Symbol$toStringTag5 = Symbol.toStringTag;
  var Timestamp = class extends DataType {
    constructor(unit) {
      let timezone = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
      super();
      _defineProperty(this, "unit", void 0);
      _defineProperty(this, "timezone", void 0);
      this.unit = unit;
      this.timezone = timezone;
    }
    get typeId() {
      return Type.Timestamp;
    }
    get [_Symbol$toStringTag5]() {
      return "Timestamp";
    }
    toString() {
      return "Timestamp<".concat(TimeUnit[this.unit]).concat(this.timezone ? ", ".concat(this.timezone) : "", ">");
    }
  };
  var IntervalUnit = {
    DAY_TIME: 0,
    YEAR_MONTH: 1
  };
  _Symbol$toStringTag6 = Symbol.toStringTag;
  var Interval = class extends DataType {
    constructor(unit) {
      super();
      _defineProperty(this, "unit", void 0);
      this.unit = unit;
    }
    get typeId() {
      return Type.Interval;
    }
    get [_Symbol$toStringTag6]() {
      return "Interval";
    }
    toString() {
      return "Interval<".concat(IntervalUnit[this.unit], ">");
    }
  };
  _Symbol$toStringTag7 = Symbol.toStringTag;
  var FixedSizeList = class extends DataType {
    constructor(listSize, child) {
      super();
      _defineProperty(this, "listSize", void 0);
      _defineProperty(this, "children", void 0);
      this.listSize = listSize;
      this.children = [child];
    }
    get typeId() {
      return Type.FixedSizeList;
    }
    get valueType() {
      return this.children[0].type;
    }
    get valueField() {
      return this.children[0];
    }
    get [_Symbol$toStringTag7]() {
      return "FixedSizeList";
    }
    toString() {
      return "FixedSizeList[".concat(this.listSize, "]<").concat(this.valueType, ">");
    }
  };
  _Symbol$toStringTag8 = Symbol.toStringTag;
  var Struct = class extends DataType {
    constructor(children) {
      super();
      _defineProperty(this, "children", void 0);
      this.children = children;
    }
    get typeId() {
      return Type.Struct;
    }
    toString() {
      return "Struct<{".concat(this.children.map((f2) => "".concat(f2.name, ":").concat(f2.type)).join(", "), "}>");
    }
    get [_Symbol$toStringTag8]() {
      return "Struct";
    }
  };

  // ../../node_modules/@loaders.gl/schema/dist/esm/lib/arrow/arrow-like-type-utils.js
  function getArrowTypeFromTypedArray(array) {
    switch (array.constructor) {
      case Int8Array:
        return new Int8();
      case Uint8Array:
        return new Uint8();
      case Int16Array:
        return new Int16();
      case Uint16Array:
        return new Uint16();
      case Int32Array:
        return new Int32();
      case Uint32Array:
        return new Uint32();
      case Float32Array:
        return new Float32();
      case Float64Array:
        return new Float64();
      default:
        throw new Error("array type not supported");
    }
  }

  // ../../node_modules/@loaders.gl/schema/dist/esm/category/mesh/deduce-mesh-schema.js
  function deduceMeshField(attributeName, attribute, optionalMetadata) {
    const type = getArrowTypeFromTypedArray(attribute.value);
    const metadata = optionalMetadata ? optionalMetadata : makeMeshAttributeMetadata(attribute);
    const field = new Field(attributeName, new FixedSizeList(attribute.size, new Field("value", type)), false, metadata);
    return field;
  }
  function makeMeshAttributeMetadata(attribute) {
    const result = /* @__PURE__ */ new Map();
    if ("byteOffset" in attribute) {
      result.set("byteOffset", attribute.byteOffset.toString(10));
    }
    if ("byteStride" in attribute) {
      result.set("byteStride", attribute.byteStride.toString(10));
    }
    if ("normalized" in attribute) {
      result.set("normalized", attribute.normalized.toString());
    }
    return result;
  }

  // src/simple-mesh-layer/simple-mesh-layer.ts
  function validateGeometryAttributes(attributes, useMeshColors) {
    const hasColorAttribute = attributes.COLOR_0 || attributes.colors;
    const useColorAttribute = hasColorAttribute && useMeshColors;
    if (!useColorAttribute) {
      attributes.colors = {
        constant: true,
        value: new Float32Array([1, 1, 1])
      };
    }
    import_core3.log.assert(attributes.positions || attributes.POSITION, 'no "postions" or "POSITION" attribute in mesh');
  }
  function getGeometry(data, useMeshColors) {
    if (data.attributes) {
      validateGeometryAttributes(data.attributes, useMeshColors);
      if (data instanceof import_core4.Geometry) {
        return data;
      } else {
        return new import_core4.Geometry(data);
      }
    } else if (data.positions || data.POSITION) {
      validateGeometryAttributes(data, useMeshColors);
      return new import_core4.Geometry({
        attributes: data
      });
    }
    throw Error("Invalid mesh");
  }
  var DEFAULT_COLOR = [0, 0, 0, 255];
  var defaultProps = {
    mesh: {
      type: "object",
      value: null,
      async: true
    },
    texture: {
      type: "image",
      value: null,
      async: true
    },
    sizeScale: {
      type: "number",
      value: 1,
      min: 0
    },
    _useMeshColors: {
      type: "boolean",
      value: false
    },
    _instanced: true,
    wireframe: false,
    material: true,
    getPosition: {
      type: "accessor",
      value: (x) => x.position
    },
    getColor: {
      type: "accessor",
      value: DEFAULT_COLOR
    },
    getOrientation: {
      type: "accessor",
      value: [0, 0, 0]
    },
    getScale: {
      type: "accessor",
      value: [1, 1, 1]
    },
    getTranslation: {
      type: "accessor",
      value: [0, 0, 0]
    },
    getTransformMatrix: {
      type: "accessor",
      value: []
    },
    textureParameters: {
      type: "object",
      ignore: true
    }
  };
  var SimpleMeshLayer = class extends import_core3.Layer {
    getShaders() {
      const transpileToGLSL100 = !(0, import_core4.isWebGL2)(this.context.gl);
      const defines = {};
      if (hasFeature(this.context.gl, FEATURES.GLSL_DERIVATIVES)) {
        defines.DERIVATIVES_AVAILABLE = 1;
      }
      return super.getShaders({
        vs: simple_mesh_layer_vertex_glsl_default,
        fs: simple_mesh_layer_fragment_glsl_default,
        modules: [import_core3.project32, import_core3.phongLighting, import_core3.picking],
        transpileToGLSL100,
        defines
      });
    }
    getBounds() {
      if (this.props._instanced) {
        return super.getBounds();
      }
      let result = this.state.positionBounds;
      if (result) {
        return result;
      }
      const {
        mesh
      } = this.props;
      if (!mesh) {
        return null;
      }
      result = mesh.header?.boundingBox;
      if (!result) {
        const {
          attributes
        } = getGeometry(mesh, this.props._useMeshColors);
        attributes.POSITION = attributes.POSITION || attributes.positions;
        result = getMeshBoundingBox(attributes);
      }
      this.state.positionBounds = result;
      return result;
    }
    initializeState() {
      const attributeManager = this.getAttributeManager();
      attributeManager.addInstanced({
        instancePositions: {
          transition: true,
          type: esm_default.DOUBLE,
          fp64: this.use64bitPositions(),
          size: 3,
          accessor: "getPosition"
        },
        instanceColors: {
          type: esm_default.UNSIGNED_BYTE,
          transition: true,
          size: this.props.colorFormat.length,
          normalized: true,
          accessor: "getColor",
          defaultValue: [0, 0, 0, 255]
        },
        instanceModelMatrix: MATRIX_ATTRIBUTES
      });
      this.setState({
        emptyTexture: new import_core4.Texture2D(this.context.gl, {
          data: new Uint8Array(4),
          width: 1,
          height: 1
        })
      });
    }
    updateState(params) {
      super.updateState(params);
      const {
        props,
        oldProps,
        changeFlags
      } = params;
      if (props.mesh !== oldProps.mesh || changeFlags.extensionsChanged) {
        this.state.positionBounds = null;
        this.state.model?.delete();
        if (props.mesh) {
          this.state.model = this.getModel(props.mesh);
          const attributes = props.mesh.attributes || props.mesh;
          this.setState({
            hasNormals: Boolean(attributes.NORMAL || attributes.normals)
          });
        }
        this.getAttributeManager().invalidateAll();
      }
      if (props.texture !== oldProps.texture) {
        this.setTexture(props.texture);
      }
      if (this.state.model) {
        this.state.model.setDrawMode(this.props.wireframe ? esm_default.LINE_STRIP : esm_default.TRIANGLES);
      }
    }
    finalizeState(context) {
      super.finalizeState(context);
      this.state.emptyTexture.delete();
    }
    draw({
      uniforms
    }) {
      if (!this.state.model) {
        return;
      }
      const {
        viewport
      } = this.context;
      const {
        sizeScale,
        coordinateSystem,
        _instanced
      } = this.props;
      this.state.model.setUniforms(uniforms).setUniforms({
        sizeScale,
        composeModelMatrix: !_instanced || shouldComposeModelMatrix(viewport, coordinateSystem),
        flatShading: !this.state.hasNormals
      }).draw();
    }
    getModel(mesh) {
      const model = new import_core4.Model(this.context.gl, {
        ...this.getShaders(),
        id: this.props.id,
        geometry: getGeometry(mesh, this.props._useMeshColors),
        isInstanced: true
      });
      const {
        texture
      } = this.props;
      const {
        emptyTexture
      } = this.state;
      model.setUniforms({
        sampler: texture || emptyTexture,
        hasTexture: Boolean(texture)
      });
      return model;
    }
    setTexture(texture) {
      const {
        emptyTexture,
        model
      } = this.state;
      if (model) {
        model.setUniforms({
          sampler: texture || emptyTexture,
          hasTexture: Boolean(texture)
        });
      }
    }
  };
  __publicField(SimpleMeshLayer, "defaultProps", defaultProps);
  __publicField(SimpleMeshLayer, "layerName", "SimpleMeshLayer");

  // src/scenegraph-layer/scenegraph-layer.ts
  var import_core10 = __toESM(require_core());
  var import_core11 = __toESM(require_core2());

  // ../../node_modules/@luma.gl/shadertools/dist/esm/lib/constants.js
  var VERTEX_SHADER = "vs";
  var FRAGMENT_SHADER = "fs";

  // ../../node_modules/@luma.gl/shadertools/dist/esm/utils/assert.js
  function assert5(condition, message) {
    if (!condition) {
      throw new Error(message || "shadertools: assertion failed.");
    }
  }

  // ../../node_modules/@luma.gl/shadertools/dist/esm/lib/filters/prop-types.js
  var TYPE_DEFINITIONS = {
    number: {
      validate(value, propType) {
        return Number.isFinite(value) && (!("max" in propType) || value <= propType.max) && (!("min" in propType) || value >= propType.min);
      }
    },
    array: {
      validate(value, propType) {
        return Array.isArray(value) || ArrayBuffer.isView(value);
      }
    }
  };
  function parsePropTypes(propDefs) {
    const propTypes = {};
    for (const propName in propDefs) {
      const propDef = propDefs[propName];
      const propType = parsePropType(propDef);
      propTypes[propName] = propType;
    }
    return propTypes;
  }
  function parsePropType(propDef) {
    let type = getTypeOf(propDef);
    if (type === "object") {
      if (!propDef) {
        return {
          type: "object",
          value: null
        };
      }
      if ("type" in propDef) {
        return Object.assign({}, propDef, TYPE_DEFINITIONS[propDef.type]);
      }
      if (!("value" in propDef)) {
        return {
          type: "object",
          value: propDef
        };
      }
      type = getTypeOf(propDef.value);
      return Object.assign({
        type
      }, propDef, TYPE_DEFINITIONS[type]);
    }
    return Object.assign({
      type,
      value: propDef
    }, TYPE_DEFINITIONS[type]);
  }
  function getTypeOf(value) {
    if (Array.isArray(value) || ArrayBuffer.isView(value)) {
      return "array";
    }
    return typeof value;
  }

  // ../../node_modules/@luma.gl/shadertools/dist/esm/lib/shader-module.js
  var VERTEX_SHADER2 = "vs";
  var FRAGMENT_SHADER2 = "fs";
  var ShaderModule = class {
    constructor(_ref) {
      let {
        name: name10,
        vs: vs2,
        fs: fs2,
        dependencies = [],
        uniforms,
        getUniforms: getUniforms2,
        deprecations = [],
        defines = {},
        inject = {},
        vertexShader,
        fragmentShader
      } = _ref;
      assert5(typeof name10 === "string");
      this.name = name10;
      this.vs = vs2 || vertexShader;
      this.fs = fs2 || fragmentShader;
      this.getModuleUniforms = getUniforms2;
      this.dependencies = dependencies;
      this.deprecations = this._parseDeprecationDefinitions(deprecations);
      this.defines = defines;
      this.injections = normalizeInjections(inject);
      if (uniforms) {
        this.uniforms = parsePropTypes(uniforms);
      }
    }
    getModuleSource(type) {
      let moduleSource;
      switch (type) {
        case VERTEX_SHADER2:
          moduleSource = this.vs || "";
          break;
        case FRAGMENT_SHADER2:
          moduleSource = this.fs || "";
          break;
        default:
          assert5(false);
      }
      return "#define MODULE_".concat(this.name.toUpperCase().replace(/[^0-9a-z]/gi, "_"), "\n").concat(moduleSource, "// END MODULE_").concat(this.name, "\n\n");
    }
    getUniforms(opts, uniforms) {
      if (this.getModuleUniforms) {
        return this.getModuleUniforms(opts, uniforms);
      }
      if (this.uniforms) {
        return this._defaultGetUniforms(opts);
      }
      return {};
    }
    getDefines() {
      return this.defines;
    }
    checkDeprecations(shaderSource, log5) {
      this.deprecations.forEach((def) => {
        if (def.regex.test(shaderSource)) {
          if (def.deprecated) {
            log5.deprecated(def.old, def.new)();
          } else {
            log5.removed(def.old, def.new)();
          }
        }
      });
    }
    _parseDeprecationDefinitions(deprecations) {
      deprecations.forEach((def) => {
        switch (def.type) {
          case "function":
            def.regex = new RegExp("\\b".concat(def.old, "\\("));
            break;
          default:
            def.regex = new RegExp("".concat(def.type, " ").concat(def.old, ";"));
        }
      });
      return deprecations;
    }
    _defaultGetUniforms() {
      let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const uniforms = {};
      const propTypes = this.uniforms;
      for (const key in propTypes) {
        const propDef = propTypes[key];
        if (key in opts && !propDef.private) {
          if (propDef.validate) {
            assert5(propDef.validate(opts[key], propDef), "".concat(this.name, ": invalid ").concat(key));
          }
          uniforms[key] = opts[key];
        } else {
          uniforms[key] = propDef.value;
        }
      }
      return uniforms;
    }
  };
  function normalizeInjections(injections) {
    const result = {
      vs: {},
      fs: {}
    };
    for (const hook in injections) {
      let injection = injections[hook];
      const stage = hook.slice(0, 2);
      if (typeof injection === "string") {
        injection = {
          order: 0,
          injection
        };
      }
      result[stage][hook] = injection;
    }
    return result;
  }

  // ../../node_modules/@luma.gl/shadertools/dist/esm/lib/resolve-modules.js
  function resolveModules(modules) {
    return getShaderDependencies(instantiateModules(modules));
  }
  function getShaderDependencies(modules) {
    const moduleMap = {};
    const moduleDepth = {};
    getDependencyGraph({
      modules,
      level: 0,
      moduleMap,
      moduleDepth
    });
    return Object.keys(moduleDepth).sort((a2, b) => moduleDepth[b] - moduleDepth[a2]).map((name10) => moduleMap[name10]);
  }
  function getDependencyGraph(_ref) {
    let {
      modules,
      level,
      moduleMap,
      moduleDepth
    } = _ref;
    if (level >= 5) {
      throw new Error("Possible loop in shader dependency graph");
    }
    for (const module2 of modules) {
      moduleMap[module2.name] = module2;
      if (moduleDepth[module2.name] === void 0 || moduleDepth[module2.name] < level) {
        moduleDepth[module2.name] = level;
      }
    }
    for (const module2 of modules) {
      if (module2.dependencies) {
        getDependencyGraph({
          modules: module2.dependencies,
          level: level + 1,
          moduleMap,
          moduleDepth
        });
      }
    }
  }
  function instantiateModules(modules, seen) {
    return modules.map((module2) => {
      if (module2 instanceof ShaderModule) {
        return module2;
      }
      assert5(typeof module2 !== "string", "Shader module use by name is deprecated. Import shader module '".concat(module2, "' and use it directly."));
      assert5(module2.name, "shader module has no name");
      module2 = new ShaderModule(module2);
      module2.dependencies = instantiateModules(module2.dependencies);
      return module2;
    });
  }

  // ../../node_modules/@luma.gl/shadertools/dist/esm/utils/is-old-ie.js
  function isOldIE() {
    let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const navigator2 = typeof window !== "undefined" ? window.navigator || {} : {};
    const userAgent = opts.userAgent || navigator2.userAgent || "";
    const isMSIE = userAgent.indexOf("MSIE ") !== -1;
    const isTrident = userAgent.indexOf("Trident/") !== -1;
    return isMSIE || isTrident;
  }

  // ../../node_modules/@luma.gl/shadertools/dist/esm/utils/webgl-info.js
  var GL_VENDOR = 7936;
  var GL_RENDERER = 7937;
  var GL_VERSION = 7938;
  var GL_SHADING_LANGUAGE_VERSION = 35724;
  var WEBGL_FEATURES = {
    GLSL_FRAG_DATA: ["WEBGL_draw_buffers", true],
    GLSL_FRAG_DEPTH: ["EXT_frag_depth", true],
    GLSL_DERIVATIVES: ["OES_standard_derivatives", true],
    GLSL_TEXTURE_LOD: ["EXT_shader_texture_lod", true]
  };
  var FEATURES2 = {};
  Object.keys(WEBGL_FEATURES).forEach((key) => {
    FEATURES2[key] = key;
  });
  function isWebGL23(gl) {
    if (typeof WebGL2RenderingContext !== "undefined" && gl instanceof WebGL2RenderingContext) {
      return true;
    }
    return Boolean(gl && gl._version === 2);
  }
  function getContextInfo(gl) {
    const info = gl.getExtension("WEBGL_debug_renderer_info");
    const vendor = gl.getParameter(info && info.UNMASKED_VENDOR_WEBGL || GL_VENDOR);
    const renderer = gl.getParameter(info && info.UNMASKED_RENDERER_WEBGL || GL_RENDERER);
    const gpuVendor = identifyGPUVendor(vendor, renderer);
    const gpuInfo = {
      gpuVendor,
      vendor,
      renderer,
      version: gl.getParameter(GL_VERSION),
      shadingLanguageVersion: gl.getParameter(GL_SHADING_LANGUAGE_VERSION)
    };
    return gpuInfo;
  }
  function identifyGPUVendor(vendor, renderer) {
    if (vendor.match(/NVIDIA/i) || renderer.match(/NVIDIA/i)) {
      return "NVIDIA";
    }
    if (vendor.match(/INTEL/i) || renderer.match(/INTEL/i)) {
      return "INTEL";
    }
    if (vendor.match(/AMD/i) || renderer.match(/AMD/i) || vendor.match(/ATI/i) || renderer.match(/ATI/i)) {
      return "AMD";
    }
    return "UNKNOWN GPU";
  }
  var compiledGlslExtensions = {};
  function canCompileGLGSExtension(gl, cap) {
    let opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    const feature = WEBGL_FEATURES[cap];
    assert5(feature, cap);
    if (!isOldIE(opts)) {
      return true;
    }
    if (cap in compiledGlslExtensions) {
      return compiledGlslExtensions[cap];
    }
    const extensionName = feature[0];
    const behavior = opts.behavior || "enable";
    const source = "#extension GL_".concat(extensionName, " : ").concat(behavior, "\nvoid main(void) {}");
    const shader = gl.createShader(35633);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    const canCompile = gl.getShaderParameter(shader, 35713);
    gl.deleteShader(shader);
    compiledGlslExtensions[cap] = canCompile;
    return canCompile;
  }
  function getFeature(gl, cap) {
    const feature = WEBGL_FEATURES[cap];
    assert5(feature, cap);
    const extensionName = isWebGL23(gl) ? feature[1] || feature[0] : feature[0];
    const value = typeof extensionName === "string" ? Boolean(gl.getExtension(extensionName)) : extensionName;
    assert5(value === false || value === true);
    return value;
  }
  function hasFeatures2(gl, features) {
    features = Array.isArray(features) ? features : [features];
    return features.every((feature) => getFeature(gl, feature));
  }

  // ../../node_modules/@luma.gl/shadertools/dist/esm/lib/platform-defines.js
  function getPlatformShaderDefines(gl) {
    const debugInfo = getContextInfo(gl);
    switch (debugInfo.gpuVendor.toLowerCase()) {
      case "nvidia":
        return "#define NVIDIA_GPU\n// Nvidia optimizes away the calculation necessary for emulated fp64\n#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1\n";
      case "intel":
        return "#define INTEL_GPU\n// Intel optimizes away the calculation necessary for emulated fp64\n#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1\n// Intel's built-in 'tan' function doesn't have acceptable precision\n#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1\n// Intel GPU doesn't have full 32 bits precision in same cases, causes overflow\n#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1\n";
      case "amd":
        return "#define AMD_GPU\n";
      default:
        return "#define DEFAULT_GPU\n// Prevent driver from optimizing away the calculation necessary for emulated fp64\n#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1\n// Intel's built-in 'tan' function doesn't have acceptable precision\n#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1\n// Intel GPU doesn't have full 32 bits precision in same cases, causes overflow\n#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1\n";
    }
  }
  function getVersionDefines(gl, glslVersion, isFragment) {
    let versionDefines = "#if (__VERSION__ > 120)\n\n# define FEATURE_GLSL_DERIVATIVES\n# define FEATURE_GLSL_DRAW_BUFFERS\n# define FEATURE_GLSL_FRAG_DEPTH\n# define FEATURE_GLSL_TEXTURE_LOD\n\n// DEPRECATED FLAGS, remove in v9\n# define FRAG_DEPTH\n# define DERIVATIVES\n# define DRAW_BUFFERS\n# define TEXTURE_LOD\n\n#endif // __VERSION\n";
    if (hasFeatures2(gl, FEATURES2.GLSL_FRAG_DEPTH)) {
      versionDefines += "\n// FRAG_DEPTH => gl_FragDepth is available\n#ifdef GL_EXT_frag_depth\n#extension GL_EXT_frag_depth : enable\n# define FEATURE_GLSL_FRAG_DEPTH\n# define FRAG_DEPTH\n# define gl_FragDepth gl_FragDepthEXT\n#endif\n";
    }
    if (hasFeatures2(gl, FEATURES2.GLSL_DERIVATIVES) && canCompileGLGSExtension(gl, FEATURES2.GLSL_DERIVATIVES)) {
      versionDefines += "\n// DERIVATIVES => dxdF, dxdY and fwidth are available\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives : enable\n# define FEATURE_GLSL_DERIVATIVES\n# define DERIVATIVES\n#endif\n";
    }
    if (hasFeatures2(gl, FEATURES2.GLSL_FRAG_DATA) && canCompileGLGSExtension(gl, FEATURES2.GLSL_FRAG_DATA, {
      behavior: "require"
    })) {
      versionDefines += "\n// DRAW_BUFFERS => gl_FragData[] is available\n#ifdef GL_EXT_draw_buffers\n#extension GL_EXT_draw_buffers : require\n#define FEATURE_GLSL_DRAW_BUFFERS\n#define DRAW_BUFFERS\n#endif\n";
    }
    if (hasFeatures2(gl, FEATURES2.GLSL_TEXTURE_LOD)) {
      versionDefines += "// TEXTURE_LOD => texture2DLod etc are available\n#ifdef GL_EXT_shader_texture_lod\n#extension GL_EXT_shader_texture_lod : enable\n\n# define FEATURE_GLSL_TEXTURE_LOD\n# define TEXTURE_LOD\n\n#endif\n";
    }
    return versionDefines;
  }

  // ../../node_modules/@luma.gl/shadertools/dist/esm/modules/module-injectors.js
  var MODULE_INJECTORS_VS = "#ifdef MODULE_LOGDEPTH\n  logdepth_adjustPosition(gl_Position);\n#endif\n";
  var MODULE_INJECTORS_FS = "#ifdef MODULE_MATERIAL\n  gl_FragColor = material_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_LIGHTING\n  gl_FragColor = lighting_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_FOG\n  gl_FragColor = fog_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_PICKING\n  gl_FragColor = picking_filterHighlightColor(gl_FragColor);\n  gl_FragColor = picking_filterPickingColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_LOGDEPTH\n  logdepth_setFragDepth();\n#endif\n";

  // ../../node_modules/@luma.gl/shadertools/dist/esm/lib/inject-shader.js
  var MODULE_INJECTORS = {
    [VERTEX_SHADER]: MODULE_INJECTORS_VS,
    [FRAGMENT_SHADER]: MODULE_INJECTORS_FS
  };
  var DECLARATION_INJECT_MARKER = "__LUMA_INJECT_DECLARATIONS__";
  var REGEX_START_OF_MAIN = /void\s+main\s*\([^)]*\)\s*\{\n?/;
  var REGEX_END_OF_MAIN = /}\n?[^{}]*$/;
  var fragments = [];
  function injectShader(source, type, inject) {
    let injectStandardStubs = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
    const isVertex = type === VERTEX_SHADER;
    for (const key in inject) {
      const fragmentData = inject[key];
      fragmentData.sort((a2, b) => a2.order - b.order);
      fragments.length = fragmentData.length;
      for (let i2 = 0, len2 = fragmentData.length; i2 < len2; ++i2) {
        fragments[i2] = fragmentData[i2].injection;
      }
      const fragmentString = "".concat(fragments.join("\n"), "\n");
      switch (key) {
        case "vs:#decl":
          if (isVertex) {
            source = source.replace(DECLARATION_INJECT_MARKER, fragmentString);
          }
          break;
        case "vs:#main-start":
          if (isVertex) {
            source = source.replace(REGEX_START_OF_MAIN, (match) => match + fragmentString);
          }
          break;
        case "vs:#main-end":
          if (isVertex) {
            source = source.replace(REGEX_END_OF_MAIN, (match) => fragmentString + match);
          }
          break;
        case "fs:#decl":
          if (!isVertex) {
            source = source.replace(DECLARATION_INJECT_MARKER, fragmentString);
          }
          break;
        case "fs:#main-start":
          if (!isVertex) {
            source = source.replace(REGEX_START_OF_MAIN, (match) => match + fragmentString);
          }
          break;
        case "fs:#main-end":
          if (!isVertex) {
            source = source.replace(REGEX_END_OF_MAIN, (match) => fragmentString + match);
          }
          break;
        default:
          source = source.replace(key, (match) => match + fragmentString);
      }
    }
    source = source.replace(DECLARATION_INJECT_MARKER, "");
    if (injectStandardStubs) {
      source = source.replace(/\}\s*$/, (match) => match + MODULE_INJECTORS[type]);
    }
    return source;
  }

  // ../../node_modules/@luma.gl/shadertools/dist/esm/lib/transpile-shader.js
  function testVariable(qualifier) {
    return new RegExp("\\b".concat(qualifier, "[ \\t]+(\\w+[ \\t]+\\w+(\\[\\w+\\])?;)"), "g");
  }
  var ES300_REPLACEMENTS = [[/^(#version[ \t]+(100|300[ \t]+es))?[ \t]*\n/, "#version 300 es\n"], [/\btexture(2D|2DProj|Cube)Lod(EXT)?\(/g, "textureLod("], [/\btexture(2D|2DProj|Cube)(EXT)?\(/g, "texture("]];
  var ES300_VERTEX_REPLACEMENTS = [...ES300_REPLACEMENTS, [testVariable("attribute"), "in $1"], [testVariable("varying"), "out $1"]];
  var ES300_FRAGMENT_REPLACEMENTS = [...ES300_REPLACEMENTS, [testVariable("varying"), "in $1"]];
  var ES100_REPLACEMENTS = [[/^#version[ \t]+300[ \t]+es/, "#version 100"], [/\btexture(2D|2DProj|Cube)Lod\(/g, "texture$1LodEXT("], [/\btexture\(/g, "texture2D("], [/\btextureLod\(/g, "texture2DLodEXT("]];
  var ES100_VERTEX_REPLACEMENTS = [...ES100_REPLACEMENTS, [testVariable("in"), "attribute $1"], [testVariable("out"), "varying $1"]];
  var ES100_FRAGMENT_REPLACEMENTS = [...ES100_REPLACEMENTS, [testVariable("in"), "varying $1"]];
  var ES100_FRAGMENT_OUTPUT_NAME = "gl_FragColor";
  var ES300_FRAGMENT_OUTPUT_REGEX = /\bout[ \t]+vec4[ \t]+(\w+)[ \t]*;\n?/;
  var REGEX_START_OF_MAIN2 = /void\s+main\s*\([^)]*\)\s*\{\n?/;
  function transpileShader(source, targetGLSLVersion, isVertex) {
    switch (targetGLSLVersion) {
      case 300:
        return isVertex ? convertShader(source, ES300_VERTEX_REPLACEMENTS) : convertFragmentShaderTo300(source);
      case 100:
        return isVertex ? convertShader(source, ES100_VERTEX_REPLACEMENTS) : convertFragmentShaderTo100(source);
      default:
        throw new Error("unknown GLSL version ".concat(targetGLSLVersion));
    }
  }
  function convertShader(source, replacements) {
    for (const [pattern, replacement] of replacements) {
      source = source.replace(pattern, replacement);
    }
    return source;
  }
  function convertFragmentShaderTo300(source) {
    source = convertShader(source, ES300_FRAGMENT_REPLACEMENTS);
    const outputMatch = source.match(ES300_FRAGMENT_OUTPUT_REGEX);
    if (outputMatch) {
      const outputName = outputMatch[1];
      source = source.replace(new RegExp("\\b".concat(ES100_FRAGMENT_OUTPUT_NAME, "\\b"), "g"), outputName);
    } else {
      const outputName = "fragmentColor";
      source = source.replace(REGEX_START_OF_MAIN2, (match) => "out vec4 ".concat(outputName, ";\n").concat(match)).replace(new RegExp("\\b".concat(ES100_FRAGMENT_OUTPUT_NAME, "\\b"), "g"), outputName);
    }
    return source;
  }
  function convertFragmentShaderTo100(source) {
    source = convertShader(source, ES100_FRAGMENT_REPLACEMENTS);
    const outputMatch = source.match(ES300_FRAGMENT_OUTPUT_REGEX);
    if (outputMatch) {
      const outputName = outputMatch[1];
      source = source.replace(ES300_FRAGMENT_OUTPUT_REGEX, "").replace(new RegExp("\\b".concat(outputName, "\\b"), "g"), ES100_FRAGMENT_OUTPUT_NAME);
    }
    return source;
  }

  // ../../node_modules/@luma.gl/shadertools/dist/esm/lib/assemble-shaders.js
  var INJECT_SHADER_DECLARATIONS = "\n\n".concat(DECLARATION_INJECT_MARKER, "\n\n");
  var SHADER_TYPE = {
    [VERTEX_SHADER]: "vertex",
    [FRAGMENT_SHADER]: "fragment"
  };
  var FRAGMENT_SHADER_PROLOGUE = "precision highp float;\n\n";
  function assembleShaders(gl, opts) {
    const {
      vs: vs2,
      fs: fs2
    } = opts;
    const modules = resolveModules(opts.modules || []);
    return {
      gl,
      vs: assembleShader(gl, Object.assign({}, opts, {
        source: vs2,
        type: VERTEX_SHADER,
        modules
      })),
      fs: assembleShader(gl, Object.assign({}, opts, {
        source: fs2,
        type: FRAGMENT_SHADER,
        modules
      })),
      getUniforms: assembleGetUniforms(modules)
    };
  }
  function assembleShader(gl, _ref) {
    let {
      id,
      source,
      type,
      modules,
      defines = {},
      hookFunctions = [],
      inject = {},
      transpileToGLSL100 = false,
      prologue = true,
      log: log5
    } = _ref;
    assert5(typeof source === "string", "shader source must be a string");
    const isVertex = type === VERTEX_SHADER;
    const sourceLines = source.split("\n");
    let glslVersion = 100;
    let versionLine = "";
    let coreSource = source;
    if (sourceLines[0].indexOf("#version ") === 0) {
      glslVersion = 300;
      versionLine = sourceLines[0];
      coreSource = sourceLines.slice(1).join("\n");
    } else {
      versionLine = "#version ".concat(glslVersion);
    }
    const allDefines = {};
    modules.forEach((module2) => {
      Object.assign(allDefines, module2.getDefines());
    });
    Object.assign(allDefines, defines);
    let assembledSource = prologue ? "".concat(versionLine, "\n").concat(getShaderName2({
      id,
      source,
      type
    }), "\n").concat(getShaderType({
      type
    }), "\n").concat(getPlatformShaderDefines(gl), "\n").concat(getVersionDefines(gl, glslVersion, !isVertex), "\n").concat(getApplicationDefines(allDefines), "\n").concat(isVertex ? "" : FRAGMENT_SHADER_PROLOGUE, "\n") : "".concat(versionLine, "\n");
    const hookFunctionMap = normalizeHookFunctions(hookFunctions);
    const hookInjections = {};
    const declInjections = {};
    const mainInjections = {};
    for (const key in inject) {
      const injection = typeof inject[key] === "string" ? {
        injection: inject[key],
        order: 0
      } : inject[key];
      const match = key.match(/^(v|f)s:(#)?([\w-]+)$/);
      if (match) {
        const hash = match[2];
        const name10 = match[3];
        if (hash) {
          if (name10 === "decl") {
            declInjections[key] = [injection];
          } else {
            mainInjections[key] = [injection];
          }
        } else {
          hookInjections[key] = [injection];
        }
      } else {
        mainInjections[key] = [injection];
      }
    }
    for (const module2 of modules) {
      if (log5) {
        module2.checkDeprecations(coreSource, log5);
      }
      const moduleSource = module2.getModuleSource(type, glslVersion);
      assembledSource += moduleSource;
      const injections = module2.injections[type];
      for (const key in injections) {
        const match = key.match(/^(v|f)s:#([\w-]+)$/);
        if (match) {
          const name10 = match[2];
          const injectionType = name10 === "decl" ? declInjections : mainInjections;
          injectionType[key] = injectionType[key] || [];
          injectionType[key].push(injections[key]);
        } else {
          hookInjections[key] = hookInjections[key] || [];
          hookInjections[key].push(injections[key]);
        }
      }
    }
    assembledSource += INJECT_SHADER_DECLARATIONS;
    assembledSource = injectShader(assembledSource, type, declInjections);
    assembledSource += getHookFunctions(hookFunctionMap[type], hookInjections);
    assembledSource += coreSource;
    assembledSource = injectShader(assembledSource, type, mainInjections);
    assembledSource = transpileShader(assembledSource, transpileToGLSL100 ? 100 : glslVersion, isVertex);
    return assembledSource;
  }
  function assembleGetUniforms(modules) {
    return function getUniforms2(opts) {
      const uniforms = {};
      for (const module2 of modules) {
        const moduleUniforms = module2.getUniforms(opts, uniforms);
        Object.assign(uniforms, moduleUniforms);
      }
      return uniforms;
    };
  }
  function getShaderType(_ref2) {
    let {
      type
    } = _ref2;
    return "\n#define SHADER_TYPE_".concat(SHADER_TYPE[type].toUpperCase(), "\n");
  }
  function getShaderName2(_ref3) {
    let {
      id,
      source,
      type
    } = _ref3;
    const injectShaderName = id && typeof id === "string" && source.indexOf("SHADER_NAME") === -1;
    return injectShaderName ? "\n#define SHADER_NAME ".concat(id, "_").concat(SHADER_TYPE[type], "\n\n") : "";
  }
  function getApplicationDefines() {
    let defines = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let count = 0;
    let sourceText = "";
    for (const define in defines) {
      if (count === 0) {
        sourceText += "\n// APPLICATION DEFINES\n";
      }
      count++;
      const value = defines[define];
      if (value || Number.isFinite(value)) {
        sourceText += "#define ".concat(define.toUpperCase(), " ").concat(defines[define], "\n");
      }
    }
    if (count === 0) {
      sourceText += "\n";
    }
    return sourceText;
  }
  function getHookFunctions(hookFunctions, hookInjections) {
    let result = "";
    for (const hookName in hookFunctions) {
      const hookFunction = hookFunctions[hookName];
      result += "void ".concat(hookFunction.signature, " {\n");
      if (hookFunction.header) {
        result += "  ".concat(hookFunction.header);
      }
      if (hookInjections[hookName]) {
        const injections = hookInjections[hookName];
        injections.sort((a2, b) => a2.order - b.order);
        for (const injection of injections) {
          result += "  ".concat(injection.injection, "\n");
        }
      }
      if (hookFunction.footer) {
        result += "  ".concat(hookFunction.footer);
      }
      result += "}\n";
    }
    return result;
  }
  function normalizeHookFunctions(hookFunctions) {
    const result = {
      vs: {},
      fs: {}
    };
    hookFunctions.forEach((hook) => {
      let opts;
      if (typeof hook !== "string") {
        opts = hook;
        hook = opts.hook;
      } else {
        opts = {};
      }
      hook = hook.trim();
      const [stage, signature] = hook.split(":");
      const name10 = hook.replace(/\(.+/, "");
      result[stage][name10] = Object.assign(opts, {
        signature
      });
    });
    return result;
  }

  // ../../node_modules/@math.gl/core/dist/esm/lib/assert.js
  function assert6(condition, message) {
    if (!condition) {
      throw new Error("math.gl assertion ".concat(message));
    }
  }

  // ../../node_modules/@math.gl/core/dist/esm/lib/common.js
  var RADIANS_TO_DEGREES = 1 / Math.PI * 180;
  var DEGREES_TO_RADIANS = 1 / 180 * Math.PI;
  var config = {
    EPSILON: 1e-12,
    debug: false,
    precision: 4,
    printTypes: false,
    printDegrees: false,
    printRowMajor: true
  };
  function formatValue2(value, {
    precision = config.precision
  } = {}) {
    value = round(value);
    return "".concat(parseFloat(value.toPrecision(precision)));
  }
  function isArray2(value) {
    return Array.isArray(value) || ArrayBuffer.isView(value) && !(value instanceof DataView);
  }
  function equals(a2, b, epsilon) {
    const oldEpsilon = config.EPSILON;
    if (epsilon) {
      config.EPSILON = epsilon;
    }
    try {
      if (a2 === b) {
        return true;
      }
      if (isArray2(a2) && isArray2(b)) {
        if (a2.length !== b.length) {
          return false;
        }
        for (let i2 = 0; i2 < a2.length; ++i2) {
          if (!equals(a2[i2], b[i2])) {
            return false;
          }
        }
        return true;
      }
      if (a2 && a2.equals) {
        return a2.equals(b);
      }
      if (b && b.equals) {
        return b.equals(a2);
      }
      if (typeof a2 === "number" && typeof b === "number") {
        return Math.abs(a2 - b) <= config.EPSILON * Math.max(1, Math.abs(a2), Math.abs(b));
      }
      return false;
    } finally {
      config.EPSILON = oldEpsilon;
    }
  }
  function round(value) {
    return Math.round(value / config.EPSILON) * config.EPSILON;
  }

  // ../../node_modules/@math.gl/core/dist/esm/classes/base/math-array.js
  function _extendableBuiltin(cls) {
    function ExtendableBuiltin() {
      var instance = Reflect.construct(cls, Array.from(arguments));
      Object.setPrototypeOf(instance, Object.getPrototypeOf(this));
      return instance;
    }
    ExtendableBuiltin.prototype = Object.create(cls.prototype, {
      constructor: {
        value: cls,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(ExtendableBuiltin, cls);
    } else {
      ExtendableBuiltin.__proto__ = cls;
    }
    return ExtendableBuiltin;
  }
  var MathArray = class extends _extendableBuiltin(Array) {
    clone() {
      return new this.constructor().copy(this);
    }
    fromArray(array, offset = 0) {
      for (let i2 = 0; i2 < this.ELEMENTS; ++i2) {
        this[i2] = array[i2 + offset];
      }
      return this.check();
    }
    toArray(targetArray = [], offset = 0) {
      for (let i2 = 0; i2 < this.ELEMENTS; ++i2) {
        targetArray[offset + i2] = this[i2];
      }
      return targetArray;
    }
    from(arrayOrObject) {
      return Array.isArray(arrayOrObject) ? this.copy(arrayOrObject) : this.fromObject(arrayOrObject);
    }
    to(arrayOrObject) {
      if (arrayOrObject === this) {
        return this;
      }
      return isArray2(arrayOrObject) ? this.toArray(arrayOrObject) : this.toObject(arrayOrObject);
    }
    toTarget(target) {
      return target ? this.to(target) : this;
    }
    toFloat32Array() {
      return new Float32Array(this);
    }
    toString() {
      return this.formatString(config);
    }
    formatString(opts) {
      let string = "";
      for (let i2 = 0; i2 < this.ELEMENTS; ++i2) {
        string += (i2 > 0 ? ", " : "") + formatValue2(this[i2], opts);
      }
      return "".concat(opts.printTypes ? this.constructor.name : "", "[").concat(string, "]");
    }
    equals(array) {
      if (!array || this.length !== array.length) {
        return false;
      }
      for (let i2 = 0; i2 < this.ELEMENTS; ++i2) {
        if (!equals(this[i2], array[i2])) {
          return false;
        }
      }
      return true;
    }
    exactEquals(array) {
      if (!array || this.length !== array.length) {
        return false;
      }
      for (let i2 = 0; i2 < this.ELEMENTS; ++i2) {
        if (this[i2] !== array[i2]) {
          return false;
        }
      }
      return true;
    }
    negate() {
      for (let i2 = 0; i2 < this.ELEMENTS; ++i2) {
        this[i2] = -this[i2];
      }
      return this.check();
    }
    lerp(a2, b, t2) {
      if (t2 === void 0) {
        return this.lerp(this, a2, b);
      }
      for (let i2 = 0; i2 < this.ELEMENTS; ++i2) {
        const ai = a2[i2];
        this[i2] = ai + t2 * (b[i2] - ai);
      }
      return this.check();
    }
    min(vector) {
      for (let i2 = 0; i2 < this.ELEMENTS; ++i2) {
        this[i2] = Math.min(vector[i2], this[i2]);
      }
      return this.check();
    }
    max(vector) {
      for (let i2 = 0; i2 < this.ELEMENTS; ++i2) {
        this[i2] = Math.max(vector[i2], this[i2]);
      }
      return this.check();
    }
    clamp(minVector, maxVector) {
      for (let i2 = 0; i2 < this.ELEMENTS; ++i2) {
        this[i2] = Math.min(Math.max(this[i2], minVector[i2]), maxVector[i2]);
      }
      return this.check();
    }
    add(...vectors) {
      for (const vector of vectors) {
        for (let i2 = 0; i2 < this.ELEMENTS; ++i2) {
          this[i2] += vector[i2];
        }
      }
      return this.check();
    }
    subtract(...vectors) {
      for (const vector of vectors) {
        for (let i2 = 0; i2 < this.ELEMENTS; ++i2) {
          this[i2] -= vector[i2];
        }
      }
      return this.check();
    }
    scale(scale5) {
      if (typeof scale5 === "number") {
        for (let i2 = 0; i2 < this.ELEMENTS; ++i2) {
          this[i2] *= scale5;
        }
      } else {
        for (let i2 = 0; i2 < this.ELEMENTS && i2 < scale5.length; ++i2) {
          this[i2] *= scale5[i2];
        }
      }
      return this.check();
    }
    multiplyByScalar(scalar) {
      for (let i2 = 0; i2 < this.ELEMENTS; ++i2) {
        this[i2] *= scalar;
      }
      return this.check();
    }
    check() {
      if (config.debug && !this.validate()) {
        throw new Error("math.gl: ".concat(this.constructor.name, " some fields set to invalid numbers'"));
      }
      return this;
    }
    validate() {
      let valid = this.length === this.ELEMENTS;
      for (let i2 = 0; i2 < this.ELEMENTS; ++i2) {
        valid = valid && Number.isFinite(this[i2]);
      }
      return valid;
    }
    sub(a2) {
      return this.subtract(a2);
    }
    setScalar(a2) {
      for (let i2 = 0; i2 < this.ELEMENTS; ++i2) {
        this[i2] = a2;
      }
      return this.check();
    }
    addScalar(a2) {
      for (let i2 = 0; i2 < this.ELEMENTS; ++i2) {
        this[i2] += a2;
      }
      return this.check();
    }
    subScalar(a2) {
      return this.addScalar(-a2);
    }
    multiplyScalar(scalar) {
      for (let i2 = 0; i2 < this.ELEMENTS; ++i2) {
        this[i2] *= scalar;
      }
      return this.check();
    }
    divideScalar(a2) {
      return this.multiplyByScalar(1 / a2);
    }
    clampScalar(min, max) {
      for (let i2 = 0; i2 < this.ELEMENTS; ++i2) {
        this[i2] = Math.min(Math.max(this[i2], min), max);
      }
      return this.check();
    }
    get elements() {
      return this;
    }
  };

  // ../../node_modules/@math.gl/core/dist/esm/lib/validators.js
  function validateVector(v, length4) {
    if (v.length !== length4) {
      return false;
    }
    for (let i2 = 0; i2 < v.length; ++i2) {
      if (!Number.isFinite(v[i2])) {
        return false;
      }
    }
    return true;
  }
  function checkNumber(value) {
    if (!Number.isFinite(value)) {
      throw new Error("Invalid number ".concat(value));
    }
    return value;
  }
  function checkVector(v, length4, callerName = "") {
    if (config.debug && !validateVector(v, length4)) {
      throw new Error("math.gl: ".concat(callerName, " some fields set to invalid numbers'"));
    }
    return v;
  }

  // ../../node_modules/@math.gl/core/dist/esm/classes/base/vector.js
  var Vector = class extends MathArray {
    get x() {
      return this[0];
    }
    set x(value) {
      this[0] = checkNumber(value);
    }
    get y() {
      return this[1];
    }
    set y(value) {
      this[1] = checkNumber(value);
    }
    len() {
      return Math.sqrt(this.lengthSquared());
    }
    magnitude() {
      return this.len();
    }
    lengthSquared() {
      let length4 = 0;
      for (let i2 = 0; i2 < this.ELEMENTS; ++i2) {
        length4 += this[i2] * this[i2];
      }
      return length4;
    }
    magnitudeSquared() {
      return this.lengthSquared();
    }
    distance(mathArray) {
      return Math.sqrt(this.distanceSquared(mathArray));
    }
    distanceSquared(mathArray) {
      let length4 = 0;
      for (let i2 = 0; i2 < this.ELEMENTS; ++i2) {
        const dist = this[i2] - mathArray[i2];
        length4 += dist * dist;
      }
      return checkNumber(length4);
    }
    dot(mathArray) {
      let product = 0;
      for (let i2 = 0; i2 < this.ELEMENTS; ++i2) {
        product += this[i2] * mathArray[i2];
      }
      return checkNumber(product);
    }
    normalize() {
      const length4 = this.magnitude();
      if (length4 !== 0) {
        for (let i2 = 0; i2 < this.ELEMENTS; ++i2) {
          this[i2] /= length4;
        }
      }
      return this.check();
    }
    multiply(...vectors) {
      for (const vector of vectors) {
        for (let i2 = 0; i2 < this.ELEMENTS; ++i2) {
          this[i2] *= vector[i2];
        }
      }
      return this.check();
    }
    divide(...vectors) {
      for (const vector of vectors) {
        for (let i2 = 0; i2 < this.ELEMENTS; ++i2) {
          this[i2] /= vector[i2];
        }
      }
      return this.check();
    }
    lengthSq() {
      return this.lengthSquared();
    }
    distanceTo(vector) {
      return this.distance(vector);
    }
    distanceToSquared(vector) {
      return this.distanceSquared(vector);
    }
    getComponent(i2) {
      assert6(i2 >= 0 && i2 < this.ELEMENTS, "index is out of range");
      return checkNumber(this[i2]);
    }
    setComponent(i2, value) {
      assert6(i2 >= 0 && i2 < this.ELEMENTS, "index is out of range");
      this[i2] = value;
      return this.check();
    }
    addVectors(a2, b) {
      return this.copy(a2).add(b);
    }
    subVectors(a2, b) {
      return this.copy(a2).subtract(b);
    }
    multiplyVectors(a2, b) {
      return this.copy(a2).multiply(b);
    }
    addScaledVector(a2, b) {
      return this.add(new this.constructor(a2).multiplyScalar(b));
    }
  };

  // ../../node_modules/gl-matrix/esm/common.js
  var EPSILON = 1e-6;
  var ARRAY_TYPE = typeof Float32Array !== "undefined" ? Float32Array : Array;
  var degree = Math.PI / 180;
  if (!Math.hypot)
    Math.hypot = function() {
      var y = 0, i2 = arguments.length;
      while (i2--) {
        y += arguments[i2] * arguments[i2];
      }
      return Math.sqrt(y);
    };

  // ../../node_modules/gl-matrix/esm/vec2.js
  function create() {
    var out = new ARRAY_TYPE(2);
    if (ARRAY_TYPE != Float32Array) {
      out[0] = 0;
      out[1] = 0;
    }
    return out;
  }
  function transformMat3(out, a2, m) {
    var x = a2[0], y = a2[1];
    out[0] = m[0] * x + m[3] * y + m[6];
    out[1] = m[1] * x + m[4] * y + m[7];
    return out;
  }
  function transformMat4(out, a2, m) {
    var x = a2[0];
    var y = a2[1];
    out[0] = m[0] * x + m[4] * y + m[12];
    out[1] = m[1] * x + m[5] * y + m[13];
    return out;
  }
  var forEach = function() {
    var vec = create();
    return function(a2, stride, offset, count, fn, arg) {
      var i2, l2;
      if (!stride) {
        stride = 2;
      }
      if (!offset) {
        offset = 0;
      }
      if (count) {
        l2 = Math.min(count * stride + offset, a2.length);
      } else {
        l2 = a2.length;
      }
      for (i2 = offset; i2 < l2; i2 += stride) {
        vec[0] = a2[i2];
        vec[1] = a2[i2 + 1];
        fn(vec, vec, arg);
        a2[i2] = vec[0];
        a2[i2 + 1] = vec[1];
      }
      return a2;
    };
  }();

  // ../../node_modules/@math.gl/core/dist/esm/lib/gl-matrix-extras.js
  function vec2_transformMat4AsVector(out, a2, m) {
    const x = a2[0];
    const y = a2[1];
    const w = m[3] * x + m[7] * y || 1;
    out[0] = (m[0] * x + m[4] * y) / w;
    out[1] = (m[1] * x + m[5] * y) / w;
    return out;
  }
  function vec3_transformMat4AsVector(out, a2, m) {
    const x = a2[0];
    const y = a2[1];
    const z = a2[2];
    const w = m[3] * x + m[7] * y + m[11] * z || 1;
    out[0] = (m[0] * x + m[4] * y + m[8] * z) / w;
    out[1] = (m[1] * x + m[5] * y + m[9] * z) / w;
    out[2] = (m[2] * x + m[6] * y + m[10] * z) / w;
    return out;
  }
  function vec3_transformMat2(out, a2, m) {
    const x = a2[0];
    const y = a2[1];
    out[0] = m[0] * x + m[2] * y;
    out[1] = m[1] * x + m[3] * y;
    out[2] = a2[2];
    return out;
  }
  function vec4_transformMat2(out, a2, m) {
    const x = a2[0];
    const y = a2[1];
    out[0] = m[0] * x + m[2] * y;
    out[1] = m[1] * x + m[3] * y;
    out[2] = a2[2];
    out[3] = a2[3];
    return out;
  }
  function vec4_transformMat3(out, a2, m) {
    const x = a2[0];
    const y = a2[1];
    const z = a2[2];
    out[0] = m[0] * x + m[3] * y + m[6] * z;
    out[1] = m[1] * x + m[4] * y + m[7] * z;
    out[2] = m[2] * x + m[5] * y + m[8] * z;
    out[3] = a2[3];
    return out;
  }

  // ../../node_modules/gl-matrix/esm/vec3.js
  function create2() {
    var out = new ARRAY_TYPE(3);
    if (ARRAY_TYPE != Float32Array) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
    }
    return out;
  }
  function length(a2) {
    var x = a2[0];
    var y = a2[1];
    var z = a2[2];
    return Math.hypot(x, y, z);
  }
  function fromValues(x, y, z) {
    var out = new ARRAY_TYPE(3);
    out[0] = x;
    out[1] = y;
    out[2] = z;
    return out;
  }
  function normalize(out, a2) {
    var x = a2[0];
    var y = a2[1];
    var z = a2[2];
    var len2 = x * x + y * y + z * z;
    if (len2 > 0) {
      len2 = 1 / Math.sqrt(len2);
    }
    out[0] = a2[0] * len2;
    out[1] = a2[1] * len2;
    out[2] = a2[2] * len2;
    return out;
  }
  function dot(a2, b) {
    return a2[0] * b[0] + a2[1] * b[1] + a2[2] * b[2];
  }
  function cross(out, a2, b) {
    var ax = a2[0], ay = a2[1], az = a2[2];
    var bx = b[0], by = b[1], bz = b[2];
    out[0] = ay * bz - az * by;
    out[1] = az * bx - ax * bz;
    out[2] = ax * by - ay * bx;
    return out;
  }
  function transformMat42(out, a2, m) {
    var x = a2[0], y = a2[1], z = a2[2];
    var w = m[3] * x + m[7] * y + m[11] * z + m[15];
    w = w || 1;
    out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
    out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
    out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
    return out;
  }
  function transformMat32(out, a2, m) {
    var x = a2[0], y = a2[1], z = a2[2];
    out[0] = x * m[0] + y * m[3] + z * m[6];
    out[1] = x * m[1] + y * m[4] + z * m[7];
    out[2] = x * m[2] + y * m[5] + z * m[8];
    return out;
  }
  function transformQuat(out, a2, q) {
    var qx = q[0], qy = q[1], qz = q[2], qw = q[3];
    var x = a2[0], y = a2[1], z = a2[2];
    var uvx = qy * z - qz * y, uvy = qz * x - qx * z, uvz = qx * y - qy * x;
    var uuvx = qy * uvz - qz * uvy, uuvy = qz * uvx - qx * uvz, uuvz = qx * uvy - qy * uvx;
    var w2 = qw * 2;
    uvx *= w2;
    uvy *= w2;
    uvz *= w2;
    uuvx *= 2;
    uuvy *= 2;
    uuvz *= 2;
    out[0] = x + uvx + uuvx;
    out[1] = y + uvy + uuvy;
    out[2] = z + uvz + uuvz;
    return out;
  }
  function rotateX(out, a2, b, rad) {
    var p2 = [], r2 = [];
    p2[0] = a2[0] - b[0];
    p2[1] = a2[1] - b[1];
    p2[2] = a2[2] - b[2];
    r2[0] = p2[0];
    r2[1] = p2[1] * Math.cos(rad) - p2[2] * Math.sin(rad);
    r2[2] = p2[1] * Math.sin(rad) + p2[2] * Math.cos(rad);
    out[0] = r2[0] + b[0];
    out[1] = r2[1] + b[1];
    out[2] = r2[2] + b[2];
    return out;
  }
  function rotateY(out, a2, b, rad) {
    var p2 = [], r2 = [];
    p2[0] = a2[0] - b[0];
    p2[1] = a2[1] - b[1];
    p2[2] = a2[2] - b[2];
    r2[0] = p2[2] * Math.sin(rad) + p2[0] * Math.cos(rad);
    r2[1] = p2[1];
    r2[2] = p2[2] * Math.cos(rad) - p2[0] * Math.sin(rad);
    out[0] = r2[0] + b[0];
    out[1] = r2[1] + b[1];
    out[2] = r2[2] + b[2];
    return out;
  }
  function rotateZ(out, a2, b, rad) {
    var p2 = [], r2 = [];
    p2[0] = a2[0] - b[0];
    p2[1] = a2[1] - b[1];
    p2[2] = a2[2] - b[2];
    r2[0] = p2[0] * Math.cos(rad) - p2[1] * Math.sin(rad);
    r2[1] = p2[0] * Math.sin(rad) + p2[1] * Math.cos(rad);
    r2[2] = p2[2];
    out[0] = r2[0] + b[0];
    out[1] = r2[1] + b[1];
    out[2] = r2[2] + b[2];
    return out;
  }
  function angle(a2, b) {
    var ax = a2[0], ay = a2[1], az = a2[2], bx = b[0], by = b[1], bz = b[2], mag1 = Math.sqrt(ax * ax + ay * ay + az * az), mag2 = Math.sqrt(bx * bx + by * by + bz * bz), mag = mag1 * mag2, cosine = mag && dot(a2, b) / mag;
    return Math.acos(Math.min(Math.max(cosine, -1), 1));
  }
  var len = length;
  var forEach2 = function() {
    var vec = create2();
    return function(a2, stride, offset, count, fn, arg) {
      var i2, l2;
      if (!stride) {
        stride = 3;
      }
      if (!offset) {
        offset = 0;
      }
      if (count) {
        l2 = Math.min(count * stride + offset, a2.length);
      } else {
        l2 = a2.length;
      }
      for (i2 = offset; i2 < l2; i2 += stride) {
        vec[0] = a2[i2];
        vec[1] = a2[i2 + 1];
        vec[2] = a2[i2 + 2];
        fn(vec, vec, arg);
        a2[i2] = vec[0];
        a2[i2 + 1] = vec[1];
        a2[i2 + 2] = vec[2];
      }
      return a2;
    };
  }();

  // ../../node_modules/@math.gl/core/dist/esm/classes/vector3.js
  var ORIGIN = [0, 0, 0];
  var ZERO;
  var Vector3 = class extends Vector {
    static get ZERO() {
      if (!ZERO) {
        ZERO = new Vector3(0, 0, 0);
        Object.freeze(ZERO);
      }
      return ZERO;
    }
    constructor(x = 0, y = 0, z = 0) {
      super(-0, -0, -0);
      if (arguments.length === 1 && isArray2(x)) {
        this.copy(x);
      } else {
        if (config.debug) {
          checkNumber(x);
          checkNumber(y);
          checkNumber(z);
        }
        this[0] = x;
        this[1] = y;
        this[2] = z;
      }
    }
    set(x, y, z) {
      this[0] = x;
      this[1] = y;
      this[2] = z;
      return this.check();
    }
    copy(array) {
      this[0] = array[0];
      this[1] = array[1];
      this[2] = array[2];
      return this.check();
    }
    fromObject(object) {
      if (config.debug) {
        checkNumber(object.x);
        checkNumber(object.y);
        checkNumber(object.z);
      }
      this[0] = object.x;
      this[1] = object.y;
      this[2] = object.z;
      return this.check();
    }
    toObject(object) {
      object.x = this[0];
      object.y = this[1];
      object.z = this[2];
      return object;
    }
    get ELEMENTS() {
      return 3;
    }
    get z() {
      return this[2];
    }
    set z(value) {
      this[2] = checkNumber(value);
    }
    angle(vector) {
      return angle(this, vector);
    }
    cross(vector) {
      cross(this, this, vector);
      return this.check();
    }
    rotateX({
      radians,
      origin = ORIGIN
    }) {
      rotateX(this, this, origin, radians);
      return this.check();
    }
    rotateY({
      radians,
      origin = ORIGIN
    }) {
      rotateY(this, this, origin, radians);
      return this.check();
    }
    rotateZ({
      radians,
      origin = ORIGIN
    }) {
      rotateZ(this, this, origin, radians);
      return this.check();
    }
    transform(matrix4) {
      return this.transformAsPoint(matrix4);
    }
    transformAsPoint(matrix4) {
      transformMat42(this, this, matrix4);
      return this.check();
    }
    transformAsVector(matrix4) {
      vec3_transformMat4AsVector(this, this, matrix4);
      return this.check();
    }
    transformByMatrix3(matrix3) {
      transformMat32(this, this, matrix3);
      return this.check();
    }
    transformByMatrix2(matrix2) {
      vec3_transformMat2(this, this, matrix2);
      return this.check();
    }
    transformByQuaternion(quaternion2) {
      transformQuat(this, this, quaternion2);
      return this.check();
    }
  };

  // ../../node_modules/@math.gl/core/dist/esm/classes/vector4.js
  var ZERO2;
  var Vector4 = class extends Vector {
    static get ZERO() {
      if (!ZERO2) {
        ZERO2 = new Vector4(0, 0, 0, 0);
        Object.freeze(ZERO2);
      }
      return ZERO2;
    }
    constructor(x = 0, y = 0, z = 0, w = 0) {
      super(-0, -0, -0, -0);
      if (isArray2(x) && arguments.length === 1) {
        this.copy(x);
      } else {
        if (config.debug) {
          checkNumber(x);
          checkNumber(y);
          checkNumber(z);
          checkNumber(w);
        }
        this[0] = x;
        this[1] = y;
        this[2] = z;
        this[3] = w;
      }
    }
    set(x, y, z, w) {
      this[0] = x;
      this[1] = y;
      this[2] = z;
      this[3] = w;
      return this.check();
    }
    copy(array) {
      this[0] = array[0];
      this[1] = array[1];
      this[2] = array[2];
      this[3] = array[3];
      return this.check();
    }
    fromObject(object) {
      if (config.debug) {
        checkNumber(object.x);
        checkNumber(object.y);
        checkNumber(object.z);
        checkNumber(object.w);
      }
      this[0] = object.x;
      this[1] = object.y;
      this[2] = object.z;
      this[3] = object.w;
      return this;
    }
    toObject(object) {
      object.x = this[0];
      object.y = this[1];
      object.z = this[2];
      object.w = this[3];
      return object;
    }
    get ELEMENTS() {
      return 4;
    }
    get z() {
      return this[2];
    }
    set z(value) {
      this[2] = checkNumber(value);
    }
    get w() {
      return this[3];
    }
    set w(value) {
      this[3] = checkNumber(value);
    }
    transform(matrix4) {
      transformMat42(this, this, matrix4);
      return this.check();
    }
    transformByMatrix3(matrix3) {
      vec4_transformMat3(this, this, matrix3);
      return this.check();
    }
    transformByMatrix2(matrix2) {
      vec4_transformMat2(this, this, matrix2);
      return this.check();
    }
    transformByQuaternion(quaternion2) {
      transformQuat(this, this, quaternion2);
      return this.check();
    }
    applyMatrix4(m) {
      m.transform(this, this);
      return this;
    }
  };

  // ../../node_modules/@math.gl/core/dist/esm/classes/base/matrix.js
  var Matrix = class extends MathArray {
    toString() {
      let string = "[";
      if (config.printRowMajor) {
        string += "row-major:";
        for (let row = 0; row < this.RANK; ++row) {
          for (let col = 0; col < this.RANK; ++col) {
            string += " ".concat(this[col * this.RANK + row]);
          }
        }
      } else {
        string += "column-major:";
        for (let i2 = 0; i2 < this.ELEMENTS; ++i2) {
          string += " ".concat(this[i2]);
        }
      }
      string += "]";
      return string;
    }
    getElementIndex(row, col) {
      return col * this.RANK + row;
    }
    getElement(row, col) {
      return this[col * this.RANK + row];
    }
    setElement(row, col, value) {
      this[col * this.RANK + row] = checkNumber(value);
      return this;
    }
    getColumn(columnIndex, result = new Array(this.RANK).fill(-0)) {
      const firstIndex = columnIndex * this.RANK;
      for (let i2 = 0; i2 < this.RANK; ++i2) {
        result[i2] = this[firstIndex + i2];
      }
      return result;
    }
    setColumn(columnIndex, columnVector) {
      const firstIndex = columnIndex * this.RANK;
      for (let i2 = 0; i2 < this.RANK; ++i2) {
        this[firstIndex + i2] = columnVector[i2];
      }
      return this;
    }
  };

  // ../../node_modules/gl-matrix/esm/mat3.js
  function create3() {
    var out = new ARRAY_TYPE(9);
    if (ARRAY_TYPE != Float32Array) {
      out[1] = 0;
      out[2] = 0;
      out[3] = 0;
      out[5] = 0;
      out[6] = 0;
      out[7] = 0;
    }
    out[0] = 1;
    out[4] = 1;
    out[8] = 1;
    return out;
  }
  function transpose(out, a2) {
    if (out === a2) {
      var a01 = a2[1], a02 = a2[2], a12 = a2[5];
      out[1] = a2[3];
      out[2] = a2[6];
      out[3] = a01;
      out[5] = a2[7];
      out[6] = a02;
      out[7] = a12;
    } else {
      out[0] = a2[0];
      out[1] = a2[3];
      out[2] = a2[6];
      out[3] = a2[1];
      out[4] = a2[4];
      out[5] = a2[7];
      out[6] = a2[2];
      out[7] = a2[5];
      out[8] = a2[8];
    }
    return out;
  }
  function invert(out, a2) {
    var a00 = a2[0], a01 = a2[1], a02 = a2[2];
    var a10 = a2[3], a11 = a2[4], a12 = a2[5];
    var a20 = a2[6], a21 = a2[7], a22 = a2[8];
    var b01 = a22 * a11 - a12 * a21;
    var b11 = -a22 * a10 + a12 * a20;
    var b21 = a21 * a10 - a11 * a20;
    var det = a00 * b01 + a01 * b11 + a02 * b21;
    if (!det) {
      return null;
    }
    det = 1 / det;
    out[0] = b01 * det;
    out[1] = (-a22 * a01 + a02 * a21) * det;
    out[2] = (a12 * a01 - a02 * a11) * det;
    out[3] = b11 * det;
    out[4] = (a22 * a00 - a02 * a20) * det;
    out[5] = (-a12 * a00 + a02 * a10) * det;
    out[6] = b21 * det;
    out[7] = (-a21 * a00 + a01 * a20) * det;
    out[8] = (a11 * a00 - a01 * a10) * det;
    return out;
  }
  function determinant(a2) {
    var a00 = a2[0], a01 = a2[1], a02 = a2[2];
    var a10 = a2[3], a11 = a2[4], a12 = a2[5];
    var a20 = a2[6], a21 = a2[7], a22 = a2[8];
    return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
  }
  function multiply(out, a2, b) {
    var a00 = a2[0], a01 = a2[1], a02 = a2[2];
    var a10 = a2[3], a11 = a2[4], a12 = a2[5];
    var a20 = a2[6], a21 = a2[7], a22 = a2[8];
    var b00 = b[0], b01 = b[1], b02 = b[2];
    var b10 = b[3], b11 = b[4], b12 = b[5];
    var b20 = b[6], b21 = b[7], b22 = b[8];
    out[0] = b00 * a00 + b01 * a10 + b02 * a20;
    out[1] = b00 * a01 + b01 * a11 + b02 * a21;
    out[2] = b00 * a02 + b01 * a12 + b02 * a22;
    out[3] = b10 * a00 + b11 * a10 + b12 * a20;
    out[4] = b10 * a01 + b11 * a11 + b12 * a21;
    out[5] = b10 * a02 + b11 * a12 + b12 * a22;
    out[6] = b20 * a00 + b21 * a10 + b22 * a20;
    out[7] = b20 * a01 + b21 * a11 + b22 * a21;
    out[8] = b20 * a02 + b21 * a12 + b22 * a22;
    return out;
  }
  function translate(out, a2, v) {
    var a00 = a2[0], a01 = a2[1], a02 = a2[2], a10 = a2[3], a11 = a2[4], a12 = a2[5], a20 = a2[6], a21 = a2[7], a22 = a2[8], x = v[0], y = v[1];
    out[0] = a00;
    out[1] = a01;
    out[2] = a02;
    out[3] = a10;
    out[4] = a11;
    out[5] = a12;
    out[6] = x * a00 + y * a10 + a20;
    out[7] = x * a01 + y * a11 + a21;
    out[8] = x * a02 + y * a12 + a22;
    return out;
  }
  function rotate(out, a2, rad) {
    var a00 = a2[0], a01 = a2[1], a02 = a2[2], a10 = a2[3], a11 = a2[4], a12 = a2[5], a20 = a2[6], a21 = a2[7], a22 = a2[8], s2 = Math.sin(rad), c = Math.cos(rad);
    out[0] = c * a00 + s2 * a10;
    out[1] = c * a01 + s2 * a11;
    out[2] = c * a02 + s2 * a12;
    out[3] = c * a10 - s2 * a00;
    out[4] = c * a11 - s2 * a01;
    out[5] = c * a12 - s2 * a02;
    out[6] = a20;
    out[7] = a21;
    out[8] = a22;
    return out;
  }
  function scale(out, a2, v) {
    var x = v[0], y = v[1];
    out[0] = x * a2[0];
    out[1] = x * a2[1];
    out[2] = x * a2[2];
    out[3] = y * a2[3];
    out[4] = y * a2[4];
    out[5] = y * a2[5];
    out[6] = a2[6];
    out[7] = a2[7];
    out[8] = a2[8];
    return out;
  }
  function fromQuat(out, q) {
    var x = q[0], y = q[1], z = q[2], w = q[3];
    var x2 = x + x;
    var y2 = y + y;
    var z2 = z + z;
    var xx = x * x2;
    var yx = y * x2;
    var yy = y * y2;
    var zx = z * x2;
    var zy = z * y2;
    var zz = z * z2;
    var wx = w * x2;
    var wy = w * y2;
    var wz = w * z2;
    out[0] = 1 - yy - zz;
    out[3] = yx - wz;
    out[6] = zx + wy;
    out[1] = yx + wz;
    out[4] = 1 - xx - zz;
    out[7] = zy - wx;
    out[2] = zx - wy;
    out[5] = zy + wx;
    out[8] = 1 - xx - yy;
    return out;
  }

  // ../../node_modules/@math.gl/core/dist/esm/classes/matrix3.js
  var INDICES;
  (function(INDICES3) {
    INDICES3[INDICES3["COL0ROW0"] = 0] = "COL0ROW0";
    INDICES3[INDICES3["COL0ROW1"] = 1] = "COL0ROW1";
    INDICES3[INDICES3["COL0ROW2"] = 2] = "COL0ROW2";
    INDICES3[INDICES3["COL1ROW0"] = 3] = "COL1ROW0";
    INDICES3[INDICES3["COL1ROW1"] = 4] = "COL1ROW1";
    INDICES3[INDICES3["COL1ROW2"] = 5] = "COL1ROW2";
    INDICES3[INDICES3["COL2ROW0"] = 6] = "COL2ROW0";
    INDICES3[INDICES3["COL2ROW1"] = 7] = "COL2ROW1";
    INDICES3[INDICES3["COL2ROW2"] = 8] = "COL2ROW2";
  })(INDICES || (INDICES = {}));
  var IDENTITY_MATRIX = Object.freeze([1, 0, 0, 0, 1, 0, 0, 0, 1]);
  var Matrix3 = class extends Matrix {
    static get IDENTITY() {
      return getIdentityMatrix();
    }
    static get ZERO() {
      return getZeroMatrix();
    }
    get ELEMENTS() {
      return 9;
    }
    get RANK() {
      return 3;
    }
    get INDICES() {
      return INDICES;
    }
    constructor(array, ...args) {
      super(-0, -0, -0, -0, -0, -0, -0, -0, -0);
      if (arguments.length === 1 && Array.isArray(array)) {
        this.copy(array);
      } else if (args.length > 0) {
        this.copy([array, ...args]);
      } else {
        this.identity();
      }
    }
    copy(array) {
      this[0] = array[0];
      this[1] = array[1];
      this[2] = array[2];
      this[3] = array[3];
      this[4] = array[4];
      this[5] = array[5];
      this[6] = array[6];
      this[7] = array[7];
      this[8] = array[8];
      return this.check();
    }
    identity() {
      return this.copy(IDENTITY_MATRIX);
    }
    fromObject(object) {
      return this.check();
    }
    fromQuaternion(q) {
      fromQuat(this, q);
      return this.check();
    }
    set(m00, m10, m20, m01, m11, m21, m02, m12, m22) {
      this[0] = m00;
      this[1] = m10;
      this[2] = m20;
      this[3] = m01;
      this[4] = m11;
      this[5] = m21;
      this[6] = m02;
      this[7] = m12;
      this[8] = m22;
      return this.check();
    }
    setRowMajor(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
      this[0] = m00;
      this[1] = m10;
      this[2] = m20;
      this[3] = m01;
      this[4] = m11;
      this[5] = m21;
      this[6] = m02;
      this[7] = m12;
      this[8] = m22;
      return this.check();
    }
    determinant() {
      return determinant(this);
    }
    transpose() {
      transpose(this, this);
      return this.check();
    }
    invert() {
      invert(this, this);
      return this.check();
    }
    multiplyLeft(a2) {
      multiply(this, a2, this);
      return this.check();
    }
    multiplyRight(a2) {
      multiply(this, this, a2);
      return this.check();
    }
    rotate(radians) {
      rotate(this, this, radians);
      return this.check();
    }
    scale(factor) {
      if (Array.isArray(factor)) {
        scale(this, this, factor);
      } else {
        scale(this, this, [factor, factor]);
      }
      return this.check();
    }
    translate(vec) {
      translate(this, this, vec);
      return this.check();
    }
    transform(vector, result) {
      let out;
      switch (vector.length) {
        case 2:
          out = transformMat3(result || [-0, -0], vector, this);
          break;
        case 3:
          out = transformMat32(result || [-0, -0, -0], vector, this);
          break;
        case 4:
          out = vec4_transformMat3(result || [-0, -0, -0, -0], vector, this);
          break;
        default:
          throw new Error("Illegal vector");
      }
      checkVector(out, vector.length);
      return out;
    }
    transformVector(vector, result) {
      return this.transform(vector, result);
    }
    transformVector2(vector, result) {
      return this.transform(vector, result);
    }
    transformVector3(vector, result) {
      return this.transform(vector, result);
    }
  };
  var ZERO_MATRIX3;
  var IDENTITY_MATRIX3;
  function getZeroMatrix() {
    if (!ZERO_MATRIX3) {
      ZERO_MATRIX3 = new Matrix3([0, 0, 0, 0, 0, 0, 0, 0, 0]);
      Object.freeze(ZERO_MATRIX3);
    }
    return ZERO_MATRIX3;
  }
  function getIdentityMatrix() {
    if (!IDENTITY_MATRIX3) {
      IDENTITY_MATRIX3 = new Matrix3();
      Object.freeze(IDENTITY_MATRIX3);
    }
    return IDENTITY_MATRIX3;
  }

  // ../../node_modules/gl-matrix/esm/mat4.js
  function identity(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  function transpose2(out, a2) {
    if (out === a2) {
      var a01 = a2[1], a02 = a2[2], a03 = a2[3];
      var a12 = a2[6], a13 = a2[7];
      var a23 = a2[11];
      out[1] = a2[4];
      out[2] = a2[8];
      out[3] = a2[12];
      out[4] = a01;
      out[6] = a2[9];
      out[7] = a2[13];
      out[8] = a02;
      out[9] = a12;
      out[11] = a2[14];
      out[12] = a03;
      out[13] = a13;
      out[14] = a23;
    } else {
      out[0] = a2[0];
      out[1] = a2[4];
      out[2] = a2[8];
      out[3] = a2[12];
      out[4] = a2[1];
      out[5] = a2[5];
      out[6] = a2[9];
      out[7] = a2[13];
      out[8] = a2[2];
      out[9] = a2[6];
      out[10] = a2[10];
      out[11] = a2[14];
      out[12] = a2[3];
      out[13] = a2[7];
      out[14] = a2[11];
      out[15] = a2[15];
    }
    return out;
  }
  function invert2(out, a2) {
    var a00 = a2[0], a01 = a2[1], a02 = a2[2], a03 = a2[3];
    var a10 = a2[4], a11 = a2[5], a12 = a2[6], a13 = a2[7];
    var a20 = a2[8], a21 = a2[9], a22 = a2[10], a23 = a2[11];
    var a30 = a2[12], a31 = a2[13], a32 = a2[14], a33 = a2[15];
    var b00 = a00 * a11 - a01 * a10;
    var b01 = a00 * a12 - a02 * a10;
    var b02 = a00 * a13 - a03 * a10;
    var b03 = a01 * a12 - a02 * a11;
    var b04 = a01 * a13 - a03 * a11;
    var b05 = a02 * a13 - a03 * a12;
    var b06 = a20 * a31 - a21 * a30;
    var b07 = a20 * a32 - a22 * a30;
    var b08 = a20 * a33 - a23 * a30;
    var b09 = a21 * a32 - a22 * a31;
    var b10 = a21 * a33 - a23 * a31;
    var b11 = a22 * a33 - a23 * a32;
    var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
    if (!det) {
      return null;
    }
    det = 1 / det;
    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
    return out;
  }
  function determinant2(a2) {
    var a00 = a2[0], a01 = a2[1], a02 = a2[2], a03 = a2[3];
    var a10 = a2[4], a11 = a2[5], a12 = a2[6], a13 = a2[7];
    var a20 = a2[8], a21 = a2[9], a22 = a2[10], a23 = a2[11];
    var a30 = a2[12], a31 = a2[13], a32 = a2[14], a33 = a2[15];
    var b00 = a00 * a11 - a01 * a10;
    var b01 = a00 * a12 - a02 * a10;
    var b02 = a00 * a13 - a03 * a10;
    var b03 = a01 * a12 - a02 * a11;
    var b04 = a01 * a13 - a03 * a11;
    var b05 = a02 * a13 - a03 * a12;
    var b06 = a20 * a31 - a21 * a30;
    var b07 = a20 * a32 - a22 * a30;
    var b08 = a20 * a33 - a23 * a30;
    var b09 = a21 * a32 - a22 * a31;
    var b10 = a21 * a33 - a23 * a31;
    var b11 = a22 * a33 - a23 * a32;
    return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
  }
  function multiply2(out, a2, b) {
    var a00 = a2[0], a01 = a2[1], a02 = a2[2], a03 = a2[3];
    var a10 = a2[4], a11 = a2[5], a12 = a2[6], a13 = a2[7];
    var a20 = a2[8], a21 = a2[9], a22 = a2[10], a23 = a2[11];
    var a30 = a2[12], a31 = a2[13], a32 = a2[14], a33 = a2[15];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[4];
    b1 = b[5];
    b2 = b[6];
    b3 = b[7];
    out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[8];
    b1 = b[9];
    b2 = b[10];
    b3 = b[11];
    out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[12];
    b1 = b[13];
    b2 = b[14];
    b3 = b[15];
    out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    return out;
  }
  function translate2(out, a2, v) {
    var x = v[0], y = v[1], z = v[2];
    var a00, a01, a02, a03;
    var a10, a11, a12, a13;
    var a20, a21, a22, a23;
    if (a2 === out) {
      out[12] = a2[0] * x + a2[4] * y + a2[8] * z + a2[12];
      out[13] = a2[1] * x + a2[5] * y + a2[9] * z + a2[13];
      out[14] = a2[2] * x + a2[6] * y + a2[10] * z + a2[14];
      out[15] = a2[3] * x + a2[7] * y + a2[11] * z + a2[15];
    } else {
      a00 = a2[0];
      a01 = a2[1];
      a02 = a2[2];
      a03 = a2[3];
      a10 = a2[4];
      a11 = a2[5];
      a12 = a2[6];
      a13 = a2[7];
      a20 = a2[8];
      a21 = a2[9];
      a22 = a2[10];
      a23 = a2[11];
      out[0] = a00;
      out[1] = a01;
      out[2] = a02;
      out[3] = a03;
      out[4] = a10;
      out[5] = a11;
      out[6] = a12;
      out[7] = a13;
      out[8] = a20;
      out[9] = a21;
      out[10] = a22;
      out[11] = a23;
      out[12] = a00 * x + a10 * y + a20 * z + a2[12];
      out[13] = a01 * x + a11 * y + a21 * z + a2[13];
      out[14] = a02 * x + a12 * y + a22 * z + a2[14];
      out[15] = a03 * x + a13 * y + a23 * z + a2[15];
    }
    return out;
  }
  function scale2(out, a2, v) {
    var x = v[0], y = v[1], z = v[2];
    out[0] = a2[0] * x;
    out[1] = a2[1] * x;
    out[2] = a2[2] * x;
    out[3] = a2[3] * x;
    out[4] = a2[4] * y;
    out[5] = a2[5] * y;
    out[6] = a2[6] * y;
    out[7] = a2[7] * y;
    out[8] = a2[8] * z;
    out[9] = a2[9] * z;
    out[10] = a2[10] * z;
    out[11] = a2[11] * z;
    out[12] = a2[12];
    out[13] = a2[13];
    out[14] = a2[14];
    out[15] = a2[15];
    return out;
  }
  function rotate2(out, a2, rad, axis) {
    var x = axis[0], y = axis[1], z = axis[2];
    var len2 = Math.hypot(x, y, z);
    var s2, c, t2;
    var a00, a01, a02, a03;
    var a10, a11, a12, a13;
    var a20, a21, a22, a23;
    var b00, b01, b02;
    var b10, b11, b12;
    var b20, b21, b22;
    if (len2 < EPSILON) {
      return null;
    }
    len2 = 1 / len2;
    x *= len2;
    y *= len2;
    z *= len2;
    s2 = Math.sin(rad);
    c = Math.cos(rad);
    t2 = 1 - c;
    a00 = a2[0];
    a01 = a2[1];
    a02 = a2[2];
    a03 = a2[3];
    a10 = a2[4];
    a11 = a2[5];
    a12 = a2[6];
    a13 = a2[7];
    a20 = a2[8];
    a21 = a2[9];
    a22 = a2[10];
    a23 = a2[11];
    b00 = x * x * t2 + c;
    b01 = y * x * t2 + z * s2;
    b02 = z * x * t2 - y * s2;
    b10 = x * y * t2 - z * s2;
    b11 = y * y * t2 + c;
    b12 = z * y * t2 + x * s2;
    b20 = x * z * t2 + y * s2;
    b21 = y * z * t2 - x * s2;
    b22 = z * z * t2 + c;
    out[0] = a00 * b00 + a10 * b01 + a20 * b02;
    out[1] = a01 * b00 + a11 * b01 + a21 * b02;
    out[2] = a02 * b00 + a12 * b01 + a22 * b02;
    out[3] = a03 * b00 + a13 * b01 + a23 * b02;
    out[4] = a00 * b10 + a10 * b11 + a20 * b12;
    out[5] = a01 * b10 + a11 * b11 + a21 * b12;
    out[6] = a02 * b10 + a12 * b11 + a22 * b12;
    out[7] = a03 * b10 + a13 * b11 + a23 * b12;
    out[8] = a00 * b20 + a10 * b21 + a20 * b22;
    out[9] = a01 * b20 + a11 * b21 + a21 * b22;
    out[10] = a02 * b20 + a12 * b21 + a22 * b22;
    out[11] = a03 * b20 + a13 * b21 + a23 * b22;
    if (a2 !== out) {
      out[12] = a2[12];
      out[13] = a2[13];
      out[14] = a2[14];
      out[15] = a2[15];
    }
    return out;
  }
  function rotateX2(out, a2, rad) {
    var s2 = Math.sin(rad);
    var c = Math.cos(rad);
    var a10 = a2[4];
    var a11 = a2[5];
    var a12 = a2[6];
    var a13 = a2[7];
    var a20 = a2[8];
    var a21 = a2[9];
    var a22 = a2[10];
    var a23 = a2[11];
    if (a2 !== out) {
      out[0] = a2[0];
      out[1] = a2[1];
      out[2] = a2[2];
      out[3] = a2[3];
      out[12] = a2[12];
      out[13] = a2[13];
      out[14] = a2[14];
      out[15] = a2[15];
    }
    out[4] = a10 * c + a20 * s2;
    out[5] = a11 * c + a21 * s2;
    out[6] = a12 * c + a22 * s2;
    out[7] = a13 * c + a23 * s2;
    out[8] = a20 * c - a10 * s2;
    out[9] = a21 * c - a11 * s2;
    out[10] = a22 * c - a12 * s2;
    out[11] = a23 * c - a13 * s2;
    return out;
  }
  function rotateY2(out, a2, rad) {
    var s2 = Math.sin(rad);
    var c = Math.cos(rad);
    var a00 = a2[0];
    var a01 = a2[1];
    var a02 = a2[2];
    var a03 = a2[3];
    var a20 = a2[8];
    var a21 = a2[9];
    var a22 = a2[10];
    var a23 = a2[11];
    if (a2 !== out) {
      out[4] = a2[4];
      out[5] = a2[5];
      out[6] = a2[6];
      out[7] = a2[7];
      out[12] = a2[12];
      out[13] = a2[13];
      out[14] = a2[14];
      out[15] = a2[15];
    }
    out[0] = a00 * c - a20 * s2;
    out[1] = a01 * c - a21 * s2;
    out[2] = a02 * c - a22 * s2;
    out[3] = a03 * c - a23 * s2;
    out[8] = a00 * s2 + a20 * c;
    out[9] = a01 * s2 + a21 * c;
    out[10] = a02 * s2 + a22 * c;
    out[11] = a03 * s2 + a23 * c;
    return out;
  }
  function rotateZ2(out, a2, rad) {
    var s2 = Math.sin(rad);
    var c = Math.cos(rad);
    var a00 = a2[0];
    var a01 = a2[1];
    var a02 = a2[2];
    var a03 = a2[3];
    var a10 = a2[4];
    var a11 = a2[5];
    var a12 = a2[6];
    var a13 = a2[7];
    if (a2 !== out) {
      out[8] = a2[8];
      out[9] = a2[9];
      out[10] = a2[10];
      out[11] = a2[11];
      out[12] = a2[12];
      out[13] = a2[13];
      out[14] = a2[14];
      out[15] = a2[15];
    }
    out[0] = a00 * c + a10 * s2;
    out[1] = a01 * c + a11 * s2;
    out[2] = a02 * c + a12 * s2;
    out[3] = a03 * c + a13 * s2;
    out[4] = a10 * c - a00 * s2;
    out[5] = a11 * c - a01 * s2;
    out[6] = a12 * c - a02 * s2;
    out[7] = a13 * c - a03 * s2;
    return out;
  }
  function fromQuat2(out, q) {
    var x = q[0], y = q[1], z = q[2], w = q[3];
    var x2 = x + x;
    var y2 = y + y;
    var z2 = z + z;
    var xx = x * x2;
    var yx = y * x2;
    var yy = y * y2;
    var zx = z * x2;
    var zy = z * y2;
    var zz = z * z2;
    var wx = w * x2;
    var wy = w * y2;
    var wz = w * z2;
    out[0] = 1 - yy - zz;
    out[1] = yx + wz;
    out[2] = zx - wy;
    out[3] = 0;
    out[4] = yx - wz;
    out[5] = 1 - xx - zz;
    out[6] = zy + wx;
    out[7] = 0;
    out[8] = zx + wy;
    out[9] = zy - wx;
    out[10] = 1 - xx - yy;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  function frustum(out, left, right, bottom, top, near, far) {
    var rl = 1 / (right - left);
    var tb = 1 / (top - bottom);
    var nf = 1 / (near - far);
    out[0] = near * 2 * rl;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = near * 2 * tb;
    out[6] = 0;
    out[7] = 0;
    out[8] = (right + left) * rl;
    out[9] = (top + bottom) * tb;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = far * near * 2 * nf;
    out[15] = 0;
    return out;
  }
  function perspectiveNO(out, fovy, aspect, near, far) {
    var f2 = 1 / Math.tan(fovy / 2), nf;
    out[0] = f2 / aspect;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = f2;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[15] = 0;
    if (far != null && far !== Infinity) {
      nf = 1 / (near - far);
      out[10] = (far + near) * nf;
      out[14] = 2 * far * near * nf;
    } else {
      out[10] = -1;
      out[14] = -2 * near;
    }
    return out;
  }
  var perspective = perspectiveNO;
  function orthoNO(out, left, right, bottom, top, near, far) {
    var lr = 1 / (left - right);
    var bt = 1 / (bottom - top);
    var nf = 1 / (near - far);
    out[0] = -2 * lr;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = -2 * bt;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 2 * nf;
    out[11] = 0;
    out[12] = (left + right) * lr;
    out[13] = (top + bottom) * bt;
    out[14] = (far + near) * nf;
    out[15] = 1;
    return out;
  }
  var ortho = orthoNO;
  function lookAt(out, eye, center, up) {
    var x0, x1, x2, y0, y1, y2, z0, z1, z2, len2;
    var eyex = eye[0];
    var eyey = eye[1];
    var eyez = eye[2];
    var upx = up[0];
    var upy = up[1];
    var upz = up[2];
    var centerx = center[0];
    var centery = center[1];
    var centerz = center[2];
    if (Math.abs(eyex - centerx) < EPSILON && Math.abs(eyey - centery) < EPSILON && Math.abs(eyez - centerz) < EPSILON) {
      return identity(out);
    }
    z0 = eyex - centerx;
    z1 = eyey - centery;
    z2 = eyez - centerz;
    len2 = 1 / Math.hypot(z0, z1, z2);
    z0 *= len2;
    z1 *= len2;
    z2 *= len2;
    x0 = upy * z2 - upz * z1;
    x1 = upz * z0 - upx * z2;
    x2 = upx * z1 - upy * z0;
    len2 = Math.hypot(x0, x1, x2);
    if (!len2) {
      x0 = 0;
      x1 = 0;
      x2 = 0;
    } else {
      len2 = 1 / len2;
      x0 *= len2;
      x1 *= len2;
      x2 *= len2;
    }
    y0 = z1 * x2 - z2 * x1;
    y1 = z2 * x0 - z0 * x2;
    y2 = z0 * x1 - z1 * x0;
    len2 = Math.hypot(y0, y1, y2);
    if (!len2) {
      y0 = 0;
      y1 = 0;
      y2 = 0;
    } else {
      len2 = 1 / len2;
      y0 *= len2;
      y1 *= len2;
      y2 *= len2;
    }
    out[0] = x0;
    out[1] = y0;
    out[2] = z0;
    out[3] = 0;
    out[4] = x1;
    out[5] = y1;
    out[6] = z1;
    out[7] = 0;
    out[8] = x2;
    out[9] = y2;
    out[10] = z2;
    out[11] = 0;
    out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
    out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
    out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
    out[15] = 1;
    return out;
  }

  // ../../node_modules/gl-matrix/esm/vec4.js
  function create4() {
    var out = new ARRAY_TYPE(4);
    if (ARRAY_TYPE != Float32Array) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      out[3] = 0;
    }
    return out;
  }
  function add(out, a2, b) {
    out[0] = a2[0] + b[0];
    out[1] = a2[1] + b[1];
    out[2] = a2[2] + b[2];
    out[3] = a2[3] + b[3];
    return out;
  }
  function scale3(out, a2, b) {
    out[0] = a2[0] * b;
    out[1] = a2[1] * b;
    out[2] = a2[2] * b;
    out[3] = a2[3] * b;
    return out;
  }
  function length2(a2) {
    var x = a2[0];
    var y = a2[1];
    var z = a2[2];
    var w = a2[3];
    return Math.hypot(x, y, z, w);
  }
  function squaredLength(a2) {
    var x = a2[0];
    var y = a2[1];
    var z = a2[2];
    var w = a2[3];
    return x * x + y * y + z * z + w * w;
  }
  function normalize2(out, a2) {
    var x = a2[0];
    var y = a2[1];
    var z = a2[2];
    var w = a2[3];
    var len2 = x * x + y * y + z * z + w * w;
    if (len2 > 0) {
      len2 = 1 / Math.sqrt(len2);
    }
    out[0] = x * len2;
    out[1] = y * len2;
    out[2] = z * len2;
    out[3] = w * len2;
    return out;
  }
  function dot2(a2, b) {
    return a2[0] * b[0] + a2[1] * b[1] + a2[2] * b[2] + a2[3] * b[3];
  }
  function lerp(out, a2, b, t2) {
    var ax = a2[0];
    var ay = a2[1];
    var az = a2[2];
    var aw = a2[3];
    out[0] = ax + t2 * (b[0] - ax);
    out[1] = ay + t2 * (b[1] - ay);
    out[2] = az + t2 * (b[2] - az);
    out[3] = aw + t2 * (b[3] - aw);
    return out;
  }
  function transformMat43(out, a2, m) {
    var x = a2[0], y = a2[1], z = a2[2], w = a2[3];
    out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
    out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
    out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
    out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
    return out;
  }
  function transformQuat2(out, a2, q) {
    var x = a2[0], y = a2[1], z = a2[2];
    var qx = q[0], qy = q[1], qz = q[2], qw = q[3];
    var ix = qw * x + qy * z - qz * y;
    var iy = qw * y + qz * x - qx * z;
    var iz = qw * z + qx * y - qy * x;
    var iw = -qx * x - qy * y - qz * z;
    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    out[3] = a2[3];
    return out;
  }
  var forEach3 = function() {
    var vec = create4();
    return function(a2, stride, offset, count, fn, arg) {
      var i2, l2;
      if (!stride) {
        stride = 4;
      }
      if (!offset) {
        offset = 0;
      }
      if (count) {
        l2 = Math.min(count * stride + offset, a2.length);
      } else {
        l2 = a2.length;
      }
      for (i2 = offset; i2 < l2; i2 += stride) {
        vec[0] = a2[i2];
        vec[1] = a2[i2 + 1];
        vec[2] = a2[i2 + 2];
        vec[3] = a2[i2 + 3];
        fn(vec, vec, arg);
        a2[i2] = vec[0];
        a2[i2 + 1] = vec[1];
        a2[i2 + 2] = vec[2];
        a2[i2 + 3] = vec[3];
      }
      return a2;
    };
  }();

  // ../../node_modules/@math.gl/core/dist/esm/classes/matrix4.js
  var INDICES2;
  (function(INDICES3) {
    INDICES3[INDICES3["COL0ROW0"] = 0] = "COL0ROW0";
    INDICES3[INDICES3["COL0ROW1"] = 1] = "COL0ROW1";
    INDICES3[INDICES3["COL0ROW2"] = 2] = "COL0ROW2";
    INDICES3[INDICES3["COL0ROW3"] = 3] = "COL0ROW3";
    INDICES3[INDICES3["COL1ROW0"] = 4] = "COL1ROW0";
    INDICES3[INDICES3["COL1ROW1"] = 5] = "COL1ROW1";
    INDICES3[INDICES3["COL1ROW2"] = 6] = "COL1ROW2";
    INDICES3[INDICES3["COL1ROW3"] = 7] = "COL1ROW3";
    INDICES3[INDICES3["COL2ROW0"] = 8] = "COL2ROW0";
    INDICES3[INDICES3["COL2ROW1"] = 9] = "COL2ROW1";
    INDICES3[INDICES3["COL2ROW2"] = 10] = "COL2ROW2";
    INDICES3[INDICES3["COL2ROW3"] = 11] = "COL2ROW3";
    INDICES3[INDICES3["COL3ROW0"] = 12] = "COL3ROW0";
    INDICES3[INDICES3["COL3ROW1"] = 13] = "COL3ROW1";
    INDICES3[INDICES3["COL3ROW2"] = 14] = "COL3ROW2";
    INDICES3[INDICES3["COL3ROW3"] = 15] = "COL3ROW3";
  })(INDICES2 || (INDICES2 = {}));
  var DEFAULT_FOVY = 45 * Math.PI / 180;
  var DEFAULT_ASPECT = 1;
  var DEFAULT_NEAR = 0.1;
  var DEFAULT_FAR = 500;
  var IDENTITY_MATRIX2 = Object.freeze([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
  var Matrix4 = class extends Matrix {
    static get IDENTITY() {
      return getIdentityMatrix2();
    }
    static get ZERO() {
      return getZeroMatrix2();
    }
    get ELEMENTS() {
      return 16;
    }
    get RANK() {
      return 4;
    }
    get INDICES() {
      return INDICES2;
    }
    constructor(array) {
      super(-0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0);
      if (arguments.length === 1 && Array.isArray(array)) {
        this.copy(array);
      } else {
        this.identity();
      }
    }
    copy(array) {
      this[0] = array[0];
      this[1] = array[1];
      this[2] = array[2];
      this[3] = array[3];
      this[4] = array[4];
      this[5] = array[5];
      this[6] = array[6];
      this[7] = array[7];
      this[8] = array[8];
      this[9] = array[9];
      this[10] = array[10];
      this[11] = array[11];
      this[12] = array[12];
      this[13] = array[13];
      this[14] = array[14];
      this[15] = array[15];
      return this.check();
    }
    set(m00, m10, m20, m30, m01, m11, m21, m31, m02, m12, m22, m32, m03, m13, m23, m33) {
      this[0] = m00;
      this[1] = m10;
      this[2] = m20;
      this[3] = m30;
      this[4] = m01;
      this[5] = m11;
      this[6] = m21;
      this[7] = m31;
      this[8] = m02;
      this[9] = m12;
      this[10] = m22;
      this[11] = m32;
      this[12] = m03;
      this[13] = m13;
      this[14] = m23;
      this[15] = m33;
      return this.check();
    }
    setRowMajor(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
      this[0] = m00;
      this[1] = m10;
      this[2] = m20;
      this[3] = m30;
      this[4] = m01;
      this[5] = m11;
      this[6] = m21;
      this[7] = m31;
      this[8] = m02;
      this[9] = m12;
      this[10] = m22;
      this[11] = m32;
      this[12] = m03;
      this[13] = m13;
      this[14] = m23;
      this[15] = m33;
      return this.check();
    }
    toRowMajor(result) {
      result[0] = this[0];
      result[1] = this[4];
      result[2] = this[8];
      result[3] = this[12];
      result[4] = this[1];
      result[5] = this[5];
      result[6] = this[9];
      result[7] = this[13];
      result[8] = this[2];
      result[9] = this[6];
      result[10] = this[10];
      result[11] = this[14];
      result[12] = this[3];
      result[13] = this[7];
      result[14] = this[11];
      result[15] = this[15];
      return result;
    }
    identity() {
      return this.copy(IDENTITY_MATRIX2);
    }
    fromObject(object) {
      return this.check();
    }
    fromQuaternion(quaternion2) {
      fromQuat2(this, quaternion2);
      return this.check();
    }
    frustum(view) {
      const {
        left,
        right,
        bottom,
        top,
        near = DEFAULT_NEAR,
        far = DEFAULT_FAR
      } = view;
      if (far === Infinity) {
        computeInfinitePerspectiveOffCenter(this, left, right, bottom, top, near);
      } else {
        frustum(this, left, right, bottom, top, near, far);
      }
      return this.check();
    }
    lookAt(view) {
      const {
        eye,
        center = [0, 0, 0],
        up = [0, 1, 0]
      } = view;
      lookAt(this, eye, center, up);
      return this.check();
    }
    ortho(view) {
      const {
        left,
        right,
        bottom,
        top,
        near = DEFAULT_NEAR,
        far = DEFAULT_FAR
      } = view;
      ortho(this, left, right, bottom, top, near, far);
      return this.check();
    }
    orthographic(view) {
      const {
        fovy = DEFAULT_FOVY,
        aspect = DEFAULT_ASPECT,
        focalDistance = 1,
        near = DEFAULT_NEAR,
        far = DEFAULT_FAR
      } = view;
      checkRadians(fovy);
      const halfY = fovy / 2;
      const top = focalDistance * Math.tan(halfY);
      const right = top * aspect;
      return this.ortho({
        left: -right,
        right,
        bottom: -top,
        top,
        near,
        far
      });
    }
    perspective(view) {
      const {
        fovy = 45 * Math.PI / 180,
        aspect = 1,
        near = 0.1,
        far = 500
      } = view;
      checkRadians(fovy);
      perspective(this, fovy, aspect, near, far);
      return this.check();
    }
    determinant() {
      return determinant2(this);
    }
    getScale(result = [-0, -0, -0]) {
      result[0] = Math.sqrt(this[0] * this[0] + this[1] * this[1] + this[2] * this[2]);
      result[1] = Math.sqrt(this[4] * this[4] + this[5] * this[5] + this[6] * this[6]);
      result[2] = Math.sqrt(this[8] * this[8] + this[9] * this[9] + this[10] * this[10]);
      return result;
    }
    getTranslation(result = [-0, -0, -0]) {
      result[0] = this[12];
      result[1] = this[13];
      result[2] = this[14];
      return result;
    }
    getRotation(result, scaleResult) {
      result = result || [-0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0];
      scaleResult = scaleResult || [-0, -0, -0];
      const scale5 = this.getScale(scaleResult);
      const inverseScale0 = 1 / scale5[0];
      const inverseScale1 = 1 / scale5[1];
      const inverseScale2 = 1 / scale5[2];
      result[0] = this[0] * inverseScale0;
      result[1] = this[1] * inverseScale1;
      result[2] = this[2] * inverseScale2;
      result[3] = 0;
      result[4] = this[4] * inverseScale0;
      result[5] = this[5] * inverseScale1;
      result[6] = this[6] * inverseScale2;
      result[7] = 0;
      result[8] = this[8] * inverseScale0;
      result[9] = this[9] * inverseScale1;
      result[10] = this[10] * inverseScale2;
      result[11] = 0;
      result[12] = 0;
      result[13] = 0;
      result[14] = 0;
      result[15] = 1;
      return result;
    }
    getRotationMatrix3(result, scaleResult) {
      result = result || [-0, -0, -0, -0, -0, -0, -0, -0, -0];
      scaleResult = scaleResult || [-0, -0, -0];
      const scale5 = this.getScale(scaleResult);
      const inverseScale0 = 1 / scale5[0];
      const inverseScale1 = 1 / scale5[1];
      const inverseScale2 = 1 / scale5[2];
      result[0] = this[0] * inverseScale0;
      result[1] = this[1] * inverseScale1;
      result[2] = this[2] * inverseScale2;
      result[3] = this[4] * inverseScale0;
      result[4] = this[5] * inverseScale1;
      result[5] = this[6] * inverseScale2;
      result[6] = this[8] * inverseScale0;
      result[7] = this[9] * inverseScale1;
      result[8] = this[10] * inverseScale2;
      return result;
    }
    transpose() {
      transpose2(this, this);
      return this.check();
    }
    invert() {
      invert2(this, this);
      return this.check();
    }
    multiplyLeft(a2) {
      multiply2(this, a2, this);
      return this.check();
    }
    multiplyRight(a2) {
      multiply2(this, this, a2);
      return this.check();
    }
    rotateX(radians) {
      rotateX2(this, this, radians);
      return this.check();
    }
    rotateY(radians) {
      rotateY2(this, this, radians);
      return this.check();
    }
    rotateZ(radians) {
      rotateZ2(this, this, radians);
      return this.check();
    }
    rotateXYZ(angleXYZ) {
      return this.rotateX(angleXYZ[0]).rotateY(angleXYZ[1]).rotateZ(angleXYZ[2]);
    }
    rotateAxis(radians, axis) {
      rotate2(this, this, radians, axis);
      return this.check();
    }
    scale(factor) {
      scale2(this, this, Array.isArray(factor) ? factor : [factor, factor, factor]);
      return this.check();
    }
    translate(vector) {
      translate2(this, this, vector);
      return this.check();
    }
    transform(vector, result) {
      if (vector.length === 4) {
        result = transformMat43(result || [-0, -0, -0, -0], vector, this);
        checkVector(result, 4);
        return result;
      }
      return this.transformAsPoint(vector, result);
    }
    transformAsPoint(vector, result) {
      const {
        length: length4
      } = vector;
      let out;
      switch (length4) {
        case 2:
          out = transformMat4(result || [-0, -0], vector, this);
          break;
        case 3:
          out = transformMat42(result || [-0, -0, -0], vector, this);
          break;
        default:
          throw new Error("Illegal vector");
      }
      checkVector(out, vector.length);
      return out;
    }
    transformAsVector(vector, result) {
      let out;
      switch (vector.length) {
        case 2:
          out = vec2_transformMat4AsVector(result || [-0, -0], vector, this);
          break;
        case 3:
          out = vec3_transformMat4AsVector(result || [-0, -0, -0], vector, this);
          break;
        default:
          throw new Error("Illegal vector");
      }
      checkVector(out, vector.length);
      return out;
    }
    transformPoint(vector, result) {
      return this.transformAsPoint(vector, result);
    }
    transformVector(vector, result) {
      return this.transformAsPoint(vector, result);
    }
    transformDirection(vector, result) {
      return this.transformAsVector(vector, result);
    }
    makeRotationX(radians) {
      return this.identity().rotateX(radians);
    }
    makeTranslation(x, y, z) {
      return this.identity().translate([x, y, z]);
    }
  };
  var ZERO3;
  var IDENTITY;
  function getZeroMatrix2() {
    if (!ZERO3) {
      ZERO3 = new Matrix4([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
      Object.freeze(ZERO3);
    }
    return ZERO3;
  }
  function getIdentityMatrix2() {
    if (!IDENTITY) {
      IDENTITY = new Matrix4();
      Object.freeze(IDENTITY);
    }
    return IDENTITY;
  }
  function checkRadians(possiblyDegrees) {
    if (possiblyDegrees > Math.PI * 2) {
      throw Error("expected radians");
    }
  }
  function computeInfinitePerspectiveOffCenter(result, left, right, bottom, top, near) {
    const column0Row0 = 2 * near / (right - left);
    const column1Row1 = 2 * near / (top - bottom);
    const column2Row0 = (right + left) / (right - left);
    const column2Row1 = (top + bottom) / (top - bottom);
    const column2Row2 = -1;
    const column2Row3 = -1;
    const column3Row2 = -2 * near;
    result[0] = column0Row0;
    result[1] = 0;
    result[2] = 0;
    result[3] = 0;
    result[4] = 0;
    result[5] = column1Row1;
    result[6] = 0;
    result[7] = 0;
    result[8] = column2Row0;
    result[9] = column2Row1;
    result[10] = column2Row2;
    result[11] = column2Row3;
    result[12] = 0;
    result[13] = 0;
    result[14] = column3Row2;
    result[15] = 0;
    return result;
  }

  // ../../node_modules/gl-matrix/esm/quat.js
  function create5() {
    var out = new ARRAY_TYPE(4);
    if (ARRAY_TYPE != Float32Array) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
    }
    out[3] = 1;
    return out;
  }
  function identity2(out) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
  }
  function setAxisAngle(out, axis, rad) {
    rad = rad * 0.5;
    var s2 = Math.sin(rad);
    out[0] = s2 * axis[0];
    out[1] = s2 * axis[1];
    out[2] = s2 * axis[2];
    out[3] = Math.cos(rad);
    return out;
  }
  function multiply3(out, a2, b) {
    var ax = a2[0], ay = a2[1], az = a2[2], aw = a2[3];
    var bx = b[0], by = b[1], bz = b[2], bw = b[3];
    out[0] = ax * bw + aw * bx + ay * bz - az * by;
    out[1] = ay * bw + aw * by + az * bx - ax * bz;
    out[2] = az * bw + aw * bz + ax * by - ay * bx;
    out[3] = aw * bw - ax * bx - ay * by - az * bz;
    return out;
  }
  function rotateX3(out, a2, rad) {
    rad *= 0.5;
    var ax = a2[0], ay = a2[1], az = a2[2], aw = a2[3];
    var bx = Math.sin(rad), bw = Math.cos(rad);
    out[0] = ax * bw + aw * bx;
    out[1] = ay * bw + az * bx;
    out[2] = az * bw - ay * bx;
    out[3] = aw * bw - ax * bx;
    return out;
  }
  function rotateY3(out, a2, rad) {
    rad *= 0.5;
    var ax = a2[0], ay = a2[1], az = a2[2], aw = a2[3];
    var by = Math.sin(rad), bw = Math.cos(rad);
    out[0] = ax * bw - az * by;
    out[1] = ay * bw + aw * by;
    out[2] = az * bw + ax * by;
    out[3] = aw * bw - ay * by;
    return out;
  }
  function rotateZ3(out, a2, rad) {
    rad *= 0.5;
    var ax = a2[0], ay = a2[1], az = a2[2], aw = a2[3];
    var bz = Math.sin(rad), bw = Math.cos(rad);
    out[0] = ax * bw + ay * bz;
    out[1] = ay * bw - ax * bz;
    out[2] = az * bw + aw * bz;
    out[3] = aw * bw - az * bz;
    return out;
  }
  function calculateW(out, a2) {
    var x = a2[0], y = a2[1], z = a2[2];
    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = Math.sqrt(Math.abs(1 - x * x - y * y - z * z));
    return out;
  }
  function slerp(out, a2, b, t2) {
    var ax = a2[0], ay = a2[1], az = a2[2], aw = a2[3];
    var bx = b[0], by = b[1], bz = b[2], bw = b[3];
    var omega, cosom, sinom, scale0, scale1;
    cosom = ax * bx + ay * by + az * bz + aw * bw;
    if (cosom < 0) {
      cosom = -cosom;
      bx = -bx;
      by = -by;
      bz = -bz;
      bw = -bw;
    }
    if (1 - cosom > EPSILON) {
      omega = Math.acos(cosom);
      sinom = Math.sin(omega);
      scale0 = Math.sin((1 - t2) * omega) / sinom;
      scale1 = Math.sin(t2 * omega) / sinom;
    } else {
      scale0 = 1 - t2;
      scale1 = t2;
    }
    out[0] = scale0 * ax + scale1 * bx;
    out[1] = scale0 * ay + scale1 * by;
    out[2] = scale0 * az + scale1 * bz;
    out[3] = scale0 * aw + scale1 * bw;
    return out;
  }
  function invert3(out, a2) {
    var a0 = a2[0], a1 = a2[1], a22 = a2[2], a3 = a2[3];
    var dot4 = a0 * a0 + a1 * a1 + a22 * a22 + a3 * a3;
    var invDot = dot4 ? 1 / dot4 : 0;
    out[0] = -a0 * invDot;
    out[1] = -a1 * invDot;
    out[2] = -a22 * invDot;
    out[3] = a3 * invDot;
    return out;
  }
  function conjugate(out, a2) {
    out[0] = -a2[0];
    out[1] = -a2[1];
    out[2] = -a2[2];
    out[3] = a2[3];
    return out;
  }
  function fromMat3(out, m) {
    var fTrace = m[0] + m[4] + m[8];
    var fRoot;
    if (fTrace > 0) {
      fRoot = Math.sqrt(fTrace + 1);
      out[3] = 0.5 * fRoot;
      fRoot = 0.5 / fRoot;
      out[0] = (m[5] - m[7]) * fRoot;
      out[1] = (m[6] - m[2]) * fRoot;
      out[2] = (m[1] - m[3]) * fRoot;
    } else {
      var i2 = 0;
      if (m[4] > m[0])
        i2 = 1;
      if (m[8] > m[i2 * 3 + i2])
        i2 = 2;
      var j = (i2 + 1) % 3;
      var k = (i2 + 2) % 3;
      fRoot = Math.sqrt(m[i2 * 3 + i2] - m[j * 3 + j] - m[k * 3 + k] + 1);
      out[i2] = 0.5 * fRoot;
      fRoot = 0.5 / fRoot;
      out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;
      out[j] = (m[j * 3 + i2] + m[i2 * 3 + j]) * fRoot;
      out[k] = (m[k * 3 + i2] + m[i2 * 3 + k]) * fRoot;
    }
    return out;
  }
  var add2 = add;
  var scale4 = scale3;
  var dot3 = dot2;
  var lerp2 = lerp;
  var length3 = length2;
  var squaredLength2 = squaredLength;
  var normalize3 = normalize2;
  var rotationTo = function() {
    var tmpvec3 = create2();
    var xUnitVec3 = fromValues(1, 0, 0);
    var yUnitVec3 = fromValues(0, 1, 0);
    return function(out, a2, b) {
      var dot4 = dot(a2, b);
      if (dot4 < -0.999999) {
        cross(tmpvec3, xUnitVec3, a2);
        if (len(tmpvec3) < 1e-6)
          cross(tmpvec3, yUnitVec3, a2);
        normalize(tmpvec3, tmpvec3);
        setAxisAngle(out, tmpvec3, Math.PI);
        return out;
      } else if (dot4 > 0.999999) {
        out[0] = 0;
        out[1] = 0;
        out[2] = 0;
        out[3] = 1;
        return out;
      } else {
        cross(tmpvec3, a2, b);
        out[0] = tmpvec3[0];
        out[1] = tmpvec3[1];
        out[2] = tmpvec3[2];
        out[3] = 1 + dot4;
        return normalize3(out, out);
      }
    };
  }();
  var sqlerp = function() {
    var temp1 = create5();
    var temp2 = create5();
    return function(out, a2, b, c, d, t2) {
      slerp(temp1, a2, d, t2);
      slerp(temp2, b, c, t2);
      slerp(out, temp1, temp2, 2 * t2 * (1 - t2));
      return out;
    };
  }();
  var setAxes = function() {
    var matr = create3();
    return function(out, view, right, up) {
      matr[0] = right[0];
      matr[3] = right[1];
      matr[6] = right[2];
      matr[1] = up[0];
      matr[4] = up[1];
      matr[7] = up[2];
      matr[2] = -view[0];
      matr[5] = -view[1];
      matr[8] = -view[2];
      return normalize3(out, fromMat3(out, matr));
    };
  }();

  // ../../node_modules/@math.gl/core/dist/esm/classes/quaternion.js
  var IDENTITY_QUATERNION = [0, 0, 0, 1];
  var Quaternion = class extends MathArray {
    constructor(x = 0, y = 0, z = 0, w = 1) {
      super(-0, -0, -0, -0);
      if (Array.isArray(x) && arguments.length === 1) {
        this.copy(x);
      } else {
        this.set(x, y, z, w);
      }
    }
    copy(array) {
      this[0] = array[0];
      this[1] = array[1];
      this[2] = array[2];
      this[3] = array[3];
      return this.check();
    }
    set(x, y, z, w) {
      this[0] = x;
      this[1] = y;
      this[2] = z;
      this[3] = w;
      return this.check();
    }
    fromObject(object) {
      this[0] = object.x;
      this[1] = object.y;
      this[2] = object.z;
      this[3] = object.w;
      return this.check();
    }
    fromMatrix3(m) {
      fromMat3(this, m);
      return this.check();
    }
    fromAxisRotation(axis, rad) {
      setAxisAngle(this, axis, rad);
      return this.check();
    }
    identity() {
      identity2(this);
      return this.check();
    }
    setAxisAngle(axis, rad) {
      return this.fromAxisRotation(axis, rad);
    }
    get ELEMENTS() {
      return 4;
    }
    get x() {
      return this[0];
    }
    set x(value) {
      this[0] = checkNumber(value);
    }
    get y() {
      return this[1];
    }
    set y(value) {
      this[1] = checkNumber(value);
    }
    get z() {
      return this[2];
    }
    set z(value) {
      this[2] = checkNumber(value);
    }
    get w() {
      return this[3];
    }
    set w(value) {
      this[3] = checkNumber(value);
    }
    len() {
      return length3(this);
    }
    lengthSquared() {
      return squaredLength2(this);
    }
    dot(a2) {
      return dot3(this, a2);
    }
    rotationTo(vectorA, vectorB) {
      rotationTo(this, vectorA, vectorB);
      return this.check();
    }
    add(a2) {
      add2(this, this, a2);
      return this.check();
    }
    calculateW() {
      calculateW(this, this);
      return this.check();
    }
    conjugate() {
      conjugate(this, this);
      return this.check();
    }
    invert() {
      invert3(this, this);
      return this.check();
    }
    lerp(a2, b, t2) {
      if (t2 === void 0) {
        return this.lerp(this, a2, b);
      }
      lerp2(this, a2, b, t2);
      return this.check();
    }
    multiplyRight(a2) {
      multiply3(this, this, a2);
      return this.check();
    }
    multiplyLeft(a2) {
      multiply3(this, a2, this);
      return this.check();
    }
    normalize() {
      const length4 = this.len();
      const l2 = length4 > 0 ? 1 / length4 : 0;
      this[0] = this[0] * l2;
      this[1] = this[1] * l2;
      this[2] = this[2] * l2;
      this[3] = this[3] * l2;
      if (length4 === 0) {
        this[3] = 1;
      }
      return this.check();
    }
    rotateX(rad) {
      rotateX3(this, this, rad);
      return this.check();
    }
    rotateY(rad) {
      rotateY3(this, this, rad);
      return this.check();
    }
    rotateZ(rad) {
      rotateZ3(this, this, rad);
      return this.check();
    }
    scale(b) {
      scale4(this, this, b);
      return this.check();
    }
    slerp(arg0, arg1, arg2) {
      let start;
      let target;
      let ratio;
      switch (arguments.length) {
        case 1:
          ({
            start = IDENTITY_QUATERNION,
            target,
            ratio
          } = arg0);
          break;
        case 2:
          start = this;
          target = arg0;
          ratio = arg1;
          break;
        default:
          start = arg0;
          target = arg1;
          ratio = arg2;
      }
      slerp(this, start, target, ratio);
      return this.check();
    }
    transformVector4(vector, result = new Vector4()) {
      transformQuat2(result, vector, this);
      return checkVector(result, 4);
    }
    lengthSq() {
      return this.lengthSquared();
    }
    setFromAxisAngle(axis, rad) {
      return this.setAxisAngle(axis, rad);
    }
    premultiply(a2) {
      return this.multiplyLeft(a2);
    }
    multiply(a2) {
      return this.multiplyRight(a2);
    }
  };

  // ../../node_modules/@luma.gl/shadertools/dist/esm/modules/lights/lights.glsl.js
  var lights_glsl_default = "#if (defined(SHADER_TYPE_FRAGMENT) && defined(LIGHTING_FRAGMENT)) || (defined(SHADER_TYPE_VERTEX) && defined(LIGHTING_VERTEX))\n\nstruct AmbientLight {\n vec3 color;\n};\n\nstruct PointLight {\n vec3 color;\n vec3 position;\n vec3 attenuation;\n};\n\nstruct DirectionalLight {\n  vec3 color;\n  vec3 direction;\n};\n\nuniform AmbientLight lighting_uAmbientLight;\nuniform PointLight lighting_uPointLight[MAX_LIGHTS];\nuniform DirectionalLight lighting_uDirectionalLight[MAX_LIGHTS];\nuniform int lighting_uPointLightCount;\nuniform int lighting_uDirectionalLightCount;\n\nuniform bool lighting_uEnabled;\n\nfloat getPointLightAttenuation(PointLight pointLight, float distance) {\n  return pointLight.attenuation.x\n       + pointLight.attenuation.y * distance\n       + pointLight.attenuation.z * distance * distance;\n}\n\n#endif\n";

  // ../../node_modules/@luma.gl/shadertools/dist/esm/modules/lights/lights.js
  var INITIAL_MODULE_OPTIONS = {
    lightSources: {}
  };
  function convertColor() {
    let {
      color = [0, 0, 0],
      intensity = 1
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return color.map((component) => component * intensity / 255);
  }
  function getLightSourceUniforms(_ref) {
    let {
      ambientLight,
      pointLights = [],
      directionalLights = []
    } = _ref;
    const lightSourceUniforms = {};
    if (ambientLight) {
      lightSourceUniforms["lighting_uAmbientLight.color"] = convertColor(ambientLight);
    } else {
      lightSourceUniforms["lighting_uAmbientLight.color"] = [0, 0, 0];
    }
    pointLights.forEach((pointLight, index) => {
      lightSourceUniforms["lighting_uPointLight[".concat(index, "].color")] = convertColor(pointLight);
      lightSourceUniforms["lighting_uPointLight[".concat(index, "].position")] = pointLight.position;
      lightSourceUniforms["lighting_uPointLight[".concat(index, "].attenuation")] = pointLight.attenuation || [1, 0, 0];
    });
    lightSourceUniforms.lighting_uPointLightCount = pointLights.length;
    directionalLights.forEach((directionalLight, index) => {
      lightSourceUniforms["lighting_uDirectionalLight[".concat(index, "].color")] = convertColor(directionalLight);
      lightSourceUniforms["lighting_uDirectionalLight[".concat(index, "].direction")] = directionalLight.direction;
    });
    lightSourceUniforms.lighting_uDirectionalLightCount = directionalLights.length;
    return lightSourceUniforms;
  }
  function getUniforms() {
    let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : INITIAL_MODULE_OPTIONS;
    if ("lightSources" in opts) {
      const {
        ambientLight,
        pointLights,
        directionalLights
      } = opts.lightSources || {};
      const hasLights = ambientLight || pointLights && pointLights.length > 0 || directionalLights && directionalLights.length > 0;
      if (!hasLights) {
        return {
          lighting_uEnabled: false
        };
      }
      return Object.assign({}, getLightSourceUniforms({
        ambientLight,
        pointLights,
        directionalLights
      }), {
        lighting_uEnabled: true
      });
    }
    if ("lights" in opts) {
      const lightSources = {
        pointLights: [],
        directionalLights: []
      };
      for (const light of opts.lights || []) {
        switch (light.type) {
          case "ambient":
            lightSources.ambientLight = light;
            break;
          case "directional":
            lightSources.directionalLights.push(light);
            break;
          case "point":
            lightSources.pointLights.push(light);
            break;
          default:
        }
      }
      return getUniforms({
        lightSources
      });
    }
    return {};
  }
  var lights = {
    name: "lights",
    vs: lights_glsl_default,
    fs: lights_glsl_default,
    getUniforms,
    defines: {
      MAX_LIGHTS: 3
    }
  };

  // ../../node_modules/@luma.gl/shadertools/dist/esm/modules/pbr/pbr-vertex.glsl.js
  var pbr_vertex_glsl_default = "uniform mat4 u_MVPMatrix;\nuniform mat4 u_ModelMatrix;\nuniform mat4 u_NormalMatrix;\n\nvarying vec3 pbr_vPosition;\nvarying vec2 pbr_vUV;\n\n#ifdef HAS_NORMALS\n# ifdef HAS_TANGENTS\nvarying mat3 pbr_vTBN;\n# else\nvarying vec3 pbr_vNormal;\n# endif\n#endif\n\nvoid pbr_setPositionNormalTangentUV(vec4 position, vec4 normal, vec4 tangent, vec2 uv)\n{\n  vec4 pos = u_ModelMatrix * position;\n  pbr_vPosition = vec3(pos.xyz) / pos.w;\n\n#ifdef HAS_NORMALS\n#ifdef HAS_TANGENTS\n  vec3 normalW = normalize(vec3(u_NormalMatrix * vec4(normal.xyz, 0.0)));\n  vec3 tangentW = normalize(vec3(u_ModelMatrix * vec4(tangent.xyz, 0.0)));\n  vec3 bitangentW = cross(normalW, tangentW) * tangent.w;\n  pbr_vTBN = mat3(tangentW, bitangentW, normalW);\n#else\n  pbr_vNormal = normalize(vec3(u_ModelMatrix * vec4(normal.xyz, 0.0)));\n#endif\n#endif\n\n#ifdef HAS_UV\n  pbr_vUV = uv;\n#else\n  pbr_vUV = vec2(0.,0.);\n#endif\n}\n";

  // ../../node_modules/@luma.gl/shadertools/dist/esm/modules/pbr/pbr-fragment.glsl.js
  var pbr_fragment_glsl_default = "#if defined(USE_TEX_LOD) && !defined(FEATURE_GLSL_TEXTURE_LOD)\n# error PBR fragment shader: Texture LOD is not available\n#endif\n\n#if !defined(HAS_TANGENTS) && !defined(FEATURE_GLSL_DERIVATIVES)\n# error PBR fragment shader: Derivatives are not available\n#endif\n\n\n#if (__VERSION__ < 300)\n  #define SMART_FOR(INIT, WEBGL1COND, WEBGL2COND, INCR) for (INIT; WEBGL1COND; INCR)\n#else\n  #define SMART_FOR(INIT, WEBGL1COND, WEBGL2COND, INCR) for (INIT; WEBGL2COND; INCR)\n#endif\n\nprecision highp float;\n\nuniform bool pbr_uUnlit;\n\n#ifdef USE_IBL\nuniform samplerCube u_DiffuseEnvSampler;\nuniform samplerCube u_SpecularEnvSampler;\nuniform sampler2D u_brdfLUT;\nuniform vec2 u_ScaleIBLAmbient;\n#endif\n\n#ifdef HAS_BASECOLORMAP\nuniform sampler2D u_BaseColorSampler;\n#endif\n#ifdef HAS_NORMALMAP\nuniform sampler2D u_NormalSampler;\nuniform float u_NormalScale;\n#endif\n#ifdef HAS_EMISSIVEMAP\nuniform sampler2D u_EmissiveSampler;\nuniform vec3 u_EmissiveFactor;\n#endif\n#ifdef HAS_METALROUGHNESSMAP\nuniform sampler2D u_MetallicRoughnessSampler;\n#endif\n#ifdef HAS_OCCLUSIONMAP\nuniform sampler2D u_OcclusionSampler;\nuniform float u_OcclusionStrength;\n#endif\n\n#ifdef ALPHA_CUTOFF\nuniform float u_AlphaCutoff;\n#endif\n\nuniform vec2 u_MetallicRoughnessValues;\nuniform vec4 u_BaseColorFactor;\n\nuniform vec3 u_Camera;\n#ifdef PBR_DEBUG\nuniform vec4 u_ScaleDiffBaseMR;\nuniform vec4 u_ScaleFGDSpec;\n#endif\n\nvarying vec3 pbr_vPosition;\n\nvarying vec2 pbr_vUV;\n\n#ifdef HAS_NORMALS\n#ifdef HAS_TANGENTS\nvarying mat3 pbr_vTBN;\n#else\nvarying vec3 pbr_vNormal;\n#endif\n#endif\n\n\nstruct PBRInfo\n{\n  float NdotL;\n  float NdotV;\n  float NdotH;\n  float LdotH;\n  float VdotH;\n  float perceptualRoughness;\n  float metalness;\n  vec3 reflectance0;\n  vec3 reflectance90;\n  float alphaRoughness;\n  vec3 diffuseColor;\n  vec3 specularColor;\n  vec3 n;\n  vec3 v;\n};\n\nconst float M_PI = 3.141592653589793;\nconst float c_MinRoughness = 0.04;\n\nvec4 SRGBtoLINEAR(vec4 srgbIn)\n{\n#ifdef MANUAL_SRGB\n#ifdef SRGB_FAST_APPROXIMATION\n  vec3 linOut = pow(srgbIn.xyz,vec3(2.2));\n#else\n  vec3 bLess = step(vec3(0.04045),srgbIn.xyz);\n  vec3 linOut = mix( srgbIn.xyz/vec3(12.92), pow((srgbIn.xyz+vec3(0.055))/vec3(1.055),vec3(2.4)), bLess );\n#endif\n  return vec4(linOut,srgbIn.w);;\n#else\n  return srgbIn;\n#endif\n}\n\nvec3 getNormal()\n{\n#ifndef HAS_TANGENTS\n  vec3 pos_dx = dFdx(pbr_vPosition);\n  vec3 pos_dy = dFdy(pbr_vPosition);\n  vec3 tex_dx = dFdx(vec3(pbr_vUV, 0.0));\n  vec3 tex_dy = dFdy(vec3(pbr_vUV, 0.0));\n  vec3 t = (tex_dy.t * pos_dx - tex_dx.t * pos_dy) / (tex_dx.s * tex_dy.t - tex_dy.s * tex_dx.t);\n\n#ifdef HAS_NORMALS\n  vec3 ng = normalize(pbr_vNormal);\n#else\n  vec3 ng = cross(pos_dx, pos_dy);\n#endif\n\n  t = normalize(t - ng * dot(ng, t));\n  vec3 b = normalize(cross(ng, t));\n  mat3 tbn = mat3(t, b, ng);\n#else\n  mat3 tbn = pbr_vTBN;\n#endif\n\n#ifdef HAS_NORMALMAP\n  vec3 n = texture2D(u_NormalSampler, pbr_vUV).rgb;\n  n = normalize(tbn * ((2.0 * n - 1.0) * vec3(u_NormalScale, u_NormalScale, 1.0)));\n#else\n  vec3 n = normalize(tbn[2].xyz);\n#endif\n\n  return n;\n}\n\n\n#ifdef USE_IBL\nvec3 getIBLContribution(PBRInfo pbrInputs, vec3 n, vec3 reflection)\n{\n  float mipCount = 9.0;\n  float lod = (pbrInputs.perceptualRoughness * mipCount);\n  vec3 brdf = SRGBtoLINEAR(texture2D(u_brdfLUT,\n    vec2(pbrInputs.NdotV, 1.0 - pbrInputs.perceptualRoughness))).rgb;\n  vec3 diffuseLight = SRGBtoLINEAR(textureCube(u_DiffuseEnvSampler, n)).rgb;\n\n#ifdef USE_TEX_LOD\n  vec3 specularLight = SRGBtoLINEAR(textureCubeLod(u_SpecularEnvSampler, reflection, lod)).rgb;\n#else\n  vec3 specularLight = SRGBtoLINEAR(textureCube(u_SpecularEnvSampler, reflection)).rgb;\n#endif\n\n  vec3 diffuse = diffuseLight * pbrInputs.diffuseColor;\n  vec3 specular = specularLight * (pbrInputs.specularColor * brdf.x + brdf.y);\n  diffuse *= u_ScaleIBLAmbient.x;\n  specular *= u_ScaleIBLAmbient.y;\n\n  return diffuse + specular;\n}\n#endif\n\n\nvec3 diffuse(PBRInfo pbrInputs)\n{\n  return pbrInputs.diffuseColor / M_PI;\n}\n\nvec3 specularReflection(PBRInfo pbrInputs)\n{\n  return pbrInputs.reflectance0 +\n    (pbrInputs.reflectance90 - pbrInputs.reflectance0) *\n    pow(clamp(1.0 - pbrInputs.VdotH, 0.0, 1.0), 5.0);\n}\n\n\n\nfloat geometricOcclusion(PBRInfo pbrInputs)\n{\n  float NdotL = pbrInputs.NdotL;\n  float NdotV = pbrInputs.NdotV;\n  float r = pbrInputs.alphaRoughness;\n\n  float attenuationL = 2.0 * NdotL / (NdotL + sqrt(r * r + (1.0 - r * r) * (NdotL * NdotL)));\n  float attenuationV = 2.0 * NdotV / (NdotV + sqrt(r * r + (1.0 - r * r) * (NdotV * NdotV)));\n  return attenuationL * attenuationV;\n}\n\n\n\n\n\nfloat microfacetDistribution(PBRInfo pbrInputs)\n{\n  float roughnessSq = pbrInputs.alphaRoughness * pbrInputs.alphaRoughness;\n  float f = (pbrInputs.NdotH * roughnessSq - pbrInputs.NdotH) * pbrInputs.NdotH + 1.0;\n  return roughnessSq / (M_PI * f * f);\n}\n\nvoid PBRInfo_setAmbientLight(inout PBRInfo pbrInputs) {\n  pbrInputs.NdotL = 1.0;\n  pbrInputs.NdotH = 0.0;\n  pbrInputs.LdotH = 0.0;\n  pbrInputs.VdotH = 1.0;\n}\n\nvoid PBRInfo_setDirectionalLight(inout PBRInfo pbrInputs, vec3 lightDirection) {\n  vec3 n = pbrInputs.n;\n  vec3 v = pbrInputs.v;\n  vec3 l = normalize(lightDirection);\n  vec3 h = normalize(l+v);\n\n  pbrInputs.NdotL = clamp(dot(n, l), 0.001, 1.0);\n  pbrInputs.NdotH = clamp(dot(n, h), 0.0, 1.0);\n  pbrInputs.LdotH = clamp(dot(l, h), 0.0, 1.0);\n  pbrInputs.VdotH = clamp(dot(v, h), 0.0, 1.0);\n}\n\nvoid PBRInfo_setPointLight(inout PBRInfo pbrInputs, PointLight pointLight) {\n  vec3 light_direction = normalize(pointLight.position - pbr_vPosition);\n  PBRInfo_setDirectionalLight(pbrInputs, light_direction);\n}\n\nvec3 calculateFinalColor(PBRInfo pbrInputs, vec3 lightColor) {\n  vec3 F = specularReflection(pbrInputs);\n  float G = geometricOcclusion(pbrInputs);\n  float D = microfacetDistribution(pbrInputs);\n  vec3 diffuseContrib = (1.0 - F) * diffuse(pbrInputs);\n  vec3 specContrib = F * G * D / (4.0 * pbrInputs.NdotL * pbrInputs.NdotV);\n  return pbrInputs.NdotL * lightColor * (diffuseContrib + specContrib);\n}\n\nvec4 pbr_filterColor(vec4 colorUnused)\n{\n#ifdef HAS_BASECOLORMAP\n  vec4 baseColor = SRGBtoLINEAR(texture2D(u_BaseColorSampler, pbr_vUV)) * u_BaseColorFactor;\n#else\n  vec4 baseColor = u_BaseColorFactor;\n#endif\n\n#ifdef ALPHA_CUTOFF\n  if (baseColor.a < u_AlphaCutoff) {\n    discard;\n  }\n#endif\n\n  vec3 color = vec3(0, 0, 0);\n\n  if(pbr_uUnlit){\n    color.rgb = baseColor.rgb;\n  }\n  else{\n\n\n    float perceptualRoughness = u_MetallicRoughnessValues.y;\n    float metallic = u_MetallicRoughnessValues.x;\n#ifdef HAS_METALROUGHNESSMAP\n\n    vec4 mrSample = texture2D(u_MetallicRoughnessSampler, pbr_vUV);\n    perceptualRoughness = mrSample.g * perceptualRoughness;\n    metallic = mrSample.b * metallic;\n#endif\n    perceptualRoughness = clamp(perceptualRoughness, c_MinRoughness, 1.0);\n    metallic = clamp(metallic, 0.0, 1.0);\n\n    float alphaRoughness = perceptualRoughness * perceptualRoughness;\n\n    vec3 f0 = vec3(0.04);\n    vec3 diffuseColor = baseColor.rgb * (vec3(1.0) - f0);\n    diffuseColor *= 1.0 - metallic;\n    vec3 specularColor = mix(f0, baseColor.rgb, metallic);\n    float reflectance = max(max(specularColor.r, specularColor.g), specularColor.b);\n\n\n\n    float reflectance90 = clamp(reflectance * 25.0, 0.0, 1.0);\n    vec3 specularEnvironmentR0 = specularColor.rgb;\n    vec3 specularEnvironmentR90 = vec3(1.0, 1.0, 1.0) * reflectance90;\n\n    vec3 n = getNormal();\n    vec3 v = normalize(u_Camera - pbr_vPosition);\n\n    float NdotV = clamp(abs(dot(n, v)), 0.001, 1.0);\n    vec3 reflection = -normalize(reflect(v, n));\n\n    PBRInfo pbrInputs = PBRInfo(\n      0.0,\n      NdotV,\n      0.0,\n      0.0,\n      0.0,\n      perceptualRoughness,\n      metallic,\n      specularEnvironmentR0,\n      specularEnvironmentR90,\n      alphaRoughness,\n      diffuseColor,\n      specularColor,\n      n,\n      v\n    );\n\n#ifdef USE_LIGHTS\n    PBRInfo_setAmbientLight(pbrInputs);\n    color += calculateFinalColor(pbrInputs, lighting_uAmbientLight.color);\n    SMART_FOR(int i = 0, i < MAX_LIGHTS, i < lighting_uDirectionalLightCount, i++) {\n      if (i < lighting_uDirectionalLightCount) {\n        PBRInfo_setDirectionalLight(pbrInputs, lighting_uDirectionalLight[i].direction);\n        color += calculateFinalColor(pbrInputs, lighting_uDirectionalLight[i].color);\n      }\n    }\n    SMART_FOR(int i = 0, i < MAX_LIGHTS, i < lighting_uPointLightCount, i++) {\n      if (i < lighting_uPointLightCount) {\n        PBRInfo_setPointLight(pbrInputs, lighting_uPointLight[i]);\n        float attenuation = getPointLightAttenuation(lighting_uPointLight[i], distance(lighting_uPointLight[i].position, pbr_vPosition));\n        color += calculateFinalColor(pbrInputs, lighting_uPointLight[i].color / attenuation);\n      }\n    }\n#endif\n#ifdef USE_IBL\n    color += getIBLContribution(pbrInputs, n, reflection);\n#endif\n#ifdef HAS_OCCLUSIONMAP\n    float ao = texture2D(u_OcclusionSampler, pbr_vUV).r;\n    color = mix(color, color * ao, u_OcclusionStrength);\n#endif\n\n#ifdef HAS_EMISSIVEMAP\n    vec3 emissive = SRGBtoLINEAR(texture2D(u_EmissiveSampler, pbr_vUV)).rgb * u_EmissiveFactor;\n    color += emissive;\n#endif\n\n#ifdef PBR_DEBUG\n\n\n\n\n\n    color = mix(color, baseColor.rgb, u_ScaleDiffBaseMR.y);\n    color = mix(color, vec3(metallic), u_ScaleDiffBaseMR.z);\n    color = mix(color, vec3(perceptualRoughness), u_ScaleDiffBaseMR.w);\n#endif\n\n  }\n\n  return vec4(pow(color,vec3(1.0/2.2)), baseColor.a);\n}\n";

  // ../../node_modules/@luma.gl/shadertools/dist/esm/modules/pbr/pbr.js
  var pbr = {
    name: "pbr",
    vs: pbr_vertex_glsl_default,
    fs: pbr_fragment_glsl_default,
    defines: {
      LIGHTING_FRAGMENT: 1
    },
    dependencies: [lights]
  };

  // ../../node_modules/@loaders.gl/images/dist/esm/lib/utils/version.js
  var VERSION3 = true ? "3.3.3" : "latest";

  // ../../node_modules/@loaders.gl/loader-utils/dist/esm/lib/env-utils/assert.js
  function assert7(condition, message) {
    if (!condition) {
      throw new Error(message || "loader assertion failed.");
    }
  }

  // ../../node_modules/@loaders.gl/loader-utils/dist/esm/lib/env-utils/globals.js
  var globals2 = {
    self: typeof self !== "undefined" && self,
    window: typeof window !== "undefined" && window,
    global: typeof global !== "undefined" && global,
    document: typeof document !== "undefined" && document
  };
  var self_2 = globals2.self || globals2.window || globals2.global || {};
  var window_2 = globals2.window || globals2.self || globals2.global || {};
  var global_2 = globals2.global || globals2.self || globals2.window || {};
  var document_2 = globals2.document || {};
  var isBrowser4 = Boolean(typeof process !== "object" || String(process) !== "[object process]" || process.browser);
  var matches = typeof process !== "undefined" && process.version && /v([0-9]*)/.exec(process.version);
  var nodeVersion = matches && parseFloat(matches[1]) || 0;

  // ../../node_modules/@loaders.gl/worker-utils/dist/esm/lib/env-utils/assert.js
  function assert8(condition, message) {
    if (!condition) {
      throw new Error(message || "loaders.gl assertion failed.");
    }
  }

  // ../../node_modules/@loaders.gl/worker-utils/dist/esm/lib/env-utils/globals.js
  var globals3 = {
    self: typeof self !== "undefined" && self,
    window: typeof window !== "undefined" && window,
    global: typeof global !== "undefined" && global,
    document: typeof document !== "undefined" && document
  };
  var self_3 = globals3.self || globals3.window || globals3.global || {};
  var window_3 = globals3.window || globals3.self || globals3.global || {};
  var global_3 = globals3.global || globals3.self || globals3.window || {};
  var document_3 = globals3.document || {};
  var isBrowser5 = typeof process !== "object" || String(process) !== "[object process]" || process.browser;
  var isWorker = typeof importScripts === "function";
  var isMobile2 = typeof window !== "undefined" && typeof window.orientation !== "undefined";
  var matches2 = typeof process !== "undefined" && process.version && /v([0-9]*)/.exec(process.version);
  var nodeVersion2 = matches2 && parseFloat(matches2[1]) || 0;

  // ../../node_modules/@loaders.gl/worker-utils/dist/esm/lib/library-utils/library-utils.js
  var node = __toESM(require_require_utils());
  var VERSION4 = true ? "3.3.3" : LATEST;
  var loadLibraryPromises = {};
  async function loadLibrary(libraryUrl) {
    let moduleName = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (moduleName) {
      libraryUrl = getLibraryUrl(libraryUrl, moduleName, options);
    }
    loadLibraryPromises[libraryUrl] = loadLibraryPromises[libraryUrl] || loadLibraryFromFile(libraryUrl);
    return await loadLibraryPromises[libraryUrl];
  }
  function getLibraryUrl(library, moduleName, options) {
    if (library.startsWith("http")) {
      return library;
    }
    const modules = options.modules || {};
    if (modules[library]) {
      return modules[library];
    }
    if (!isBrowser5) {
      return "modules/".concat(moduleName, "/dist/libs/").concat(library);
    }
    if (options.CDN) {
      assert8(options.CDN.startsWith("http"));
      return "".concat(options.CDN, "/").concat(moduleName, "@").concat(VERSION4, "/dist/libs/").concat(library);
    }
    if (isWorker) {
      return "../src/libs/".concat(library);
    }
    return "modules/".concat(moduleName, "/src/libs/").concat(library);
  }
  async function loadLibraryFromFile(libraryUrl) {
    if (libraryUrl.endsWith("wasm")) {
      const response2 = await fetch(libraryUrl);
      return await response2.arrayBuffer();
    }
    if (!isBrowser5) {
      try {
        return node && node.requireFromFile && await node.requireFromFile(libraryUrl);
      } catch {
        return null;
      }
    }
    if (isWorker) {
      return importScripts(libraryUrl);
    }
    const response = await fetch(libraryUrl);
    const scriptSource = await response.text();
    return loadLibraryFromString(scriptSource, libraryUrl);
  }
  function loadLibraryFromString(scriptSource, id) {
    if (!isBrowser5) {
      return node.requireFromString && node.requireFromString(scriptSource, id);
    }
    if (isWorker) {
      eval.call(global_3, scriptSource);
      return null;
    }
    const script = document.createElement("script");
    script.id = id;
    try {
      script.appendChild(document.createTextNode(scriptSource));
    } catch (e) {
      script.text = scriptSource;
    }
    document.body.appendChild(script);
    return null;
  }

  // ../../node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/get-first-characters.js
  function getFirstCharacters(data) {
    let length4 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 5;
    if (typeof data === "string") {
      return data.slice(0, length4);
    } else if (ArrayBuffer.isView(data)) {
      return getMagicString(data.buffer, data.byteOffset, length4);
    } else if (data instanceof ArrayBuffer) {
      const byteOffset = 0;
      return getMagicString(data, byteOffset, length4);
    }
    return "";
  }
  function getMagicString(arrayBuffer2, byteOffset, length4) {
    if (arrayBuffer2.byteLength <= byteOffset + length4) {
      return "";
    }
    const dataView = new DataView(arrayBuffer2);
    let magic = "";
    for (let i2 = 0; i2 < length4; i2++) {
      magic += String.fromCharCode(dataView.getUint8(byteOffset + i2));
    }
    return magic;
  }

  // ../../node_modules/@loaders.gl/loader-utils/dist/esm/lib/parser-utils/parse-json.js
  function parseJSON(string) {
    try {
      return JSON.parse(string);
    } catch (_) {
      throw new Error('Failed to parse JSON from data starting with "'.concat(getFirstCharacters(string), '"'));
    }
  }

  // ../../node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/array-buffer-utils.js
  function sliceArrayBuffer(arrayBuffer2, byteOffset, byteLength) {
    const subArray = byteLength !== void 0 ? new Uint8Array(arrayBuffer2).subarray(byteOffset, byteOffset + byteLength) : new Uint8Array(arrayBuffer2).subarray(byteOffset);
    const arrayCopy = new Uint8Array(subArray);
    return arrayCopy.buffer;
  }

  // ../../node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/memory-copy-utils.js
  function padToNBytes(byteLength, padding) {
    assert7(byteLength >= 0);
    assert7(padding > 0);
    return byteLength + (padding - 1) & ~(padding - 1);
  }
  function copyToArray(source, target, targetOffset) {
    let sourceArray;
    if (source instanceof ArrayBuffer) {
      sourceArray = new Uint8Array(source);
    } else {
      const srcByteOffset = source.byteOffset;
      const srcByteLength = source.byteLength;
      sourceArray = new Uint8Array(source.buffer || source.arrayBuffer, srcByteOffset, srcByteLength);
    }
    target.set(sourceArray, targetOffset);
    return targetOffset + padToNBytes(sourceArray.byteLength, 4);
  }

  // ../../node_modules/@loaders.gl/images/dist/esm/lib/category-api/image-type.js
  var {
    _parseImageNode
  } = globalThis;
  var IMAGE_SUPPORTED = typeof Image !== "undefined";
  var IMAGE_BITMAP_SUPPORTED = typeof ImageBitmap !== "undefined";
  var NODE_IMAGE_SUPPORTED = Boolean(_parseImageNode);
  var DATA_SUPPORTED = isBrowser4 ? true : NODE_IMAGE_SUPPORTED;
  function isImageTypeSupported(type) {
    switch (type) {
      case "auto":
        return IMAGE_BITMAP_SUPPORTED || IMAGE_SUPPORTED || DATA_SUPPORTED;
      case "imagebitmap":
        return IMAGE_BITMAP_SUPPORTED;
      case "image":
        return IMAGE_SUPPORTED;
      case "data":
        return DATA_SUPPORTED;
      default:
        throw new Error("@loaders.gl/images: image ".concat(type, " not supported in this environment"));
    }
  }
  function getDefaultImageType() {
    if (IMAGE_BITMAP_SUPPORTED) {
      return "imagebitmap";
    }
    if (IMAGE_SUPPORTED) {
      return "image";
    }
    if (DATA_SUPPORTED) {
      return "data";
    }
    throw new Error("Install '@loaders.gl/polyfills' to parse images under Node.js");
  }

  // ../../node_modules/@loaders.gl/images/dist/esm/lib/category-api/parsed-image-api.js
  function getImageType(image) {
    const format = getImageTypeOrNull(image);
    if (!format) {
      throw new Error("Not an image");
    }
    return format;
  }
  function getImageData(image) {
    switch (getImageType(image)) {
      case "data":
        return image;
      case "image":
      case "imagebitmap":
        const canvas = document.createElement("canvas");
        const context = canvas.getContext("2d");
        if (!context) {
          throw new Error("getImageData");
        }
        canvas.width = image.width;
        canvas.height = image.height;
        context.drawImage(image, 0, 0);
        return context.getImageData(0, 0, image.width, image.height);
      default:
        throw new Error("getImageData");
    }
  }
  function getImageTypeOrNull(image) {
    if (typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
      return "imagebitmap";
    }
    if (typeof Image !== "undefined" && image instanceof Image) {
      return "image";
    }
    if (image && typeof image === "object" && image.data && image.width && image.height) {
      return "data";
    }
    return null;
  }

  // ../../node_modules/@loaders.gl/images/dist/esm/lib/parsers/svg-utils.js
  var SVG_DATA_URL_PATTERN = /^data:image\/svg\+xml/;
  var SVG_URL_PATTERN = /\.svg((\?|#).*)?$/;
  function isSVG(url) {
    return url && (SVG_DATA_URL_PATTERN.test(url) || SVG_URL_PATTERN.test(url));
  }
  function getBlobOrSVGDataUrl(arrayBuffer2, url) {
    if (isSVG(url)) {
      const textDecoder = new TextDecoder();
      let xmlText = textDecoder.decode(arrayBuffer2);
      try {
        if (typeof unescape === "function" && typeof encodeURIComponent === "function") {
          xmlText = unescape(encodeURIComponent(xmlText));
        }
      } catch (error2) {
        throw new Error(error2.message);
      }
      const src = "data:image/svg+xml;base64,".concat(btoa(xmlText));
      return src;
    }
    return getBlob(arrayBuffer2, url);
  }
  function getBlob(arrayBuffer2, url) {
    if (isSVG(url)) {
      throw new Error("SVG cannot be parsed directly to imagebitmap");
    }
    return new Blob([new Uint8Array(arrayBuffer2)]);
  }

  // ../../node_modules/@loaders.gl/images/dist/esm/lib/parsers/parse-to-image.js
  async function parseToImage(arrayBuffer2, options, url) {
    const blobOrDataUrl = getBlobOrSVGDataUrl(arrayBuffer2, url);
    const URL = self.URL || self.webkitURL;
    const objectUrl = typeof blobOrDataUrl !== "string" && URL.createObjectURL(blobOrDataUrl);
    try {
      return await loadToImage(objectUrl || blobOrDataUrl, options);
    } finally {
      if (objectUrl) {
        URL.revokeObjectURL(objectUrl);
      }
    }
  }
  async function loadToImage(url, options) {
    const image = new Image();
    image.src = url;
    if (options.image && options.image.decode && image.decode) {
      await image.decode();
      return image;
    }
    return await new Promise((resolve, reject) => {
      try {
        image.onload = () => resolve(image);
        image.onerror = (err) => reject(new Error("Could not load image ".concat(url, ": ").concat(err)));
      } catch (error2) {
        reject(error2);
      }
    });
  }

  // ../../node_modules/@loaders.gl/images/dist/esm/lib/parsers/parse-to-image-bitmap.js
  var EMPTY_OBJECT = {};
  var imagebitmapOptionsSupported = true;
  async function parseToImageBitmap(arrayBuffer2, options, url) {
    let blob;
    if (isSVG(url)) {
      const image = await parseToImage(arrayBuffer2, options, url);
      blob = image;
    } else {
      blob = getBlob(arrayBuffer2, url);
    }
    const imagebitmapOptions = options && options.imagebitmap;
    return await safeCreateImageBitmap(blob, imagebitmapOptions);
  }
  async function safeCreateImageBitmap(blob) {
    let imagebitmapOptions = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    if (isEmptyObject(imagebitmapOptions) || !imagebitmapOptionsSupported) {
      imagebitmapOptions = null;
    }
    if (imagebitmapOptions) {
      try {
        return await createImageBitmap(blob, imagebitmapOptions);
      } catch (error2) {
        console.warn(error2);
        imagebitmapOptionsSupported = false;
      }
    }
    return await createImageBitmap(blob);
  }
  function isEmptyObject(object) {
    for (const key in object || EMPTY_OBJECT) {
      return false;
    }
    return true;
  }

  // ../../node_modules/@loaders.gl/images/dist/esm/lib/category-api/binary-image-api.js
  var BIG_ENDIAN = false;
  var LITTLE_ENDIAN = true;
  function getBinaryImageMetadata(binaryData) {
    const dataView = toDataView(binaryData);
    return getPngMetadata(dataView) || getJpegMetadata(dataView) || getGifMetadata(dataView) || getBmpMetadata(dataView);
  }
  function getPngMetadata(binaryData) {
    const dataView = toDataView(binaryData);
    const isPng = dataView.byteLength >= 24 && dataView.getUint32(0, BIG_ENDIAN) === 2303741511;
    if (!isPng) {
      return null;
    }
    return {
      mimeType: "image/png",
      width: dataView.getUint32(16, BIG_ENDIAN),
      height: dataView.getUint32(20, BIG_ENDIAN)
    };
  }
  function getGifMetadata(binaryData) {
    const dataView = toDataView(binaryData);
    const isGif = dataView.byteLength >= 10 && dataView.getUint32(0, BIG_ENDIAN) === 1195984440;
    if (!isGif) {
      return null;
    }
    return {
      mimeType: "image/gif",
      width: dataView.getUint16(6, LITTLE_ENDIAN),
      height: dataView.getUint16(8, LITTLE_ENDIAN)
    };
  }
  function getBmpMetadata(binaryData) {
    const dataView = toDataView(binaryData);
    const isBmp = dataView.byteLength >= 14 && dataView.getUint16(0, BIG_ENDIAN) === 16973 && dataView.getUint32(2, LITTLE_ENDIAN) === dataView.byteLength;
    if (!isBmp) {
      return null;
    }
    return {
      mimeType: "image/bmp",
      width: dataView.getUint32(18, LITTLE_ENDIAN),
      height: dataView.getUint32(22, LITTLE_ENDIAN)
    };
  }
  function getJpegMetadata(binaryData) {
    const dataView = toDataView(binaryData);
    const isJpeg = dataView.byteLength >= 3 && dataView.getUint16(0, BIG_ENDIAN) === 65496 && dataView.getUint8(2) === 255;
    if (!isJpeg) {
      return null;
    }
    const {
      tableMarkers,
      sofMarkers
    } = getJpegMarkers();
    let i2 = 2;
    while (i2 + 9 < dataView.byteLength) {
      const marker = dataView.getUint16(i2, BIG_ENDIAN);
      if (sofMarkers.has(marker)) {
        return {
          mimeType: "image/jpeg",
          height: dataView.getUint16(i2 + 5, BIG_ENDIAN),
          width: dataView.getUint16(i2 + 7, BIG_ENDIAN)
        };
      }
      if (!tableMarkers.has(marker)) {
        return null;
      }
      i2 += 2;
      i2 += dataView.getUint16(i2, BIG_ENDIAN);
    }
    return null;
  }
  function getJpegMarkers() {
    const tableMarkers = /* @__PURE__ */ new Set([65499, 65476, 65484, 65501, 65534]);
    for (let i2 = 65504; i2 < 65520; ++i2) {
      tableMarkers.add(i2);
    }
    const sofMarkers = /* @__PURE__ */ new Set([65472, 65473, 65474, 65475, 65477, 65478, 65479, 65481, 65482, 65483, 65485, 65486, 65487, 65502]);
    return {
      tableMarkers,
      sofMarkers
    };
  }
  function toDataView(data) {
    if (data instanceof DataView) {
      return data;
    }
    if (ArrayBuffer.isView(data)) {
      return new DataView(data.buffer);
    }
    if (data instanceof ArrayBuffer) {
      return new DataView(data);
    }
    throw new Error("toDataView");
  }

  // ../../node_modules/@loaders.gl/images/dist/esm/lib/parsers/parse-to-node-image.js
  async function parseToNodeImage(arrayBuffer2, options) {
    const {
      mimeType
    } = getBinaryImageMetadata(arrayBuffer2) || {};
    const _parseImageNode2 = globalThis._parseImageNode;
    assert7(_parseImageNode2);
    return await _parseImageNode2(arrayBuffer2, mimeType);
  }

  // ../../node_modules/@loaders.gl/images/dist/esm/lib/parsers/parse-image.js
  async function parseImage(arrayBuffer2, options, context) {
    options = options || {};
    const imageOptions = options.image || {};
    const imageType = imageOptions.type || "auto";
    const {
      url
    } = context || {};
    const loadType = getLoadableImageType(imageType);
    let image;
    switch (loadType) {
      case "imagebitmap":
        image = await parseToImageBitmap(arrayBuffer2, options, url);
        break;
      case "image":
        image = await parseToImage(arrayBuffer2, options, url);
        break;
      case "data":
        image = await parseToNodeImage(arrayBuffer2, options);
        break;
      default:
        assert7(false);
    }
    if (imageType === "data") {
      image = getImageData(image);
    }
    return image;
  }
  function getLoadableImageType(type) {
    switch (type) {
      case "auto":
      case "data":
        return getDefaultImageType();
      default:
        isImageTypeSupported(type);
        return type;
    }
  }

  // ../../node_modules/@loaders.gl/images/dist/esm/image-loader.js
  var EXTENSIONS = ["png", "jpg", "jpeg", "gif", "webp", "bmp", "ico", "svg"];
  var MIME_TYPES = ["image/png", "image/jpeg", "image/gif", "image/webp", "image/bmp", "image/vnd.microsoft.icon", "image/svg+xml"];
  var DEFAULT_IMAGE_LOADER_OPTIONS = {
    image: {
      type: "auto",
      decode: true
    }
  };
  var ImageLoader = {
    id: "image",
    module: "images",
    name: "Images",
    version: VERSION3,
    mimeTypes: MIME_TYPES,
    extensions: EXTENSIONS,
    parse: parseImage,
    tests: [(arrayBuffer2) => Boolean(getBinaryImageMetadata(new DataView(arrayBuffer2)))],
    options: DEFAULT_IMAGE_LOADER_OPTIONS
  };

  // ../../node_modules/@loaders.gl/images/dist/esm/lib/category-api/image-format.js
  var NODE_FORMAT_SUPPORT = ["image/png", "image/jpeg", "image/gif"];
  var mimeTypeSupported = {};
  function _isImageFormatSupported(mimeType) {
    if (mimeTypeSupported[mimeType] === void 0) {
      mimeTypeSupported[mimeType] = checkFormatSupport(mimeType);
    }
    return mimeTypeSupported[mimeType];
  }
  function checkFormatSupport(mimeType) {
    switch (mimeType) {
      case "image/webp":
        return checkWebPSupport();
      case "image/svg":
        return isBrowser4;
      default:
        if (!isBrowser4) {
          const {
            _parseImageNode: _parseImageNode2
          } = globalThis;
          return Boolean(_parseImageNode2) && NODE_FORMAT_SUPPORT.includes(mimeType);
        }
        return true;
    }
  }
  function checkWebPSupport() {
    if (!isBrowser4) {
      return false;
    }
    try {
      const element = document.createElement("canvas");
      return element.toDataURL("image/webp").indexOf("data:image/webp") === 0;
    } catch {
      return false;
    }
  }

  // ../../node_modules/@luma.gl/experimental/dist/esm/scenegraph/scenegraph-node.js
  var ScenegraphNode = class {
    constructor() {
      let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const {
        id
      } = props;
      this.id = id || uid(this.constructor.name);
      this.display = true;
      this.position = new Vector3();
      this.rotation = new Vector3();
      this.scale = new Vector3(1, 1, 1);
      this.matrix = new Matrix4();
      this.userData = {};
      this.props = {};
      this._setScenegraphNodeProps(props);
    }
    delete() {
    }
    setProps(props) {
      this._setScenegraphNodeProps(props);
      return this;
    }
    toString() {
      return "{type: ScenegraphNode, id: ".concat(this.id, ")}");
    }
    setPosition(position) {
      assert3(position.length === 3, "setPosition requires vector argument");
      this.position = position;
      return this;
    }
    setRotation(rotation) {
      assert3(rotation.length === 3, "setRotation requires vector argument");
      this.rotation = rotation;
      return this;
    }
    setScale(scale5) {
      assert3(scale5.length === 3, "setScale requires vector argument");
      this.scale = scale5;
      return this;
    }
    setMatrix(matrix) {
      let copyMatrix = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      if (copyMatrix) {
        this.matrix.copy(matrix);
      } else {
        this.matrix = matrix;
      }
    }
    setMatrixComponents(_ref) {
      let {
        position,
        rotation,
        scale: scale5,
        update = true
      } = _ref;
      if (position) {
        this.setPosition(position);
      }
      if (rotation) {
        this.setRotation(rotation);
      }
      if (scale5) {
        this.setScale(scale5);
      }
      if (update) {
        this.updateMatrix();
      }
      return this;
    }
    updateMatrix() {
      const pos = this.position;
      const rot = this.rotation;
      const scale5 = this.scale;
      this.matrix.identity();
      this.matrix.translate(pos);
      this.matrix.rotateXYZ(rot);
      this.matrix.scale(scale5);
      return this;
    }
    update() {
      let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const {
        position,
        rotation,
        scale: scale5
      } = options;
      if (position) {
        this.setPosition(position);
      }
      if (rotation) {
        this.setRotation(rotation);
      }
      if (scale5) {
        this.setScale(scale5);
      }
      this.updateMatrix();
      return this;
    }
    getCoordinateUniforms(viewMatrix, modelMatrix2) {
      assert3(viewMatrix);
      modelMatrix2 = modelMatrix2 || this.matrix;
      const worldMatrix = new Matrix4(viewMatrix).multiplyRight(modelMatrix2);
      const worldInverse = worldMatrix.invert();
      const worldInverseTranspose = worldInverse.transpose();
      return {
        viewMatrix,
        modelMatrix: modelMatrix2,
        objectMatrix: modelMatrix2,
        worldMatrix,
        worldInverseMatrix: worldInverse,
        worldInverseTransposeMatrix: worldInverseTranspose
      };
    }
    _setScenegraphNodeProps(props) {
      if ("display" in props) {
        this.display = props.display;
      }
      if ("position" in props) {
        this.setPosition(props.position);
      }
      if ("rotation" in props) {
        this.setRotation(props.rotation);
      }
      if ("scale" in props) {
        this.setScale(props.scale);
      }
      if ("matrix" in props) {
        this.setMatrix(props.matrix);
      }
      Object.assign(this.props, props);
    }
  };

  // ../../node_modules/@luma.gl/experimental/dist/esm/scenegraph/group-node.js
  var GroupNode = class extends ScenegraphNode {
    constructor() {
      let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      props = Array.isArray(props) ? {
        children: props
      } : props;
      const {
        children = []
      } = props;
      log.assert(children.every((child) => child instanceof ScenegraphNode), "every child must an instance of ScenegraphNode");
      super(props);
      this.children = children;
    }
    add() {
      for (var _len = arguments.length, children = new Array(_len), _key = 0; _key < _len; _key++) {
        children[_key] = arguments[_key];
      }
      for (const child of children) {
        if (Array.isArray(child)) {
          this.add(...child);
        } else {
          this.children.push(child);
        }
      }
      return this;
    }
    remove(child) {
      const children = this.children;
      const indexOf = children.indexOf(child);
      if (indexOf > -1) {
        children.splice(indexOf, 1);
      }
      return this;
    }
    removeAll() {
      this.children = [];
      return this;
    }
    delete() {
      this.children.forEach((child) => child.delete());
      this.removeAll();
      super.delete();
    }
    traverse(visitor) {
      let {
        worldMatrix = new Matrix4()
      } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      const modelMatrix2 = new Matrix4(worldMatrix).multiplyRight(this.matrix);
      for (const child of this.children) {
        if (child instanceof GroupNode) {
          child.traverse(visitor, {
            worldMatrix: modelMatrix2
          });
        } else {
          visitor(child, {
            worldMatrix: modelMatrix2
          });
        }
      }
    }
  };

  // ../../node_modules/@luma.gl/experimental/dist/esm/gltf/gltf-animator.js
  var ATTRIBUTE_TYPE_TO_COMPONENTS = {
    SCALAR: 1,
    VEC2: 2,
    VEC3: 3,
    VEC4: 4,
    MAT2: 4,
    MAT3: 9,
    MAT4: 16
  };
  var ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY = {
    5120: Int8Array,
    5121: Uint8Array,
    5122: Int16Array,
    5123: Uint16Array,
    5125: Uint32Array,
    5126: Float32Array
  };
  function accessorToJsArray(accessor) {
    if (!accessor._animation) {
      const ArrayType = ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY[accessor.componentType];
      const components = ATTRIBUTE_TYPE_TO_COMPONENTS[accessor.type];
      const length4 = components * accessor.count;
      const {
        buffer,
        byteOffset
      } = accessor.bufferView.data;
      const array = new ArrayType(buffer, byteOffset + (accessor.byteOffset || 0), length4);
      if (components === 1) {
        accessor._animation = Array.from(array);
      } else {
        const slicedArray = [];
        for (let i2 = 0; i2 < array.length; i2 += components) {
          slicedArray.push(Array.from(array.slice(i2, i2 + components)));
        }
        accessor._animation = slicedArray;
      }
    }
    return accessor._animation;
  }
  var helperMatrix = new Matrix4();
  function applyTranslationRotationScale(gltfNode, node2) {
    node2.matrix.identity();
    if (gltfNode.translation) {
      node2.matrix.translate(gltfNode.translation);
    }
    if (gltfNode.rotation) {
      const rotationMatrix = helperMatrix.fromQuaternion(gltfNode.rotation);
      node2.matrix.multiplyRight(rotationMatrix);
    }
    if (gltfNode.scale) {
      node2.matrix.scale(gltfNode.scale);
    }
  }
  var quaternion = new Quaternion();
  function linearInterpolate(target, path, start, stop, ratio) {
    if (path === "rotation") {
      quaternion.slerp({
        start,
        target: stop,
        ratio
      });
      for (let i2 = 0; i2 < quaternion.length; i2++) {
        target[path][i2] = quaternion[i2];
      }
    } else {
      for (let i2 = 0; i2 < start.length; i2++) {
        target[path][i2] = ratio * stop[i2] + (1 - ratio) * start[i2];
      }
    }
  }
  function cubicsplineInterpolate(target, path, _ref) {
    let {
      p0,
      outTangent0,
      inTangent1,
      p1,
      tDiff,
      ratio: t2
    } = _ref;
    for (let i2 = 0; i2 < target[path].length; i2++) {
      const m0 = outTangent0[i2] * tDiff;
      const m1 = inTangent1[i2] * tDiff;
      target[path][i2] = (2 * Math.pow(t2, 3) - 3 * Math.pow(t2, 2) + 1) * p0[i2] + (Math.pow(t2, 3) - 2 * Math.pow(t2, 2) + t2) * m0 + (-2 * Math.pow(t2, 3) + 3 * Math.pow(t2, 2)) * p1[i2] + (Math.pow(t2, 3) - Math.pow(t2, 2)) * m1;
    }
  }
  function stepInterpolate(target, path, value) {
    for (let i2 = 0; i2 < value.length; i2++) {
      target[path][i2] = value[i2];
    }
  }
  function interpolate(time, _ref2, target, path) {
    let {
      input,
      interpolation,
      output
    } = _ref2;
    const maxTime = input[input.length - 1];
    const animationTime = time % maxTime;
    const nextIndex = input.findIndex((t2) => t2 >= animationTime);
    const previousIndex = Math.max(0, nextIndex - 1);
    if (!Array.isArray(target[path])) {
      switch (path) {
        case "translation":
          target[path] = [0, 0, 0];
          break;
        case "rotation":
          target[path] = [0, 0, 0, 1];
          break;
        case "scale":
          target[path] = [1, 1, 1];
          break;
        default:
          log.warn("Bad animation path ".concat(path))();
      }
    }
    assert3(target[path].length === output[previousIndex].length);
    const previousTime = input[previousIndex];
    const nextTime = input[nextIndex];
    switch (interpolation) {
      case "STEP":
        stepInterpolate(target, path, output[previousIndex]);
        break;
      case "LINEAR":
        if (nextTime > previousTime) {
          const ratio = (animationTime - previousTime) / (nextTime - previousTime);
          linearInterpolate(target, path, output[previousIndex], output[nextIndex], ratio);
        }
        break;
      case "CUBICSPLINE":
        if (nextTime > previousTime) {
          const ratio = (animationTime - previousTime) / (nextTime - previousTime);
          const tDiff = nextTime - previousTime;
          const p0 = output[3 * previousIndex + 1];
          const outTangent0 = output[3 * previousIndex + 2];
          const inTangent1 = output[3 * nextIndex + 0];
          const p1 = output[3 * nextIndex + 1];
          cubicsplineInterpolate(target, path, {
            p0,
            outTangent0,
            inTangent1,
            p1,
            tDiff,
            ratio
          });
        }
        break;
      default:
        log.warn("Interpolation ".concat(interpolation, " not supported"))();
        break;
    }
  }
  var GLTFAnimation = class {
    constructor(props) {
      this.startTime = 0;
      this.playing = true;
      this.speed = 1;
      this.channels = [];
      Object.assign(this, props);
    }
    animate(timeMs) {
      if (!this.playing) {
        return;
      }
      const absTime = timeMs / 1e3;
      const time = (absTime - this.startTime) * this.speed;
      this.channels.forEach((_ref3) => {
        let {
          sampler,
          target,
          path
        } = _ref3;
        interpolate(time, sampler, target, path);
        applyTranslationRotationScale(target, target._node);
      });
    }
  };
  var GLTFAnimator = class {
    constructor(gltf) {
      this.animations = gltf.animations.map((animation, index) => {
        const name10 = animation.name || "Animation-".concat(index);
        const samplers = animation.samplers.map((_ref4) => {
          let {
            input,
            interpolation = "LINEAR",
            output
          } = _ref4;
          return {
            input: accessorToJsArray(gltf.accessors[input]),
            interpolation,
            output: accessorToJsArray(gltf.accessors[output])
          };
        });
        const channels = animation.channels.map((_ref5) => {
          let {
            sampler,
            target
          } = _ref5;
          return {
            sampler: samplers[sampler],
            target: gltf.nodes[target.node],
            path: target.path
          };
        });
        return new GLTFAnimation({
          name: name10,
          channels
        });
      });
    }
    animate(time) {
      this.setTime(time);
    }
    setTime(time) {
      this.animations.forEach((animation) => animation.animate(time));
    }
    getAnimations() {
      return this.animations;
    }
  };

  // ../../node_modules/@luma.gl/engine/dist/esm/lib/program-manager.js
  var ProgramManager = class {
    static getDefaultProgramManager(gl) {
      gl.luma = gl.luma || {};
      gl.luma.defaultProgramManager = gl.luma.defaultProgramManager || new ProgramManager(gl);
      return gl.luma.defaultProgramManager;
    }
    constructor(gl) {
      this.gl = gl;
      this._programCache = {};
      this._getUniforms = {};
      this._registeredModules = {};
      this._hookFunctions = [];
      this._defaultModules = [];
      this._hashes = {};
      this._hashCounter = 0;
      this.stateHash = 0;
      this._useCounts = {};
    }
    addDefaultModule(module2) {
      if (!this._defaultModules.find((m) => m.name === module2.name)) {
        this._defaultModules.push(module2);
      }
      this.stateHash++;
    }
    removeDefaultModule(module2) {
      const moduleName = typeof module2 === "string" ? module2 : module2.name;
      this._defaultModules = this._defaultModules.filter((m) => m.name !== moduleName);
      this.stateHash++;
    }
    addShaderHook(hook, opts) {
      if (opts) {
        hook = Object.assign(opts, {
          hook
        });
      }
      this._hookFunctions.push(hook);
      this.stateHash++;
    }
    get() {
      let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const {
        vs: vs2 = "",
        fs: fs2 = "",
        defines = {},
        inject = {},
        varyings = [],
        bufferMode = 35981,
        transpileToGLSL100 = false
      } = props;
      const modules = this._getModuleList(props.modules);
      const vsHash = this._getHash(vs2);
      const fsHash = this._getHash(fs2);
      const moduleHashes = modules.map((m) => this._getHash(m.name)).sort();
      const varyingHashes = varyings.map((v) => this._getHash(v));
      const defineKeys = Object.keys(defines).sort();
      const injectKeys = Object.keys(inject).sort();
      const defineHashes = [];
      const injectHashes = [];
      for (const key of defineKeys) {
        defineHashes.push(this._getHash(key));
        defineHashes.push(this._getHash(defines[key]));
      }
      for (const key of injectKeys) {
        injectHashes.push(this._getHash(key));
        injectHashes.push(this._getHash(inject[key]));
      }
      const hash = "".concat(vsHash, "/").concat(fsHash, "D").concat(defineHashes.join("/"), "M").concat(moduleHashes.join("/"), "I").concat(injectHashes.join("/"), "V").concat(varyingHashes.join("/"), "H").concat(this.stateHash, "B").concat(bufferMode).concat(transpileToGLSL100 ? "T" : "");
      if (!this._programCache[hash]) {
        const assembled = assembleShaders(this.gl, {
          vs: vs2,
          fs: fs2,
          modules,
          inject,
          defines,
          hookFunctions: this._hookFunctions,
          transpileToGLSL100
        });
        this._programCache[hash] = new Program(this.gl, {
          hash,
          vs: assembled.vs,
          fs: assembled.fs,
          varyings,
          bufferMode
        });
        this._getUniforms[hash] = assembled.getUniforms || ((x) => {
        });
        this._useCounts[hash] = 0;
      }
      this._useCounts[hash]++;
      return this._programCache[hash];
    }
    getUniforms(program) {
      return this._getUniforms[program.hash] || null;
    }
    release(program) {
      const hash = program.hash;
      this._useCounts[hash]--;
      if (this._useCounts[hash] === 0) {
        this._programCache[hash].delete();
        delete this._programCache[hash];
        delete this._getUniforms[hash];
        delete this._useCounts[hash];
      }
    }
    _getHash(key) {
      if (this._hashes[key] === void 0) {
        this._hashes[key] = this._hashCounter++;
      }
      return this._hashes[key];
    }
    _getModuleList() {
      let appModules = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      const modules = new Array(this._defaultModules.length + appModules.length);
      const seen = {};
      let count = 0;
      for (let i2 = 0, len2 = this._defaultModules.length; i2 < len2; ++i2) {
        const module2 = this._defaultModules[i2];
        const name10 = module2.name;
        modules[count++] = module2;
        seen[name10] = true;
      }
      for (let i2 = 0, len2 = appModules.length; i2 < len2; ++i2) {
        const module2 = appModules[i2];
        const name10 = module2.name;
        if (!seen[name10]) {
          modules[count++] = module2;
          seen[name10] = true;
        }
      }
      modules.length = count;
      return modules;
    }
  };

  // ../../node_modules/@luma.gl/engine/dist/esm/lib/model-utils.js
  var GLTF_TO_LUMA_ATTRIBUTE_MAP = {
    POSITION: "positions",
    NORMAL: "normals",
    COLOR_0: "colors",
    TEXCOORD_0: "texCoords",
    TEXCOORD_1: "texCoords1",
    TEXCOORD_2: "texCoords2"
  };
  function getBuffersFromGeometry(gl, geometry, options) {
    const buffers = {};
    let indices = geometry.indices;
    for (const name10 in geometry.attributes) {
      const attribute = geometry.attributes[name10];
      const remappedName = mapAttributeName(name10, options);
      if (name10 === "indices") {
        indices = attribute;
      } else if (attribute.constant) {
        buffers[remappedName] = attribute.value;
      } else {
        const typedArray = attribute.value;
        const accessor = {
          ...attribute
        };
        delete accessor.value;
        buffers[remappedName] = [new Buffer2(gl, typedArray), accessor];
        inferAttributeAccessor(name10, accessor);
      }
    }
    if (indices) {
      const data = indices.value || indices;
      assert3(data instanceof Uint16Array || data instanceof Uint32Array, 'attribute array for "indices" must be of integer type');
      const accessor = {
        size: 1,
        isIndexed: indices.isIndexed === void 0 ? true : indices.isIndexed
      };
      buffers.indices = [new Buffer2(gl, {
        data,
        target: 34963
      }), accessor];
    }
    return buffers;
  }
  function mapAttributeName(name10, options) {
    const {
      attributeMap = GLTF_TO_LUMA_ATTRIBUTE_MAP
    } = options || {};
    return attributeMap && attributeMap[name10] || name10;
  }
  function inferAttributeAccessor(attributeName, attribute) {
    let category;
    switch (attributeName) {
      case "texCoords":
      case "texCoord1":
      case "texCoord2":
      case "texCoord3":
        category = "uvs";
        break;
      case "vertices":
      case "positions":
      case "normals":
      case "pickingColors":
        category = "vectors";
        break;
      default:
    }
    switch (category) {
      case "vectors":
        attribute.size = attribute.size || 3;
        break;
      case "uvs":
        attribute.size = attribute.size || 2;
        break;
      default:
    }
    assert3(Number.isFinite(attribute.size), "attribute ".concat(attributeName, " needs size"));
  }

  // ../../node_modules/@luma.gl/engine/dist/esm/lib/model.js
  var LOG_DRAW_PRIORITY = 2;
  var LOG_DRAW_TIMEOUT = 1e4;
  var ERR_MODEL_PARAMS = "Model needs drawMode and vertexCount";
  var NOOP = () => {
  };
  var DRAW_PARAMS = {};
  var Model2 = class {
    constructor(gl) {
      let props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      const {
        id = uid("model")
      } = props;
      assert3(isWebGL(gl));
      this.id = id;
      this.gl = gl;
      this.id = props.id || uid("Model");
      this.lastLogTime = 0;
      this.animated = false;
      this.initialize(props);
    }
    initialize(props) {
      this.props = {};
      this.programManager = props.programManager || ProgramManager.getDefaultProgramManager(this.gl);
      this._programManagerState = -1;
      this._managedProgram = false;
      const {
        program = null,
        vs: vs2,
        fs: fs2,
        modules,
        defines,
        inject,
        varyings,
        bufferMode,
        transpileToGLSL100
      } = props;
      this.programProps = {
        program,
        vs: vs2,
        fs: fs2,
        modules,
        defines,
        inject,
        varyings,
        bufferMode,
        transpileToGLSL100
      };
      this.program = null;
      this.vertexArray = null;
      this._programDirty = true;
      this.userData = {};
      this.needsRedraw = true;
      this._attributes = {};
      this.attributes = {};
      this.uniforms = {};
      this.pickable = true;
      this._checkProgram();
      this.setUniforms(Object.assign({}, this.getModuleUniforms(props.moduleSettings)));
      this.drawMode = props.drawMode !== void 0 ? props.drawMode : 4;
      this.vertexCount = props.vertexCount || 0;
      this.geometryBuffers = {};
      this.isInstanced = props.isInstanced || props.instanced || props.instanceCount > 0;
      this._setModelProps(props);
      this.geometry = {};
      assert3(this.drawMode !== void 0 && Number.isFinite(this.vertexCount), ERR_MODEL_PARAMS);
    }
    setProps(props) {
      this._setModelProps(props);
    }
    delete() {
      for (const key in this._attributes) {
        if (this._attributes[key] !== this.attributes[key]) {
          this._attributes[key].delete();
        }
      }
      if (this._managedProgram) {
        this.programManager.release(this.program);
        this._managedProgram = false;
      }
      this.vertexArray.delete();
      this._deleteGeometryBuffers();
    }
    getDrawMode() {
      return this.drawMode;
    }
    getVertexCount() {
      return this.vertexCount;
    }
    getInstanceCount() {
      return this.instanceCount;
    }
    getAttributes() {
      return this.attributes;
    }
    getProgram() {
      return this.program;
    }
    setProgram(props) {
      const {
        program,
        vs: vs2,
        fs: fs2,
        modules,
        defines,
        inject,
        varyings,
        bufferMode,
        transpileToGLSL100
      } = props;
      this.programProps = {
        program,
        vs: vs2,
        fs: fs2,
        modules,
        defines,
        inject,
        varyings,
        bufferMode,
        transpileToGLSL100
      };
      this._programDirty = true;
    }
    getUniforms() {
      return this.uniforms;
    }
    setDrawMode(drawMode) {
      this.drawMode = drawMode;
      return this;
    }
    setVertexCount(vertexCount) {
      assert3(Number.isFinite(vertexCount));
      this.vertexCount = vertexCount;
      return this;
    }
    setInstanceCount(instanceCount) {
      assert3(Number.isFinite(instanceCount));
      this.instanceCount = instanceCount;
      return this;
    }
    setGeometry(geometry) {
      this.drawMode = geometry.drawMode;
      this.vertexCount = geometry.getVertexCount();
      this._deleteGeometryBuffers();
      this.geometryBuffers = getBuffersFromGeometry(this.gl, geometry);
      this.vertexArray.setAttributes(this.geometryBuffers);
      return this;
    }
    setAttributes() {
      let attributes = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      if (isObjectEmpty2(attributes)) {
        return this;
      }
      const normalizedAttributes = {};
      for (const name10 in attributes) {
        const attribute = attributes[name10];
        normalizedAttributes[name10] = attribute.getValue ? attribute.getValue() : attribute;
      }
      this.vertexArray.setAttributes(normalizedAttributes);
      return this;
    }
    setUniforms() {
      let uniforms = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      Object.assign(this.uniforms, uniforms);
      return this;
    }
    getModuleUniforms(opts) {
      this._checkProgram();
      const getUniforms2 = this.programManager.getUniforms(this.program);
      if (getUniforms2) {
        return getUniforms2(opts);
      }
      return {};
    }
    updateModuleSettings(opts) {
      const uniforms = this.getModuleUniforms(opts || {});
      return this.setUniforms(uniforms);
    }
    clear(opts) {
      clear(this.program.gl, opts);
      return this;
    }
    draw() {
      let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      this._checkProgram();
      const {
        moduleSettings = null,
        framebuffer,
        uniforms = {},
        attributes = {},
        transformFeedback = this.transformFeedback,
        parameters = {},
        vertexArray = this.vertexArray
      } = opts;
      this.setAttributes(attributes);
      this.updateModuleSettings(moduleSettings);
      this.setUniforms(uniforms);
      let logPriority;
      if (log.priority >= LOG_DRAW_PRIORITY) {
        logPriority = this._logDrawCallStart(LOG_DRAW_PRIORITY);
      }
      const drawParams = this.vertexArray.getDrawParams();
      const {
        isIndexed = drawParams.isIndexed,
        indexType = drawParams.indexType,
        indexOffset = drawParams.indexOffset,
        vertexArrayInstanced = drawParams.isInstanced
      } = this.props;
      if (vertexArrayInstanced && !this.isInstanced) {
        log.warn("Found instanced attributes on non-instanced model", this.id)();
      }
      const {
        isInstanced,
        instanceCount
      } = this;
      const {
        onBeforeRender = NOOP,
        onAfterRender = NOOP
      } = this.props;
      onBeforeRender();
      this.program.setUniforms(this.uniforms);
      const didDraw = this.program.draw(Object.assign(DRAW_PARAMS, opts, {
        logPriority,
        uniforms: null,
        framebuffer,
        parameters,
        drawMode: this.getDrawMode(),
        vertexCount: this.getVertexCount(),
        vertexArray,
        transformFeedback,
        isIndexed,
        indexType,
        isInstanced,
        instanceCount,
        offset: isIndexed ? indexOffset : 0
      }));
      onAfterRender();
      if (log.priority >= LOG_DRAW_PRIORITY) {
        this._logDrawCallEnd(logPriority, vertexArray, framebuffer);
      }
      return didDraw;
    }
    transform() {
      let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const {
        discard = true,
        feedbackBuffers,
        unbindModels = []
      } = opts;
      let {
        parameters
      } = opts;
      if (feedbackBuffers) {
        this._setFeedbackBuffers(feedbackBuffers);
      }
      if (discard) {
        parameters = Object.assign({}, parameters, {
          [35977]: discard
        });
      }
      unbindModels.forEach((model) => model.vertexArray.unbindBuffers());
      try {
        this.draw(Object.assign({}, opts, {
          parameters
        }));
      } finally {
        unbindModels.forEach((model) => model.vertexArray.bindBuffers());
      }
      return this;
    }
    render() {
      let uniforms = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      log.warn("Model.render() is deprecated. Use Model.setUniforms() and Model.draw()")();
      return this.setUniforms(uniforms).draw();
    }
    _setModelProps(props) {
      Object.assign(this.props, props);
      if ("uniforms" in props) {
        this.setUniforms(props.uniforms);
      }
      if ("pickable" in props) {
        this.pickable = props.pickable;
      }
      if ("instanceCount" in props) {
        this.instanceCount = props.instanceCount;
      }
      if ("geometry" in props) {
        this.setGeometry(props.geometry);
      }
      if ("attributes" in props) {
        this.setAttributes(props.attributes);
      }
      if ("_feedbackBuffers" in props) {
        this._setFeedbackBuffers(props._feedbackBuffers);
      }
    }
    _checkProgram() {
      const needsUpdate = this._programDirty || this.programManager.stateHash !== this._programManagerState;
      if (!needsUpdate) {
        return;
      }
      let {
        program
      } = this.programProps;
      if (program) {
        this._managedProgram = false;
      } else {
        const {
          vs: vs2,
          fs: fs2,
          modules,
          inject,
          defines,
          varyings,
          bufferMode,
          transpileToGLSL100
        } = this.programProps;
        program = this.programManager.get({
          vs: vs2,
          fs: fs2,
          modules,
          inject,
          defines,
          varyings,
          bufferMode,
          transpileToGLSL100
        });
        if (this.program && this._managedProgram) {
          this.programManager.release(this.program);
        }
        this._programManagerState = this.programManager.stateHash;
        this._managedProgram = true;
      }
      assert3(program instanceof Program, "Model needs a program");
      this._programDirty = false;
      if (program === this.program) {
        return;
      }
      this.program = program;
      if (this.vertexArray) {
        this.vertexArray.setProps({
          program: this.program,
          attributes: this.vertexArray.attributes
        });
      } else {
        this.vertexArray = new VertexArray(this.gl, {
          program: this.program
        });
      }
      this.setUniforms(Object.assign({}, this.getModuleUniforms()));
    }
    _deleteGeometryBuffers() {
      for (const name10 in this.geometryBuffers) {
        const buffer = this.geometryBuffers[name10][0] || this.geometryBuffers[name10];
        if (buffer instanceof Buffer2) {
          buffer.delete();
        }
      }
    }
    _setAnimationProps(animationProps) {
      if (this.animated) {
        assert3(animationProps, "Model.draw(): animated uniforms but no animationProps");
      }
    }
    _setFeedbackBuffers() {
      let feedbackBuffers = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      if (isObjectEmpty2(feedbackBuffers)) {
        return this;
      }
      const {
        gl
      } = this.program;
      this.transformFeedback = this.transformFeedback || new TransformFeedback(gl, {
        program: this.program
      });
      this.transformFeedback.setBuffers(feedbackBuffers);
      return this;
    }
    _logDrawCallStart(logLevel) {
      const logDrawTimeout = logLevel > 3 ? 0 : LOG_DRAW_TIMEOUT;
      if (Date.now() - this.lastLogTime < logDrawTimeout) {
        return void 0;
      }
      this.lastLogTime = Date.now();
      log.group(LOG_DRAW_PRIORITY, ">>> DRAWING MODEL ".concat(this.id), {
        collapsed: log.level <= 2
      })();
      return logLevel;
    }
    _logDrawCallEnd(logLevel, vertexArray, uniforms, framebuffer) {
      if (logLevel === void 0) {
        return;
      }
      const attributeTable = getDebugTableForVertexArray({
        vertexArray,
        header: "".concat(this.id, " attributes"),
        attributes: this._attributes
      });
      const {
        table: uniformTable,
        unusedTable,
        unusedCount
      } = getDebugTableForUniforms({
        header: "".concat(this.id, " uniforms"),
        program: this.program,
        uniforms: Object.assign({}, this.program.uniforms, uniforms)
      });
      const {
        table: missingTable,
        count: missingCount
      } = getDebugTableForUniforms({
        header: "".concat(this.id, " uniforms"),
        program: this.program,
        uniforms: Object.assign({}, this.program.uniforms, uniforms),
        undefinedOnly: true
      });
      if (missingCount > 0) {
        log.log("MISSING UNIFORMS", Object.keys(missingTable))();
      }
      if (unusedCount > 0) {
        log.log("UNUSED UNIFORMS", Object.keys(unusedTable))();
      }
      const configTable = getDebugTableForProgramConfiguration(this.vertexArray.configuration);
      log.table(logLevel, attributeTable)();
      log.table(logLevel, uniformTable)();
      log.table(logLevel + 1, configTable)();
      if (framebuffer) {
        framebuffer.log({
          logLevel: LOG_DRAW_PRIORITY,
          message: "Rendered to ".concat(framebuffer.id)
        });
      }
      log.groupEnd(LOG_DRAW_PRIORITY)();
    }
  };

  // ../../node_modules/@luma.gl/experimental/dist/esm/scenegraph/model-node.js
  var ModelNode = class extends ScenegraphNode {
    constructor(gl) {
      let props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      super(props);
      this.onBeforeRender = null;
      this.AfterRender = null;
      if (gl instanceof Model2) {
        this.model = gl;
        this._setModelNodeProps(props);
      } else {
        this.model = new Model2(gl, props);
      }
      this.managedResources = props.managedResources || [];
    }
    setProps(props) {
      super.setProps(props);
      this._setModelNodeProps(props);
      return this;
    }
    delete() {
      if (this.model) {
        this.model.delete();
        this.model = null;
      }
      this.managedResources.forEach((resource) => resource.delete());
      this.managedResources = [];
    }
    draw() {
      return this.model.draw(...arguments);
    }
    setUniforms() {
      this.model.setUniforms(...arguments);
      return this;
    }
    setAttributes() {
      this.model.setAttributes(...arguments);
      return this;
    }
    updateModuleSettings() {
      this.model.updateModuleSettings(...arguments);
      return this;
    }
    _setModelNodeProps(props) {
      this.model.setProps(props);
    }
  };

  // ../../node_modules/@luma.gl/experimental/dist/esm/gltf/gltf-material-parser.js
  var GLTFMaterialParser = class {
    constructor(gl, _ref) {
      let {
        attributes,
        material,
        pbrDebug,
        imageBasedLightingEnvironment,
        lights: lights2,
        useTangents
      } = _ref;
      this.gl = gl;
      this.defines = {
        MANUAL_SRGB: 1,
        SRGB_FAST_APPROXIMATION: 1
      };
      if (hasFeature(gl, FEATURES.GLSL_TEXTURE_LOD)) {
        this.defines.USE_TEX_LOD = 1;
      }
      this.uniforms = {
        u_Camera: [0, 0, 0],
        u_MetallicRoughnessValues: [1, 1]
      };
      this.parameters = {};
      this.generatedTextures = [];
      if (imageBasedLightingEnvironment) {
        this.uniforms.u_DiffuseEnvSampler = imageBasedLightingEnvironment.getDiffuseEnvSampler();
        this.uniforms.u_SpecularEnvSampler = imageBasedLightingEnvironment.getSpecularEnvSampler();
        this.uniforms.u_brdfLUT = imageBasedLightingEnvironment.getBrdfTexture();
        this.uniforms.u_ScaleIBLAmbient = [1, 1];
      }
      if (pbrDebug) {
        this.uniforms.u_ScaleDiffBaseMR = [0, 0, 0, 0];
        this.uniforms.u_ScaleFGDSpec = [0, 0, 0, 0];
      }
      this.defineIfPresent(attributes.NORMAL, "HAS_NORMALS");
      this.defineIfPresent(attributes.TANGENT && useTangents, "HAS_TANGENTS");
      this.defineIfPresent(attributes.TEXCOORD_0, "HAS_UV");
      this.defineIfPresent(imageBasedLightingEnvironment, "USE_IBL");
      this.defineIfPresent(lights2, "USE_LIGHTS");
      this.defineIfPresent(pbrDebug, "PBR_DEBUG");
      if (material) {
        this.parseMaterial(material);
      }
    }
    defineIfPresent(value, name10) {
      if (value) {
        this.defines[name10] = 1;
      }
    }
    parseTexture(gltfTexture, name10) {
      let define = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
      const parameters = gltfTexture.texture && gltfTexture.texture.sampler && gltfTexture.texture.sampler.parameters || {};
      const image = gltfTexture.texture.source.image;
      let textureOptions;
      let specialTextureParameters = {};
      if (image.compressed) {
        textureOptions = image;
        specialTextureParameters = {
          [this.gl.TEXTURE_MIN_FILTER]: image.data.length > 1 ? this.gl.LINEAR_MIPMAP_NEAREST : this.gl.LINEAR
        };
      } else {
        textureOptions = {
          data: image
        };
      }
      const texture = new Texture2D(this.gl, {
        id: gltfTexture.name || gltfTexture.id,
        parameters: {
          ...parameters,
          ...specialTextureParameters
        },
        pixelStore: {
          [this.gl.UNPACK_FLIP_Y_WEBGL]: false
        },
        ...textureOptions
      });
      this.uniforms[name10] = texture;
      this.defineIfPresent(define, define);
      this.generatedTextures.push(texture);
    }
    parsePbrMetallicRoughness(pbrMetallicRoughness) {
      if (pbrMetallicRoughness.baseColorTexture) {
        this.parseTexture(pbrMetallicRoughness.baseColorTexture, "u_BaseColorSampler", "HAS_BASECOLORMAP");
      }
      this.uniforms.u_BaseColorFactor = pbrMetallicRoughness.baseColorFactor || [1, 1, 1, 1];
      if (pbrMetallicRoughness.metallicRoughnessTexture) {
        this.parseTexture(pbrMetallicRoughness.metallicRoughnessTexture, "u_MetallicRoughnessSampler", "HAS_METALROUGHNESSMAP");
      }
      const {
        metallicFactor = 1,
        roughnessFactor = 1
      } = pbrMetallicRoughness;
      this.uniforms.u_MetallicRoughnessValues = [metallicFactor, roughnessFactor];
    }
    parseMaterial(material) {
      this.uniforms.pbr_uUnlit = Boolean(material.unlit);
      if (material.pbrMetallicRoughness) {
        this.parsePbrMetallicRoughness(material.pbrMetallicRoughness);
      }
      if (material.normalTexture) {
        this.parseTexture(material.normalTexture, "u_NormalSampler", "HAS_NORMALMAP");
        const {
          scale: scale5 = 1
        } = material.normalTexture;
        this.uniforms.u_NormalScale = scale5;
      }
      if (material.occlusionTexture) {
        this.parseTexture(material.occlusionTexture, "u_OcclusionSampler", "HAS_OCCLUSIONMAP");
        const {
          strength = 1
        } = material.occlusionTexture;
        this.uniforms.u_OcclusionStrength = strength;
      }
      if (material.emissiveTexture) {
        this.parseTexture(material.emissiveTexture, "u_EmissiveSampler", "HAS_EMISSIVEMAP");
        this.uniforms.u_EmissiveFactor = material.emissiveFactor || [0, 0, 0];
      }
      if (material.alphaMode === "MASK") {
        const {
          alphaCutoff = 0.5
        } = material;
        this.defines.ALPHA_CUTOFF = 1;
        this.uniforms.u_AlphaCutoff = alphaCutoff;
      } else if (material.alphaMode === "BLEND") {
        log.warn("BLEND alphaMode might not work well because it requires mesh sorting")();
        Object.assign(this.parameters, {
          blend: true,
          blendEquation: this.gl.FUNC_ADD,
          blendFunc: [this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA, this.gl.ONE, this.gl.ONE_MINUS_SRC_ALPHA]
        });
      }
    }
    delete() {
      this.generatedTextures.forEach((texture) => texture.delete());
    }
  };

  // ../../node_modules/@luma.gl/experimental/dist/esm/gltf/create-gltf-model.js
  var vs = "\n#if (__VERSION__ < 300)\n  #define _attr attribute\n#else\n  #define _attr in\n#endif\n\n  _attr vec4 POSITION;\n\n  #ifdef HAS_NORMALS\n    _attr vec4 NORMAL;\n  #endif\n\n  #ifdef HAS_TANGENTS\n    _attr vec4 TANGENT;\n  #endif\n\n  #ifdef HAS_UV\n    _attr vec2 TEXCOORD_0;\n  #endif\n\n  void main(void) {\n    vec4 _NORMAL = vec4(0.);\n    vec4 _TANGENT = vec4(0.);\n    vec2 _TEXCOORD_0 = vec2(0.);\n\n    #ifdef HAS_NORMALS\n      _NORMAL = NORMAL;\n    #endif\n\n    #ifdef HAS_TANGENTS\n      _TANGENT = TANGENT;\n    #endif\n\n    #ifdef HAS_UV\n      _TEXCOORD_0 = TEXCOORD_0;\n    #endif\n\n    pbr_setPositionNormalTangentUV(POSITION, _NORMAL, _TANGENT, _TEXCOORD_0);\n    gl_Position = u_MVPMatrix * POSITION;\n  }\n";
  var fs = "\n#if (__VERSION__ < 300)\n  #define fragmentColor gl_FragColor\n#else\n  out vec4 fragmentColor;\n#endif\n\n  void main(void) {\n    fragmentColor = pbr_filterColor(vec4(0));\n  }\n";
  function addVersionToShader(gl, source) {
    if (isWebGL2(gl)) {
      return "#version 300 es\n".concat(source);
    }
    return source;
  }
  function createGLTFModel(gl, options) {
    const {
      id,
      drawMode,
      vertexCount,
      attributes,
      modelOptions
    } = options;
    const materialParser = new GLTFMaterialParser(gl, options);
    log.info(4, "createGLTFModel defines: ", materialParser.defines)();
    const managedResources = [];
    managedResources.push(...materialParser.generatedTextures);
    managedResources.push(...Object.values(attributes).map((attribute) => attribute.buffer));
    const model = new ModelNode(gl, Object.assign({
      id,
      drawMode,
      vertexCount,
      modules: [pbr],
      defines: materialParser.defines,
      parameters: materialParser.parameters,
      vs: addVersionToShader(gl, vs),
      fs: addVersionToShader(gl, fs),
      managedResources
    }, modelOptions));
    model.setProps({
      attributes
    });
    model.setUniforms(materialParser.uniforms);
    return model;
  }

  // ../../node_modules/@luma.gl/experimental/dist/esm/gltf/gltf-instantiator.js
  var ATTRIBUTE_TYPE_TO_COMPONENTS2 = {
    SCALAR: 1,
    VEC2: 2,
    VEC3: 3,
    VEC4: 4,
    MAT2: 4,
    MAT3: 9,
    MAT4: 16
  };
  var DEFAULT_OPTIONS = {
    modelOptions: {},
    pbrDebug: false,
    imageBasedLightingEnvironment: null,
    lights: true,
    useTangents: false
  };
  var GLTFInstantiator = class {
    constructor(gl) {
      let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      this.gl = gl;
      this.options = Object.assign({}, DEFAULT_OPTIONS, options);
    }
    instantiate(gltf) {
      this.gltf = gltf;
      const scenes = (gltf.scenes || []).map((scene) => this.createScene(scene));
      return scenes;
    }
    createAnimator() {
      if (Array.isArray(this.gltf.animations)) {
        return new GLTFAnimator(this.gltf);
      }
      return null;
    }
    createScene(gltfScene) {
      const gltfNodes = gltfScene.nodes || [];
      const nodes = gltfNodes.map((node2) => this.createNode(node2));
      const scene = new GroupNode({
        id: gltfScene.name || gltfScene.id,
        children: nodes
      });
      return scene;
    }
    createNode(gltfNode) {
      if (!gltfNode._node) {
        const gltfChildren = gltfNode.children || [];
        const children = gltfChildren.map((child) => this.createNode(child));
        if (gltfNode.mesh) {
          children.push(this.createMesh(gltfNode.mesh));
        }
        const node2 = new GroupNode({
          id: gltfNode.name || gltfNode.id,
          children
        });
        if (gltfNode.matrix) {
          node2.setMatrix(gltfNode.matrix);
        } else {
          node2.matrix.identity();
          if (gltfNode.translation) {
            node2.matrix.translate(gltfNode.translation);
          }
          if (gltfNode.rotation) {
            const rotationMatrix = new Matrix4().fromQuaternion(gltfNode.rotation);
            node2.matrix.multiplyRight(rotationMatrix);
          }
          if (gltfNode.scale) {
            node2.matrix.scale(gltfNode.scale);
          }
        }
        gltfNode._node = node2;
      }
      return gltfNode._node;
    }
    createMesh(gltfMesh) {
      if (!gltfMesh._mesh) {
        const gltfPrimitives = gltfMesh.primitives || [];
        const primitives = gltfPrimitives.map((gltfPrimitive, i2) => this.createPrimitive(gltfPrimitive, i2, gltfMesh));
        const mesh = new GroupNode({
          id: gltfMesh.name || gltfMesh.id,
          children: primitives
        });
        gltfMesh._mesh = mesh;
      }
      return gltfMesh._mesh;
    }
    getVertexCount(attributes) {
      log.warn("getVertexCount() not found")();
    }
    createPrimitive(gltfPrimitive, i2, gltfMesh) {
      return createGLTFModel(this.gl, Object.assign({
        id: gltfPrimitive.name || "".concat(gltfMesh.name || gltfMesh.id, "-primitive-").concat(i2),
        drawMode: gltfPrimitive.mode || 4,
        vertexCount: gltfPrimitive.indices ? gltfPrimitive.indices.count : this.getVertexCount(gltfPrimitive.attributes),
        attributes: this.createAttributes(gltfPrimitive.attributes, gltfPrimitive.indices),
        material: gltfPrimitive.material
      }, this.options));
    }
    createAttributes(attributes, indices) {
      const loadedAttributes = {};
      Object.keys(attributes).forEach((attrName) => {
        loadedAttributes[attrName] = this.createAccessor(attributes[attrName], this.createBuffer(attributes[attrName], this.gl.ARRAY_BUFFER));
      });
      if (indices) {
        loadedAttributes.indices = this.createAccessor(indices, this.createBuffer(indices, this.gl.ELEMENT_ARRAY_BUFFER));
      }
      log.info(4, "glTF Attributes", {
        attributes,
        indices,
        generated: loadedAttributes
      })();
      return loadedAttributes;
    }
    createBuffer(attribute, target) {
      if (!attribute.bufferView) {
        attribute.bufferView = {};
      }
      const {
        bufferView
      } = attribute;
      if (!bufferView.lumaBuffers) {
        bufferView.lumaBuffers = {};
      }
      if (!bufferView.lumaBuffers[target]) {
        bufferView.lumaBuffers[target] = new Buffer2(this.gl, {
          id: "from-".concat(bufferView.id),
          data: bufferView.data || attribute.value,
          target
        });
      }
      return bufferView.lumaBuffers[target];
    }
    createAccessor(accessor, buffer) {
      return new Accessor({
        buffer,
        offset: accessor.byteOffset || 0,
        stride: accessor.bufferView.byteStride || 0,
        type: accessor.componentType,
        size: ATTRIBUTE_TYPE_TO_COMPONENTS2[accessor.type]
      });
    }
    createSampler(gltfSampler) {
      return gltfSampler;
    }
    needsPOT() {
      return false;
    }
  };

  // ../../node_modules/@luma.gl/experimental/dist/esm/gltf/create-gltf-objects.js
  function createGLTFObjects(gl, gltf, options) {
    const instantiator = new GLTFInstantiator(gl, options);
    const scenes = instantiator.instantiate(gltf);
    const animator = instantiator.createAnimator();
    return {
      scenes,
      animator
    };
  }

  // ../../node_modules/@loaders.gl/gltf/dist/esm/lib/utils/version.js
  var VERSION5 = true ? "3.3.3" : "latest";

  // ../../node_modules/@loaders.gl/textures/dist/esm/lib/utils/version.js
  var VERSION6 = true ? "3.3.3" : "beta";

  // ../../node_modules/@loaders.gl/textures/dist/esm/lib/parsers/basis-module-loader.js
  var VERSION7 = true ? "3.3.3" : "beta";
  var BASIS_CDN_ENCODER_WASM = "https://unpkg.com/@loaders.gl/textures@".concat(VERSION7, "/dist/libs/basis_encoder.wasm");
  var BASIS_CDN_ENCODER_JS = "https://unpkg.com/@loaders.gl/textures@".concat(VERSION7, "/dist/libs/basis_encoder.js");
  var loadBasisTranscoderPromise;
  async function loadBasisTrascoderModule(options) {
    const modules = options.modules || {};
    if (modules.basis) {
      return modules.basis;
    }
    loadBasisTranscoderPromise = loadBasisTranscoderPromise || loadBasisTrascoder(options);
    return await loadBasisTranscoderPromise;
  }
  async function loadBasisTrascoder(options) {
    let BASIS = null;
    let wasmBinary = null;
    [BASIS, wasmBinary] = await Promise.all([await loadLibrary("basis_transcoder.js", "textures", options), await loadLibrary("basis_transcoder.wasm", "textures", options)]);
    BASIS = BASIS || globalThis.BASIS;
    return await initializeBasisTrascoderModule(BASIS, wasmBinary);
  }
  function initializeBasisTrascoderModule(BasisModule, wasmBinary) {
    const options = {};
    if (wasmBinary) {
      options.wasmBinary = wasmBinary;
    }
    return new Promise((resolve) => {
      BasisModule(options).then((module2) => {
        const {
          BasisFile,
          initializeBasis
        } = module2;
        initializeBasis();
        resolve({
          BasisFile
        });
      });
    });
  }
  var loadBasisEncoderPromise;
  async function loadBasisEncoderModule(options) {
    const modules = options.modules || {};
    if (modules.basisEncoder) {
      return modules.basisEncoder;
    }
    loadBasisEncoderPromise = loadBasisEncoderPromise || loadBasisEncoder(options);
    return await loadBasisEncoderPromise;
  }
  async function loadBasisEncoder(options) {
    let BASIS_ENCODER = null;
    let wasmBinary = null;
    [BASIS_ENCODER, wasmBinary] = await Promise.all([await loadLibrary(BASIS_CDN_ENCODER_JS, "textures", options), await loadLibrary(BASIS_CDN_ENCODER_WASM, "textures", options)]);
    BASIS_ENCODER = BASIS_ENCODER || globalThis.BASIS;
    return await initializeBasisEncoderModule(BASIS_ENCODER, wasmBinary);
  }
  function initializeBasisEncoderModule(BasisEncoderModule, wasmBinary) {
    const options = {};
    if (wasmBinary) {
      options.wasmBinary = wasmBinary;
    }
    return new Promise((resolve) => {
      BasisEncoderModule(options).then((module2) => {
        const {
          BasisFile,
          KTX2File,
          initializeBasis,
          BasisEncoder
        } = module2;
        initializeBasis();
        resolve({
          BasisFile,
          KTX2File,
          BasisEncoder
        });
      });
    });
  }

  // ../../node_modules/@loaders.gl/textures/dist/esm/lib/gl-extensions.js
  var GL_EXTENSIONS_CONSTANTS = {
    COMPRESSED_RGB_S3TC_DXT1_EXT: 33776,
    COMPRESSED_RGBA_S3TC_DXT1_EXT: 33777,
    COMPRESSED_RGBA_S3TC_DXT3_EXT: 33778,
    COMPRESSED_RGBA_S3TC_DXT5_EXT: 33779,
    COMPRESSED_R11_EAC: 37488,
    COMPRESSED_SIGNED_R11_EAC: 37489,
    COMPRESSED_RG11_EAC: 37490,
    COMPRESSED_SIGNED_RG11_EAC: 37491,
    COMPRESSED_RGB8_ETC2: 37492,
    COMPRESSED_RGBA8_ETC2_EAC: 37493,
    COMPRESSED_SRGB8_ETC2: 37494,
    COMPRESSED_SRGB8_ALPHA8_ETC2_EAC: 37495,
    COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2: 37496,
    COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2: 37497,
    COMPRESSED_RGB_PVRTC_4BPPV1_IMG: 35840,
    COMPRESSED_RGBA_PVRTC_4BPPV1_IMG: 35842,
    COMPRESSED_RGB_PVRTC_2BPPV1_IMG: 35841,
    COMPRESSED_RGBA_PVRTC_2BPPV1_IMG: 35843,
    COMPRESSED_RGB_ETC1_WEBGL: 36196,
    COMPRESSED_RGB_ATC_WEBGL: 35986,
    COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL: 35987,
    COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL: 34798,
    COMPRESSED_RGBA_ASTC_4X4_KHR: 37808,
    COMPRESSED_RGBA_ASTC_5X4_KHR: 37809,
    COMPRESSED_RGBA_ASTC_5X5_KHR: 37810,
    COMPRESSED_RGBA_ASTC_6X5_KHR: 37811,
    COMPRESSED_RGBA_ASTC_6X6_KHR: 37812,
    COMPRESSED_RGBA_ASTC_8X5_KHR: 37813,
    COMPRESSED_RGBA_ASTC_8X6_KHR: 37814,
    COMPRESSED_RGBA_ASTC_8X8_KHR: 37815,
    COMPRESSED_RGBA_ASTC_10X5_KHR: 37816,
    COMPRESSED_RGBA_ASTC_10X6_KHR: 37817,
    COMPRESSED_RGBA_ASTC_10X8_KHR: 37818,
    COMPRESSED_RGBA_ASTC_10X10_KHR: 37819,
    COMPRESSED_RGBA_ASTC_12X10_KHR: 37820,
    COMPRESSED_RGBA_ASTC_12X12_KHR: 37821,
    COMPRESSED_SRGB8_ALPHA8_ASTC_4X4_KHR: 37840,
    COMPRESSED_SRGB8_ALPHA8_ASTC_5X4_KHR: 37841,
    COMPRESSED_SRGB8_ALPHA8_ASTC_5X5_KHR: 37842,
    COMPRESSED_SRGB8_ALPHA8_ASTC_6X5_KHR: 37843,
    COMPRESSED_SRGB8_ALPHA8_ASTC_6X6_KHR: 37844,
    COMPRESSED_SRGB8_ALPHA8_ASTC_8X5_KHR: 37845,
    COMPRESSED_SRGB8_ALPHA8_ASTC_8X6_KHR: 37846,
    COMPRESSED_SRGB8_ALPHA8_ASTC_8X8_KHR: 37847,
    COMPRESSED_SRGB8_ALPHA8_ASTC_10X5_KHR: 37848,
    COMPRESSED_SRGB8_ALPHA8_ASTC_10X6_KHR: 37849,
    COMPRESSED_SRGB8_ALPHA8_ASTC_10X8_KHR: 37850,
    COMPRESSED_SRGB8_ALPHA8_ASTC_10X10_KHR: 37851,
    COMPRESSED_SRGB8_ALPHA8_ASTC_12X10_KHR: 37852,
    COMPRESSED_SRGB8_ALPHA8_ASTC_12X12_KHR: 37853,
    COMPRESSED_RED_RGTC1_EXT: 36283,
    COMPRESSED_SIGNED_RED_RGTC1_EXT: 36284,
    COMPRESSED_RED_GREEN_RGTC2_EXT: 36285,
    COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT: 36286,
    COMPRESSED_SRGB_S3TC_DXT1_EXT: 35916,
    COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT: 35917,
    COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT: 35918,
    COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT: 35919
  };

  // ../../node_modules/@loaders.gl/textures/dist/esm/lib/utils/texture-formats.js
  var BROWSER_PREFIXES = ["", "WEBKIT_", "MOZ_"];
  var WEBGL_EXTENSIONS = {
    WEBGL_compressed_texture_s3tc: "dxt",
    WEBGL_compressed_texture_s3tc_srgb: "dxt-srgb",
    WEBGL_compressed_texture_etc1: "etc1",
    WEBGL_compressed_texture_etc: "etc2",
    WEBGL_compressed_texture_pvrtc: "pvrtc",
    WEBGL_compressed_texture_atc: "atc",
    WEBGL_compressed_texture_astc: "astc",
    EXT_texture_compression_rgtc: "rgtc"
  };
  var formats = null;
  function getSupportedGPUTextureFormats(gl) {
    if (!formats) {
      gl = gl || getWebGLContext() || void 0;
      formats = /* @__PURE__ */ new Set();
      for (const prefix of BROWSER_PREFIXES) {
        for (const extension in WEBGL_EXTENSIONS) {
          if (gl && gl.getExtension("".concat(prefix).concat(extension))) {
            const gpuTextureFormat = WEBGL_EXTENSIONS[extension];
            formats.add(gpuTextureFormat);
          }
        }
      }
    }
    return formats;
  }
  function getWebGLContext() {
    try {
      const canvas = document.createElement("canvas");
      return canvas.getContext("webgl");
    } catch (error2) {
      return null;
    }
  }

  // ../../node_modules/ktx-parse/dist/ktx-parse.modern.js
  var t = new Uint8Array([0]);
  var n;
  var i;
  var s;
  var a;
  var r;
  var o;
  var l;
  var f;
  !function(t2) {
    t2[t2.NONE = 0] = "NONE", t2[t2.BASISLZ = 1] = "BASISLZ", t2[t2.ZSTD = 2] = "ZSTD", t2[t2.ZLIB = 3] = "ZLIB";
  }(n || (n = {})), function(t2) {
    t2[t2.BASICFORMAT = 0] = "BASICFORMAT";
  }(i || (i = {})), function(t2) {
    t2[t2.UNSPECIFIED = 0] = "UNSPECIFIED", t2[t2.ETC1S = 163] = "ETC1S", t2[t2.UASTC = 166] = "UASTC";
  }(s || (s = {})), function(t2) {
    t2[t2.UNSPECIFIED = 0] = "UNSPECIFIED", t2[t2.SRGB = 1] = "SRGB";
  }(a || (a = {})), function(t2) {
    t2[t2.UNSPECIFIED = 0] = "UNSPECIFIED", t2[t2.LINEAR = 1] = "LINEAR", t2[t2.SRGB = 2] = "SRGB", t2[t2.ITU = 3] = "ITU", t2[t2.NTSC = 4] = "NTSC", t2[t2.SLOG = 5] = "SLOG", t2[t2.SLOG2 = 6] = "SLOG2";
  }(r || (r = {})), function(t2) {
    t2[t2.ALPHA_STRAIGHT = 0] = "ALPHA_STRAIGHT", t2[t2.ALPHA_PREMULTIPLIED = 1] = "ALPHA_PREMULTIPLIED";
  }(o || (o = {})), function(t2) {
    t2[t2.RGB = 0] = "RGB", t2[t2.RRR = 3] = "RRR", t2[t2.GGG = 4] = "GGG", t2[t2.AAA = 15] = "AAA";
  }(l || (l = {})), function(t2) {
    t2[t2.RGB = 0] = "RGB", t2[t2.RGBA = 3] = "RGBA", t2[t2.RRR = 4] = "RRR", t2[t2.RRRG = 5] = "RRRG";
  }(f || (f = {}));

  // ../../node_modules/@loaders.gl/textures/dist/esm/lib/parsers/parse-ktx.js
  var KTX2_ID = [
    171,
    75,
    84,
    88,
    32,
    50,
    48,
    187,
    13,
    10,
    26,
    10
  ];
  function isKTX(data) {
    const id = new Uint8Array(data);
    const notKTX = id.byteLength < KTX2_ID.length || id[0] !== KTX2_ID[0] || id[1] !== KTX2_ID[1] || id[2] !== KTX2_ID[2] || id[3] !== KTX2_ID[3] || id[4] !== KTX2_ID[4] || id[5] !== KTX2_ID[5] || id[6] !== KTX2_ID[6] || id[7] !== KTX2_ID[7] || id[8] !== KTX2_ID[8] || id[9] !== KTX2_ID[9] || id[10] !== KTX2_ID[10] || id[11] !== KTX2_ID[11];
    return !notKTX;
  }

  // ../../node_modules/@loaders.gl/textures/dist/esm/lib/parsers/parse-basis.js
  var OutputFormat = {
    etc1: {
      basisFormat: 0,
      compressed: true,
      format: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_ETC1_WEBGL
    },
    etc2: {
      basisFormat: 1,
      compressed: true
    },
    bc1: {
      basisFormat: 2,
      compressed: true,
      format: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_S3TC_DXT1_EXT
    },
    bc3: {
      basisFormat: 3,
      compressed: true,
      format: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_S3TC_DXT5_EXT
    },
    bc4: {
      basisFormat: 4,
      compressed: true
    },
    bc5: {
      basisFormat: 5,
      compressed: true
    },
    "bc7-m6-opaque-only": {
      basisFormat: 6,
      compressed: true
    },
    "bc7-m5": {
      basisFormat: 7,
      compressed: true
    },
    "pvrtc1-4-rgb": {
      basisFormat: 8,
      compressed: true,
      format: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_PVRTC_4BPPV1_IMG
    },
    "pvrtc1-4-rgba": {
      basisFormat: 9,
      compressed: true,
      format: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG
    },
    "astc-4x4": {
      basisFormat: 10,
      compressed: true,
      format: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_4X4_KHR
    },
    "atc-rgb": {
      basisFormat: 11,
      compressed: true
    },
    "atc-rgba-interpolated-alpha": {
      basisFormat: 12,
      compressed: true
    },
    rgba32: {
      basisFormat: 13,
      compressed: false
    },
    rgb565: {
      basisFormat: 14,
      compressed: false
    },
    bgr565: {
      basisFormat: 15,
      compressed: false
    },
    rgba4444: {
      basisFormat: 16,
      compressed: false
    }
  };
  async function parseBasis(data, options) {
    if (options.basis.containerFormat === "auto") {
      if (isKTX(data)) {
        const fileConstructors = await loadBasisEncoderModule(options);
        return parseKTX2File(fileConstructors.KTX2File, data, options);
      }
      const {
        BasisFile
      } = await loadBasisTrascoderModule(options);
      return parseBasisFile(BasisFile, data, options);
    }
    switch (options.basis.module) {
      case "encoder":
        const fileConstructors = await loadBasisEncoderModule(options);
        switch (options.basis.containerFormat) {
          case "ktx2":
            return parseKTX2File(fileConstructors.KTX2File, data, options);
          case "basis":
          default:
            return parseBasisFile(fileConstructors.BasisFile, data, options);
        }
      case "transcoder":
      default:
        const {
          BasisFile
        } = await loadBasisTrascoderModule(options);
        return parseBasisFile(BasisFile, data, options);
    }
  }
  function parseBasisFile(BasisFile, data, options) {
    const basisFile = new BasisFile(new Uint8Array(data));
    try {
      if (!basisFile.startTranscoding()) {
        throw new Error("Failed to start basis transcoding");
      }
      const imageCount = basisFile.getNumImages();
      const images = [];
      for (let imageIndex = 0; imageIndex < imageCount; imageIndex++) {
        const levelsCount = basisFile.getNumLevels(imageIndex);
        const levels = [];
        for (let levelIndex = 0; levelIndex < levelsCount; levelIndex++) {
          levels.push(transcodeImage(basisFile, imageIndex, levelIndex, options));
        }
        images.push(levels);
      }
      return images;
    } finally {
      basisFile.close();
      basisFile.delete();
    }
  }
  function transcodeImage(basisFile, imageIndex, levelIndex, options) {
    const width = basisFile.getImageWidth(imageIndex, levelIndex);
    const height = basisFile.getImageHeight(imageIndex, levelIndex);
    const hasAlpha = basisFile.getHasAlpha();
    const {
      compressed,
      format,
      basisFormat
    } = getBasisOptions(options, hasAlpha);
    const decodedSize = basisFile.getImageTranscodedSizeInBytes(imageIndex, levelIndex, basisFormat);
    const decodedData = new Uint8Array(decodedSize);
    if (!basisFile.transcodeImage(decodedData, imageIndex, levelIndex, basisFormat, 0, 0)) {
      throw new Error("failed to start Basis transcoding");
    }
    return {
      width,
      height,
      data: decodedData,
      compressed,
      format,
      hasAlpha
    };
  }
  function parseKTX2File(KTX2File, data, options) {
    const ktx2File = new KTX2File(new Uint8Array(data));
    try {
      if (!ktx2File.startTranscoding()) {
        throw new Error("failed to start KTX2 transcoding");
      }
      const levelsCount = ktx2File.getLevels();
      const levels = [];
      for (let levelIndex = 0; levelIndex < levelsCount; levelIndex++) {
        levels.push(transcodeKTX2Image(ktx2File, levelIndex, options));
        break;
      }
      return [levels];
    } finally {
      ktx2File.close();
      ktx2File.delete();
    }
  }
  function transcodeKTX2Image(ktx2File, levelIndex, options) {
    const {
      alphaFlag,
      height,
      width
    } = ktx2File.getImageLevelInfo(levelIndex, 0, 0);
    const {
      compressed,
      format,
      basisFormat
    } = getBasisOptions(options, alphaFlag);
    const decodedSize = ktx2File.getImageTranscodedSizeInBytes(levelIndex, 0, 0, basisFormat);
    const decodedData = new Uint8Array(decodedSize);
    if (!ktx2File.transcodeImage(decodedData, levelIndex, 0, 0, basisFormat, 0, -1, -1)) {
      throw new Error("Failed to transcode KTX2 image");
    }
    return {
      width,
      height,
      data: decodedData,
      compressed,
      levelSize: decodedSize,
      hasAlpha: alphaFlag,
      format
    };
  }
  function getBasisOptions(options, hasAlpha) {
    let format = options && options.basis && options.basis.format;
    if (format === "auto") {
      format = selectSupportedBasisFormat();
    }
    if (typeof format === "object") {
      format = hasAlpha ? format.alpha : format.noAlpha;
    }
    format = format.toLowerCase();
    return OutputFormat[format];
  }
  function selectSupportedBasisFormat() {
    const supportedFormats = getSupportedGPUTextureFormats();
    if (supportedFormats.has("astc")) {
      return "astc-4x4";
    } else if (supportedFormats.has("dxt")) {
      return {
        alpha: "bc3",
        noAlpha: "bc1"
      };
    } else if (supportedFormats.has("pvrtc")) {
      return {
        alpha: "pvrtc1-4-rgba",
        noAlpha: "pvrtc1-4-rgb"
      };
    } else if (supportedFormats.has("etc1")) {
      return "etc1";
    } else if (supportedFormats.has("etc2")) {
      return "etc2";
    }
    return "rgb565";
  }

  // ../../node_modules/@loaders.gl/textures/dist/esm/basis-loader.js
  var BasisWorkerLoader = {
    name: "Basis",
    id: isBrowser5 ? "basis" : "basis-nodejs",
    module: "textures",
    version: VERSION6,
    worker: true,
    extensions: ["basis", "ktx2"],
    mimeTypes: ["application/octet-stream", "image/ktx2"],
    tests: ["sB"],
    binary: true,
    options: {
      basis: {
        format: "auto",
        libraryPath: "libs/",
        containerFormat: "auto",
        module: "transcoder"
      }
    }
  };
  var BasisLoader = {
    ...BasisWorkerLoader,
    parse: parseBasis
  };

  // ../../node_modules/@loaders.gl/gltf/dist/esm/lib/utils/assert.js
  function assert9(condition, message) {
    if (!condition) {
      throw new Error(message || "assert failed: gltf");
    }
  }

  // ../../node_modules/@loaders.gl/gltf/dist/esm/lib/gltf-utils/resolve-url.js
  function resolveUrl(url, options) {
    const absolute = url.startsWith("data:") || url.startsWith("http:") || url.startsWith("https:");
    if (absolute) {
      return url;
    }
    const baseUrl = options.baseUri || options.uri;
    if (!baseUrl) {
      throw new Error("'baseUri' must be provided to resolve relative url ".concat(url));
    }
    return baseUrl.substr(0, baseUrl.lastIndexOf("/") + 1) + url;
  }

  // ../../node_modules/@loaders.gl/gltf/dist/esm/lib/gltf-utils/get-typed-array.js
  function getTypedArrayForBufferView(json, buffers, bufferViewIndex) {
    const bufferView = json.bufferViews[bufferViewIndex];
    assert9(bufferView);
    const bufferIndex = bufferView.buffer;
    const binChunk = buffers[bufferIndex];
    assert9(binChunk);
    const byteOffset = (bufferView.byteOffset || 0) + binChunk.byteOffset;
    return new Uint8Array(binChunk.arrayBuffer, byteOffset, bufferView.byteLength);
  }

  // ../../node_modules/@loaders.gl/gltf/dist/esm/lib/extensions/EXT_meshopt_compression.js
  var EXT_meshopt_compression_exports = {};
  __export(EXT_meshopt_compression_exports, {
    decode: () => decode2,
    name: () => name
  });

  // ../../node_modules/@loaders.gl/gltf/dist/esm/lib/gltf-utils/gltf-utils.js
  var TYPES = ["SCALAR", "VEC2", "VEC3", "VEC4"];
  var ARRAY_CONSTRUCTOR_TO_WEBGL_CONSTANT = [[Int8Array, 5120], [Uint8Array, 5121], [Int16Array, 5122], [Uint16Array, 5123], [Uint32Array, 5125], [Float32Array, 5126], [Float64Array, 5130]];
  var ARRAY_TO_COMPONENT_TYPE = new Map(ARRAY_CONSTRUCTOR_TO_WEBGL_CONSTANT);
  var ATTRIBUTE_TYPE_TO_COMPONENTS3 = {
    SCALAR: 1,
    VEC2: 2,
    VEC3: 3,
    VEC4: 4,
    MAT2: 4,
    MAT3: 9,
    MAT4: 16
  };
  var ATTRIBUTE_COMPONENT_TYPE_TO_BYTE_SIZE = {
    5120: 1,
    5121: 1,
    5122: 2,
    5123: 2,
    5125: 4,
    5126: 4
  };
  var ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY2 = {
    5120: Int8Array,
    5121: Uint8Array,
    5122: Int16Array,
    5123: Uint16Array,
    5125: Uint32Array,
    5126: Float32Array
  };
  function getAccessorTypeFromSize(size) {
    const type = TYPES[size - 1];
    return type || TYPES[0];
  }
  function getComponentTypeFromArray(typedArray) {
    const componentType = ARRAY_TO_COMPONENT_TYPE.get(typedArray.constructor);
    if (!componentType) {
      throw new Error("Illegal typed array");
    }
    return componentType;
  }
  function getAccessorArrayTypeAndLength(accessor, bufferView) {
    const ArrayType = ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY2[accessor.componentType];
    const components = ATTRIBUTE_TYPE_TO_COMPONENTS3[accessor.type];
    const bytesPerComponent = ATTRIBUTE_COMPONENT_TYPE_TO_BYTE_SIZE[accessor.componentType];
    const length4 = accessor.count * components;
    const byteLength = accessor.count * components * bytesPerComponent;
    assert9(byteLength >= 0 && byteLength <= bufferView.byteLength);
    return {
      ArrayType,
      length: length4,
      byteLength
    };
  }

  // ../../node_modules/@loaders.gl/gltf/dist/esm/lib/api/gltf-scenegraph.js
  var DEFAULT_GLTF_JSON = {
    asset: {
      version: "2.0",
      generator: "loaders.gl"
    },
    buffers: []
  };
  var GLTFScenegraph = class {
    constructor(gltf) {
      _defineProperty(this, "gltf", void 0);
      _defineProperty(this, "sourceBuffers", void 0);
      _defineProperty(this, "byteLength", void 0);
      this.gltf = gltf || {
        json: {
          ...DEFAULT_GLTF_JSON
        },
        buffers: []
      };
      this.sourceBuffers = [];
      this.byteLength = 0;
      if (this.gltf.buffers && this.gltf.buffers[0]) {
        this.byteLength = this.gltf.buffers[0].byteLength;
        this.sourceBuffers = [this.gltf.buffers[0]];
      }
    }
    get json() {
      return this.gltf.json;
    }
    getApplicationData(key) {
      const data = this.json[key];
      return data;
    }
    getExtraData(key) {
      const extras = this.json.extras || {};
      return extras[key];
    }
    getExtension(extensionName) {
      const isExtension = this.getUsedExtensions().find((name10) => name10 === extensionName);
      const extensions = this.json.extensions || {};
      return isExtension ? extensions[extensionName] || true : null;
    }
    getRequiredExtension(extensionName) {
      const isRequired = this.getRequiredExtensions().find((name10) => name10 === extensionName);
      return isRequired ? this.getExtension(extensionName) : null;
    }
    getRequiredExtensions() {
      return this.json.extensionsRequired || [];
    }
    getUsedExtensions() {
      return this.json.extensionsUsed || [];
    }
    getRemovedExtensions() {
      return this.json.extensionsRemoved || [];
    }
    getObjectExtension(object, extensionName) {
      const extensions = object.extensions || {};
      return extensions[extensionName];
    }
    getScene(index) {
      return this.getObject("scenes", index);
    }
    getNode(index) {
      return this.getObject("nodes", index);
    }
    getSkin(index) {
      return this.getObject("skins", index);
    }
    getMesh(index) {
      return this.getObject("meshes", index);
    }
    getMaterial(index) {
      return this.getObject("materials", index);
    }
    getAccessor(index) {
      return this.getObject("accessors", index);
    }
    getTexture(index) {
      return this.getObject("textures", index);
    }
    getSampler(index) {
      return this.getObject("samplers", index);
    }
    getImage(index) {
      return this.getObject("images", index);
    }
    getBufferView(index) {
      return this.getObject("bufferViews", index);
    }
    getBuffer(index) {
      return this.getObject("buffers", index);
    }
    getObject(array, index) {
      if (typeof index === "object") {
        return index;
      }
      const object = this.json[array] && this.json[array][index];
      if (!object) {
        throw new Error("glTF file error: Could not find ".concat(array, "[").concat(index, "]"));
      }
      return object;
    }
    getTypedArrayForBufferView(bufferView) {
      bufferView = this.getBufferView(bufferView);
      const bufferIndex = bufferView.buffer;
      const binChunk = this.gltf.buffers[bufferIndex];
      assert9(binChunk);
      const byteOffset = (bufferView.byteOffset || 0) + binChunk.byteOffset;
      return new Uint8Array(binChunk.arrayBuffer, byteOffset, bufferView.byteLength);
    }
    getTypedArrayForAccessor(accessor) {
      accessor = this.getAccessor(accessor);
      const bufferView = this.getBufferView(accessor.bufferView);
      const buffer = this.getBuffer(bufferView.buffer);
      const arrayBuffer2 = buffer.data;
      const {
        ArrayType,
        length: length4
      } = getAccessorArrayTypeAndLength(accessor, bufferView);
      const byteOffset = bufferView.byteOffset + accessor.byteOffset;
      return new ArrayType(arrayBuffer2, byteOffset, length4);
    }
    getTypedArrayForImageData(image) {
      image = this.getAccessor(image);
      const bufferView = this.getBufferView(image.bufferView);
      const buffer = this.getBuffer(bufferView.buffer);
      const arrayBuffer2 = buffer.data;
      const byteOffset = bufferView.byteOffset || 0;
      return new Uint8Array(arrayBuffer2, byteOffset, bufferView.byteLength);
    }
    addApplicationData(key, data) {
      this.json[key] = data;
      return this;
    }
    addExtraData(key, data) {
      this.json.extras = this.json.extras || {};
      this.json.extras[key] = data;
      return this;
    }
    addObjectExtension(object, extensionName, data) {
      object.extensions = object.extensions || {};
      object.extensions[extensionName] = data;
      this.registerUsedExtension(extensionName);
      return this;
    }
    setObjectExtension(object, extensionName, data) {
      const extensions = object.extensions || {};
      extensions[extensionName] = data;
    }
    removeObjectExtension(object, extensionName) {
      const extensions = object.extensions || {};
      const extension = extensions[extensionName];
      delete extensions[extensionName];
      return extension;
    }
    addExtension(extensionName) {
      let extensionData = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      assert9(extensionData);
      this.json.extensions = this.json.extensions || {};
      this.json.extensions[extensionName] = extensionData;
      this.registerUsedExtension(extensionName);
      return extensionData;
    }
    addRequiredExtension(extensionName) {
      let extensionData = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      assert9(extensionData);
      this.addExtension(extensionName, extensionData);
      this.registerRequiredExtension(extensionName);
      return extensionData;
    }
    registerUsedExtension(extensionName) {
      this.json.extensionsUsed = this.json.extensionsUsed || [];
      if (!this.json.extensionsUsed.find((ext) => ext === extensionName)) {
        this.json.extensionsUsed.push(extensionName);
      }
    }
    registerRequiredExtension(extensionName) {
      this.registerUsedExtension(extensionName);
      this.json.extensionsRequired = this.json.extensionsRequired || [];
      if (!this.json.extensionsRequired.find((ext) => ext === extensionName)) {
        this.json.extensionsRequired.push(extensionName);
      }
    }
    removeExtension(extensionName) {
      if (!this.getExtension(extensionName)) {
        return;
      }
      if (this.json.extensionsRequired) {
        this._removeStringFromArray(this.json.extensionsRequired, extensionName);
      }
      if (this.json.extensionsUsed) {
        this._removeStringFromArray(this.json.extensionsUsed, extensionName);
      }
      if (this.json.extensions) {
        delete this.json.extensions[extensionName];
      }
      if (!Array.isArray(this.json.extensionsRemoved)) {
        this.json.extensionsRemoved = [];
      }
      const extensionsRemoved = this.json.extensionsRemoved;
      if (!extensionsRemoved.includes(extensionName)) {
        extensionsRemoved.push(extensionName);
      }
    }
    setDefaultScene(sceneIndex) {
      this.json.scene = sceneIndex;
    }
    addScene(scene) {
      const {
        nodeIndices
      } = scene;
      this.json.scenes = this.json.scenes || [];
      this.json.scenes.push({
        nodes: nodeIndices
      });
      return this.json.scenes.length - 1;
    }
    addNode(node2) {
      const {
        meshIndex,
        matrix
      } = node2;
      this.json.nodes = this.json.nodes || [];
      const nodeData = {
        mesh: meshIndex
      };
      if (matrix) {
        nodeData.matrix = matrix;
      }
      this.json.nodes.push(nodeData);
      return this.json.nodes.length - 1;
    }
    addMesh(mesh) {
      const {
        attributes,
        indices,
        material,
        mode = 4
      } = mesh;
      const accessors = this._addAttributes(attributes);
      const glTFMesh = {
        primitives: [{
          attributes: accessors,
          mode
        }]
      };
      if (indices) {
        const indicesAccessor = this._addIndices(indices);
        glTFMesh.primitives[0].indices = indicesAccessor;
      }
      if (Number.isFinite(material)) {
        glTFMesh.primitives[0].material = material;
      }
      this.json.meshes = this.json.meshes || [];
      this.json.meshes.push(glTFMesh);
      return this.json.meshes.length - 1;
    }
    addPointCloud(attributes) {
      const accessorIndices = this._addAttributes(attributes);
      const glTFMesh = {
        primitives: [{
          attributes: accessorIndices,
          mode: 0
        }]
      };
      this.json.meshes = this.json.meshes || [];
      this.json.meshes.push(glTFMesh);
      return this.json.meshes.length - 1;
    }
    addImage(imageData, mimeTypeOpt) {
      const metadata = getBinaryImageMetadata(imageData);
      const mimeType = mimeTypeOpt || (metadata === null || metadata === void 0 ? void 0 : metadata.mimeType);
      const bufferViewIndex = this.addBufferView(imageData);
      const glTFImage = {
        bufferView: bufferViewIndex,
        mimeType
      };
      this.json.images = this.json.images || [];
      this.json.images.push(glTFImage);
      return this.json.images.length - 1;
    }
    addBufferView(buffer) {
      const byteLength = buffer.byteLength;
      assert9(Number.isFinite(byteLength));
      this.sourceBuffers = this.sourceBuffers || [];
      this.sourceBuffers.push(buffer);
      const glTFBufferView = {
        buffer: 0,
        byteOffset: this.byteLength,
        byteLength
      };
      this.byteLength += padToNBytes(byteLength, 4);
      this.json.bufferViews = this.json.bufferViews || [];
      this.json.bufferViews.push(glTFBufferView);
      return this.json.bufferViews.length - 1;
    }
    addAccessor(bufferViewIndex, accessor) {
      const glTFAccessor = {
        bufferView: bufferViewIndex,
        type: getAccessorTypeFromSize(accessor.size),
        componentType: accessor.componentType,
        count: accessor.count,
        max: accessor.max,
        min: accessor.min
      };
      this.json.accessors = this.json.accessors || [];
      this.json.accessors.push(glTFAccessor);
      return this.json.accessors.length - 1;
    }
    addBinaryBuffer(sourceBuffer) {
      let accessor = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
        size: 3
      };
      const bufferViewIndex = this.addBufferView(sourceBuffer);
      let minMax = {
        min: accessor.min,
        max: accessor.max
      };
      if (!minMax.min || !minMax.max) {
        minMax = this._getAccessorMinMax(sourceBuffer, accessor.size);
      }
      const accessorDefaults = {
        size: accessor.size,
        componentType: getComponentTypeFromArray(sourceBuffer),
        count: Math.round(sourceBuffer.length / accessor.size),
        min: minMax.min,
        max: minMax.max
      };
      return this.addAccessor(bufferViewIndex, Object.assign(accessorDefaults, accessor));
    }
    addTexture(texture) {
      const {
        imageIndex
      } = texture;
      const glTFTexture = {
        source: imageIndex
      };
      this.json.textures = this.json.textures || [];
      this.json.textures.push(glTFTexture);
      return this.json.textures.length - 1;
    }
    addMaterial(pbrMaterialInfo) {
      this.json.materials = this.json.materials || [];
      this.json.materials.push(pbrMaterialInfo);
      return this.json.materials.length - 1;
    }
    createBinaryChunk() {
      var _this$json, _this$json$buffers;
      this.gltf.buffers = [];
      const totalByteLength = this.byteLength;
      const arrayBuffer2 = new ArrayBuffer(totalByteLength);
      const targetArray = new Uint8Array(arrayBuffer2);
      let dstByteOffset = 0;
      for (const sourceBuffer of this.sourceBuffers || []) {
        dstByteOffset = copyToArray(sourceBuffer, targetArray, dstByteOffset);
      }
      if ((_this$json = this.json) !== null && _this$json !== void 0 && (_this$json$buffers = _this$json.buffers) !== null && _this$json$buffers !== void 0 && _this$json$buffers[0]) {
        this.json.buffers[0].byteLength = totalByteLength;
      } else {
        this.json.buffers = [{
          byteLength: totalByteLength
        }];
      }
      this.gltf.binary = arrayBuffer2;
      this.sourceBuffers = [arrayBuffer2];
    }
    _removeStringFromArray(array, string) {
      let found = true;
      while (found) {
        const index = array.indexOf(string);
        if (index > -1) {
          array.splice(index, 1);
        } else {
          found = false;
        }
      }
    }
    _addAttributes() {
      let attributes = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const result = {};
      for (const attributeKey in attributes) {
        const attributeData = attributes[attributeKey];
        const attrName = this._getGltfAttributeName(attributeKey);
        const accessor = this.addBinaryBuffer(attributeData.value, attributeData);
        result[attrName] = accessor;
      }
      return result;
    }
    _addIndices(indices) {
      return this.addBinaryBuffer(indices, {
        size: 1
      });
    }
    _getGltfAttributeName(attributeName) {
      switch (attributeName.toLowerCase()) {
        case "position":
        case "positions":
        case "vertices":
          return "POSITION";
        case "normal":
        case "normals":
          return "NORMAL";
        case "color":
        case "colors":
          return "COLOR_0";
        case "texcoord":
        case "texcoords":
          return "TEXCOORD_0";
        default:
          return attributeName;
      }
    }
    _getAccessorMinMax(buffer, size) {
      const result = {
        min: null,
        max: null
      };
      if (buffer.length < size) {
        return result;
      }
      result.min = [];
      result.max = [];
      const initValues = buffer.subarray(0, size);
      for (const value of initValues) {
        result.min.push(value);
        result.max.push(value);
      }
      for (let index = size; index < buffer.length; index += size) {
        for (let componentIndex = 0; componentIndex < size; componentIndex++) {
          result.min[0 + componentIndex] = Math.min(
            result.min[0 + componentIndex],
            buffer[index + componentIndex]
          );
          result.max[0 + componentIndex] = Math.max(
            result.max[0 + componentIndex],
            buffer[index + componentIndex]
          );
        }
      }
      return result;
    }
  };

  // ../../node_modules/@loaders.gl/gltf/dist/esm/meshopt/meshopt-decoder.js
  var wasm_base = "B9h9z9tFBBBF8fL9gBB9gLaaaaaFa9gEaaaB9gFaFa9gEaaaFaEMcBFFFGGGEIIILF9wFFFLEFBFKNFaFCx/IFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBF8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBGy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBEn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBIi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBKI9z9iqlBOc+x8ycGBM/qQFTa8jUUUUBCU/EBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAGTkUUUBRNCUoBAG9uC/wgBZHKCUGAKCUG9JyRVAECFJRICBRcGXEXAcAF9PQFAVAFAclAcAVJAF9JyRMGXGXAG9FQBAMCbJHKC9wZRSAKCIrCEJCGrRQANCUGJRfCBRbAIRTEXGXAOATlAQ9PQBCBRISEMATAQJRIGXAS9FQBCBRtCBREEXGXAOAIlCi9PQBCBRISLMANCU/CBJAEJRKGXGXGXGXGXATAECKrJ2BBAtCKZrCEZfIBFGEBMAKhB83EBAKCNJhB83EBSEMAKAI2BIAI2BBHmCKrHYAYCE6HYy86BBAKCFJAICIJAYJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCGJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCEJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCIJAYAmJHY2BBAI2BFHmCKrHPAPCE6HPy86BBAKCLJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCKJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCOJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCNJAYAmJHY2BBAI2BGHmCKrHPAPCE6HPy86BBAKCVJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCcJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCMJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCSJAYAmJHm2BBAI2BEHICKrHYAYCE6HYy86BBAKCQJAmAYJHm2BBAICIrCEZHYAYCE6HYy86BBAKCfJAmAYJHm2BBAICGrCEZHYAYCE6HYy86BBAKCbJAmAYJHK2BBAICEZHIAICE6HIy86BBAKAIJRISGMAKAI2BNAI2BBHmCIrHYAYCb6HYy86BBAKCFJAICNJAYJHY2BBAmCbZHmAmCb6Hmy86BBAKCGJAYAmJHm2BBAI2BFHYCIrHPAPCb6HPy86BBAKCEJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCIJAmAYJHm2BBAI2BGHYCIrHPAPCb6HPy86BBAKCLJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCKJAmAYJHm2BBAI2BEHYCIrHPAPCb6HPy86BBAKCOJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCNJAmAYJHm2BBAI2BIHYCIrHPAPCb6HPy86BBAKCVJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCcJAmAYJHm2BBAI2BLHYCIrHPAPCb6HPy86BBAKCMJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCSJAmAYJHm2BBAI2BKHYCIrHPAPCb6HPy86BBAKCQJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCfJAmAYJHm2BBAI2BOHICIrHYAYCb6HYy86BBAKCbJAmAYJHK2BBAICbZHIAICb6HIy86BBAKAIJRISFMAKAI8pBB83BBAKCNJAICNJ8pBB83BBAICTJRIMAtCGJRtAECTJHEAS9JQBMMGXAIQBCBRISEMGXAM9FQBANAbJ2BBRtCBRKAfREEXAEANCU/CBJAKJ2BBHTCFrCBATCFZl9zAtJHt86BBAEAGJREAKCFJHKAM9HQBMMAfCFJRfAIRTAbCFJHbAG9HQBMMABAcAG9sJANCUGJAMAG9sTkUUUBpANANCUGJAMCaJAG9sJAGTkUUUBpMAMCBAIyAcJRcAIQBMC9+RKSFMCBC99AOAIlAGCAAGCA9Ly6yRKMALCU/EBJ8kUUUUBAKM+OmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUFT+JUUUBpALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM+lLKFaF99GaG99FaG99GXGXAGCI9HQBAF9FQFEXGXGX9DBBB8/9DBBB+/ABCGJHG1BB+yAB1BBHE+yHI+L+TABCFJHL1BBHK+yHO+L+THN9DBBBB9gHVyAN9DBB/+hANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE86BBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG86BBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG86BBABCIJRBAFCaJHFQBSGMMAF9FQBEXGXGX9DBBB8/9DBBB+/ABCIJHG8uFB+yAB8uFBHE+yHI+L+TABCGJHL8uFBHK+yHO+L+THN9DBBBB9gHVyAN9DB/+g6ANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE87FBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG87FBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG87FBABCNJRBAFCaJHFQBMMM/SEIEaE99EaF99GXAF9FQBCBREABRIEXGXGX9D/zI818/AICKJ8uFBHLCEq+y+VHKAI8uFB+y+UHO9DB/+g6+U9DBBB8/9DBBB+/AO9DBBBB9gy+SHN+L9DBBB9P9d9FQBAN+oRVSFMCUUUU94RVMAICIJ8uFBRcAICGJ8uFBRMABALCFJCEZAEqCFWJAV87FBGXGXAKAM+y+UHN9DB/+g6+U9DBBB8/9DBBB+/AN9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRMSFMCUUUU94RMMABALCGJCEZAEqCFWJAM87FBGXGXAKAc+y+UHK9DB/+g6+U9DBBB8/9DBBB+/AK9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRcSFMCUUUU94RcMABALCaJCEZAEqCFWJAc87FBGXGX9DBBU8/AOAO+U+TANAN+U+TAKAK+U+THO9DBBBBAO9DBBBB9gy+R9DB/+g6+U9DBBB8/+SHO+L9DBBB9P9d9FQBAO+oRcSFMCUUUU94RcMABALCEZAEqCFWJAc87FBAICNJRIAECIJREAFCaJHFQBMMM9JBGXAGCGrAF9sHF9FQBEXABAB8oGBHGCNWCN91+yAGCi91CnWCUUU/8EJ+++U84GBABCIJRBAFCaJHFQBMMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEM/lFFFaGXGXAFABqCEZ9FQBABRESFMGXGXAGCT9PQBABRESFMABREEXAEAF8oGBjGBAECIJAFCIJ8oGBjGBAECNJAFCNJ8oGBjGBAECSJAFCSJ8oGBjGBAECTJREAFCTJRFAGC9wJHGCb9LQBMMAGCI9JQBEXAEAF8oGBjGBAFCIJRFAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF2BB86BBAECFJREAFCFJRFAGCaJHGQBMMABMoFFGaGXGXABCEZ9FQBABRESFMAFCgFZC+BwsN9sRIGXGXAGCT9PQBABRESFMABREEXAEAIjGBAECSJAIjGBAECNJAIjGBAECIJAIjGBAECTJREAGC9wJHGCb9LQBMMAGCI9JQBEXAEAIjGBAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF86BBAECFJREAGCaJHGQBMMABMMMFBCUNMIT9kBB";
  var wasm_simd = "B9h9z9tFBBBF8dL9gBB9gLaaaaaFa9gEaaaB9gGaaB9gFaFaEQSBBFBFFGEGEGIILF9wFFFLEFBFKNFaFCx/aFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBG8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBIy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBKi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBNn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBcI9z9iqlBMc/j9JSIBTEM9+FLa8jUUUUBCTlRBCBRFEXCBRGCBREEXABCNJAGJAECUaAFAGrCFZHIy86BBAEAIJREAGCFJHGCN9HQBMAFCx+YUUBJAE86BBAFCEWCxkUUBJAB8pEN83EBAFCFJHFCUG9HQBMMkRIbaG97FaK978jUUUUBCU/KBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAG/8cBBCUoBAG9uC/wgBZHKCUGAKCUG9JyRNAECFJRKCBRVGXEXAVAF9PQFANAFAVlAVANJAF9JyRcGXGXAG9FQBAcCbJHIC9wZHMCE9sRSAMCFWRQAICIrCEJCGrRfCBRbEXAKRTCBRtGXEXGXAOATlAf9PQBCBRKSLMALCU/CBJAtAM9sJRmATAfJRKCBREGXAMCoB9JQBAOAKlC/gB9JQBCBRIEXAmAIJREGXGXGXGXGXATAICKrJ2BBHYCEZfIBFGEBMAECBDtDMIBSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAnDeBJAeCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAnDeBJAeCx+YUUBJ2BBJRKSFMAEAKDBBBDMIBAKCTJRKMGXGXGXGXGXAYCGrCEZfIBFGEBMAECBDtDMITSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCIJAnDeBJAeCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCNJAnDeBJAeCx+YUUBJ2BBJRKSFMAEAKDBBBDMITAKCTJRKMGXGXGXGXGXAYCIrCEZfIBFGEBMAECBDtDMIASEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCIJAnDeBJAeCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCNJAnDeBJAeCx+YUUBJ2BBJRKSFMAEAKDBBBDMIAAKCTJRKMGXGXGXGXGXAYCKrfIBFGEBMAECBDtDMI8wSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCIJAnDeBJAYCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCNJAnDeBJAYCx+YUUBJ2BBJRKSFMAEAKDBBBDMI8wAKCTJRKMAICoBJREAICUFJAM9LQFAERIAOAKlC/fB9LQBMMGXAEAM9PQBAECErRIEXGXAOAKlCi9PQBCBRKSOMAmAEJRYGXGXGXGXGXATAECKrJ2BBAICKZrCEZfIBFGEBMAYCBDtDMIBSEMAYAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAnDeBJAeCx+YUUBJ2BBJRKSGMAYAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAnDeBJAeCx+YUUBJ2BBJRKSFMAYAKDBBBDMIBAKCTJRKMAICGJRIAECTJHEAM9JQBMMGXAK9FQBAKRTAtCFJHtCI6QGSFMMCBRKSEMGXAM9FQBALCUGJAbJREALAbJDBGBRnCBRYEXAEALCU/CBJAYJHIDBIBHdCFD9tAdCFDbHPD9OD9hD9RHdAIAMJDBIBHiCFD9tAiAPD9OD9hD9RHiDQBTFtGmEYIPLdKeOnH8ZAIAQJDBIBHpCFD9tApAPD9OD9hD9RHpAIASJDBIBHyCFD9tAyAPD9OD9hD9RHyDQBTFtGmEYIPLdKeOnH8cDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGEAnD9uHnDyBjGBAEAGJHIAnAPAPDQILKOILKOILKOILKOD9uHnDyBjGBAIAGJHIAnAPAPDQNVcMNVcMNVcMNVcMD9uHnDyBjGBAIAGJHIAnAPAPDQSQfbSQfbSQfbSQfbD9uHnDyBjGBAIAGJHIAnA8ZA8cDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHnDyBjGBAIAGJHIAnAPAPDQILKOILKOILKOILKOD9uHnDyBjGBAIAGJHIAnAPAPDQNVcMNVcMNVcMNVcMD9uHnDyBjGBAIAGJHIAnAPAPDQSQfbSQfbSQfbSQfbD9uHnDyBjGBAIAGJHIAnAdAiDQNiV8ZcpMyS8cQ8df8eb8fHdApAyDQNiV8ZcpMyS8cQ8df8eb8fHiDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGED9uHnDyBjGBAIAGJHIAnAPAPDQILKOILKOILKOILKOD9uHnDyBjGBAIAGJHIAnAPAPDQNVcMNVcMNVcMNVcMD9uHnDyBjGBAIAGJHIAnAPAPDQSQfbSQfbSQfbSQfbD9uHnDyBjGBAIAGJHIAnAdAiDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHnDyBjGBAIAGJHIAnAPAPDQILKOILKOILKOILKOD9uHnDyBjGBAIAGJHIAnAPAPDQNVcMNVcMNVcMNVcMD9uHnDyBjGBAIAGJHIAnAPAPDQSQfbSQfbSQfbSQfbD9uHnDyBjGBAIAGJREAYCTJHYAM9JQBMMAbCIJHbAG9JQBMMABAVAG9sJALCUGJAcAG9s/8cBBALALCUGJAcCaJAG9sJAG/8cBBMAcCBAKyAVJRVAKQBMC9+RKSFMCBC99AOAKlAGCAAGCA9Ly6yRKMALCU/KBJ8kUUUUBAKMNBT+BUUUBM+KmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUF/8MBALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM/xLGEaK978jUUUUBCAlHE8kUUUUBGXGXAGCI9HQBGXAFC98ZHI9FQBABRGCBRLEXAGAGDBBBHKCiD+rFCiD+sFD/6FHOAKCND+rFCiD+sFD/6FAOD/gFAKCTD+rFCiD+sFD/6FHND/gFD/kFD/lFHVCBDtD+2FHcAOCUUUU94DtHMD9OD9RD/kFHO9DBB/+hDYAOAOD/mFAVAVD/mFANAcANAMD9OD9RD/kFHOAOD/mFD/kFD/kFD/jFD/nFHND/mF9DBBX9LDYHcD/kFCgFDtD9OAKCUUU94DtD9OD9QAOAND/mFAcD/kFCND+rFCU/+EDtD9OD9QAVAND/mFAcD/kFCTD+rFCUU/8ODtD9OD9QDMBBAGCTJRGALCIJHLAI9JQBMMAIAF9PQFAEAFCEZHLCGWHGqCBCTAGl/8MBAEABAICGWJHIAG/8cBBGXAL9FQBAEAEDBIBHKCiD+rFCiD+sFD/6FHOAKCND+rFCiD+sFD/6FAOD/gFAKCTD+rFCiD+sFD/6FHND/gFD/kFD/lFHVCBDtD+2FHcAOCUUUU94DtHMD9OD9RD/kFHO9DBB/+hDYAOAOD/mFAVAVD/mFANAcANAMD9OD9RD/kFHOAOD/mFD/kFD/kFD/jFD/nFHND/mF9DBBX9LDYHcD/kFCgFDtD9OAKCUUU94DtD9OD9QAOAND/mFAcD/kFCND+rFCU/+EDtD9OD9QAVAND/mFAcD/kFCTD+rFCUU/8ODtD9OD9QDMIBMAIAEAG/8cBBSFMABAFC98ZHGT+HUUUBAGAF9PQBAEAFCEZHICEWHLJCBCAALl/8MBAEABAGCEWJHGAL/8cBBAEAIT+HUUUBAGAEAL/8cBBMAECAJ8kUUUUBM+yEGGaO97GXAF9FQBCBRGEXABCTJHEAEDBBBHICBDtHLCUU98D8cFCUU98D8cEHKD9OABDBBBHOAIDQILKOSQfbPden8c8d8e8fCggFDtD9OD/6FAOAIDQBFGENVcMTtmYi8ZpyHICTD+sFD/6FHND/gFAICTD+rFCTD+sFD/6FHVD/gFD/kFD/lFHI9DB/+g6DYAVAIALD+2FHLAVCUUUU94DtHcD9OD9RD/kFHVAVD/mFAIAID/mFANALANAcD9OD9RD/kFHIAID/mFD/kFD/kFD/jFD/nFHND/mF9DBBX9LDYHLD/kFCTD+rFAVAND/mFALD/kFCggEDtD9OD9QHVAIAND/mFALD/kFCaDbCBDnGCBDnECBDnKCBDnOCBDncCBDnMCBDnfCBDnbD9OHIDQNVi8ZcMpySQ8c8dfb8e8fD9QDMBBABAOAKD9OAVAIDQBFTtGEmYILPdKOenD9QDMBBABCAJRBAGCIJHGAF9JQBMMM94FEa8jUUUUBCAlHE8kUUUUBABAFC98ZHIT+JUUUBGXAIAF9PQBAEAFCEZHLCEWHFJCBCAAFl/8MBAEABAICEWJHBAF/8cBBAEALT+JUUUBABAEAF/8cBBMAECAJ8kUUUUBM/hEIGaF97FaL978jUUUUBCTlRGGXAF9FQBCBREEXAGABDBBBHIABCTJHLDBBBHKDQILKOSQfbPden8c8d8e8fHOCTD+sFHNCID+rFDMIBAB9DBBU8/DY9D/zI818/DYANCEDtD9QD/6FD/nFHNAIAKDQBFGENVcMTtmYi8ZpyHICTD+rFCTD+sFD/6FD/mFHKAKD/mFANAICTD+sFD/6FD/mFHVAVD/mFANAOCTD+rFCTD+sFD/6FD/mFHOAOD/mFD/kFD/kFD/lFCBDtD+4FD/jF9DB/+g6DYHND/mF9DBBX9LDYHID/kFCggEDtHcD9OAVAND/mFAID/kFCTD+rFD9QHVAOAND/mFAID/kFCTD+rFAKAND/mFAID/kFAcD9OD9QHNDQBFTtGEmYILPdKOenHID8dBAGDBIBDyB+t+J83EBABCNJAID8dFAGDBIBDyF+t+J83EBALAVANDQNVi8ZcMpySQ8c8dfb8e8fHND8dBAGDBIBDyG+t+J83EBABCiJAND8dFAGDBIBDyE+t+J83EBABCAJRBAECIJHEAF9JQBMMM/3FGEaF978jUUUUBCoBlREGXAGCGrAF9sHIC98ZHL9FQBCBRGABRFEXAFAFDBBBHKCND+rFCND+sFD/6FAKCiD+sFCnD+rFCUUU/8EDtD+uFD/mFDMBBAFCTJRFAGCIJHGAL9JQBMMGXALAI9PQBAEAICEZHGCGWHFqCBCoBAFl/8MBAEABALCGWJHLAF/8cBBGXAG9FQBAEAEDBIBHKCND+rFCND+sFD/6FAKCiD+sFCnD+rFCUUU/8EDtD+uFD/mFDMIBMALAEAF/8cBBMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEMMMFBCUNMIT9tBB";
  var detector = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 3, 2, 0, 0, 5, 3, 1, 0, 1, 12, 1, 0, 10, 22, 2, 12, 0, 65, 0, 65, 0, 65, 0, 252, 10, 0, 0, 11, 7, 0, 65, 0, 253, 15, 26, 11]);
  var wasmpack = new Uint8Array([32, 0, 65, 253, 3, 1, 2, 34, 4, 106, 6, 5, 11, 8, 7, 20, 13, 33, 12, 16, 128, 9, 116, 64, 19, 113, 127, 15, 10, 21, 22, 14, 255, 66, 24, 54, 136, 107, 18, 23, 192, 26, 114, 118, 132, 17, 77, 101, 130, 144, 27, 87, 131, 44, 45, 74, 156, 154, 70, 167]);
  var FILTERS = {
    0: "",
    1: "meshopt_decodeFilterOct",
    2: "meshopt_decodeFilterQuat",
    3: "meshopt_decodeFilterExp",
    NONE: "",
    OCTAHEDRAL: "meshopt_decodeFilterOct",
    QUATERNION: "meshopt_decodeFilterQuat",
    EXPONENTIAL: "meshopt_decodeFilterExp"
  };
  var DECODERS = {
    0: "meshopt_decodeVertexBuffer",
    1: "meshopt_decodeIndexBuffer",
    2: "meshopt_decodeIndexSequence",
    ATTRIBUTES: "meshopt_decodeVertexBuffer",
    TRIANGLES: "meshopt_decodeIndexBuffer",
    INDICES: "meshopt_decodeIndexSequence"
  };
  async function meshoptDecodeGltfBuffer(target, count, size, source, mode) {
    let filter = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : "NONE";
    const instance = await loadWasmInstance();
    decode(instance, instance.exports[DECODERS[mode]], target, count, size, source, instance.exports[FILTERS[filter || "NONE"]]);
  }
  var wasmPromise;
  async function loadWasmInstance() {
    if (!wasmPromise) {
      wasmPromise = loadWasmModule();
    }
    return wasmPromise;
  }
  async function loadWasmModule() {
    let wasm = wasm_base;
    if (WebAssembly.validate(detector)) {
      wasm = wasm_simd;
      console.log("Warning: meshopt_decoder is using experimental SIMD support");
    }
    const result = await WebAssembly.instantiate(unpack(wasm), {});
    await result.instance.exports.__wasm_call_ctors();
    return result.instance;
  }
  function unpack(data) {
    const result = new Uint8Array(data.length);
    for (let i2 = 0; i2 < data.length; ++i2) {
      const ch = data.charCodeAt(i2);
      result[i2] = ch > 96 ? ch - 71 : ch > 64 ? ch - 65 : ch > 47 ? ch + 4 : ch > 46 ? 63 : 62;
    }
    let write = 0;
    for (let i2 = 0; i2 < data.length; ++i2) {
      result[write++] = result[i2] < 60 ? wasmpack[result[i2]] : (result[i2] - 60) * 64 + result[++i2];
    }
    return result.buffer.slice(0, write);
  }
  function decode(instance, fun, target, count, size, source, filter) {
    const sbrk = instance.exports.sbrk;
    const count4 = count + 3 & ~3;
    const tp = sbrk(count4 * size);
    const sp = sbrk(source.length);
    const heap = new Uint8Array(instance.exports.memory.buffer);
    heap.set(source, sp);
    const res = fun(tp, count, size, sp, source.length);
    if (res === 0 && filter) {
      filter(tp, count4, size);
    }
    target.set(heap.subarray(tp, tp + count * size));
    sbrk(tp - sbrk(0));
    if (res !== 0) {
      throw new Error("Malformed buffer data: ".concat(res));
    }
  }

  // ../../node_modules/@loaders.gl/gltf/dist/esm/lib/extensions/EXT_meshopt_compression.js
  var EXT_MESHOPT_COMPRESSION = "EXT_meshopt_compression";
  var name = EXT_MESHOPT_COMPRESSION;
  async function decode2(gltfData, options) {
    var _options$gltf;
    const scenegraph = new GLTFScenegraph(gltfData);
    if (!(options !== null && options !== void 0 && (_options$gltf = options.gltf) !== null && _options$gltf !== void 0 && _options$gltf.decompressMeshes)) {
      return;
    }
    const promises = [];
    for (const bufferViewIndex of gltfData.json.bufferViews || []) {
      promises.push(decodeMeshoptBufferView(scenegraph, bufferViewIndex));
    }
    await Promise.all(promises);
    scenegraph.removeExtension(EXT_MESHOPT_COMPRESSION);
  }
  async function decodeMeshoptBufferView(scenegraph, bufferView) {
    const meshoptExtension = scenegraph.getObjectExtension(bufferView, EXT_MESHOPT_COMPRESSION);
    if (meshoptExtension) {
      const {
        byteOffset = 0,
        byteLength = 0,
        byteStride,
        count,
        mode,
        filter = "NONE",
        buffer: bufferIndex
      } = meshoptExtension;
      const buffer = scenegraph.gltf.buffers[bufferIndex];
      const source = new Uint8Array(buffer.arrayBuffer, buffer.byteOffset + byteOffset, byteLength);
      const result = new Uint8Array(scenegraph.gltf.buffers[bufferView.buffer].arrayBuffer, bufferView.byteOffset, bufferView.byteLength);
      await meshoptDecodeGltfBuffer(result, count, byteStride, source, mode, filter);
      return result;
    }
    return null;
  }

  // ../../node_modules/@loaders.gl/gltf/dist/esm/lib/extensions/EXT_texture_webp.js
  var EXT_texture_webp_exports = {};
  __export(EXT_texture_webp_exports, {
    name: () => name2,
    preprocess: () => preprocess
  });
  var EXT_TEXTURE_WEBP = "EXT_texture_webp";
  var name2 = EXT_TEXTURE_WEBP;
  function preprocess(gltfData, options) {
    const scenegraph = new GLTFScenegraph(gltfData);
    if (!_isImageFormatSupported("image/webp")) {
      if (scenegraph.getRequiredExtensions().includes(EXT_TEXTURE_WEBP)) {
        throw new Error("gltf: Required extension ".concat(EXT_TEXTURE_WEBP, " not supported by browser"));
      }
      return;
    }
    const {
      json
    } = scenegraph;
    for (const texture of json.textures || []) {
      const extension = scenegraph.getObjectExtension(texture, EXT_TEXTURE_WEBP);
      if (extension) {
        texture.source = extension.source;
      }
      scenegraph.removeObjectExtension(texture, EXT_TEXTURE_WEBP);
    }
    scenegraph.removeExtension(EXT_TEXTURE_WEBP);
  }

  // ../../node_modules/@loaders.gl/gltf/dist/esm/lib/extensions/KHR_texture_basisu.js
  var KHR_texture_basisu_exports = {};
  __export(KHR_texture_basisu_exports, {
    name: () => name3,
    preprocess: () => preprocess2
  });
  var KHR_TEXTURE_BASISU = "KHR_texture_basisu";
  var name3 = KHR_TEXTURE_BASISU;
  function preprocess2(gltfData, options) {
    const scene = new GLTFScenegraph(gltfData);
    const {
      json
    } = scene;
    for (const texture of json.textures || []) {
      const extension = scene.getObjectExtension(texture, KHR_TEXTURE_BASISU);
      if (extension) {
        texture.source = extension.source;
      }
      scene.removeObjectExtension(texture, KHR_TEXTURE_BASISU);
    }
    scene.removeExtension(KHR_TEXTURE_BASISU);
  }

  // ../../node_modules/@loaders.gl/gltf/dist/esm/lib/extensions/KHR_draco_mesh_compression.js
  var KHR_draco_mesh_compression_exports = {};
  __export(KHR_draco_mesh_compression_exports, {
    decode: () => decode3,
    encode: () => encode,
    name: () => name4,
    preprocess: () => preprocess3
  });

  // ../../node_modules/@loaders.gl/draco/dist/esm/lib/utils/version.js
  var VERSION8 = true ? "3.3.3" : "latest";

  // ../../node_modules/@loaders.gl/draco/dist/esm/draco-loader.js
  var DEFAULT_DRACO_OPTIONS = {
    draco: {
      decoderType: typeof WebAssembly === "object" ? "wasm" : "js",
      libraryPath: "libs/",
      extraAttributes: {},
      attributeNameEntry: void 0
    }
  };
  var DracoLoader = {
    name: "Draco",
    id: isBrowser5 ? "draco" : "draco-nodejs",
    module: "draco",
    shapes: ["mesh"],
    version: VERSION8,
    worker: true,
    extensions: ["drc"],
    mimeTypes: ["application/octet-stream"],
    binary: true,
    tests: ["DRACO"],
    options: DEFAULT_DRACO_OPTIONS
  };

  // ../../node_modules/@loaders.gl/draco/dist/esm/lib/utils/get-draco-schema.js
  function getDracoSchema(attributes, loaderData, indices) {
    const metadataMap = makeMetadata(loaderData.metadata);
    const fields = [];
    const namedLoaderDataAttributes = transformAttributesLoaderData(loaderData.attributes);
    for (const attributeName in attributes) {
      const attribute = attributes[attributeName];
      const field = getArrowFieldFromAttribute(attributeName, attribute, namedLoaderDataAttributes[attributeName]);
      fields.push(field);
    }
    if (indices) {
      const indicesField = getArrowFieldFromAttribute("indices", indices);
      fields.push(indicesField);
    }
    return new Schema(fields, metadataMap);
  }
  function transformAttributesLoaderData(loaderData) {
    const result = {};
    for (const key in loaderData) {
      const dracoAttribute = loaderData[key];
      result[dracoAttribute.name || "undefined"] = dracoAttribute;
    }
    return result;
  }
  function getArrowFieldFromAttribute(attributeName, attribute, loaderData) {
    const metadataMap = loaderData ? makeMetadata(loaderData.metadata) : void 0;
    const field = deduceMeshField(attributeName, attribute, metadataMap);
    return field;
  }
  function makeMetadata(metadata) {
    const metadataMap = /* @__PURE__ */ new Map();
    for (const key in metadata) {
      metadataMap.set("".concat(key, ".string"), JSON.stringify(metadata[key]));
    }
    return metadataMap;
  }

  // ../../node_modules/@loaders.gl/draco/dist/esm/lib/draco-parser.js
  var DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP = {
    POSITION: "POSITION",
    NORMAL: "NORMAL",
    COLOR: "COLOR_0",
    TEX_COORD: "TEXCOORD_0"
  };
  var DRACO_DATA_TYPE_TO_TYPED_ARRAY_MAP = {
    1: Int8Array,
    2: Uint8Array,
    3: Int16Array,
    4: Uint16Array,
    5: Int32Array,
    6: Uint32Array,
    9: Float32Array
  };
  var INDEX_ITEM_SIZE = 4;
  var DracoParser = class {
    constructor(draco) {
      _defineProperty(this, "draco", void 0);
      _defineProperty(this, "decoder", void 0);
      _defineProperty(this, "metadataQuerier", void 0);
      this.draco = draco;
      this.decoder = new this.draco.Decoder();
      this.metadataQuerier = new this.draco.MetadataQuerier();
    }
    destroy() {
      this.draco.destroy(this.decoder);
      this.draco.destroy(this.metadataQuerier);
    }
    parseSync(arrayBuffer2) {
      let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      const buffer = new this.draco.DecoderBuffer();
      buffer.Init(new Int8Array(arrayBuffer2), arrayBuffer2.byteLength);
      this._disableAttributeTransforms(options);
      const geometry_type = this.decoder.GetEncodedGeometryType(buffer);
      const dracoGeometry = geometry_type === this.draco.TRIANGULAR_MESH ? new this.draco.Mesh() : new this.draco.PointCloud();
      try {
        let dracoStatus;
        switch (geometry_type) {
          case this.draco.TRIANGULAR_MESH:
            dracoStatus = this.decoder.DecodeBufferToMesh(buffer, dracoGeometry);
            break;
          case this.draco.POINT_CLOUD:
            dracoStatus = this.decoder.DecodeBufferToPointCloud(buffer, dracoGeometry);
            break;
          default:
            throw new Error("DRACO: Unknown geometry type.");
        }
        if (!dracoStatus.ok() || !dracoGeometry.ptr) {
          const message = "DRACO decompression failed: ".concat(dracoStatus.error_msg());
          throw new Error(message);
        }
        const loaderData = this._getDracoLoaderData(dracoGeometry, geometry_type, options);
        const geometry = this._getMeshData(dracoGeometry, loaderData, options);
        const boundingBox = getMeshBoundingBox(geometry.attributes);
        const schema = getDracoSchema(geometry.attributes, loaderData, geometry.indices);
        const data = {
          loader: "draco",
          loaderData,
          header: {
            vertexCount: dracoGeometry.num_points(),
            boundingBox
          },
          ...geometry,
          schema
        };
        return data;
      } finally {
        this.draco.destroy(buffer);
        if (dracoGeometry) {
          this.draco.destroy(dracoGeometry);
        }
      }
    }
    _getDracoLoaderData(dracoGeometry, geometry_type, options) {
      const metadata = this._getTopLevelMetadata(dracoGeometry);
      const attributes = this._getDracoAttributes(dracoGeometry, options);
      return {
        geometry_type,
        num_attributes: dracoGeometry.num_attributes(),
        num_points: dracoGeometry.num_points(),
        num_faces: dracoGeometry instanceof this.draco.Mesh ? dracoGeometry.num_faces() : 0,
        metadata,
        attributes
      };
    }
    _getDracoAttributes(dracoGeometry, options) {
      const dracoAttributes = {};
      for (let attributeId = 0; attributeId < dracoGeometry.num_attributes(); attributeId++) {
        const dracoAttribute = this.decoder.GetAttribute(dracoGeometry, attributeId);
        const metadata = this._getAttributeMetadata(dracoGeometry, attributeId);
        dracoAttributes[dracoAttribute.unique_id()] = {
          unique_id: dracoAttribute.unique_id(),
          attribute_type: dracoAttribute.attribute_type(),
          data_type: dracoAttribute.data_type(),
          num_components: dracoAttribute.num_components(),
          byte_offset: dracoAttribute.byte_offset(),
          byte_stride: dracoAttribute.byte_stride(),
          normalized: dracoAttribute.normalized(),
          attribute_index: attributeId,
          metadata
        };
        const quantization = this._getQuantizationTransform(dracoAttribute, options);
        if (quantization) {
          dracoAttributes[dracoAttribute.unique_id()].quantization_transform = quantization;
        }
        const octahedron = this._getOctahedronTransform(dracoAttribute, options);
        if (octahedron) {
          dracoAttributes[dracoAttribute.unique_id()].octahedron_transform = octahedron;
        }
      }
      return dracoAttributes;
    }
    _getMeshData(dracoGeometry, loaderData, options) {
      const attributes = this._getMeshAttributes(loaderData, dracoGeometry, options);
      const positionAttribute = attributes.POSITION;
      if (!positionAttribute) {
        throw new Error("DRACO: No position attribute found.");
      }
      if (dracoGeometry instanceof this.draco.Mesh) {
        switch (options.topology) {
          case "triangle-strip":
            return {
              topology: "triangle-strip",
              mode: 4,
              attributes,
              indices: {
                value: this._getTriangleStripIndices(dracoGeometry),
                size: 1
              }
            };
          case "triangle-list":
          default:
            return {
              topology: "triangle-list",
              mode: 5,
              attributes,
              indices: {
                value: this._getTriangleListIndices(dracoGeometry),
                size: 1
              }
            };
        }
      }
      return {
        topology: "point-list",
        mode: 0,
        attributes
      };
    }
    _getMeshAttributes(loaderData, dracoGeometry, options) {
      const attributes = {};
      for (const loaderAttribute of Object.values(loaderData.attributes)) {
        const attributeName = this._deduceAttributeName(loaderAttribute, options);
        loaderAttribute.name = attributeName;
        const {
          value,
          size
        } = this._getAttributeValues(dracoGeometry, loaderAttribute);
        attributes[attributeName] = {
          value,
          size,
          byteOffset: loaderAttribute.byte_offset,
          byteStride: loaderAttribute.byte_stride,
          normalized: loaderAttribute.normalized
        };
      }
      return attributes;
    }
    _getTriangleListIndices(dracoGeometry) {
      const numFaces = dracoGeometry.num_faces();
      const numIndices = numFaces * 3;
      const byteLength = numIndices * INDEX_ITEM_SIZE;
      const ptr = this.draco._malloc(byteLength);
      try {
        this.decoder.GetTrianglesUInt32Array(dracoGeometry, byteLength, ptr);
        return new Uint32Array(this.draco.HEAPF32.buffer, ptr, numIndices).slice();
      } finally {
        this.draco._free(ptr);
      }
    }
    _getTriangleStripIndices(dracoGeometry) {
      const dracoArray = new this.draco.DracoInt32Array();
      try {
        this.decoder.GetTriangleStripsFromMesh(dracoGeometry, dracoArray);
        return getUint32Array(dracoArray);
      } finally {
        this.draco.destroy(dracoArray);
      }
    }
    _getAttributeValues(dracoGeometry, attribute) {
      const TypedArrayCtor = DRACO_DATA_TYPE_TO_TYPED_ARRAY_MAP[attribute.data_type];
      const numComponents = attribute.num_components;
      const numPoints = dracoGeometry.num_points();
      const numValues = numPoints * numComponents;
      const byteLength = numValues * TypedArrayCtor.BYTES_PER_ELEMENT;
      const dataType = getDracoDataType(this.draco, TypedArrayCtor);
      let value;
      const ptr = this.draco._malloc(byteLength);
      try {
        const dracoAttribute = this.decoder.GetAttribute(dracoGeometry, attribute.attribute_index);
        this.decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, dracoAttribute, dataType, byteLength, ptr);
        value = new TypedArrayCtor(this.draco.HEAPF32.buffer, ptr, numValues).slice();
      } finally {
        this.draco._free(ptr);
      }
      return {
        value,
        size: numComponents
      };
    }
    _deduceAttributeName(attribute, options) {
      const uniqueId = attribute.unique_id;
      for (const [attributeName, attributeUniqueId] of Object.entries(options.extraAttributes || {})) {
        if (attributeUniqueId === uniqueId) {
          return attributeName;
        }
      }
      const thisAttributeType = attribute.attribute_type;
      for (const dracoAttributeConstant in DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP) {
        const attributeType = this.draco[dracoAttributeConstant];
        if (attributeType === thisAttributeType) {
          return DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP[dracoAttributeConstant];
        }
      }
      const entryName = options.attributeNameEntry || "name";
      if (attribute.metadata[entryName]) {
        return attribute.metadata[entryName].string;
      }
      return "CUSTOM_ATTRIBUTE_".concat(uniqueId);
    }
    _getTopLevelMetadata(dracoGeometry) {
      const dracoMetadata = this.decoder.GetMetadata(dracoGeometry);
      return this._getDracoMetadata(dracoMetadata);
    }
    _getAttributeMetadata(dracoGeometry, attributeId) {
      const dracoMetadata = this.decoder.GetAttributeMetadata(dracoGeometry, attributeId);
      return this._getDracoMetadata(dracoMetadata);
    }
    _getDracoMetadata(dracoMetadata) {
      if (!dracoMetadata || !dracoMetadata.ptr) {
        return {};
      }
      const result = {};
      const numEntries = this.metadataQuerier.NumEntries(dracoMetadata);
      for (let entryIndex = 0; entryIndex < numEntries; entryIndex++) {
        const entryName = this.metadataQuerier.GetEntryName(dracoMetadata, entryIndex);
        result[entryName] = this._getDracoMetadataField(dracoMetadata, entryName);
      }
      return result;
    }
    _getDracoMetadataField(dracoMetadata, entryName) {
      const dracoArray = new this.draco.DracoInt32Array();
      try {
        this.metadataQuerier.GetIntEntryArray(dracoMetadata, entryName, dracoArray);
        const intArray = getInt32Array(dracoArray);
        return {
          int: this.metadataQuerier.GetIntEntry(dracoMetadata, entryName),
          string: this.metadataQuerier.GetStringEntry(dracoMetadata, entryName),
          double: this.metadataQuerier.GetDoubleEntry(dracoMetadata, entryName),
          intArray
        };
      } finally {
        this.draco.destroy(dracoArray);
      }
    }
    _disableAttributeTransforms(options) {
      const {
        quantizedAttributes = [],
        octahedronAttributes = []
      } = options;
      const skipAttributes = [...quantizedAttributes, ...octahedronAttributes];
      for (const dracoAttributeName of skipAttributes) {
        this.decoder.SkipAttributeTransform(this.draco[dracoAttributeName]);
      }
    }
    _getQuantizationTransform(dracoAttribute, options) {
      const {
        quantizedAttributes = []
      } = options;
      const attribute_type = dracoAttribute.attribute_type();
      const skip = quantizedAttributes.map((type) => this.decoder[type]).includes(attribute_type);
      if (skip) {
        const transform = new this.draco.AttributeQuantizationTransform();
        try {
          if (transform.InitFromAttribute(dracoAttribute)) {
            return {
              quantization_bits: transform.quantization_bits(),
              range: transform.range(),
              min_values: new Float32Array([1, 2, 3]).map((i2) => transform.min_value(i2))
            };
          }
        } finally {
          this.draco.destroy(transform);
        }
      }
      return null;
    }
    _getOctahedronTransform(dracoAttribute, options) {
      const {
        octahedronAttributes = []
      } = options;
      const attribute_type = dracoAttribute.attribute_type();
      const octahedron = octahedronAttributes.map((type) => this.decoder[type]).includes(attribute_type);
      if (octahedron) {
        const transform = new this.draco.AttributeQuantizationTransform();
        try {
          if (transform.InitFromAttribute(dracoAttribute)) {
            return {
              quantization_bits: transform.quantization_bits()
            };
          }
        } finally {
          this.draco.destroy(transform);
        }
      }
      return null;
    }
  };
  function getDracoDataType(draco, attributeType) {
    switch (attributeType) {
      case Float32Array:
        return draco.DT_FLOAT32;
      case Int8Array:
        return draco.DT_INT8;
      case Int16Array:
        return draco.DT_INT16;
      case Int32Array:
        return draco.DT_INT32;
      case Uint8Array:
        return draco.DT_UINT8;
      case Uint16Array:
        return draco.DT_UINT16;
      case Uint32Array:
        return draco.DT_UINT32;
      default:
        return draco.DT_INVALID;
    }
  }
  function getInt32Array(dracoArray) {
    const numValues = dracoArray.size();
    const intArray = new Int32Array(numValues);
    for (let i2 = 0; i2 < numValues; i2++) {
      intArray[i2] = dracoArray.GetValue(i2);
    }
    return intArray;
  }
  function getUint32Array(dracoArray) {
    const numValues = dracoArray.size();
    const intArray = new Int32Array(numValues);
    for (let i2 = 0; i2 < numValues; i2++) {
      intArray[i2] = dracoArray.GetValue(i2);
    }
    return intArray;
  }

  // ../../node_modules/@loaders.gl/draco/dist/esm/lib/draco-module-loader.js
  var DRACO_DECODER_VERSION = "1.5.5";
  var DRACO_ENCODER_VERSION = "1.4.1";
  var STATIC_DECODER_URL = "https://www.gstatic.com/draco/versioned/decoders/".concat(DRACO_DECODER_VERSION);
  var DRACO_JS_DECODER_URL = "".concat(STATIC_DECODER_URL, "/draco_decoder.js");
  var DRACO_WASM_WRAPPER_URL = "".concat(STATIC_DECODER_URL, "/draco_wasm_wrapper.js");
  var DRACO_WASM_DECODER_URL = "".concat(STATIC_DECODER_URL, "/draco_decoder.wasm");
  var DRACO_ENCODER_URL = "https://raw.githubusercontent.com/google/draco/".concat(DRACO_ENCODER_VERSION, "/javascript/draco_encoder.js");
  var loadDecoderPromise;
  async function loadDracoDecoderModule(options) {
    const modules = options.modules || {};
    if (modules.draco3d) {
      loadDecoderPromise = loadDecoderPromise || modules.draco3d.createDecoderModule({}).then((draco) => {
        return {
          draco
        };
      });
    } else {
      loadDecoderPromise = loadDecoderPromise || loadDracoDecoder(options);
    }
    return await loadDecoderPromise;
  }
  async function loadDracoDecoder(options) {
    let DracoDecoderModule;
    let wasmBinary;
    switch (options.draco && options.draco.decoderType) {
      case "js":
        DracoDecoderModule = await loadLibrary(DRACO_JS_DECODER_URL, "draco", options);
        break;
      case "wasm":
      default:
        [DracoDecoderModule, wasmBinary] = await Promise.all([await loadLibrary(DRACO_WASM_WRAPPER_URL, "draco", options), await loadLibrary(DRACO_WASM_DECODER_URL, "draco", options)]);
    }
    DracoDecoderModule = DracoDecoderModule || globalThis.DracoDecoderModule;
    return await initializeDracoDecoder(DracoDecoderModule, wasmBinary);
  }
  function initializeDracoDecoder(DracoDecoderModule, wasmBinary) {
    const options = {};
    if (wasmBinary) {
      options.wasmBinary = wasmBinary;
    }
    return new Promise((resolve) => {
      DracoDecoderModule({
        ...options,
        onModuleLoaded: (draco) => resolve({
          draco
        })
      });
    });
  }

  // ../../node_modules/@loaders.gl/draco/dist/esm/index.js
  var DracoLoader2 = {
    ...DracoLoader,
    parse
  };
  async function parse(arrayBuffer2, options) {
    const {
      draco
    } = await loadDracoDecoderModule(options);
    const dracoParser = new DracoParser(draco);
    try {
      return dracoParser.parseSync(arrayBuffer2, options === null || options === void 0 ? void 0 : options.draco);
    } finally {
      dracoParser.destroy();
    }
  }

  // ../../node_modules/@loaders.gl/gltf/dist/esm/lib/gltf-utils/gltf-attribute-utils.js
  function getGLTFAccessors(attributes) {
    const accessors = {};
    for (const name10 in attributes) {
      const attribute = attributes[name10];
      if (name10 !== "indices") {
        const glTFAccessor = getGLTFAccessor(attribute);
        accessors[name10] = glTFAccessor;
      }
    }
    return accessors;
  }
  function getGLTFAccessor(attribute) {
    const {
      buffer,
      size,
      count
    } = getAccessorData(attribute);
    const glTFAccessor = {
      value: buffer,
      size,
      byteOffset: 0,
      count,
      type: getAccessorTypeFromSize(size),
      componentType: getComponentTypeFromArray(buffer)
    };
    return glTFAccessor;
  }
  function getAccessorData(attribute) {
    let buffer = attribute;
    let size = 1;
    let count = 0;
    if (attribute && attribute.value) {
      buffer = attribute.value;
      size = attribute.size || 1;
    }
    if (buffer) {
      if (!ArrayBuffer.isView(buffer)) {
        buffer = toTypedArray2(buffer, Float32Array);
      }
      count = buffer.length / size;
    }
    return {
      buffer,
      size,
      count
    };
  }
  function toTypedArray2(array, ArrayType) {
    let convertTypedArrays = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    if (!array) {
      return null;
    }
    if (Array.isArray(array)) {
      return new ArrayType(array);
    }
    if (convertTypedArrays && !(array instanceof ArrayType)) {
      return new ArrayType(array);
    }
    return array;
  }

  // ../../node_modules/@loaders.gl/gltf/dist/esm/lib/extensions/KHR_draco_mesh_compression.js
  var KHR_DRACO_MESH_COMPRESSION = "KHR_draco_mesh_compression";
  var name4 = KHR_DRACO_MESH_COMPRESSION;
  function preprocess3(gltfData, options, context) {
    const scenegraph = new GLTFScenegraph(gltfData);
    for (const primitive of makeMeshPrimitiveIterator(scenegraph)) {
      if (scenegraph.getObjectExtension(primitive, KHR_DRACO_MESH_COMPRESSION)) {
      }
    }
  }
  async function decode3(gltfData, options, context) {
    var _options$gltf;
    if (!(options !== null && options !== void 0 && (_options$gltf = options.gltf) !== null && _options$gltf !== void 0 && _options$gltf.decompressMeshes)) {
      return;
    }
    const scenegraph = new GLTFScenegraph(gltfData);
    const promises = [];
    for (const primitive of makeMeshPrimitiveIterator(scenegraph)) {
      if (scenegraph.getObjectExtension(primitive, KHR_DRACO_MESH_COMPRESSION)) {
        promises.push(decompressPrimitive(scenegraph, primitive, options, context));
      }
    }
    await Promise.all(promises);
    scenegraph.removeExtension(KHR_DRACO_MESH_COMPRESSION);
  }
  function encode(gltfData) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const scenegraph = new GLTFScenegraph(gltfData);
    for (const mesh of scenegraph.json.meshes || []) {
      compressMesh(mesh, options);
      scenegraph.addRequiredExtension(KHR_DRACO_MESH_COMPRESSION);
    }
  }
  async function decompressPrimitive(scenegraph, primitive, options, context) {
    const dracoExtension = scenegraph.getObjectExtension(primitive, KHR_DRACO_MESH_COMPRESSION);
    if (!dracoExtension) {
      return;
    }
    const buffer = scenegraph.getTypedArrayForBufferView(dracoExtension.bufferView);
    const bufferCopy = sliceArrayBuffer(buffer.buffer, buffer.byteOffset);
    const {
      parse: parse3
    } = context;
    const dracoOptions = {
      ...options
    };
    delete dracoOptions["3d-tiles"];
    const decodedData = await parse3(bufferCopy, DracoLoader2, dracoOptions, context);
    const decodedAttributes = getGLTFAccessors(decodedData.attributes);
    for (const [attributeName, decodedAttribute] of Object.entries(decodedAttributes)) {
      if (attributeName in primitive.attributes) {
        const accessorIndex = primitive.attributes[attributeName];
        const accessor = scenegraph.getAccessor(accessorIndex);
        if (accessor !== null && accessor !== void 0 && accessor.min && accessor !== null && accessor !== void 0 && accessor.max) {
          decodedAttribute.min = accessor.min;
          decodedAttribute.max = accessor.max;
        }
      }
    }
    primitive.attributes = decodedAttributes;
    if (decodedData.indices) {
      primitive.indices = getGLTFAccessor(decodedData.indices);
    }
    checkPrimitive(primitive);
  }
  function compressMesh(attributes, indices) {
    var _context$parseSync;
    let mode = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 4;
    let options = arguments.length > 3 ? arguments[3] : void 0;
    let context = arguments.length > 4 ? arguments[4] : void 0;
    if (!options.DracoWriter) {
      throw new Error("options.gltf.DracoWriter not provided");
    }
    const compressedData = options.DracoWriter.encodeSync({
      attributes
    });
    const decodedData = context === null || context === void 0 ? void 0 : (_context$parseSync = context.parseSync) === null || _context$parseSync === void 0 ? void 0 : _context$parseSync.call(context, {
      attributes
    });
    const fauxAccessors = options._addFauxAttributes(decodedData.attributes);
    const bufferViewIndex = options.addBufferView(compressedData);
    const glTFMesh = {
      primitives: [{
        attributes: fauxAccessors,
        mode,
        extensions: {
          [KHR_DRACO_MESH_COMPRESSION]: {
            bufferView: bufferViewIndex,
            attributes: fauxAccessors
          }
        }
      }]
    };
    return glTFMesh;
  }
  function checkPrimitive(primitive) {
    if (!primitive.attributes && Object.keys(primitive.attributes).length > 0) {
      throw new Error("glTF: Empty primitive detected: Draco decompression failure?");
    }
  }
  function* makeMeshPrimitiveIterator(scenegraph) {
    for (const mesh of scenegraph.json.meshes || []) {
      for (const primitive of mesh.primitives) {
        yield primitive;
      }
    }
  }

  // ../../node_modules/@loaders.gl/gltf/dist/esm/lib/extensions/KHR_texture_transform.js
  var KHR_texture_transform_exports = {};
  __export(KHR_texture_transform_exports, {
    decode: () => decode4,
    name: () => name5
  });

  // ../../node_modules/@loaders.gl/gltf/dist/esm/lib/gltf-utils/gltf-constants.js
  var COMPONENTS = {
    SCALAR: 1,
    VEC2: 2,
    VEC3: 3,
    VEC4: 4,
    MAT2: 4,
    MAT3: 9,
    MAT4: 16
  };
  var BYTES = {
    5120: 1,
    5121: 1,
    5122: 2,
    5123: 2,
    5125: 4,
    5126: 4
  };

  // ../../node_modules/@loaders.gl/gltf/dist/esm/lib/extensions/KHR_texture_transform.js
  var EXT_MESHOPT_TRANSFORM = "KHR_texture_transform";
  var name5 = EXT_MESHOPT_TRANSFORM;
  var scratchVector = new Vector3();
  var scratchRotationMatrix = new Matrix3();
  var scratchScaleMatrix = new Matrix3();
  async function decode4(gltfData, options) {
    const gltfScenegraph = new GLTFScenegraph(gltfData);
    const extension = gltfScenegraph.getExtension(EXT_MESHOPT_TRANSFORM);
    if (!extension) {
      return;
    }
    const materials = gltfData.json.materials || [];
    for (let i2 = 0; i2 < materials.length; i2++) {
      transformTexCoords(i2, gltfData);
    }
  }
  function transformTexCoords(materialIndex, gltfData) {
    var _gltfData$json$materi, _material$pbrMetallic, _material$pbrMetallic2;
    const processedTexCoords = [];
    const material = (_gltfData$json$materi = gltfData.json.materials) === null || _gltfData$json$materi === void 0 ? void 0 : _gltfData$json$materi[materialIndex];
    const baseColorTexture = material === null || material === void 0 ? void 0 : (_material$pbrMetallic = material.pbrMetallicRoughness) === null || _material$pbrMetallic === void 0 ? void 0 : _material$pbrMetallic.baseColorTexture;
    if (baseColorTexture) {
      transformPrimitives(gltfData, materialIndex, baseColorTexture, processedTexCoords);
    }
    const emisiveTexture = material === null || material === void 0 ? void 0 : material.emissiveTexture;
    if (emisiveTexture) {
      transformPrimitives(gltfData, materialIndex, emisiveTexture, processedTexCoords);
    }
    const normalTexture = material === null || material === void 0 ? void 0 : material.normalTexture;
    if (normalTexture) {
      transformPrimitives(gltfData, materialIndex, normalTexture, processedTexCoords);
    }
    const occlusionTexture = material === null || material === void 0 ? void 0 : material.occlusionTexture;
    if (occlusionTexture) {
      transformPrimitives(gltfData, materialIndex, occlusionTexture, processedTexCoords);
    }
    const metallicRoughnessTexture = material === null || material === void 0 ? void 0 : (_material$pbrMetallic2 = material.pbrMetallicRoughness) === null || _material$pbrMetallic2 === void 0 ? void 0 : _material$pbrMetallic2.metallicRoughnessTexture;
    if (metallicRoughnessTexture) {
      transformPrimitives(gltfData, materialIndex, metallicRoughnessTexture, processedTexCoords);
    }
  }
  function transformPrimitives(gltfData, materialIndex, texture, processedTexCoords) {
    const transformParameters = getTransformParameters(texture, processedTexCoords);
    if (!transformParameters) {
      return;
    }
    const meshes = gltfData.json.meshes || [];
    for (const mesh of meshes) {
      for (const primitive of mesh.primitives) {
        const material = primitive.material;
        if (Number.isFinite(material) && materialIndex === material) {
          transformPrimitive(gltfData, primitive, transformParameters);
        }
      }
    }
  }
  function getTransformParameters(texture, processedTexCoords) {
    var _texture$extensions;
    const textureInfo = (_texture$extensions = texture.extensions) === null || _texture$extensions === void 0 ? void 0 : _texture$extensions[EXT_MESHOPT_TRANSFORM];
    const {
      texCoord: originalTexCoord = 0
    } = texture;
    const {
      texCoord = originalTexCoord
    } = textureInfo;
    const isProcessed = processedTexCoords.findIndex((_ref) => {
      let [original, newTexCoord] = _ref;
      return original === originalTexCoord && newTexCoord === texCoord;
    }) !== -1;
    if (!isProcessed) {
      const matrix = makeTransformationMatrix(textureInfo);
      if (originalTexCoord !== texCoord) {
        texture.texCoord = texCoord;
      }
      processedTexCoords.push([originalTexCoord, texCoord]);
      return {
        originalTexCoord,
        texCoord,
        matrix
      };
    }
    return null;
  }
  function transformPrimitive(gltfData, primitive, transformParameters) {
    const {
      originalTexCoord,
      texCoord,
      matrix
    } = transformParameters;
    const texCoordAccessor = primitive.attributes["TEXCOORD_".concat(originalTexCoord)];
    if (Number.isFinite(texCoordAccessor)) {
      var _gltfData$json$access;
      const accessor = (_gltfData$json$access = gltfData.json.accessors) === null || _gltfData$json$access === void 0 ? void 0 : _gltfData$json$access[texCoordAccessor];
      if (accessor && accessor.bufferView) {
        var _gltfData$json$buffer;
        const bufferView = (_gltfData$json$buffer = gltfData.json.bufferViews) === null || _gltfData$json$buffer === void 0 ? void 0 : _gltfData$json$buffer[accessor.bufferView];
        if (bufferView) {
          const {
            arrayBuffer: arrayBuffer2,
            byteOffset: bufferByteOffset
          } = gltfData.buffers[bufferView.buffer];
          const byteOffset = (bufferByteOffset || 0) + (accessor.byteOffset || 0) + (bufferView.byteOffset || 0);
          const {
            ArrayType,
            length: length4
          } = getAccessorArrayTypeAndLength(accessor, bufferView);
          const bytes = BYTES[accessor.componentType];
          const components = COMPONENTS[accessor.type];
          const elementAddressScale = bufferView.byteStride || bytes * components;
          const result = new Float32Array(length4);
          for (let i2 = 0; i2 < accessor.count; i2++) {
            const uv = new ArrayType(arrayBuffer2, byteOffset + i2 * elementAddressScale, 2);
            scratchVector.set(uv[0], uv[1], 1);
            scratchVector.transformByMatrix3(matrix);
            result.set([scratchVector[0], scratchVector[1]], i2 * components);
          }
          if (originalTexCoord === texCoord) {
            updateGltf(accessor, bufferView, gltfData.buffers, result);
          } else {
            createAttribute(texCoord, accessor, primitive, gltfData, result);
          }
        }
      }
    }
  }
  function updateGltf(accessor, bufferView, buffers, newTexCoordArray) {
    accessor.componentType = 5126;
    buffers.push({
      arrayBuffer: newTexCoordArray.buffer,
      byteOffset: 0,
      byteLength: newTexCoordArray.buffer.byteLength
    });
    bufferView.buffer = buffers.length - 1;
    bufferView.byteLength = newTexCoordArray.buffer.byteLength;
    bufferView.byteOffset = 0;
    delete bufferView.byteStride;
  }
  function createAttribute(newTexCoord, originalAccessor, primitive, gltfData, newTexCoordArray) {
    gltfData.buffers.push({
      arrayBuffer: newTexCoordArray.buffer,
      byteOffset: 0,
      byteLength: newTexCoordArray.buffer.byteLength
    });
    const bufferViews = gltfData.json.bufferViews;
    if (!bufferViews) {
      return;
    }
    bufferViews.push({
      buffer: gltfData.buffers.length - 1,
      byteLength: newTexCoordArray.buffer.byteLength,
      byteOffset: 0
    });
    const accessors = gltfData.json.accessors;
    if (!accessors) {
      return;
    }
    accessors.push({
      bufferView: (bufferViews === null || bufferViews === void 0 ? void 0 : bufferViews.length) - 1,
      byteOffset: 0,
      componentType: 5126,
      count: originalAccessor.count,
      type: "VEC2"
    });
    primitive.attributes["TEXCOORD_".concat(newTexCoord)] = accessors.length - 1;
  }
  function makeTransformationMatrix(extensionData) {
    const {
      offset = [0, 0],
      rotation = 0,
      scale: scale5 = [1, 1]
    } = extensionData;
    const translationMatirx = new Matrix3().set(1, 0, 0, 0, 1, 0, offset[0], offset[1], 1);
    const rotationMatirx = scratchRotationMatrix.set(Math.cos(rotation), Math.sin(rotation), 0, -Math.sin(rotation), Math.cos(rotation), 0, 0, 0, 1);
    const scaleMatrix = scratchScaleMatrix.set(scale5[0], 0, 0, 0, scale5[1], 0, 0, 0, 1);
    return translationMatirx.multiplyRight(rotationMatirx).multiplyRight(scaleMatrix);
  }

  // ../../node_modules/@loaders.gl/gltf/dist/esm/lib/extensions/deprecated/KHR_lights_punctual.js
  var KHR_lights_punctual_exports = {};
  __export(KHR_lights_punctual_exports, {
    decode: () => decode5,
    encode: () => encode2,
    name: () => name6
  });
  var KHR_LIGHTS_PUNCTUAL = "KHR_lights_punctual";
  var name6 = KHR_LIGHTS_PUNCTUAL;
  async function decode5(gltfData) {
    const gltfScenegraph = new GLTFScenegraph(gltfData);
    const {
      json
    } = gltfScenegraph;
    const extension = gltfScenegraph.getExtension(KHR_LIGHTS_PUNCTUAL);
    if (extension) {
      gltfScenegraph.json.lights = extension.lights;
      gltfScenegraph.removeExtension(KHR_LIGHTS_PUNCTUAL);
    }
    for (const node2 of json.nodes || []) {
      const nodeExtension = gltfScenegraph.getObjectExtension(node2, KHR_LIGHTS_PUNCTUAL);
      if (nodeExtension) {
        node2.light = nodeExtension.light;
      }
      gltfScenegraph.removeObjectExtension(node2, KHR_LIGHTS_PUNCTUAL);
    }
  }
  async function encode2(gltfData) {
    const gltfScenegraph = new GLTFScenegraph(gltfData);
    const {
      json
    } = gltfScenegraph;
    if (json.lights) {
      const extension = gltfScenegraph.addExtension(KHR_LIGHTS_PUNCTUAL);
      assert9(!extension.lights);
      extension.lights = json.lights;
      delete json.lights;
    }
    if (gltfScenegraph.json.lights) {
      for (const light of gltfScenegraph.json.lights) {
        const node2 = light.node;
        gltfScenegraph.addObjectExtension(node2, KHR_LIGHTS_PUNCTUAL, light);
      }
      delete gltfScenegraph.json.lights;
    }
  }

  // ../../node_modules/@loaders.gl/gltf/dist/esm/lib/extensions/deprecated/KHR_materials_unlit.js
  var KHR_materials_unlit_exports = {};
  __export(KHR_materials_unlit_exports, {
    decode: () => decode6,
    encode: () => encode3,
    name: () => name7
  });
  var KHR_MATERIALS_UNLIT = "KHR_materials_unlit";
  var name7 = KHR_MATERIALS_UNLIT;
  async function decode6(gltfData) {
    const gltfScenegraph = new GLTFScenegraph(gltfData);
    const {
      json
    } = gltfScenegraph;
    for (const material of json.materials || []) {
      const extension = material.extensions && material.extensions.KHR_materials_unlit;
      if (extension) {
        material.unlit = true;
      }
      gltfScenegraph.removeObjectExtension(material, KHR_MATERIALS_UNLIT);
    }
    gltfScenegraph.removeExtension(KHR_MATERIALS_UNLIT);
  }
  function encode3(gltfData) {
    const gltfScenegraph = new GLTFScenegraph(gltfData);
    const {
      json
    } = gltfScenegraph;
    if (gltfScenegraph.materials) {
      for (const material of json.materials || []) {
        if (material.unlit) {
          delete material.unlit;
          gltfScenegraph.addObjectExtension(material, KHR_MATERIALS_UNLIT, {});
          gltfScenegraph.addExtension(KHR_MATERIALS_UNLIT);
        }
      }
    }
  }

  // ../../node_modules/@loaders.gl/gltf/dist/esm/lib/extensions/deprecated/KHR_techniques_webgl.js
  var KHR_techniques_webgl_exports = {};
  __export(KHR_techniques_webgl_exports, {
    decode: () => decode7,
    encode: () => encode4,
    name: () => name8
  });
  var KHR_TECHNIQUES_WEBGL = "KHR_techniques_webgl";
  var name8 = KHR_TECHNIQUES_WEBGL;
  async function decode7(gltfData) {
    const gltfScenegraph = new GLTFScenegraph(gltfData);
    const {
      json
    } = gltfScenegraph;
    const extension = gltfScenegraph.getExtension(KHR_TECHNIQUES_WEBGL);
    if (extension) {
      const techniques = resolveTechniques(extension, gltfScenegraph);
      for (const material of json.materials || []) {
        const materialExtension = gltfScenegraph.getObjectExtension(material, KHR_TECHNIQUES_WEBGL);
        if (materialExtension) {
          material.technique = Object.assign(
            {},
            materialExtension,
            techniques[materialExtension.technique]
          );
          material.technique.values = resolveValues(material.technique, gltfScenegraph);
        }
        gltfScenegraph.removeObjectExtension(material, KHR_TECHNIQUES_WEBGL);
      }
      gltfScenegraph.removeExtension(KHR_TECHNIQUES_WEBGL);
    }
  }
  async function encode4(gltfData, options) {
  }
  function resolveTechniques(techniquesExtension, gltfScenegraph) {
    const {
      programs = [],
      shaders = [],
      techniques = []
    } = techniquesExtension;
    const textDecoder = new TextDecoder();
    shaders.forEach((shader) => {
      if (Number.isFinite(shader.bufferView)) {
        shader.code = textDecoder.decode(gltfScenegraph.getTypedArrayForBufferView(shader.bufferView));
      } else {
        throw new Error("KHR_techniques_webgl: no shader code");
      }
    });
    programs.forEach((program) => {
      program.fragmentShader = shaders[program.fragmentShader];
      program.vertexShader = shaders[program.vertexShader];
    });
    techniques.forEach((technique) => {
      technique.program = programs[technique.program];
    });
    return techniques;
  }
  function resolveValues(technique, gltfScenegraph) {
    const values = Object.assign({}, technique.values);
    Object.keys(technique.uniforms || {}).forEach((uniform) => {
      if (technique.uniforms[uniform].value && !(uniform in values)) {
        values[uniform] = technique.uniforms[uniform].value;
      }
    });
    Object.keys(values).forEach((uniform) => {
      if (typeof values[uniform] === "object" && values[uniform].index !== void 0) {
        values[uniform].texture = gltfScenegraph.getTexture(values[uniform].index);
      }
    });
    return values;
  }

  // ../../node_modules/@loaders.gl/gltf/dist/esm/lib/extensions/deprecated/EXT_feature_metadata.js
  var EXT_feature_metadata_exports = {};
  __export(EXT_feature_metadata_exports, {
    decode: () => decode8,
    name: () => name9
  });
  var EXT_FEATURE_METADATA = "EXT_feature_metadata";
  var name9 = EXT_FEATURE_METADATA;
  async function decode8(gltfData) {
    const scenegraph = new GLTFScenegraph(gltfData);
    decodeExtFeatureMetadata(scenegraph);
  }
  function decodeExtFeatureMetadata(scenegraph) {
    var _extension$schema;
    const extension = scenegraph.getExtension(EXT_FEATURE_METADATA);
    const schemaClasses = extension === null || extension === void 0 ? void 0 : (_extension$schema = extension.schema) === null || _extension$schema === void 0 ? void 0 : _extension$schema.classes;
    const featureTables = extension === null || extension === void 0 ? void 0 : extension.featureTables;
    const featureTextures = extension === null || extension === void 0 ? void 0 : extension.featureTextures;
    if (featureTextures) {
      console.warn('featureTextures is not yet supported in the "EXT_feature_metadata" extension.');
    }
    if (schemaClasses && featureTables) {
      for (const schemaName in schemaClasses) {
        const schemaClass = schemaClasses[schemaName];
        const featureTable = findFeatureTableByName(featureTables, schemaName);
        if (featureTable) {
          handleFeatureTableProperties(scenegraph, featureTable, schemaClass);
        }
      }
    }
  }
  function handleFeatureTableProperties(scenegraph, featureTable, schemaClass) {
    for (const propertyName in schemaClass.properties) {
      var _featureTable$propert;
      const schemaProperty = schemaClass.properties[propertyName];
      const featureTableProperty = featureTable === null || featureTable === void 0 ? void 0 : (_featureTable$propert = featureTable.properties) === null || _featureTable$propert === void 0 ? void 0 : _featureTable$propert[propertyName];
      const numberOfFeatures = featureTable.count;
      if (featureTableProperty) {
        const data = getPropertyDataFromBinarySource(scenegraph, schemaProperty, numberOfFeatures, featureTableProperty);
        featureTableProperty.data = data;
      }
    }
  }
  function getPropertyDataFromBinarySource(scenegraph, schemaProperty, numberOfFeatures, featureTableProperty) {
    const bufferView = featureTableProperty.bufferView;
    let data = scenegraph.getTypedArrayForBufferView(bufferView);
    switch (schemaProperty.type) {
      case "STRING": {
        const stringOffsetBufferView = featureTableProperty.stringOffsetBufferView;
        const offsetsData = scenegraph.getTypedArrayForBufferView(stringOffsetBufferView);
        data = getStringAttributes(data, offsetsData, numberOfFeatures);
        break;
      }
      default:
    }
    return data;
  }
  function findFeatureTableByName(featureTables, schemaClassName) {
    for (const featureTableName in featureTables) {
      const featureTable = featureTables[featureTableName];
      if (featureTable.class === schemaClassName) {
        return featureTable;
      }
    }
    return null;
  }
  function getStringAttributes(data, offsetsData, stringsCount) {
    const stringsArray = [];
    const textDecoder = new TextDecoder("utf8");
    let stringOffset = 0;
    const bytesPerStringSize = 4;
    for (let index = 0; index < stringsCount; index++) {
      const stringByteSize = offsetsData[(index + 1) * bytesPerStringSize] - offsetsData[index * bytesPerStringSize];
      const stringData = data.subarray(stringOffset, stringByteSize + stringOffset);
      const stringAttribute = textDecoder.decode(stringData);
      stringsArray.push(stringAttribute);
      stringOffset += stringByteSize;
    }
    return stringsArray;
  }

  // ../../node_modules/@loaders.gl/gltf/dist/esm/lib/api/gltf-extensions.js
  var EXTENSIONS2 = [
    EXT_meshopt_compression_exports,
    EXT_texture_webp_exports,
    KHR_texture_basisu_exports,
    KHR_draco_mesh_compression_exports,
    KHR_lights_punctual_exports,
    KHR_materials_unlit_exports,
    KHR_techniques_webgl_exports,
    KHR_texture_transform_exports,
    EXT_feature_metadata_exports
  ];
  function preprocessExtensions(gltf) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    let context = arguments.length > 2 ? arguments[2] : void 0;
    const extensions = EXTENSIONS2.filter((extension) => useExtension(extension.name, options));
    for (const extension of extensions) {
      var _extension$preprocess;
      (_extension$preprocess = extension.preprocess) === null || _extension$preprocess === void 0 ? void 0 : _extension$preprocess.call(extension, gltf, options, context);
    }
  }
  async function decodeExtensions(gltf) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    let context = arguments.length > 2 ? arguments[2] : void 0;
    const extensions = EXTENSIONS2.filter((extension) => useExtension(extension.name, options));
    for (const extension of extensions) {
      var _extension$decode;
      await ((_extension$decode = extension.decode) === null || _extension$decode === void 0 ? void 0 : _extension$decode.call(extension, gltf, options, context));
    }
  }
  function useExtension(extensionName, options) {
    var _options$gltf;
    const excludes = (options === null || options === void 0 ? void 0 : (_options$gltf = options.gltf) === null || _options$gltf === void 0 ? void 0 : _options$gltf.excludeExtensions) || {};
    const exclude = extensionName in excludes && !excludes[extensionName];
    return !exclude;
  }

  // ../../node_modules/@loaders.gl/gltf/dist/esm/lib/extensions/KHR_binary_gltf.js
  var KHR_BINARY_GLTF = "KHR_binary_glTF";
  function preprocess4(gltfData) {
    const gltfScenegraph = new GLTFScenegraph(gltfData);
    const {
      json
    } = gltfScenegraph;
    for (const image of json.images || []) {
      const extension = gltfScenegraph.getObjectExtension(image, KHR_BINARY_GLTF);
      if (extension) {
        Object.assign(image, extension);
      }
      gltfScenegraph.removeObjectExtension(image, KHR_BINARY_GLTF);
    }
    if (json.buffers && json.buffers[0]) {
      delete json.buffers[0].uri;
    }
    gltfScenegraph.removeExtension(KHR_BINARY_GLTF);
  }

  // ../../node_modules/@loaders.gl/gltf/dist/esm/lib/api/normalize-gltf-v1.js
  var GLTF_ARRAYS = {
    accessors: "accessor",
    animations: "animation",
    buffers: "buffer",
    bufferViews: "bufferView",
    images: "image",
    materials: "material",
    meshes: "mesh",
    nodes: "node",
    samplers: "sampler",
    scenes: "scene",
    skins: "skin",
    textures: "texture"
  };
  var GLTF_KEYS = {
    accessor: "accessors",
    animations: "animation",
    buffer: "buffers",
    bufferView: "bufferViews",
    image: "images",
    material: "materials",
    mesh: "meshes",
    node: "nodes",
    sampler: "samplers",
    scene: "scenes",
    skin: "skins",
    texture: "textures"
  };
  var GLTFV1Normalizer = class {
    constructor() {
      _defineProperty(this, "idToIndexMap", {
        animations: {},
        accessors: {},
        buffers: {},
        bufferViews: {},
        images: {},
        materials: {},
        meshes: {},
        nodes: {},
        samplers: {},
        scenes: {},
        skins: {},
        textures: {}
      });
      _defineProperty(this, "json", void 0);
    }
    normalize(gltf, options) {
      this.json = gltf.json;
      const json = gltf.json;
      switch (json.asset && json.asset.version) {
        case "2.0":
          return;
        case void 0:
        case "1.0":
          break;
        default:
          console.warn("glTF: Unknown version ".concat(json.asset.version));
          return;
      }
      if (!options.normalize) {
        throw new Error("glTF v1 is not supported.");
      }
      console.warn("Converting glTF v1 to glTF v2 format. This is experimental and may fail.");
      this._addAsset(json);
      this._convertTopLevelObjectsToArrays(json);
      preprocess4(gltf);
      this._convertObjectIdsToArrayIndices(json);
      this._updateObjects(json);
      this._updateMaterial(json);
    }
    _addAsset(json) {
      json.asset = json.asset || {};
      json.asset.version = "2.0";
      json.asset.generator = json.asset.generator || "Normalized to glTF 2.0 by loaders.gl";
    }
    _convertTopLevelObjectsToArrays(json) {
      for (const arrayName in GLTF_ARRAYS) {
        this._convertTopLevelObjectToArray(json, arrayName);
      }
    }
    _convertTopLevelObjectToArray(json, mapName) {
      const objectMap = json[mapName];
      if (!objectMap || Array.isArray(objectMap)) {
        return;
      }
      json[mapName] = [];
      for (const id in objectMap) {
        const object = objectMap[id];
        object.id = object.id || id;
        const index = json[mapName].length;
        json[mapName].push(object);
        this.idToIndexMap[mapName][id] = index;
      }
    }
    _convertObjectIdsToArrayIndices(json) {
      for (const arrayName in GLTF_ARRAYS) {
        this._convertIdsToIndices(json, arrayName);
      }
      if ("scene" in json) {
        json.scene = this._convertIdToIndex(json.scene, "scene");
      }
      for (const texture of json.textures) {
        this._convertTextureIds(texture);
      }
      for (const mesh of json.meshes) {
        this._convertMeshIds(mesh);
      }
      for (const node2 of json.nodes) {
        this._convertNodeIds(node2);
      }
      for (const node2 of json.scenes) {
        this._convertSceneIds(node2);
      }
    }
    _convertTextureIds(texture) {
      if (texture.source) {
        texture.source = this._convertIdToIndex(texture.source, "image");
      }
    }
    _convertMeshIds(mesh) {
      for (const primitive of mesh.primitives) {
        const {
          attributes,
          indices,
          material
        } = primitive;
        for (const attributeName in attributes) {
          attributes[attributeName] = this._convertIdToIndex(attributes[attributeName], "accessor");
        }
        if (indices) {
          primitive.indices = this._convertIdToIndex(indices, "accessor");
        }
        if (material) {
          primitive.material = this._convertIdToIndex(material, "material");
        }
      }
    }
    _convertNodeIds(node2) {
      if (node2.children) {
        node2.children = node2.children.map((child) => this._convertIdToIndex(child, "node"));
      }
      if (node2.meshes) {
        node2.meshes = node2.meshes.map((mesh) => this._convertIdToIndex(mesh, "mesh"));
      }
    }
    _convertSceneIds(scene) {
      if (scene.nodes) {
        scene.nodes = scene.nodes.map((node2) => this._convertIdToIndex(node2, "node"));
      }
    }
    _convertIdsToIndices(json, topLevelArrayName) {
      if (!json[topLevelArrayName]) {
        console.warn("gltf v1: json doesn't contain attribute ".concat(topLevelArrayName));
        json[topLevelArrayName] = [];
      }
      for (const object of json[topLevelArrayName]) {
        for (const key in object) {
          const id = object[key];
          const index = this._convertIdToIndex(id, key);
          object[key] = index;
        }
      }
    }
    _convertIdToIndex(id, key) {
      const arrayName = GLTF_KEYS[key];
      if (arrayName in this.idToIndexMap) {
        const index = this.idToIndexMap[arrayName][id];
        if (!Number.isFinite(index)) {
          throw new Error("gltf v1: failed to resolve ".concat(key, " with id ").concat(id));
        }
        return index;
      }
      return id;
    }
    _updateObjects(json) {
      for (const buffer of this.json.buffers) {
        delete buffer.type;
      }
    }
    _updateMaterial(json) {
      for (const material of json.materials) {
        var _material$values, _material$values2, _material$values3;
        material.pbrMetallicRoughness = {
          baseColorFactor: [1, 1, 1, 1],
          metallicFactor: 1,
          roughnessFactor: 1
        };
        const textureId = ((_material$values = material.values) === null || _material$values === void 0 ? void 0 : _material$values.tex) || ((_material$values2 = material.values) === null || _material$values2 === void 0 ? void 0 : _material$values2.texture2d_0) || ((_material$values3 = material.values) === null || _material$values3 === void 0 ? void 0 : _material$values3.diffuseTex);
        const textureIndex = json.textures.findIndex((texture) => texture.id === textureId);
        if (textureIndex !== -1) {
          material.pbrMetallicRoughness.baseColorTexture = {
            index: textureIndex
          };
        }
      }
    }
  };
  function normalizeGLTFV1(gltf) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return new GLTFV1Normalizer().normalize(gltf, options);
  }

  // ../../node_modules/@loaders.gl/gltf/dist/esm/lib/api/post-process-gltf.js
  var COMPONENTS2 = {
    SCALAR: 1,
    VEC2: 2,
    VEC3: 3,
    VEC4: 4,
    MAT2: 4,
    MAT3: 9,
    MAT4: 16
  };
  var BYTES2 = {
    5120: 1,
    5121: 1,
    5122: 2,
    5123: 2,
    5125: 4,
    5126: 4
  };
  var GL_SAMPLER = {
    TEXTURE_MAG_FILTER: 10240,
    TEXTURE_MIN_FILTER: 10241,
    TEXTURE_WRAP_S: 10242,
    TEXTURE_WRAP_T: 10243,
    REPEAT: 10497,
    LINEAR: 9729,
    NEAREST_MIPMAP_LINEAR: 9986
  };
  var SAMPLER_PARAMETER_GLTF_TO_GL = {
    magFilter: GL_SAMPLER.TEXTURE_MAG_FILTER,
    minFilter: GL_SAMPLER.TEXTURE_MIN_FILTER,
    wrapS: GL_SAMPLER.TEXTURE_WRAP_S,
    wrapT: GL_SAMPLER.TEXTURE_WRAP_T
  };
  var DEFAULT_SAMPLER = {
    [GL_SAMPLER.TEXTURE_MAG_FILTER]: GL_SAMPLER.LINEAR,
    [GL_SAMPLER.TEXTURE_MIN_FILTER]: GL_SAMPLER.NEAREST_MIPMAP_LINEAR,
    [GL_SAMPLER.TEXTURE_WRAP_S]: GL_SAMPLER.REPEAT,
    [GL_SAMPLER.TEXTURE_WRAP_T]: GL_SAMPLER.REPEAT
  };
  function getBytesFromComponentType(componentType) {
    return BYTES2[componentType];
  }
  function getSizeFromAccessorType(type) {
    return COMPONENTS2[type];
  }
  var GLTFPostProcessor = class {
    constructor() {
      _defineProperty(this, "baseUri", "");
      _defineProperty(this, "json", {});
      _defineProperty(this, "buffers", []);
      _defineProperty(this, "images", []);
    }
    postProcess(gltf) {
      let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      const {
        json,
        buffers = [],
        images = [],
        baseUri = ""
      } = gltf;
      assert9(json);
      this.baseUri = baseUri;
      this.json = json;
      this.buffers = buffers;
      this.images = images;
      this._resolveTree(this.json, options);
      return this.json;
    }
    _resolveTree(json) {
      let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (json.bufferViews) {
        json.bufferViews = json.bufferViews.map((bufView, i2) => this._resolveBufferView(bufView, i2));
      }
      if (json.images) {
        json.images = json.images.map((image, i2) => this._resolveImage(image, i2));
      }
      if (json.samplers) {
        json.samplers = json.samplers.map((sampler, i2) => this._resolveSampler(sampler, i2));
      }
      if (json.textures) {
        json.textures = json.textures.map((texture, i2) => this._resolveTexture(texture, i2));
      }
      if (json.accessors) {
        json.accessors = json.accessors.map((accessor, i2) => this._resolveAccessor(accessor, i2));
      }
      if (json.materials) {
        json.materials = json.materials.map((material, i2) => this._resolveMaterial(material, i2));
      }
      if (json.meshes) {
        json.meshes = json.meshes.map((mesh, i2) => this._resolveMesh(mesh, i2));
      }
      if (json.nodes) {
        json.nodes = json.nodes.map((node2, i2) => this._resolveNode(node2, i2));
      }
      if (json.skins) {
        json.skins = json.skins.map((skin, i2) => this._resolveSkin(skin, i2));
      }
      if (json.scenes) {
        json.scenes = json.scenes.map((scene, i2) => this._resolveScene(scene, i2));
      }
      if (json.scene !== void 0) {
        json.scene = json.scenes[this.json.scene];
      }
    }
    getScene(index) {
      return this._get("scenes", index);
    }
    getNode(index) {
      return this._get("nodes", index);
    }
    getSkin(index) {
      return this._get("skins", index);
    }
    getMesh(index) {
      return this._get("meshes", index);
    }
    getMaterial(index) {
      return this._get("materials", index);
    }
    getAccessor(index) {
      return this._get("accessors", index);
    }
    getCamera(index) {
      return null;
    }
    getTexture(index) {
      return this._get("textures", index);
    }
    getSampler(index) {
      return this._get("samplers", index);
    }
    getImage(index) {
      return this._get("images", index);
    }
    getBufferView(index) {
      return this._get("bufferViews", index);
    }
    getBuffer(index) {
      return this._get("buffers", index);
    }
    _get(array, index) {
      if (typeof index === "object") {
        return index;
      }
      const object = this.json[array] && this.json[array][index];
      if (!object) {
        console.warn("glTF file error: Could not find ".concat(array, "[").concat(index, "]"));
      }
      return object;
    }
    _resolveScene(scene, index) {
      scene.id = scene.id || "scene-".concat(index);
      scene.nodes = (scene.nodes || []).map((node2) => this.getNode(node2));
      return scene;
    }
    _resolveNode(node2, index) {
      node2.id = node2.id || "node-".concat(index);
      if (node2.children) {
        node2.children = node2.children.map((child) => this.getNode(child));
      }
      if (node2.mesh !== void 0) {
        node2.mesh = this.getMesh(node2.mesh);
      } else if (node2.meshes !== void 0 && node2.meshes.length) {
        node2.mesh = node2.meshes.reduce((accum, meshIndex) => {
          const mesh = this.getMesh(meshIndex);
          accum.id = mesh.id;
          accum.primitives = accum.primitives.concat(mesh.primitives);
          return accum;
        }, {
          primitives: []
        });
      }
      if (node2.camera !== void 0) {
        node2.camera = this.getCamera(node2.camera);
      }
      if (node2.skin !== void 0) {
        node2.skin = this.getSkin(node2.skin);
      }
      return node2;
    }
    _resolveSkin(skin, index) {
      skin.id = skin.id || "skin-".concat(index);
      skin.inverseBindMatrices = this.getAccessor(skin.inverseBindMatrices);
      return skin;
    }
    _resolveMesh(mesh, index) {
      mesh.id = mesh.id || "mesh-".concat(index);
      if (mesh.primitives) {
        mesh.primitives = mesh.primitives.map((primitive) => {
          primitive = {
            ...primitive
          };
          const attributes = primitive.attributes;
          primitive.attributes = {};
          for (const attribute in attributes) {
            primitive.attributes[attribute] = this.getAccessor(attributes[attribute]);
          }
          if (primitive.indices !== void 0) {
            primitive.indices = this.getAccessor(primitive.indices);
          }
          if (primitive.material !== void 0) {
            primitive.material = this.getMaterial(primitive.material);
          }
          return primitive;
        });
      }
      return mesh;
    }
    _resolveMaterial(material, index) {
      material.id = material.id || "material-".concat(index);
      if (material.normalTexture) {
        material.normalTexture = {
          ...material.normalTexture
        };
        material.normalTexture.texture = this.getTexture(material.normalTexture.index);
      }
      if (material.occlusionTexture) {
        material.occlustionTexture = {
          ...material.occlustionTexture
        };
        material.occlusionTexture.texture = this.getTexture(material.occlusionTexture.index);
      }
      if (material.emissiveTexture) {
        material.emmisiveTexture = {
          ...material.emmisiveTexture
        };
        material.emissiveTexture.texture = this.getTexture(material.emissiveTexture.index);
      }
      if (!material.emissiveFactor) {
        material.emissiveFactor = material.emmisiveTexture ? [1, 1, 1] : [0, 0, 0];
      }
      if (material.pbrMetallicRoughness) {
        material.pbrMetallicRoughness = {
          ...material.pbrMetallicRoughness
        };
        const mr = material.pbrMetallicRoughness;
        if (mr.baseColorTexture) {
          mr.baseColorTexture = {
            ...mr.baseColorTexture
          };
          mr.baseColorTexture.texture = this.getTexture(mr.baseColorTexture.index);
        }
        if (mr.metallicRoughnessTexture) {
          mr.metallicRoughnessTexture = {
            ...mr.metallicRoughnessTexture
          };
          mr.metallicRoughnessTexture.texture = this.getTexture(mr.metallicRoughnessTexture.index);
        }
      }
      return material;
    }
    _resolveAccessor(accessor, index) {
      accessor.id = accessor.id || "accessor-".concat(index);
      if (accessor.bufferView !== void 0) {
        accessor.bufferView = this.getBufferView(accessor.bufferView);
      }
      accessor.bytesPerComponent = getBytesFromComponentType(accessor.componentType);
      accessor.components = getSizeFromAccessorType(accessor.type);
      accessor.bytesPerElement = accessor.bytesPerComponent * accessor.components;
      if (accessor.bufferView) {
        const buffer = accessor.bufferView.buffer;
        const {
          ArrayType,
          byteLength
        } = getAccessorArrayTypeAndLength(accessor, accessor.bufferView);
        const byteOffset = (accessor.bufferView.byteOffset || 0) + (accessor.byteOffset || 0) + buffer.byteOffset;
        let cutBuffer = buffer.arrayBuffer.slice(byteOffset, byteOffset + byteLength);
        if (accessor.bufferView.byteStride) {
          cutBuffer = this._getValueFromInterleavedBuffer(buffer, byteOffset, accessor.bufferView.byteStride, accessor.bytesPerElement, accessor.count);
        }
        accessor.value = new ArrayType(cutBuffer);
      }
      return accessor;
    }
    _getValueFromInterleavedBuffer(buffer, byteOffset, byteStride, bytesPerElement, count) {
      const result = new Uint8Array(count * bytesPerElement);
      for (let i2 = 0; i2 < count; i2++) {
        const elementOffset = byteOffset + i2 * byteStride;
        result.set(new Uint8Array(buffer.arrayBuffer.slice(elementOffset, elementOffset + bytesPerElement)), i2 * bytesPerElement);
      }
      return result.buffer;
    }
    _resolveTexture(texture, index) {
      texture.id = texture.id || "texture-".concat(index);
      texture.sampler = "sampler" in texture ? this.getSampler(texture.sampler) : DEFAULT_SAMPLER;
      texture.source = this.getImage(texture.source);
      return texture;
    }
    _resolveSampler(sampler, index) {
      sampler.id = sampler.id || "sampler-".concat(index);
      sampler.parameters = {};
      for (const key in sampler) {
        const glEnum = this._enumSamplerParameter(key);
        if (glEnum !== void 0) {
          sampler.parameters[glEnum] = sampler[key];
        }
      }
      return sampler;
    }
    _enumSamplerParameter(key) {
      return SAMPLER_PARAMETER_GLTF_TO_GL[key];
    }
    _resolveImage(image, index) {
      image.id = image.id || "image-".concat(index);
      if (image.bufferView !== void 0) {
        image.bufferView = this.getBufferView(image.bufferView);
      }
      const preloadedImage = this.images[index];
      if (preloadedImage) {
        image.image = preloadedImage;
      }
      return image;
    }
    _resolveBufferView(bufferView, index) {
      const bufferIndex = bufferView.buffer;
      const result = {
        id: "bufferView-".concat(index),
        ...bufferView,
        buffer: this.buffers[bufferIndex]
      };
      const arrayBuffer2 = this.buffers[bufferIndex].arrayBuffer;
      let byteOffset = this.buffers[bufferIndex].byteOffset || 0;
      if ("byteOffset" in bufferView) {
        byteOffset += bufferView.byteOffset;
      }
      result.data = new Uint8Array(arrayBuffer2, byteOffset, bufferView.byteLength);
      return result;
    }
    _resolveCamera(camera, index) {
      camera.id = camera.id || "camera-".concat(index);
      if (camera.perspective) {
      }
      if (camera.orthographic) {
      }
      return camera;
    }
  };
  function postProcessGLTF(gltf, options) {
    return new GLTFPostProcessor().postProcess(gltf, options);
  }

  // ../../node_modules/@loaders.gl/gltf/dist/esm/lib/parsers/parse-glb.js
  var MAGIC_glTF = 1735152710;
  var GLB_FILE_HEADER_SIZE = 12;
  var GLB_CHUNK_HEADER_SIZE = 8;
  var GLB_CHUNK_TYPE_JSON = 1313821514;
  var GLB_CHUNK_TYPE_BIN = 5130562;
  var GLB_CHUNK_TYPE_JSON_XVIZ_DEPRECATED = 0;
  var GLB_CHUNK_TYPE_BIX_XVIZ_DEPRECATED = 1;
  var GLB_V1_CONTENT_FORMAT_JSON = 0;
  var LE = true;
  function getMagicString2(dataView) {
    let byteOffset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    return "".concat(String.fromCharCode(dataView.getUint8(byteOffset + 0))).concat(String.fromCharCode(dataView.getUint8(byteOffset + 1))).concat(String.fromCharCode(dataView.getUint8(byteOffset + 2))).concat(String.fromCharCode(dataView.getUint8(byteOffset + 3)));
  }
  function isGLB(arrayBuffer2) {
    let byteOffset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    const dataView = new DataView(arrayBuffer2);
    const {
      magic = MAGIC_glTF
    } = options;
    const magic1 = dataView.getUint32(byteOffset, false);
    return magic1 === magic || magic1 === MAGIC_glTF;
  }
  function parseGLBSync(glb, arrayBuffer2) {
    let byteOffset = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
    let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    const dataView = new DataView(arrayBuffer2);
    const type = getMagicString2(dataView, byteOffset + 0);
    const version = dataView.getUint32(byteOffset + 4, LE);
    const byteLength = dataView.getUint32(byteOffset + 8, LE);
    Object.assign(glb, {
      header: {
        byteOffset,
        byteLength,
        hasBinChunk: false
      },
      type,
      version,
      json: {},
      binChunks: []
    });
    byteOffset += GLB_FILE_HEADER_SIZE;
    switch (glb.version) {
      case 1:
        return parseGLBV1(glb, dataView, byteOffset);
      case 2:
        return parseGLBV2(glb, dataView, byteOffset, options = {});
      default:
        throw new Error("Invalid GLB version ".concat(glb.version, ". Only supports v1 and v2."));
    }
  }
  function parseGLBV1(glb, dataView, byteOffset) {
    assert7(glb.header.byteLength > GLB_FILE_HEADER_SIZE + GLB_CHUNK_HEADER_SIZE);
    const contentLength = dataView.getUint32(byteOffset + 0, LE);
    const contentFormat = dataView.getUint32(byteOffset + 4, LE);
    byteOffset += GLB_CHUNK_HEADER_SIZE;
    assert7(contentFormat === GLB_V1_CONTENT_FORMAT_JSON);
    parseJSONChunk(glb, dataView, byteOffset, contentLength);
    byteOffset += contentLength;
    byteOffset += parseBINChunk(glb, dataView, byteOffset, glb.header.byteLength);
    return byteOffset;
  }
  function parseGLBV2(glb, dataView, byteOffset, options) {
    assert7(glb.header.byteLength > GLB_FILE_HEADER_SIZE + GLB_CHUNK_HEADER_SIZE);
    parseGLBChunksSync(glb, dataView, byteOffset, options);
    return byteOffset + glb.header.byteLength;
  }
  function parseGLBChunksSync(glb, dataView, byteOffset, options) {
    while (byteOffset + 8 <= glb.header.byteLength) {
      const chunkLength = dataView.getUint32(byteOffset + 0, LE);
      const chunkFormat = dataView.getUint32(byteOffset + 4, LE);
      byteOffset += GLB_CHUNK_HEADER_SIZE;
      switch (chunkFormat) {
        case GLB_CHUNK_TYPE_JSON:
          parseJSONChunk(glb, dataView, byteOffset, chunkLength);
          break;
        case GLB_CHUNK_TYPE_BIN:
          parseBINChunk(glb, dataView, byteOffset, chunkLength);
          break;
        case GLB_CHUNK_TYPE_JSON_XVIZ_DEPRECATED:
          if (!options.strict) {
            parseJSONChunk(glb, dataView, byteOffset, chunkLength);
          }
          break;
        case GLB_CHUNK_TYPE_BIX_XVIZ_DEPRECATED:
          if (!options.strict) {
            parseBINChunk(glb, dataView, byteOffset, chunkLength);
          }
          break;
        default:
          break;
      }
      byteOffset += padToNBytes(chunkLength, 4);
    }
    return byteOffset;
  }
  function parseJSONChunk(glb, dataView, byteOffset, chunkLength) {
    const jsonChunk = new Uint8Array(dataView.buffer, byteOffset, chunkLength);
    const textDecoder = new TextDecoder("utf8");
    const jsonText = textDecoder.decode(jsonChunk);
    glb.json = JSON.parse(jsonText);
    return padToNBytes(chunkLength, 4);
  }
  function parseBINChunk(glb, dataView, byteOffset, chunkLength) {
    glb.header.hasBinChunk = true;
    glb.binChunks.push({
      byteOffset,
      byteLength: chunkLength,
      arrayBuffer: dataView.buffer
    });
    return padToNBytes(chunkLength, 4);
  }

  // ../../node_modules/@loaders.gl/gltf/dist/esm/lib/parsers/parse-gltf.js
  async function parseGLTF(gltf, arrayBufferOrString) {
    var _options$gltf, _options$gltf2, _options$gltf3, _options$gltf4;
    let byteOffset = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
    let options = arguments.length > 3 ? arguments[3] : void 0;
    let context = arguments.length > 4 ? arguments[4] : void 0;
    parseGLTFContainerSync(gltf, arrayBufferOrString, byteOffset, options);
    normalizeGLTFV1(gltf, {
      normalize: options === null || options === void 0 ? void 0 : (_options$gltf = options.gltf) === null || _options$gltf === void 0 ? void 0 : _options$gltf.normalize
    });
    preprocessExtensions(gltf, options, context);
    const promises = [];
    if (options !== null && options !== void 0 && (_options$gltf2 = options.gltf) !== null && _options$gltf2 !== void 0 && _options$gltf2.loadBuffers && gltf.json.buffers) {
      await loadBuffers(gltf, options, context);
    }
    if (options !== null && options !== void 0 && (_options$gltf3 = options.gltf) !== null && _options$gltf3 !== void 0 && _options$gltf3.loadImages) {
      const promise2 = loadImages(gltf, options, context);
      promises.push(promise2);
    }
    const promise = decodeExtensions(gltf, options, context);
    promises.push(promise);
    await Promise.all(promises);
    return options !== null && options !== void 0 && (_options$gltf4 = options.gltf) !== null && _options$gltf4 !== void 0 && _options$gltf4.postProcess ? postProcessGLTF(gltf, options) : gltf;
  }
  function parseGLTFContainerSync(gltf, data, byteOffset, options) {
    if (options.uri) {
      gltf.baseUri = options.uri;
    }
    if (data instanceof ArrayBuffer && !isGLB(data, byteOffset, options)) {
      const textDecoder = new TextDecoder();
      data = textDecoder.decode(data);
    }
    if (typeof data === "string") {
      gltf.json = parseJSON(data);
    } else if (data instanceof ArrayBuffer) {
      const glb = {};
      byteOffset = parseGLBSync(glb, data, byteOffset, options.glb);
      assert9(glb.type === "glTF", "Invalid GLB magic string ".concat(glb.type));
      gltf._glb = glb;
      gltf.json = glb.json;
    } else {
      assert9(false, "GLTF: must be ArrayBuffer or string");
    }
    const buffers = gltf.json.buffers || [];
    gltf.buffers = new Array(buffers.length).fill(null);
    if (gltf._glb && gltf._glb.header.hasBinChunk) {
      const {
        binChunks
      } = gltf._glb;
      gltf.buffers[0] = {
        arrayBuffer: binChunks[0].arrayBuffer,
        byteOffset: binChunks[0].byteOffset,
        byteLength: binChunks[0].byteLength
      };
    }
    const images = gltf.json.images || [];
    gltf.images = new Array(images.length).fill({});
  }
  async function loadBuffers(gltf, options, context) {
    const buffers = gltf.json.buffers || [];
    for (let i2 = 0; i2 < buffers.length; ++i2) {
      const buffer = buffers[i2];
      if (buffer.uri) {
        var _context$fetch, _response$arrayBuffer;
        const {
          fetch: fetch2
        } = context;
        assert9(fetch2);
        const uri = resolveUrl(buffer.uri, options);
        const response = await (context === null || context === void 0 ? void 0 : (_context$fetch = context.fetch) === null || _context$fetch === void 0 ? void 0 : _context$fetch.call(context, uri));
        const arrayBuffer2 = await (response === null || response === void 0 ? void 0 : (_response$arrayBuffer = response.arrayBuffer) === null || _response$arrayBuffer === void 0 ? void 0 : _response$arrayBuffer.call(response));
        gltf.buffers[i2] = {
          arrayBuffer: arrayBuffer2,
          byteOffset: 0,
          byteLength: arrayBuffer2.byteLength
        };
        delete buffer.uri;
      } else if (gltf.buffers[i2] === null) {
        gltf.buffers[i2] = {
          arrayBuffer: new ArrayBuffer(buffer.byteLength),
          byteOffset: 0,
          byteLength: buffer.byteLength
        };
      }
    }
  }
  async function loadImages(gltf, options, context) {
    const imageIndices = getReferencesImageIndices(gltf);
    const images = gltf.json.images || [];
    const promises = [];
    for (const imageIndex of imageIndices) {
      promises.push(loadImage2(gltf, images[imageIndex], imageIndex, options, context));
    }
    return await Promise.all(promises);
  }
  function getReferencesImageIndices(gltf) {
    const imageIndices = /* @__PURE__ */ new Set();
    const textures = gltf.json.textures || [];
    for (const texture of textures) {
      if (texture.source !== void 0) {
        imageIndices.add(texture.source);
      }
    }
    return Array.from(imageIndices).sort();
  }
  async function loadImage2(gltf, image, index, options, context) {
    const {
      fetch: fetch2,
      parse: parse3
    } = context;
    let arrayBuffer2;
    if (image.uri && !image.hasOwnProperty("bufferView")) {
      const uri = resolveUrl(image.uri, options);
      const response = await fetch2(uri);
      arrayBuffer2 = await response.arrayBuffer();
      image.bufferView = {
        data: arrayBuffer2
      };
    }
    if (Number.isFinite(image.bufferView)) {
      const array = getTypedArrayForBufferView(gltf.json, gltf.buffers, image.bufferView);
      arrayBuffer2 = sliceArrayBuffer(array.buffer, array.byteOffset, array.byteLength);
    }
    assert9(arrayBuffer2, "glTF image has no data");
    let parsedImage = await parse3(arrayBuffer2, [ImageLoader, BasisLoader], {
      mimeType: image.mimeType,
      basis: options.basis || {
        format: selectSupportedBasisFormat()
      }
    }, context);
    if (parsedImage && parsedImage[0]) {
      parsedImage = {
        compressed: true,
        mipmaps: false,
        width: parsedImage[0].width,
        height: parsedImage[0].height,
        data: parsedImage[0]
      };
    }
    gltf.images = gltf.images || [];
    gltf.images[index] = parsedImage;
  }

  // ../../node_modules/@loaders.gl/gltf/dist/esm/gltf-loader.js
  var GLTFLoader = {
    name: "glTF",
    id: "gltf",
    module: "gltf",
    version: VERSION5,
    extensions: ["gltf", "glb"],
    mimeTypes: ["model/gltf+json", "model/gltf-binary"],
    text: true,
    binary: true,
    tests: ["glTF"],
    parse: parse2,
    options: {
      gltf: {
        normalize: true,
        loadBuffers: true,
        loadImages: true,
        decompressMeshes: true,
        postProcess: true
      },
      log: console
    },
    deprecatedOptions: {
      fetchImages: "gltf.loadImages",
      createImages: "gltf.loadImages",
      decompress: "gltf.decompressMeshes",
      postProcess: "gltf.postProcess",
      gltf: {
        decompress: "gltf.decompressMeshes"
      }
    }
  };
  async function parse2(arrayBuffer2) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    let context = arguments.length > 2 ? arguments[2] : void 0;
    options = {
      ...GLTFLoader.options,
      ...options
    };
    options.gltf = {
      ...GLTFLoader.options.gltf,
      ...options.gltf
    };
    const {
      byteOffset = 0
    } = options;
    const gltf = {};
    return await parseGLTF(gltf, arrayBuffer2, byteOffset, options, context);
  }

  // src/scenegraph-layer/gltf-utils.ts
  async function waitForGLTFAssets(gltfObjects) {
    const remaining = [];
    gltfObjects.scenes.forEach((scene) => {
      scene.traverse((model) => {
        Object.values(model.model.getUniforms()).forEach((uniform) => {
          if (uniform.loaded === false) {
            remaining.push(uniform);
          }
        });
      });
    });
    return await waitWhileCondition(() => remaining.some((uniform) => !uniform.loaded));
  }
  async function waitWhileCondition(condition) {
    while (condition()) {
      await new Promise((resolve) => requestAnimationFrame(resolve));
    }
  }

  // src/scenegraph-layer/scenegraph-layer-vertex.glsl.ts
  var scenegraph_layer_vertex_glsl_default = `#version 300 es

// Instance attributes
in vec3 instancePositions;
in vec3 instancePositions64Low;
in vec4 instanceColors;
in vec3 instancePickingColors;
in mat3 instanceModelMatrix;
in vec3 instanceTranslation;

// Uniforms
uniform float sizeScale;
uniform float sizeMinPixels;
uniform float sizeMaxPixels;
uniform mat4 sceneModelMatrix;
uniform bool composeModelMatrix;

// Attributes
in vec4 POSITION;

#ifdef HAS_UV
  in vec2 TEXCOORD_0;
#endif

#ifdef MODULE_PBR
  #ifdef HAS_NORMALS
    in vec4 NORMAL;
  #endif
#endif

// Varying
out vec4 vColor;

// MODULE_PBR contains all the varying definitions needed
#ifndef MODULE_PBR
  #ifdef HAS_UV
    out vec2 vTEXCOORD_0;
  #endif
#endif

// Main
void main(void) {
  #if defined(HAS_UV) && !defined(MODULE_PBR)
    vTEXCOORD_0 = TEXCOORD_0;
    geometry.uv = vTEXCOORD_0;
  #endif

  geometry.worldPosition = instancePositions;
  geometry.pickingColor = instancePickingColors;

  vec3 normal = vec3(0.0, 0.0, 1.0);
  #ifdef MODULE_PBR
    #ifdef HAS_NORMALS
      normal = instanceModelMatrix * (sceneModelMatrix * vec4(NORMAL.xyz, 0.0)).xyz;
    #endif
  #endif

  float originalSize = project_size_to_pixel(sizeScale);
  float clampedSize = clamp(originalSize, sizeMinPixels, sizeMaxPixels);

  vec3 pos = (instanceModelMatrix * (sceneModelMatrix * POSITION).xyz) * sizeScale * (clampedSize / originalSize) + instanceTranslation;
  if(composeModelMatrix) {
    DECKGL_FILTER_SIZE(pos, geometry);
    // using instancePositions as world coordinates
    // when using globe mode, this branch does not re-orient the model to align with the surface of the earth
    // call project_normal before setting position to avoid rotation
    geometry.normal = project_normal(normal);
    geometry.worldPosition += pos;
    gl_Position = project_position_to_clipspace(pos + instancePositions, instancePositions64Low, vec3(0.0), geometry.position);
  }
  else {
    pos = project_size(pos);
    DECKGL_FILTER_SIZE(pos, geometry);
    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, pos, geometry.position);
    geometry.normal = project_normal(normal);
  }
  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);

  #ifdef MODULE_PBR
    // set PBR data
    pbr_vPosition = geometry.position.xyz;
    #ifdef HAS_NORMALS
      pbr_vNormal = geometry.normal;
    #endif

    #ifdef HAS_UV
      pbr_vUV = TEXCOORD_0;
    #else
      pbr_vUV = vec2(0., 0.);
    #endif
    geometry.uv = pbr_vUV;
  #endif

  vColor = instanceColors;
  DECKGL_FILTER_COLOR(vColor, geometry);
}
`;

  // src/scenegraph-layer/scenegraph-layer-fragment.glsl.ts
  var scenegraph_layer_fragment_glsl_default = `#version 300 es

// Uniforms
uniform float opacity;

// Varying
in vec4 vColor;

out vec4 fragmentColor;

// MODULE_PBR contains all the varying definitions needed
#ifndef MODULE_PBR
  #if defined(HAS_UV) && defined(HAS_BASECOLORMAP)
    in vec2 vTEXCOORD_0;
    uniform sampler2D u_BaseColorSampler;
  #endif
#endif

void main(void) {
  #ifdef MODULE_PBR
    fragmentColor = vColor * pbr_filterColor(vec4(0));
    geometry.uv = pbr_vUV;
  #else
    #if defined(HAS_UV) && defined(HAS_BASECOLORMAP)
      fragmentColor = vColor * texture2D(u_BaseColorSampler, vTEXCOORD_0);
      geometry.uv = vTEXCOORD_0;
    #else
      fragmentColor = vColor;
    #endif
  #endif

  fragmentColor.a *= opacity;
  DECKGL_FILTER_COLOR(fragmentColor, geometry);
}
`;

  // src/scenegraph-layer/scenegraph-layer.ts
  var DEFAULT_COLOR2 = [255, 255, 255, 255];
  var defaultProps2 = {
    scenegraph: {
      type: "object",
      value: null,
      async: true
    },
    getScene: (gltf) => {
      if (gltf && gltf.scenes) {
        return typeof gltf.scene === "object" ? gltf.scene : gltf.scenes[gltf.scene || 0];
      }
      return gltf;
    },
    getAnimator: (scenegraph) => scenegraph && scenegraph.animator,
    _animations: null,
    sizeScale: {
      type: "number",
      value: 1,
      min: 0
    },
    sizeMinPixels: {
      type: "number",
      min: 0,
      value: 0
    },
    sizeMaxPixels: {
      type: "number",
      min: 0,
      value: Number.MAX_SAFE_INTEGER
    },
    getPosition: {
      type: "accessor",
      value: (x) => x.position
    },
    getColor: {
      type: "accessor",
      value: DEFAULT_COLOR2
    },
    _lighting: "flat",
    _imageBasedLightingEnvironment: null,
    getOrientation: {
      type: "accessor",
      value: [0, 0, 0]
    },
    getScale: {
      type: "accessor",
      value: [1, 1, 1]
    },
    getTranslation: {
      type: "accessor",
      value: [0, 0, 0]
    },
    getTransformMatrix: {
      type: "accessor",
      value: []
    },
    loaders: [GLTFLoader]
  };
  var ScenegraphLayer = class extends import_core10.Layer {
    getShaders() {
      const modules = [import_core10.project32, import_core10.picking];
      if (this.props._lighting === "pbr") {
        modules.push(pbr);
      }
      return {
        vs: scenegraph_layer_vertex_glsl_default,
        fs: scenegraph_layer_fragment_glsl_default,
        modules
      };
    }
    initializeState() {
      const attributeManager = this.getAttributeManager();
      attributeManager.addInstanced({
        instancePositions: {
          size: 3,
          type: esm_default.DOUBLE,
          fp64: this.use64bitPositions(),
          accessor: "getPosition",
          transition: true
        },
        instanceColors: {
          type: esm_default.UNSIGNED_BYTE,
          size: this.props.colorFormat.length,
          accessor: "getColor",
          normalized: true,
          defaultValue: DEFAULT_COLOR2,
          transition: true
        },
        instanceModelMatrix: MATRIX_ATTRIBUTES
      });
    }
    updateState(params) {
      super.updateState(params);
      const {
        props,
        oldProps
      } = params;
      if (props.scenegraph !== oldProps.scenegraph) {
        this._updateScenegraph();
      } else if (props._animations !== oldProps._animations) {
        this._applyAnimationsProp(this.state.scenegraph, this.state.animator, props._animations);
      }
    }
    finalizeState(context) {
      super.finalizeState(context);
      this._deleteScenegraph();
    }
    _updateScenegraph() {
      const props = this.props;
      const {
        gl
      } = this.context;
      let scenegraphData = null;
      if (props.scenegraph instanceof ScenegraphNode) {
        scenegraphData = {
          scenes: [props.scenegraph]
        };
      } else if (props.scenegraph && !props.scenegraph.gltf) {
        const gltf = props.scenegraph;
        const gltfObjects = createGLTFObjects(gl, gltf, this._getModelOptions());
        scenegraphData = {
          gltf,
          ...gltfObjects
        };
        waitForGLTFAssets(gltfObjects).then(() => this.setNeedsRedraw());
      } else if (props.scenegraph) {
        import_core10.log.deprecated("ScenegraphLayer.props.scenegraph", "Use GLTFLoader instead of GLTFScenegraphLoader")();
        scenegraphData = props.scenegraph;
      }
      const options = {
        layer: this,
        gl
      };
      const scenegraph = props.getScene(scenegraphData, options);
      const animator = props.getAnimator(scenegraphData, options);
      if (scenegraph instanceof ScenegraphNode) {
        this._deleteScenegraph();
        this._applyAllAttributes(scenegraph);
        this._applyAnimationsProp(scenegraph, animator, props._animations);
        this.setState({
          scenegraph,
          animator
        });
      } else if (scenegraph !== null) {
        import_core10.log.warn("invalid scenegraph:", scenegraph)();
      }
    }
    _applyAllAttributes(scenegraph) {
      if (this.state.attributesAvailable) {
        const allAttributes = this.getAttributeManager().getAttributes();
        scenegraph.traverse((model) => {
          this._setModelAttributes(model.model, allAttributes);
        });
      }
    }
    _applyAnimationsProp(scenegraph, animator, animationsProp) {
      if (!scenegraph || !animator || !animationsProp) {
        return;
      }
      const animations = animator.getAnimations();
      Object.keys(animationsProp).sort().forEach((key) => {
        const value = animationsProp[key];
        if (key === "*") {
          animations.forEach((animation) => {
            Object.assign(animation, value);
          });
        } else if (Number.isFinite(Number(key))) {
          const number = Number(key);
          if (number >= 0 && number < animations.length) {
            Object.assign(animations[number], value);
          } else {
            import_core10.log.warn(`animation ${key} not found`)();
          }
        } else {
          const findResult = animations.find(({
            name: name10
          }) => name10 === key);
          if (findResult) {
            Object.assign(findResult, value);
          } else {
            import_core10.log.warn(`animation ${key} not found`)();
          }
        }
      });
    }
    _deleteScenegraph() {
      const {
        scenegraph
      } = this.state;
      if (scenegraph instanceof ScenegraphNode) {
        scenegraph.delete();
      }
    }
    _getModelOptions() {
      const {
        _imageBasedLightingEnvironment
      } = this.props;
      let env = null;
      if (_imageBasedLightingEnvironment) {
        if (typeof _imageBasedLightingEnvironment === "function") {
          env = _imageBasedLightingEnvironment({
            gl: this.context.gl,
            layer: this
          });
        } else {
          env = _imageBasedLightingEnvironment;
        }
      }
      return {
        gl: this.context.gl,
        waitForFullLoad: true,
        imageBasedLightingEnvironment: env,
        modelOptions: {
          isInstanced: true,
          transpileToGLSL100: !(0, import_core11.isWebGL2)(this.context.gl),
          ...this.getShaders()
        },
        useTangents: false
      };
    }
    updateAttributes(changedAttributes) {
      this.setState({
        attributesAvailable: true
      });
      if (!this.state.scenegraph)
        return;
      this.state.scenegraph.traverse((model) => {
        this._setModelAttributes(model.model, changedAttributes);
      });
    }
    draw({
      moduleParameters = null,
      parameters = {},
      context
    }) {
      if (!this.state.scenegraph)
        return;
      if (this.props._animations && this.state.animator) {
        this.state.animator.animate(context.timeline.getTime());
        this.setNeedsRedraw();
      }
      const {
        viewport
      } = this.context;
      const {
        sizeScale,
        sizeMinPixels,
        sizeMaxPixels,
        opacity,
        coordinateSystem
      } = this.props;
      const numInstances = this.getNumInstances();
      this.state.scenegraph.traverse((model, {
        worldMatrix
      }) => {
        model.model.setInstanceCount(numInstances);
        model.updateModuleSettings(moduleParameters);
        model.draw({
          parameters,
          uniforms: {
            sizeScale,
            opacity,
            sizeMinPixels,
            sizeMaxPixels,
            composeModelMatrix: shouldComposeModelMatrix(viewport, coordinateSystem),
            sceneModelMatrix: worldMatrix,
            u_Camera: model.model.getUniforms().project_uCameraPosition
          }
        });
      });
    }
  };
  __publicField(ScenegraphLayer, "defaultProps", defaultProps2);
  __publicField(ScenegraphLayer, "layerName", "ScenegraphLayer");
  return __toCommonJS(bundle_exports);
})();
      return __exports__;
      });
