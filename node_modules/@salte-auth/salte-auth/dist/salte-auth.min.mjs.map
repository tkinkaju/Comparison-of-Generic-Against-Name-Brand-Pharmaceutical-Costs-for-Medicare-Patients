{"version":3,"file":"salte-auth.min.mjs","sources":["../node_modules/@babel/runtime/helpers/asyncToGenerator.js","../node_modules/@babel/runtime/helpers/defineProperty.js","../src/base/core/salte-auth-error.ts","../src/base/core/required.ts","../src/utils/interceptors/fetch.ts","../src/utils/events.ts","../src/utils/interceptors/xhr.ts","../node_modules/@babel/runtime/helpers/arrayWithHoles.js","../node_modules/@babel/runtime/helpers/iterableToArrayLimit.js","../node_modules/@babel/runtime/helpers/nonIterableRest.js","../node_modules/@babel/runtime/helpers/slicedToArray.js","../src/utils/url.ts","../src/utils/common.ts","../src/utils/access-token.ts","../src/utils/id-token.ts","../src/utils/logger.ts","../src/base/core/storage.ts","../src/base/core/events.ts","../src/base/core/shared.ts","../node_modules/nanoid/index.browser.js","../src/base/core/provider.ts","../src/base/provider-oauth2.ts","../src/base/provider-openid.ts","../src/generic.ts","../src/base/handler.ts","../src/salte-auth.ts","../src/mixins/auth.ts"],"sourcesContent":["function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n\n      _next(undefined);\n    });\n  };\n}\n\nmodule.exports = _asyncToGenerator;","function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nmodule.exports = _defineProperty;","export class SalteAuthError extends Error {\n  public code: string;\n\n  public constructor({ message, code }: SalteAuthError.Options) {\n    super(message);\n\n    this.code = code;\n  }\n}\n\nexport declare namespace SalteAuthError {\n  export interface Options {\n    message: string;\n    code: string;\n  }\n}\n","import { SalteAuthError } from './salte-auth-error';\n\nexport class Required {\n  public constructor(config?: Required.Config) {\n    this.config = config || {};\n  }\n\n  protected required(...keys: string[]): void {\n    const missing = keys.filter((key: string) => {\n      return this.config[key] === undefined;\n    });\n\n    if (missing.length > 0) {\n      throw new SalteAuthError({\n        code: 'missing_required_properties',\n        message: `Missing the following required fields. (${missing.join(', ')})`,\n      });\n    }\n  }\n}\n\nexport interface Required {\n  config: Required.Config;\n};\n\nexport declare namespace Required {\n  export interface Config {\n    [key: string]: any;\n  }\n}\n","export class Fetch {\n  static real: (input: RequestInfo, init?: RequestInit) => Promise<Response>;\n  static hasSetup = false;\n  static interceptors: Function[];\n\n  static setup(force?: boolean) {\n    if (this.hasSetup && !force) return;\n    this.hasSetup = true;\n    this.interceptors = [];\n\n    if (!this.real) this.real = window.fetch;\n\n    if (window.fetch) {\n      window.fetch = async function(input, options) {\n        const request = input instanceof Request ? input : new Request(input, options);\n\n        for (let i = 0; i < Fetch.interceptors.length; i++) {\n          const interceptor = Fetch.interceptors[i];\n\n          await Promise.resolve(interceptor(request));\n        }\n\n        return Fetch.real.call(this, request);\n      };\n    }\n  }\n\n  static add(interceptor: (request: Request) => void) {\n    this.setup();\n\n    this.interceptors.push(interceptor);\n  }\n}\n\n","let setup = false;\nconst callbacks: Function[] = [];\nexport declare interface SalteAuthEvent extends Event {\n  detail?: any;\n}\n\nexport declare interface CreateOptions {\n  bubbles?: boolean;\n  cancelable?: boolean;\n  detail?: any;\n}\n\nfunction onRouteChange() {\n  callbacks.forEach((callback) => callback());\n}\n\nexport class Events {\n  public static route(callback: () => void) {\n    if (!setup) {\n      window.addEventListener('popstate', onRouteChange, { passive: true });\n      window.addEventListener('click', onRouteChange, { passive: true });\n      setTimeout(onRouteChange);\n      setup = true;\n    }\n\n    callbacks.push(callback);\n  }\n\n  public static create(name: string, params: CreateOptions): SalteAuthEvent {\n    const event: SalteAuthEvent = document.createEvent('Event');\n    event.initEvent(name, params.bubbles || false, params.cancelable || true);\n    event.detail = params.detail;\n    return event;\n  }\n\n  public static isCrossDomainError(e: Error): boolean {\n    return e instanceof DOMException || e.message === 'Permission denied';\n  }\n}\n","import { Events } from '../events';\n\nexport class XHR {\n  static realOpen: (method: string, url: string) => void;\n  static realSend: (body?: Document | BodyInit | null) => void;\n  static hasSetup = false;\n  static interceptors: Function[];\n\n  public static setup(force?: boolean) {\n    if (this.hasSetup && !force) return;\n    this.hasSetup = true;\n    this.interceptors = [];\n\n    if (!this.realOpen) this.realOpen = XMLHttpRequest.prototype.open;\n    if (!this.realSend) this.realSend = XMLHttpRequest.prototype.send;\n\n    const requestPrototype: XHR.ExtendedXMLHttpRequest = XMLHttpRequest.prototype;\n    requestPrototype.open = function(...args: any) {\n      const [, url] = args;\n      this.$url = url;\n      return XHR.realOpen.apply(this, args);\n    };\n\n    requestPrototype.send = function(data) {\n      const promises = [];\n      for (let i = 0; i < XHR.interceptors.length; i++) {\n        const interceptor = XHR.interceptors[i];\n\n        promises.push(interceptor(this, data));\n      }\n\n      Promise.all(promises).then(() => {\n        XHR.realSend.call(this, data);\n      }).catch((error) => {\n        this.dispatchEvent(Events.create('error', {\n          detail: error\n        }));\n      });\n    };\n  }\n\n  public static add(interceptor: (request: XHR.ExtendedXMLHttpRequest, data?: string | Document | Blob | ArrayBufferView | ArrayBuffer | FormData | URLSearchParams | ReadableStream<Uint8Array> | null) => void) {\n    this.setup();\n\n    this.interceptors.push(interceptor);\n  }\n}\n\nexport declare namespace XHR {\n  export interface ExtendedXMLHttpRequest extends XMLHttpRequest {\n    $url?: string;\n  }\n}\n","function _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nmodule.exports = _arrayWithHoles;","function _iterableToArrayLimit(arr, i) {\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nmodule.exports = _iterableToArrayLimit;","function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\n\nmodule.exports = _nonIterableRest;","var arrayWithHoles = require(\"./arrayWithHoles\");\n\nvar iterableToArrayLimit = require(\"./iterableToArrayLimit\");\n\nvar nonIterableRest = require(\"./nonIterableRest\");\n\nfunction _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || nonIterableRest();\n}\n\nmodule.exports = _slicedToArray;","import { Common } from './common';\n\nlet urlDocument: Document;\nlet base: HTMLBaseElement;\nlet anchor: HTMLAnchorElement;\n\nexport class URL {\n  /**\n   * Outputs a result equivalent to `location.origin`\n   */\n  public static get origin() {\n    return `${location.protocol}//${location.host}`;\n  }\n\n  public static resolve(path: string) {\n    if (!urlDocument) {\n      urlDocument = document.implementation.createHTMLDocument('url');\n      base = urlDocument.createElement('base');\n      anchor = urlDocument.createElement('a');\n      urlDocument.head.appendChild(base);\n    }\n    base.href = window.location.protocol + '//' + window.location.host;\n    anchor.href = path.replace(/ /g, '%20');\n    return anchor.href.replace(/\\/$/, '');\n  }\n\n  public static match(url: string, tests: (string | RegExp)[] | boolean): boolean {\n    if (tests instanceof Array) {\n      const resolvedUrl = this.resolve(url);\n\n      const match = Common.find(tests, (test) => {\n        if (test instanceof RegExp) {\n          return !!resolvedUrl.match(test);\n        }\n\n        return resolvedUrl.indexOf(this.resolve(test)) === 0;\n      });\n\n      return !!match;\n    }\n\n    return tests === true;\n  }\n\n  public static parse({ search, hash }: Location) {\n    let params: string[] = [];\n\n    if (search) params = params.concat(search.replace('?', '').split('&'));\n    if (hash) params = params.concat(hash.replace('#', '').split('&'));\n\n    const parsed: any = {};\n\n    Common.forEach(params, (param) => {\n      const [key, value] = param.split('=');\n\n      parsed[key] = value;\n    });\n\n    return parsed;\n  }\n}\n","import { URL } from './url';\nimport { Events } from './events';\n\nconst debounces: {\n  [key: string]: number;\n} = {};\n\nexport class Common {\n  public static includes(source: any[] | string, value: any) {\n    return source.indexOf(value) !== -1;\n  }\n\n  public static forEach<T>(source: T[], cb: (value: T, key: number | string) => void): void;\n  public static forEach<T extends object>(source: T, cb: (item: any, key: number | string) => void): void;\n  public static forEach<T>(source: T[] | T, cb: (item: T | any, key: number | string) => void): void {\n    if (Array.isArray(source)) {\n      for (let i = 0; i < source.length; i++) {\n        cb(source[i], i);\n      }\n    } else {\n      for (let key in source) {\n        cb(source[key], key);\n      }\n    }\n  }\n\n  public static find<T>(source: T[], cb: (value: T, key: number | string) => boolean): T;\n  public static find<T extends object>(source: T, cb: (item: any, key: number | string) => boolean): any;\n  public static find<T>(source: T[] | T, cb: (item: T | any, key: number | string) => boolean): T | any {\n    if (Array.isArray(source)) {\n      for (let i = 0; i < source.length; i++) {\n        const item = source[i];\n        if (cb(item, i)) {\n          return item;\n        }\n      }\n    } else {\n      for (let key in source) {\n        const item = source[key];\n        if (cb(item, key)) {\n          return item;\n        }\n      }\n    }\n\n    return null;\n  }\n\n  public static assign(target: any, ...sources: any[]) {\n    this.forEach(sources, (source) => {\n      for (const key in source) {\n        target[key] = source[key];\n      }\n    });\n\n    return target;\n  }\n\n  public static defaults(target: any, ...sources: any[]) {\n    this.forEach(sources, (source) => {\n      for (const key in source) {\n        if (this.isObject(target[key]) && this.isObject(source[key])) {\n          target[key] = this.defaults(target[key], source[key]);\n        } else if (target[key] === undefined) {\n          target[key] = source[key];\n        }\n      }\n    });\n\n    return target;\n  }\n\n  public static isObject(value: any) {\n    return typeof(value) === 'object' && !Array.isArray(value);\n  }\n\n  public static async iframe({ url, redirectUrl, visible }: Common.IFrameOptions): Promise<any> {\n    const iframe = document.createElement('iframe');\n    iframe.setAttribute('owner', '@salte-auth/salte-auth');\n\n    if (visible) {\n      this.assign(iframe.style, {\n        border: 'none',\n        bottom: 0,\n        height: '100%',\n        left: 0,\n        position: 'fixed',\n        right: 0,\n        top: 0,\n        width: '100%',\n        zIndex: 9999,\n\n        opacity: 0,\n        transition: '0.5s opacity',\n      });\n\n      setTimeout(() => iframe.style.opacity = '1');\n    } else {\n      iframe.style.display = 'none';\n    }\n\n    iframe.src = url;\n    document.body.appendChild(iframe);\n\n    return new Promise((resolve, reject) => {\n      const checker = setInterval(() => {\n        try {\n          const { location } = iframe.contentWindow;\n          // This could throw cross-domain errors, so we need to silence them.\n          if (location.href.indexOf(redirectUrl) !== 0) return;\n          const parsed = URL.parse(location);\n\n          iframe.parentElement && iframe.parentElement.removeChild(iframe);\n          clearInterval(checker);\n          resolve(parsed);\n        } catch (error) {\n          if (Events.isCrossDomainError(error)) return;\n\n          iframe.parentElement && iframe.parentElement.removeChild(iframe);\n          clearInterval(checker);\n\n          reject(error);\n        }\n      });\n    });\n  }\n\n  public static debounce(identifier: string, callback: () => void, timeout?: number): void {\n    clearTimeout(debounces[identifier]);\n\n    debounces[identifier] = window.setTimeout(() => {\n      delete debounces[identifier];\n\n      callback();\n    }, timeout);\n  }\n}\n\nexport declare namespace Common {\n  export interface IFrameOptions {\n    url: string;\n    redirectUrl: string;\n    visible?: boolean;\n  }\n}\n\n\n","import { Common } from './common';\n\nexport class AccessToken {\n  public raw: string;\n  public expiration: number;\n  public type: string;\n\n  public constructor(accessToken: string, expiration: string, type: string) {\n    this.raw = accessToken;\n    this.expiration = Common.includes([undefined, null], expiration) ? null : Number(expiration);\n    this.type = type;\n  }\n\n  public get expired() {\n    return !this.raw || this.expiration <= Date.now();\n  }\n}\n","import { SalteAuthError } from '../base/core/salte-auth-error';\n\nexport class IDToken {\n  public raw: string;\n  public user: IDToken.UserInfo;\n\n  public constructor(idToken: string) {\n    this.raw = idToken;\n    this.user = IDToken.parse(this.raw);\n  }\n\n  public get expired() {\n    return !this.user || (this.user.exp * 1000) <= Date.now();\n  }\n\n  public static parse(idToken?: string): IDToken.UserInfo | null {\n    try {\n      const separated = idToken.split('.');\n\n      if (separated.length !== 3) {\n        throw new SalteAuthError({\n          code: 'invalid_id_token',\n          message: `ID Token didn't match the desired format. ({header}.{payload}.{validation})`,\n        });\n      }\n\n      // This fixes an issue where various providers will encode values\n      // incorrectly and cause the browser to fail to decode.\n      // https://stackoverflow.com/questions/43065553/base64-decoded-differently-in-java-jjwt\n      return JSON.parse(atob(separated[1].replace(/-/g, '+').replace(/_/g, '/')));\n    } catch (error) {\n      return null;\n    }\n  }\n}\n\nexport declare namespace IDToken {\n  export interface UserInfo {\n    /**\n     * Issuer Identifier for the Issuer of the response.\n     */\n    iss: string;\n\n    /**\n     * A locally unique and never reassigned identifier within the Provider for the End-User.\n     */\n    sub: string;\n\n    /**\n     * Audience(s) that this ID Token is intended for.\n     */\n    aud: string[];\n\n    /**\n     * Value used to mitigate replay attacks by associating a client session with an id_token.\n     */\n    nonce: string;\n\n    /**\n     * Expiration time on or after which the ID Token MUST NOT be accepted for processing.\n     *\n     * Represented as a unix epoch timestamp (seconds)\n     */\n    exp: number;\n\n    /**\n     * When the JWT was issued.\n     *\n     * Represented as a unix epoch timestamp (seconds)\n     */\n    iat: number;\n  }\n}\n\n","import { Common } from './common';\n\nexport class Logger {\n  private static levels: {\n    [key: string]: number;\n  } = {\n    trace: 0,\n    info: 1,\n    warn: 2,\n    error: 3\n  };\n\n  public name: string;\n  private level: number | boolean;\n\n  public constructor(name: string, level: string);\n  public constructor(name: string, level: boolean);\n  public constructor(name: string, level: string | boolean) {\n    this.name = name;\n    this.level = typeof(level) === 'string' ? this.toLevel(level) : level;\n  }\n\n  public trace(message: string, ...optionalParams: any[]) {\n    this.log('trace', message, ...optionalParams);\n  }\n\n  public info(message: string, ...optionalParams: any[]) {\n    this.log('info', message, ...optionalParams);\n  }\n\n  public warn(message: string, ...optionalParams: any[]) {\n    this.log('warn', message, ...optionalParams);\n  }\n\n  public error(message: string, ...optionalParams: any[]) {\n    this.log('error', message, ...optionalParams);\n  }\n\n  private log(level: string, message: string, ...optionalParams: any[]) {\n    if (this.enabled(level)) {\n      console.log(`${level}: ${message}`, ...optionalParams);\n    }\n  }\n\n  public enabled(level: string) {\n    if (this.level === false) return false;\n\n    return this.level === true || this.level <= this.toLevel(level);\n  }\n\n  public toLevel(name: string): number {\n    return Common.find(Logger.levels, (_level, key) => key === name);\n  }\n}\n","import { SalteAuthError } from './salte-auth-error';\n\nimport { Required } from './required';\n\nimport { Common } from '../../utils';\n\nexport class Storage extends Required {\n  public constructor(config?: Storage.Config) {\n    super(config);\n\n    this.config = Common.defaults(this.config, {\n      storage: 'session'\n    });\n  }\n\n  public get(key: string, defaultValue: string = null): string {\n    return this.storage.getItem(this.key(key)) || defaultValue;\n  }\n\n  public set(key: string, value?: any): void {\n    if (Common.includes([undefined, null], value)) {\n      this.clear(key);\n    } else {\n      this.storage.setItem(this.key(key), value);\n    }\n  }\n\n  public clear(key: string) {\n    this.storage.removeItem(this.key(key));\n  }\n\n  public reset(): void {\n    const baseKey = this.key('');\n    for (const key in localStorage) {\n      if (key.indexOf(baseKey) === 0) {\n        localStorage.removeItem(key);\n      }\n    }\n\n    for (const key in sessionStorage) {\n      if (key.indexOf(baseKey) === 0) {\n        sessionStorage.removeItem(key);\n      }\n    }\n  }\n\n  protected key(key?: string): string {\n    return `salte.auth.${key}`;\n  }\n\n  private get storage() {\n    const storage = this.config && this.config.storage;\n\n    switch (storage) {\n      case 'local': return localStorage;\n      case 'session': return sessionStorage;\n    }\n\n    throw new SalteAuthError({\n      code: 'invalid_storage',\n      message: `Storage doesn't exist for the given value. (${storage})`,\n    });\n  }\n}\n\nexport interface Storage {\n  config: Storage.Config;\n};\n\nexport declare namespace Storage {\n  export interface Config extends Required.Config {\n    /**\n     * The storage api to keep authenticate information stored in.\n     *\n     * @default 'session'\n     */\n    storage?: ('local'|'session');\n  }\n}\n","import { Storage } from './storage';\nimport { Common } from '../../utils';\n\nexport class Events extends Storage {\n  private listeners: Map<string, Function[]> = new Map();\n\n  public on(name: string, listener: Function) {\n    if (!this.listeners.has(name)) {\n      this.listeners.set(name, []);\n    }\n\n    const listeners = this.listeners.get(name);\n    listeners.push(listener);\n  }\n\n  public off(name: string, listener: Function) {\n    if (!this.listeners.has(name)) return;\n    const listeners = this.listeners.get(name);\n\n    if (!listeners.length) return;\n    const index = listeners.indexOf(listener);\n\n    if (index === -1) return;\n    listeners.splice(index, 1);\n  }\n\n  public emit(name: string, ...args: any[]) {\n    if (!this.listeners.has(name)) return;\n\n    const listeners = this.listeners.get(name);\n\n    Common.forEach(listeners, (listener) => listener(...args));\n  }\n}\n\nexport interface Events {\n  config: Events.Config;\n};\n\nexport declare namespace Events {\n  // TODO: What's the best way to forward a configuration?\n  export interface Config extends Storage.Config {} // eslint-disable-line\n}\n","import { Events } from './events';\n\nimport { Common } from '../../utils';\n\nexport class Shared extends Events {\n  public constructor(config?: Shared.Config) {\n    super(config);\n\n    this.config = Common.defaults(this.config, {\n      redirectUrl: location.origin,\n      level: 'warn'\n    });\n  }\n\n  /**\n   * Returns a redirect url for the given login type.\n   * @param type Are we logging in or logging out?\n   */\n  public redirectUrl(type: 'login'|'logout'): string {\n    if (typeof(this.config.redirectUrl) === 'string') {\n      return this.config.redirectUrl;\n    }\n\n    return this.config.redirectUrl[type];\n  }\n}\n\nexport interface Shared {\n  config: Shared.Config;\n}\n\nexport declare namespace Shared {\n  export interface Config extends Events.Config {\n    [key: string]: any;\n\n    /**\n     * URL the Provider will send the response back to.\n     */\n    redirectUrl?: string | RedirectUrl;\n  }\n\n  export interface RedirectUrl {\n    /**\n     * The URL the Provider will send the response back to on login.\n     */\n    login: string;\n\n    /**\n     * The URL the Provider will send the response back to on logout.\n     */\n    logout: string;\n  }\n}\n","if (process.env.NODE_ENV !== 'production') {\n  if (typeof self === 'undefined' || (!self.crypto && !self.msCrypto)) {\n    throw new Error(\n      'Your browser does not have secure random generator. ' +\n      'If you don’t need unpredictable IDs, you can use nanoid/non-secure.'\n    )\n  }\n}\n\nvar crypto = self.crypto || self.msCrypto\n\n/*\n * This alphabet uses a-z A-Z 0-9 _- symbols.\n * Symbols order was changed for better gzip compression.\n */\nvar url = 'Uint8ArdomValuesObj012345679BCDEFGHIJKLMNPQRSTWXYZ_cfghkpqvwxyz-'\n\nmodule.exports = function (size) {\n  size = size || 21\n  var id = ''\n  var bytes = crypto.getRandomValues(new Uint8Array(size))\n  while (0 < size--) {\n    id += url[bytes[size] & 63]\n  }\n  return id\n}\n","import { Shared } from './shared';\n\nimport { Common, Interceptors, Logger } from '../../utils';\nimport { SalteAuthError } from './salte-auth-error';\n\nexport class Provider extends Shared {\n  protected logger: Logger;\n\n  public constructor(config: Provider.Config) {\n    super(config);\n\n    this.config = Common.defaults(this.config, {\n      validation: true,\n      level: 'warn'\n    });\n    this.logger = new Logger(`@salte-auth/salte-auth:providers/${this.$name}`, this.config.level);\n  }\n\n  /**\n   * Determines if validation is enabled for the given key.\n   * @param key the key to determine whether validation is enabled for\n   * @returns whether validation is enabled for the key.\n   */\n  protected validation(key: string): boolean {\n    if (typeof(this.config.validation) === 'object') {\n      return this.config.validation[key] === true;\n    }\n\n    return this.config.validation === true;\n  }\n\n  /**\n   * The unique name of the provider\n   */\n  public get $name(): string {\n    return this.config.name || this.name;\n  }\n\n  /**\n   * Returns a scoped key for storage.\n   * @param key The storage key.\n   *\n   * @example auth0.key('hello') // 'salte.auth.provider.auth0.hello'\n   */\n  protected key(key: string) {\n    return `salte.auth.provider.${this.$name}.${key}`;\n  }\n\n  /**\n   * Creates a url with the given query parameters\n   * @param base the base url without query parameters\n   * @param params the query parameters to attache to the url\n   * @returns the built url\n   */\n  protected url(base: string, params: object = {}): string {\n    let url = base;\n\n    Common.forEach(params, (value, key) => {\n      if (Common.includes([undefined, null, ''], value)) return;\n\n      url += `${url.indexOf('?') === -1 ? '?' : '&'}${key}=${encodeURIComponent(value)}`;\n    });\n\n    return url;\n  }\n\n  /**\n   * Returns the logout url for the provider.\n   */\n  public get logout(): string {\n    throw new SalteAuthError({\n      code: 'logout_not_supported',\n      message: `This provider doesn't support logout.`,\n    });\n  }\n}\n\nexport interface Provider {\n  /**\n   * The unique name of the provider\n   */\n  name: string;\n\n  /**\n   * Returns the login url for the provider.\n   */\n  login: string;\n\n  /**\n   * An internal login command to `salte-auth` that enables enhancing the login with common parameters.\n   */\n  $login(options?: object): string;\n\n  validate(options: object | void): void;\n\n  /**\n   * Checks for errors returned from the provider.\n   */\n  $validate(options: object): void;\n\n  /**\n   * Reinitializes the ID and Access Tokens of the given provider.\n   */\n  sync(): void;\n\n  /**\n   * Invoked when Salte Auth is initialized\n   */\n  connected?(): void;\n\n  /**\n   * Invoked when an endpoint is marked as secured.\n   * @returns true if the endpoint is already secured, otherwise it returns a url to secure the endpoint.\n   */\n  secure?(request?: Interceptors.XHR.ExtendedXMLHttpRequest | Request): Promise<string | boolean>;\n\n  on(name: 'login', listener: (error?: Error, data?: any) => void): void;\n  on(name: 'logout', listener: (error?: Error) => void): void;\n}\n\nexport interface Provider {\n  config: Provider.Config;\n};\n\nexport declare namespace Provider {\n  export interface Config extends Shared.Config {\n    /**\n     * The name associated with your provider\n     */\n    name?: string;\n\n    /**\n     * The url of the designated provider.\n     */\n    url?: string;\n\n    /**\n     * Used to disable certain security validations if your provider doesn't support them.\n     *\n     * @default true\n     */\n    validation?: ValidationOptions | boolean;\n\n    /**\n     * The routes to secure for this provider.\n     */\n    routes?: (string | RegExp)[] | boolean;\n\n    /**\n     * The endpoints to secure for this provider.\n     */\n    endpoints?: (string | RegExp)[];\n\n    /**\n     * Determines the level of verbosity of the logs.\n     *\n     * @default 'warn'\n     */\n    level?: ('error'|'warn'|'info'|'trace');\n  }\n\n  export interface ValidationOptions {\n    [key: string]: boolean;\n  }\n}\n","import nanoid from 'nanoid';\n\nimport { AccessToken, Common, Interceptors } from '../utils';\nimport { Provider } from './core/provider';\nimport { SalteAuthError } from './core/salte-auth-error';\n\nexport class OAuth2Provider extends Provider {\n  public accessToken?: AccessToken;\n\n  public constructor(config?: OAuth2Provider.Config) {\n    super(config);\n\n    this.sync();\n  }\n\n  public connected() {\n    this.required('clientID', 'responseType');\n  }\n\n  public async secure(request: Interceptors.XHR.ExtendedXMLHttpRequest | Request): Promise<string | boolean> {\n    if (this.config.responseType === 'token') {\n      if (this.accessToken.expired) {\n        return this.$login();\n      }\n\n      if (request) {\n        if (request instanceof Request) {\n          request.headers.set('Authorization', `Bearer ${this.accessToken.raw}`);\n        } else if (request instanceof XMLHttpRequest) {\n          request.setRequestHeader('Authorization', `Bearer ${this.accessToken.raw}`);\n        } else {\n          throw new SalteAuthError({\n            code: 'unknown_request',\n            message: `Unknown request type. (${request})`,\n          });\n        }\n      }\n    }\n\n    return true;\n  }\n\n  public $validate(options: OAuth2Provider.Validation): void {\n    try {\n      if (!options) {\n        throw new SalteAuthError({\n          code: 'empty_response',\n          message: `The response provided was empty, this is most likely due to the configured handler not providing it.`\n        });\n      }\n\n      if (options.error) {\n        throw new SalteAuthError({\n          code: options.error,\n          message: `${options.error_description ? options.error_description : options.error}${options.error_uri ? ` (${options.error_uri})` : ''}`,\n        });\n      }\n\n      const { code, access_token, state, expires_in, token_type } = options;\n\n      if (this.validation('state') && this.get('state') !== state) {\n        throw new SalteAuthError({\n          code: 'invalid_state',\n          message: 'State provided by identity provider did not match local state.',\n        });\n      }\n\n      const types = this.get('response-type', '').split(' ');\n      if (Common.includes(types, 'code')) {\n        if (!code) {\n          throw new SalteAuthError({\n            code: 'invalid_code',\n            message: 'Expected a code to be returned by the Provider.',\n          });\n        }\n      } else if (Common.includes(types, 'token')) {\n        if (!access_token) {\n          throw new SalteAuthError({\n            code: 'invalid_access_token',\n            message: 'Expected an access token to be returned by the Provider.',\n          });\n        }\n      }\n\n      if (code) {\n        this.set('code.raw', code);\n        this.clear('access-token.raw');\n        this.clear('access-token.expiration');\n        this.clear('access-token.type');\n      } else if (access_token) {\n        this.set('access-token.raw', access_token);\n        this.set('access-token.expiration', Date.now() + (Number(expires_in) * 1000));\n        this.set('access-token.type', token_type);\n        this.clear('code.raw');\n      }\n    } finally {\n      this.clear('state');\n    }\n  }\n\n  public validate(options: OAuth2Provider.Validation) {\n    try {\n      this.$validate(options);\n    } catch (error) {\n      this.emit('login', error);\n      throw error;\n    } finally {\n      this.sync();\n    }\n\n    this.emit('login', null, this.code || this.accessToken);\n  }\n\n  public get code() {\n    return this.get('code.raw');\n  }\n\n  public $login(options: OAuth2Provider.OverrideOptions = {}): string {\n    const state = `${this.$name}-state-${nanoid()}`;\n    const responseType = options.responseType || this.config.responseType;\n\n    this.set('state', state);\n    this.set('response-type', responseType);\n\n    return this.url(this.login, {\n      client_id: this.config.clientID,\n      response_type: responseType,\n      redirect_uri: this.config.redirectUrl,\n      scope: this.config.scope,\n      state\n    });\n  }\n\n  public sync() {\n    this.accessToken = new AccessToken(\n      this.get('access-token.raw'),\n      this.get('access-token.expiration'),\n      this.get('access-token.type')\n    );\n  }\n}\n\nexport interface OAuth2Provider {\n  config: OAuth2Provider.Config;\n\n  on(name: 'login', listener: (error?: Error, accessToken?: AccessToken) => void): void;\n  on(name: 'login', listener: (error?: Error, code?: string) => void): void;\n  on(name: 'logout', listener: (error?: Error) => void): void;\n}\n\nexport declare namespace OAuth2Provider {\n  export interface Config extends Provider.Config {\n    /**\n     * Determines whether a authorization code (server) or access token (client) should be returned.\n     * @type {('code'|'token')}\n     */\n    responseType?: string;\n\n    /**\n     * A list of space-delimited claims used to determine what user information is provided and what access is given.\n     */\n    scope?: string;\n\n    /**\n     * The client id of your identity provider\n     */\n    clientID: string;\n\n    validation?: boolean | ValidationOptions;\n  }\n\n  export interface OverrideOptions {\n    /**\n     * Determines whether a authorization code (server) or access token (client) should be returned.\n     * @type {('code'|'token')}\n     */\n    responseType?: string;\n  }\n\n  export interface ValidationOptions extends Provider.ValidationOptions {\n    /**\n     * Disables cross-site forgery validation via \"state\".\n     */\n    state: boolean;\n  }\n\n  export interface Validation {\n    /**\n     * An error code sent from the Provider\n     */\n    error: ('unauthorized_client'|'access_denied'|'unsupported_response_type'|'invalid_scope'|'server_error'|'temporarily_unavailable');\n\n    /**\n     * Human-readable message sent back by the Provider.\n     */\n    error_description?: string;\n\n    /**\n     * A URI to a human-readable web page with information about the error.\n     */\n    error_uri?: string;\n\n    /**\n     * A value sent back by the server to the client.\n     *\n     * Used to prevent cross-site request forgery.\n     */\n    state: string;\n\n    /**\n     * The authorization code generated by the Provider.\n     *\n     * Generally used by a backend server to generate an access token.\n     */\n    code: string;\n\n    /**\n     * The access token issued by the Provider.\n     */\n    access_token: string;\n\n    /**\n     * The type of the token issued.\n     */\n    token_type: ('bearer'|'mac');\n\n    /**\n     * The lifetime (in seconds) of the access_token.\n     *\n     * For example, the value \"3600\" denotes that the access token will\n     * expire in one hour from the time the response was generated.\n     */\n    expires_in: string;\n  }\n}\n","import nanoid from 'nanoid';\n\nimport { OAuth2Provider } from './provider-oauth2';\n\nimport { SalteAuthError } from './core/salte-auth-error';\n\nimport { Common, IDToken, Interceptors } from '../utils';\n\nexport class OpenIDProvider extends OAuth2Provider {\n  public idToken?: IDToken;\n\n  public constructor(config?: OpenIDProvider.Config) {\n    super(config);\n\n    this.config.renewal = typeof(this.config.renewal) === 'object' ? this.config.renewal : { type: this.config.renewal };\n\n    this.config = Common.defaults(this.config, {\n      responseType: 'id_token',\n      scope: 'openid',\n      renewal: {\n        type: 'auto',\n        buffer: 60000\n      }\n    });\n\n    this.sync();\n  }\n\n  public async secure(request: Interceptors.XHR.ExtendedXMLHttpRequest | Request): Promise<string | boolean> {\n    if (Common.includes(['id_token', 'id_token token', 'token'], this.config.responseType)) {\n      if (this.idToken.expired) {\n        return this.$login();\n      }\n\n      if (this.accessToken.expired) {\n        const parsed = await Common.iframe({\n          redirectUrl: this.redirectUrl('login'),\n          url: this.$login({\n            prompt: 'none',\n            responseType: 'token',\n          }),\n        });\n\n        this.validate(parsed);\n      }\n\n      if (request) {\n        if (request instanceof Request) {\n          request.headers.set('Authorization', `Bearer ${this.accessToken.raw}`);\n        } else if (request instanceof XMLHttpRequest) {\n          request.setRequestHeader('Authorization', `Bearer ${this.accessToken.raw}`);\n        } else {\n          throw new SalteAuthError({\n            code: 'unknown_request',\n            message: `Unknown request type. (${request})`,\n          });\n        }\n      }\n    }\n\n    return true;\n  }\n\n  public $validate(options: OpenIDProvider.Validation): void {\n    try {\n      super.$validate(options);\n\n      const types = this.get('response-type', '').split(' ');\n      if (Common.includes(types, 'id_token')) {\n        const { id_token } = options;\n\n        const user = IDToken.parse(id_token);\n\n        if (!user) {\n          throw new SalteAuthError({\n            code: 'invalid_id_token',\n            message: 'Failed to parse user information due to invalid id token.',\n          });\n        }\n\n        if (this.validation('nonce') && this.get('nonce') !== user.nonce) {\n          throw new SalteAuthError({\n            code: 'invalid_nonce',\n            message: 'Nonce provided by identity provider did not match the local nonce.',\n          });\n        }\n\n        this.set('id-token.raw', id_token);\n      } else if (Common.includes(types, 'code')) {\n        this.clear('id-token.raw');\n      }\n    } finally {\n      this.clear('nonce');\n    }\n  }\n\n  public validate(options: OpenIDProvider.Validation): any {\n    try {\n      this.$validate(options);\n    } catch (error) {\n      this.emit('login', error);\n      throw error;\n    } finally {\n      this.sync();\n    }\n\n    const responseType = this.get('response-type', '');\n    const types = responseType.split(' ');\n    if (Common.includes(types, 'id_token')) {\n      this.emit('login', null, this.idToken);\n    } else if (Common.includes(types, 'token')) {\n      this.emit('login', null, this.accessToken);\n    } else if (Common.includes(types, 'code')) {\n      this.emit('login', null, this.code);\n    } else {\n      throw new SalteAuthError({\n        code: 'invalid_response_type',\n        message: `Unknown Response Type (${responseType})`\n      });\n    }\n  }\n\n  public $login(options?: OpenIDProvider.OverrideOptions): string {\n    const nonce = `${this.$name}-nonce-${nanoid()}`;\n\n    this.set('nonce', nonce);\n\n    return this.url(super.$login(options), {\n      prompt: options && options.prompt,\n      nonce\n    });\n  }\n\n  public sync() {\n    super.sync();\n\n    this.idToken = new IDToken(this.get('id-token.raw'));\n  }\n}\n\nexport interface OpenIDProvider {\n  config: OpenIDProvider.Config;\n\n  // TODO: Fix this\n  // on(name: 'login', listener: (error?: Error, user?: IDToken) => void): void;\n  // on(name: 'logout', listener: (error?: Error) => void): void;\n}\n\nexport declare namespace OpenIDProvider {\n  export interface Config extends OAuth2Provider.Config {\n    /**\n     * Determines whether a authorization code (server) or id token (client) should be returned.\n     */\n    responseType?: ('id_token'|'id_token token'|'code');\n\n    validation?: boolean | ValidationOptions;\n\n    /**\n     * Determines whether token renewal should be handled automatically or manually.\n     *\n     * @default 'auto'\n     */\n    renewal?: ('auto'|'manual'| {\n      type?: ('auto'|'manual');\n      /**\n       * The amount of time prior to experation to renew the `id_token`.\n       *\n       * @default 60000\n       */\n      buffer?: number;\n    });\n  }\n\n  export interface ValidationOptions extends OAuth2Provider.ValidationOptions {\n    /**\n     * Disables replay attack mitigation via \"nonce\".\n     */\n    nonce: boolean;\n  }\n\n  export interface OverrideOptions extends OAuth2Provider.OverrideOptions {\n    /**\n     * Indicate that the Provider shouldn't display any user interaction.\n     */\n    prompt?: ('none'|'login'|'consent'|'select_account');\n  }\n\n  export interface Validation extends OAuth2Provider.Validation {\n    /**\n     * A JSON Web Token (JWT) that contains user profile information\n     */\n    id_token: string;\n  }\n}\n","import { OAuth2Provider } from './base/provider-oauth2';\nimport { OpenIDProvider } from './base/provider-openid';\n\nexport class OAuth2 extends OAuth2Provider {\n  constructor(config: OAuth2.Config) {\n    super(config);\n\n    this.required('login');\n  }\n\n  get name(): string {\n    return 'generic.oauth2';\n  }\n\n  get login(): string {\n    return this.config.login.apply(this);\n  }\n}\n\nexport interface OAuth2 {\n  config: OAuth2.Config;\n};\n\nexport declare namespace OAuth2 {\n  export interface Config extends OAuth2Provider.Config {\n    login(): string;\n  }\n}\n\nexport class OpenID extends OpenIDProvider {\n  constructor(config: OpenID.Config) {\n    super(config);\n\n    this.required('login', 'logout');\n  }\n\n  get name(): string {\n    return 'generic.openid';\n  }\n\n  get login(): string {\n    return this.config.login.apply(this);\n  }\n\n  get logout(): string {\n    return this.config.logout.apply(this);\n  }\n}\n\nexport interface OpenID {\n  config: OpenID.Config;\n};\n\nexport declare namespace OpenID {\n  export interface Config extends OpenIDProvider.Config {\n    login(): string;\n    logout(): string;\n  }\n}\n","import { Storage } from './core/storage';\nimport { Common, Logger, URL } from '../utils';\n\nexport class Handler extends Storage {\n  protected logger: Logger;\n\n  public constructor(config?: Handler.Config) {\n    super(config);\n\n    this.config = Common.defaults(this.config, {\n      navigate: 'reload',\n      level: 'warn'\n    });\n    this.logger = new Logger(`@salte-auth/salte-auth:handlers/${this.$name}`, this.config.level);\n  }\n\n  /**\n   * The unique name of the handler\n   */\n  public get $name() {\n    return this.config.name || this.name;\n  }\n\n  /**\n   * Returns a scoped key for storage.\n   * @param key The storage key.\n   *\n   * @example redirect.key('hello') // 'salte.auth.handler.redirect.hello'\n   */\n  protected key(key: string) {\n    return `salte.auth.handler.${this.$name}.${key}`;\n  }\n\n  /**\n   * Navigates to the url provided.\n   * @param url the url to navigate to\n   */\n  /* istanbul ignore next */\n  protected navigate(url: string) {\n    if (this.config.navigate === 'history' && url.indexOf(URL.origin) === 0) {\n      history.pushState('', document.title, url);\n    }\n\n    location.href = url;\n  }\n}\n\nexport interface Handler {\n  config: Handler.Config;\n\n  /**\n   * The unique name of the handler\n   */\n  name: string;\n\n  /**\n   * Determines whether the handler supports automatic login.\n   */\n  auto: boolean;\n\n  open(options: Handler.OpenOptions): Promise<object>;\n  connected?(options: Handler.ConnectedOptions): object | void;\n}\n\nexport declare namespace Handler {\n  export interface Config extends Storage.Config {\n    /**\n     * Overrides the default name of the handler.\n     */\n    name?: string;\n\n    /**\n     * Dictates that this is the default handler.\n     */\n    default?: boolean;\n\n    /**\n     * Determines how page navigations are interpreted by this handler.\n     *\n     * * **reload:** Reloads the whole page when `navigate` is invoked.\n     * * **history:** Utilizes the history api to prevent page reloads when possible.\n     *\n     * @default 'reload'\n     */\n    navigate?: ('reload'|'history');\n\n    /**\n     * Determines the level of verbosity of the logs.\n     *\n     * @default 'warn'\n     */\n    level?: ('error'|'warn'|'info'|'trace');\n  }\n\n  export interface ConnectedOptions {\n    action?: string;\n  }\n\n  export interface OpenOptions {\n    url: string;\n    redirectUrl: string;\n  }\n}\n","import { AuthMixinGenerator, SalteAuthMixedIn, Constructor } from './mixins/auth';\nimport { Shared } from './base/core/shared';\nimport * as Generic from './generic';\nimport * as Utils from './utils';\nimport { Common, Events, Interceptors, URL, IDToken, Logger } from './utils';\n\nimport { Provider } from './base/core/provider';\nimport { SalteAuthError } from './base/core/salte-auth-error';\nimport { Handler } from './base/handler';\n\nexport class SalteAuth extends Shared {\n  public logger: Logger;\n  public mixin: (base: Constructor) => SalteAuthMixedIn;\n\n  public constructor(config: SalteAuth.Config) {\n    super(config);\n\n    this.required('providers', 'handlers');\n\n    this.config = Common.defaults(this.config, {\n      validation: true,\n      level: 'warn'\n    });\n\n    this.logger = new Logger(`@salte-auth/salte-auth:core`, this.config.level);\n\n    Common.forEach(this.config.providers, (provider) => {\n      provider.connected && provider.connected();\n\n      provider.on('login', (error, data) => {\n        this.emit('login', error, data);\n      });\n\n      provider.on('logout', (error) => {\n        this.emit('logout', error);\n      });\n    });\n\n    const action = this.get('action');\n    const provider = action ? this.provider(this.get('provider')) : null;\n    const handlerName = action ? this.get('handler') : null;\n\n    if (!Common.includes([undefined, null, 'login', 'logout'], action)) {\n      throw new SalteAuthError({\n        code: 'unknown_action',\n        message: `Unable to finish redirect due to an unknown action! (${action})`,\n      });\n    }\n\n    Common.forEach(this.config.handlers, (handler) => {\n      if (!handler.connected) return;\n\n      const responsible = handler.$name === handlerName;\n\n      setTimeout(() => {\n        const parsed = handler.connected({ action: responsible ? action : null });\n\n        if (!responsible) return;\n\n        if (action === 'login') {\n          provider.validate(parsed);\n        } else {\n          provider.reset();\n          provider.sync();\n          provider.emit('logout');\n        }\n      });\n    });\n\n    this.clear('action');\n    this.clear('provider');\n    this.clear('handler');\n\n    Interceptors.Fetch.add(async (request) => {\n      for (let i = 0; i < this.config.providers.length; i++) {\n        const provider = this.config.providers[i];\n\n        if (URL.match(request.url, provider.config.endpoints)) {\n          provider.secure && await provider.secure(request);\n        }\n      }\n    });\n\n    Interceptors.XHR.add(async (request) => {\n      for (let i = 0; i < this.config.providers.length; i++) {\n        const provider = this.config.providers[i];\n\n        if (URL.match(request.$url, provider.config.endpoints)) {\n          provider.secure && await provider.secure(request);\n        }\n      }\n    });\n\n    Events.route(async () => {\n      try {\n        const handler = this.handler();\n\n        for (let i = 0; i < this.config.providers.length; i++) {\n          const provider = this.config.providers[i];\n\n          if (URL.match(location.href, provider.config.routes)) {\n            let response: string | boolean = null;\n\n            while (response !== true) {\n              response = await provider.secure();\n\n              if (typeof(response) === 'string') {\n                if (!handler.auto) {\n                  throw new SalteAuthError({\n                    code: 'auto_unsupported',\n                    message: `The default handler doesn't support automatic authentication! (${handler.$name})`,\n                  });\n                }\n\n                this.set('action', 'login');\n                this.set('provider', provider.$name);\n                this.set('handler', handler.$name);\n\n                const params = await handler.open({\n                  redirectUrl: provider.redirectUrl('login'),\n                  url: response,\n                });\n\n                provider.validate(params);\n\n                this.clear('action');\n                this.clear('provider');\n                this.clear('handler');\n              }\n            }\n          }\n        }\n      } catch (error) {\n        this.clear('action');\n        this.clear('provider');\n        this.clear('handler');\n        throw error;\n      }\n    });\n\n    this.mixin = AuthMixinGenerator(this);\n  }\n\n  /**\n   * Login to the specified provider.\n   *\n   * @param options the authentication options\n   */\n  public async login(options: SalteAuth.AuthOptions): Promise<void>;\n  /**\n   * Login to the specified provider.\n   *\n   * @param provider the provider to login with\n   */\n  public async login(provider: string): Promise<void>;\n  public async login(options: SalteAuth.AuthOptions | string): Promise<void> {\n    options = typeof(options) === 'string' ? { provider: options } : options;\n\n    try {\n      const provider = this.provider(options.provider);\n      const handler = this.handler(options.handler);\n\n      this.set('action', 'login');\n      this.set('provider', provider.$name);\n      this.set('handler', handler.$name);\n\n      const params = await handler.open({\n        redirectUrl: provider.redirectUrl('login'),\n        url: provider.$login(),\n      });\n\n      provider.validate(params);\n    } finally {\n      this.clear('action');\n      this.clear('provider');\n      this.clear('handler');\n    }\n  }\n\n  /**\n   * Logout of the specified provider.\n   *\n   * @param options the authentication options\n   */\n  public async logout(options: SalteAuth.AuthOptions): Promise<void>;\n  /**\n   * Logout of the specified provider.\n   *\n   * @param provider the provider to logout of\n   */\n  public async logout(provider: string): Promise<void>;\n  public async logout(options: SalteAuth.AuthOptions | string): Promise<void> {\n    options = typeof(options) === 'string' ? { provider: options } : options;\n\n    const provider = this.provider(options.provider);\n    try {\n      const handler = this.handler(options.handler);\n\n      this.set('action', 'logout');\n      this.set('provider', provider.$name);\n      this.set('handler', handler.$name);\n\n      await handler.open({\n        redirectUrl: provider.redirectUrl('logout'),\n        url: provider.logout,\n      });\n\n      provider.reset();\n      provider.emit('logout');\n    } catch (error) {\n      provider.emit('logout', error);\n      throw error;\n    } finally {\n      this.clear('action');\n      this.clear('provider');\n      this.clear('handler');\n    }\n  }\n\n  /**\n   * Returns a provider that matches the given name.\n   * @param name the name of the provider\n   * @returns the provider with the given name.\n   */\n  public provider(name?: string): Provider {\n    const provider = Common.find(this.config.providers, (provider) => provider.$name === name);\n\n    if (!provider) {\n      throw new SalteAuthError({\n        code: 'invalid_provider',\n        message: `Unable to locate provider with the given name. (${name})`,\n      });\n    }\n\n    return provider;\n  }\n\n  /**\n   * Returns a handler that matches the given name.\n   * @param name the name of the handler\n   * @returns the handler with the given name, if no name is specified then the default handler.\n   */\n  public handler(name?: string): Handler {\n    const handler = name === undefined ?\n      Common.find(this.config.handlers, (handler) => !!handler.config.default) :\n      Common.find(this.config.handlers, (handler) => handler.$name === name)\n\n    if (!handler) {\n      throw new SalteAuthError({\n        code: 'invalid_handler',\n        message: `Unable to locate handler with the given name. (${name})`,\n      });\n    }\n\n    return handler;\n  }\n}\n\nexport interface SalteAuth {\n  config: SalteAuth.Config;\n  on(name: 'login', listener: (error?: Error, data?: SalteAuth.EventWrapper) => void): void;\n  on(name: 'logout', listener: (error?: Error, data?: SalteAuth.EventWrapper) => void): void;\n}\n\nexport declare namespace SalteAuth {\n  interface Config extends Shared.Config {\n    providers: Provider[];\n\n    handlers: Handler[];\n\n    /**\n     * Determines the level of verbosity of the logs.\n     *\n     * @default 'warn'\n     */\n    level?: ('error'|'warn'|'info'|'trace');\n  }\n\n  interface EventWrapper {\n    provider: string;\n    data?: IDToken.UserInfo | string;\n  }\n\n  interface AuthOptions {\n    provider: string;\n    handler?: string;\n  }\n}\n\nexport { SalteAuthError } from './base/core/salte-auth-error';\nexport { OAuth2Provider } from './base/provider-oauth2';\nexport { OpenIDProvider } from './base/provider-openid';\nexport { Handler, Utils, Generic };\n","import { SalteAuth } from '../salte-auth';\n\nexport type SalteAuthMixedIn<T = {\n  auth: SalteAuth;\n}> = new (...args: any[]) => T;\n\nexport type Constructor<T = {\n  requestUpdate?(field: string): void;\n}> = new (...args: any[]) => T;\n\nexport function AuthMixinGenerator(auth: SalteAuth) {\n  return function<TBase extends Constructor>(Base: TBase): SalteAuthMixedIn {\n    return class extends Base {\n      public auth: SalteAuth;\n\n      public constructor(...args: any[]) {\n        super(...args);\n\n        this.auth = auth;\n\n        this.auth.on('login', () => {\n          if (this.requestUpdate) this.requestUpdate('auth');\n        });\n\n        this.auth.on('logout', () => {\n          if (this.requestUpdate) this.requestUpdate('auth');\n        });\n      }\n    };\n  };\n}\n"],"names":["asyncGeneratorStep","gen","resolve","reject","_next","_throw","key","arg","info","value","error","done","Promise","then","fn","self","this","args","arguments","apply","err","undefined","obj","Object","defineProperty","enumerable","configurable","writable","SalteAuthError","Error","constructor","message","code","Required","config","required","keys","missing","filter","length","join","Fetch","force","hasSetup","interceptors","real","window","fetch","input","options","request","Request","i","interceptor","call","setup","push","callbacks","onRouteChange","forEach","callback","Events","addEventListener","passive","setTimeout","name","params","event","document","createEvent","initEvent","bubbles","cancelable","detail","e","DOMException","XHR","realOpen","XMLHttpRequest","prototype","open","realSend","send","requestPrototype","url","$url","data","promises","all","catch","dispatchEvent","create","arr","Array","isArray","_arr","_n","_d","_e","_s","_i","Symbol","iterator","next","TypeError","arrayWithHoles","iterableToArrayLimit","nonIterableRest","urlDocument","base","anchor","URL","location","protocol","host","path","implementation","createHTMLDocument","createElement","head","appendChild","href","replace","tests","resolvedUrl","Common","find","test","RegExp","match","indexOf","search","hash","concat","split","parsed","param","debounces","source","cb","item","target","sources","isObject","defaults","redirectUrl","visible","iframe","setAttribute","_this","assign","style","border","bottom","height","left","position","right","top","width","zIndex","opacity","transition","display","src","body","checker","setInterval","contentWindow","parse","parentElement","removeChild","clearInterval","isCrossDomainError","identifier","timeout","clearTimeout","AccessToken","accessToken","expiration","type","raw","includes","Number","Date","now","IDToken","idToken","user","exp","separated","JSON","atob","Logger","level","toLevel","trace","optionalParams","log","warn","enabled","console","levels","_level","Storage","storage","get","defaultValue","getItem","set","clear","setItem","removeItem","reset","baseKey","localStorage","sessionStorage","Map","on","listener","listeners","has","off","index","splice","emit","Shared","origin","crypto","msCrypto","size","id","bytes","getRandomValues","Uint8Array","Provider","validation","logger","$name","encodeURIComponent","OAuth2Provider","sync","connected","secure","responseType","expired","$login","headers","setRequestHeader","$validate","error_description","error_uri","access_token","state","expires_in","token_type","types","validate","nanoid","login","client_id","clientID","response_type","redirect_uri","scope","OpenIDProvider","renewal","buffer","prompt","id_token","nonce","super","logout","Handler","navigate","history","pushState","title","SalteAuth","providers","provider","action","handlerName","auth","handlers","handler","responsible","Interceptors","add","endpoints","route","routes","response","auto","mixin","Base","requestUpdate","_this2","_this3","default"],"mappings":"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"}