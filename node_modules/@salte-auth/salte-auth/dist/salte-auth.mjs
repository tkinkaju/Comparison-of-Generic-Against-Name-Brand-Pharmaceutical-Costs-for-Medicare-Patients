
/**
 * @salte-auth/salte-auth JavaScript Library v3.0.0-rc.8
 *
 * @license MIT (https://github.com/salte-auth/salte-auth/blob/master/LICENSE)
 *
 * Made with â™¥ by Nick Woodward <nick@salte.io>, Dave Woodward <dave@salte.io>
 */

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

var asyncToGenerator = _asyncToGenerator;

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

var defineProperty = _defineProperty;

function AuthMixinGenerator(auth) {
  return function (Base) {
    var _temp;

    return _temp = class extends Base {
      constructor() {
        super(...arguments);

        defineProperty(this, "auth", void 0);

        this.auth = auth;
        this.auth.on('login', () => {
          if (this.requestUpdate) this.requestUpdate('auth');
        });
        this.auth.on('logout', () => {
          if (this.requestUpdate) this.requestUpdate('auth');
        });
      }

    }, _temp;
  };
}

class SalteAuthError extends Error {
  constructor(_ref) {
    let message = _ref.message,
        code = _ref.code;
    super(message);

    defineProperty(this, "code", void 0);

    this.code = code;
  }

}

class Required {
  constructor(config) {
    this.config = config || {};
  }

  required() {
    for (var _len = arguments.length, keys = new Array(_len), _key = 0; _key < _len; _key++) {
      keys[_key] = arguments[_key];
    }

    const missing = keys.filter(key => {
      return this.config[key] === undefined;
    });

    if (missing.length > 0) {
      throw new SalteAuthError({
        code: 'missing_required_properties',
        message: "Missing the following required fields. (".concat(missing.join(', '), ")")
      });
    }
  }

}

class Fetch {
  static setup(force) {
    if (this.hasSetup && !force) return;
    this.hasSetup = true;
    this.interceptors = [];
    if (!this.real) this.real = window.fetch;

    if (window.fetch) {
      window.fetch =
      /*#__PURE__*/
      function () {
        var _ref = asyncToGenerator(function* (input, options) {
          const request = input instanceof Request ? input : new Request(input, options);

          for (let i = 0; i < Fetch.interceptors.length; i++) {
            const interceptor = Fetch.interceptors[i];
            yield Promise.resolve(interceptor(request));
          }

          return Fetch.real.call(this, request);
        });

        return function (_x, _x2) {
          return _ref.apply(this, arguments);
        };
      }();
    }
  }

  static add(interceptor) {
    this.setup();
    this.interceptors.push(interceptor);
  }

}

defineProperty(Fetch, "real", void 0);

defineProperty(Fetch, "hasSetup", false);

defineProperty(Fetch, "interceptors", void 0);

let setup = false;
const callbacks = [];

function onRouteChange() {
  callbacks.forEach(callback => callback());
}

class Events {
  static route(callback) {
    if (!setup) {
      window.addEventListener('popstate', onRouteChange, {
        passive: true
      });
      window.addEventListener('click', onRouteChange, {
        passive: true
      });
      setTimeout(onRouteChange);
      setup = true;
    }

    callbacks.push(callback);
  }

  static create(name, params) {
    const event = document.createEvent('Event');
    event.initEvent(name, params.bubbles || false, params.cancelable || true);
    event.detail = params.detail;
    return event;
  }

  static isCrossDomainError(e) {
    return e instanceof DOMException || e.message === 'Permission denied';
  }

}

class XHR {
  static setup(force) {
    if (this.hasSetup && !force) return;
    this.hasSetup = true;
    this.interceptors = [];
    if (!this.realOpen) this.realOpen = XMLHttpRequest.prototype.open;
    if (!this.realSend) this.realSend = XMLHttpRequest.prototype.send;
    const requestPrototype = XMLHttpRequest.prototype;

    requestPrototype.open = function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      const url = args[1];
      this.$url = url;
      return XHR.realOpen.apply(this, args);
    };

    requestPrototype.send = function (data) {
      const promises = [];

      for (let i = 0; i < XHR.interceptors.length; i++) {
        const interceptor = XHR.interceptors[i];
        promises.push(interceptor(this, data));
      }

      Promise.all(promises).then(() => {
        XHR.realSend.call(this, data);
      }).catch(error => {
        this.dispatchEvent(Events.create('error', {
          detail: error
        }));
      });
    };
  }

  static add(interceptor) {
    this.setup();
    this.interceptors.push(interceptor);
  }

}

defineProperty(XHR, "realOpen", void 0);

defineProperty(XHR, "realSend", void 0);

defineProperty(XHR, "hasSetup", false);

defineProperty(XHR, "interceptors", void 0);



var index = /*#__PURE__*/Object.freeze({
  Fetch: Fetch,
  XHR: XHR
});

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

var arrayWithHoles = _arrayWithHoles;

function _iterableToArrayLimit(arr, i) {
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

var iterableToArrayLimit = _iterableToArrayLimit;

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}

var nonIterableRest = _nonIterableRest;

function _slicedToArray(arr, i) {
  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || nonIterableRest();
}

var slicedToArray = _slicedToArray;

let urlDocument;
let base;
let anchor;
class URL {
  /**
   * Outputs a result equivalent to `location.origin`
   */
  static get origin() {
    return "".concat(location.protocol, "//").concat(location.host);
  }

  static resolve(path) {
    if (!urlDocument) {
      urlDocument = document.implementation.createHTMLDocument('url');
      base = urlDocument.createElement('base');
      anchor = urlDocument.createElement('a');
      urlDocument.head.appendChild(base);
    }

    base.href = window.location.protocol + '//' + window.location.host;
    anchor.href = path.replace(/ /g, '%20');
    return anchor.href.replace(/\/$/, '');
  }

  static match(url, tests) {
    if (tests instanceof Array) {
      const resolvedUrl = this.resolve(url);
      const match = Common.find(tests, test => {
        if (test instanceof RegExp) {
          return !!resolvedUrl.match(test);
        }

        return resolvedUrl.indexOf(this.resolve(test)) === 0;
      });
      return !!match;
    }

    return tests === true;
  }

  static parse(_ref) {
    let search = _ref.search,
        hash = _ref.hash;
    let params = [];
    if (search) params = params.concat(search.replace('?', '').split('&'));
    if (hash) params = params.concat(hash.replace('#', '').split('&'));
    const parsed = {};
    Common.forEach(params, param => {
      const _param$split = param.split('='),
            _param$split2 = slicedToArray(_param$split, 2),
            key = _param$split2[0],
            value = _param$split2[1];

      parsed[key] = value;
    });
    return parsed;
  }

}

const debounces = {};
class Common {
  static includes(source, value) {
    return source.indexOf(value) !== -1;
  }

  static forEach(source, cb) {
    if (Array.isArray(source)) {
      for (let i = 0; i < source.length; i++) {
        cb(source[i], i);
      }
    } else {
      for (let key in source) {
        cb(source[key], key);
      }
    }
  }

  static find(source, cb) {
    if (Array.isArray(source)) {
      for (let i = 0; i < source.length; i++) {
        const item = source[i];

        if (cb(item, i)) {
          return item;
        }
      }
    } else {
      for (let key in source) {
        const item = source[key];

        if (cb(item, key)) {
          return item;
        }
      }
    }

    return null;
  }

  static assign(target) {
    for (var _len = arguments.length, sources = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      sources[_key - 1] = arguments[_key];
    }

    this.forEach(sources, source => {
      for (const key in source) {
        target[key] = source[key];
      }
    });
    return target;
  }

  static defaults(target) {
    for (var _len2 = arguments.length, sources = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      sources[_key2 - 1] = arguments[_key2];
    }

    this.forEach(sources, source => {
      for (const key in source) {
        if (this.isObject(target[key]) && this.isObject(source[key])) {
          target[key] = this.defaults(target[key], source[key]);
        } else if (target[key] === undefined) {
          target[key] = source[key];
        }
      }
    });
    return target;
  }

  static isObject(value) {
    return typeof value === 'object' && !Array.isArray(value);
  }

  static iframe(_ref) {
    var _this = this;

    return asyncToGenerator(function* () {
      let url = _ref.url,
          redirectUrl = _ref.redirectUrl,
          visible = _ref.visible;
      const iframe = document.createElement('iframe');
      iframe.setAttribute('owner', '@salte-auth/salte-auth');

      if (visible) {
        _this.assign(iframe.style, {
          border: 'none',
          bottom: 0,
          height: '100%',
          left: 0,
          position: 'fixed',
          right: 0,
          top: 0,
          width: '100%',
          zIndex: 9999,
          opacity: 0,
          transition: '0.5s opacity'
        });

        setTimeout(() => iframe.style.opacity = '1');
      } else {
        iframe.style.display = 'none';
      }

      iframe.src = url;
      document.body.appendChild(iframe);
      return new Promise((resolve, reject) => {
        const checker = setInterval(() => {
          try {
            const location = iframe.contentWindow.location; // This could throw cross-domain errors, so we need to silence them.

            if (location.href.indexOf(redirectUrl) !== 0) return;
            const parsed = URL.parse(location);
            iframe.parentElement && iframe.parentElement.removeChild(iframe);
            clearInterval(checker);
            resolve(parsed);
          } catch (error) {
            if (Events.isCrossDomainError(error)) return;
            iframe.parentElement && iframe.parentElement.removeChild(iframe);
            clearInterval(checker);
            reject(error);
          }
        });
      });
    })();
  }

  static debounce(identifier, callback, timeout) {
    clearTimeout(debounces[identifier]);
    debounces[identifier] = window.setTimeout(() => {
      delete debounces[identifier];
      callback();
    }, timeout);
  }

}

class AccessToken {
  constructor(accessToken, expiration, type) {
    defineProperty(this, "raw", void 0);

    defineProperty(this, "expiration", void 0);

    defineProperty(this, "type", void 0);

    this.raw = accessToken;
    this.expiration = Common.includes([undefined, null], expiration) ? null : Number(expiration);
    this.type = type;
  }

  get expired() {
    return !this.raw || this.expiration <= Date.now();
  }

}

class IDToken {
  constructor(idToken) {
    defineProperty(this, "raw", void 0);

    defineProperty(this, "user", void 0);

    this.raw = idToken;
    this.user = IDToken.parse(this.raw);
  }

  get expired() {
    return !this.user || this.user.exp * 1000 <= Date.now();
  }

  static parse(idToken) {
    try {
      const separated = idToken.split('.');

      if (separated.length !== 3) {
        throw new SalteAuthError({
          code: 'invalid_id_token',
          message: "ID Token didn't match the desired format. ({header}.{payload}.{validation})"
        });
      } // This fixes an issue where various providers will encode values
      // incorrectly and cause the browser to fail to decode.
      // https://stackoverflow.com/questions/43065553/base64-decoded-differently-in-java-jjwt


      return JSON.parse(atob(separated[1].replace(/-/g, '+').replace(/_/g, '/')));
    } catch (error) {
      return null;
    }
  }

}

class Logger {
  constructor(name, level) {
    defineProperty(this, "name", void 0);

    defineProperty(this, "level", void 0);

    this.name = name;
    this.level = typeof level === 'string' ? this.toLevel(level) : level;
  }

  trace(message) {
    for (var _len = arguments.length, optionalParams = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      optionalParams[_key - 1] = arguments[_key];
    }

    this.log('trace', message, ...optionalParams);
  }

  info(message) {
    for (var _len2 = arguments.length, optionalParams = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      optionalParams[_key2 - 1] = arguments[_key2];
    }

    this.log('info', message, ...optionalParams);
  }

  warn(message) {
    for (var _len3 = arguments.length, optionalParams = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
      optionalParams[_key3 - 1] = arguments[_key3];
    }

    this.log('warn', message, ...optionalParams);
  }

  error(message) {
    for (var _len4 = arguments.length, optionalParams = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
      optionalParams[_key4 - 1] = arguments[_key4];
    }

    this.log('error', message, ...optionalParams);
  }

  log(level, message) {
    if (this.enabled(level)) {
      for (var _len5 = arguments.length, optionalParams = new Array(_len5 > 2 ? _len5 - 2 : 0), _key5 = 2; _key5 < _len5; _key5++) {
        optionalParams[_key5 - 2] = arguments[_key5];
      }

      console.log("".concat(level, ": ").concat(message), ...optionalParams);
    }
  }

  enabled(level) {
    if (this.level === false) return false;
    return this.level === true || this.level <= this.toLevel(level);
  }

  toLevel(name) {
    return Common.find(Logger.levels, (_level, key) => key === name);
  }

}

defineProperty(Logger, "levels", {
  trace: 0,
  info: 1,
  warn: 2,
  error: 3
});



var index$1 = /*#__PURE__*/Object.freeze({
  Interceptors: index,
  AccessToken: AccessToken,
  IDToken: IDToken,
  Common: Common,
  Events: Events,
  URL: URL,
  Logger: Logger
});

class Storage extends Required {
  constructor(config) {
    super(config);
    this.config = Common.defaults(this.config, {
      storage: 'session'
    });
  }

  get(key) {
    let defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    return this.storage.getItem(this.key(key)) || defaultValue;
  }

  set(key, value) {
    if (Common.includes([undefined, null], value)) {
      this.clear(key);
    } else {
      this.storage.setItem(this.key(key), value);
    }
  }

  clear(key) {
    this.storage.removeItem(this.key(key));
  }

  reset() {
    const baseKey = this.key('');

    for (const key in localStorage) {
      if (key.indexOf(baseKey) === 0) {
        localStorage.removeItem(key);
      }
    }

    for (const key in sessionStorage) {
      if (key.indexOf(baseKey) === 0) {
        sessionStorage.removeItem(key);
      }
    }
  }

  key(key) {
    return "salte.auth.".concat(key);
  }

  get storage() {
    const storage = this.config && this.config.storage;

    switch (storage) {
      case 'local':
        return localStorage;

      case 'session':
        return sessionStorage;
    }

    throw new SalteAuthError({
      code: 'invalid_storage',
      message: "Storage doesn't exist for the given value. (".concat(storage, ")")
    });
  }

}

class Events$1 extends Storage {
  constructor() {
    super(...arguments);

    defineProperty(this, "listeners", new Map());
  }

  on(name, listener) {
    if (!this.listeners.has(name)) {
      this.listeners.set(name, []);
    }

    const listeners = this.listeners.get(name);
    listeners.push(listener);
  }

  off(name, listener) {
    if (!this.listeners.has(name)) return;
    const listeners = this.listeners.get(name);
    if (!listeners.length) return;
    const index = listeners.indexOf(listener);
    if (index === -1) return;
    listeners.splice(index, 1);
  }

  emit(name) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    if (!this.listeners.has(name)) return;
    const listeners = this.listeners.get(name);
    Common.forEach(listeners, listener => listener(...args));
  }

}

class Shared extends Events$1 {
  constructor(config) {
    super(config);
    this.config = Common.defaults(this.config, {
      redirectUrl: location.origin,
      level: 'warn'
    });
  }
  /**
   * Returns a redirect url for the given login type.
   * @param type Are we logging in or logging out?
   */


  redirectUrl(type) {
    if (typeof this.config.redirectUrl === 'string') {
      return this.config.redirectUrl;
    }

    return this.config.redirectUrl[type];
  }

}

var crypto = self.crypto || self.msCrypto;

/*
 * This alphabet uses a-z A-Z 0-9 _- symbols.
 * Symbols order was changed for better gzip compression.
 */
var url = 'Uint8ArdomValuesObj012345679BCDEFGHIJKLMNPQRSTWXYZ_cfghkpqvwxyz-';

var index_browser = function (size) {
  size = size || 21;
  var id = '';
  var bytes = crypto.getRandomValues(new Uint8Array(size));
  while (0 < size--) {
    id += url[bytes[size] & 63];
  }
  return id
};

class Provider extends Shared {
  constructor(config) {
    super(config);

    defineProperty(this, "logger", void 0);

    this.config = Common.defaults(this.config, {
      validation: true,
      level: 'warn'
    });
    this.logger = new Logger("@salte-auth/salte-auth:providers/".concat(this.$name), this.config.level);
  }
  /**
   * Determines if validation is enabled for the given key.
   * @param key the key to determine whether validation is enabled for
   * @returns whether validation is enabled for the key.
   */


  validation(key) {
    if (typeof this.config.validation === 'object') {
      return this.config.validation[key] === true;
    }

    return this.config.validation === true;
  }
  /**
   * The unique name of the provider
   */


  get $name() {
    return this.config.name || this.name;
  }
  /**
   * Returns a scoped key for storage.
   * @param key The storage key.
   *
   * @example auth0.key('hello') // 'salte.auth.provider.auth0.hello'
   */


  key(key) {
    return "salte.auth.provider.".concat(this.$name, ".").concat(key);
  }
  /**
   * Creates a url with the given query parameters
   * @param base the base url without query parameters
   * @param params the query parameters to attache to the url
   * @returns the built url
   */


  url(base) {
    let params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    let url = base;
    Common.forEach(params, (value, key) => {
      if (Common.includes([undefined, null, ''], value)) return;
      url += "".concat(url.indexOf('?') === -1 ? '?' : '&').concat(key, "=").concat(encodeURIComponent(value));
    });
    return url;
  }
  /**
   * Returns the logout url for the provider.
   */


  get logout() {
    throw new SalteAuthError({
      code: 'logout_not_supported',
      message: "This provider doesn't support logout."
    });
  }

}

class OAuth2Provider extends Provider {
  constructor(config) {
    super(config);

    defineProperty(this, "accessToken", void 0);

    this.sync();
  }

  connected() {
    this.required('clientID', 'responseType');
  }

  secure(request) {
    var _this = this;

    return asyncToGenerator(function* () {
      if (_this.config.responseType === 'token') {
        if (_this.accessToken.expired) {
          return _this.$login();
        }

        if (request) {
          if (request instanceof Request) {
            request.headers.set('Authorization', "Bearer ".concat(_this.accessToken.raw));
          } else if (request instanceof XMLHttpRequest) {
            request.setRequestHeader('Authorization', "Bearer ".concat(_this.accessToken.raw));
          } else {
            throw new SalteAuthError({
              code: 'unknown_request',
              message: "Unknown request type. (".concat(request, ")")
            });
          }
        }
      }

      return true;
    })();
  }

  $validate(options) {
    try {
      if (!options) {
        throw new SalteAuthError({
          code: 'empty_response',
          message: "The response provided was empty, this is most likely due to the configured handler not providing it."
        });
      }

      if (options.error) {
        throw new SalteAuthError({
          code: options.error,
          message: "".concat(options.error_description ? options.error_description : options.error).concat(options.error_uri ? " (".concat(options.error_uri, ")") : '')
        });
      }

      const code = options.code,
            access_token = options.access_token,
            state = options.state,
            expires_in = options.expires_in,
            token_type = options.token_type;

      if (this.validation('state') && this.get('state') !== state) {
        throw new SalteAuthError({
          code: 'invalid_state',
          message: 'State provided by identity provider did not match local state.'
        });
      }

      const types = this.get('response-type', '').split(' ');

      if (Common.includes(types, 'code')) {
        if (!code) {
          throw new SalteAuthError({
            code: 'invalid_code',
            message: 'Expected a code to be returned by the Provider.'
          });
        }
      } else if (Common.includes(types, 'token')) {
        if (!access_token) {
          throw new SalteAuthError({
            code: 'invalid_access_token',
            message: 'Expected an access token to be returned by the Provider.'
          });
        }
      }

      if (code) {
        this.set('code.raw', code);
        this.clear('access-token.raw');
        this.clear('access-token.expiration');
        this.clear('access-token.type');
      } else if (access_token) {
        this.set('access-token.raw', access_token);
        this.set('access-token.expiration', Date.now() + Number(expires_in) * 1000);
        this.set('access-token.type', token_type);
        this.clear('code.raw');
      }
    } finally {
      this.clear('state');
    }
  }

  validate(options) {
    try {
      this.$validate(options);
    } catch (error) {
      this.emit('login', error);
      throw error;
    } finally {
      this.sync();
    }

    this.emit('login', null, this.code || this.accessToken);
  }

  get code() {
    return this.get('code.raw');
  }

  $login() {
    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const state = "".concat(this.$name, "-state-").concat(index_browser());
    const responseType = options.responseType || this.config.responseType;
    this.set('state', state);
    this.set('response-type', responseType);
    return this.url(this.login, {
      client_id: this.config.clientID,
      response_type: responseType,
      redirect_uri: this.config.redirectUrl,
      scope: this.config.scope,
      state
    });
  }

  sync() {
    this.accessToken = new AccessToken(this.get('access-token.raw'), this.get('access-token.expiration'), this.get('access-token.type'));
  }

}

class OpenIDProvider extends OAuth2Provider {
  constructor(config) {
    super(config);

    defineProperty(this, "idToken", void 0);

    this.config.renewal = typeof this.config.renewal === 'object' ? this.config.renewal : {
      type: this.config.renewal
    };
    this.config = Common.defaults(this.config, {
      responseType: 'id_token',
      scope: 'openid',
      renewal: {
        type: 'auto',
        buffer: 60000
      }
    });
    this.sync();
  }

  secure(request) {
    var _this = this;

    return asyncToGenerator(function* () {
      if (Common.includes(['id_token', 'id_token token', 'token'], _this.config.responseType)) {
        if (_this.idToken.expired) {
          return _this.$login();
        }

        if (_this.accessToken.expired) {
          const parsed = yield Common.iframe({
            redirectUrl: _this.redirectUrl('login'),
            url: _this.$login({
              prompt: 'none',
              responseType: 'token'
            })
          });

          _this.validate(parsed);
        }

        if (request) {
          if (request instanceof Request) {
            request.headers.set('Authorization', "Bearer ".concat(_this.accessToken.raw));
          } else if (request instanceof XMLHttpRequest) {
            request.setRequestHeader('Authorization', "Bearer ".concat(_this.accessToken.raw));
          } else {
            throw new SalteAuthError({
              code: 'unknown_request',
              message: "Unknown request type. (".concat(request, ")")
            });
          }
        }
      }

      return true;
    })();
  }

  $validate(options) {
    try {
      super.$validate(options);
      const types = this.get('response-type', '').split(' ');

      if (Common.includes(types, 'id_token')) {
        const id_token = options.id_token;
        const user = IDToken.parse(id_token);

        if (!user) {
          throw new SalteAuthError({
            code: 'invalid_id_token',
            message: 'Failed to parse user information due to invalid id token.'
          });
        }

        if (this.validation('nonce') && this.get('nonce') !== user.nonce) {
          throw new SalteAuthError({
            code: 'invalid_nonce',
            message: 'Nonce provided by identity provider did not match the local nonce.'
          });
        }

        this.set('id-token.raw', id_token);
      } else if (Common.includes(types, 'code')) {
        this.clear('id-token.raw');
      }
    } finally {
      this.clear('nonce');
    }
  }

  validate(options) {
    try {
      this.$validate(options);
    } catch (error) {
      this.emit('login', error);
      throw error;
    } finally {
      this.sync();
    }

    const responseType = this.get('response-type', '');
    const types = responseType.split(' ');

    if (Common.includes(types, 'id_token')) {
      this.emit('login', null, this.idToken);
    } else if (Common.includes(types, 'token')) {
      this.emit('login', null, this.accessToken);
    } else if (Common.includes(types, 'code')) {
      this.emit('login', null, this.code);
    } else {
      throw new SalteAuthError({
        code: 'invalid_response_type',
        message: "Unknown Response Type (".concat(responseType, ")")
      });
    }
  }

  $login(options) {
    const nonce = "".concat(this.$name, "-nonce-").concat(index_browser());
    this.set('nonce', nonce);
    return this.url(super.$login(options), {
      prompt: options && options.prompt,
      nonce
    });
  }

  sync() {
    super.sync();
    this.idToken = new IDToken(this.get('id-token.raw'));
  }

}

class OAuth2 extends OAuth2Provider {
  constructor(config) {
    super(config);
    this.required('login');
  }

  get name() {
    return 'generic.oauth2';
  }

  get login() {
    return this.config.login.apply(this);
  }

}
class OpenID extends OpenIDProvider {
  constructor(config) {
    super(config);
    this.required('login', 'logout');
  }

  get name() {
    return 'generic.openid';
  }

  get login() {
    return this.config.login.apply(this);
  }

  get logout() {
    return this.config.logout.apply(this);
  }

}

var generic = /*#__PURE__*/Object.freeze({
  OAuth2: OAuth2,
  OpenID: OpenID
});

class Handler extends Storage {
  constructor(config) {
    super(config);

    defineProperty(this, "logger", void 0);

    this.config = Common.defaults(this.config, {
      navigate: 'reload',
      level: 'warn'
    });
    this.logger = new Logger("@salte-auth/salte-auth:handlers/".concat(this.$name), this.config.level);
  }
  /**
   * The unique name of the handler
   */


  get $name() {
    return this.config.name || this.name;
  }
  /**
   * Returns a scoped key for storage.
   * @param key The storage key.
   *
   * @example redirect.key('hello') // 'salte.auth.handler.redirect.hello'
   */


  key(key) {
    return "salte.auth.handler.".concat(this.$name, ".").concat(key);
  }
  /**
   * Navigates to the url provided.
   * @param url the url to navigate to
   */

  /* istanbul ignore next */


  navigate(url) {
    if (this.config.navigate === 'history' && url.indexOf(URL.origin) === 0) {
      history.pushState('', document.title, url);
    }

    location.href = url;
  }

}

class SalteAuth extends Shared {
  constructor(config) {
    var _this;

    super(config);
    _this = this;

    defineProperty(this, "logger", void 0);

    defineProperty(this, "mixin", void 0);

    this.required('providers', 'handlers');
    this.config = Common.defaults(this.config, {
      validation: true,
      level: 'warn'
    });
    this.logger = new Logger("@salte-auth/salte-auth:core", this.config.level);
    Common.forEach(this.config.providers, provider => {
      provider.connected && provider.connected();
      provider.on('login', (error, data) => {
        this.emit('login', error, data);
      });
      provider.on('logout', error => {
        this.emit('logout', error);
      });
    });
    const action = this.get('action');
    const provider = action ? this.provider(this.get('provider')) : null;
    const handlerName = action ? this.get('handler') : null;

    if (!Common.includes([undefined, null, 'login', 'logout'], action)) {
      throw new SalteAuthError({
        code: 'unknown_action',
        message: "Unable to finish redirect due to an unknown action! (".concat(action, ")")
      });
    }

    Common.forEach(this.config.handlers, handler => {
      if (!handler.connected) return;
      const responsible = handler.$name === handlerName;
      setTimeout(() => {
        const parsed = handler.connected({
          action: responsible ? action : null
        });
        if (!responsible) return;

        if (action === 'login') {
          provider.validate(parsed);
        } else {
          provider.reset();
          provider.sync();
          provider.emit('logout');
        }
      });
    });
    this.clear('action');
    this.clear('provider');
    this.clear('handler');
    Fetch.add(
    /*#__PURE__*/
    function () {
      var _ref = asyncToGenerator(function* (request) {
        for (let i = 0; i < _this.config.providers.length; i++) {
          const provider = _this.config.providers[i];

          if (URL.match(request.url, provider.config.endpoints)) {
            provider.secure && (yield provider.secure(request));
          }
        }
      });

      return function (_x) {
        return _ref.apply(this, arguments);
      };
    }());
    XHR.add(
    /*#__PURE__*/
    function () {
      var _ref2 = asyncToGenerator(function* (request) {
        for (let i = 0; i < _this.config.providers.length; i++) {
          const provider = _this.config.providers[i];

          if (URL.match(request.$url, provider.config.endpoints)) {
            provider.secure && (yield provider.secure(request));
          }
        }
      });

      return function (_x2) {
        return _ref2.apply(this, arguments);
      };
    }());
    Events.route(
    /*#__PURE__*/
    asyncToGenerator(function* () {
      try {
        const handler = _this.handler();

        for (let i = 0; i < _this.config.providers.length; i++) {
          const provider = _this.config.providers[i];

          if (URL.match(location.href, provider.config.routes)) {
            let response = null;

            while (response !== true) {
              response = yield provider.secure();

              if (typeof response === 'string') {
                if (!handler.auto) {
                  throw new SalteAuthError({
                    code: 'auto_unsupported',
                    message: "The default handler doesn't support automatic authentication! (".concat(handler.$name, ")")
                  });
                }

                _this.set('action', 'login');

                _this.set('provider', provider.$name);

                _this.set('handler', handler.$name);

                const params = yield handler.open({
                  redirectUrl: provider.redirectUrl('login'),
                  url: response
                });
                provider.validate(params);

                _this.clear('action');

                _this.clear('provider');

                _this.clear('handler');
              }
            }
          }
        }
      } catch (error) {
        _this.clear('action');

        _this.clear('provider');

        _this.clear('handler');

        throw error;
      }
    }));
    this.mixin = AuthMixinGenerator(this);
  }
  /**
   * Login to the specified provider.
   *
   * @param options the authentication options
   */


  login(options) {
    var _this2 = this;

    return asyncToGenerator(function* () {
      options = typeof options === 'string' ? {
        provider: options
      } : options;

      try {
        const provider = _this2.provider(options.provider);

        const handler = _this2.handler(options.handler);

        _this2.set('action', 'login');

        _this2.set('provider', provider.$name);

        _this2.set('handler', handler.$name);

        const params = yield handler.open({
          redirectUrl: provider.redirectUrl('login'),
          url: provider.$login()
        });
        provider.validate(params);
      } finally {
        _this2.clear('action');

        _this2.clear('provider');

        _this2.clear('handler');
      }
    })();
  }
  /**
   * Logout of the specified provider.
   *
   * @param options the authentication options
   */


  logout(options) {
    var _this3 = this;

    return asyncToGenerator(function* () {
      options = typeof options === 'string' ? {
        provider: options
      } : options;

      const provider = _this3.provider(options.provider);

      try {
        const handler = _this3.handler(options.handler);

        _this3.set('action', 'logout');

        _this3.set('provider', provider.$name);

        _this3.set('handler', handler.$name);

        yield handler.open({
          redirectUrl: provider.redirectUrl('logout'),
          url: provider.logout
        });
        provider.reset();
        provider.emit('logout');
      } catch (error) {
        provider.emit('logout', error);
        throw error;
      } finally {
        _this3.clear('action');

        _this3.clear('provider');

        _this3.clear('handler');
      }
    })();
  }
  /**
   * Returns a provider that matches the given name.
   * @param name the name of the provider
   * @returns the provider with the given name.
   */


  provider(name) {
    const provider = Common.find(this.config.providers, provider => provider.$name === name);

    if (!provider) {
      throw new SalteAuthError({
        code: 'invalid_provider',
        message: "Unable to locate provider with the given name. (".concat(name, ")")
      });
    }

    return provider;
  }
  /**
   * Returns a handler that matches the given name.
   * @param name the name of the handler
   * @returns the handler with the given name, if no name is specified then the default handler.
   */


  handler(name) {
    const handler = name === undefined ? Common.find(this.config.handlers, handler => !!handler.config.default) : Common.find(this.config.handlers, handler => handler.$name === name);

    if (!handler) {
      throw new SalteAuthError({
        code: 'invalid_handler',
        message: "Unable to locate handler with the given name. (".concat(name, ")")
      });
    }

    return handler;
  }

}

export { generic as Generic, Handler, OAuth2Provider, OpenIDProvider, SalteAuth, SalteAuthError, index$1 as Utils };
//# sourceMappingURL=salte-auth.mjs.map
