{"version":3,"file":"csv-loader.js","names":["VERSION","DEFAULT_CSV_LOADER_OPTIONS","csv","shape","optimizeMemoryUsage","header","columnPrefix","quoteChar","escapeChar","dynamicTyping","comments","skipEmptyLines","delimitersToGuess","CSVLoader","id","module","name","version","extensions","mimeTypes","category","parse","arrayBuffer","options","parseCSV","TextDecoder","decode","parseText","text","parseInBatches","parseCSVInBatches","csvText","csvOptions","firstRow","readFirstRow","isHeaderRow","Boolean","parseWithHeader","papaparseConfig","download","transformHeader","duplicateColumnTransformer","undefined","error","e","Error","result","Papa","rows","data","headerRow","meta","fields","generateHeader","length","map","row","Array","isArray","convertToObjectRow","convertToArrayRow","asyncIterator","batchSize","asyncQueue","AsyncQueue","isFirstRow","tableBatchBuilder","schema","config","chunkSize","step","results","collapsedRow","flat","join","trim","bytesUsed","cursor","deduceSchema","JSON","stringify","TableBatchBuilder","addRow","batch","getFullBatch","enqueue","complete","getFinalBatch","close","AsyncIteratorStreamer","every","value","preview","observedColumns","Set","col","colName","counter","has","add","count","headers","i","push","columnName","String","index","type","Float32Array","_typecheckCSVLoader"],"sources":["../../src/csv-loader.ts"],"sourcesContent":["import type {LoaderWithParser, LoaderOptions} from '@loaders.gl/loader-utils';\nimport type {Batch} from '@loaders.gl/schema';\ntype Schema = any;\n\nimport {\n  AsyncQueue,\n  TableBatchBuilder,\n  convertToArrayRow,\n  convertToObjectRow\n} from '@loaders.gl/schema';\nimport Papa from './papaparse/papaparse';\nimport AsyncIteratorStreamer from './papaparse/async-iterator-streamer';\n\n// __VERSION__ is injected by babel-plugin-version-inline\n// @ts-ignore TS2304: Cannot find name '__VERSION__'.\nconst VERSION = typeof __VERSION__ !== 'undefined' ? __VERSION__ : 'latest';\n\nexport type CSVLoaderOptions = LoaderOptions & {\n  csv?: {\n    // loaders.gl options\n    shape?: 'array-row-table' | 'object-row-table' | 'columnar-table';\n    /** optimizes memory usage but increases parsing time. */\n    optimizeMemoryUsage?: boolean;\n    columnPrefix?: string;\n    header?: 'auto';\n\n    // CSV options (papaparse)\n    // delimiter: auto\n    // newline: auto\n    quoteChar?: string;\n    escapeChar?: string;\n    // Convert numbers and boolean values in rows from strings\n    dynamicTyping?: boolean;\n    comments?: boolean;\n    skipEmptyLines?: boolean | 'greedy';\n    // transform: null?\n    delimitersToGuess?: string[];\n    // fastMode: auto\n  };\n};\n\nconst DEFAULT_CSV_LOADER_OPTIONS = {\n  csv: {\n    shape: 'object-row-table',\n    optimizeMemoryUsage: false,\n    // CSV options\n    header: 'auto',\n    columnPrefix: 'column',\n    // delimiter: auto\n    // newline: auto\n    quoteChar: '\"',\n    escapeChar: '\"',\n    dynamicTyping: true,\n    comments: false,\n    skipEmptyLines: true,\n    // transform: null?\n    delimitersToGuess: [',', '\\t', '|', ';']\n    // fastMode: auto\n  }\n};\n\nexport const CSVLoader = {\n  id: 'csv',\n  module: 'csv',\n  name: 'CSV',\n  version: VERSION,\n  extensions: ['csv', 'tsv', 'dsv'],\n  mimeTypes: ['text/csv', 'text/tab-separated-values', 'text/dsv'],\n  category: 'table',\n  parse: async (arrayBuffer: ArrayBuffer, options?: CSVLoaderOptions) =>\n    parseCSV(new TextDecoder().decode(arrayBuffer), options),\n  parseText: (text: string, options?: CSVLoaderOptions) => parseCSV(text, options),\n  parseInBatches: parseCSVInBatches,\n  // @ts-ignore\n  // testText: null,\n  options: DEFAULT_CSV_LOADER_OPTIONS as CSVLoaderOptions\n};\n\nasync function parseCSV(csvText: string, options?: CSVLoaderOptions) {\n  // Apps can call the parse method directly, we so apply default options here\n  const csvOptions = {...DEFAULT_CSV_LOADER_OPTIONS.csv, ...options?.csv};\n\n  const firstRow = readFirstRow(csvText);\n  const header: boolean =\n    csvOptions.header === 'auto' ? isHeaderRow(firstRow) : Boolean(csvOptions.header);\n\n  const parseWithHeader = header;\n\n  const papaparseConfig = {\n    // dynamicTyping: true,\n    ...csvOptions,\n    header: parseWithHeader,\n    download: false, // We handle loading, no need for papaparse to do it for us\n    transformHeader: parseWithHeader ? duplicateColumnTransformer() : undefined,\n    error: (e) => {\n      throw new Error(e);\n    }\n  };\n\n  const result = Papa.parse(csvText, papaparseConfig);\n  let {data: rows} = result;\n\n  const headerRow = result.meta.fields || generateHeader(csvOptions.columnPrefix, firstRow.length);\n\n  switch (csvOptions.shape) {\n    case 'object-row-table':\n      rows = rows.map((row) => (Array.isArray(row) ? convertToObjectRow(row, headerRow) : row));\n      break;\n    case 'array-row-table':\n      rows = rows.map((row) => (Array.isArray(row) ? row : convertToArrayRow(row, headerRow)));\n      break;\n    default:\n  }\n\n  /*\n  if (!header && shape === 'object-row-table') {\n    // If the dataset has no header, transform the array result into an object shape with an\n    // autogenerated header\n    return result.data.map((row) =>\n      row.reduce((acc, value, i) => {\n        acc[headerRow[i]] = value;\n        return acc;\n      }, {})\n    );\n  }\n  */\n  return rows;\n}\n\n// TODO - support batch size 0 = no batching/single batch?\nfunction parseCSVInBatches(\n  asyncIterator: AsyncIterable<ArrayBuffer> | Iterable<ArrayBuffer>,\n  options?: CSVLoaderOptions\n): AsyncIterable<Batch> {\n  // Papaparse does not support standard batch size handling\n  // TODO - investigate papaparse chunks mode\n  options = {...options};\n  if (options.batchSize === 'auto') {\n    options.batchSize = 4000;\n  }\n\n  // Apps can call the parse method directly, we so apply default options here\n  const csvOptions = {...DEFAULT_CSV_LOADER_OPTIONS.csv, ...options?.csv};\n\n  const asyncQueue = new AsyncQueue<Batch>();\n\n  let isFirstRow: boolean = true;\n  let headerRow: string[] | null = null;\n  let tableBatchBuilder: TableBatchBuilder | null = null;\n  let schema: Schema | null = null;\n\n  const config = {\n    // dynamicTyping: true, // Convert numbers and boolean values in rows from strings,\n    ...csvOptions,\n    header: false, // Unfortunately, header detection is not automatic and does not infer shapes\n    download: false, // We handle loading, no need for papaparse to do it for us\n    // chunkSize is set to 5MB explicitly (same as Papaparse default) due to a bug where the\n    // streaming parser gets stuck if skipEmptyLines and a step callback are both supplied.\n    // See https://github.com/mholt/PapaParse/issues/465\n    chunkSize: 1024 * 1024 * 5,\n    // skipEmptyLines is set to a boolean value if supplied. Greedy is set to true\n    // skipEmptyLines is handled manually given two bugs where the streaming parser gets stuck if\n    // both of the skipEmptyLines and step callback options are provided:\n    // - true doesn't work unless chunkSize is set: https://github.com/mholt/PapaParse/issues/465\n    // - greedy doesn't work: https://github.com/mholt/PapaParse/issues/825\n    skipEmptyLines: false,\n\n    // step is called on every row\n    // eslint-disable-next-line complexity\n    step(results) {\n      let row = results.data;\n\n      if (csvOptions.skipEmptyLines) {\n        // Manually reject lines that are empty\n        const collapsedRow = row.flat().join('').trim();\n        if (collapsedRow === '') {\n          return;\n        }\n      }\n      const bytesUsed = results.meta.cursor;\n\n      // Check if we need to save a header row\n      if (isFirstRow && !headerRow) {\n        // Auto detects or can be forced with csvOptions.header\n        const header = csvOptions.header === 'auto' ? isHeaderRow(row) : Boolean(csvOptions.header);\n        if (header) {\n          headerRow = row.map(duplicateColumnTransformer());\n          return;\n        }\n      }\n\n      // If first data row, we can deduce the schema\n      if (isFirstRow) {\n        isFirstRow = false;\n        if (!headerRow) {\n          headerRow = generateHeader(csvOptions.columnPrefix, row.length);\n        }\n        schema = deduceSchema(row, headerRow);\n      }\n\n      if (csvOptions.optimizeMemoryUsage) {\n        // A workaround to allocate new strings and don't retain pointers to original strings.\n        // https://bugs.chromium.org/p/v8/issues/detail?id=2869\n        row = JSON.parse(JSON.stringify(row));\n      }\n\n      // Add the row\n      tableBatchBuilder =\n        tableBatchBuilder ||\n        new TableBatchBuilder(schema, {\n          // @ts-expect-error\n          shape: csvOptions.shape || 'array-row-table',\n          ...options\n        });\n\n      try {\n        tableBatchBuilder.addRow(row);\n        // If a batch has been completed, emit it\n        const batch = tableBatchBuilder && tableBatchBuilder.getFullBatch({bytesUsed});\n        if (batch) {\n          asyncQueue.enqueue(batch);\n        }\n      } catch (error) {\n        asyncQueue.enqueue(error as Error);\n      }\n    },\n\n    // complete is called when all rows have been read\n    complete(results) {\n      try {\n        const bytesUsed = results.meta.cursor;\n        // Ensure any final (partial) batch gets emitted\n        const batch = tableBatchBuilder && tableBatchBuilder.getFinalBatch({bytesUsed});\n        if (batch) {\n          asyncQueue.enqueue(batch);\n        }\n      } catch (error) {\n        asyncQueue.enqueue(error as Error);\n      }\n\n      asyncQueue.close();\n    }\n  };\n\n  Papa.parse(asyncIterator, config, AsyncIteratorStreamer);\n\n  // TODO - Does it matter if we return asyncIterable or asyncIterator\n  // return asyncQueue[Symbol.asyncIterator]();\n  return asyncQueue;\n}\n\n/**\n * Checks if a certain row is a header row\n * @param row the row to check\n * @returns true if the row looks like a header\n */\nfunction isHeaderRow(row: string[]): boolean {\n  return row && row.every((value) => typeof value === 'string');\n}\n\n/**\n * Reads, parses, and returns the first row of a CSV text\n * @param csvText the csv text to parse\n * @returns the first row\n */\nfunction readFirstRow(csvText: string): any[] {\n  const result = Papa.parse(csvText, {\n    download: false,\n    dynamicTyping: true,\n    preview: 1\n  });\n  return result.data[0];\n}\n\n/**\n * Creates a transformer that renames duplicate columns. This is needed as Papaparse doesn't handle\n * duplicate header columns and would use the latest occurrence by default.\n * See the header option in https://www.papaparse.com/docs#config\n * @returns a transform function that returns sanitized names for duplicate fields\n */\nfunction duplicateColumnTransformer() {\n  const observedColumns = new Set();\n  return (col) => {\n    let colName = col;\n    let counter = 1;\n    while (observedColumns.has(colName)) {\n      colName = `${col}.${counter}`;\n      counter++;\n    }\n    observedColumns.add(colName);\n    return colName;\n  };\n}\n\n/**\n * Generates the header of a CSV given a prefix and a column count\n * @param columnPrefix the columnPrefix to use\n * @param count the count of column names to generate\n * @returns an array of column names\n */\nfunction generateHeader(columnPrefix: string, count: number = 0): string[] {\n  const headers: string[] = [];\n  for (let i = 0; i < count; i++) {\n    headers.push(`${columnPrefix}${i + 1}`);\n  }\n  return headers;\n}\n\nfunction deduceSchema(row, headerRow) {\n  const schema = headerRow ? {} : [];\n  for (let i = 0; i < row.length; i++) {\n    const columnName = (headerRow && headerRow[i]) || i;\n    const value = row[i];\n    switch (typeof value) {\n      case 'number':\n      case 'boolean':\n        // TODO - booleans could be handled differently...\n        schema[columnName] = {name: String(columnName), index: i, type: Float32Array};\n        break;\n      case 'string':\n      default:\n        schema[columnName] = {name: String(columnName), index: i, type: Array};\n      // We currently only handle numeric rows\n      // TODO we could offer a function to map strings to numbers?\n    }\n  }\n  return schema;\n}\n\nexport const _typecheckCSVLoader: LoaderWithParser = CSVLoader;\n"],"mappings":"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"}