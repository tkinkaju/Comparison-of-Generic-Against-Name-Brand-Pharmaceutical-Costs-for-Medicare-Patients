{"version":3,"file":"async-iterator-streamer.js","names":["ChunkStreamer","Papa","AsyncIteratorStreamer","config","call","textDecoder","TextDecoder","_config","encoding","stream","asyncIterator","_input","chunk","parseChunk","getStringChunk","_finished","_sendError","_nextChunk","nextChunk","decode","prototype","Object","create","constructor"],"sources":["../../../src/papaparse/async-iterator-streamer.ts"],"sourcesContent":["// @ts-nocheck\n// A custom papaparse `Streamer` for async iterators\n// Ideally this can be contributed back to papaparse\n// Or papaparse can expose Streamer API so we can extend without forking.\n\n/* eslint-disable no-invalid-this */\n\n// Note: papaparse is not an ES6 module\nimport Papa from './papaparse';\nconst {ChunkStreamer} = Papa;\n\nexport default function AsyncIteratorStreamer(config) {\n  config = config || {};\n\n  ChunkStreamer.call(this, config);\n\n  this.textDecoder = new TextDecoder(this._config.encoding);\n\n  // Implement ChunkStreamer base class methods\n\n  // this.pause = function() {\n  //   ChunkStreamer.prototype.pause.apply(this, arguments);\n  // };\n\n  // this.resume = function() {\n  //   ChunkStreamer.prototype.resume.apply(this, arguments);\n  //   this._input.resume();\n  // };\n\n  this.stream = async function (asyncIterator) {\n    this._input = asyncIterator;\n\n    try {\n      // ES2018 version\n      // TODO - check for pause and abort flags?\n      for await (const chunk of asyncIterator) {\n        this.parseChunk(this.getStringChunk(chunk));\n      }\n\n      // ES5 VERSION\n      // while (true) {\n      //   asyncIterator.next().then(function(value) {\n      //     if (value.done) {\n      //       // finalize iterator?\n      //     }\n      //   }\n      //   const  = await ;\n      //   if (done) return total;\n      //   total += value.length;\n      // }\n\n      this._finished = true;\n      this.parseChunk('');\n    } catch (error) {\n      // Inform ChunkStreamer base class of error\n      this._sendError(error);\n    }\n  };\n\n  this._nextChunk = function nextChunk() {\n    // Left empty, as async iterator automatically pulls next chunk\n  };\n\n  // HELPER METHODS\n  this.getStringChunk = function (chunk) {\n    return typeof chunk === 'string' ? chunk : this.textDecoder.decode(chunk, {stream: true});\n  };\n}\n\nAsyncIteratorStreamer.prototype = Object.create(ChunkStreamer.prototype);\nAsyncIteratorStreamer.prototype.constructor = AsyncIteratorStreamer;\n"],"mappings":";;;;;;;;;AAQA;AAA+B;AAAA;AAC/B,IAAOA,aAAa,GAAIC,kBAAI,CAArBD,aAAa;AAEL,SAASE,qBAAqB,CAACC,MAAM,EAAE;EACpDA,MAAM,GAAGA,MAAM,IAAI,CAAC,CAAC;EAErBH,aAAa,CAACI,IAAI,CAAC,IAAI,EAAED,MAAM,CAAC;EAEhC,IAAI,CAACE,WAAW,GAAG,IAAIC,WAAW,CAAC,IAAI,CAACC,OAAO,CAACC,QAAQ,CAAC;;EAazD,IAAI,CAACC,MAAM;IAAA,qEAAG,iBAAgBC,aAAa;MAAA;MAAA;QAAA;UAAA;YAAA;cACzC,IAAI,CAACC,MAAM,GAAGD,aAAa;cAAC;cAAA;cAAA;cAAA;cAAA,2BAKAA,aAAa;YAAA;cAAA;cAAA;YAAA;cAAA;gBAAA;gBAAA;cAAA;cAAtBE,KAAK;cACpB,IAAI,CAACC,UAAU,CAAC,IAAI,CAACC,cAAc,CAACF,KAAK,CAAC,CAAC;YAAC;cAAA;cAAA;cAAA;YAAA;cAAA;cAAA;YAAA;cAAA;cAAA;cAAA;cAAA;YAAA;cAAA;cAAA;cAAA;gBAAA;gBAAA;cAAA;cAAA;cAAA;YAAA;cAAA;cAAA;gBAAA;gBAAA;cAAA;cAAA;YAAA;cAAA;YAAA;cAAA;YAAA;;cAe9C,IAAI,CAACG,SAAS,GAAG,IAAI;cACrB,IAAI,CAACF,UAAU,CAAC,EAAE,CAAC;cAAC;cAAA;YAAA;cAAA;cAAA;cAGpB,IAAI,CAACG,UAAU,aAAO;YAAC;YAAA;cAAA;UAAA;QAAA;MAAA;IAAA,CAE1B;IAAA;MAAA;IAAA;EAAA;EAED,IAAI,CAACC,UAAU,GAAG,SAASC,SAAS,GAAG;EAEvC,CAAC;;EAGD,IAAI,CAACJ,cAAc,GAAG,UAAUF,KAAK,EAAE;IACrC,OAAO,OAAOA,KAAK,KAAK,QAAQ,GAAGA,KAAK,GAAG,IAAI,CAACP,WAAW,CAACc,MAAM,CAACP,KAAK,EAAE;MAACH,MAAM,EAAE;IAAI,CAAC,CAAC;EAC3F,CAAC;AACH;AAEAP,qBAAqB,CAACkB,SAAS,GAAGC,MAAM,CAACC,MAAM,CAACtB,aAAa,CAACoB,SAAS,CAAC;AACxElB,qBAAqB,CAACkB,SAAS,CAACG,WAAW,GAAGrB,qBAAqB"}