{"version":3,"file":"async-iterator-streamer.js","names":["Papa","ChunkStreamer","AsyncIteratorStreamer","config","call","textDecoder","TextDecoder","_config","encoding","stream","asyncIterator","_input","chunk","parseChunk","getStringChunk","_finished","error","_sendError","_nextChunk","nextChunk","decode","prototype","Object","create","constructor"],"sources":["../../../src/papaparse/async-iterator-streamer.ts"],"sourcesContent":["// @ts-nocheck\n// A custom papaparse `Streamer` for async iterators\n// Ideally this can be contributed back to papaparse\n// Or papaparse can expose Streamer API so we can extend without forking.\n\n/* eslint-disable no-invalid-this */\n\n// Note: papaparse is not an ES6 module\nimport Papa from './papaparse';\nconst {ChunkStreamer} = Papa;\n\nexport default function AsyncIteratorStreamer(config) {\n  config = config || {};\n\n  ChunkStreamer.call(this, config);\n\n  this.textDecoder = new TextDecoder(this._config.encoding);\n\n  // Implement ChunkStreamer base class methods\n\n  // this.pause = function() {\n  //   ChunkStreamer.prototype.pause.apply(this, arguments);\n  // };\n\n  // this.resume = function() {\n  //   ChunkStreamer.prototype.resume.apply(this, arguments);\n  //   this._input.resume();\n  // };\n\n  this.stream = async function (asyncIterator) {\n    this._input = asyncIterator;\n\n    try {\n      // ES2018 version\n      // TODO - check for pause and abort flags?\n      for await (const chunk of asyncIterator) {\n        this.parseChunk(this.getStringChunk(chunk));\n      }\n\n      // ES5 VERSION\n      // while (true) {\n      //   asyncIterator.next().then(function(value) {\n      //     if (value.done) {\n      //       // finalize iterator?\n      //     }\n      //   }\n      //   const  = await ;\n      //   if (done) return total;\n      //   total += value.length;\n      // }\n\n      this._finished = true;\n      this.parseChunk('');\n    } catch (error) {\n      // Inform ChunkStreamer base class of error\n      this._sendError(error);\n    }\n  };\n\n  this._nextChunk = function nextChunk() {\n    // Left empty, as async iterator automatically pulls next chunk\n  };\n\n  // HELPER METHODS\n  this.getStringChunk = function (chunk) {\n    return typeof chunk === 'string' ? chunk : this.textDecoder.decode(chunk, {stream: true});\n  };\n}\n\nAsyncIteratorStreamer.prototype = Object.create(ChunkStreamer.prototype);\nAsyncIteratorStreamer.prototype.constructor = AsyncIteratorStreamer;\n"],"mappings":";;AAQA,OAAOA,IAAI,MAAM,aAAa;AAC9B,MAAM;EAACC;AAAa,CAAC,GAAGD,IAAI;AAE5B,eAAe,SAASE,qBAAqB,CAACC,MAAM,EAAE;EACpDA,MAAM,GAAGA,MAAM,IAAI,CAAC,CAAC;EAErBF,aAAa,CAACG,IAAI,CAAC,IAAI,EAAED,MAAM,CAAC;EAEhC,IAAI,CAACE,WAAW,GAAG,IAAIC,WAAW,CAAC,IAAI,CAACC,OAAO,CAACC,QAAQ,CAAC;;EAazD,IAAI,CAACC,MAAM,GAAG,gBAAgBC,aAAa,EAAE;IAC3C,IAAI,CAACC,MAAM,GAAGD,aAAa;IAE3B,IAAI;MAGF,WAAW,MAAME,KAAK,IAAIF,aAAa,EAAE;QACvC,IAAI,CAACG,UAAU,CAAC,IAAI,CAACC,cAAc,CAACF,KAAK,CAAC,CAAC;MAC7C;;MAcA,IAAI,CAACG,SAAS,GAAG,IAAI;MACrB,IAAI,CAACF,UAAU,CAAC,EAAE,CAAC;IACrB,CAAC,CAAC,OAAOG,KAAK,EAAE;MAEd,IAAI,CAACC,UAAU,CAACD,KAAK,CAAC;IACxB;EACF,CAAC;EAED,IAAI,CAACE,UAAU,GAAG,SAASC,SAAS,GAAG;EAEvC,CAAC;;EAGD,IAAI,CAACL,cAAc,GAAG,UAAUF,KAAK,EAAE;IACrC,OAAO,OAAOA,KAAK,KAAK,QAAQ,GAAGA,KAAK,GAAG,IAAI,CAACP,WAAW,CAACe,MAAM,CAACR,KAAK,EAAE;MAACH,MAAM,EAAE;IAAI,CAAC,CAAC;EAC3F,CAAC;AACH;AAEAP,qBAAqB,CAACmB,SAAS,GAAGC,MAAM,CAACC,MAAM,CAACtB,aAAa,CAACoB,SAAS,CAAC;AACxEnB,qBAAqB,CAACmB,SAAS,CAACG,WAAW,GAAGtB,qBAAqB"}