{"version":3,"file":"csv-loader.js","names":["AsyncQueue","TableBatchBuilder","convertToArrayRow","convertToObjectRow","Papa","AsyncIteratorStreamer","VERSION","DEFAULT_CSV_LOADER_OPTIONS","csv","shape","optimizeMemoryUsage","header","columnPrefix","quoteChar","escapeChar","dynamicTyping","comments","skipEmptyLines","delimitersToGuess","CSVLoader","id","module","name","version","extensions","mimeTypes","category","parse","arrayBuffer","options","parseCSV","TextDecoder","decode","parseText","text","parseInBatches","parseCSVInBatches","csvText","csvOptions","firstRow","readFirstRow","isHeaderRow","Boolean","parseWithHeader","papaparseConfig","download","transformHeader","duplicateColumnTransformer","undefined","error","e","Error","result","data","rows","headerRow","meta","fields","generateHeader","length","map","row","Array","isArray","asyncIterator","batchSize","asyncQueue","isFirstRow","tableBatchBuilder","schema","config","chunkSize","step","results","collapsedRow","flat","join","trim","bytesUsed","cursor","deduceSchema","JSON","stringify","addRow","batch","getFullBatch","enqueue","complete","getFinalBatch","close","every","value","preview","observedColumns","Set","col","colName","counter","has","add","count","headers","i","push","columnName","String","index","type","Float32Array","_typecheckCSVLoader"],"sources":["../../src/csv-loader.ts"],"sourcesContent":["import type {LoaderWithParser, LoaderOptions} from '@loaders.gl/loader-utils';\nimport type {Batch} from '@loaders.gl/schema';\ntype Schema = any;\n\nimport {\n  AsyncQueue,\n  TableBatchBuilder,\n  convertToArrayRow,\n  convertToObjectRow\n} from '@loaders.gl/schema';\nimport Papa from './papaparse/papaparse';\nimport AsyncIteratorStreamer from './papaparse/async-iterator-streamer';\n\n// __VERSION__ is injected by babel-plugin-version-inline\n// @ts-ignore TS2304: Cannot find name '__VERSION__'.\nconst VERSION = typeof __VERSION__ !== 'undefined' ? __VERSION__ : 'latest';\n\nexport type CSVLoaderOptions = LoaderOptions & {\n  csv?: {\n    // loaders.gl options\n    shape?: 'array-row-table' | 'object-row-table' | 'columnar-table';\n    /** optimizes memory usage but increases parsing time. */\n    optimizeMemoryUsage?: boolean;\n    columnPrefix?: string;\n    header?: 'auto';\n\n    // CSV options (papaparse)\n    // delimiter: auto\n    // newline: auto\n    quoteChar?: string;\n    escapeChar?: string;\n    // Convert numbers and boolean values in rows from strings\n    dynamicTyping?: boolean;\n    comments?: boolean;\n    skipEmptyLines?: boolean | 'greedy';\n    // transform: null?\n    delimitersToGuess?: string[];\n    // fastMode: auto\n  };\n};\n\nconst DEFAULT_CSV_LOADER_OPTIONS = {\n  csv: {\n    shape: 'object-row-table',\n    optimizeMemoryUsage: false,\n    // CSV options\n    header: 'auto',\n    columnPrefix: 'column',\n    // delimiter: auto\n    // newline: auto\n    quoteChar: '\"',\n    escapeChar: '\"',\n    dynamicTyping: true,\n    comments: false,\n    skipEmptyLines: true,\n    // transform: null?\n    delimitersToGuess: [',', '\\t', '|', ';']\n    // fastMode: auto\n  }\n};\n\nexport const CSVLoader = {\n  id: 'csv',\n  module: 'csv',\n  name: 'CSV',\n  version: VERSION,\n  extensions: ['csv', 'tsv', 'dsv'],\n  mimeTypes: ['text/csv', 'text/tab-separated-values', 'text/dsv'],\n  category: 'table',\n  parse: async (arrayBuffer: ArrayBuffer, options?: CSVLoaderOptions) =>\n    parseCSV(new TextDecoder().decode(arrayBuffer), options),\n  parseText: (text: string, options?: CSVLoaderOptions) => parseCSV(text, options),\n  parseInBatches: parseCSVInBatches,\n  // @ts-ignore\n  // testText: null,\n  options: DEFAULT_CSV_LOADER_OPTIONS as CSVLoaderOptions\n};\n\nasync function parseCSV(csvText: string, options?: CSVLoaderOptions) {\n  // Apps can call the parse method directly, we so apply default options here\n  const csvOptions = {...DEFAULT_CSV_LOADER_OPTIONS.csv, ...options?.csv};\n\n  const firstRow = readFirstRow(csvText);\n  const header: boolean =\n    csvOptions.header === 'auto' ? isHeaderRow(firstRow) : Boolean(csvOptions.header);\n\n  const parseWithHeader = header;\n\n  const papaparseConfig = {\n    // dynamicTyping: true,\n    ...csvOptions,\n    header: parseWithHeader,\n    download: false, // We handle loading, no need for papaparse to do it for us\n    transformHeader: parseWithHeader ? duplicateColumnTransformer() : undefined,\n    error: (e) => {\n      throw new Error(e);\n    }\n  };\n\n  const result = Papa.parse(csvText, papaparseConfig);\n  let {data: rows} = result;\n\n  const headerRow = result.meta.fields || generateHeader(csvOptions.columnPrefix, firstRow.length);\n\n  switch (csvOptions.shape) {\n    case 'object-row-table':\n      rows = rows.map((row) => (Array.isArray(row) ? convertToObjectRow(row, headerRow) : row));\n      break;\n    case 'array-row-table':\n      rows = rows.map((row) => (Array.isArray(row) ? row : convertToArrayRow(row, headerRow)));\n      break;\n    default:\n  }\n\n  /*\n  if (!header && shape === 'object-row-table') {\n    // If the dataset has no header, transform the array result into an object shape with an\n    // autogenerated header\n    return result.data.map((row) =>\n      row.reduce((acc, value, i) => {\n        acc[headerRow[i]] = value;\n        return acc;\n      }, {})\n    );\n  }\n  */\n  return rows;\n}\n\n// TODO - support batch size 0 = no batching/single batch?\nfunction parseCSVInBatches(\n  asyncIterator: AsyncIterable<ArrayBuffer> | Iterable<ArrayBuffer>,\n  options?: CSVLoaderOptions\n): AsyncIterable<Batch> {\n  // Papaparse does not support standard batch size handling\n  // TODO - investigate papaparse chunks mode\n  options = {...options};\n  if (options.batchSize === 'auto') {\n    options.batchSize = 4000;\n  }\n\n  // Apps can call the parse method directly, we so apply default options here\n  const csvOptions = {...DEFAULT_CSV_LOADER_OPTIONS.csv, ...options?.csv};\n\n  const asyncQueue = new AsyncQueue<Batch>();\n\n  let isFirstRow: boolean = true;\n  let headerRow: string[] | null = null;\n  let tableBatchBuilder: TableBatchBuilder | null = null;\n  let schema: Schema | null = null;\n\n  const config = {\n    // dynamicTyping: true, // Convert numbers and boolean values in rows from strings,\n    ...csvOptions,\n    header: false, // Unfortunately, header detection is not automatic and does not infer shapes\n    download: false, // We handle loading, no need for papaparse to do it for us\n    // chunkSize is set to 5MB explicitly (same as Papaparse default) due to a bug where the\n    // streaming parser gets stuck if skipEmptyLines and a step callback are both supplied.\n    // See https://github.com/mholt/PapaParse/issues/465\n    chunkSize: 1024 * 1024 * 5,\n    // skipEmptyLines is set to a boolean value if supplied. Greedy is set to true\n    // skipEmptyLines is handled manually given two bugs where the streaming parser gets stuck if\n    // both of the skipEmptyLines and step callback options are provided:\n    // - true doesn't work unless chunkSize is set: https://github.com/mholt/PapaParse/issues/465\n    // - greedy doesn't work: https://github.com/mholt/PapaParse/issues/825\n    skipEmptyLines: false,\n\n    // step is called on every row\n    // eslint-disable-next-line complexity\n    step(results) {\n      let row = results.data;\n\n      if (csvOptions.skipEmptyLines) {\n        // Manually reject lines that are empty\n        const collapsedRow = row.flat().join('').trim();\n        if (collapsedRow === '') {\n          return;\n        }\n      }\n      const bytesUsed = results.meta.cursor;\n\n      // Check if we need to save a header row\n      if (isFirstRow && !headerRow) {\n        // Auto detects or can be forced with csvOptions.header\n        const header = csvOptions.header === 'auto' ? isHeaderRow(row) : Boolean(csvOptions.header);\n        if (header) {\n          headerRow = row.map(duplicateColumnTransformer());\n          return;\n        }\n      }\n\n      // If first data row, we can deduce the schema\n      if (isFirstRow) {\n        isFirstRow = false;\n        if (!headerRow) {\n          headerRow = generateHeader(csvOptions.columnPrefix, row.length);\n        }\n        schema = deduceSchema(row, headerRow);\n      }\n\n      if (csvOptions.optimizeMemoryUsage) {\n        // A workaround to allocate new strings and don't retain pointers to original strings.\n        // https://bugs.chromium.org/p/v8/issues/detail?id=2869\n        row = JSON.parse(JSON.stringify(row));\n      }\n\n      // Add the row\n      tableBatchBuilder =\n        tableBatchBuilder ||\n        new TableBatchBuilder(schema, {\n          // @ts-expect-error\n          shape: csvOptions.shape || 'array-row-table',\n          ...options\n        });\n\n      try {\n        tableBatchBuilder.addRow(row);\n        // If a batch has been completed, emit it\n        const batch = tableBatchBuilder && tableBatchBuilder.getFullBatch({bytesUsed});\n        if (batch) {\n          asyncQueue.enqueue(batch);\n        }\n      } catch (error) {\n        asyncQueue.enqueue(error as Error);\n      }\n    },\n\n    // complete is called when all rows have been read\n    complete(results) {\n      try {\n        const bytesUsed = results.meta.cursor;\n        // Ensure any final (partial) batch gets emitted\n        const batch = tableBatchBuilder && tableBatchBuilder.getFinalBatch({bytesUsed});\n        if (batch) {\n          asyncQueue.enqueue(batch);\n        }\n      } catch (error) {\n        asyncQueue.enqueue(error as Error);\n      }\n\n      asyncQueue.close();\n    }\n  };\n\n  Papa.parse(asyncIterator, config, AsyncIteratorStreamer);\n\n  // TODO - Does it matter if we return asyncIterable or asyncIterator\n  // return asyncQueue[Symbol.asyncIterator]();\n  return asyncQueue;\n}\n\n/**\n * Checks if a certain row is a header row\n * @param row the row to check\n * @returns true if the row looks like a header\n */\nfunction isHeaderRow(row: string[]): boolean {\n  return row && row.every((value) => typeof value === 'string');\n}\n\n/**\n * Reads, parses, and returns the first row of a CSV text\n * @param csvText the csv text to parse\n * @returns the first row\n */\nfunction readFirstRow(csvText: string): any[] {\n  const result = Papa.parse(csvText, {\n    download: false,\n    dynamicTyping: true,\n    preview: 1\n  });\n  return result.data[0];\n}\n\n/**\n * Creates a transformer that renames duplicate columns. This is needed as Papaparse doesn't handle\n * duplicate header columns and would use the latest occurrence by default.\n * See the header option in https://www.papaparse.com/docs#config\n * @returns a transform function that returns sanitized names for duplicate fields\n */\nfunction duplicateColumnTransformer() {\n  const observedColumns = new Set();\n  return (col) => {\n    let colName = col;\n    let counter = 1;\n    while (observedColumns.has(colName)) {\n      colName = `${col}.${counter}`;\n      counter++;\n    }\n    observedColumns.add(colName);\n    return colName;\n  };\n}\n\n/**\n * Generates the header of a CSV given a prefix and a column count\n * @param columnPrefix the columnPrefix to use\n * @param count the count of column names to generate\n * @returns an array of column names\n */\nfunction generateHeader(columnPrefix: string, count: number = 0): string[] {\n  const headers: string[] = [];\n  for (let i = 0; i < count; i++) {\n    headers.push(`${columnPrefix}${i + 1}`);\n  }\n  return headers;\n}\n\nfunction deduceSchema(row, headerRow) {\n  const schema = headerRow ? {} : [];\n  for (let i = 0; i < row.length; i++) {\n    const columnName = (headerRow && headerRow[i]) || i;\n    const value = row[i];\n    switch (typeof value) {\n      case 'number':\n      case 'boolean':\n        // TODO - booleans could be handled differently...\n        schema[columnName] = {name: String(columnName), index: i, type: Float32Array};\n        break;\n      case 'string':\n      default:\n        schema[columnName] = {name: String(columnName), index: i, type: Array};\n      // We currently only handle numeric rows\n      // TODO we could offer a function to map strings to numbers?\n    }\n  }\n  return schema;\n}\n\nexport const _typecheckCSVLoader: LoaderWithParser = CSVLoader;\n"],"mappings":"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"}