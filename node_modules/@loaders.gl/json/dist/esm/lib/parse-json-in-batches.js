import { TableBatchBuilder } from '@loaders.gl/schema';
import { assert, makeTextDecoderIterator } from '@loaders.gl/loader-utils';
import StreamingJSONParser from './parser/streaming-json-parser';
import JSONPath from './jsonpath/jsonpath';

export default async function* parseJSONInBatches(binaryAsyncIterator, options) {
  var _options$json;
  const asyncIterator = makeTextDecoderIterator(binaryAsyncIterator);
  const {
    metadata
  } = options;
  const {
    jsonpaths
  } = options.json || {};
  let isFirstChunk = true;

  const schema = null;
  const shape = (options === null || options === void 0 ? void 0 : (_options$json = options.json) === null || _options$json === void 0 ? void 0 : _options$json.shape) || 'row-table';
  const tableBatchBuilder = new TableBatchBuilder(schema, {
    ...options,
    shape
  });
  const parser = new StreamingJSONParser({
    jsonpaths
  });
  for await (const chunk of asyncIterator) {
    const rows = parser.write(chunk);
    const jsonpath = rows.length > 0 && parser.getStreamingJsonPathAsString();
    if (rows.length > 0 && isFirstChunk) {
      if (metadata) {
        const initialBatch = {
          shape,
          batchType: 'partial-result',
          data: [],
          length: 0,
          bytesUsed: 0,
          container: parser.getPartialResult(),
          jsonpath
        };
        yield initialBatch;
      }
      isFirstChunk = false;
    }

    for (const row of rows) {
      tableBatchBuilder.addRow(row);
      const batch = tableBatchBuilder.getFullBatch({
        jsonpath
      });
      if (batch) {
        yield batch;
      }
    }
    tableBatchBuilder.chunkComplete(chunk);
    const batch = tableBatchBuilder.getFullBatch({
      jsonpath
    });
    if (batch) {
      yield batch;
    }
  }

  const jsonpath = parser.getStreamingJsonPathAsString();
  const batch = tableBatchBuilder.getFinalBatch({
    jsonpath
  });
  if (batch) {
    yield batch;
  }
  if (metadata) {
    const finalBatch = {
      shape,
      batchType: 'final-result',
      container: parser.getPartialResult(),
      jsonpath: parser.getStreamingJsonPathAsString(),
      data: [],
      length: 0
    };

    yield finalBatch;
  }
}
export function rebuildJsonObject(batch, data) {
  assert(batch.batchType === 'final-result');

  if (batch.jsonpath === '$') {
    return data;
  }

  if (batch.jsonpath && batch.jsonpath.length > 1) {
    const topLevelObject = batch.container;
    const streamingPath = new JSONPath(batch.jsonpath);
    streamingPath.setFieldAtPath(topLevelObject, data);
    return topLevelObject;
  }

  return batch.container;
}
//# sourceMappingURL=parse-json-in-batches.js.map