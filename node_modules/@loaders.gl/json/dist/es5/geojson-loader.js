"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GeoJSONWorkerLoader = exports.GeoJSONLoader = void 0;
var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _awaitAsyncGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/awaitAsyncGenerator"));
var _wrapAsyncGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/wrapAsyncGenerator"));
var _gis = require("@loaders.gl/gis");
var _parseJson = _interopRequireDefault(require("./lib/parse-json"));
var _parseJsonInBatches = _interopRequireDefault(require("./lib/parse-json-in-batches"));
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _asyncIterator(iterable) { var method, async, sync, retry = 2; for ("undefined" != typeof Symbol && (async = Symbol.asyncIterator, sync = Symbol.iterator); retry--;) { if (async && null != (method = iterable[async])) return method.call(iterable); if (sync && null != (method = iterable[sync])) return new AsyncFromSyncIterator(method.call(iterable)); async = "@@asyncIterator", sync = "@@iterator"; } throw new TypeError("Object is not async iterable"); }
function AsyncFromSyncIterator(s) { function AsyncFromSyncIteratorContinuation(r) { if (Object(r) !== r) return Promise.reject(new TypeError(r + " is not an object.")); var done = r.done; return Promise.resolve(r.value).then(function (value) { return { value: value, done: done }; }); } return AsyncFromSyncIterator = function AsyncFromSyncIterator(s) { this.s = s, this.n = s.next; }, AsyncFromSyncIterator.prototype = { s: null, n: null, next: function next() { return AsyncFromSyncIteratorContinuation(this.n.apply(this.s, arguments)); }, return: function _return(value) { var ret = this.s.return; return void 0 === ret ? Promise.resolve({ value: value, done: !0 }) : AsyncFromSyncIteratorContinuation(ret.apply(this.s, arguments)); }, throw: function _throw(value) { var thr = this.s.return; return void 0 === thr ? Promise.reject(value) : AsyncFromSyncIteratorContinuation(thr.apply(this.s, arguments)); } }, new AsyncFromSyncIterator(s); }
var VERSION = typeof "3.3.3" !== 'undefined' ? "3.3.3" : 'latest';
var DEFAULT_GEOJSON_LOADER_OPTIONS = {
  geojson: {
    shape: 'object-row-table'
  },
  json: {
    jsonpaths: ['$', '$.features']
  },
  gis: {
    format: 'geojson'
  }
};

var GeoJSONWorkerLoader = {
  name: 'GeoJSON',
  id: 'geojson',
  module: 'geojson',
  version: VERSION,
  worker: true,
  extensions: ['geojson'],
  mimeTypes: ['application/geo+json'],
  category: 'geometry',
  text: true,
  options: DEFAULT_GEOJSON_LOADER_OPTIONS
};
exports.GeoJSONWorkerLoader = GeoJSONWorkerLoader;
var GeoJSONLoader = _objectSpread(_objectSpread({}, GeoJSONWorkerLoader), {}, {
  parse: parse,
  parseTextSync: parseTextSync,
  parseInBatches: parseInBatches
});
exports.GeoJSONLoader = GeoJSONLoader;
function parse(_x2, _x3) {
  return _parse.apply(this, arguments);
}
function _parse() {
  _parse = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee2(arrayBuffer, options) {
    return _regenerator.default.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            return _context2.abrupt("return", parseTextSync(new TextDecoder().decode(arrayBuffer), options));
          case 1:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _parse.apply(this, arguments);
}
function parseTextSync(text, options) {
  options = _objectSpread(_objectSpread({}, DEFAULT_GEOJSON_LOADER_OPTIONS), options);
  options.json = _objectSpread(_objectSpread({}, DEFAULT_GEOJSON_LOADER_OPTIONS.geojson), options.geojson);
  options.gis = options.gis || {};
  var json = (0, _parseJson.default)(text, options);
  switch (options.gis.format) {
    case 'binary':
      return (0, _gis.geojsonToBinary)(json);
    default:
      return json;
  }
}
function parseInBatches(asyncIterator, options) {
  options = _objectSpread(_objectSpread({}, DEFAULT_GEOJSON_LOADER_OPTIONS), options);
  options.json = _objectSpread(_objectSpread({}, DEFAULT_GEOJSON_LOADER_OPTIONS.geojson), options.geojson);
  var geojsonIterator = (0, _parseJsonInBatches.default)(asyncIterator, options);
  switch (options.gis.format) {
    case 'binary':
      return makeBinaryGeometryIterator(geojsonIterator);
    default:
      return geojsonIterator;
  }
}
function makeBinaryGeometryIterator(_x) {
  return _makeBinaryGeometryIterator.apply(this, arguments);
}
function _makeBinaryGeometryIterator() {
  _makeBinaryGeometryIterator = (0, _wrapAsyncGenerator2.default)(_regenerator.default.mark(function _callee(geojsonIterator) {
    var _iteratorAbruptCompletion, _didIteratorError, _iteratorError, _iterator, _step, batch;
    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _iteratorAbruptCompletion = false;
            _didIteratorError = false;
            _context.prev = 2;
            _iterator = _asyncIterator(geojsonIterator);
          case 4:
            _context.next = 6;
            return (0, _awaitAsyncGenerator2.default)(_iterator.next());
          case 6:
            if (!(_iteratorAbruptCompletion = !(_step = _context.sent).done)) {
              _context.next = 14;
              break;
            }
            batch = _step.value;
            batch.data = (0, _gis.geojsonToBinary)(batch.data);
            _context.next = 11;
            return batch;
          case 11:
            _iteratorAbruptCompletion = false;
            _context.next = 4;
            break;
          case 14:
            _context.next = 20;
            break;
          case 16:
            _context.prev = 16;
            _context.t0 = _context["catch"](2);
            _didIteratorError = true;
            _iteratorError = _context.t0;
          case 20:
            _context.prev = 20;
            _context.prev = 21;
            if (!(_iteratorAbruptCompletion && _iterator.return != null)) {
              _context.next = 25;
              break;
            }
            _context.next = 25;
            return (0, _awaitAsyncGenerator2.default)(_iterator.return());
          case 25:
            _context.prev = 25;
            if (!_didIteratorError) {
              _context.next = 28;
              break;
            }
            throw _iteratorError;
          case 28:
            return _context.finish(25);
          case 29:
            return _context.finish(20);
          case 30:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[2, 16, 20, 30], [21,, 25, 29]]);
  }));
  return _makeBinaryGeometryIterator.apply(this, arguments);
}
//# sourceMappingURL=geojson-loader.js.map