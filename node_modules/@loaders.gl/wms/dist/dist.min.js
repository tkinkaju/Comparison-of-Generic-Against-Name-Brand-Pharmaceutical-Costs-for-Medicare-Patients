var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[Object.keys(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};

// ../xml/node_modules/fast-xml-parser/src/util.js
var require_util = __commonJS({
  "../xml/node_modules/fast-xml-parser/src/util.js"(exports2) {
    "use strict";
    var nameStartChar = ":A-Za-z_\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
    var nameChar = nameStartChar + "\\-.\\d\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
    var nameRegexp = "[" + nameStartChar + "][" + nameChar + "]*";
    var regexName = new RegExp("^" + nameRegexp + "$");
    var getAllMatches = function(string, regex) {
      const matches2 = [];
      let match = regex.exec(string);
      while (match) {
        const allmatches = [];
        allmatches.startIndex = regex.lastIndex - match[0].length;
        const len = match.length;
        for (let index = 0; index < len; index++) {
          allmatches.push(match[index]);
        }
        matches2.push(allmatches);
        match = regex.exec(string);
      }
      return matches2;
    };
    var isName = function(string) {
      const match = regexName.exec(string);
      return !(match === null || typeof match === "undefined");
    };
    exports2.isExist = function(v) {
      return typeof v !== "undefined";
    };
    exports2.isEmptyObject = function(obj) {
      return Object.keys(obj).length === 0;
    };
    exports2.merge = function(target, a, arrayMode) {
      if (a) {
        const keys = Object.keys(a);
        const len = keys.length;
        for (let i = 0; i < len; i++) {
          if (arrayMode === "strict") {
            target[keys[i]] = [a[keys[i]]];
          } else {
            target[keys[i]] = a[keys[i]];
          }
        }
      }
    };
    exports2.getValue = function(v) {
      if (exports2.isExist(v)) {
        return v;
      } else {
        return "";
      }
    };
    exports2.isName = isName;
    exports2.getAllMatches = getAllMatches;
    exports2.nameRegexp = nameRegexp;
  }
});

// ../xml/node_modules/fast-xml-parser/src/validator.js
var require_validator = __commonJS({
  "../xml/node_modules/fast-xml-parser/src/validator.js"(exports2) {
    "use strict";
    var util = require_util();
    var defaultOptions = {
      allowBooleanAttributes: false,
      unpairedTags: []
    };
    exports2.validate = function(xmlData, options) {
      options = Object.assign({}, defaultOptions, options);
      const tags = [];
      let tagFound = false;
      let reachedRoot = false;
      if (xmlData[0] === "\uFEFF") {
        xmlData = xmlData.substr(1);
      }
      for (let i = 0; i < xmlData.length; i++) {
        if (xmlData[i] === "<" && xmlData[i + 1] === "?") {
          i += 2;
          i = readPI(xmlData, i);
          if (i.err)
            return i;
        } else if (xmlData[i] === "<") {
          let tagStartPos = i;
          i++;
          if (xmlData[i] === "!") {
            i = readCommentAndCDATA(xmlData, i);
            continue;
          } else {
            let closingTag = false;
            if (xmlData[i] === "/") {
              closingTag = true;
              i++;
            }
            let tagName = "";
            for (; i < xmlData.length && xmlData[i] !== ">" && xmlData[i] !== " " && xmlData[i] !== "	" && xmlData[i] !== "\n" && xmlData[i] !== "\r"; i++) {
              tagName += xmlData[i];
            }
            tagName = tagName.trim();
            if (tagName[tagName.length - 1] === "/") {
              tagName = tagName.substring(0, tagName.length - 1);
              i--;
            }
            if (!validateTagName(tagName)) {
              let msg;
              if (tagName.trim().length === 0) {
                msg = "Invalid space after '<'.";
              } else {
                msg = "Tag '" + tagName + "' is an invalid name.";
              }
              return getErrorObject("InvalidTag", msg, getLineNumberForPosition(xmlData, i));
            }
            const result = readAttributeStr(xmlData, i);
            if (result === false) {
              return getErrorObject("InvalidAttr", "Attributes for '" + tagName + "' have open quote.", getLineNumberForPosition(xmlData, i));
            }
            let attrStr = result.value;
            i = result.index;
            if (attrStr[attrStr.length - 1] === "/") {
              const attrStrStart = i - attrStr.length;
              attrStr = attrStr.substring(0, attrStr.length - 1);
              const isValid = validateAttributeString(attrStr, options);
              if (isValid === true) {
                tagFound = true;
              } else {
                return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, attrStrStart + isValid.err.line));
              }
            } else if (closingTag) {
              if (!result.tagClosed) {
                return getErrorObject("InvalidTag", "Closing tag '" + tagName + "' doesn't have proper closing.", getLineNumberForPosition(xmlData, i));
              } else if (attrStr.trim().length > 0) {
                return getErrorObject("InvalidTag", "Closing tag '" + tagName + "' can't have attributes or invalid starting.", getLineNumberForPosition(xmlData, tagStartPos));
              } else {
                const otg = tags.pop();
                if (tagName !== otg.tagName) {
                  let openPos = getLineNumberForPosition(xmlData, otg.tagStartPos);
                  return getErrorObject("InvalidTag", "Expected closing tag '" + otg.tagName + "' (opened in line " + openPos.line + ", col " + openPos.col + ") instead of closing tag '" + tagName + "'.", getLineNumberForPosition(xmlData, tagStartPos));
                }
                if (tags.length == 0) {
                  reachedRoot = true;
                }
              }
            } else {
              const isValid = validateAttributeString(attrStr, options);
              if (isValid !== true) {
                return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, i - attrStr.length + isValid.err.line));
              }
              if (reachedRoot === true) {
                return getErrorObject("InvalidXml", "Multiple possible root nodes found.", getLineNumberForPosition(xmlData, i));
              } else if (options.unpairedTags.indexOf(tagName) !== -1) {
              } else {
                tags.push({ tagName, tagStartPos });
              }
              tagFound = true;
            }
            for (i++; i < xmlData.length; i++) {
              if (xmlData[i] === "<") {
                if (xmlData[i + 1] === "!") {
                  i++;
                  i = readCommentAndCDATA(xmlData, i);
                  continue;
                } else if (xmlData[i + 1] === "?") {
                  i = readPI(xmlData, ++i);
                  if (i.err)
                    return i;
                } else {
                  break;
                }
              } else if (xmlData[i] === "&") {
                const afterAmp = validateAmpersand(xmlData, i);
                if (afterAmp == -1)
                  return getErrorObject("InvalidChar", "char '&' is not expected.", getLineNumberForPosition(xmlData, i));
                i = afterAmp;
              } else {
                if (reachedRoot === true && !isWhiteSpace(xmlData[i])) {
                  return getErrorObject("InvalidXml", "Extra text at the end", getLineNumberForPosition(xmlData, i));
                }
              }
            }
            if (xmlData[i] === "<") {
              i--;
            }
          }
        } else {
          if (isWhiteSpace(xmlData[i])) {
            continue;
          }
          return getErrorObject("InvalidChar", "char '" + xmlData[i] + "' is not expected.", getLineNumberForPosition(xmlData, i));
        }
      }
      if (!tagFound) {
        return getErrorObject("InvalidXml", "Start tag expected.", 1);
      } else if (tags.length == 1) {
        return getErrorObject("InvalidTag", "Unclosed tag '" + tags[0].tagName + "'.", getLineNumberForPosition(xmlData, tags[0].tagStartPos));
      } else if (tags.length > 0) {
        return getErrorObject("InvalidXml", "Invalid '" + JSON.stringify(tags.map((t) => t.tagName), null, 4).replace(/\r?\n/g, "") + "' found.", { line: 1, col: 1 });
      }
      return true;
    };
    function isWhiteSpace(char) {
      return char === " " || char === "	" || char === "\n" || char === "\r";
    }
    function readPI(xmlData, i) {
      const start = i;
      for (; i < xmlData.length; i++) {
        if (xmlData[i] == "?" || xmlData[i] == " ") {
          const tagname = xmlData.substr(start, i - start);
          if (i > 5 && tagname === "xml") {
            return getErrorObject("InvalidXml", "XML declaration allowed only at the start of the document.", getLineNumberForPosition(xmlData, i));
          } else if (xmlData[i] == "?" && xmlData[i + 1] == ">") {
            i++;
            break;
          } else {
            continue;
          }
        }
      }
      return i;
    }
    function readCommentAndCDATA(xmlData, i) {
      if (xmlData.length > i + 5 && xmlData[i + 1] === "-" && xmlData[i + 2] === "-") {
        for (i += 3; i < xmlData.length; i++) {
          if (xmlData[i] === "-" && xmlData[i + 1] === "-" && xmlData[i + 2] === ">") {
            i += 2;
            break;
          }
        }
      } else if (xmlData.length > i + 8 && xmlData[i + 1] === "D" && xmlData[i + 2] === "O" && xmlData[i + 3] === "C" && xmlData[i + 4] === "T" && xmlData[i + 5] === "Y" && xmlData[i + 6] === "P" && xmlData[i + 7] === "E") {
        let angleBracketsCount = 1;
        for (i += 8; i < xmlData.length; i++) {
          if (xmlData[i] === "<") {
            angleBracketsCount++;
          } else if (xmlData[i] === ">") {
            angleBracketsCount--;
            if (angleBracketsCount === 0) {
              break;
            }
          }
        }
      } else if (xmlData.length > i + 9 && xmlData[i + 1] === "[" && xmlData[i + 2] === "C" && xmlData[i + 3] === "D" && xmlData[i + 4] === "A" && xmlData[i + 5] === "T" && xmlData[i + 6] === "A" && xmlData[i + 7] === "[") {
        for (i += 8; i < xmlData.length; i++) {
          if (xmlData[i] === "]" && xmlData[i + 1] === "]" && xmlData[i + 2] === ">") {
            i += 2;
            break;
          }
        }
      }
      return i;
    }
    var doubleQuote = '"';
    var singleQuote = "'";
    function readAttributeStr(xmlData, i) {
      let attrStr = "";
      let startChar = "";
      let tagClosed = false;
      for (; i < xmlData.length; i++) {
        if (xmlData[i] === doubleQuote || xmlData[i] === singleQuote) {
          if (startChar === "") {
            startChar = xmlData[i];
          } else if (startChar !== xmlData[i]) {
          } else {
            startChar = "";
          }
        } else if (xmlData[i] === ">") {
          if (startChar === "") {
            tagClosed = true;
            break;
          }
        }
        attrStr += xmlData[i];
      }
      if (startChar !== "") {
        return false;
      }
      return {
        value: attrStr,
        index: i,
        tagClosed
      };
    }
    var validAttrStrRegxp = new RegExp(`(\\s*)([^\\s=]+)(\\s*=)?(\\s*(['"])(([\\s\\S])*?)\\5)?`, "g");
    function validateAttributeString(attrStr, options) {
      const matches2 = util.getAllMatches(attrStr, validAttrStrRegxp);
      const attrNames = {};
      for (let i = 0; i < matches2.length; i++) {
        if (matches2[i][1].length === 0) {
          return getErrorObject("InvalidAttr", "Attribute '" + matches2[i][2] + "' has no space in starting.", getPositionFromMatch(matches2[i]));
        } else if (matches2[i][3] !== void 0 && matches2[i][4] === void 0) {
          return getErrorObject("InvalidAttr", "Attribute '" + matches2[i][2] + "' is without value.", getPositionFromMatch(matches2[i]));
        } else if (matches2[i][3] === void 0 && !options.allowBooleanAttributes) {
          return getErrorObject("InvalidAttr", "boolean attribute '" + matches2[i][2] + "' is not allowed.", getPositionFromMatch(matches2[i]));
        }
        const attrName = matches2[i][2];
        if (!validateAttrName(attrName)) {
          return getErrorObject("InvalidAttr", "Attribute '" + attrName + "' is an invalid name.", getPositionFromMatch(matches2[i]));
        }
        if (!attrNames.hasOwnProperty(attrName)) {
          attrNames[attrName] = 1;
        } else {
          return getErrorObject("InvalidAttr", "Attribute '" + attrName + "' is repeated.", getPositionFromMatch(matches2[i]));
        }
      }
      return true;
    }
    function validateNumberAmpersand(xmlData, i) {
      let re = /\d/;
      if (xmlData[i] === "x") {
        i++;
        re = /[\da-fA-F]/;
      }
      for (; i < xmlData.length; i++) {
        if (xmlData[i] === ";")
          return i;
        if (!xmlData[i].match(re))
          break;
      }
      return -1;
    }
    function validateAmpersand(xmlData, i) {
      i++;
      if (xmlData[i] === ";")
        return -1;
      if (xmlData[i] === "#") {
        i++;
        return validateNumberAmpersand(xmlData, i);
      }
      let count = 0;
      for (; i < xmlData.length; i++, count++) {
        if (xmlData[i].match(/\w/) && count < 20)
          continue;
        if (xmlData[i] === ";")
          break;
        return -1;
      }
      return i;
    }
    function getErrorObject(code, message, lineNumber) {
      return {
        err: {
          code,
          msg: message,
          line: lineNumber.line || lineNumber,
          col: lineNumber.col
        }
      };
    }
    function validateAttrName(attrName) {
      return util.isName(attrName);
    }
    function validateTagName(tagname) {
      return util.isName(tagname);
    }
    function getLineNumberForPosition(xmlData, index) {
      const lines = xmlData.substring(0, index).split(/\r?\n/);
      return {
        line: lines.length,
        col: lines[lines.length - 1].length + 1
      };
    }
    function getPositionFromMatch(match) {
      return match.startIndex + match[1].length;
    }
  }
});

// ../xml/node_modules/fast-xml-parser/src/xmlparser/OptionsBuilder.js
var require_OptionsBuilder = __commonJS({
  "../xml/node_modules/fast-xml-parser/src/xmlparser/OptionsBuilder.js"(exports2) {
    var defaultOptions = {
      preserveOrder: false,
      attributeNamePrefix: "@_",
      attributesGroupName: false,
      textNodeName: "#text",
      ignoreAttributes: true,
      removeNSPrefix: false,
      allowBooleanAttributes: false,
      parseTagValue: true,
      parseAttributeValue: false,
      trimValues: true,
      cdataPropName: false,
      numberParseOptions: {
        hex: true,
        leadingZeros: true
      },
      tagValueProcessor: function(tagName, val) {
        return val;
      },
      attributeValueProcessor: function(attrName, val) {
        return val;
      },
      stopNodes: [],
      alwaysCreateTextNode: false,
      isArray: () => false,
      commentPropName: false,
      unpairedTags: [],
      processEntities: true,
      htmlEntities: false,
      ignoreDeclaration: false,
      ignorePiTags: false,
      transformTagName: false
    };
    var buildOptions = function(options) {
      return Object.assign({}, defaultOptions, options);
    };
    exports2.buildOptions = buildOptions;
    exports2.defaultOptions = defaultOptions;
  }
});

// ../xml/node_modules/fast-xml-parser/src/xmlparser/xmlNode.js
var require_xmlNode = __commonJS({
  "../xml/node_modules/fast-xml-parser/src/xmlparser/xmlNode.js"(exports2, module2) {
    "use strict";
    var XmlNode = class {
      constructor(tagname) {
        this.tagname = tagname;
        this.child = [];
        this[":@"] = {};
      }
      add(key, val) {
        this.child.push({ [key]: val });
      }
      addChild(node) {
        if (node[":@"] && Object.keys(node[":@"]).length > 0) {
          this.child.push({ [node.tagname]: node.child, [":@"]: node[":@"] });
        } else {
          this.child.push({ [node.tagname]: node.child });
        }
      }
    };
    module2.exports = XmlNode;
  }
});

// ../xml/node_modules/fast-xml-parser/src/xmlparser/DocTypeReader.js
var require_DocTypeReader = __commonJS({
  "../xml/node_modules/fast-xml-parser/src/xmlparser/DocTypeReader.js"(exports2, module2) {
    function readDocType(xmlData, i) {
      const entities = {};
      if (xmlData[i + 3] === "O" && xmlData[i + 4] === "C" && xmlData[i + 5] === "T" && xmlData[i + 6] === "Y" && xmlData[i + 7] === "P" && xmlData[i + 8] === "E") {
        i = i + 9;
        let angleBracketsCount = 1;
        let hasBody = false, entity = false, comment = false;
        let exp = "";
        for (; i < xmlData.length; i++) {
          if (xmlData[i] === "<") {
            if (hasBody && xmlData[i + 1] === "!" && xmlData[i + 2] === "E" && xmlData[i + 3] === "N" && xmlData[i + 4] === "T" && xmlData[i + 5] === "I" && xmlData[i + 6] === "T" && xmlData[i + 7] === "Y") {
              i += 7;
              entity = true;
            } else if (hasBody && xmlData[i + 1] === "!" && xmlData[i + 2] === "E" && xmlData[i + 3] === "L" && xmlData[i + 4] === "E" && xmlData[i + 5] === "M" && xmlData[i + 6] === "E" && xmlData[i + 7] === "N" && xmlData[i + 8] === "T") {
              i += 8;
            } else if (hasBody && xmlData[i + 1] === "!" && xmlData[i + 2] === "A" && xmlData[i + 3] === "T" && xmlData[i + 4] === "T" && xmlData[i + 5] === "L" && xmlData[i + 6] === "I" && xmlData[i + 7] === "S" && xmlData[i + 8] === "T") {
              i += 8;
            } else if (hasBody && xmlData[i + 1] === "!" && xmlData[i + 2] === "N" && xmlData[i + 3] === "O" && xmlData[i + 4] === "T" && xmlData[i + 5] === "A" && xmlData[i + 6] === "T" && xmlData[i + 7] === "I" && xmlData[i + 8] === "O" && xmlData[i + 9] === "N") {
              i += 9;
            } else if (xmlData[i + 1] === "!" && xmlData[i + 2] === "-" && xmlData[i + 3] === "-") {
              comment = true;
            } else {
              throw new Error("Invalid DOCTYPE");
            }
            angleBracketsCount++;
            exp = "";
          } else if (xmlData[i] === ">") {
            if (comment) {
              if (xmlData[i - 1] === "-" && xmlData[i - 2] === "-") {
                comment = false;
              } else {
                throw new Error(`Invalid XML comment in DOCTYPE`);
              }
            } else if (entity) {
              parseEntityExp(exp, entities);
              entity = false;
            }
            angleBracketsCount--;
            if (angleBracketsCount === 0) {
              break;
            }
          } else if (xmlData[i] === "[") {
            hasBody = true;
          } else {
            exp += xmlData[i];
          }
        }
        if (angleBracketsCount !== 0) {
          throw new Error(`Unclosed DOCTYPE`);
        }
      } else {
        throw new Error(`Invalid Tag instead of DOCTYPE`);
      }
      return { entities, i };
    }
    var entityRegex = RegExp(`^\\s([a-zA-z0-0]+)[ 	](['"])([^&]+)\\2`);
    function parseEntityExp(exp, entities) {
      const match = entityRegex.exec(exp);
      if (match) {
        entities[match[1]] = {
          regx: RegExp(`&${match[1]};`, "g"),
          val: match[3]
        };
      }
    }
    module2.exports = readDocType;
  }
});

// ../../node_modules/strnum/strnum.js
var require_strnum = __commonJS({
  "../../node_modules/strnum/strnum.js"(exports2, module2) {
    var hexRegex = /^[-+]?0x[a-fA-F0-9]+$/;
    var numRegex = /^([\-\+])?(0*)(\.[0-9]+([eE]\-?[0-9]+)?|[0-9]+(\.[0-9]+([eE]\-?[0-9]+)?)?)$/;
    if (!Number.parseInt && window.parseInt) {
      Number.parseInt = window.parseInt;
    }
    if (!Number.parseFloat && window.parseFloat) {
      Number.parseFloat = window.parseFloat;
    }
    var consider = {
      hex: true,
      leadingZeros: true,
      decimalPoint: ".",
      eNotation: true
    };
    function toNumber(str, options = {}) {
      options = Object.assign({}, consider, options);
      if (!str || typeof str !== "string")
        return str;
      let trimmedStr = str.trim();
      if (options.skipLike !== void 0 && options.skipLike.test(trimmedStr))
        return str;
      else if (options.hex && hexRegex.test(trimmedStr)) {
        return Number.parseInt(trimmedStr, 16);
      } else {
        const match = numRegex.exec(trimmedStr);
        if (match) {
          const sign = match[1];
          const leadingZeros = match[2];
          let numTrimmedByZeros = trimZeros(match[3]);
          const eNotation = match[4] || match[6];
          if (!options.leadingZeros && leadingZeros.length > 0 && sign && trimmedStr[2] !== ".")
            return str;
          else if (!options.leadingZeros && leadingZeros.length > 0 && !sign && trimmedStr[1] !== ".")
            return str;
          else {
            const num = Number(trimmedStr);
            const numStr = "" + num;
            if (numStr.search(/[eE]/) !== -1) {
              if (options.eNotation)
                return num;
              else
                return str;
            } else if (eNotation) {
              if (options.eNotation)
                return num;
              else
                return str;
            } else if (trimmedStr.indexOf(".") !== -1) {
              if (numStr === "0" && numTrimmedByZeros === "")
                return num;
              else if (numStr === numTrimmedByZeros)
                return num;
              else if (sign && numStr === "-" + numTrimmedByZeros)
                return num;
              else
                return str;
            }
            if (leadingZeros) {
              if (numTrimmedByZeros === numStr)
                return num;
              else if (sign + numTrimmedByZeros === numStr)
                return num;
              else
                return str;
            }
            if (trimmedStr === numStr)
              return num;
            else if (trimmedStr === sign + numStr)
              return num;
            return str;
          }
        } else {
          return str;
        }
      }
    }
    function trimZeros(numStr) {
      if (numStr && numStr.indexOf(".") !== -1) {
        numStr = numStr.replace(/0+$/, "");
        if (numStr === ".")
          numStr = "0";
        else if (numStr[0] === ".")
          numStr = "0" + numStr;
        else if (numStr[numStr.length - 1] === ".")
          numStr = numStr.substr(0, numStr.length - 1);
        return numStr;
      }
      return numStr;
    }
    module2.exports = toNumber;
  }
});

// ../xml/node_modules/fast-xml-parser/src/xmlparser/OrderedObjParser.js
var require_OrderedObjParser = __commonJS({
  "../xml/node_modules/fast-xml-parser/src/xmlparser/OrderedObjParser.js"(exports2, module2) {
    "use strict";
    var util = require_util();
    var xmlNode = require_xmlNode();
    var readDocType = require_DocTypeReader();
    var toNumber = require_strnum();
    var regx = "<((!\\[CDATA\\[([\\s\\S]*?)(]]>))|((NAME:)?(NAME))([^>]*)>|((\\/)(NAME)\\s*>))([^<]*)".replace(/NAME/g, util.nameRegexp);
    var OrderedObjParser = class {
      constructor(options) {
        this.options = options;
        this.currentNode = null;
        this.tagsNodeStack = [];
        this.docTypeEntities = {};
        this.lastEntities = {
          "apos": { regex: /&(apos|#39|#x27);/g, val: "'" },
          "gt": { regex: /&(gt|#62|#x3E);/g, val: ">" },
          "lt": { regex: /&(lt|#60|#x3C);/g, val: "<" },
          "quot": { regex: /&(quot|#34|#x22);/g, val: '"' }
        };
        this.ampEntity = { regex: /&(amp|#38|#x26);/g, val: "&" };
        this.htmlEntities = {
          "space": { regex: /&(nbsp|#160);/g, val: " " },
          "cent": { regex: /&(cent|#162);/g, val: "\xA2" },
          "pound": { regex: /&(pound|#163);/g, val: "\xA3" },
          "yen": { regex: /&(yen|#165);/g, val: "\xA5" },
          "euro": { regex: /&(euro|#8364);/g, val: "\u20AC" },
          "copyright": { regex: /&(copy|#169);/g, val: "\xA9" },
          "reg": { regex: /&(reg|#174);/g, val: "\xAE" },
          "inr": { regex: /&(inr|#8377);/g, val: "\u20B9" }
        };
        this.addExternalEntities = addExternalEntities;
        this.parseXml = parseXml;
        this.parseTextData = parseTextData;
        this.resolveNameSpace = resolveNameSpace;
        this.buildAttributesMap = buildAttributesMap;
        this.isItStopNode = isItStopNode;
        this.replaceEntitiesValue = replaceEntitiesValue;
        this.readStopNodeData = readStopNodeData;
        this.saveTextToParentTag = saveTextToParentTag;
      }
    };
    function addExternalEntities(externalEntities) {
      const entKeys = Object.keys(externalEntities);
      for (let i = 0; i < entKeys.length; i++) {
        const ent = entKeys[i];
        this.lastEntities[ent] = {
          regex: new RegExp("&" + ent + ";", "g"),
          val: externalEntities[ent]
        };
      }
    }
    function parseTextData(val, tagName, jPath, dontTrim, hasAttributes, isLeafNode, escapeEntities) {
      if (val !== void 0) {
        if (this.options.trimValues && !dontTrim) {
          val = val.trim();
        }
        if (val.length > 0) {
          if (!escapeEntities)
            val = this.replaceEntitiesValue(val);
          const newval = this.options.tagValueProcessor(tagName, val, jPath, hasAttributes, isLeafNode);
          if (newval === null || newval === void 0) {
            return val;
          } else if (typeof newval !== typeof val || newval !== val) {
            return newval;
          } else if (this.options.trimValues) {
            return parseValue(val, this.options.parseTagValue, this.options.numberParseOptions);
          } else {
            const trimmedVal = val.trim();
            if (trimmedVal === val) {
              return parseValue(val, this.options.parseTagValue, this.options.numberParseOptions);
            } else {
              return val;
            }
          }
        }
      }
    }
    function resolveNameSpace(tagname) {
      if (this.options.removeNSPrefix) {
        const tags = tagname.split(":");
        const prefix = tagname.charAt(0) === "/" ? "/" : "";
        if (tags[0] === "xmlns") {
          return "";
        }
        if (tags.length === 2) {
          tagname = prefix + tags[1];
        }
      }
      return tagname;
    }
    var attrsRegx = new RegExp(`([^\\s=]+)\\s*(=\\s*(['"])([\\s\\S]*?)\\3)?`, "gm");
    function buildAttributesMap(attrStr, jPath) {
      if (!this.options.ignoreAttributes && typeof attrStr === "string") {
        const matches2 = util.getAllMatches(attrStr, attrsRegx);
        const len = matches2.length;
        const attrs = {};
        for (let i = 0; i < len; i++) {
          const attrName = this.resolveNameSpace(matches2[i][1]);
          let oldVal = matches2[i][4];
          const aName = this.options.attributeNamePrefix + attrName;
          if (attrName.length) {
            if (oldVal !== void 0) {
              if (this.options.trimValues) {
                oldVal = oldVal.trim();
              }
              oldVal = this.replaceEntitiesValue(oldVal);
              const newVal = this.options.attributeValueProcessor(attrName, oldVal, jPath);
              if (newVal === null || newVal === void 0) {
                attrs[aName] = oldVal;
              } else if (typeof newVal !== typeof oldVal || newVal !== oldVal) {
                attrs[aName] = newVal;
              } else {
                attrs[aName] = parseValue(oldVal, this.options.parseAttributeValue, this.options.numberParseOptions);
              }
            } else if (this.options.allowBooleanAttributes) {
              attrs[aName] = true;
            }
          }
        }
        if (!Object.keys(attrs).length) {
          return;
        }
        if (this.options.attributesGroupName) {
          const attrCollection = {};
          attrCollection[this.options.attributesGroupName] = attrs;
          return attrCollection;
        }
        return attrs;
      }
    }
    var parseXml = function(xmlData) {
      xmlData = xmlData.replace(/\r\n?/g, "\n");
      const xmlObj = new xmlNode("!xml");
      let currentNode = xmlObj;
      let textData = "";
      let jPath = "";
      for (let i = 0; i < xmlData.length; i++) {
        const ch = xmlData[i];
        if (ch === "<") {
          if (xmlData[i + 1] === "/") {
            const closeIndex = findClosingIndex(xmlData, ">", i, "Closing Tag is not closed.");
            let tagName = xmlData.substring(i + 2, closeIndex).trim();
            if (this.options.removeNSPrefix) {
              const colonIndex = tagName.indexOf(":");
              if (colonIndex !== -1) {
                tagName = tagName.substr(colonIndex + 1);
              }
            }
            if (this.options.transformTagName) {
              tagName = this.options.transformTagName(tagName);
            }
            if (currentNode) {
              textData = this.saveTextToParentTag(textData, currentNode, jPath);
            }
            jPath = jPath.substr(0, jPath.lastIndexOf("."));
            currentNode = this.tagsNodeStack.pop();
            textData = "";
            i = closeIndex;
          } else if (xmlData[i + 1] === "?") {
            let tagData = readTagExp(xmlData, i, false, "?>");
            if (!tagData)
              throw new Error("Pi Tag is not closed.");
            textData = this.saveTextToParentTag(textData, currentNode, jPath);
            if (this.options.ignoreDeclaration && tagData.tagName === "?xml" || this.options.ignorePiTags) {
            } else {
              const childNode = new xmlNode(tagData.tagName);
              childNode.add(this.options.textNodeName, "");
              if (tagData.tagName !== tagData.tagExp && tagData.attrExpPresent) {
                childNode[":@"] = this.buildAttributesMap(tagData.tagExp, jPath);
              }
              currentNode.addChild(childNode);
            }
            i = tagData.closeIndex + 1;
          } else if (xmlData.substr(i + 1, 3) === "!--") {
            const endIndex = findClosingIndex(xmlData, "-->", i + 4, "Comment is not closed.");
            if (this.options.commentPropName) {
              const comment = xmlData.substring(i + 4, endIndex - 2);
              textData = this.saveTextToParentTag(textData, currentNode, jPath);
              currentNode.add(this.options.commentPropName, [{ [this.options.textNodeName]: comment }]);
            }
            i = endIndex;
          } else if (xmlData.substr(i + 1, 2) === "!D") {
            const result = readDocType(xmlData, i);
            this.docTypeEntities = result.entities;
            i = result.i;
          } else if (xmlData.substr(i + 1, 2) === "![") {
            const closeIndex = findClosingIndex(xmlData, "]]>", i, "CDATA is not closed.") - 2;
            const tagExp = xmlData.substring(i + 9, closeIndex);
            textData = this.saveTextToParentTag(textData, currentNode, jPath);
            if (this.options.cdataPropName) {
              currentNode.add(this.options.cdataPropName, [{ [this.options.textNodeName]: tagExp }]);
            } else {
              let val = this.parseTextData(tagExp, currentNode.tagname, jPath, true, false, true);
              if (val == void 0)
                val = "";
              currentNode.add(this.options.textNodeName, val);
            }
            i = closeIndex + 2;
          } else {
            let result = readTagExp(xmlData, i, this.options.removeNSPrefix);
            let tagName = result.tagName;
            let tagExp = result.tagExp;
            let attrExpPresent = result.attrExpPresent;
            let closeIndex = result.closeIndex;
            if (this.options.transformTagName) {
              tagName = this.options.transformTagName(tagName);
            }
            if (currentNode && textData) {
              if (currentNode.tagname !== "!xml") {
                textData = this.saveTextToParentTag(textData, currentNode, jPath, false);
              }
            }
            if (tagName !== xmlObj.tagname) {
              jPath += jPath ? "." + tagName : tagName;
            }
            const lastTag = currentNode;
            if (lastTag && this.options.unpairedTags.indexOf(lastTag.tagname) !== -1) {
              currentNode = this.tagsNodeStack.pop();
            }
            if (this.isItStopNode(this.options.stopNodes, jPath, tagName)) {
              let tagContent = "";
              if (tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1) {
                i = result.closeIndex;
              } else if (this.options.unpairedTags.indexOf(tagName) !== -1) {
                i = result.closeIndex;
              } else {
                const result2 = this.readStopNodeData(xmlData, tagName, closeIndex + 1);
                if (!result2)
                  throw new Error(`Unexpected end of ${tagName}`);
                i = result2.i;
                tagContent = result2.tagContent;
              }
              const childNode = new xmlNode(tagName);
              if (tagName !== tagExp && attrExpPresent) {
                childNode[":@"] = this.buildAttributesMap(tagExp, jPath);
              }
              if (tagContent) {
                tagContent = this.parseTextData(tagContent, tagName, jPath, true, attrExpPresent, true, true);
              }
              jPath = jPath.substr(0, jPath.lastIndexOf("."));
              childNode.add(this.options.textNodeName, tagContent);
              currentNode.addChild(childNode);
            } else {
              if (tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1) {
                if (tagName[tagName.length - 1] === "/") {
                  tagName = tagName.substr(0, tagName.length - 1);
                  tagExp = tagName;
                } else {
                  tagExp = tagExp.substr(0, tagExp.length - 1);
                }
                if (this.options.transformTagName) {
                  tagName = this.options.transformTagName(tagName);
                }
                const childNode = new xmlNode(tagName);
                if (tagName !== tagExp && attrExpPresent) {
                  childNode[":@"] = this.buildAttributesMap(tagExp, jPath);
                }
                jPath = jPath.substr(0, jPath.lastIndexOf("."));
                currentNode.addChild(childNode);
              } else {
                const childNode = new xmlNode(tagName);
                this.tagsNodeStack.push(currentNode);
                if (tagName !== tagExp && attrExpPresent) {
                  childNode[":@"] = this.buildAttributesMap(tagExp, jPath);
                }
                currentNode.addChild(childNode);
                currentNode = childNode;
              }
              textData = "";
              i = closeIndex;
            }
          }
        } else {
          textData += xmlData[i];
        }
      }
      return xmlObj.child;
    };
    var replaceEntitiesValue = function(val) {
      if (this.options.processEntities) {
        for (let entityName in this.docTypeEntities) {
          const entity = this.docTypeEntities[entityName];
          val = val.replace(entity.regx, entity.val);
        }
        for (let entityName in this.lastEntities) {
          const entity = this.lastEntities[entityName];
          val = val.replace(entity.regex, entity.val);
        }
        if (this.options.htmlEntities) {
          for (let entityName in this.htmlEntities) {
            const entity = this.htmlEntities[entityName];
            val = val.replace(entity.regex, entity.val);
          }
        }
        val = val.replace(this.ampEntity.regex, this.ampEntity.val);
      }
      return val;
    };
    function saveTextToParentTag(textData, currentNode, jPath, isLeafNode) {
      if (textData) {
        if (isLeafNode === void 0)
          isLeafNode = Object.keys(currentNode.child).length === 0;
        textData = this.parseTextData(textData, currentNode.tagname, jPath, false, currentNode[":@"] ? Object.keys(currentNode[":@"]).length !== 0 : false, isLeafNode);
        if (textData !== void 0 && textData !== "")
          currentNode.add(this.options.textNodeName, textData);
        textData = "";
      }
      return textData;
    }
    function isItStopNode(stopNodes, jPath, currentTagName) {
      const allNodesExp = "*." + currentTagName;
      for (const stopNodePath in stopNodes) {
        const stopNodeExp = stopNodes[stopNodePath];
        if (allNodesExp === stopNodeExp || jPath === stopNodeExp)
          return true;
      }
      return false;
    }
    function tagExpWithClosingIndex(xmlData, i, closingChar = ">") {
      let attrBoundary;
      let tagExp = "";
      for (let index = i; index < xmlData.length; index++) {
        let ch = xmlData[index];
        if (attrBoundary) {
          if (ch === attrBoundary)
            attrBoundary = "";
        } else if (ch === '"' || ch === "'") {
          attrBoundary = ch;
        } else if (ch === closingChar[0]) {
          if (closingChar[1]) {
            if (xmlData[index + 1] === closingChar[1]) {
              return {
                data: tagExp,
                index
              };
            }
          } else {
            return {
              data: tagExp,
              index
            };
          }
        } else if (ch === "	") {
          ch = " ";
        }
        tagExp += ch;
      }
    }
    function findClosingIndex(xmlData, str, i, errMsg) {
      const closingIndex = xmlData.indexOf(str, i);
      if (closingIndex === -1) {
        throw new Error(errMsg);
      } else {
        return closingIndex + str.length - 1;
      }
    }
    function readTagExp(xmlData, i, removeNSPrefix, closingChar = ">") {
      const result = tagExpWithClosingIndex(xmlData, i + 1, closingChar);
      if (!result)
        return;
      let tagExp = result.data;
      const closeIndex = result.index;
      const separatorIndex = tagExp.search(/\s/);
      let tagName = tagExp;
      let attrExpPresent = true;
      if (separatorIndex !== -1) {
        tagName = tagExp.substr(0, separatorIndex).replace(/\s\s*$/, "");
        tagExp = tagExp.substr(separatorIndex + 1);
      }
      if (removeNSPrefix) {
        const colonIndex = tagName.indexOf(":");
        if (colonIndex !== -1) {
          tagName = tagName.substr(colonIndex + 1);
          attrExpPresent = tagName !== result.data.substr(colonIndex + 1);
        }
      }
      return {
        tagName,
        tagExp,
        closeIndex,
        attrExpPresent
      };
    }
    function readStopNodeData(xmlData, tagName, i) {
      const startIndex = i;
      let openTagCount = 1;
      for (; i < xmlData.length; i++) {
        if (xmlData[i] === "<") {
          if (xmlData[i + 1] === "/") {
            const closeIndex = findClosingIndex(xmlData, ">", i, `${tagName} is not closed`);
            let closeTagName = xmlData.substring(i + 2, closeIndex).trim();
            if (closeTagName === tagName) {
              openTagCount--;
              if (openTagCount === 0) {
                return {
                  tagContent: xmlData.substring(startIndex, i),
                  i: closeIndex
                };
              }
            }
            i = closeIndex;
          } else if (xmlData[i + 1] === "?") {
            const closeIndex = findClosingIndex(xmlData, "?>", i + 1, "StopNode is not closed.");
            i = closeIndex;
          } else if (xmlData.substr(i + 1, 3) === "!--") {
            const closeIndex = findClosingIndex(xmlData, "-->", i + 3, "StopNode is not closed.");
            i = closeIndex;
          } else if (xmlData.substr(i + 1, 2) === "![") {
            const closeIndex = findClosingIndex(xmlData, "]]>", i, "StopNode is not closed.") - 2;
            i = closeIndex;
          } else {
            const tagData = readTagExp(xmlData, i, ">");
            if (tagData) {
              const openTagName = tagData && tagData.tagName;
              if (openTagName === tagName && tagData.tagExp[tagData.tagExp.length - 1] !== "/") {
                openTagCount++;
              }
              i = tagData.closeIndex;
            }
          }
        }
      }
    }
    function parseValue(val, shouldParse, options) {
      if (shouldParse && typeof val === "string") {
        const newval = val.trim();
        if (newval === "true")
          return true;
        else if (newval === "false")
          return false;
        else
          return toNumber(val, options);
      } else {
        if (util.isExist(val)) {
          return val;
        } else {
          return "";
        }
      }
    }
    module2.exports = OrderedObjParser;
  }
});

// ../xml/node_modules/fast-xml-parser/src/xmlparser/node2json.js
var require_node2json = __commonJS({
  "../xml/node_modules/fast-xml-parser/src/xmlparser/node2json.js"(exports2) {
    "use strict";
    function prettify(node, options) {
      return compress(node, options);
    }
    function compress(arr, options, jPath) {
      let text;
      const compressedObj = {};
      for (let i = 0; i < arr.length; i++) {
        const tagObj = arr[i];
        const property = propName(tagObj);
        let newJpath = "";
        if (jPath === void 0)
          newJpath = property;
        else
          newJpath = jPath + "." + property;
        if (property === options.textNodeName) {
          if (text === void 0)
            text = tagObj[property];
          else
            text += "" + tagObj[property];
        } else if (property === void 0) {
          continue;
        } else if (tagObj[property]) {
          let val = compress(tagObj[property], options, newJpath);
          const isLeaf = isLeafTag(val, options);
          if (tagObj[":@"]) {
            assignAttributes(val, tagObj[":@"], newJpath, options);
          } else if (Object.keys(val).length === 1 && val[options.textNodeName] !== void 0 && !options.alwaysCreateTextNode) {
            val = val[options.textNodeName];
          } else if (Object.keys(val).length === 0) {
            if (options.alwaysCreateTextNode)
              val[options.textNodeName] = "";
            else
              val = "";
          }
          if (compressedObj[property] !== void 0 && compressedObj.hasOwnProperty(property)) {
            if (!Array.isArray(compressedObj[property])) {
              compressedObj[property] = [compressedObj[property]];
            }
            compressedObj[property].push(val);
          } else {
            if (options.isArray(property, newJpath, isLeaf)) {
              compressedObj[property] = [val];
            } else {
              compressedObj[property] = val;
            }
          }
        }
      }
      if (typeof text === "string") {
        if (text.length > 0)
          compressedObj[options.textNodeName] = text;
      } else if (text !== void 0)
        compressedObj[options.textNodeName] = text;
      return compressedObj;
    }
    function propName(obj) {
      const keys = Object.keys(obj);
      for (let i = 0; i < keys.length; i++) {
        const key = keys[i];
        if (key !== ":@")
          return key;
      }
    }
    function assignAttributes(obj, attrMap, jpath, options) {
      if (attrMap) {
        const keys = Object.keys(attrMap);
        const len = keys.length;
        for (let i = 0; i < len; i++) {
          const atrrName = keys[i];
          if (options.isArray(atrrName, jpath + "." + atrrName, true, true)) {
            obj[atrrName] = [attrMap[atrrName]];
          } else {
            obj[atrrName] = attrMap[atrrName];
          }
        }
      }
    }
    function isLeafTag(obj, options) {
      const propCount = Object.keys(obj).length;
      if (propCount === 0 || propCount === 1 && obj[options.textNodeName])
        return true;
      return false;
    }
    exports2.prettify = prettify;
  }
});

// ../xml/node_modules/fast-xml-parser/src/xmlparser/XMLParser.js
var require_XMLParser = __commonJS({
  "../xml/node_modules/fast-xml-parser/src/xmlparser/XMLParser.js"(exports2, module2) {
    var { buildOptions } = require_OptionsBuilder();
    var OrderedObjParser = require_OrderedObjParser();
    var { prettify } = require_node2json();
    var validator = require_validator();
    var XMLParser = class {
      constructor(options) {
        this.externalEntities = {};
        this.options = buildOptions(options);
      }
      parse(xmlData, validationOption) {
        if (typeof xmlData === "string") {
        } else if (xmlData.toString) {
          xmlData = xmlData.toString();
        } else {
          throw new Error("XML data is accepted in String or Bytes[] form.");
        }
        if (validationOption) {
          if (validationOption === true)
            validationOption = {};
          const result = validator.validate(xmlData, validationOption);
          if (result !== true) {
            throw Error(`${result.err.msg}:${result.err.line}:${result.err.col}`);
          }
        }
        const orderedObjParser = new OrderedObjParser(this.options);
        orderedObjParser.addExternalEntities(this.externalEntities);
        const orderedResult = orderedObjParser.parseXml(xmlData);
        if (this.options.preserveOrder || orderedResult === void 0)
          return orderedResult;
        else
          return prettify(orderedResult, this.options);
      }
      addEntity(key, value) {
        if (value.indexOf("&") !== -1) {
          throw new Error("Entity value can't have '&'");
        } else if (key.indexOf("&") !== -1 || key.indexOf(";") !== -1) {
          throw new Error("An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'");
        } else if (value === "&") {
          throw new Error("An entity with value '&' is not permitted");
        } else {
          this.externalEntities[key] = value;
        }
      }
    };
    module2.exports = XMLParser;
  }
});

// ../xml/node_modules/fast-xml-parser/src/xmlbuilder/orderedJs2Xml.js
var require_orderedJs2Xml = __commonJS({
  "../xml/node_modules/fast-xml-parser/src/xmlbuilder/orderedJs2Xml.js"(exports2, module2) {
    var EOL = "\n";
    function toXml(jArray, options) {
      return arrToStr(jArray, options, "", 0);
    }
    function arrToStr(arr, options, jPath, level) {
      let xmlStr = "";
      let indentation = "";
      if (options.format && options.indentBy.length > 0) {
        indentation = EOL + "" + options.indentBy.repeat(level);
      }
      for (let i = 0; i < arr.length; i++) {
        const tagObj = arr[i];
        const tagName = propName(tagObj);
        let newJPath = "";
        if (jPath.length === 0)
          newJPath = tagName;
        else
          newJPath = `${jPath}.${tagName}`;
        if (tagName === options.textNodeName) {
          let tagText = tagObj[tagName];
          if (!isStopNode(newJPath, options)) {
            tagText = options.tagValueProcessor(tagName, tagText);
            tagText = replaceEntitiesValue(tagText, options);
          }
          xmlStr += indentation + tagText;
          continue;
        } else if (tagName === options.cdataPropName) {
          xmlStr += indentation + `<![CDATA[${tagObj[tagName][0][options.textNodeName]}]]>`;
          continue;
        } else if (tagName === options.commentPropName) {
          xmlStr += indentation + `<!--${tagObj[tagName][0][options.textNodeName]}-->`;
          continue;
        } else if (tagName[0] === "?") {
          const attStr2 = attr_to_str(tagObj[":@"], options);
          const tempInd = tagName === "?xml" ? "" : indentation;
          let piTextNodeName = tagObj[tagName][0][options.textNodeName];
          piTextNodeName = piTextNodeName.length !== 0 ? " " + piTextNodeName : "";
          xmlStr += tempInd + `<${tagName}${piTextNodeName}${attStr2}?>`;
          continue;
        }
        const attStr = attr_to_str(tagObj[":@"], options);
        let tagStart = indentation + `<${tagName}${attStr}`;
        let tagValue = arrToStr(tagObj[tagName], options, newJPath, level + 1);
        if (options.unpairedTags.indexOf(tagName) !== -1) {
          if (options.suppressUnpairedNode)
            xmlStr += tagStart + ">";
          else
            xmlStr += tagStart + "/>";
        } else if ((!tagValue || tagValue.length === 0) && options.suppressEmptyNode) {
          xmlStr += tagStart + "/>";
        } else {
          xmlStr += tagStart + `>${tagValue}${indentation}</${tagName}>`;
        }
      }
      return xmlStr;
    }
    function propName(obj) {
      const keys = Object.keys(obj);
      for (let i = 0; i < keys.length; i++) {
        const key = keys[i];
        if (key !== ":@")
          return key;
      }
    }
    function attr_to_str(attrMap, options) {
      let attrStr = "";
      if (attrMap && !options.ignoreAttributes) {
        for (let attr in attrMap) {
          let attrVal = options.attributeValueProcessor(attr, attrMap[attr]);
          attrVal = replaceEntitiesValue(attrVal, options);
          if (attrVal === true && options.suppressBooleanAttributes) {
            attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}`;
          } else {
            attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}="${attrVal}"`;
          }
        }
      }
      return attrStr;
    }
    function isStopNode(jPath, options) {
      jPath = jPath.substr(0, jPath.length - options.textNodeName.length - 1);
      let tagName = jPath.substr(jPath.lastIndexOf(".") + 1);
      for (let index in options.stopNodes) {
        if (options.stopNodes[index] === jPath || options.stopNodes[index] === "*." + tagName)
          return true;
      }
      return false;
    }
    function replaceEntitiesValue(textValue, options) {
      if (textValue && textValue.length > 0 && options.processEntities) {
        for (let i = 0; i < options.entities.length; i++) {
          const entity = options.entities[i];
          textValue = textValue.replace(entity.regex, entity.val);
        }
      }
      return textValue;
    }
    module2.exports = toXml;
  }
});

// ../xml/node_modules/fast-xml-parser/src/xmlbuilder/json2xml.js
var require_json2xml = __commonJS({
  "../xml/node_modules/fast-xml-parser/src/xmlbuilder/json2xml.js"(exports2, module2) {
    "use strict";
    var buildFromOrderedJs = require_orderedJs2Xml();
    var defaultOptions = {
      attributeNamePrefix: "@_",
      attributesGroupName: false,
      textNodeName: "#text",
      ignoreAttributes: true,
      cdataPropName: false,
      format: false,
      indentBy: "  ",
      suppressEmptyNode: false,
      suppressUnpairedNode: true,
      suppressBooleanAttributes: true,
      tagValueProcessor: function(key, a) {
        return a;
      },
      attributeValueProcessor: function(attrName, a) {
        return a;
      },
      preserveOrder: false,
      commentPropName: false,
      unpairedTags: [],
      entities: [
        { regex: new RegExp("&", "g"), val: "&amp;" },
        { regex: new RegExp(">", "g"), val: "&gt;" },
        { regex: new RegExp("<", "g"), val: "&lt;" },
        { regex: new RegExp("'", "g"), val: "&apos;" },
        { regex: new RegExp('"', "g"), val: "&quot;" }
      ],
      processEntities: true,
      stopNodes: [],
      transformTagName: false
    };
    function Builder(options) {
      this.options = Object.assign({}, defaultOptions, options);
      if (this.options.ignoreAttributes || this.options.attributesGroupName) {
        this.isAttribute = function() {
          return false;
        };
      } else {
        this.attrPrefixLen = this.options.attributeNamePrefix.length;
        this.isAttribute = isAttribute;
      }
      this.processTextOrObjNode = processTextOrObjNode;
      if (this.options.format) {
        this.indentate = indentate;
        this.tagEndChar = ">\n";
        this.newLine = "\n";
      } else {
        this.indentate = function() {
          return "";
        };
        this.tagEndChar = ">";
        this.newLine = "";
      }
      if (this.options.suppressEmptyNode) {
        this.buildTextNode = buildEmptyTextNode;
        this.buildObjNode = buildEmptyObjNode;
      } else {
        this.buildTextNode = buildTextValNode;
        this.buildObjNode = buildObjectNode;
      }
      this.buildTextValNode = buildTextValNode;
      this.buildObjectNode = buildObjectNode;
      this.replaceEntitiesValue = replaceEntitiesValue;
      this.buildAttrPairStr = buildAttrPairStr;
    }
    Builder.prototype.build = function(jObj) {
      if (this.options.preserveOrder) {
        return buildFromOrderedJs(jObj, this.options);
      } else {
        if (Array.isArray(jObj) && this.options.arrayNodeName && this.options.arrayNodeName.length > 1) {
          jObj = {
            [this.options.arrayNodeName]: jObj
          };
        }
        return this.j2x(jObj, 0).val;
      }
    };
    Builder.prototype.j2x = function(jObj, level) {
      let attrStr = "";
      let val = "";
      for (let key in jObj) {
        if (typeof jObj[key] === "undefined") {
        } else if (jObj[key] === null) {
          if (key[0] === "?")
            val += this.indentate(level) + "<" + key + "?" + this.tagEndChar;
          else
            val += this.indentate(level) + "<" + key + "/" + this.tagEndChar;
        } else if (jObj[key] instanceof Date) {
          val += this.buildTextNode(jObj[key], key, "", level);
        } else if (typeof jObj[key] !== "object") {
          const attr = this.isAttribute(key);
          if (attr) {
            attrStr += this.buildAttrPairStr(attr, "" + jObj[key]);
          } else {
            if (key === this.options.textNodeName) {
              let newval = this.options.tagValueProcessor(key, "" + jObj[key]);
              val += this.replaceEntitiesValue(newval);
            } else {
              val += this.buildTextNode(jObj[key], key, "", level);
            }
          }
        } else if (Array.isArray(jObj[key])) {
          const arrLen = jObj[key].length;
          for (let j = 0; j < arrLen; j++) {
            const item = jObj[key][j];
            if (typeof item === "undefined") {
            } else if (item === null) {
              if (key[0] === "?")
                val += this.indentate(level) + "<" + key + "?" + this.tagEndChar;
              else
                val += this.indentate(level) + "<" + key + "/" + this.tagEndChar;
            } else if (typeof item === "object") {
              val += this.processTextOrObjNode(item, key, level);
            } else {
              val += this.buildTextNode(item, key, "", level);
            }
          }
        } else {
          if (this.options.attributesGroupName && key === this.options.attributesGroupName) {
            const Ks = Object.keys(jObj[key]);
            const L = Ks.length;
            for (let j = 0; j < L; j++) {
              attrStr += this.buildAttrPairStr(Ks[j], "" + jObj[key][Ks[j]]);
            }
          } else {
            val += this.processTextOrObjNode(jObj[key], key, level);
          }
        }
      }
      return { attrStr, val };
    };
    function buildAttrPairStr(attrName, val) {
      val = this.options.attributeValueProcessor(attrName, "" + val);
      val = this.replaceEntitiesValue(val);
      if (this.options.suppressBooleanAttributes && val === "true") {
        return " " + attrName;
      } else
        return " " + attrName + '="' + val + '"';
    }
    function processTextOrObjNode(object, key, level) {
      const result = this.j2x(object, level + 1);
      if (object[this.options.textNodeName] !== void 0 && Object.keys(object).length === 1) {
        return this.buildTextNode(object[this.options.textNodeName], key, result.attrStr, level);
      } else {
        return this.buildObjNode(result.val, key, result.attrStr, level);
      }
    }
    function buildObjectNode(val, key, attrStr, level) {
      let tagEndExp = "</" + key + this.tagEndChar;
      let piClosingChar = "";
      if (key[0] === "?") {
        piClosingChar = "?";
        tagEndExp = "";
      }
      if (attrStr && val.indexOf("<") === -1) {
        return this.indentate(level) + "<" + key + attrStr + piClosingChar + ">" + val + tagEndExp;
      } else if (this.options.commentPropName !== false && key === this.options.commentPropName && piClosingChar.length === 0) {
        return this.indentate(level) + `<!--${val}-->` + this.newLine;
      } else {
        return this.indentate(level) + "<" + key + attrStr + piClosingChar + this.tagEndChar + val + this.indentate(level) + tagEndExp;
      }
    }
    function buildEmptyObjNode(val, key, attrStr, level) {
      if (val !== "") {
        return this.buildObjectNode(val, key, attrStr, level);
      } else {
        if (key[0] === "?")
          return this.indentate(level) + "<" + key + attrStr + "?" + this.tagEndChar;
        else
          return this.indentate(level) + "<" + key + attrStr + "/" + this.tagEndChar;
      }
    }
    function buildTextValNode(val, key, attrStr, level) {
      if (this.options.cdataPropName !== false && key === this.options.cdataPropName) {
        return this.indentate(level) + `<![CDATA[${val}]]>` + this.newLine;
      } else if (this.options.commentPropName !== false && key === this.options.commentPropName) {
        return this.indentate(level) + `<!--${val}-->` + this.newLine;
      } else {
        let textValue = this.options.tagValueProcessor(key, val);
        textValue = this.replaceEntitiesValue(textValue);
        if (textValue === "" && this.options.unpairedTags.indexOf(key) !== -1) {
          if (this.options.suppressUnpairedNode) {
            return this.indentate(level) + "<" + key + this.tagEndChar;
          } else {
            return this.indentate(level) + "<" + key + "/" + this.tagEndChar;
          }
        } else {
          return this.indentate(level) + "<" + key + attrStr + ">" + textValue + "</" + key + this.tagEndChar;
        }
      }
    }
    function replaceEntitiesValue(textValue) {
      if (textValue && textValue.length > 0 && this.options.processEntities) {
        for (let i = 0; i < this.options.entities.length; i++) {
          const entity = this.options.entities[i];
          textValue = textValue.replace(entity.regex, entity.val);
        }
      }
      return textValue;
    }
    function buildEmptyTextNode(val, key, attrStr, level) {
      if (val === "" && this.options.unpairedTags.indexOf(key) !== -1) {
        if (this.options.suppressUnpairedNode) {
          return this.indentate(level) + "<" + key + this.tagEndChar;
        } else {
          return this.indentate(level) + "<" + key + "/" + this.tagEndChar;
        }
      } else if (val !== "") {
        return this.buildTextValNode(val, key, attrStr, level);
      } else {
        if (key[0] === "?")
          return this.indentate(level) + "<" + key + attrStr + "?" + this.tagEndChar;
        else
          return this.indentate(level) + "<" + key + attrStr + "/" + this.tagEndChar;
      }
    }
    function indentate(level) {
      return this.options.indentBy.repeat(level);
    }
    function isAttribute(name) {
      if (name.startsWith(this.options.attributeNamePrefix)) {
        return name.substr(this.attrPrefixLen);
      } else {
        return false;
      }
    }
    module2.exports = Builder;
  }
});

// ../xml/node_modules/fast-xml-parser/src/fxp.js
var require_fxp = __commonJS({
  "../xml/node_modules/fast-xml-parser/src/fxp.js"(exports2, module2) {
    "use strict";
    var validator = require_validator();
    var XMLParser = require_XMLParser();
    var XMLBuilder = require_json2xml();
    module2.exports = {
      XMLParser,
      XMLValidator: validator,
      XMLBuilder
    };
  }
});

// ../xml/src/lib/parse-xml.ts
function parseXML(text, options) {
  const parser = new import_fast_xml_parser.XMLParser({
    ignoreAttributes: false,
    attributeNamePrefix: "",
    ...options?.xml
  });
  const parsedXML = parser.parse(text);
  return parsedXML;
}
var import_fast_xml_parser;
var init_parse_xml = __esm({
  "../xml/src/lib/parse-xml.ts"() {
    import_fast_xml_parser = __toModule(require_fxp());
  }
});

// ../xml/src/xml-loader.ts
function testXMLFile(text) {
  return text.startsWith("<?xml");
}
var VERSION, XMLLoader;
var init_xml_loader = __esm({
  "../xml/src/xml-loader.ts"() {
    init_parse_xml();
    VERSION = typeof __VERSION__ !== "undefined" ? __VERSION__ : "latest";
    XMLLoader = {
      name: "XML",
      id: "xml",
      module: "xml",
      version: VERSION,
      worker: false,
      extensions: ["xml"],
      mimeTypes: ["application/xml", "text/xml"],
      testText: testXMLFile,
      options: {
        xml: {}
      },
      parse: async (arrayBuffer, options) => parseXML(new TextDecoder().decode(arrayBuffer), options),
      parseTextSync: (text, options) => parseXML(text, options)
    };
  }
});

// ../xml/src/index.ts
var init_src = __esm({
  "../xml/src/index.ts"() {
    init_xml_loader();
  }
});

// src/lib/wms/parse-wms.ts
function parseWMSCapabilities(text, options) {
  const parsedXML = XMLLoader.parseTextSync(text, options);
  const xmlCapabilities = parsedXML.WMT_MS_Capabilities || parsedXML.WMS_Capabilities || parsedXML;
  return extractCapabilities(xmlCapabilities);
}
function extractCapabilities(xml) {
  const capabilities = {
    name: xml.Service?.Name || "unnamed",
    title: xml.Service?.Title,
    keywords: [],
    requests: {},
    layer: extractLayer(xml.Capability?.Layer),
    raw: xml
  };
  for (const keyword of xml.Service?.KeywordList?.Keyword || []) {
    capabilities.keywords.push(keyword);
  }
  for (const [name, xmlRequest] of Object.entries(xml.Capability?.Request || {})) {
    capabilities.requests[name] = extractRequest(name, xmlRequest);
  }
  return capabilities;
}
function extractRequest(name, xmlRequest) {
  const format = xmlRequest?.Format;
  const mimeTypes = Array.isArray(format) ? format : [format];
  return { name, mimeTypes };
}
function extractLayer(xmlLayer) {
  const layer = {
    name: xmlLayer?.Name,
    title: xmlLayer?.Title,
    srs: xmlLayer?.SRS || [],
    layers: []
  };
  const xmlLayers = getXMLArray(xmlLayer?.Layer);
  for (const xmlSubLayer of xmlLayers) {
    layer.layers?.push(extractLayer(xmlSubLayer));
  }
  return layer;
}
function getXMLArray(xmlValue) {
  if (Array.isArray(xmlValue)) {
    return xmlValue;
  }
  if (xmlValue) {
    return [xmlValue];
  }
  return [];
}
function parseWMSFeatureInfo(text, options) {
  const parsedXML = XMLLoader.parseTextSync(text, options);
  const xmlFeatureInfo = parsedXML.FeatureInfoResponse?.FIELDS || [];
  const xmlFeatures = Array.isArray(xmlFeatureInfo) ? xmlFeatureInfo : [xmlFeatureInfo];
  return {
    features: xmlFeatures.map((xmlFeature) => extractFeature(xmlFeature))
  };
}
function extractFeature(xmlFeature) {
  const xmlFields = xmlFeature || {};
  return {
    attributes: xmlFields,
    type: "",
    bounds: { bottom: 0, top: 0, left: 0, right: 0 }
  };
}
function parseWMSLayerDescription(text, options) {
  const parsedXML = XMLLoader.parseTextSync(text, options);
  return parsedXML;
}
function parseWMSError(text, options) {
  const parsedXML = XMLLoader.parseTextSync?.(text, options);
  const serviceExceptionXML = parsedXML?.ServiceExceptionReport?.ServiceException || parsedXML?.["ogc:ServiceExceptionReport"]?.["ogc:ServiceException"];
  const message = typeof serviceExceptionXML === "string" ? serviceExceptionXML : serviceExceptionXML["#text"] || serviceExceptionXML.code || "Unknown error";
  return message;
}
var init_parse_wms = __esm({
  "src/lib/wms/parse-wms.ts"() {
    init_src();
  }
});

// src/wms-error-loader.ts
function testXMLFile2(text) {
  return text.startsWith("<?xml");
}
function parseTextSync(text, options) {
  const wmsOptions = { ...WMSErrorLoader.options.wms, ...options?.wms };
  const error = parseWMSError(text, wmsOptions);
  const message = wmsOptions.minimalErrors ? error : `WMS Service error: ${error}`;
  if (wmsOptions.throwOnError) {
    throw new Error(message);
  }
  return message;
}
var VERSION2, WMSErrorLoader;
var init_wms_error_loader = __esm({
  "src/wms-error-loader.ts"() {
    init_parse_wms();
    VERSION2 = typeof __VERSION__ !== "undefined" ? __VERSION__ : "latest";
    WMSErrorLoader = {
      id: "wms-error",
      name: "WMS Error",
      module: "wms",
      version: VERSION2,
      worker: false,
      extensions: ["xml"],
      mimeTypes: ["application/vnd.ogc.se_xml", "application/xml", "text/xml"],
      testText: testXMLFile2,
      options: {
        wms: {
          throwOnError: false
        }
      },
      parse: async (arrayBuffer, options) => parseTextSync(new TextDecoder().decode(arrayBuffer), options),
      parseSync: (arrayBuffer, options) => parseTextSync(new TextDecoder().decode(arrayBuffer), options),
      parseTextSync: (text, options) => parseTextSync(text, options)
    };
  }
});

// src/wms-capabilities-loader.ts
function testXMLFile3(text) {
  return text.startsWith("<?xml");
}
var VERSION3, WMSCapabilitiesLoader;
var init_wms_capabilities_loader = __esm({
  "src/wms-capabilities-loader.ts"() {
    init_parse_wms();
    VERSION3 = typeof __VERSION__ !== "undefined" ? __VERSION__ : "latest";
    WMSCapabilitiesLoader = {
      id: "wms-capabilities",
      name: "WMS Capabilities",
      module: "wms",
      version: VERSION3,
      worker: false,
      extensions: ["xml"],
      mimeTypes: ["application/vnd.ogc.wms_xml", "application/xml", "text/xml"],
      testText: testXMLFile3,
      options: {
        wms: {}
      },
      parse: async (arrayBuffer, options) => parseWMSCapabilities(new TextDecoder().decode(arrayBuffer), options),
      parseTextSync: (text, options) => parseWMSCapabilities(text, options)
    };
  }
});

// src/lib/data-sources/image-source.ts
var ImageSource;
var init_image_source = __esm({
  "src/lib/data-sources/image-source.ts"() {
    ImageSource = class {
    };
  }
});

// ../images/src/lib/utils/version.ts
var VERSION4;
var init_version = __esm({
  "../images/src/lib/utils/version.ts"() {
    VERSION4 = typeof __VERSION__ !== "undefined" ? __VERSION__ : "latest";
  }
});

// ../loader-utils/src/lib/env-utils/assert.ts
function assert(condition, message) {
  if (!condition) {
    throw new Error(message || "loader assertion failed.");
  }
}
var init_assert = __esm({
  "../loader-utils/src/lib/env-utils/assert.ts"() {
  }
});

// ../loader-utils/src/lib/env-utils/globals.ts
var globals, self_, window_, global_, document_, isBrowser, matches, nodeVersion;
var init_globals = __esm({
  "../loader-utils/src/lib/env-utils/globals.ts"() {
    globals = {
      self: typeof self !== "undefined" && self,
      window: typeof window !== "undefined" && window,
      global: typeof global !== "undefined" && global,
      document: typeof document !== "undefined" && document
    };
    self_ = globals.self || globals.window || globals.global || {};
    window_ = globals.window || globals.self || globals.global || {};
    global_ = globals.global || globals.self || globals.window || {};
    document_ = globals.document || {};
    isBrowser = Boolean(typeof process !== "object" || String(process) !== "[object process]" || process.browser);
    matches = typeof process !== "undefined" && process.version && /v([0-9]*)/.exec(process.version);
    nodeVersion = matches && parseFloat(matches[1]) || 0;
  }
});

// ../loader-utils/src/index.ts
var init_src2 = __esm({
  "../loader-utils/src/index.ts"() {
    init_assert();
    init_globals();
  }
});

// ../images/src/lib/category-api/image-type.ts
function isImageTypeSupported(type) {
  switch (type) {
    case "auto":
      return IMAGE_BITMAP_SUPPORTED || IMAGE_SUPPORTED || DATA_SUPPORTED;
    case "imagebitmap":
      return IMAGE_BITMAP_SUPPORTED;
    case "image":
      return IMAGE_SUPPORTED;
    case "data":
      return DATA_SUPPORTED;
    default:
      throw new Error(`@loaders.gl/images: image ${type} not supported in this environment`);
  }
}
function getDefaultImageType() {
  if (IMAGE_BITMAP_SUPPORTED) {
    return "imagebitmap";
  }
  if (IMAGE_SUPPORTED) {
    return "image";
  }
  if (DATA_SUPPORTED) {
    return "data";
  }
  throw new Error("Install '@loaders.gl/polyfills' to parse images under Node.js");
}
var _parseImageNode, IMAGE_SUPPORTED, IMAGE_BITMAP_SUPPORTED, NODE_IMAGE_SUPPORTED, DATA_SUPPORTED;
var init_image_type = __esm({
  "../images/src/lib/category-api/image-type.ts"() {
    init_src2();
    ({ _parseImageNode } = globalThis);
    IMAGE_SUPPORTED = typeof Image !== "undefined";
    IMAGE_BITMAP_SUPPORTED = typeof ImageBitmap !== "undefined";
    NODE_IMAGE_SUPPORTED = Boolean(_parseImageNode);
    DATA_SUPPORTED = isBrowser ? true : NODE_IMAGE_SUPPORTED;
  }
});

// ../images/src/lib/category-api/parsed-image-api.ts
function getImageType(image) {
  const format = getImageTypeOrNull(image);
  if (!format) {
    throw new Error("Not an image");
  }
  return format;
}
function getImageData(image) {
  switch (getImageType(image)) {
    case "data":
      return image;
    case "image":
    case "imagebitmap":
      const canvas = document.createElement("canvas");
      const context = canvas.getContext("2d");
      if (!context) {
        throw new Error("getImageData");
      }
      canvas.width = image.width;
      canvas.height = image.height;
      context.drawImage(image, 0, 0);
      return context.getImageData(0, 0, image.width, image.height);
    default:
      throw new Error("getImageData");
  }
}
function getImageTypeOrNull(image) {
  if (typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
    return "imagebitmap";
  }
  if (typeof Image !== "undefined" && image instanceof Image) {
    return "image";
  }
  if (image && typeof image === "object" && image.data && image.width && image.height) {
    return "data";
  }
  return null;
}
var init_parsed_image_api = __esm({
  "../images/src/lib/category-api/parsed-image-api.ts"() {
  }
});

// ../images/src/lib/parsers/svg-utils.ts
function isSVG(url) {
  return url && (SVG_DATA_URL_PATTERN.test(url) || SVG_URL_PATTERN.test(url));
}
function getBlobOrSVGDataUrl(arrayBuffer, url) {
  if (isSVG(url)) {
    const textDecoder = new TextDecoder();
    let xmlText = textDecoder.decode(arrayBuffer);
    try {
      if (typeof unescape === "function" && typeof encodeURIComponent === "function") {
        xmlText = unescape(encodeURIComponent(xmlText));
      }
    } catch (error) {
      throw new Error(error.message);
    }
    const src = `data:image/svg+xml;base64,${btoa(xmlText)}`;
    return src;
  }
  return getBlob(arrayBuffer, url);
}
function getBlob(arrayBuffer, url) {
  if (isSVG(url)) {
    throw new Error("SVG cannot be parsed directly to imagebitmap");
  }
  return new Blob([new Uint8Array(arrayBuffer)]);
}
var SVG_DATA_URL_PATTERN, SVG_URL_PATTERN;
var init_svg_utils = __esm({
  "../images/src/lib/parsers/svg-utils.ts"() {
    SVG_DATA_URL_PATTERN = /^data:image\/svg\+xml/;
    SVG_URL_PATTERN = /\.svg((\?|#).*)?$/;
  }
});

// ../images/src/lib/parsers/parse-to-image.ts
async function parseToImage(arrayBuffer, options, url) {
  const blobOrDataUrl = getBlobOrSVGDataUrl(arrayBuffer, url);
  const URL = self.URL || self.webkitURL;
  const objectUrl = typeof blobOrDataUrl !== "string" && URL.createObjectURL(blobOrDataUrl);
  try {
    return await loadToImage(objectUrl || blobOrDataUrl, options);
  } finally {
    if (objectUrl) {
      URL.revokeObjectURL(objectUrl);
    }
  }
}
async function loadToImage(url, options) {
  const image = new Image();
  image.src = url;
  if (options.image && options.image.decode && image.decode) {
    await image.decode();
    return image;
  }
  return await new Promise((resolve, reject) => {
    try {
      image.onload = () => resolve(image);
      image.onerror = (err) => reject(new Error(`Could not load image ${url}: ${err}`));
    } catch (error) {
      reject(error);
    }
  });
}
var init_parse_to_image = __esm({
  "../images/src/lib/parsers/parse-to-image.ts"() {
    init_svg_utils();
  }
});

// ../images/src/lib/parsers/parse-to-image-bitmap.ts
async function parseToImageBitmap(arrayBuffer, options, url) {
  let blob;
  if (isSVG(url)) {
    const image = await parseToImage(arrayBuffer, options, url);
    blob = image;
  } else {
    blob = getBlob(arrayBuffer, url);
  }
  const imagebitmapOptions = options && options.imagebitmap;
  return await safeCreateImageBitmap(blob, imagebitmapOptions);
}
async function safeCreateImageBitmap(blob, imagebitmapOptions = null) {
  if (isEmptyObject(imagebitmapOptions) || !imagebitmapOptionsSupported) {
    imagebitmapOptions = null;
  }
  if (imagebitmapOptions) {
    try {
      return await createImageBitmap(blob, imagebitmapOptions);
    } catch (error) {
      console.warn(error);
      imagebitmapOptionsSupported = false;
    }
  }
  return await createImageBitmap(blob);
}
function isEmptyObject(object) {
  for (const key in object || EMPTY_OBJECT) {
    return false;
  }
  return true;
}
var EMPTY_OBJECT, imagebitmapOptionsSupported;
var init_parse_to_image_bitmap = __esm({
  "../images/src/lib/parsers/parse-to-image-bitmap.ts"() {
    init_svg_utils();
    init_parse_to_image();
    EMPTY_OBJECT = {};
    imagebitmapOptionsSupported = true;
  }
});

// ../images/src/lib/category-api/binary-image-api.ts
function getBinaryImageMetadata(binaryData) {
  const dataView = toDataView(binaryData);
  return getPngMetadata(dataView) || getJpegMetadata(dataView) || getGifMetadata(dataView) || getBmpMetadata(dataView);
}
function getPngMetadata(binaryData) {
  const dataView = toDataView(binaryData);
  const isPng = dataView.byteLength >= 24 && dataView.getUint32(0, BIG_ENDIAN) === 2303741511;
  if (!isPng) {
    return null;
  }
  return {
    mimeType: "image/png",
    width: dataView.getUint32(16, BIG_ENDIAN),
    height: dataView.getUint32(20, BIG_ENDIAN)
  };
}
function getGifMetadata(binaryData) {
  const dataView = toDataView(binaryData);
  const isGif = dataView.byteLength >= 10 && dataView.getUint32(0, BIG_ENDIAN) === 1195984440;
  if (!isGif) {
    return null;
  }
  return {
    mimeType: "image/gif",
    width: dataView.getUint16(6, LITTLE_ENDIAN),
    height: dataView.getUint16(8, LITTLE_ENDIAN)
  };
}
function getBmpMetadata(binaryData) {
  const dataView = toDataView(binaryData);
  const isBmp = dataView.byteLength >= 14 && dataView.getUint16(0, BIG_ENDIAN) === 16973 && dataView.getUint32(2, LITTLE_ENDIAN) === dataView.byteLength;
  if (!isBmp) {
    return null;
  }
  return {
    mimeType: "image/bmp",
    width: dataView.getUint32(18, LITTLE_ENDIAN),
    height: dataView.getUint32(22, LITTLE_ENDIAN)
  };
}
function getJpegMetadata(binaryData) {
  const dataView = toDataView(binaryData);
  const isJpeg = dataView.byteLength >= 3 && dataView.getUint16(0, BIG_ENDIAN) === 65496 && dataView.getUint8(2) === 255;
  if (!isJpeg) {
    return null;
  }
  const { tableMarkers, sofMarkers } = getJpegMarkers();
  let i = 2;
  while (i + 9 < dataView.byteLength) {
    const marker = dataView.getUint16(i, BIG_ENDIAN);
    if (sofMarkers.has(marker)) {
      return {
        mimeType: "image/jpeg",
        height: dataView.getUint16(i + 5, BIG_ENDIAN),
        width: dataView.getUint16(i + 7, BIG_ENDIAN)
      };
    }
    if (!tableMarkers.has(marker)) {
      return null;
    }
    i += 2;
    i += dataView.getUint16(i, BIG_ENDIAN);
  }
  return null;
}
function getJpegMarkers() {
  const tableMarkers = new Set([65499, 65476, 65484, 65501, 65534]);
  for (let i = 65504; i < 65520; ++i) {
    tableMarkers.add(i);
  }
  const sofMarkers = new Set([
    65472,
    65473,
    65474,
    65475,
    65477,
    65478,
    65479,
    65481,
    65482,
    65483,
    65485,
    65486,
    65487,
    65502
  ]);
  return { tableMarkers, sofMarkers };
}
function toDataView(data) {
  if (data instanceof DataView) {
    return data;
  }
  if (ArrayBuffer.isView(data)) {
    return new DataView(data.buffer);
  }
  if (data instanceof ArrayBuffer) {
    return new DataView(data);
  }
  throw new Error("toDataView");
}
var BIG_ENDIAN, LITTLE_ENDIAN;
var init_binary_image_api = __esm({
  "../images/src/lib/category-api/binary-image-api.ts"() {
    BIG_ENDIAN = false;
    LITTLE_ENDIAN = true;
  }
});

// ../images/src/lib/parsers/parse-to-node-image.ts
async function parseToNodeImage(arrayBuffer, options) {
  const { mimeType } = getBinaryImageMetadata(arrayBuffer) || {};
  const _parseImageNode2 = globalThis._parseImageNode;
  assert(_parseImageNode2);
  return await _parseImageNode2(arrayBuffer, mimeType);
}
var init_parse_to_node_image = __esm({
  "../images/src/lib/parsers/parse-to-node-image.ts"() {
    init_src2();
    init_binary_image_api();
  }
});

// ../images/src/lib/parsers/parse-image.ts
async function parseImage(arrayBuffer, options, context) {
  options = options || {};
  const imageOptions = options.image || {};
  const imageType = imageOptions.type || "auto";
  const { url } = context || {};
  const loadType = getLoadableImageType(imageType);
  let image;
  switch (loadType) {
    case "imagebitmap":
      image = await parseToImageBitmap(arrayBuffer, options, url);
      break;
    case "image":
      image = await parseToImage(arrayBuffer, options, url);
      break;
    case "data":
      image = await parseToNodeImage(arrayBuffer, options);
      break;
    default:
      assert(false);
  }
  if (imageType === "data") {
    image = getImageData(image);
  }
  return image;
}
function getLoadableImageType(type) {
  switch (type) {
    case "auto":
    case "data":
      return getDefaultImageType();
    default:
      isImageTypeSupported(type);
      return type;
  }
}
var init_parse_image = __esm({
  "../images/src/lib/parsers/parse-image.ts"() {
    init_src2();
    init_image_type();
    init_parsed_image_api();
    init_parse_to_image();
    init_parse_to_image_bitmap();
    init_parse_to_node_image();
  }
});

// ../images/src/image-loader.ts
var EXTENSIONS, MIME_TYPES, DEFAULT_IMAGE_LOADER_OPTIONS, ImageLoader;
var init_image_loader = __esm({
  "../images/src/image-loader.ts"() {
    init_version();
    init_parse_image();
    init_binary_image_api();
    EXTENSIONS = ["png", "jpg", "jpeg", "gif", "webp", "bmp", "ico", "svg"];
    MIME_TYPES = [
      "image/png",
      "image/jpeg",
      "image/gif",
      "image/webp",
      "image/bmp",
      "image/vnd.microsoft.icon",
      "image/svg+xml"
    ];
    DEFAULT_IMAGE_LOADER_OPTIONS = {
      image: {
        type: "auto",
        decode: true
      }
    };
    ImageLoader = {
      id: "image",
      module: "images",
      name: "Images",
      version: VERSION4,
      mimeTypes: MIME_TYPES,
      extensions: EXTENSIONS,
      parse: parseImage,
      tests: [(arrayBuffer) => Boolean(getBinaryImageMetadata(new DataView(arrayBuffer)))],
      options: DEFAULT_IMAGE_LOADER_OPTIONS
    };
  }
});

// ../images/src/index.ts
var init_src3 = __esm({
  "../images/src/index.ts"() {
    init_image_loader();
  }
});

// src/lib/data-sources/image-services/image-service.ts
function getFetchFunction(options) {
  const fetchFunction = options?.fetch;
  if (fetchFunction && typeof fetchFunction === "function") {
    return (url, fetchOptions2) => fetchFunction(url, fetchOptions2);
  }
  const fetchOptions = options?.fetch;
  if (fetchOptions && typeof fetchOptions !== "function") {
    return (url) => fetch(url, fetchOptions);
  }
  return (url) => fetch(url);
}
function mergeImageServiceProps(props) {
  return {
    ...props,
    loadOptions: {
      ...props.loadOptions,
      fetch: getFetchFunction(props.loadOptions)
    }
  };
}
var ImageService;
var init_image_service = __esm({
  "src/lib/data-sources/image-services/image-service.ts"() {
    init_src3();
    init_image_source();
    ImageService = class extends ImageSource {
      constructor(props) {
        super();
        this.props = mergeImageServiceProps(props);
        this.fetch = getFetchFunction(props);
      }
      async getMetadata() {
        throw new Error("ImageSource.getMetadata not implemented");
      }
      async getImage(parameters) {
        const granularParameters = this.getGranularParameters(parameters);
        const url = this.getURLFromTemplate(granularParameters);
        const response = await this.fetch(url);
        const arrayBuffer = await response.arrayBuffer();
        return await ImageLoader.parse(arrayBuffer);
      }
      getGranularParameters(parameters) {
        const [east, north, west, south] = parameters.bbox;
        return { ...parameters, east, north, south, west };
      }
      getURLFromTemplate(parameters) {
        let url = this.props.url;
        for (const [key, value] of Object.entries(parameters)) {
          url = url.replace(`\${${key}}`, String(value));
          url = url.replace(`{${key}}`, String(value));
        }
        return url;
      }
    };
    ImageService.type = "template";
    ImageService.testURL = (url) => url.toLowerCase().includes("{");
  }
});

// src/wip/wms-feature-info-loader.ts
var WMSFeatureInfoLoader;
var init_wms_feature_info_loader = __esm({
  "src/wip/wms-feature-info-loader.ts"() {
    init_wms_capabilities_loader();
    init_parse_wms();
    WMSFeatureInfoLoader = {
      ...WMSCapabilitiesLoader,
      id: "wms-feature-info",
      name: "WMS FeatureInfo",
      parse: async (arrayBuffer, options) => parseWMSFeatureInfo(new TextDecoder().decode(arrayBuffer), options),
      parseTextSync: (text, options) => parseWMSFeatureInfo(text, options)
    };
  }
});

// src/wip/wms-layer-description-loader.ts
var WMSLayerDescriptionLoader;
var init_wms_layer_description_loader = __esm({
  "src/wip/wms-layer-description-loader.ts"() {
    init_wms_capabilities_loader();
    init_parse_wms();
    WMSLayerDescriptionLoader = {
      ...WMSCapabilitiesLoader,
      id: "wms-layer-description",
      name: "WMS DescribeLayer",
      parse: async (arrayBuffer, options) => parseWMSLayerDescription(new TextDecoder().decode(arrayBuffer), options),
      parseTextSync: (text, options) => parseWMSLayerDescription(text, options)
    };
  }
});

// src/lib/data-sources/image-services/wms-service.ts
var WMSService;
var init_wms_service = __esm({
  "src/lib/data-sources/image-services/wms-service.ts"() {
    init_src3();
    init_image_source();
    init_image_service();
    init_wms_capabilities_loader();
    init_wms_feature_info_loader();
    init_wms_layer_description_loader();
    init_wms_error_loader();
    WMSService = class extends ImageSource {
      constructor(props) {
        super();
        this.capabilities = null;
        this.loaders = [
          ImageLoader,
          WMSErrorLoader,
          WMSCapabilitiesLoader,
          WMSFeatureInfoLoader,
          WMSLayerDescriptionLoader
        ];
        this.props = mergeImageServiceProps(props);
        this.fetch = getFetchFunction(this.props);
        this.props.loadOptions = {
          ...this.props.loadOptions,
          wms: { ...this.props.loadOptions?.wms, throwOnError: true }
        };
      }
      getMetadata() {
        return this.getCapabilities();
      }
      getImage(parameters) {
        return this.getMap(parameters);
      }
      async getCapabilities(wmsParameters, vendorParameters) {
        const url = this.getCapabilitiesURL(wmsParameters, vendorParameters);
        const response = await this.fetch(url);
        const arrayBuffer = await response.arrayBuffer();
        this._checkResponse(response, arrayBuffer);
        const capabilities = await WMSCapabilitiesLoader.parse(arrayBuffer, this.props.loadOptions);
        this.capabilities = capabilities;
        return capabilities;
      }
      async getMap(options, vendorParameters) {
        const url = this.getMapURL(options, vendorParameters);
        const response = await this.fetch(url);
        const arrayBuffer = await response.arrayBuffer();
        this._checkResponse(response, arrayBuffer);
        try {
          return await ImageLoader.parse(arrayBuffer, this.props.loadOptions);
        } catch {
          throw this._parseError(arrayBuffer);
        }
      }
      async getFeatureInfo(options, vendorParameters) {
        const url = this.getFeatureInfoURL(options, vendorParameters);
        const response = await this.fetch(url);
        const arrayBuffer = await response.arrayBuffer();
        this._checkResponse(response, arrayBuffer);
        return await WMSFeatureInfoLoader.parse(arrayBuffer, this.props.loadOptions);
      }
      async getFeatureInfoText(options, vendorParameters) {
        options = { ...options, info_format: "text/plain" };
        const url = this.getFeatureInfoURL(options, vendorParameters);
        const response = await this.fetch(url);
        const arrayBuffer = await response.arrayBuffer();
        this._checkResponse(response, arrayBuffer);
        return new TextDecoder().decode(arrayBuffer);
      }
      async describeLayer(options, vendorParameters) {
        const url = this.describeLayerURL(options, vendorParameters);
        const response = await this.fetch(url);
        const arrayBuffer = await response.arrayBuffer();
        this._checkResponse(response, arrayBuffer);
        return await WMSLayerDescriptionLoader.parse(arrayBuffer, this.props.loadOptions);
      }
      async getLegendGraphic(options, vendorParameters) {
        const url = this.getLegendGraphicURL(options, vendorParameters);
        const response = await this.fetch(url);
        const arrayBuffer = await response.arrayBuffer();
        this._checkResponse(response, arrayBuffer);
        try {
          return await ImageLoader.parse(arrayBuffer, this.props.loadOptions);
        } catch {
          throw this._parseError(arrayBuffer);
        }
      }
      getCapabilitiesURL(wmsParameters, vendorParameters) {
        const options = {
          service: "WMS",
          version: "1.1.1",
          request: "GetCapabilities",
          ...wmsParameters,
          ...vendorParameters
        };
        return this._getWMSUrl(options, vendorParameters);
      }
      getMapURL(wmsParameters, vendorParameters) {
        const options = {
          service: "WMS",
          version: "1.1.1",
          request: "GetMap",
          styles: void 0,
          srs: "EPSG:4326",
          format: "image/png",
          ...wmsParameters,
          ...vendorParameters
        };
        return this._getWMSUrl(options, vendorParameters);
      }
      getFeatureInfoURL(wmsParameters, vendorParameters) {
        const options = {
          service: "WMS",
          version: "1.1.1",
          request: "GetFeatureInfo",
          srs: "EPSG:4326",
          format: "image/png",
          info_format: "text/plain",
          styles: void 0,
          ...wmsParameters,
          ...vendorParameters
        };
        return this._getWMSUrl(options, vendorParameters);
      }
      describeLayerURL(wmsParameters, vendorParameters) {
        const options = {
          service: "WMS",
          version: "1.1.1",
          request: "DescribeLayer",
          ...wmsParameters,
          ...vendorParameters
        };
        return this._getWMSUrl(options, vendorParameters);
      }
      getLegendGraphicURL(wmsParameters, vendorParameters) {
        const options = {
          service: "WMS",
          version: "1.1.1",
          request: "GetLegendGraphic",
          ...wmsParameters,
          ...vendorParameters
        };
        return this._getWMSUrl(options, vendorParameters);
      }
      _getWMSUrl(options, vendorParameters) {
        let url = this.props.url;
        let first = true;
        for (const [key, value] of Object.entries(options)) {
          url += first ? "?" : "&";
          first = false;
          if (Array.isArray(value)) {
            url += `${key.toUpperCase()}=${value.join(",")}`;
          } else {
            url += `${key.toUpperCase()}=${value ? String(value) : ""}`;
          }
        }
        return encodeURI(url);
      }
      _checkResponse(response, arrayBuffer) {
        const contentType = response.headers["content-type"];
        if (!response.ok || WMSErrorLoader.mimeTypes.includes(contentType)) {
          const error = WMSErrorLoader.parseSync(arrayBuffer, this.props.loadOptions);
          throw new Error(error);
        }
      }
      _parseError(arrayBuffer) {
        const error = WMSErrorLoader.parseSync(arrayBuffer, this.props.loadOptions);
        return new Error(error);
      }
    };
    WMSService.type = "wms";
    WMSService.testURL = (url) => url.toLowerCase().includes("wms");
  }
});

// src/lib/data-sources/image-services/arcgis-image-service.ts
var ArcGISImageService;
var init_arcgis_image_service = __esm({
  "src/lib/data-sources/image-services/arcgis-image-service.ts"() {
    init_image_source();
    init_image_service();
    ArcGISImageService = class extends ImageSource {
      constructor(props) {
        super();
        this.props = mergeImageServiceProps(props);
        this.fetch = getFetchFunction(this.props);
      }
      async getMetadata() {
        return await this.info();
      }
      async getImage(parameters) {
        throw new Error("not implemented");
      }
      async info() {
        throw new Error("not implemented");
      }
      exportImage(options) {
        throw new Error("not implemented");
      }
      infoURL(options) {
        return this.props.url;
      }
      exportImageURL(options) {
        return this.props.url;
      }
      getUrl(options, extra) {
        let url = `${this.props.url}`;
        let first = true;
        for (const [key, value] of Object.entries(options)) {
          url += first ? "?" : "&";
          first = false;
          if (Array.isArray(value)) {
            url += `${key.toUpperCase()}=${value.join(",")}`;
          } else {
            url += `${key.toUpperCase()}=${value ? String(value) : ""}`;
          }
        }
        return url;
      }
      async checkResponse(response) {
        if (!response.ok) {
          throw new Error("error");
        }
      }
    };
    ArcGISImageService.type = "arcgis-image-server";
    ArcGISImageService.testURL = (url) => url.toLowerCase().includes("ImageServer");
  }
});

// src/lib/data-sources/create-image-source.ts
function createImageSource(props) {
  const { type = "auto" } = props;
  const serviceType = type === "auto" ? guessServiceType(props.url) : type;
  switch (serviceType) {
    case "template":
      return new ImageService(props);
    case "wms":
      return new WMSService(props);
    default:
      throw new Error("Not a valid image source type");
  }
}
function guessServiceType(url) {
  for (const Service of SERVICES) {
    if (Service.testURL && Service.testURL(url)) {
      return Service.type;
    }
  }
  return "wms";
}
var SERVICES;
var init_create_image_source = __esm({
  "src/lib/data-sources/create-image-source.ts"() {
    init_image_service();
    init_wms_service();
    init_arcgis_image_service();
    SERVICES = [WMSService, ArcGISImageService, ImageService];
  }
});

// src/lib/wmts/parse-wmts.ts
function parseWMTSCapabilities(text, options) {
  options = { ...options, xml: { ...options?.xml, removeNSPrefix: true } };
  const parsedXML = XMLLoader.parseTextSync(text, options);
  const xmlCapabilities = parsedXML.Capabilities || parsedXML;
  return uncapitalizeKeys(xmlCapabilities);
}
function uncapitalizeKeys(object) {
  if (object && typeof object === "object") {
    const newObject = {};
    for (const [key, value] of Object.entries(object)) {
      newObject[uncapitalize(key)] = uncapitalizeKeys(value);
    }
    return newObject;
  }
  return object;
}
function uncapitalize(str) {
  return typeof str === "string" ? str.charAt(0).toLowerCase() + str.slice(1) : str;
}
var init_parse_wmts = __esm({
  "src/lib/wmts/parse-wmts.ts"() {
    init_src();
  }
});

// src/wip/wmts-capabilities-loader.ts
function testXMLFile4(text) {
  return text.startsWith("<?xml");
}
var VERSION5, WMTSCapabilitiesLoader;
var init_wmts_capabilities_loader = __esm({
  "src/wip/wmts-capabilities-loader.ts"() {
    init_parse_wmts();
    VERSION5 = typeof __VERSION__ !== "undefined" ? __VERSION__ : "latest";
    WMTSCapabilitiesLoader = {
      id: "wmts-capabilities",
      name: "WMTS Capabilities",
      module: "wms",
      version: VERSION5,
      worker: false,
      extensions: ["xml"],
      mimeTypes: ["application/vnd.ogc.wmts_xml", "application/xml", "text/xml"],
      testText: testXMLFile4,
      options: {
        wms: {}
      },
      parse: async (arrayBuffer, options) => parseWMTSCapabilities(new TextDecoder().decode(arrayBuffer), options),
      parseTextSync: (text, options) => parseWMTSCapabilities(text, options)
    };
  }
});

// src/lib/wfs/parse-wfs.ts
function parseWFSCapabilities(text, options) {
  options = { ...options, xml: { ...options?.xml, removeNSPrefix: true } };
  const parsedXML = XMLLoader.parseTextSync(text, options);
  const xmlCapabilities = parsedXML.Capabilities || parsedXML;
  return uncapitalizeKeys2(xmlCapabilities);
}
function uncapitalizeKeys2(object) {
  if (object && typeof object === "object") {
    const newObject = {};
    for (const [key, value] of Object.entries(object)) {
      newObject[uncapitalize2(key)] = uncapitalizeKeys2(value);
    }
    return newObject;
  }
  return object;
}
function uncapitalize2(str) {
  return typeof str === "string" ? str.charAt(0).toLowerCase() + str.slice(1) : str;
}
var init_parse_wfs = __esm({
  "src/lib/wfs/parse-wfs.ts"() {
    init_src();
  }
});

// src/wip/wfs-capabilities-loader.ts
function testXMLFile5(text) {
  return text.startsWith("<?xml");
}
var VERSION6, WFSCapabilitiesLoader;
var init_wfs_capabilities_loader = __esm({
  "src/wip/wfs-capabilities-loader.ts"() {
    init_parse_wfs();
    VERSION6 = typeof __VERSION__ !== "undefined" ? __VERSION__ : "latest";
    WFSCapabilitiesLoader = {
      id: "wfs-capabilities",
      name: "WFS Capabilities",
      module: "wms",
      version: VERSION6,
      worker: false,
      extensions: ["xml"],
      mimeTypes: ["application/vnd.ogc.wfs_xml", "application/xml", "text/xml"],
      testText: testXMLFile5,
      options: {
        wms: {}
      },
      parse: async (arrayBuffer, options) => parseWFSCapabilities(new TextDecoder().decode(arrayBuffer), options),
      parseTextSync: (text, options) => parseWFSCapabilities(text, options)
    };
  }
});

// src/lib/gml/deep-strict-equal.ts
function deepStrictEqual(actual, expected, strict) {
  if (actual === expected) {
    return true;
  } else if (actual instanceof Date && expected instanceof Date) {
    return actual.getTime() === expected.getTime();
  } else if (actual instanceof RegExp && expected instanceof RegExp) {
    return actual.source === expected.source && actual.global === expected.global && actual.multiline === expected.multiline && actual.lastIndex === expected.lastIndex && actual.ignoreCase === expected.ignoreCase;
  } else if ((actual === null || typeof actual !== "object") && (expected === null || typeof expected !== "object")) {
    return strict ? actual === expected : actual == expected;
  }
  return objEquiv(actual, expected, strict);
}
function isPrimitive(arg) {
  return arg === null || typeof arg !== "object" && typeof arg !== "function";
}
function isArguments(object) {
  return Object.prototype.toString.call(object) == "[object Arguments]";
}
function objEquiv(a, b, strict) {
  if (a === null || a === void 0 || b === null || b === void 0)
    return false;
  if (isPrimitive(a) || isPrimitive(b))
    return a === b;
  if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b))
    return false;
  const aIsArgs = isArguments(a);
  const bIsArgs = isArguments(b);
  if (aIsArgs && !bIsArgs || !aIsArgs && bIsArgs)
    return false;
  if (aIsArgs) {
    a = pSlice.call(a);
    b = pSlice.call(b);
    return deepStrictEqual(a, b, strict);
  }
  const ka = Object.keys(a);
  const kb = Object.keys(b);
  let key;
  let i;
  if (ka.length !== kb.length)
    return false;
  ka.sort();
  kb.sort();
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] !== kb[i])
      return false;
  }
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!deepStrictEqual(a[key], b[key], strict))
      return false;
  }
  return true;
}
var pSlice;
var init_deep_strict_equal = __esm({
  "src/lib/gml/deep-strict-equal.ts"() {
    pSlice = Array.prototype.slice;
  }
});

// ../../node_modules/@turf/clone/main.js
var require_main = __commonJS({
  "../../node_modules/@turf/clone/main.js"(exports2, module2) {
    "use strict";
    function clone(geojson) {
      if (!geojson)
        throw new Error("geojson is required");
      switch (geojson.type) {
        case "Feature":
          return cloneFeature(geojson);
        case "FeatureCollection":
          return cloneFeatureCollection(geojson);
        case "Point":
        case "LineString":
        case "Polygon":
        case "MultiPoint":
        case "MultiLineString":
        case "MultiPolygon":
        case "GeometryCollection":
          return cloneGeometry(geojson);
        default:
          throw new Error("unknown GeoJSON type");
      }
    }
    function cloneFeature(geojson) {
      var cloned = { type: "Feature" };
      Object.keys(geojson).forEach(function(key) {
        switch (key) {
          case "type":
          case "properties":
          case "geometry":
            return;
          default:
            cloned[key] = geojson[key];
        }
      });
      cloned.properties = cloneProperties(geojson.properties);
      cloned.geometry = cloneGeometry(geojson.geometry);
      return cloned;
    }
    function cloneProperties(properties) {
      var cloned = {};
      if (!properties)
        return cloned;
      Object.keys(properties).forEach(function(key) {
        var value = properties[key];
        if (typeof value === "object") {
          if (value === null) {
            cloned[key] = null;
          } else if (value.length) {
            cloned[key] = value.map(function(item) {
              return item;
            });
          } else {
            cloned[key] = cloneProperties(value);
          }
        } else
          cloned[key] = value;
      });
      return cloned;
    }
    function cloneFeatureCollection(geojson) {
      var cloned = { type: "FeatureCollection" };
      Object.keys(geojson).forEach(function(key) {
        switch (key) {
          case "type":
          case "features":
            return;
          default:
            cloned[key] = geojson[key];
        }
      });
      cloned.features = geojson.features.map(function(feature) {
        return cloneFeature(feature);
      });
      return cloned;
    }
    function cloneGeometry(geometry) {
      var geom = { type: geometry.type };
      if (geometry.bbox)
        geom.bbox = geometry.bbox;
      if (geometry.type === "GeometryCollection") {
        geom.geometries = geometry.geometries.map(function(geom2) {
          return cloneGeometry(geom2);
        });
        return geom;
      }
      geom.coordinates = deepSlice(geometry.coordinates);
      return geom;
    }
    function deepSlice(coords) {
      if (typeof coords[0] !== "object") {
        return coords.slice();
      }
      return coords.map(function(coord) {
        return deepSlice(coord);
      });
    }
    module2.exports = clone;
    module2.exports.default = clone;
  }
});

// ../../node_modules/@turf/helpers/main.js
var require_main2 = __commonJS({
  "../../node_modules/@turf/helpers/main.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var earthRadius = 63710088e-1;
    var factors = {
      meters: earthRadius,
      metres: earthRadius,
      millimeters: earthRadius * 1e3,
      millimetres: earthRadius * 1e3,
      centimeters: earthRadius * 100,
      centimetres: earthRadius * 100,
      kilometers: earthRadius / 1e3,
      kilometres: earthRadius / 1e3,
      miles: earthRadius / 1609.344,
      nauticalmiles: earthRadius / 1852,
      inches: earthRadius * 39.37,
      yards: earthRadius / 1.0936,
      feet: earthRadius * 3.28084,
      radians: 1,
      degrees: earthRadius / 111325
    };
    var unitsFactors = {
      meters: 1,
      metres: 1,
      millimeters: 1e3,
      millimetres: 1e3,
      centimeters: 100,
      centimetres: 100,
      kilometers: 1 / 1e3,
      kilometres: 1 / 1e3,
      miles: 1 / 1609.344,
      nauticalmiles: 1 / 1852,
      inches: 39.37,
      yards: 1 / 1.0936,
      feet: 3.28084,
      radians: 1 / earthRadius,
      degrees: 1 / 111325
    };
    var areaFactors = {
      meters: 1,
      metres: 1,
      millimeters: 1e6,
      millimetres: 1e6,
      centimeters: 1e4,
      centimetres: 1e4,
      kilometers: 1e-6,
      kilometres: 1e-6,
      acres: 247105e-9,
      miles: 386e-9,
      yards: 1.195990046,
      feet: 10.763910417,
      inches: 1550.003100006
    };
    function feature(geometry2, properties, options) {
      options = options || {};
      if (!isObject(options))
        throw new Error("options is invalid");
      var bbox = options.bbox;
      var id = options.id;
      if (geometry2 === void 0)
        throw new Error("geometry is required");
      if (properties && properties.constructor !== Object)
        throw new Error("properties must be an Object");
      if (bbox)
        validateBBox(bbox);
      if (id)
        validateId(id);
      var feat = { type: "Feature" };
      if (id)
        feat.id = id;
      if (bbox)
        feat.bbox = bbox;
      feat.properties = properties || {};
      feat.geometry = geometry2;
      return feat;
    }
    function geometry(type, coordinates, options) {
      options = options || {};
      if (!isObject(options))
        throw new Error("options is invalid");
      var bbox = options.bbox;
      if (!type)
        throw new Error("type is required");
      if (!coordinates)
        throw new Error("coordinates is required");
      if (!Array.isArray(coordinates))
        throw new Error("coordinates must be an Array");
      if (bbox)
        validateBBox(bbox);
      var geom;
      switch (type) {
        case "Point":
          geom = point(coordinates).geometry;
          break;
        case "LineString":
          geom = lineString(coordinates).geometry;
          break;
        case "Polygon":
          geom = polygon(coordinates).geometry;
          break;
        case "MultiPoint":
          geom = multiPoint(coordinates).geometry;
          break;
        case "MultiLineString":
          geom = multiLineString(coordinates).geometry;
          break;
        case "MultiPolygon":
          geom = multiPolygon(coordinates).geometry;
          break;
        default:
          throw new Error(type + " is invalid");
      }
      if (bbox)
        geom.bbox = bbox;
      return geom;
    }
    function point(coordinates, properties, options) {
      if (!coordinates)
        throw new Error("coordinates is required");
      if (!Array.isArray(coordinates))
        throw new Error("coordinates must be an Array");
      if (coordinates.length < 2)
        throw new Error("coordinates must be at least 2 numbers long");
      if (!isNumber(coordinates[0]) || !isNumber(coordinates[1]))
        throw new Error("coordinates must contain numbers");
      return feature({
        type: "Point",
        coordinates
      }, properties, options);
    }
    function points(coordinates, properties, options) {
      if (!coordinates)
        throw new Error("coordinates is required");
      if (!Array.isArray(coordinates))
        throw new Error("coordinates must be an Array");
      return featureCollection(coordinates.map(function(coords) {
        return point(coords, properties);
      }), options);
    }
    function polygon(coordinates, properties, options) {
      if (!coordinates)
        throw new Error("coordinates is required");
      for (var i = 0; i < coordinates.length; i++) {
        var ring = coordinates[i];
        if (ring.length < 4) {
          throw new Error("Each LinearRing of a Polygon must have 4 or more Positions.");
        }
        for (var j = 0; j < ring[ring.length - 1].length; j++) {
          if (i === 0 && j === 0 && !isNumber(ring[0][0]) || !isNumber(ring[0][1]))
            throw new Error("coordinates must contain numbers");
          if (ring[ring.length - 1][j] !== ring[0][j]) {
            throw new Error("First and last Position are not equivalent.");
          }
        }
      }
      return feature({
        type: "Polygon",
        coordinates
      }, properties, options);
    }
    function polygons(coordinates, properties, options) {
      if (!coordinates)
        throw new Error("coordinates is required");
      if (!Array.isArray(coordinates))
        throw new Error("coordinates must be an Array");
      return featureCollection(coordinates.map(function(coords) {
        return polygon(coords, properties);
      }), options);
    }
    function lineString(coordinates, properties, options) {
      if (!coordinates)
        throw new Error("coordinates is required");
      if (coordinates.length < 2)
        throw new Error("coordinates must be an array of two or more positions");
      if (!isNumber(coordinates[0][1]) || !isNumber(coordinates[0][1]))
        throw new Error("coordinates must contain numbers");
      return feature({
        type: "LineString",
        coordinates
      }, properties, options);
    }
    function lineStrings(coordinates, properties, options) {
      if (!coordinates)
        throw new Error("coordinates is required");
      if (!Array.isArray(coordinates))
        throw new Error("coordinates must be an Array");
      return featureCollection(coordinates.map(function(coords) {
        return lineString(coords, properties);
      }), options);
    }
    function featureCollection(features, options) {
      options = options || {};
      if (!isObject(options))
        throw new Error("options is invalid");
      var bbox = options.bbox;
      var id = options.id;
      if (!features)
        throw new Error("No features passed");
      if (!Array.isArray(features))
        throw new Error("features must be an Array");
      if (bbox)
        validateBBox(bbox);
      if (id)
        validateId(id);
      var fc = { type: "FeatureCollection" };
      if (id)
        fc.id = id;
      if (bbox)
        fc.bbox = bbox;
      fc.features = features;
      return fc;
    }
    function multiLineString(coordinates, properties, options) {
      if (!coordinates)
        throw new Error("coordinates is required");
      return feature({
        type: "MultiLineString",
        coordinates
      }, properties, options);
    }
    function multiPoint(coordinates, properties, options) {
      if (!coordinates)
        throw new Error("coordinates is required");
      return feature({
        type: "MultiPoint",
        coordinates
      }, properties, options);
    }
    function multiPolygon(coordinates, properties, options) {
      if (!coordinates)
        throw new Error("coordinates is required");
      return feature({
        type: "MultiPolygon",
        coordinates
      }, properties, options);
    }
    function geometryCollection(geometries, properties, options) {
      if (!geometries)
        throw new Error("geometries is required");
      if (!Array.isArray(geometries))
        throw new Error("geometries must be an Array");
      return feature({
        type: "GeometryCollection",
        geometries
      }, properties, options);
    }
    function round(num, precision) {
      if (num === void 0 || num === null || isNaN(num))
        throw new Error("num is required");
      if (precision && !(precision >= 0))
        throw new Error("precision must be a positive number");
      var multiplier = Math.pow(10, precision || 0);
      return Math.round(num * multiplier) / multiplier;
    }
    function radiansToLength(radians, units) {
      if (radians === void 0 || radians === null)
        throw new Error("radians is required");
      if (units && typeof units !== "string")
        throw new Error("units must be a string");
      var factor = factors[units || "kilometers"];
      if (!factor)
        throw new Error(units + " units is invalid");
      return radians * factor;
    }
    function lengthToRadians(distance, units) {
      if (distance === void 0 || distance === null)
        throw new Error("distance is required");
      if (units && typeof units !== "string")
        throw new Error("units must be a string");
      var factor = factors[units || "kilometers"];
      if (!factor)
        throw new Error(units + " units is invalid");
      return distance / factor;
    }
    function lengthToDegrees(distance, units) {
      return radiansToDegrees(lengthToRadians(distance, units));
    }
    function bearingToAzimuth(bearing) {
      if (bearing === null || bearing === void 0)
        throw new Error("bearing is required");
      var angle = bearing % 360;
      if (angle < 0)
        angle += 360;
      return angle;
    }
    function radiansToDegrees(radians) {
      if (radians === null || radians === void 0)
        throw new Error("radians is required");
      var degrees = radians % (2 * Math.PI);
      return degrees * 180 / Math.PI;
    }
    function degreesToRadians(degrees) {
      if (degrees === null || degrees === void 0)
        throw new Error("degrees is required");
      var radians = degrees % 360;
      return radians * Math.PI / 180;
    }
    function convertLength(length, originalUnit, finalUnit) {
      if (length === null || length === void 0)
        throw new Error("length is required");
      if (!(length >= 0))
        throw new Error("length must be a positive number");
      return radiansToLength(lengthToRadians(length, originalUnit), finalUnit || "kilometers");
    }
    function convertArea(area, originalUnit, finalUnit) {
      if (area === null || area === void 0)
        throw new Error("area is required");
      if (!(area >= 0))
        throw new Error("area must be a positive number");
      var startFactor = areaFactors[originalUnit || "meters"];
      if (!startFactor)
        throw new Error("invalid original units");
      var finalFactor = areaFactors[finalUnit || "kilometers"];
      if (!finalFactor)
        throw new Error("invalid final units");
      return area / startFactor * finalFactor;
    }
    function isNumber(num) {
      return !isNaN(num) && num !== null && !Array.isArray(num);
    }
    function isObject(input) {
      return !!input && input.constructor === Object;
    }
    function validateBBox(bbox) {
      if (!bbox)
        throw new Error("bbox is required");
      if (!Array.isArray(bbox))
        throw new Error("bbox must be an Array");
      if (bbox.length !== 4 && bbox.length !== 6)
        throw new Error("bbox must be an Array of 4 or 6 numbers");
      bbox.forEach(function(num) {
        if (!isNumber(num))
          throw new Error("bbox must only contain numbers");
      });
    }
    function validateId(id) {
      if (!id)
        throw new Error("id is required");
      if (["string", "number"].indexOf(typeof id) === -1)
        throw new Error("id must be a number or a string");
    }
    function radians2degrees() {
      throw new Error("method has been renamed to `radiansToDegrees`");
    }
    function degrees2radians() {
      throw new Error("method has been renamed to `degreesToRadians`");
    }
    function distanceToDegrees() {
      throw new Error("method has been renamed to `lengthToDegrees`");
    }
    function distanceToRadians() {
      throw new Error("method has been renamed to `lengthToRadians`");
    }
    function radiansToDistance() {
      throw new Error("method has been renamed to `radiansToLength`");
    }
    function bearingToAngle() {
      throw new Error("method has been renamed to `bearingToAzimuth`");
    }
    function convertDistance() {
      throw new Error("method has been renamed to `convertLength`");
    }
    exports2.earthRadius = earthRadius;
    exports2.factors = factors;
    exports2.unitsFactors = unitsFactors;
    exports2.areaFactors = areaFactors;
    exports2.feature = feature;
    exports2.geometry = geometry;
    exports2.point = point;
    exports2.points = points;
    exports2.polygon = polygon;
    exports2.polygons = polygons;
    exports2.lineString = lineString;
    exports2.lineStrings = lineStrings;
    exports2.featureCollection = featureCollection;
    exports2.multiLineString = multiLineString;
    exports2.multiPoint = multiPoint;
    exports2.multiPolygon = multiPolygon;
    exports2.geometryCollection = geometryCollection;
    exports2.round = round;
    exports2.radiansToLength = radiansToLength;
    exports2.lengthToRadians = lengthToRadians;
    exports2.lengthToDegrees = lengthToDegrees;
    exports2.bearingToAzimuth = bearingToAzimuth;
    exports2.radiansToDegrees = radiansToDegrees;
    exports2.degreesToRadians = degreesToRadians;
    exports2.convertLength = convertLength;
    exports2.convertArea = convertArea;
    exports2.isNumber = isNumber;
    exports2.isObject = isObject;
    exports2.validateBBox = validateBBox;
    exports2.validateId = validateId;
    exports2.radians2degrees = radians2degrees;
    exports2.degrees2radians = degrees2radians;
    exports2.distanceToDegrees = distanceToDegrees;
    exports2.distanceToRadians = distanceToRadians;
    exports2.radiansToDistance = radiansToDistance;
    exports2.bearingToAngle = bearingToAngle;
    exports2.convertDistance = convertDistance;
  }
});

// ../../node_modules/@turf/invariant/main.js
var require_main3 = __commonJS({
  "../../node_modules/@turf/invariant/main.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var helpers = require_main2();
    function getCoord(coord) {
      if (!coord)
        throw new Error("coord is required");
      if (coord.type === "Feature" && coord.geometry !== null && coord.geometry.type === "Point")
        return coord.geometry.coordinates;
      if (coord.type === "Point")
        return coord.coordinates;
      if (Array.isArray(coord) && coord.length >= 2 && coord[0].length === void 0 && coord[1].length === void 0)
        return coord;
      throw new Error("coord must be GeoJSON Point or an Array of numbers");
    }
    function getCoords(coords) {
      if (!coords)
        throw new Error("coords is required");
      if (coords.type === "Feature" && coords.geometry !== null)
        return coords.geometry.coordinates;
      if (coords.coordinates)
        return coords.coordinates;
      if (Array.isArray(coords))
        return coords;
      throw new Error("coords must be GeoJSON Feature, Geometry Object or an Array");
    }
    function containsNumber(coordinates) {
      if (coordinates.length > 1 && helpers.isNumber(coordinates[0]) && helpers.isNumber(coordinates[1])) {
        return true;
      }
      if (Array.isArray(coordinates[0]) && coordinates[0].length) {
        return containsNumber(coordinates[0]);
      }
      throw new Error("coordinates must only contain numbers");
    }
    function geojsonType(value, type, name) {
      if (!type || !name)
        throw new Error("type and name required");
      if (!value || value.type !== type) {
        throw new Error("Invalid input to " + name + ": must be a " + type + ", given " + value.type);
      }
    }
    function featureOf(feature, type, name) {
      if (!feature)
        throw new Error("No feature passed");
      if (!name)
        throw new Error(".featureOf() requires a name");
      if (!feature || feature.type !== "Feature" || !feature.geometry) {
        throw new Error("Invalid input to " + name + ", Feature with geometry required");
      }
      if (!feature.geometry || feature.geometry.type !== type) {
        throw new Error("Invalid input to " + name + ": must be a " + type + ", given " + feature.geometry.type);
      }
    }
    function collectionOf(featureCollection, type, name) {
      if (!featureCollection)
        throw new Error("No featureCollection passed");
      if (!name)
        throw new Error(".collectionOf() requires a name");
      if (!featureCollection || featureCollection.type !== "FeatureCollection") {
        throw new Error("Invalid input to " + name + ", FeatureCollection required");
      }
      for (var i = 0; i < featureCollection.features.length; i++) {
        var feature = featureCollection.features[i];
        if (!feature || feature.type !== "Feature" || !feature.geometry) {
          throw new Error("Invalid input to " + name + ", Feature with geometry required");
        }
        if (!feature.geometry || feature.geometry.type !== type) {
          throw new Error("Invalid input to " + name + ": must be a " + type + ", given " + feature.geometry.type);
        }
      }
    }
    function getGeom(geojson) {
      if (!geojson)
        throw new Error("geojson is required");
      if (geojson.geometry !== void 0)
        return geojson.geometry;
      if (geojson.coordinates || geojson.geometries)
        return geojson;
      throw new Error("geojson must be a valid Feature or Geometry Object");
    }
    function getGeomType() {
      throw new Error("invariant.getGeomType has been deprecated in v5.0 in favor of invariant.getType");
    }
    function getType(geojson, name) {
      if (!geojson)
        throw new Error((name || "geojson") + " is required");
      if (geojson.geometry && geojson.geometry.type)
        return geojson.geometry.type;
      if (geojson.type)
        return geojson.type;
      throw new Error((name || "geojson") + " is invalid");
    }
    exports2.getCoord = getCoord;
    exports2.getCoords = getCoords;
    exports2.containsNumber = containsNumber;
    exports2.geojsonType = geojsonType;
    exports2.featureOf = featureOf;
    exports2.collectionOf = collectionOf;
    exports2.getGeom = getGeom;
    exports2.getGeomType = getGeomType;
    exports2.getType = getType;
  }
});

// ../../node_modules/@turf/boolean-clockwise/main.js
var require_main4 = __commonJS({
  "../../node_modules/@turf/boolean-clockwise/main.js"(exports2, module2) {
    "use strict";
    var invariant = require_main3();
    function booleanClockwise(line) {
      if (!line)
        throw new Error("line is required");
      var type = line.geometry ? line.geometry.type : line.type;
      if (!Array.isArray(line) && type !== "LineString")
        throw new Error("geometry must be a LineString");
      var ring = invariant.getCoords(line);
      var sum = 0;
      var i = 1;
      var prev, cur;
      while (i < ring.length) {
        prev = cur || ring[0];
        cur = ring[i];
        sum += (cur[0] - prev[0]) * (cur[1] + prev[1]);
        i++;
      }
      return sum > 0;
    }
    module2.exports = booleanClockwise;
    module2.exports.default = booleanClockwise;
  }
});

// ../../node_modules/@turf/meta/main.js
var require_main5 = __commonJS({
  "../../node_modules/@turf/meta/main.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var helpers = require_main2();
    function coordEach(geojson, callback, excludeWrapCoord) {
      if (geojson === null)
        return;
      var j, k, l, geometry, stopG, coords, geometryMaybeCollection, wrapShrink = 0, coordIndex = 0, isGeometryCollection, type = geojson.type, isFeatureCollection = type === "FeatureCollection", isFeature = type === "Feature", stop = isFeatureCollection ? geojson.features.length : 1;
      for (var featureIndex = 0; featureIndex < stop; featureIndex++) {
        geometryMaybeCollection = isFeatureCollection ? geojson.features[featureIndex].geometry : isFeature ? geojson.geometry : geojson;
        isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === "GeometryCollection" : false;
        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;
        for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {
          var multiFeatureIndex = 0;
          var geometryIndex = 0;
          geometry = isGeometryCollection ? geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;
          if (geometry === null)
            continue;
          coords = geometry.coordinates;
          var geomType = geometry.type;
          wrapShrink = excludeWrapCoord && (geomType === "Polygon" || geomType === "MultiPolygon") ? 1 : 0;
          switch (geomType) {
            case null:
              break;
            case "Point":
              if (callback(coords, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false)
                return false;
              coordIndex++;
              multiFeatureIndex++;
              break;
            case "LineString":
            case "MultiPoint":
              for (j = 0; j < coords.length; j++) {
                if (callback(coords[j], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false)
                  return false;
                coordIndex++;
                if (geomType === "MultiPoint")
                  multiFeatureIndex++;
              }
              if (geomType === "LineString")
                multiFeatureIndex++;
              break;
            case "Polygon":
            case "MultiLineString":
              for (j = 0; j < coords.length; j++) {
                for (k = 0; k < coords[j].length - wrapShrink; k++) {
                  if (callback(coords[j][k], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false)
                    return false;
                  coordIndex++;
                }
                if (geomType === "MultiLineString")
                  multiFeatureIndex++;
                if (geomType === "Polygon")
                  geometryIndex++;
              }
              if (geomType === "Polygon")
                multiFeatureIndex++;
              break;
            case "MultiPolygon":
              for (j = 0; j < coords.length; j++) {
                if (geomType === "MultiPolygon")
                  geometryIndex = 0;
                for (k = 0; k < coords[j].length; k++) {
                  for (l = 0; l < coords[j][k].length - wrapShrink; l++) {
                    if (callback(coords[j][k][l], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false)
                      return false;
                    coordIndex++;
                  }
                  geometryIndex++;
                }
                multiFeatureIndex++;
              }
              break;
            case "GeometryCollection":
              for (j = 0; j < geometry.geometries.length; j++)
                if (coordEach(geometry.geometries[j], callback, excludeWrapCoord) === false)
                  return false;
              break;
            default:
              throw new Error("Unknown Geometry Type");
          }
        }
      }
    }
    function coordReduce(geojson, callback, initialValue, excludeWrapCoord) {
      var previousValue = initialValue;
      coordEach(geojson, function(currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {
        if (coordIndex === 0 && initialValue === void 0)
          previousValue = currentCoord;
        else
          previousValue = callback(previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex);
      }, excludeWrapCoord);
      return previousValue;
    }
    function propEach(geojson, callback) {
      var i;
      switch (geojson.type) {
        case "FeatureCollection":
          for (i = 0; i < geojson.features.length; i++) {
            if (callback(geojson.features[i].properties, i) === false)
              break;
          }
          break;
        case "Feature":
          callback(geojson.properties, 0);
          break;
      }
    }
    function propReduce(geojson, callback, initialValue) {
      var previousValue = initialValue;
      propEach(geojson, function(currentProperties, featureIndex) {
        if (featureIndex === 0 && initialValue === void 0)
          previousValue = currentProperties;
        else
          previousValue = callback(previousValue, currentProperties, featureIndex);
      });
      return previousValue;
    }
    function featureEach(geojson, callback) {
      if (geojson.type === "Feature") {
        callback(geojson, 0);
      } else if (geojson.type === "FeatureCollection") {
        for (var i = 0; i < geojson.features.length; i++) {
          if (callback(geojson.features[i], i) === false)
            break;
        }
      }
    }
    function featureReduce(geojson, callback, initialValue) {
      var previousValue = initialValue;
      featureEach(geojson, function(currentFeature, featureIndex) {
        if (featureIndex === 0 && initialValue === void 0)
          previousValue = currentFeature;
        else
          previousValue = callback(previousValue, currentFeature, featureIndex);
      });
      return previousValue;
    }
    function coordAll(geojson) {
      var coords = [];
      coordEach(geojson, function(coord) {
        coords.push(coord);
      });
      return coords;
    }
    function geomEach(geojson, callback) {
      var i, j, g, geometry, stopG, geometryMaybeCollection, isGeometryCollection, featureProperties, featureBBox, featureId, featureIndex = 0, isFeatureCollection = geojson.type === "FeatureCollection", isFeature = geojson.type === "Feature", stop = isFeatureCollection ? geojson.features.length : 1;
      for (i = 0; i < stop; i++) {
        geometryMaybeCollection = isFeatureCollection ? geojson.features[i].geometry : isFeature ? geojson.geometry : geojson;
        featureProperties = isFeatureCollection ? geojson.features[i].properties : isFeature ? geojson.properties : {};
        featureBBox = isFeatureCollection ? geojson.features[i].bbox : isFeature ? geojson.bbox : void 0;
        featureId = isFeatureCollection ? geojson.features[i].id : isFeature ? geojson.id : void 0;
        isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === "GeometryCollection" : false;
        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;
        for (g = 0; g < stopG; g++) {
          geometry = isGeometryCollection ? geometryMaybeCollection.geometries[g] : geometryMaybeCollection;
          if (geometry === null) {
            if (callback(null, featureIndex, featureProperties, featureBBox, featureId) === false)
              return false;
            continue;
          }
          switch (geometry.type) {
            case "Point":
            case "LineString":
            case "MultiPoint":
            case "Polygon":
            case "MultiLineString":
            case "MultiPolygon": {
              if (callback(geometry, featureIndex, featureProperties, featureBBox, featureId) === false)
                return false;
              break;
            }
            case "GeometryCollection": {
              for (j = 0; j < geometry.geometries.length; j++) {
                if (callback(geometry.geometries[j], featureIndex, featureProperties, featureBBox, featureId) === false)
                  return false;
              }
              break;
            }
            default:
              throw new Error("Unknown Geometry Type");
          }
        }
        featureIndex++;
      }
    }
    function geomReduce(geojson, callback, initialValue) {
      var previousValue = initialValue;
      geomEach(geojson, function(currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {
        if (featureIndex === 0 && initialValue === void 0)
          previousValue = currentGeometry;
        else
          previousValue = callback(previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId);
      });
      return previousValue;
    }
    function flattenEach(geojson, callback) {
      geomEach(geojson, function(geometry, featureIndex, properties, bbox, id) {
        var type = geometry === null ? null : geometry.type;
        switch (type) {
          case null:
          case "Point":
          case "LineString":
          case "Polygon":
            if (callback(helpers.feature(geometry, properties, { bbox, id }), featureIndex, 0) === false)
              return false;
            return;
        }
        var geomType;
        switch (type) {
          case "MultiPoint":
            geomType = "Point";
            break;
          case "MultiLineString":
            geomType = "LineString";
            break;
          case "MultiPolygon":
            geomType = "Polygon";
            break;
        }
        for (var multiFeatureIndex = 0; multiFeatureIndex < geometry.coordinates.length; multiFeatureIndex++) {
          var coordinate = geometry.coordinates[multiFeatureIndex];
          var geom = {
            type: geomType,
            coordinates: coordinate
          };
          if (callback(helpers.feature(geom, properties), featureIndex, multiFeatureIndex) === false)
            return false;
        }
      });
    }
    function flattenReduce(geojson, callback, initialValue) {
      var previousValue = initialValue;
      flattenEach(geojson, function(currentFeature, featureIndex, multiFeatureIndex) {
        if (featureIndex === 0 && multiFeatureIndex === 0 && initialValue === void 0)
          previousValue = currentFeature;
        else
          previousValue = callback(previousValue, currentFeature, featureIndex, multiFeatureIndex);
      });
      return previousValue;
    }
    function segmentEach(geojson, callback) {
      flattenEach(geojson, function(feature$$1, featureIndex, multiFeatureIndex) {
        var segmentIndex = 0;
        if (!feature$$1.geometry)
          return;
        var type = feature$$1.geometry.type;
        if (type === "Point" || type === "MultiPoint")
          return;
        var previousCoords;
        if (coordEach(feature$$1, function(currentCoord, coordIndex, featureIndexCoord, mutliPartIndexCoord, geometryIndex) {
          if (previousCoords === void 0) {
            previousCoords = currentCoord;
            return;
          }
          var currentSegment = helpers.lineString([previousCoords, currentCoord], feature$$1.properties);
          if (callback(currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) === false)
            return false;
          segmentIndex++;
          previousCoords = currentCoord;
        }) === false)
          return false;
      });
    }
    function segmentReduce(geojson, callback, initialValue) {
      var previousValue = initialValue;
      var started = false;
      segmentEach(geojson, function(currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {
        if (started === false && initialValue === void 0)
          previousValue = currentSegment;
        else
          previousValue = callback(previousValue, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex);
        started = true;
      });
      return previousValue;
    }
    function lineEach(geojson, callback) {
      if (!geojson)
        throw new Error("geojson is required");
      flattenEach(geojson, function(feature$$1, featureIndex, multiFeatureIndex) {
        if (feature$$1.geometry === null)
          return;
        var type = feature$$1.geometry.type;
        var coords = feature$$1.geometry.coordinates;
        switch (type) {
          case "LineString":
            if (callback(feature$$1, featureIndex, multiFeatureIndex, 0, 0) === false)
              return false;
            break;
          case "Polygon":
            for (var geometryIndex = 0; geometryIndex < coords.length; geometryIndex++) {
              if (callback(helpers.lineString(coords[geometryIndex], feature$$1.properties), featureIndex, multiFeatureIndex, geometryIndex) === false)
                return false;
            }
            break;
        }
      });
    }
    function lineReduce(geojson, callback, initialValue) {
      var previousValue = initialValue;
      lineEach(geojson, function(currentLine, featureIndex, multiFeatureIndex, geometryIndex) {
        if (featureIndex === 0 && initialValue === void 0)
          previousValue = currentLine;
        else
          previousValue = callback(previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex);
      });
      return previousValue;
    }
    function findSegment(geojson, options) {
      options = options || {};
      if (!helpers.isObject(options))
        throw new Error("options is invalid");
      var featureIndex = options.featureIndex || 0;
      var multiFeatureIndex = options.multiFeatureIndex || 0;
      var geometryIndex = options.geometryIndex || 0;
      var segmentIndex = options.segmentIndex || 0;
      var properties = options.properties;
      var geometry;
      switch (geojson.type) {
        case "FeatureCollection":
          if (featureIndex < 0)
            featureIndex = geojson.features.length + featureIndex;
          properties = properties || geojson.features[featureIndex].properties;
          geometry = geojson.features[featureIndex].geometry;
          break;
        case "Feature":
          properties = properties || geojson.properties;
          geometry = geojson.geometry;
          break;
        case "Point":
        case "MultiPoint":
          return null;
        case "LineString":
        case "Polygon":
        case "MultiLineString":
        case "MultiPolygon":
          geometry = geojson;
          break;
        default:
          throw new Error("geojson is invalid");
      }
      if (geometry === null)
        return null;
      var coords = geometry.coordinates;
      switch (geometry.type) {
        case "Point":
        case "MultiPoint":
          return null;
        case "LineString":
          if (segmentIndex < 0)
            segmentIndex = coords.length + segmentIndex - 1;
          return helpers.lineString([coords[segmentIndex], coords[segmentIndex + 1]], properties, options);
        case "Polygon":
          if (geometryIndex < 0)
            geometryIndex = coords.length + geometryIndex;
          if (segmentIndex < 0)
            segmentIndex = coords[geometryIndex].length + segmentIndex - 1;
          return helpers.lineString([coords[geometryIndex][segmentIndex], coords[geometryIndex][segmentIndex + 1]], properties, options);
        case "MultiLineString":
          if (multiFeatureIndex < 0)
            multiFeatureIndex = coords.length + multiFeatureIndex;
          if (segmentIndex < 0)
            segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;
          return helpers.lineString([coords[multiFeatureIndex][segmentIndex], coords[multiFeatureIndex][segmentIndex + 1]], properties, options);
        case "MultiPolygon":
          if (multiFeatureIndex < 0)
            multiFeatureIndex = coords.length + multiFeatureIndex;
          if (geometryIndex < 0)
            geometryIndex = coords[multiFeatureIndex].length + geometryIndex;
          if (segmentIndex < 0)
            segmentIndex = coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;
          return helpers.lineString([coords[multiFeatureIndex][geometryIndex][segmentIndex], coords[multiFeatureIndex][geometryIndex][segmentIndex + 1]], properties, options);
      }
      throw new Error("geojson is invalid");
    }
    function findPoint(geojson, options) {
      options = options || {};
      if (!helpers.isObject(options))
        throw new Error("options is invalid");
      var featureIndex = options.featureIndex || 0;
      var multiFeatureIndex = options.multiFeatureIndex || 0;
      var geometryIndex = options.geometryIndex || 0;
      var coordIndex = options.coordIndex || 0;
      var properties = options.properties;
      var geometry;
      switch (geojson.type) {
        case "FeatureCollection":
          if (featureIndex < 0)
            featureIndex = geojson.features.length + featureIndex;
          properties = properties || geojson.features[featureIndex].properties;
          geometry = geojson.features[featureIndex].geometry;
          break;
        case "Feature":
          properties = properties || geojson.properties;
          geometry = geojson.geometry;
          break;
        case "Point":
        case "MultiPoint":
          return null;
        case "LineString":
        case "Polygon":
        case "MultiLineString":
        case "MultiPolygon":
          geometry = geojson;
          break;
        default:
          throw new Error("geojson is invalid");
      }
      if (geometry === null)
        return null;
      var coords = geometry.coordinates;
      switch (geometry.type) {
        case "Point":
          return helpers.point(coords, properties, options);
        case "MultiPoint":
          if (multiFeatureIndex < 0)
            multiFeatureIndex = coords.length + multiFeatureIndex;
          return helpers.point(coords[multiFeatureIndex], properties, options);
        case "LineString":
          if (coordIndex < 0)
            coordIndex = coords.length + coordIndex;
          return helpers.point(coords[coordIndex], properties, options);
        case "Polygon":
          if (geometryIndex < 0)
            geometryIndex = coords.length + geometryIndex;
          if (coordIndex < 0)
            coordIndex = coords[geometryIndex].length + coordIndex;
          return helpers.point(coords[geometryIndex][coordIndex], properties, options);
        case "MultiLineString":
          if (multiFeatureIndex < 0)
            multiFeatureIndex = coords.length + multiFeatureIndex;
          if (coordIndex < 0)
            coordIndex = coords[multiFeatureIndex].length + coordIndex;
          return helpers.point(coords[multiFeatureIndex][coordIndex], properties, options);
        case "MultiPolygon":
          if (multiFeatureIndex < 0)
            multiFeatureIndex = coords.length + multiFeatureIndex;
          if (geometryIndex < 0)
            geometryIndex = coords[multiFeatureIndex].length + geometryIndex;
          if (coordIndex < 0)
            coordIndex = coords[multiFeatureIndex][geometryIndex].length - coordIndex;
          return helpers.point(coords[multiFeatureIndex][geometryIndex][coordIndex], properties, options);
      }
      throw new Error("geojson is invalid");
    }
    exports2.coordEach = coordEach;
    exports2.coordReduce = coordReduce;
    exports2.propEach = propEach;
    exports2.propReduce = propReduce;
    exports2.featureEach = featureEach;
    exports2.featureReduce = featureReduce;
    exports2.coordAll = coordAll;
    exports2.geomEach = geomEach;
    exports2.geomReduce = geomReduce;
    exports2.flattenEach = flattenEach;
    exports2.flattenReduce = flattenReduce;
    exports2.segmentEach = segmentEach;
    exports2.segmentReduce = segmentReduce;
    exports2.lineEach = lineEach;
    exports2.lineReduce = lineReduce;
    exports2.findSegment = findSegment;
    exports2.findPoint = findPoint;
  }
});

// ../../node_modules/@turf/rewind/main.js
var require_main6 = __commonJS({
  "../../node_modules/@turf/rewind/main.js"(exports2, module2) {
    "use strict";
    function _interopDefault(ex) {
      return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
    }
    var clone = _interopDefault(require_main());
    var booleanClockwise = _interopDefault(require_main4());
    var meta = require_main5();
    var invariant = require_main3();
    var helpers = require_main2();
    function rewind2(geojson, options) {
      options = options || {};
      if (!helpers.isObject(options))
        throw new Error("options is invalid");
      var reverse = options.reverse || false;
      var mutate = options.mutate || false;
      if (!geojson)
        throw new Error("<geojson> is required");
      if (typeof reverse !== "boolean")
        throw new Error("<reverse> must be a boolean");
      if (typeof mutate !== "boolean")
        throw new Error("<mutate> must be a boolean");
      if (mutate === false)
        geojson = clone(geojson);
      var results = [];
      switch (geojson.type) {
        case "GeometryCollection":
          meta.geomEach(geojson, function(geometry) {
            rewindFeature(geometry, reverse);
          });
          return geojson;
        case "FeatureCollection":
          meta.featureEach(geojson, function(feature) {
            meta.featureEach(rewindFeature(feature, reverse), function(result) {
              results.push(result);
            });
          });
          return helpers.featureCollection(results);
      }
      return rewindFeature(geojson, reverse);
    }
    function rewindFeature(geojson, reverse) {
      var type = geojson.type === "Feature" ? geojson.geometry.type : geojson.type;
      switch (type) {
        case "GeometryCollection":
          meta.geomEach(geojson, function(geometry) {
            rewindFeature(geometry, reverse);
          });
          return geojson;
        case "LineString":
          rewindLineString(invariant.getCoords(geojson), reverse);
          return geojson;
        case "Polygon":
          rewindPolygon(invariant.getCoords(geojson), reverse);
          return geojson;
        case "MultiLineString":
          invariant.getCoords(geojson).forEach(function(lineCoords) {
            rewindLineString(lineCoords, reverse);
          });
          return geojson;
        case "MultiPolygon":
          invariant.getCoords(geojson).forEach(function(lineCoords) {
            rewindPolygon(lineCoords, reverse);
          });
          return geojson;
        case "Point":
        case "MultiPoint":
          return geojson;
      }
    }
    function rewindLineString(coords, reverse) {
      if (booleanClockwise(coords) === reverse)
        coords.reverse();
    }
    function rewindPolygon(coords, reverse) {
      if (booleanClockwise(coords[0]) !== reverse) {
        coords[0].reverse();
      }
      for (var i = 1; i < coords.length; i++) {
        if (booleanClockwise(coords[i]) === reverse) {
          coords[i].reverse();
        }
      }
    }
    module2.exports = rewind2;
    module2.exports.default = rewind2;
  }
});

// src/lib/gml/parse-gml.ts
function noTransform(...coords) {
  return coords;
}
function parseGML(text, options) {
  const parsedXML = XMLLoader.parseTextSync(text, options);
  options = { transformCoords: noTransform, stride: 2, ...options };
  const context = createChildContext(parsedXML, options, {});
  return parseGMLToGeometry(parsedXML, options, context);
}
function parseGMLToGeometry(inputXML, options, context) {
  const childContext = createChildContext(inputXML, options, context);
  let geometry = null;
  const [name, xml] = getFirstKeyValue(inputXML);
  switch (name) {
    case "gml:LineString":
      geometry = {
        type: "LineString",
        coordinates: parseLinearRingOrLineString(xml, options, childContext)
      };
      break;
    case "gml:Polygon":
    case "gml:Rectangle":
      geometry = {
        type: "Polygon",
        coordinates: parsePolygonOrRectangle(xml, options, childContext)
      };
      break;
    case "gml:Surface":
      geometry = {
        type: "MultiPolygon",
        coordinates: parseSurface(xml, options, childContext)
      };
      break;
    case "gml:MultiSurface":
      geometry = {
        type: "MultiPolygon",
        coordinates: parseMultiSurface(xml, options, childContext)
      };
      break;
    default:
      return null;
  }
  return (0, import_rewind.default)(geometry, { mutate: true });
}
function parseCoords(s, options, context) {
  const stride = context.srsDimension || options.stride || 2;
  const coords = s.replace(/\s+/g, " ").trim().split(" ");
  if (coords.length === 0 || coords.length % stride !== 0) {
    throw new Error(`invalid coordinates list (stride ${stride})`);
  }
  const points = [];
  for (let i = 0; i < coords.length - 1; i += stride) {
    const point = coords.slice(i, i + stride).map(parseFloat);
    points.push(options.transformCoords?.(...point) || point);
  }
  return points;
}
function parsePosList(xml, options, context) {
  const childContext = createChildContext(xml, options, context);
  const coords = textOf(xml);
  if (!coords) {
    throw new Error("invalid gml:posList element");
  }
  return parseCoords(coords, options, childContext);
}
function parsePos(xml, options, context) {
  const childContext = createChildContext(xml, options, context);
  const coords = textOf(xml);
  if (!coords) {
    throw new Error("invalid gml:pos element");
  }
  const points = parseCoords(coords, options, childContext);
  if (points.length !== 1) {
    throw new Error("gml:pos must have 1 point");
  }
  return points[0];
}
function parsePoint(xml, options, context) {
  const childContext = createChildContext(xml, options, context);
  const pos = findIn(xml, "gml:pos");
  if (!pos) {
    throw new Error("invalid gml:Point element, expected a gml:pos subelement");
  }
  return parsePos(pos, options, childContext);
}
function parseLinearRingOrLineString(xml, options, context) {
  const childContext = createChildContext(xml, options, context);
  let points = [];
  const posList = findIn(xml, "gml:posList");
  if (posList) {
    points = parsePosList(posList, options, childContext);
  } else {
    for (const [childName, childXML] of Object.entries(xml)) {
      switch (childName) {
        case "gml:Point":
          points.push(parsePoint(childXML, options, childContext));
          break;
        case "gml:pos":
          points.push(parsePos(childXML, options, childContext));
          break;
        default:
          continue;
      }
    }
  }
  if (points.length === 0) {
    throw new Error(`${xml.name} must have > 0 points`);
  }
  return points;
}
function parseCurveSegments(xml, options, context) {
  const points = [];
  for (const [childName, childXML] of Object.entries(xml)) {
    switch (childName) {
      case "gml:LineStringSegment":
        const points2 = parseLinearRingOrLineString(childXML, options, context);
        const end = points[points.length - 1];
        const start = points2[0];
        if (end && start && deepStrictEqual(end, start)) {
          points2.shift();
        }
        points.push(...points2);
        break;
      default:
        continue;
    }
  }
  if (points.length === 0) {
    throw new Error("gml:Curve > gml:segments must have > 0 points");
  }
  return points;
}
function parseRing(xml, options, context) {
  const childContext = createChildContext(xml, options, context);
  const points = [];
  for (const [childName, childXML] of Object.entries(xml)) {
    switch (childName) {
      case "gml:curveMember":
        let points2;
        const lineString = findIn(childXML, "gml:LineString");
        if (lineString) {
          points2 = parseLinearRingOrLineString(lineString, options, childContext);
        } else {
          const segments = findIn(childXML, "gml:Curve", "gml:segments");
          if (!segments) {
            throw new Error(`invalid ${childName} element`);
          }
          points2 = parseCurveSegments(segments, options, childContext);
        }
        const end = points[points.length - 1];
        const start = points2[0];
        if (end && start && deepStrictEqual(end, start)) {
          points2.shift();
        }
        points.push(...points2);
        break;
    }
  }
  if (points.length < 4) {
    throw new Error(`${xml.name} must have >= 4 points`);
  }
  return points;
}
function parseExteriorOrInterior(xml, options, context) {
  const linearRing = findIn(xml, "gml:LinearRing");
  if (linearRing) {
    return parseLinearRingOrLineString(linearRing, options, context);
  }
  const ring = findIn(xml, "gml:Ring");
  if (!ring) {
    throw new Error(`invalid ${xml.name} element`);
  }
  return parseRing(ring, options, context);
}
function parsePolygonOrRectangle(xml, options, context) {
  const childContext = createChildContext(xml, options, context);
  const exterior = findIn(xml, "gml:exterior");
  if (!exterior) {
    throw new Error(`invalid ${xml.name} element`);
  }
  const pointLists = [parseExteriorOrInterior(exterior, options, childContext)];
  for (const [childName, childXML] of Object.entries(xml)) {
    switch (childName) {
      case "gml:interior":
        pointLists.push(parseExteriorOrInterior(childXML, options, childContext));
        break;
    }
  }
  return pointLists;
}
function parseSurface(xml, options, context) {
  const childContext = createChildContext(xml, options, context);
  const patches = findIn(xml, "gml:patches");
  if (!patches) {
    throw new Error(`invalid ${xml.name} element`);
  }
  const polygons = [];
  for (const [childName, childXML] of Object.entries(xml)) {
    switch (childName) {
      case "gml:PolygonPatch":
      case "gml:Rectangle":
        polygons.push(parsePolygonOrRectangle(childXML, options, childContext));
        break;
      default:
        continue;
    }
  }
  if (polygons.length === 0) {
    throw new Error(`${xml.name} must have > 0 polygons`);
  }
  return polygons;
}
function parseCompositeSurface(xml, options, context) {
  const childContext = createChildContext(xml, options, context);
  const polygons = [];
  for (const [childName, childXML] of Object.entries(xml)) {
    switch (childName) {
      case "gml:surfaceMember":
      case "gml:surfaceMembers":
        const [c2Name, c2Xml] = getFirstKeyValue(childXML);
        switch (c2Name) {
          case "gml:Surface":
            polygons.push(...parseSurface(c2Xml, options, childContext));
            break;
          case "gml:Polygon":
            polygons.push(parsePolygonOrRectangle(c2Xml, options, childContext));
            break;
        }
        break;
    }
  }
  if (polygons.length === 0) {
    throw new Error(`${xml.name} must have > 0 polygons`);
  }
  return polygons;
}
function parseMultiSurface(xml, options, context) {
  let el = xml;
  const surfaceMembers = findIn(xml, "gml:LinearRing");
  if (surfaceMembers) {
    el = surfaceMembers;
  }
  const polygons = [];
  for (const [childName, childXML] of Object.entries(el)) {
    switch (childName) {
      case "gml:Surface":
        const polygons2 = parseSurface(childXML, options, context);
        polygons.push(...polygons2);
        break;
      case "gml:surfaceMember":
        const polygons3 = parseSurfaceMember(childXML, options, context);
        polygons.push(...polygons3);
        break;
      case "gml:surfaceMembers":
        const polygonXML = findIn(childXML, "gml:Polygon");
        for (const surfaceMemberXML of polygonXML) {
          const polygons32 = parseSurfaceMember(surfaceMemberXML, options, context);
          polygons.push(...polygons32);
        }
        break;
    }
  }
  if (polygons.length === 0) {
    throw new Error(`${xml.name} must have > 0 polygons`);
  }
  return polygons;
}
function parseSurfaceMember(xml, options, context) {
  const [childName, childXml] = getFirstKeyValue(xml);
  switch (childName) {
    case "gml:CompositeSurface":
      return parseCompositeSurface(childXml, options, context);
    case "gml:Surface":
      return parseSurface(childXml, options, context);
    case "gml:Polygon":
      return [parsePolygonOrRectangle(childXml, options, context)];
  }
  throw new Error(`${childName} must have polygons`);
}
function textOf(el) {
  if (typeof el !== "string") {
    throw new Error("expected string");
  }
  return el;
}
function findIn(root, ...tags) {
  let el = root;
  for (const tag of tags) {
    const child = el[tag];
    if (!child) {
      return null;
    }
    el = child;
  }
  return el;
}
function getFirstKeyValue(object) {
  if (object && typeof object === "object") {
    for (const [key, value] of Object.entries(object)) {
      return [key, value];
    }
  }
  return ["", null];
}
function createChildContext(xml, options, context) {
  const srsDimensionAttribute = xml.attributes && xml.attributes.srsDimension;
  if (srsDimensionAttribute) {
    const srsDimension = parseInt(srsDimensionAttribute);
    if (Number.isNaN(srsDimension) || srsDimension <= 0) {
      throw new Error(`invalid srsDimension attribute value "${srsDimensionAttribute}", expected a positive integer`);
    }
    const childContext = Object.create(context);
    childContext.srsDimension = srsDimension;
    return childContext;
  }
  return context;
}
var import_rewind;
var init_parse_gml = __esm({
  "src/lib/gml/parse-gml.ts"() {
    init_src();
    init_deep_strict_equal();
    import_rewind = __toModule(require_main6());
  }
});

// src/wip/gml-loader.ts
function testXMLFile6(text) {
  return text.startsWith("<?xml");
}
var VERSION7, GMLLoader;
var init_gml_loader = __esm({
  "src/wip/gml-loader.ts"() {
    init_parse_gml();
    VERSION7 = typeof __VERSION__ !== "undefined" ? __VERSION__ : "latest";
    GMLLoader = {
      name: "GML",
      id: "gml",
      module: "wms",
      version: VERSION7,
      worker: false,
      extensions: ["xml"],
      mimeTypes: ["application/vnd.ogc.gml_xml", "application/xml", "text/xml"],
      testText: testXMLFile6,
      options: {
        gml: {}
      },
      parse: async (arrayBuffer, options) => parseGML(new TextDecoder().decode(arrayBuffer), options),
      parseTextSync: (text, options) => parseGML(text, options)
    };
  }
});

// src/index.ts
var src_exports = {};
__export(src_exports, {
  ImageService: () => ImageService,
  ImageSource: () => ImageSource,
  WMSCapabilitiesLoader: () => WMSCapabilitiesLoader,
  WMSErrorLoader: () => WMSErrorLoader,
  WMSService: () => WMSService,
  _ArcGISImageService: () => ArcGISImageService,
  _GMLLoader: () => GMLLoader,
  _WFSCapabilitiesLoader: () => WFSCapabilitiesLoader,
  _WMSFeatureInfoLoader: () => WMSFeatureInfoLoader,
  _WMSLayerDescriptionLoader: () => WMSLayerDescriptionLoader,
  _WMTSCapabilitiesLoader: () => WMTSCapabilitiesLoader,
  createImageSource: () => createImageSource
});
var init_src4 = __esm({
  "src/index.ts"() {
    init_wms_error_loader();
    init_wms_capabilities_loader();
    init_image_source();
    init_create_image_source();
    init_image_service();
    init_wms_service();
    init_arcgis_image_service();
    init_wms_feature_info_loader();
    init_wms_layer_description_loader();
    init_wmts_capabilities_loader();
    init_wfs_capabilities_loader();
    init_gml_loader();
  }
});

// src/bundle.ts
var moduleExports = (init_src4(), src_exports);
globalThis.loaders = globalThis.loaders || {};
module.exports = Object.assign(globalThis.loaders, moduleExports);
