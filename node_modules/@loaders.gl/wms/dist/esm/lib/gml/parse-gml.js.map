{"version":3,"file":"parse-gml.js","names":["XMLLoader","deepStrictEqual","rewind","noTransform","coords","parseGML","text","options","parsedXML","parseTextSync","transformCoords","stride","context","createChildContext","parseGMLToGeometry","inputXML","childContext","geometry","name","xml","getFirstKeyValue","type","coordinates","parseLinearRingOrLineString","parsePolygonOrRectangle","parseSurface","parseMultiSurface","mutate","parseCoords","s","srsDimension","replace","trim","split","length","Error","points","i","point","slice","map","parseFloat","push","parsePosList","textOf","parsePos","parsePoint","pos","findIn","posList","childName","childXML","Object","entries","parseCurveSegments","points2","end","start","shift","parseRing","lineString","segments","parseExteriorOrInterior","linearRing","ring","exterior","pointLists","patches","polygons","parseCompositeSurface","c2Name","c2Xml","el","surfaceMembers","polygons2","polygons3","parseSurfaceMember","polygonXML","surfaceMemberXML","childXml","root","tags","tag","child","object","key","value","srsDimensionAttribute","attributes","parseInt","Number","isNaN","create"],"sources":["../../../../src/lib/gml/parse-gml.ts"],"sourcesContent":["// loaders.gl, MIT license\n\n// Forked from https://github.com/derhuerst/parse-gml-polygon/blob/master/index.js\n// under ISC license\n\n/* eslint-disable no-continue, default-case */\n\nimport type {\n  // GeoJSON,\n  // Feature,\n  // FeatureCollection,\n  Geometry,\n  Position\n  // GeoJsonProperties,\n  // Point,\n  // MultiPoint,\n  // LineString,\n  // MultiLineString,\n  // Polygon,\n  // MultiPolygon,\n  // GeometryCollection\n} from '@loaders.gl/schema';\n\nimport {XMLLoader} from '@loaders.gl/xml';\nimport {deepStrictEqual} from './deep-strict-equal';\nimport rewind from '@turf/rewind';\n\nfunction noTransform(...coords) {\n  return coords;\n}\n\nexport type ParseGMLOptions = {\n  transformCoords?: Function;\n  stride?: 2 | 3 | 4;\n};\n\nexport type ParseGMLContext = {\n  srsDimension?: number;\n  [key: string]: any;\n};\n\n/**\n * Parses a typed data structure from raw XML for GML features\n * @note Error handlings is fairly weak\n */\nexport function parseGML(text: string, options) {\n  // GeoJSON | null {\n  const parsedXML = XMLLoader.parseTextSync(text, options);\n\n  options = {transformCoords: noTransform, stride: 2, ...options};\n  const context = createChildContext(parsedXML, options, {});\n\n  return parseGMLToGeometry(parsedXML, options, context);\n}\n\n/** Parse a GeoJSON geometry from GML XML */\nexport function parseGMLToGeometry(\n  inputXML: any,\n  options: ParseGMLOptions,\n  context: ParseGMLContext\n): Geometry | null {\n  const childContext = createChildContext(inputXML, options, context);\n\n  let geometry: Geometry | null = null;\n\n  const [name, xml] = getFirstKeyValue(inputXML);\n\n  switch (name) {\n    // case 'gml:MultiPoint':\n    //   geometry = {\n    //     type: 'MultiPoint',\n    //     coordinates: parseMultiPoint(xml, options, childContext)\n    //   };\n    //   break;\n\n    case 'gml:LineString':\n      geometry = {\n        type: 'LineString',\n        coordinates: parseLinearRingOrLineString(xml, options, childContext)\n      };\n      break;\n\n      // case 'gml:MultiLineString':\n      //   geometry = {\n      //     type: 'MultiLineString',\n      //     coordinates: parseMultiLineString(xml, options, childContext)\n      //   };\n      //   break;\n\n    case 'gml:Polygon':\n    case 'gml:Rectangle':\n      geometry = {\n        type: 'Polygon',\n        coordinates: parsePolygonOrRectangle(xml, options, childContext)\n      };\n      break;\n    case 'gml:Surface':\n      geometry = {\n        type: 'MultiPolygon',\n        coordinates: parseSurface(xml, options, childContext)\n      };\n      break;\n    case 'gml:MultiSurface':\n      geometry = {\n        type: 'MultiPolygon',\n        coordinates: parseMultiSurface(xml, options, childContext)\n      };\n      break;\n\n    default:\n      return null;\n  }\n\n  // todo\n  return rewind(geometry, {mutate: true});\n}\n\n/** Parse a list of coordinates from a string */\nfunction parseCoords(s: string, options: ParseGMLOptions, context: ParseGMLContext): Position[] {\n  const stride = context.srsDimension || options.stride || 2;\n\n  // Handle white space\n  const coords = s.replace(/\\s+/g, ' ').trim().split(' ');\n\n  if (coords.length === 0 || coords.length % stride !== 0) {\n    throw new Error(`invalid coordinates list (stride ${stride})`);\n  }\n\n  const points: Position[] = [];\n  for (let i = 0; i < coords.length - 1; i += stride) {\n    const point = coords.slice(i, i + stride).map(parseFloat);\n    points.push(options.transformCoords?.(...point) || point);\n  }\n\n  return points;\n}\n\nexport function parsePosList(xml: any, options: ParseGMLOptions, context: ParseGMLContext) {\n  const childContext = createChildContext(xml, options, context);\n\n  const coords = textOf(xml);\n  if (!coords) {\n    throw new Error('invalid gml:posList element');\n  }\n\n  return parseCoords(coords, options, childContext);\n}\n\nexport function parsePos(xml: any, options: ParseGMLOptions, context: ParseGMLContext): Position {\n  const childContext = createChildContext(xml, options, context);\n\n  const coords = textOf(xml);\n  if (!coords) {\n    throw new Error('invalid gml:pos element');\n  }\n\n  const points = parseCoords(coords, options, childContext);\n  if (points.length !== 1) {\n    throw new Error('gml:pos must have 1 point');\n  }\n  return points[0];\n}\n\nexport function parsePoint(xml: any, options: ParseGMLOptions, context: ParseGMLContext): number[] {\n  const childContext = createChildContext(xml, options, context);\n\n  // TODO AV: Parse other gml:Point options\n  const pos = findIn(xml, 'gml:pos');\n  if (!pos) {\n    throw new Error('invalid gml:Point element, expected a gml:pos subelement');\n  }\n  return parsePos(pos, options, childContext);\n}\n\nexport function parseLinearRingOrLineString(\n  xml: any,\n  options: ParseGMLOptions,\n  context: ParseGMLContext\n): Position[] {\n  // or a LineStringSegment\n  const childContext = createChildContext(xml, options, context);\n\n  let points: Position[] = [];\n\n  const posList = findIn(xml, 'gml:posList');\n  if (posList) {\n    points = parsePosList(posList, options, childContext);\n  } else {\n    for (const [childName, childXML] of Object.entries(xml)) {\n      switch (childName) {\n        case 'gml:Point':\n          points.push(parsePoint(childXML, options, childContext));\n          break;\n        case 'gml:pos':\n          points.push(parsePos(childXML, options, childContext));\n          break;\n        default:\n          continue;\n      }\n    }\n  }\n\n  if (points.length === 0) {\n    throw new Error(`${xml.name} must have > 0 points`);\n  }\n  return points;\n}\n\nexport function parseCurveSegments(\n  xml: any,\n  options: ParseGMLOptions,\n  context: ParseGMLContext\n): Position[] {\n  const points: Position[] = [];\n\n  for (const [childName, childXML] of Object.entries(xml)) {\n    switch (childName) {\n      case 'gml:LineStringSegment':\n        const points2 = parseLinearRingOrLineString(childXML, options, context);\n\n        // remove overlapping\n        const end = points[points.length - 1];\n        const start = points2[0];\n        if (end && start && deepStrictEqual(end, start)) {\n          points2.shift();\n        }\n\n        points.push(...points2);\n        break;\n      default:\n        continue;\n    }\n  }\n\n  if (points.length === 0) {\n    throw new Error('gml:Curve > gml:segments must have > 0 points');\n  }\n  return points;\n}\n\nexport function parseRing(\n  xml: any,\n  options: ParseGMLOptions,\n  context: ParseGMLContext\n): Position[] {\n  const childContext = createChildContext(xml, options, context);\n\n  const points: Position[] = [];\n\n  for (const [childName, childXML] of Object.entries(xml)) {\n    switch (childName) {\n      case 'gml:curveMember':\n        let points2;\n\n        const lineString = findIn(childXML, 'gml:LineString');\n        if (lineString) {\n          points2 = parseLinearRingOrLineString(lineString, options, childContext);\n        } else {\n          const segments = findIn(childXML, 'gml:Curve', 'gml:segments');\n          if (!segments) {\n            throw new Error(`invalid ${childName} element`);\n          }\n\n          points2 = parseCurveSegments(segments, options, childContext);\n        }\n\n        // remove overlapping\n        const end = points[points.length - 1];\n        const start = points2[0];\n        if (end && start && deepStrictEqual(end, start)) {\n          points2.shift();\n        }\n\n        points.push(...points2);\n\n        break;\n    }\n  }\n\n  if (points.length < 4) {\n    throw new Error(`${xml.name} must have >= 4 points`);\n  }\n  return points;\n}\n\nexport function parseExteriorOrInterior(\n  xml: any,\n  options: ParseGMLOptions,\n  context: ParseGMLContext\n): Position[] {\n  const linearRing = findIn(xml, 'gml:LinearRing');\n  if (linearRing) {\n    return parseLinearRingOrLineString(linearRing, options, context);\n  }\n\n  const ring = findIn(xml, 'gml:Ring');\n  if (!ring) {\n    throw new Error(`invalid ${xml.name} element`);\n  }\n\n  return parseRing(ring, options, context);\n}\n\nexport function parsePolygonOrRectangle(\n  xml: any,\n  options: ParseGMLOptions,\n  context: ParseGMLContext\n): Position[][] {\n  // or PolygonPatch\n  const childContext = createChildContext(xml, options, context);\n\n  const exterior = findIn(xml, 'gml:exterior');\n  if (!exterior) {\n    throw new Error(`invalid ${xml.name} element`);\n  }\n\n  const pointLists: Position[][] = [parseExteriorOrInterior(exterior, options, childContext)];\n\n  for (const [childName, childXML] of Object.entries(xml)) {\n    switch (childName) {\n      case 'gml:interior':\n        pointLists.push(parseExteriorOrInterior(childXML, options, childContext));\n        break;\n    }\n  }\n\n  return pointLists;\n}\n\nexport function parseSurface(\n  xml: any,\n  options: ParseGMLOptions,\n  context: ParseGMLContext\n): Position[][][] {\n  const childContext = createChildContext(xml, options, context);\n\n  const patches = findIn(xml, 'gml:patches');\n  if (!patches) {\n    throw new Error(`invalid ${xml.name} element`);\n  }\n\n  const polygons: Position[][][] = [];\n  for (const [childName, childXML] of Object.entries(xml)) {\n    switch (childName) {\n      case 'gml:PolygonPatch':\n      case 'gml:Rectangle':\n        polygons.push(parsePolygonOrRectangle(childXML, options, childContext));\n        break;\n\n      default:\n        continue;\n    }\n  }\n\n  if (polygons.length === 0) {\n    throw new Error(`${xml.name} must have > 0 polygons`);\n  }\n\n  return polygons;\n}\n\nexport function parseCompositeSurface(\n  xml: any,\n  options: ParseGMLOptions,\n  context: ParseGMLContext\n): Position[][][] {\n  const childContext = createChildContext(xml, options, context);\n\n  const polygons: Position[][][] = [];\n  for (const [childName, childXML] of Object.entries(xml)) {\n    switch (childName) {\n      case 'gml:surfaceMember':\n      case 'gml:surfaceMembers':\n        const [c2Name, c2Xml] = getFirstKeyValue(childXML);\n        switch (c2Name) {\n          case 'gml:Surface':\n            polygons.push(...parseSurface(c2Xml, options, childContext));\n            break;\n          case 'gml:Polygon':\n            polygons.push(parsePolygonOrRectangle(c2Xml, options, childContext));\n            break;\n        }\n        break;\n    }\n  }\n\n  if (polygons.length === 0) {\n    throw new Error(`${xml.name} must have > 0 polygons`);\n  }\n  return polygons;\n}\n\nexport function parseMultiSurface(\n  xml: any,\n  options: ParseGMLOptions,\n  context: ParseGMLContext\n): Position[][][] {\n  let el = xml;\n\n  const surfaceMembers = findIn(xml, 'gml:LinearRing');\n  if (surfaceMembers) {\n    el = surfaceMembers;\n  }\n\n  const polygons: Position[][][] = [];\n  for (const [childName, childXML] of Object.entries(el)) {\n    switch (childName) {\n      case 'gml:Surface':\n        const polygons2 = parseSurface(childXML, options, context);\n        polygons.push(...polygons2);\n        break;\n      case 'gml:surfaceMember':\n        const polygons3 = parseSurfaceMember(childXML, options, context);\n        polygons.push(...polygons3);\n        break;\n\n      case 'gml:surfaceMembers':\n        const polygonXML = findIn(childXML, 'gml:Polygon');\n        for (const surfaceMemberXML of polygonXML as []) {\n          const polygons3 = parseSurfaceMember(surfaceMemberXML, options, context);\n          polygons.push(...polygons3);\n        }\n        break;\n    }\n  }\n\n  if (polygons.length === 0) {\n    throw new Error(`${xml.name} must have > 0 polygons`);\n  }\n\n  return polygons;\n}\n\nfunction parseSurfaceMember(\n  xml: any,\n  options: ParseGMLOptions,\n  context: ParseGMLContext\n): Position[][][] {\n  const [childName, childXml] = getFirstKeyValue(xml);\n  switch (childName) {\n    case 'gml:CompositeSurface':\n      return parseCompositeSurface(childXml, options, context);\n    case 'gml:Surface':\n      return parseSurface(childXml, options, context);\n    case 'gml:Polygon':\n      return [parsePolygonOrRectangle(childXml, options, context)];\n  }\n  throw new Error(`${childName} must have polygons`);\n}\n\n// Helpers\n\nfunction textOf(el: any): string {\n  if (typeof el !== 'string') {\n    throw new Error('expected string');\n  }\n  return el;\n}\n\nfunction findIn(root: any, ...tags: string[]): any {\n  let el = root;\n  for (const tag of tags) {\n    const child = el[tag];\n    if (!child) {\n      return null;\n    }\n    el = child;\n  }\n  return el;\n}\n\n/** @returns the first [key, value] pair in an object, or ['', null] if empty object */\nfunction getFirstKeyValue(object: any): [string, any] {\n  if (object && typeof object === 'object') {\n    for (const [key, value] of Object.entries(object)) {\n      return [key, value];\n    }\n  }\n  return ['', null];\n}\n\n/** A bit heavyweight for just tracking dimension? */\nfunction createChildContext(xml, options, context): ParseGMLContext {\n  const srsDimensionAttribute = xml.attributes && xml.attributes.srsDimension;\n\n  if (srsDimensionAttribute) {\n    const srsDimension = parseInt(srsDimensionAttribute);\n    if (Number.isNaN(srsDimension) || srsDimension <= 0) {\n      throw new Error(\n        `invalid srsDimension attribute value \"${srsDimensionAttribute}\", expected a positive integer`\n      );\n    }\n\n    const childContext = Object.create(context);\n    childContext.srsDimension = srsDimension;\n    return childContext;\n  }\n\n  return context;\n}\n"],"mappings":"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"}