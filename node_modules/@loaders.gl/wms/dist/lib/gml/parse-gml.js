"use strict";
// loaders.gl, MIT license
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseMultiSurface = exports.parseCompositeSurface = exports.parseSurface = exports.parsePolygonOrRectangle = exports.parseExteriorOrInterior = exports.parseRing = exports.parseCurveSegments = exports.parseLinearRingOrLineString = exports.parsePoint = exports.parsePos = exports.parsePosList = exports.parseGMLToGeometry = exports.parseGML = void 0;
const xml_1 = require("@loaders.gl/xml");
const deep_strict_equal_1 = require("./deep-strict-equal");
const rewind_1 = __importDefault(require("@turf/rewind"));
function noTransform(...coords) {
    return coords;
}
/**
 * Parses a typed data structure from raw XML for GML features
 * @note Error handlings is fairly weak
 */
function parseGML(text, options) {
    // GeoJSON | null {
    const parsedXML = xml_1.XMLLoader.parseTextSync(text, options);
    options = { transformCoords: noTransform, stride: 2, ...options };
    const context = createChildContext(parsedXML, options, {});
    return parseGMLToGeometry(parsedXML, options, context);
}
exports.parseGML = parseGML;
/** Parse a GeoJSON geometry from GML XML */
function parseGMLToGeometry(inputXML, options, context) {
    const childContext = createChildContext(inputXML, options, context);
    let geometry = null;
    const [name, xml] = getFirstKeyValue(inputXML);
    switch (name) {
        // case 'gml:MultiPoint':
        //   geometry = {
        //     type: 'MultiPoint',
        //     coordinates: parseMultiPoint(xml, options, childContext)
        //   };
        //   break;
        case 'gml:LineString':
            geometry = {
                type: 'LineString',
                coordinates: parseLinearRingOrLineString(xml, options, childContext)
            };
            break;
        // case 'gml:MultiLineString':
        //   geometry = {
        //     type: 'MultiLineString',
        //     coordinates: parseMultiLineString(xml, options, childContext)
        //   };
        //   break;
        case 'gml:Polygon':
        case 'gml:Rectangle':
            geometry = {
                type: 'Polygon',
                coordinates: parsePolygonOrRectangle(xml, options, childContext)
            };
            break;
        case 'gml:Surface':
            geometry = {
                type: 'MultiPolygon',
                coordinates: parseSurface(xml, options, childContext)
            };
            break;
        case 'gml:MultiSurface':
            geometry = {
                type: 'MultiPolygon',
                coordinates: parseMultiSurface(xml, options, childContext)
            };
            break;
        default:
            return null;
    }
    // todo
    return (0, rewind_1.default)(geometry, { mutate: true });
}
exports.parseGMLToGeometry = parseGMLToGeometry;
/** Parse a list of coordinates from a string */
function parseCoords(s, options, context) {
    const stride = context.srsDimension || options.stride || 2;
    // Handle white space
    const coords = s.replace(/\s+/g, ' ').trim().split(' ');
    if (coords.length === 0 || coords.length % stride !== 0) {
        throw new Error(`invalid coordinates list (stride ${stride})`);
    }
    const points = [];
    for (let i = 0; i < coords.length - 1; i += stride) {
        const point = coords.slice(i, i + stride).map(parseFloat);
        points.push(options.transformCoords?.(...point) || point);
    }
    return points;
}
function parsePosList(xml, options, context) {
    const childContext = createChildContext(xml, options, context);
    const coords = textOf(xml);
    if (!coords) {
        throw new Error('invalid gml:posList element');
    }
    return parseCoords(coords, options, childContext);
}
exports.parsePosList = parsePosList;
function parsePos(xml, options, context) {
    const childContext = createChildContext(xml, options, context);
    const coords = textOf(xml);
    if (!coords) {
        throw new Error('invalid gml:pos element');
    }
    const points = parseCoords(coords, options, childContext);
    if (points.length !== 1) {
        throw new Error('gml:pos must have 1 point');
    }
    return points[0];
}
exports.parsePos = parsePos;
function parsePoint(xml, options, context) {
    const childContext = createChildContext(xml, options, context);
    // TODO AV: Parse other gml:Point options
    const pos = findIn(xml, 'gml:pos');
    if (!pos) {
        throw new Error('invalid gml:Point element, expected a gml:pos subelement');
    }
    return parsePos(pos, options, childContext);
}
exports.parsePoint = parsePoint;
function parseLinearRingOrLineString(xml, options, context) {
    // or a LineStringSegment
    const childContext = createChildContext(xml, options, context);
    let points = [];
    const posList = findIn(xml, 'gml:posList');
    if (posList) {
        points = parsePosList(posList, options, childContext);
    }
    else {
        for (const [childName, childXML] of Object.entries(xml)) {
            switch (childName) {
                case 'gml:Point':
                    points.push(parsePoint(childXML, options, childContext));
                    break;
                case 'gml:pos':
                    points.push(parsePos(childXML, options, childContext));
                    break;
                default:
                    continue;
            }
        }
    }
    if (points.length === 0) {
        throw new Error(`${xml.name} must have > 0 points`);
    }
    return points;
}
exports.parseLinearRingOrLineString = parseLinearRingOrLineString;
function parseCurveSegments(xml, options, context) {
    const points = [];
    for (const [childName, childXML] of Object.entries(xml)) {
        switch (childName) {
            case 'gml:LineStringSegment':
                const points2 = parseLinearRingOrLineString(childXML, options, context);
                // remove overlapping
                const end = points[points.length - 1];
                const start = points2[0];
                if (end && start && (0, deep_strict_equal_1.deepStrictEqual)(end, start)) {
                    points2.shift();
                }
                points.push(...points2);
                break;
            default:
                continue;
        }
    }
    if (points.length === 0) {
        throw new Error('gml:Curve > gml:segments must have > 0 points');
    }
    return points;
}
exports.parseCurveSegments = parseCurveSegments;
function parseRing(xml, options, context) {
    const childContext = createChildContext(xml, options, context);
    const points = [];
    for (const [childName, childXML] of Object.entries(xml)) {
        switch (childName) {
            case 'gml:curveMember':
                let points2;
                const lineString = findIn(childXML, 'gml:LineString');
                if (lineString) {
                    points2 = parseLinearRingOrLineString(lineString, options, childContext);
                }
                else {
                    const segments = findIn(childXML, 'gml:Curve', 'gml:segments');
                    if (!segments) {
                        throw new Error(`invalid ${childName} element`);
                    }
                    points2 = parseCurveSegments(segments, options, childContext);
                }
                // remove overlapping
                const end = points[points.length - 1];
                const start = points2[0];
                if (end && start && (0, deep_strict_equal_1.deepStrictEqual)(end, start)) {
                    points2.shift();
                }
                points.push(...points2);
                break;
        }
    }
    if (points.length < 4) {
        throw new Error(`${xml.name} must have >= 4 points`);
    }
    return points;
}
exports.parseRing = parseRing;
function parseExteriorOrInterior(xml, options, context) {
    const linearRing = findIn(xml, 'gml:LinearRing');
    if (linearRing) {
        return parseLinearRingOrLineString(linearRing, options, context);
    }
    const ring = findIn(xml, 'gml:Ring');
    if (!ring) {
        throw new Error(`invalid ${xml.name} element`);
    }
    return parseRing(ring, options, context);
}
exports.parseExteriorOrInterior = parseExteriorOrInterior;
function parsePolygonOrRectangle(xml, options, context) {
    // or PolygonPatch
    const childContext = createChildContext(xml, options, context);
    const exterior = findIn(xml, 'gml:exterior');
    if (!exterior) {
        throw new Error(`invalid ${xml.name} element`);
    }
    const pointLists = [parseExteriorOrInterior(exterior, options, childContext)];
    for (const [childName, childXML] of Object.entries(xml)) {
        switch (childName) {
            case 'gml:interior':
                pointLists.push(parseExteriorOrInterior(childXML, options, childContext));
                break;
        }
    }
    return pointLists;
}
exports.parsePolygonOrRectangle = parsePolygonOrRectangle;
function parseSurface(xml, options, context) {
    const childContext = createChildContext(xml, options, context);
    const patches = findIn(xml, 'gml:patches');
    if (!patches) {
        throw new Error(`invalid ${xml.name} element`);
    }
    const polygons = [];
    for (const [childName, childXML] of Object.entries(xml)) {
        switch (childName) {
            case 'gml:PolygonPatch':
            case 'gml:Rectangle':
                polygons.push(parsePolygonOrRectangle(childXML, options, childContext));
                break;
            default:
                continue;
        }
    }
    if (polygons.length === 0) {
        throw new Error(`${xml.name} must have > 0 polygons`);
    }
    return polygons;
}
exports.parseSurface = parseSurface;
function parseCompositeSurface(xml, options, context) {
    const childContext = createChildContext(xml, options, context);
    const polygons = [];
    for (const [childName, childXML] of Object.entries(xml)) {
        switch (childName) {
            case 'gml:surfaceMember':
            case 'gml:surfaceMembers':
                const [c2Name, c2Xml] = getFirstKeyValue(childXML);
                switch (c2Name) {
                    case 'gml:Surface':
                        polygons.push(...parseSurface(c2Xml, options, childContext));
                        break;
                    case 'gml:Polygon':
                        polygons.push(parsePolygonOrRectangle(c2Xml, options, childContext));
                        break;
                }
                break;
        }
    }
    if (polygons.length === 0) {
        throw new Error(`${xml.name} must have > 0 polygons`);
    }
    return polygons;
}
exports.parseCompositeSurface = parseCompositeSurface;
function parseMultiSurface(xml, options, context) {
    let el = xml;
    const surfaceMembers = findIn(xml, 'gml:LinearRing');
    if (surfaceMembers) {
        el = surfaceMembers;
    }
    const polygons = [];
    for (const [childName, childXML] of Object.entries(el)) {
        switch (childName) {
            case 'gml:Surface':
                const polygons2 = parseSurface(childXML, options, context);
                polygons.push(...polygons2);
                break;
            case 'gml:surfaceMember':
                const polygons3 = parseSurfaceMember(childXML, options, context);
                polygons.push(...polygons3);
                break;
            case 'gml:surfaceMembers':
                const polygonXML = findIn(childXML, 'gml:Polygon');
                for (const surfaceMemberXML of polygonXML) {
                    const polygons3 = parseSurfaceMember(surfaceMemberXML, options, context);
                    polygons.push(...polygons3);
                }
                break;
        }
    }
    if (polygons.length === 0) {
        throw new Error(`${xml.name} must have > 0 polygons`);
    }
    return polygons;
}
exports.parseMultiSurface = parseMultiSurface;
function parseSurfaceMember(xml, options, context) {
    const [childName, childXml] = getFirstKeyValue(xml);
    switch (childName) {
        case 'gml:CompositeSurface':
            return parseCompositeSurface(childXml, options, context);
        case 'gml:Surface':
            return parseSurface(childXml, options, context);
        case 'gml:Polygon':
            return [parsePolygonOrRectangle(childXml, options, context)];
    }
    throw new Error(`${childName} must have polygons`);
}
// Helpers
function textOf(el) {
    if (typeof el !== 'string') {
        throw new Error('expected string');
    }
    return el;
}
function findIn(root, ...tags) {
    let el = root;
    for (const tag of tags) {
        const child = el[tag];
        if (!child) {
            return null;
        }
        el = child;
    }
    return el;
}
/** @returns the first [key, value] pair in an object, or ['', null] if empty object */
function getFirstKeyValue(object) {
    if (object && typeof object === 'object') {
        for (const [key, value] of Object.entries(object)) {
            return [key, value];
        }
    }
    return ['', null];
}
/** A bit heavyweight for just tracking dimension? */
function createChildContext(xml, options, context) {
    const srsDimensionAttribute = xml.attributes && xml.attributes.srsDimension;
    if (srsDimensionAttribute) {
        const srsDimension = parseInt(srsDimensionAttribute);
        if (Number.isNaN(srsDimension) || srsDimension <= 0) {
            throw new Error(`invalid srsDimension attribute value "${srsDimensionAttribute}", expected a positive integer`);
        }
        const childContext = Object.create(context);
        childContext.srsDimension = srsDimension;
        return childContext;
    }
    return context;
}
