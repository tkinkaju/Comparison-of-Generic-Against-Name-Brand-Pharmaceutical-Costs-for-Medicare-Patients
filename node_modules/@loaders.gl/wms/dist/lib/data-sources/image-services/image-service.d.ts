import { LoaderOptions } from '@loaders.gl/loader-utils';
import type { ImageType } from '@loaders.gl/images';
import type { ImageSourceMetadata, GetImageParameters } from '../image-source';
import { ImageSource } from '../image-source';
/** Template URL string should contain `${width}` etc which will be substituted. */
export type ImageServiceProps = {
    /** Base URL to the service */
    url: string;
    /** Any load options to the loaders.gl Loaders used by the WMSService methods */
    loadOptions?: LoaderOptions;
};
/**
 * Quickly connect to "ad hoc" image sources without subclassing ImageSource.
 * ImageSource allows template url strings to be used to ad hoc connect to arbitrary image data sources
 * Accepts a template url string and builds requests URLs
 */
export declare class ImageService extends ImageSource {
    static type: 'template';
    static testURL: (url: string) => boolean;
    props: Required<ImageServiceProps>;
    fetch: (url: string, options?: RequestInit) => Promise<Response>;
    constructor(props: ImageServiceProps);
    getMetadata(): Promise<ImageSourceMetadata>;
    getImage(parameters: GetImageParameters): Promise<ImageType>;
    /** Break up bounding box in east, north, south, west */
    protected getGranularParameters(parameters: GetImageParameters): Record<string, unknown>;
    /** Supports both ${} and {} notations */
    protected getURLFromTemplate(parameters: Record<string, unknown>): string;
}
/**
 * Gets the current fetch function from options
 * @todo - move to loader-utils module
 * @todo - use in core module counterpart
 * @param options
 * @param context
 */
export declare function getFetchFunction(options?: LoaderOptions): (url: string, fetchOptions?: RequestInit) => Promise<Response>;
export declare function mergeImageServiceProps(props: ImageServiceProps): Required<ImageServiceProps>;
//# sourceMappingURL=image-service.d.ts.map