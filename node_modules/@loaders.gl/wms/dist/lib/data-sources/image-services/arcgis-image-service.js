"use strict";
// loaders.gl, MIT license
Object.defineProperty(exports, "__esModule", { value: true });
exports.ArcGISImageService = void 0;
const image_source_1 = require("../image-source");
const image_service_1 = require("./image-service");
class ArcGISImageService extends image_source_1.ImageSource {
    constructor(props) {
        super();
        this.props = (0, image_service_1.mergeImageServiceProps)(props);
        this.fetch = (0, image_service_1.getFetchFunction)(this.props);
    }
    // ImageSource (normalized endpoints)
    async getMetadata() {
        return (await this.info());
        // TODO - normalize metadata
    }
    async getImage(parameters) {
        throw new Error('not implemented');
        // TODO - Map generic parameters to ArcGIS specific parameters
        // return await this.exportImage(parameters);
    }
    // ImageServer endpoints
    async info() {
        // We just need a JSON parsing...
        // return this.getUrl({path: '', ...options});
        throw new Error('not implemented');
    }
    /**
     * Form a URL to an ESRI ImageServer
     // https://sampleserver6.arcgisonline.com/arcgis/rest/services/NLCDLandCover2001/ImageServer/exportImage?bbox=${bounds[0]},${bounds[1]},${bounds[2]},${bounds[3]}&bboxSR=4326&size=${width},${height}&imageSR=102100&time=&format=jpgpng&pixelType=U8&noData=&noDataInterpretation=esriNoDataMatchAny&interpolation=+RSP_NearestNeighbor&compression=&compressionQuality=&bandIds=&mosaicRule=&renderingRule=&f=image`,
     */
    exportImage(options) {
        // See WMSService.getMap()
        throw new Error('not implemented');
    }
    // URL creators
    infoURL(options) {
        return this.props.url;
        // return this.getUrl({path: '', ...options});
    }
    /**
     * Form a URL to an ESRI ImageServer
     // https://sampleserver6.arcgisonline.com/arcgis/rest/services/NLCDLandCover2001/ImageServer/exportImage?bbox=${bounds[0]},${bounds[1]},${bounds[2]},${bounds[3]}&bboxSR=4326&size=${width},${height}&imageSR=102100&time=&format=jpgpng&pixelType=U8&noData=&noDataInterpretation=esriNoDataMatchAny&interpolation=+RSP_NearestNeighbor&compression=&compressionQuality=&bandIds=&mosaicRule=&renderingRule=&f=image`,
     */
    exportImageURL(options) {
        // const {boundingBox} = options;
        // const bbox = `bbox=${boundingBox[0]},${boundingBox[1]},${boundingBox[2]},${boundingBox[3]}`;
        // const size = `size=${width},${height}`;
        // return this.getUrl({path: 'exportImage'});
        return this.props.url;
    }
    // INTERNAL METHODS
    /**
     * @note protected, since perhaps getWMSUrl may need to be overridden to handle certain backends?
     * @note if override is common, maybe add a callback prop?
     * */
    getUrl(options, extra) {
        let url = `${this.props.url}`;
        let first = true;
        for (const [key, value] of Object.entries(options)) {
            url += first ? '?' : '&';
            first = false;
            if (Array.isArray(value)) {
                url += `${key.toUpperCase()}=${value.join(',')}`;
            }
            else {
                url += `${key.toUpperCase()}=${value ? String(value) : ''}`;
            }
        }
        return url;
    }
    /** Checks for and parses a WMS XML formatted ServiceError and throws an exception */
    async checkResponse(response) {
        if (!response.ok) {
            // } || response.headers['content-type'] === WMSErrorLoader.mimeTypes[0]) {
            // const arrayBuffer = await response.arrayBuffer();
            // const error = await WMSErrorLoader.parse(arrayBuffer, this.loadOptions);
            throw new Error('error');
        }
    }
}
exports.ArcGISImageService = ArcGISImageService;
ArcGISImageService.type = 'arcgis-image-server';
ArcGISImageService.testURL = (url) => url.toLowerCase().includes('ImageServer');
