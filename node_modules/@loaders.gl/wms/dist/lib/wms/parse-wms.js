"use strict";
// loaders.gl, MIT license
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseWMSError = exports.parseWMSLayerDescription = exports.parseWMSFeatureInfo = exports.parseWMSCapabilities = void 0;
const xml_1 = require("@loaders.gl/xml");
// GetCapabilities
/**
 * Parses a typed data structure from raw XML for `GetCapabilities` response
 * @note Error handlings is fairly weak
 */
function parseWMSCapabilities(text, options) {
    const parsedXML = xml_1.XMLLoader.parseTextSync(text, options);
    const xmlCapabilities = parsedXML.WMT_MS_Capabilities || parsedXML.WMS_Capabilities || parsedXML;
    return extractCapabilities(xmlCapabilities);
}
exports.parseWMSCapabilities = parseWMSCapabilities;
/** Extract typed capability data from XML */
function extractCapabilities(xml) {
    const capabilities = {
        name: xml.Service?.Name || 'unnamed',
        title: xml.Service?.Title,
        keywords: [],
        requests: {},
        layer: extractLayer(xml.Capability?.Layer),
        raw: xml
    };
    for (const keyword of xml.Service?.KeywordList?.Keyword || []) {
        capabilities.keywords.push(keyword);
    }
    for (const [name, xmlRequest] of Object.entries(xml.Capability?.Request || {})) {
        capabilities.requests[name] = extractRequest(name, xmlRequest);
    }
    return capabilities;
}
/** Extract typed request data from XML */
function extractRequest(name, xmlRequest) {
    const format = xmlRequest?.Format;
    const mimeTypes = Array.isArray(format) ? format : [format];
    return { name, mimeTypes };
}
/** Extract request data */
function extractLayer(xmlLayer) {
    const layer = {
        name: xmlLayer?.Name,
        title: xmlLayer?.Title,
        srs: xmlLayer?.SRS || [],
        layers: []
    };
    // Single layer is not represented as array in XML
    const xmlLayers = getXMLArray(xmlLayer?.Layer);
    for (const xmlSubLayer of xmlLayers) {
        layer.layers?.push(extractLayer(xmlSubLayer));
    }
    return layer;
}
function getXMLArray(xmlValue) {
    if (Array.isArray(xmlValue)) {
        return xmlValue;
    }
    if (xmlValue) {
        return [xmlValue];
    }
    return [];
}
// GetFeatureInfo
/**
 * Parses a typed data structure from raw XML for `GetFeatureInfo` response
 * @note Error handlings is fairly weak
 */
function parseWMSFeatureInfo(text, options) {
    const parsedXML = xml_1.XMLLoader.parseTextSync(text, options);
    const xmlFeatureInfo = parsedXML.FeatureInfoResponse?.FIELDS || [];
    const xmlFeatures = Array.isArray(xmlFeatureInfo) ? xmlFeatureInfo : [xmlFeatureInfo];
    return {
        features: xmlFeatures.map((xmlFeature) => extractFeature(xmlFeature))
    };
}
exports.parseWMSFeatureInfo = parseWMSFeatureInfo;
function extractFeature(xmlFeature) {
    const xmlFields = xmlFeature || {};
    // TODO - not correct
    return {
        attributes: xmlFields,
        type: '',
        bounds: { bottom: 0, top: 0, left: 0, right: 0 }
    };
}
// GetFeatureInfo
/**
 * Parses a typed data structure from raw XML for `GetFeatureInfo` response
 * @note Error handlings is fairly weak
 */
function parseWMSLayerDescription(text, options) {
    const parsedXML = xml_1.XMLLoader.parseTextSync(text, options);
    // TODO - implement parser
    return parsedXML;
}
exports.parseWMSLayerDescription = parseWMSLayerDescription;
/**
 * Extract an error message from WMS error response XML
 * @param text
 * @param options
 * @returns a string with a human readable message
 */
function parseWMSError(text, options) {
    const parsedXML = xml_1.XMLLoader.parseTextSync?.(text, options);
    const serviceExceptionXML = parsedXML?.ServiceExceptionReport?.ServiceException ||
        parsedXML?.['ogc:ServiceExceptionReport']?.['ogc:ServiceException'];
    // Sigh, can be either a string or an object
    const message = typeof serviceExceptionXML === 'string'
        ? serviceExceptionXML
        : serviceExceptionXML['#text'] || serviceExceptionXML.code || 'Unknown error';
    return message;
}
exports.parseWMSError = parseWMSError;
