{"version":3,"file":"parse-gml.js","names":["noTransform","coords","parseGML","text","options","parsedXML","XMLLoader","parseTextSync","transformCoords","stride","context","createChildContext","parseGMLToGeometry","inputXML","childContext","geometry","getFirstKeyValue","name","xml","type","coordinates","parseLinearRingOrLineString","parsePolygonOrRectangle","parseSurface","parseMultiSurface","rewind","mutate","parseCoords","s","srsDimension","replace","trim","split","length","Error","points","i","point","slice","map","parseFloat","push","parsePosList","textOf","parsePos","parsePoint","pos","findIn","posList","Object","entries","childName","childXML","parseCurveSegments","points2","end","start","deepStrictEqual","shift","parseRing","lineString","segments","parseExteriorOrInterior","linearRing","ring","exterior","pointLists","patches","polygons","parseCompositeSurface","c2Name","c2Xml","el","surfaceMembers","polygons2","polygons3","parseSurfaceMember","polygonXML","surfaceMemberXML","childXml","root","tags","tag","child","object","key","value","srsDimensionAttribute","attributes","parseInt","Number","isNaN","create"],"sources":["../../../../src/lib/gml/parse-gml.ts"],"sourcesContent":["// loaders.gl, MIT license\n\n// Forked from https://github.com/derhuerst/parse-gml-polygon/blob/master/index.js\n// under ISC license\n\n/* eslint-disable no-continue, default-case */\n\nimport type {\n  // GeoJSON,\n  // Feature,\n  // FeatureCollection,\n  Geometry,\n  Position\n  // GeoJsonProperties,\n  // Point,\n  // MultiPoint,\n  // LineString,\n  // MultiLineString,\n  // Polygon,\n  // MultiPolygon,\n  // GeometryCollection\n} from '@loaders.gl/schema';\n\nimport {XMLLoader} from '@loaders.gl/xml';\nimport {deepStrictEqual} from './deep-strict-equal';\nimport rewind from '@turf/rewind';\n\nfunction noTransform(...coords) {\n  return coords;\n}\n\nexport type ParseGMLOptions = {\n  transformCoords?: Function;\n  stride?: 2 | 3 | 4;\n};\n\nexport type ParseGMLContext = {\n  srsDimension?: number;\n  [key: string]: any;\n};\n\n/**\n * Parses a typed data structure from raw XML for GML features\n * @note Error handlings is fairly weak\n */\nexport function parseGML(text: string, options) {\n  // GeoJSON | null {\n  const parsedXML = XMLLoader.parseTextSync(text, options);\n\n  options = {transformCoords: noTransform, stride: 2, ...options};\n  const context = createChildContext(parsedXML, options, {});\n\n  return parseGMLToGeometry(parsedXML, options, context);\n}\n\n/** Parse a GeoJSON geometry from GML XML */\nexport function parseGMLToGeometry(\n  inputXML: any,\n  options: ParseGMLOptions,\n  context: ParseGMLContext\n): Geometry | null {\n  const childContext = createChildContext(inputXML, options, context);\n\n  let geometry: Geometry | null = null;\n\n  const [name, xml] = getFirstKeyValue(inputXML);\n\n  switch (name) {\n    // case 'gml:MultiPoint':\n    //   geometry = {\n    //     type: 'MultiPoint',\n    //     coordinates: parseMultiPoint(xml, options, childContext)\n    //   };\n    //   break;\n\n    case 'gml:LineString':\n      geometry = {\n        type: 'LineString',\n        coordinates: parseLinearRingOrLineString(xml, options, childContext)\n      };\n      break;\n\n      // case 'gml:MultiLineString':\n      //   geometry = {\n      //     type: 'MultiLineString',\n      //     coordinates: parseMultiLineString(xml, options, childContext)\n      //   };\n      //   break;\n\n    case 'gml:Polygon':\n    case 'gml:Rectangle':\n      geometry = {\n        type: 'Polygon',\n        coordinates: parsePolygonOrRectangle(xml, options, childContext)\n      };\n      break;\n    case 'gml:Surface':\n      geometry = {\n        type: 'MultiPolygon',\n        coordinates: parseSurface(xml, options, childContext)\n      };\n      break;\n    case 'gml:MultiSurface':\n      geometry = {\n        type: 'MultiPolygon',\n        coordinates: parseMultiSurface(xml, options, childContext)\n      };\n      break;\n\n    default:\n      return null;\n  }\n\n  // todo\n  return rewind(geometry, {mutate: true});\n}\n\n/** Parse a list of coordinates from a string */\nfunction parseCoords(s: string, options: ParseGMLOptions, context: ParseGMLContext): Position[] {\n  const stride = context.srsDimension || options.stride || 2;\n\n  // Handle white space\n  const coords = s.replace(/\\s+/g, ' ').trim().split(' ');\n\n  if (coords.length === 0 || coords.length % stride !== 0) {\n    throw new Error(`invalid coordinates list (stride ${stride})`);\n  }\n\n  const points: Position[] = [];\n  for (let i = 0; i < coords.length - 1; i += stride) {\n    const point = coords.slice(i, i + stride).map(parseFloat);\n    points.push(options.transformCoords?.(...point) || point);\n  }\n\n  return points;\n}\n\nexport function parsePosList(xml: any, options: ParseGMLOptions, context: ParseGMLContext) {\n  const childContext = createChildContext(xml, options, context);\n\n  const coords = textOf(xml);\n  if (!coords) {\n    throw new Error('invalid gml:posList element');\n  }\n\n  return parseCoords(coords, options, childContext);\n}\n\nexport function parsePos(xml: any, options: ParseGMLOptions, context: ParseGMLContext): Position {\n  const childContext = createChildContext(xml, options, context);\n\n  const coords = textOf(xml);\n  if (!coords) {\n    throw new Error('invalid gml:pos element');\n  }\n\n  const points = parseCoords(coords, options, childContext);\n  if (points.length !== 1) {\n    throw new Error('gml:pos must have 1 point');\n  }\n  return points[0];\n}\n\nexport function parsePoint(xml: any, options: ParseGMLOptions, context: ParseGMLContext): number[] {\n  const childContext = createChildContext(xml, options, context);\n\n  // TODO AV: Parse other gml:Point options\n  const pos = findIn(xml, 'gml:pos');\n  if (!pos) {\n    throw new Error('invalid gml:Point element, expected a gml:pos subelement');\n  }\n  return parsePos(pos, options, childContext);\n}\n\nexport function parseLinearRingOrLineString(\n  xml: any,\n  options: ParseGMLOptions,\n  context: ParseGMLContext\n): Position[] {\n  // or a LineStringSegment\n  const childContext = createChildContext(xml, options, context);\n\n  let points: Position[] = [];\n\n  const posList = findIn(xml, 'gml:posList');\n  if (posList) {\n    points = parsePosList(posList, options, childContext);\n  } else {\n    for (const [childName, childXML] of Object.entries(xml)) {\n      switch (childName) {\n        case 'gml:Point':\n          points.push(parsePoint(childXML, options, childContext));\n          break;\n        case 'gml:pos':\n          points.push(parsePos(childXML, options, childContext));\n          break;\n        default:\n          continue;\n      }\n    }\n  }\n\n  if (points.length === 0) {\n    throw new Error(`${xml.name} must have > 0 points`);\n  }\n  return points;\n}\n\nexport function parseCurveSegments(\n  xml: any,\n  options: ParseGMLOptions,\n  context: ParseGMLContext\n): Position[] {\n  const points: Position[] = [];\n\n  for (const [childName, childXML] of Object.entries(xml)) {\n    switch (childName) {\n      case 'gml:LineStringSegment':\n        const points2 = parseLinearRingOrLineString(childXML, options, context);\n\n        // remove overlapping\n        const end = points[points.length - 1];\n        const start = points2[0];\n        if (end && start && deepStrictEqual(end, start)) {\n          points2.shift();\n        }\n\n        points.push(...points2);\n        break;\n      default:\n        continue;\n    }\n  }\n\n  if (points.length === 0) {\n    throw new Error('gml:Curve > gml:segments must have > 0 points');\n  }\n  return points;\n}\n\nexport function parseRing(\n  xml: any,\n  options: ParseGMLOptions,\n  context: ParseGMLContext\n): Position[] {\n  const childContext = createChildContext(xml, options, context);\n\n  const points: Position[] = [];\n\n  for (const [childName, childXML] of Object.entries(xml)) {\n    switch (childName) {\n      case 'gml:curveMember':\n        let points2;\n\n        const lineString = findIn(childXML, 'gml:LineString');\n        if (lineString) {\n          points2 = parseLinearRingOrLineString(lineString, options, childContext);\n        } else {\n          const segments = findIn(childXML, 'gml:Curve', 'gml:segments');\n          if (!segments) {\n            throw new Error(`invalid ${childName} element`);\n          }\n\n          points2 = parseCurveSegments(segments, options, childContext);\n        }\n\n        // remove overlapping\n        const end = points[points.length - 1];\n        const start = points2[0];\n        if (end && start && deepStrictEqual(end, start)) {\n          points2.shift();\n        }\n\n        points.push(...points2);\n\n        break;\n    }\n  }\n\n  if (points.length < 4) {\n    throw new Error(`${xml.name} must have >= 4 points`);\n  }\n  return points;\n}\n\nexport function parseExteriorOrInterior(\n  xml: any,\n  options: ParseGMLOptions,\n  context: ParseGMLContext\n): Position[] {\n  const linearRing = findIn(xml, 'gml:LinearRing');\n  if (linearRing) {\n    return parseLinearRingOrLineString(linearRing, options, context);\n  }\n\n  const ring = findIn(xml, 'gml:Ring');\n  if (!ring) {\n    throw new Error(`invalid ${xml.name} element`);\n  }\n\n  return parseRing(ring, options, context);\n}\n\nexport function parsePolygonOrRectangle(\n  xml: any,\n  options: ParseGMLOptions,\n  context: ParseGMLContext\n): Position[][] {\n  // or PolygonPatch\n  const childContext = createChildContext(xml, options, context);\n\n  const exterior = findIn(xml, 'gml:exterior');\n  if (!exterior) {\n    throw new Error(`invalid ${xml.name} element`);\n  }\n\n  const pointLists: Position[][] = [parseExteriorOrInterior(exterior, options, childContext)];\n\n  for (const [childName, childXML] of Object.entries(xml)) {\n    switch (childName) {\n      case 'gml:interior':\n        pointLists.push(parseExteriorOrInterior(childXML, options, childContext));\n        break;\n    }\n  }\n\n  return pointLists;\n}\n\nexport function parseSurface(\n  xml: any,\n  options: ParseGMLOptions,\n  context: ParseGMLContext\n): Position[][][] {\n  const childContext = createChildContext(xml, options, context);\n\n  const patches = findIn(xml, 'gml:patches');\n  if (!patches) {\n    throw new Error(`invalid ${xml.name} element`);\n  }\n\n  const polygons: Position[][][] = [];\n  for (const [childName, childXML] of Object.entries(xml)) {\n    switch (childName) {\n      case 'gml:PolygonPatch':\n      case 'gml:Rectangle':\n        polygons.push(parsePolygonOrRectangle(childXML, options, childContext));\n        break;\n\n      default:\n        continue;\n    }\n  }\n\n  if (polygons.length === 0) {\n    throw new Error(`${xml.name} must have > 0 polygons`);\n  }\n\n  return polygons;\n}\n\nexport function parseCompositeSurface(\n  xml: any,\n  options: ParseGMLOptions,\n  context: ParseGMLContext\n): Position[][][] {\n  const childContext = createChildContext(xml, options, context);\n\n  const polygons: Position[][][] = [];\n  for (const [childName, childXML] of Object.entries(xml)) {\n    switch (childName) {\n      case 'gml:surfaceMember':\n      case 'gml:surfaceMembers':\n        const [c2Name, c2Xml] = getFirstKeyValue(childXML);\n        switch (c2Name) {\n          case 'gml:Surface':\n            polygons.push(...parseSurface(c2Xml, options, childContext));\n            break;\n          case 'gml:Polygon':\n            polygons.push(parsePolygonOrRectangle(c2Xml, options, childContext));\n            break;\n        }\n        break;\n    }\n  }\n\n  if (polygons.length === 0) {\n    throw new Error(`${xml.name} must have > 0 polygons`);\n  }\n  return polygons;\n}\n\nexport function parseMultiSurface(\n  xml: any,\n  options: ParseGMLOptions,\n  context: ParseGMLContext\n): Position[][][] {\n  let el = xml;\n\n  const surfaceMembers = findIn(xml, 'gml:LinearRing');\n  if (surfaceMembers) {\n    el = surfaceMembers;\n  }\n\n  const polygons: Position[][][] = [];\n  for (const [childName, childXML] of Object.entries(el)) {\n    switch (childName) {\n      case 'gml:Surface':\n        const polygons2 = parseSurface(childXML, options, context);\n        polygons.push(...polygons2);\n        break;\n      case 'gml:surfaceMember':\n        const polygons3 = parseSurfaceMember(childXML, options, context);\n        polygons.push(...polygons3);\n        break;\n\n      case 'gml:surfaceMembers':\n        const polygonXML = findIn(childXML, 'gml:Polygon');\n        for (const surfaceMemberXML of polygonXML as []) {\n          const polygons3 = parseSurfaceMember(surfaceMemberXML, options, context);\n          polygons.push(...polygons3);\n        }\n        break;\n    }\n  }\n\n  if (polygons.length === 0) {\n    throw new Error(`${xml.name} must have > 0 polygons`);\n  }\n\n  return polygons;\n}\n\nfunction parseSurfaceMember(\n  xml: any,\n  options: ParseGMLOptions,\n  context: ParseGMLContext\n): Position[][][] {\n  const [childName, childXml] = getFirstKeyValue(xml);\n  switch (childName) {\n    case 'gml:CompositeSurface':\n      return parseCompositeSurface(childXml, options, context);\n    case 'gml:Surface':\n      return parseSurface(childXml, options, context);\n    case 'gml:Polygon':\n      return [parsePolygonOrRectangle(childXml, options, context)];\n  }\n  throw new Error(`${childName} must have polygons`);\n}\n\n// Helpers\n\nfunction textOf(el: any): string {\n  if (typeof el !== 'string') {\n    throw new Error('expected string');\n  }\n  return el;\n}\n\nfunction findIn(root: any, ...tags: string[]): any {\n  let el = root;\n  for (const tag of tags) {\n    const child = el[tag];\n    if (!child) {\n      return null;\n    }\n    el = child;\n  }\n  return el;\n}\n\n/** @returns the first [key, value] pair in an object, or ['', null] if empty object */\nfunction getFirstKeyValue(object: any): [string, any] {\n  if (object && typeof object === 'object') {\n    for (const [key, value] of Object.entries(object)) {\n      return [key, value];\n    }\n  }\n  return ['', null];\n}\n\n/** A bit heavyweight for just tracking dimension? */\nfunction createChildContext(xml, options, context): ParseGMLContext {\n  const srsDimensionAttribute = xml.attributes && xml.attributes.srsDimension;\n\n  if (srsDimensionAttribute) {\n    const srsDimension = parseInt(srsDimensionAttribute);\n    if (Number.isNaN(srsDimension) || srsDimension <= 0) {\n      throw new Error(\n        `invalid srsDimension attribute value \"${srsDimensionAttribute}\", expected a positive integer`\n      );\n    }\n\n    const childContext = Object.create(context);\n    childContext.srsDimension = srsDimension;\n    return childContext;\n  }\n\n  return context;\n}\n"],"mappings":"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"}