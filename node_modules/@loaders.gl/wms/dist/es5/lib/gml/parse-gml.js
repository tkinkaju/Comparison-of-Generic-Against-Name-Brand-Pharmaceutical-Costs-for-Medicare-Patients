"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseCompositeSurface = parseCompositeSurface;
exports.parseCurveSegments = parseCurveSegments;
exports.parseExteriorOrInterior = parseExteriorOrInterior;
exports.parseGML = parseGML;
exports.parseGMLToGeometry = parseGMLToGeometry;
exports.parseLinearRingOrLineString = parseLinearRingOrLineString;
exports.parseMultiSurface = parseMultiSurface;
exports.parsePoint = parsePoint;
exports.parsePolygonOrRectangle = parsePolygonOrRectangle;
exports.parsePos = parsePos;
exports.parsePosList = parsePosList;
exports.parseRing = parseRing;
exports.parseSurface = parseSurface;
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _xml = require("@loaders.gl/xml");
var _deepStrictEqual = require("./deep-strict-equal");
var _rewind = _interopRequireDefault(require("@turf/rewind"));
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function noTransform() {
  for (var _len = arguments.length, coords = new Array(_len), _key = 0; _key < _len; _key++) {
    coords[_key] = arguments[_key];
  }
  return coords;
}
function parseGML(text, options) {
  var parsedXML = _xml.XMLLoader.parseTextSync(text, options);
  options = _objectSpread({
    transformCoords: noTransform,
    stride: 2
  }, options);
  var context = createChildContext(parsedXML, options, {});
  return parseGMLToGeometry(parsedXML, options, context);
}

function parseGMLToGeometry(inputXML, options, context) {
  var childContext = createChildContext(inputXML, options, context);
  var geometry = null;
  var _getFirstKeyValue = getFirstKeyValue(inputXML),
    _getFirstKeyValue2 = (0, _slicedToArray2.default)(_getFirstKeyValue, 2),
    name = _getFirstKeyValue2[0],
    xml = _getFirstKeyValue2[1];
  switch (name) {

    case 'gml:LineString':
      geometry = {
        type: 'LineString',
        coordinates: parseLinearRingOrLineString(xml, options, childContext)
      };
      break;

    case 'gml:Polygon':
    case 'gml:Rectangle':
      geometry = {
        type: 'Polygon',
        coordinates: parsePolygonOrRectangle(xml, options, childContext)
      };
      break;
    case 'gml:Surface':
      geometry = {
        type: 'MultiPolygon',
        coordinates: parseSurface(xml, options, childContext)
      };
      break;
    case 'gml:MultiSurface':
      geometry = {
        type: 'MultiPolygon',
        coordinates: parseMultiSurface(xml, options, childContext)
      };
      break;
    default:
      return null;
  }

  return (0, _rewind.default)(geometry, {
    mutate: true
  });
}

function parseCoords(s, options, context) {
  var stride = context.srsDimension || options.stride || 2;

  var coords = s.replace(/\s+/g, ' ').trim().split(' ');
  if (coords.length === 0 || coords.length % stride !== 0) {
    throw new Error("invalid coordinates list (stride ".concat(stride, ")"));
  }
  var points = [];
  for (var i = 0; i < coords.length - 1; i += stride) {
    var _options$transformCoo, _options$transformCoo2;
    var point = coords.slice(i, i + stride).map(parseFloat);
    points.push(((_options$transformCoo = options.transformCoords) === null || _options$transformCoo === void 0 ? void 0 : (_options$transformCoo2 = _options$transformCoo).call.apply(_options$transformCoo2, [options].concat((0, _toConsumableArray2.default)(point)))) || point);
  }
  return points;
}
function parsePosList(xml, options, context) {
  var childContext = createChildContext(xml, options, context);
  var coords = textOf(xml);
  if (!coords) {
    throw new Error('invalid gml:posList element');
  }
  return parseCoords(coords, options, childContext);
}
function parsePos(xml, options, context) {
  var childContext = createChildContext(xml, options, context);
  var coords = textOf(xml);
  if (!coords) {
    throw new Error('invalid gml:pos element');
  }
  var points = parseCoords(coords, options, childContext);
  if (points.length !== 1) {
    throw new Error('gml:pos must have 1 point');
  }
  return points[0];
}
function parsePoint(xml, options, context) {
  var childContext = createChildContext(xml, options, context);

  var pos = findIn(xml, 'gml:pos');
  if (!pos) {
    throw new Error('invalid gml:Point element, expected a gml:pos subelement');
  }
  return parsePos(pos, options, childContext);
}
function parseLinearRingOrLineString(xml, options, context) {
  var childContext = createChildContext(xml, options, context);
  var points = [];
  var posList = findIn(xml, 'gml:posList');
  if (posList) {
    points = parsePosList(posList, options, childContext);
  } else {
    for (var _i = 0, _Object$entries = Object.entries(xml); _i < _Object$entries.length; _i++) {
      var _Object$entries$_i = (0, _slicedToArray2.default)(_Object$entries[_i], 2),
        childName = _Object$entries$_i[0],
        childXML = _Object$entries$_i[1];
      switch (childName) {
        case 'gml:Point':
          points.push(parsePoint(childXML, options, childContext));
          break;
        case 'gml:pos':
          points.push(parsePos(childXML, options, childContext));
          break;
        default:
          continue;
      }
    }
  }
  if (points.length === 0) {
    throw new Error("".concat(xml.name, " must have > 0 points"));
  }
  return points;
}
function parseCurveSegments(xml, options, context) {
  var points = [];
  for (var _i2 = 0, _Object$entries2 = Object.entries(xml); _i2 < _Object$entries2.length; _i2++) {
    var _Object$entries2$_i = (0, _slicedToArray2.default)(_Object$entries2[_i2], 2),
      childName = _Object$entries2$_i[0],
      childXML = _Object$entries2$_i[1];
    switch (childName) {
      case 'gml:LineStringSegment':
        var points2 = parseLinearRingOrLineString(childXML, options, context);

        var end = points[points.length - 1];
        var start = points2[0];
        if (end && start && (0, _deepStrictEqual.deepStrictEqual)(end, start)) {
          points2.shift();
        }
        points.push.apply(points, (0, _toConsumableArray2.default)(points2));
        break;
      default:
        continue;
    }
  }
  if (points.length === 0) {
    throw new Error('gml:Curve > gml:segments must have > 0 points');
  }
  return points;
}
function parseRing(xml, options, context) {
  var childContext = createChildContext(xml, options, context);
  var points = [];
  for (var _i3 = 0, _Object$entries3 = Object.entries(xml); _i3 < _Object$entries3.length; _i3++) {
    var _Object$entries3$_i = (0, _slicedToArray2.default)(_Object$entries3[_i3], 2),
      childName = _Object$entries3$_i[0],
      childXML = _Object$entries3$_i[1];
    switch (childName) {
      case 'gml:curveMember':
        var points2 = void 0;
        var lineString = findIn(childXML, 'gml:LineString');
        if (lineString) {
          points2 = parseLinearRingOrLineString(lineString, options, childContext);
        } else {
          var segments = findIn(childXML, 'gml:Curve', 'gml:segments');
          if (!segments) {
            throw new Error("invalid ".concat(childName, " element"));
          }
          points2 = parseCurveSegments(segments, options, childContext);
        }

        var end = points[points.length - 1];
        var start = points2[0];
        if (end && start && (0, _deepStrictEqual.deepStrictEqual)(end, start)) {
          points2.shift();
        }
        points.push.apply(points, (0, _toConsumableArray2.default)(points2));
        break;
    }
  }
  if (points.length < 4) {
    throw new Error("".concat(xml.name, " must have >= 4 points"));
  }
  return points;
}
function parseExteriorOrInterior(xml, options, context) {
  var linearRing = findIn(xml, 'gml:LinearRing');
  if (linearRing) {
    return parseLinearRingOrLineString(linearRing, options, context);
  }
  var ring = findIn(xml, 'gml:Ring');
  if (!ring) {
    throw new Error("invalid ".concat(xml.name, " element"));
  }
  return parseRing(ring, options, context);
}
function parsePolygonOrRectangle(xml, options, context) {
  var childContext = createChildContext(xml, options, context);
  var exterior = findIn(xml, 'gml:exterior');
  if (!exterior) {
    throw new Error("invalid ".concat(xml.name, " element"));
  }
  var pointLists = [parseExteriorOrInterior(exterior, options, childContext)];
  for (var _i4 = 0, _Object$entries4 = Object.entries(xml); _i4 < _Object$entries4.length; _i4++) {
    var _Object$entries4$_i = (0, _slicedToArray2.default)(_Object$entries4[_i4], 2),
      childName = _Object$entries4$_i[0],
      childXML = _Object$entries4$_i[1];
    switch (childName) {
      case 'gml:interior':
        pointLists.push(parseExteriorOrInterior(childXML, options, childContext));
        break;
    }
  }
  return pointLists;
}
function parseSurface(xml, options, context) {
  var childContext = createChildContext(xml, options, context);
  var patches = findIn(xml, 'gml:patches');
  if (!patches) {
    throw new Error("invalid ".concat(xml.name, " element"));
  }
  var polygons = [];
  for (var _i5 = 0, _Object$entries5 = Object.entries(xml); _i5 < _Object$entries5.length; _i5++) {
    var _Object$entries5$_i = (0, _slicedToArray2.default)(_Object$entries5[_i5], 2),
      childName = _Object$entries5$_i[0],
      childXML = _Object$entries5$_i[1];
    switch (childName) {
      case 'gml:PolygonPatch':
      case 'gml:Rectangle':
        polygons.push(parsePolygonOrRectangle(childXML, options, childContext));
        break;
      default:
        continue;
    }
  }
  if (polygons.length === 0) {
    throw new Error("".concat(xml.name, " must have > 0 polygons"));
  }
  return polygons;
}
function parseCompositeSurface(xml, options, context) {
  var childContext = createChildContext(xml, options, context);
  var polygons = [];
  for (var _i6 = 0, _Object$entries6 = Object.entries(xml); _i6 < _Object$entries6.length; _i6++) {
    var _Object$entries6$_i = (0, _slicedToArray2.default)(_Object$entries6[_i6], 2),
      childName = _Object$entries6$_i[0],
      childXML = _Object$entries6$_i[1];
    switch (childName) {
      case 'gml:surfaceMember':
      case 'gml:surfaceMembers':
        var _getFirstKeyValue3 = getFirstKeyValue(childXML),
          _getFirstKeyValue4 = (0, _slicedToArray2.default)(_getFirstKeyValue3, 2),
          c2Name = _getFirstKeyValue4[0],
          c2Xml = _getFirstKeyValue4[1];
        switch (c2Name) {
          case 'gml:Surface':
            polygons.push.apply(polygons, (0, _toConsumableArray2.default)(parseSurface(c2Xml, options, childContext)));
            break;
          case 'gml:Polygon':
            polygons.push(parsePolygonOrRectangle(c2Xml, options, childContext));
            break;
        }
        break;
    }
  }
  if (polygons.length === 0) {
    throw new Error("".concat(xml.name, " must have > 0 polygons"));
  }
  return polygons;
}
function parseMultiSurface(xml, options, context) {
  var el = xml;
  var surfaceMembers = findIn(xml, 'gml:LinearRing');
  if (surfaceMembers) {
    el = surfaceMembers;
  }
  var polygons = [];
  for (var _i7 = 0, _Object$entries7 = Object.entries(el); _i7 < _Object$entries7.length; _i7++) {
    var _Object$entries7$_i = (0, _slicedToArray2.default)(_Object$entries7[_i7], 2),
      childName = _Object$entries7$_i[0],
      childXML = _Object$entries7$_i[1];
    switch (childName) {
      case 'gml:Surface':
        var polygons2 = parseSurface(childXML, options, context);
        polygons.push.apply(polygons, (0, _toConsumableArray2.default)(polygons2));
        break;
      case 'gml:surfaceMember':
        var polygons3 = parseSurfaceMember(childXML, options, context);
        polygons.push.apply(polygons, polygons3);
        break;
      case 'gml:surfaceMembers':
        var polygonXML = findIn(childXML, 'gml:Polygon');
        var _iterator = _createForOfIteratorHelper(polygonXML),
          _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var surfaceMemberXML = _step.value;
            var _polygons = parseSurfaceMember(surfaceMemberXML, options, context);
            polygons.push.apply(polygons, _polygons);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        break;
    }
  }
  if (polygons.length === 0) {
    throw new Error("".concat(xml.name, " must have > 0 polygons"));
  }
  return polygons;
}
function parseSurfaceMember(xml, options, context) {
  var _getFirstKeyValue5 = getFirstKeyValue(xml),
    _getFirstKeyValue6 = (0, _slicedToArray2.default)(_getFirstKeyValue5, 2),
    childName = _getFirstKeyValue6[0],
    childXml = _getFirstKeyValue6[1];
  switch (childName) {
    case 'gml:CompositeSurface':
      return parseCompositeSurface(childXml, options, context);
    case 'gml:Surface':
      return parseSurface(childXml, options, context);
    case 'gml:Polygon':
      return [parsePolygonOrRectangle(childXml, options, context)];
  }
  throw new Error("".concat(childName, " must have polygons"));
}

function textOf(el) {
  if (typeof el !== 'string') {
    throw new Error('expected string');
  }
  return el;
}
function findIn(root) {
  var el = root;
  for (var _len2 = arguments.length, tags = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    tags[_key2 - 1] = arguments[_key2];
  }
  for (var _i8 = 0, _tags = tags; _i8 < _tags.length; _i8++) {
    var tag = _tags[_i8];
    var child = el[tag];
    if (!child) {
      return null;
    }
    el = child;
  }
  return el;
}

function getFirstKeyValue(object) {
  if (object && (0, _typeof2.default)(object) === 'object') {
    for (var _i9 = 0, _Object$entries8 = Object.entries(object); _i9 < _Object$entries8.length; _i9++) {
      var _Object$entries8$_i = (0, _slicedToArray2.default)(_Object$entries8[_i9], 2),
        _key3 = _Object$entries8$_i[0],
        value = _Object$entries8$_i[1];
      return [_key3, value];
    }
  }
  return ['', null];
}

function createChildContext(xml, options, context) {
  var srsDimensionAttribute = xml.attributes && xml.attributes.srsDimension;
  if (srsDimensionAttribute) {
    var srsDimension = parseInt(srsDimensionAttribute);
    if (Number.isNaN(srsDimension) || srsDimension <= 0) {
      throw new Error("invalid srsDimension attribute value \"".concat(srsDimensionAttribute, "\", expected a positive integer"));
    }
    var childContext = Object.create(context);
    childContext.srsDimension = srsDimension;
    return childContext;
  }
  return context;
}
//# sourceMappingURL=parse-gml.js.map