{"version":3,"file":"async-deep-map.js","names":["isObject","value","asyncDeepMap","tree","func","options","mapSubtree","object","Array","isArray","mapArray","mapObject","url","promises","values","key","promise","then","push","Promise","all","urlArray","map"],"sources":["../../../../src/lib/texture-api/async-deep-map.ts"],"sourcesContent":["// loaders.gl, MIT license\n/*\nAsynchronously maps a deep structure of values (e.g. objects and arrays of urls).\n\nE.g. a mipmapped cubemap\n{\n  [CUBE_FACE_FRONT]: [\n    \"image-front-0.jpg\",\n    \"image-front-1.jpg\",\n    \"image-front-2.jpg\",\n  ],\n  [CUBE_MAP_BACK]: [\n    ...\n  ]\n}\n*/\nexport type Options = Record<string, any>;\nexport type Func = (url: string, options: Options) => unknown;\n\nconst isObject = (value: any): boolean => value && typeof value === 'object';\n\n// Loads a deep structure of urls (objects and arrays of urls)\n// Returns an object with six key-value pairs containing the images (or image mip arrays)\n// for each cube face\nexport async function asyncDeepMap(tree: unknown, func: Func, options: Options = {}) {\n  return await mapSubtree(tree, func, options);\n}\n\nexport async function mapSubtree(object: unknown, func: Func, options: Options) {\n  if (Array.isArray(object)) {\n    return await mapArray(object, func, options);\n  }\n\n  if (isObject(object)) {\n    return await mapObject(object as object, func, options);\n  }\n\n  // TODO - ignore non-urls, non-arraybuffers?\n  const url = object as string;\n  return await func(url, options);\n}\n\n// HELPERS\n\nasync function mapObject(\n  object: Record<string, any>,\n  func: Func,\n  options: Options\n): Promise<Record<string, any>> {\n  const promises: Promise<any>[] = [];\n  const values: Record<string, any> = {};\n\n  for (const key in object) {\n    const url = object[key];\n    const promise = mapSubtree(url, func, options).then((value) => {\n      values[key] = value;\n    });\n    promises.push(promise);\n  }\n\n  await Promise.all(promises);\n\n  return values;\n}\n\nasync function mapArray(urlArray: string[], func: Func, options = {}): Promise<any[]> {\n  const promises = urlArray.map((url) => mapSubtree(url, func, options));\n  return await Promise.all(promises);\n}\n"],"mappings":";;;;;;;;;;;;AAmBA,IAAMA,QAAQ,GAAG,SAAXA,QAAQ,CAAIC,KAAU;EAAA,OAAcA,KAAK,IAAI,sBAAOA,KAAK,MAAK,QAAQ;AAAA;;AAAC,SAKvDC,YAAY;EAAA;AAAA;AAAA;EAAA,0EAA3B,iBAA4BC,IAAa,EAAEC,IAAU;IAAA;MAAA;IAAA;MAAA;QAAA;UAAA;YAAEC,OAAgB,2DAAG,CAAC,CAAC;YAAA;YAAA,OACpEC,UAAU,CAACH,IAAI,EAAEC,IAAI,EAAEC,OAAO,CAAC;UAAA;YAAA;UAAA;UAAA;YAAA;QAAA;MAAA;IAAA;EAAA,CAC7C;EAAA;AAAA;AAAA,SAEqBC,UAAU;EAAA;AAAA;AAAA;EAAA,wEAAzB,kBAA0BC,MAAe,EAAEH,IAAU,EAAEC,OAAgB;IAAA;IAAA;MAAA;QAAA;UAAA;YAAA,KACxEG,KAAK,CAACC,OAAO,CAACF,MAAM,CAAC;cAAA;cAAA;YAAA;YAAA;YAAA,OACVG,QAAQ,CAACH,MAAM,EAAEH,IAAI,EAAEC,OAAO,CAAC;UAAA;YAAA;UAAA;YAAA,KAG1CL,QAAQ,CAACO,MAAM,CAAC;cAAA;cAAA;YAAA;YAAA;YAAA,OACLI,SAAS,CAACJ,MAAM,EAAYH,IAAI,EAAEC,OAAO,CAAC;UAAA;YAAA;UAAA;YAInDO,GAAG,GAAGL,MAAM;YAAA;YAAA,OACLH,IAAI,CAACQ,GAAG,EAAEP,OAAO,CAAC;UAAA;YAAA;UAAA;UAAA;YAAA;QAAA;MAAA;IAAA;EAAA,CAChC;EAAA;AAAA;AAAA,SAIcM,SAAS;EAAA;AAAA;AAAA;EAAA,uEAAxB,kBACEJ,MAA2B,EAC3BH,IAAU,EACVC,OAAgB;IAAA;IAAA;MAAA;QAAA;UAAA;YAEVQ,QAAwB,GAAG,EAAE;YAC7BC,MAA2B,GAAG,CAAC,CAAC;YAAA,uBAE3BC,GAAG;cACZ,IAAMH,GAAG,GAAGL,MAAM,CAACQ,GAAG,CAAC;cACvB,IAAMC,OAAO,GAAGV,UAAU,CAACM,GAAG,EAAER,IAAI,EAAEC,OAAO,CAAC,CAACY,IAAI,CAAC,UAAChB,KAAK,EAAK;gBAC7Da,MAAM,CAACC,GAAG,CAAC,GAAGd,KAAK;cACrB,CAAC,CAAC;cACFY,QAAQ,CAACK,IAAI,CAACF,OAAO,CAAC;YAAC;YALzB,KAAWD,GAAG,IAAIR,MAAM,EAAE;cAAA,MAAfQ,GAAG;YAMd;YAAC;YAAA,OAEKI,OAAO,CAACC,GAAG,CAACP,QAAQ,CAAC;UAAA;YAAA,kCAEpBC,MAAM;UAAA;UAAA;YAAA;QAAA;MAAA;IAAA;EAAA,CACd;EAAA;AAAA;AAAA,SAEcJ,QAAQ;EAAA;AAAA;AAAA;EAAA,sEAAvB,kBAAwBW,QAAkB,EAAEjB,IAAU;IAAA;MAAA;MAAA;IAAA;MAAA;QAAA;UAAA;YAAEC,OAAO,8DAAG,CAAC,CAAC;YAC5DQ,QAAQ,GAAGQ,QAAQ,CAACC,GAAG,CAAC,UAACV,GAAG;cAAA,OAAKN,UAAU,CAACM,GAAG,EAAER,IAAI,EAAEC,OAAO,CAAC;YAAA,EAAC;YAAA;YAAA,OACzDc,OAAO,CAACC,GAAG,CAACP,QAAQ,CAAC;UAAA;YAAA;UAAA;UAAA;YAAA;QAAA;MAAA;IAAA;EAAA,CACnC;EAAA;AAAA"}