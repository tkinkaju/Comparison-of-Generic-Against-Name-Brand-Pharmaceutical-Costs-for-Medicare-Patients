{"version":3,"file":"compute-tangents.js","names":[],"sources":["../../../../src/geometry/attributes/compute-tangents.ts"],"sourcesContent":["/*\nexport function computeTangents({indices, positions, normals, uvs}) {\n  var index = geometry.index;\n  var attributes = geometry.attributes;\n\n  // based on http://www.terathon.com/code/tangent.html\n  // (per vertex tangents)\n\n  if (\n    index === null ||\n    attributes.position === undefined ||\n    attributes.normal === undefined ||\n    attributes.uv === undefined\n  ) {\n    console.warn(\n      'THREE.BufferGeometry: Missing required attributes (index, position, normal or uv) in BufferGeometry.computeTangents()'\n    );\n    return;\n  }\n\n  var nVertices = positions.length / 3;\n\n  var tangents = new Float32Array(4 * nVertices); // size: 4\n\n  var tan1 = [],\n    tan2 = [];\n\n  for (var k = 0; k < nVertices; k++) {\n    tan1[k] = new THREE.Vector3();\n    tan2[k] = new THREE.Vector3();\n  }\n\n  var vA = new THREE.Vector3(),\n    vB = new THREE.Vector3(),\n    vC = new THREE.Vector3(),\n    uvA = new THREE.Vector2(),\n    uvB = new THREE.Vector2(),\n    uvC = new THREE.Vector2(),\n    sdir = new THREE.Vector3(),\n    tdir = new THREE.Vector3();\n\n  function handleTriangle(a, b, c) {\n    vA.fromArray(positions, a * 3);\n    vB.fromArray(positions, b * 3);\n    vC.fromArray(positions, c * 3);\n\n    uvA.fromArray(uvs, a * 2);\n    uvB.fromArray(uvs, b * 2);\n    uvC.fromArray(uvs, c * 2);\n\n    var x1 = vB.x - vA.x;\n    var x2 = vC.x - vA.x;\n\n    var y1 = vB.y - vA.y;\n    var y2 = vC.y - vA.y;\n\n    var z1 = vB.z - vA.z;\n    var z2 = vC.z - vA.z;\n\n    var s1 = uvB.x - uvA.x;\n    var s2 = uvC.x - uvA.x;\n\n    var t1 = uvB.y - uvA.y;\n    var t2 = uvC.y - uvA.y;\n\n    var r = 1.0 / (s1 * t2 - s2 * t1);\n\n    sdir.set((t2 * x1 - t1 * x2) * r, (t2 * y1 - t1 * y2) * r, (t2 * z1 - t1 * z2) * r);\n\n    tdir.set((s1 * x2 - s2 * x1) * r, (s1 * y2 - s2 * y1) * r, (s1 * z2 - s2 * z1) * r);\n\n    tan1[a].add(sdir);\n    tan1[b].add(sdir);\n    tan1[c].add(sdir);\n\n    tan2[a].add(tdir);\n    tan2[b].add(tdir);\n    tan2[c].add(tdir);\n  }\n\n  var groups = geometry.groups;\n\n  if (groups.length === 0) {\n    groups = [\n      {\n        start: 0,\n        count: indices.length\n      }\n    ];\n  }\n\n  for (var j = 0, jl = groups.length; j < jl; ++j) {\n    var group = groups[j];\n\n    var start = group.start;\n    var count = group.count;\n\n    for (var i = start, il = start + count; i < il; i += 3) {\n      handleTriangle(indices[i + 0], indices[i + 1], indices[i + 2]);\n    }\n  }\n\n  var tmp = new THREE.Vector3(),\n    tmp2 = new THREE.Vector3();\n  var n = new THREE.Vector3(),\n    n2 = new THREE.Vector3();\n  var w, t, test;\n\n  function handleVertex(v) {\n    n.fromArray(normals, v * 3);\n    n2.copy(n);\n\n    t = tan1[v];\n\n    // Gram-Schmidt orthogonalize\n\n    tmp.copy(t);\n    tmp.sub(n.multiplyScalar(n.dot(t))).normalize();\n\n    // Calculate handedness\n\n    tmp2.crossVectors(n2, t);\n    test = tmp2.dot(tan2[v]);\n    w = test < 0.0 ? -1.0 : 1.0;\n\n    tangents[v * 4] = tmp.x;\n    tangents[v * 4 + 1] = tmp.y;\n    tangents[v * 4 + 2] = tmp.z;\n    tangents[v * 4 + 3] = w;\n  }\n\n  for (var j = 0, jl = groups.length; j < jl; ++j) {\n    var group = groups[j];\n\n    var start = group.start;\n    var count = group.count;\n\n    for (var i = start, il = start + count; i < il; i += 3) {\n      handleVertex(indices[i + 0]);\n      handleVertex(indices[i + 1]);\n      handleVertex(indices[i + 2]);\n    }\n  }\n}\n*/\n"],"mappings":""}