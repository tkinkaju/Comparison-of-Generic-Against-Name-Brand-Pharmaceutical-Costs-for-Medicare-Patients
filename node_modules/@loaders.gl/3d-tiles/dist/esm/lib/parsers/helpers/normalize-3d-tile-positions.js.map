{"version":3,"file":"normalize-3d-tile-positions.js","names":["Vector3","GL","normalize3DTilePositionAttribute","tile","positions","options","isQuantized","decodeQuantizedPositions","type","UNSIGNED_SHORT","value","size","normalized","scratchPosition","decodedArray","Float32Array","pointCount","i","set","scale","quantizedRange","multiply","quantizedVolumeScale","add","quantizedVolumeOffset","toArray"],"sources":["../../../../../src/lib/parsers/helpers/normalize-3d-tile-positions.ts"],"sourcesContent":["import {Vector3} from '@math.gl/core';\nimport {GL} from '@loaders.gl/math';\n\n// Prepare attribute for positions\nexport function normalize3DTilePositionAttribute(tile, positions, options) {\n  if (!tile.isQuantized) {\n    return positions;\n  }\n\n  // For quantized posititions, either expand to Float32Array or return custom accessor\n  // https://github.com/AnalyticalGraphicsInc/3d-tiles/blob/master/specification/TileFormats/Instanced3DModel/README.md#quantized-positions\n\n  // Optionally decodes quantized positions on GPU, for simpler renderers that don't accept normalized attributes\n  if (options['3d-tiles'] && options['3d-tiles'].decodeQuantizedPositions) {\n    tile.isQuantized = false;\n    return decodeQuantizedPositions(tile, positions);\n  }\n\n  // Default: Use normalized shorts directly, no copying/processing.\n  // NOTE: The \"missing\" offset/scaling operations are automatically added to modelMatrix if `tile.isQuantized === true`\n  return {\n    type: GL.UNSIGNED_SHORT,\n    value: positions,\n    size: 3,\n    normalized: true\n  };\n}\n\n// Pre-scale quantized positions on CPU\nfunction decodeQuantizedPositions(tile, positions) {\n  const scratchPosition = new Vector3();\n  const decodedArray = new Float32Array(tile.pointCount * 3);\n\n  for (let i = 0; i < tile.pointCount; i++) {\n    // POSITION = POSITION_QUANTIZED / 65535.0 * QUANTIZED_VOLUME_SCALE + QUANTIZED_VOLUME_OFFSET\n    scratchPosition\n      .set(positions[i * 3], positions[i * 3 + 1], positions[i * 3 + 2])\n      .scale(1 / tile.quantizedRange)\n      .multiply(tile.quantizedVolumeScale)\n      .add(tile.quantizedVolumeOffset)\n      .toArray(decodedArray, i * 3);\n  }\n\n  return decodedArray;\n}\n"],"mappings":"AAAA,SAAQA,OAAO,QAAO,eAAe;AACrC,SAAQC,EAAE,QAAO,kBAAkB;;AAGnC,OAAO,SAASC,gCAAgC,CAACC,IAAI,EAAEC,SAAS,EAAEC,OAAO,EAAE;EACzE,IAAI,CAACF,IAAI,CAACG,WAAW,EAAE;IACrB,OAAOF,SAAS;EAClB;;EAMA,IAAIC,OAAO,CAAC,UAAU,CAAC,IAAIA,OAAO,CAAC,UAAU,CAAC,CAACE,wBAAwB,EAAE;IACvEJ,IAAI,CAACG,WAAW,GAAG,KAAK;IACxB,OAAOC,wBAAwB,CAACJ,IAAI,EAAEC,SAAS,CAAC;EAClD;;EAIA,OAAO;IACLI,IAAI,EAAEP,EAAE,CAACQ,cAAc;IACvBC,KAAK,EAAEN,SAAS;IAChBO,IAAI,EAAE,CAAC;IACPC,UAAU,EAAE;EACd,CAAC;AACH;;AAGA,SAASL,wBAAwB,CAACJ,IAAI,EAAEC,SAAS,EAAE;EACjD,MAAMS,eAAe,GAAG,IAAIb,OAAO,EAAE;EACrC,MAAMc,YAAY,GAAG,IAAIC,YAAY,CAACZ,IAAI,CAACa,UAAU,GAAG,CAAC,CAAC;EAE1D,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGd,IAAI,CAACa,UAAU,EAAEC,CAAC,EAAE,EAAE;IAExCJ,eAAe,CACZK,GAAG,CAACd,SAAS,CAACa,CAAC,GAAG,CAAC,CAAC,EAAEb,SAAS,CAACa,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,EAAEb,SAAS,CAACa,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC,CACjEE,KAAK,CAAC,CAAC,GAAGhB,IAAI,CAACiB,cAAc,CAAC,CAC9BC,QAAQ,CAAClB,IAAI,CAACmB,oBAAoB,CAAC,CACnCC,GAAG,CAACpB,IAAI,CAACqB,qBAAqB,CAAC,CAC/BC,OAAO,CAACX,YAAY,EAAEG,CAAC,GAAG,CAAC,CAAC;EACjC;EAEA,OAAOH,YAAY;AACrB"}