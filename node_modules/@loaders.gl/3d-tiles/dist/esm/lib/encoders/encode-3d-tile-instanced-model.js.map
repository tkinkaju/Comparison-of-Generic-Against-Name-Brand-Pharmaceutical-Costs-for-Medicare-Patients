{"version":3,"file":"encode-3d-tile-instanced-model.js","names":["copyStringToDataView","MAGIC_ARRAY","encode3DTileHeader","encode3DTileByteLength","encodeInstancedModel3DTile","tile","dataView","byteOffset","options","featuresLength","gltfFormat","gltfUri","gltfUriByteLength","length","featureTableJson","INSTANCES_LENGTH","POSITION","Array","fill","featureTableJsonString","JSON","stringify","featureTableJsonByteLength","magic","INSTANCED_MODEL","byteOffsetStart","setUint32"],"sources":["../../../../src/lib/encoders/encode-3d-tile-instanced-model.ts"],"sourcesContent":["// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\nimport {copyStringToDataView} from '@loaders.gl/loader-utils';\nimport {MAGIC_ARRAY} from '../constants';\nimport {encode3DTileHeader, encode3DTileByteLength} from './helpers/encode-3d-tile-header';\n\n// Procedurally encode the tile array buffer for testing purposes\n// eslint-disable-next-line max-statements\nexport function encodeInstancedModel3DTile(tile, dataView, byteOffset, options) {\n  const {featuresLength = 1, gltfFormat = 1, gltfUri = ''} = tile;\n\n  const gltfUriByteLength = gltfUri.length;\n\n  const featureTableJson = {\n    INSTANCES_LENGTH: featuresLength,\n    POSITION: new Array(featuresLength * 3).fill(0)\n  };\n  const featureTableJsonString = JSON.stringify(featureTableJson);\n  const featureTableJsonByteLength = featureTableJsonString.length;\n\n  // Add default magic for this tile type\n  tile = {magic: MAGIC_ARRAY.INSTANCED_MODEL, ...tile};\n\n  const byteOffsetStart = byteOffset;\n\n  byteOffset = encode3DTileHeader(tile, dataView, 0);\n\n  if (dataView) {\n    dataView.setUint32(12, featureTableJsonByteLength, true); // featureTableJsonByteLength\n    dataView.setUint32(16, 0, true); // featureTableBinaryByteLength\n    dataView.setUint32(20, 0, true); // batchTableJsonByteLength\n    dataView.setUint32(24, 0, true); // batchTableBinaryByteLength\n    dataView.setUint32(28, gltfFormat, true); // gltfFormat\n  }\n\n  byteOffset += 20;\n\n  byteOffset += copyStringToDataView(\n    dataView,\n    byteOffset,\n    featureTableJsonString,\n    featureTableJsonByteLength\n  );\n  byteOffset += copyStringToDataView(dataView, byteOffset, gltfUri, gltfUriByteLength);\n\n  // Go \"back\" and rewrite the tile's `byteLength` now that we know the value\n  encode3DTileByteLength(dataView, byteOffsetStart, byteOffset - byteOffsetStart);\n\n  return byteOffset;\n}\n"],"mappings":";;AAGA,SAAQA,oBAAoB,QAAO,0BAA0B;AAC7D,SAAQC,WAAW,QAAO,cAAc;AACxC,SAAQC,kBAAkB,EAAEC,sBAAsB,QAAO,iCAAiC;;AAI1F,OAAO,SAASC,0BAA0B,CAACC,IAAI,EAAEC,QAAQ,EAAEC,UAAU,EAAEC,OAAO,EAAE;EAC9E,MAAM;IAACC,cAAc,GAAG,CAAC;IAAEC,UAAU,GAAG,CAAC;IAAEC,OAAO,GAAG;EAAE,CAAC,GAAGN,IAAI;EAE/D,MAAMO,iBAAiB,GAAGD,OAAO,CAACE,MAAM;EAExC,MAAMC,gBAAgB,GAAG;IACvBC,gBAAgB,EAAEN,cAAc;IAChCO,QAAQ,EAAE,IAAIC,KAAK,CAACR,cAAc,GAAG,CAAC,CAAC,CAACS,IAAI,CAAC,CAAC;EAChD,CAAC;EACD,MAAMC,sBAAsB,GAAGC,IAAI,CAACC,SAAS,CAACP,gBAAgB,CAAC;EAC/D,MAAMQ,0BAA0B,GAAGH,sBAAsB,CAACN,MAAM;;EAGhER,IAAI,GAAG;IAACkB,KAAK,EAAEtB,WAAW,CAACuB,eAAe;IAAE,GAAGnB;EAAI,CAAC;EAEpD,MAAMoB,eAAe,GAAGlB,UAAU;EAElCA,UAAU,GAAGL,kBAAkB,CAACG,IAAI,EAAEC,QAAQ,EAAE,CAAC,CAAC;EAElD,IAAIA,QAAQ,EAAE;IACZA,QAAQ,CAACoB,SAAS,CAAC,EAAE,EAAEJ,0BAA0B,EAAE,IAAI,CAAC;IACxDhB,QAAQ,CAACoB,SAAS,CAAC,EAAE,EAAE,CAAC,EAAE,IAAI,CAAC;IAC/BpB,QAAQ,CAACoB,SAAS,CAAC,EAAE,EAAE,CAAC,EAAE,IAAI,CAAC;IAC/BpB,QAAQ,CAACoB,SAAS,CAAC,EAAE,EAAE,CAAC,EAAE,IAAI,CAAC;IAC/BpB,QAAQ,CAACoB,SAAS,CAAC,EAAE,EAAEhB,UAAU,EAAE,IAAI,CAAC;EAC1C;;EAEAH,UAAU,IAAI,EAAE;EAEhBA,UAAU,IAAIP,oBAAoB,CAChCM,QAAQ,EACRC,UAAU,EACVY,sBAAsB,EACtBG,0BAA0B,CAC3B;EACDf,UAAU,IAAIP,oBAAoB,CAACM,QAAQ,EAAEC,UAAU,EAAEI,OAAO,EAAEC,iBAAiB,CAAC;;EAGpFT,sBAAsB,CAACG,QAAQ,EAAEmB,eAAe,EAAElB,UAAU,GAAGkB,eAAe,CAAC;EAE/E,OAAOlB,UAAU;AACnB"}