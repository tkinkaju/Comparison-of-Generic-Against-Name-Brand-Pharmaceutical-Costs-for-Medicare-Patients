{"version":3,"file":"response-utils.js","names":["makeResponse","resource","isResponse","headers","contentLength","getResourceContentLength","String","getResourceUrlAndType","url","type","getInitialDataUrl","initialDataUrl","TextEncoder","encode","response","Response","Object","defineProperty","value","checkResponse","ok","getResponseError","message","Error","checkResponseSync","status","statusText","length","slice","contentType","get","text","includes","INITIAL_DATA_LENGTH","Blob","blobSlice","Promise","resolve","reader","FileReader","onload","event","target","result","readAsDataURL","ArrayBuffer","base64","arrayBufferToBase64","buffer","binary","bytes","Uint8Array","i","byteLength","fromCharCode","btoa"],"sources":["../../../../src/lib/utils/response-utils.ts"],"sourcesContent":["import {isResponse} from '../../javascript-utils/is-type';\nimport {getResourceContentLength, getResourceUrlAndType} from './resource-utils';\n\n/**\n * Returns a Response object\n * Adds content-length header when possible\n *\n * @param resource\n */\nexport async function makeResponse(resource: any): Promise<Response> {\n  if (isResponse(resource)) {\n    return resource;\n  }\n\n  // Add content-length header if possible\n  const headers: {[header: string]: string} = {};\n\n  const contentLength = getResourceContentLength(resource);\n  if (contentLength >= 0) {\n    headers['content-length'] = String(contentLength);\n  }\n\n  // `new Response(File)` does not preserve content-type and URL\n  // so we add them here\n  const {url, type} = getResourceUrlAndType(resource);\n  if (type) {\n    headers['content-type'] = type;\n  }\n\n  // Add a custom header with initial bytes if available\n  const initialDataUrl = await getInitialDataUrl(resource);\n  if (initialDataUrl) {\n    headers['x-first-bytes'] = initialDataUrl;\n  }\n\n  // TODO - is this the best way of handling strings?\n  // Maybe package as data URL instead?\n  if (typeof resource === 'string') {\n    // Convert to ArrayBuffer to avoid Response treating it as a URL\n    resource = new TextEncoder().encode(resource);\n  }\n\n  // Attempt to create a Response from the resource, adding headers and setting url\n  const response = new Response(resource, {headers});\n  // We can't control `Response.url` via constructor, use a property override to record URL.\n  Object.defineProperty(response, 'url', {value: url});\n  return response;\n}\n\n/**\n * Checks response status (async) and throws a helpful error message if status is not OK.\n * @param response\n */\nexport async function checkResponse(response: Response): Promise<void> {\n  if (!response.ok) {\n    const message = await getResponseError(response);\n    throw new Error(message);\n  }\n}\n\n/**\n * Checks response status (sync) and throws a helpful error message if status is not OK.\n * @param response\n */\nexport function checkResponseSync(response: Response): void {\n  if (!response.ok) {\n    let message = `${response.status} ${response.statusText}`;\n    message = message.length > 60 ? `${message.slice(0, 60)}...` : message;\n    throw new Error(message);\n  }\n}\n\n// HELPERS\n\nasync function getResponseError(response): Promise<string> {\n  let message = `Failed to fetch resource ${response.url} (${response.status}): `;\n  try {\n    const contentType = response.headers.get('Content-Type');\n    let text = response.statusText;\n    if (contentType.includes('application/json')) {\n      text += ` ${await response.text()}`;\n    }\n    message += text;\n    message = message.length > 60 ? `${message.slice(0, 60)}...` : message;\n  } catch (error) {\n    // eslint forbids return in a finally statement, so we just catch here\n  }\n  return message;\n}\n\nasync function getInitialDataUrl(resource): Promise<string | null> {\n  const INITIAL_DATA_LENGTH = 5;\n  if (typeof resource === 'string') {\n    return `data:,${resource.slice(0, INITIAL_DATA_LENGTH)}`;\n  }\n  if (resource instanceof Blob) {\n    const blobSlice = resource.slice(0, 5);\n    return await new Promise((resolve) => {\n      const reader = new FileReader();\n      reader.onload = (event) => resolve(event?.target?.result as string);\n      reader.readAsDataURL(blobSlice);\n    });\n  }\n  if (resource instanceof ArrayBuffer) {\n    const slice = resource.slice(0, INITIAL_DATA_LENGTH);\n    const base64 = arrayBufferToBase64(slice);\n    return `data:base64,${base64}`;\n  }\n  return null;\n}\n\n// https://stackoverflow.com/questions/9267899/arraybuffer-to-base64-encoded-string\nfunction arrayBufferToBase64(buffer) {\n  let binary = '';\n  const bytes = new Uint8Array(buffer);\n  for (let i = 0; i < bytes.byteLength; i++) {\n    binary += String.fromCharCode(bytes[i]);\n  }\n  return btoa(binary);\n}\n"],"mappings":"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"}