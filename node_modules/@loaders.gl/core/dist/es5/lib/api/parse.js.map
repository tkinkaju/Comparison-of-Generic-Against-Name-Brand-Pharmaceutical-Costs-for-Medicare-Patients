{"version":3,"file":"parse.js","names":["parse","data","loaders","options","context","assert","Array","isArray","isLoaderObject","undefined","getResourceUrlAndType","url","typedLoaders","candidateLoaders","getLoadersFromContext","selectLoader","loader","normalizeOptions","getLoaderContext","parseWithLoader","validateWorkerVersion","isResponse","response","ok","redirected","status","statusText","type","headers","Object","fromEntries","entries","getArrayBufferOrStringFromData","parseTextSync","dataType","canParseWithWorker","parseWithWorker","parseText","parseSync","Error","id"],"sources":["../../../../src/lib/api/parse.ts"],"sourcesContent":["import type {DataType, Loader, LoaderContext, LoaderOptions} from '@loaders.gl/loader-utils';\nimport {assert, validateWorkerVersion} from '@loaders.gl/worker-utils';\nimport {parseWithWorker, canParseWithWorker} from '@loaders.gl/loader-utils';\nimport {isLoaderObject} from '../loader-utils/normalize-loader';\nimport {isResponse} from '../../javascript-utils/is-type';\nimport {normalizeOptions} from '../loader-utils/option-utils';\nimport {getArrayBufferOrStringFromData} from '../loader-utils/get-data';\nimport {getLoaderContext, getLoadersFromContext} from '../loader-utils/loader-context';\nimport {getResourceUrlAndType} from '../utils/resource-utils';\nimport {selectLoader} from './select-loader';\n\n/**\n * Parses `data` using a specified loader\n * @param data\n * @param loaders\n * @param options\n * @param context\n */\nexport async function parse(\n  data: DataType | Promise<DataType>,\n  loaders?: Loader | Loader[] | LoaderOptions,\n  options?: LoaderOptions,\n  context?: LoaderContext\n): Promise<any> {\n  assert(!context || typeof context === 'object'); // parse no longer accepts final url\n\n  // Signature: parse(data, options, context | url)\n  // Uses registered loaders\n  if (loaders && !Array.isArray(loaders) && !isLoaderObject(loaders)) {\n    context = undefined; // context not supported in short signature\n    options = loaders as LoaderOptions;\n    loaders = undefined;\n  }\n\n  data = await data; // Resolve any promise\n  options = options || {};\n\n  // Extract a url for auto detection\n  const {url} = getResourceUrlAndType(data);\n\n  // Chooses a loader (and normalizes it)\n  // Also use any loaders in the context, new loaders take priority\n  const typedLoaders = loaders as Loader | Loader[] | undefined;\n  const candidateLoaders = getLoadersFromContext(typedLoaders, context);\n  // todo hacky type cast\n  const loader = await selectLoader(data as ArrayBuffer, candidateLoaders, options);\n  // Note: if no loader was found, if so just return null\n  if (!loader) {\n    return null;\n  }\n\n  // Normalize options\n  options = normalizeOptions(options, loader, candidateLoaders, url);\n\n  // Get a context (if already present, will be unchanged)\n  context = getLoaderContext({url, parse, loaders: candidateLoaders}, options, context);\n\n  return await parseWithLoader(loader, data, options, context);\n}\n\n// TODO: support progress and abort\n// TODO - should accept loader.parseAsyncIterator and concatenate.\nasync function parseWithLoader(loader, data, options, context) {\n  validateWorkerVersion(loader);\n\n  if (isResponse(data)) {\n    // Serialize to support passing the response to web worker\n    const response = data as Response;\n    const {ok, redirected, status, statusText, type, url} = response;\n    const headers = Object.fromEntries(response.headers.entries());\n    context.response = {headers, ok, redirected, status, statusText, type, url};\n  }\n\n  data = await getArrayBufferOrStringFromData(data, loader, options);\n\n  // First check for synchronous text parser, wrap results in promises\n  if (loader.parseTextSync && typeof data === 'string') {\n    options.dataType = 'text';\n    return loader.parseTextSync(data, options, context, loader);\n  }\n\n  // If we have a workerUrl and the loader can parse the given options efficiently in a worker\n  if (canParseWithWorker(loader, options)) {\n    return await parseWithWorker(loader, data, options, context, parse);\n  }\n\n  // Check for asynchronous parser\n  if (loader.parseText && typeof data === 'string') {\n    return await loader.parseText(data, options, context, loader);\n  }\n\n  if (loader.parse) {\n    return await loader.parse(data, options, context, loader);\n  }\n\n  // This should not happen, all sync loaders should also offer `parse` function\n  assert(!loader.parseSync);\n\n  // TBD - If asynchronous parser not available, return null\n  throw new Error(`${loader.id} loader - no parser found and worker is disabled`);\n}\n"],"mappings":"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"}