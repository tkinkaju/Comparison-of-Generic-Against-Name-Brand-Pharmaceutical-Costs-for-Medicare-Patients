{"version":3,"file":"KHR_texture_transform.js","names":["Vector3","Matrix3","getAccessorArrayTypeAndLength","BYTES","COMPONENTS","GLTFScenegraph","EXT_MESHOPT_TRANSFORM","name","scratchVector","scratchRotationMatrix","scratchScaleMatrix","decode","gltfData","options","gltfScenegraph","extension","getExtension","materials","json","i","length","transformTexCoords","materialIndex","processedTexCoords","material","baseColorTexture","pbrMetallicRoughness","transformPrimitives","emisiveTexture","emissiveTexture","normalTexture","occlusionTexture","metallicRoughnessTexture","texture","transformParameters","getTransformParameters","meshes","mesh","primitive","primitives","Number","isFinite","transformPrimitive","textureInfo","extensions","texCoord","originalTexCoord","isProcessed","findIndex","original","newTexCoord","matrix","makeTransformationMatrix","push","texCoordAccessor","attributes","accessor","accessors","bufferView","bufferViews","arrayBuffer","byteOffset","bufferByteOffset","buffers","buffer","ArrayType","bytes","componentType","components","type","elementAddressScale","byteStride","result","Float32Array","count","uv","set","transformByMatrix3","updateGltf","createAttribute","newTexCoordArray","byteLength","originalAccessor","extensionData","offset","rotation","scale","translationMatirx","rotationMatirx","Math","cos","sin","scaleMatrix","multiplyRight"],"sources":["../../../../src/lib/extensions/KHR_texture_transform.ts"],"sourcesContent":["/**\n * https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_texture_transform/README.md\n */\n\nimport {Vector3, Matrix3} from '@math.gl/core';\nimport type {GLTFMeshPrimitive, GLTFWithBuffers} from '../types/gltf-types';\nimport type {GLTFLoaderOptions} from '../../gltf-loader';\nimport {getAccessorArrayTypeAndLength} from '../gltf-utils/gltf-utils';\nimport {BYTES, COMPONENTS} from '../gltf-utils/gltf-constants';\nimport {\n  Accessor,\n  BufferView,\n  MaterialNormalTextureInfo,\n  MaterialOcclusionTextureInfo,\n  TextureInfo as GLTFTextureInfo\n} from '../types/gltf-json-schema';\nimport GLTFScenegraph from '../api/gltf-scenegraph';\n\n/** Extension name */\nconst EXT_MESHOPT_TRANSFORM = 'KHR_texture_transform';\n\nexport const name = EXT_MESHOPT_TRANSFORM;\n\nconst scratchVector = new Vector3();\nconst scratchRotationMatrix = new Matrix3();\nconst scratchScaleMatrix = new Matrix3();\n\n/** Extension textureInfo https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_texture_transform#gltf-schema-updates */\ntype TextureInfo = {\n  /** The offset of the UV coordinate origin as a factor of the texture dimensions. */\n  offset?: [number, number];\n  /** Rotate the UVs by this many radians counter-clockwise around the origin. This is equivalent to a similar rotation of the image clockwise. */\n  rotation?: number;\n  /** The scale factor applied to the components of the UV coordinates. */\n  scale?: [number, number];\n  /** Overrides the textureInfo texCoord value if supplied, and if this extension is supported. */\n  texCoord?: number;\n};\n/** Intersection of all GLTF textures */\ntype CompoundGLTFTextureInfo = GLTFTextureInfo &\n  MaterialNormalTextureInfo &\n  MaterialOcclusionTextureInfo;\n/** Parameters for TEXCOORD transformation */\ntype TransformParameters = {\n  /** Original texCoord value https://www.khronos.org/registry/glTF/specs/2.0/glTF-2.0.html#_textureinfo_texcoord */\n  originalTexCoord: number;\n  /** New texCoord value from extension https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_texture_transform#gltf-schema-updates */\n  texCoord: number;\n  /** Transformation matrix */\n  matrix: Matrix3;\n};\n\n/**\n * The extension entry to process the transformation\n * @param gltfData gltf buffers and json\n * @param options GLTFLoader options\n */\nexport async function decode(gltfData: GLTFWithBuffers, options: GLTFLoaderOptions) {\n  const gltfScenegraph = new GLTFScenegraph(gltfData);\n  const extension = gltfScenegraph.getExtension(EXT_MESHOPT_TRANSFORM);\n  if (!extension) {\n    return;\n  }\n  const materials = gltfData.json.materials || [];\n  for (let i = 0; i < materials.length; i++) {\n    transformTexCoords(i, gltfData);\n  }\n}\n\n/**\n * Transform TEXCOORD by material\n * @param materialIndex processing material index\n * @param gltfData gltf buffers and json\n */\nfunction transformTexCoords(materialIndex: number, gltfData: GLTFWithBuffers): void {\n  // Save processed texCoords in order no to process the same twice\n  const processedTexCoords: [number, number][] = [];\n  const material = gltfData.json.materials?.[materialIndex];\n  const baseColorTexture = material?.pbrMetallicRoughness?.baseColorTexture;\n  if (baseColorTexture) {\n    transformPrimitives(gltfData, materialIndex, baseColorTexture, processedTexCoords);\n  }\n  const emisiveTexture = material?.emissiveTexture;\n  if (emisiveTexture) {\n    transformPrimitives(gltfData, materialIndex, emisiveTexture, processedTexCoords);\n  }\n  const normalTexture = material?.normalTexture;\n  if (normalTexture) {\n    transformPrimitives(gltfData, materialIndex, normalTexture, processedTexCoords);\n  }\n  const occlusionTexture = material?.occlusionTexture;\n  if (occlusionTexture) {\n    transformPrimitives(gltfData, materialIndex, occlusionTexture, processedTexCoords);\n  }\n  const metallicRoughnessTexture = material?.pbrMetallicRoughness?.metallicRoughnessTexture;\n  if (metallicRoughnessTexture) {\n    transformPrimitives(gltfData, materialIndex, metallicRoughnessTexture, processedTexCoords);\n  }\n}\n\n/**\n * Transform primitives of the particular material\n * @param gltfData gltf data\n * @param materialIndex primitives with this material will be transformed\n * @param texture texture object\n * @param processedTexCoords storage to save already processed texCoords\n */\nfunction transformPrimitives(\n  gltfData: GLTFWithBuffers,\n  materialIndex: number,\n  texture: CompoundGLTFTextureInfo,\n  processedTexCoords: [number, number][]\n) {\n  const transformParameters = getTransformParameters(texture, processedTexCoords);\n  if (!transformParameters) {\n    return;\n  }\n  const meshes = gltfData.json.meshes || [];\n  for (const mesh of meshes) {\n    for (const primitive of mesh.primitives) {\n      const material = primitive.material;\n      if (Number.isFinite(material) && materialIndex === material) {\n        transformPrimitive(gltfData, primitive, transformParameters);\n      }\n    }\n  }\n}\n\n/**\n * Get parameters for TEXCOORD transformation\n * @param texture texture object\n * @param processedTexCoords storage to save already processed texCoords\n * @returns texCoord couple and transformation matrix\n */\nfunction getTransformParameters(\n  texture: CompoundGLTFTextureInfo,\n  processedTexCoords: [number, number][]\n): TransformParameters | null {\n  const textureInfo = texture.extensions?.[EXT_MESHOPT_TRANSFORM];\n  const {texCoord: originalTexCoord = 0} = texture;\n  // If texCoord is not set in the extension, original attribute data will be replaced\n  const {texCoord = originalTexCoord} = textureInfo;\n  // Make sure that couple [originalTexCoord, extensionTexCoord] is not processed twice\n  const isProcessed =\n    processedTexCoords.findIndex(\n      ([original, newTexCoord]) => original === originalTexCoord && newTexCoord === texCoord\n    ) !== -1;\n  if (!isProcessed) {\n    const matrix = makeTransformationMatrix(textureInfo);\n    if (originalTexCoord !== texCoord) {\n      texture.texCoord = texCoord;\n    }\n    processedTexCoords.push([originalTexCoord, texCoord]);\n    return {originalTexCoord, texCoord, matrix};\n  }\n  return null;\n}\n\n/**\n * Transform `TEXCOORD_0` attribute in the primitive\n * @param gltfData gltf data\n * @param primitive primitive object\n * @param transformParameters texCoord couple and transformation matrix\n */\nfunction transformPrimitive(\n  gltfData: GLTFWithBuffers,\n  primitive: GLTFMeshPrimitive,\n  transformParameters: TransformParameters\n) {\n  const {originalTexCoord, texCoord, matrix} = transformParameters;\n  const texCoordAccessor = primitive.attributes[`TEXCOORD_${originalTexCoord}`];\n  if (Number.isFinite(texCoordAccessor)) {\n    // Get accessor of the `TEXCOORD_0` attribute\n    const accessor = gltfData.json.accessors?.[texCoordAccessor];\n    if (accessor && accessor.bufferView) {\n      // Get `bufferView` of the `accessor`\n      const bufferView = gltfData.json.bufferViews?.[accessor.bufferView];\n      if (bufferView) {\n        // Get `arrayBuffer` the `bufferView` look at\n        const {arrayBuffer, byteOffset: bufferByteOffset} = gltfData.buffers[bufferView.buffer];\n        // Resulting byteOffset is sum of the buffer, accessor and bufferView byte offsets\n        const byteOffset =\n          (bufferByteOffset || 0) + (accessor.byteOffset || 0) + (bufferView.byteOffset || 0);\n        // Deduce TypedArray type and its length from `accessor` and `bufferView` data\n        const {ArrayType, length} = getAccessorArrayTypeAndLength(accessor, bufferView);\n        // Number of bytes each component occupies\n        const bytes = BYTES[accessor.componentType];\n        // Number of components. For the `TEXCOORD_0` with `VEC2` type, it must return 2\n        const components = COMPONENTS[accessor.type];\n        // Multiplier to calculate the address of the `TEXCOORD_0` element in the arrayBuffer\n        const elementAddressScale = bufferView.byteStride || bytes * components;\n        // Data transform to Float32Array\n        const result = new Float32Array(length);\n        for (let i = 0; i < accessor.count; i++) {\n          // Take [u, v] couple from the arrayBuffer\n          const uv = new ArrayType(arrayBuffer, byteOffset + i * elementAddressScale, 2);\n          // Set and transform Vector3 per https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_texture_transform#overview\n          scratchVector.set(uv[0], uv[1], 1);\n          scratchVector.transformByMatrix3(matrix);\n          // Save result in Float32Array\n          result.set([scratchVector[0], scratchVector[1]], i * components);\n        }\n        // If texCoord the same, replace gltf structural data\n        if (originalTexCoord === texCoord) {\n          updateGltf(accessor, bufferView, gltfData.buffers, result);\n        } else {\n          // If texCoord change, create new attribute\n          createAttribute(texCoord, accessor, primitive, gltfData, result);\n        }\n      }\n    }\n  }\n}\n\n/**\n * Update GLTF structural objects with new data as we create new `Float32Array` for `TEXCOORD_0`.\n * @param accessor accessor to change\n * @param bufferView bufferView to change\n * @param buffers binary buffers\n * @param newTexcoordArray typed array with data after transformation\n */\nfunction updateGltf(\n  accessor: Accessor,\n  bufferView: BufferView,\n  buffers: {arrayBuffer: ArrayBuffer; byteOffset: number; byteLength: number}[],\n  newTexCoordArray: Float32Array\n): void {\n  accessor.componentType = 5126;\n  buffers.push({\n    arrayBuffer: newTexCoordArray.buffer,\n    byteOffset: 0,\n    byteLength: newTexCoordArray.buffer.byteLength\n  });\n  bufferView.buffer = buffers.length - 1;\n  bufferView.byteLength = newTexCoordArray.buffer.byteLength;\n  bufferView.byteOffset = 0;\n  delete bufferView.byteStride;\n}\n\n/**\n *\n * @param newTexCoord new `texCoord` value\n * @param originalAccessor original accessor object, that store data before transformation\n * @param primitive primitive object\n * @param gltfData gltf data\n * @param newTexCoordArray typed array with data after transformation\n * @returns\n */\nfunction createAttribute(\n  newTexCoord: number,\n  originalAccessor: Accessor,\n  primitive: GLTFMeshPrimitive,\n  gltfData: GLTFWithBuffers,\n  newTexCoordArray: Float32Array\n) {\n  gltfData.buffers.push({\n    arrayBuffer: newTexCoordArray.buffer,\n    byteOffset: 0,\n    byteLength: newTexCoordArray.buffer.byteLength\n  });\n  const bufferViews = gltfData.json.bufferViews;\n  if (!bufferViews) {\n    return;\n  }\n  bufferViews.push({\n    buffer: gltfData.buffers.length - 1,\n    byteLength: newTexCoordArray.buffer.byteLength,\n    byteOffset: 0\n  });\n  const accessors = gltfData.json.accessors;\n  if (!accessors) {\n    return;\n  }\n  accessors.push({\n    bufferView: bufferViews?.length - 1,\n    byteOffset: 0,\n    componentType: 5126,\n    count: originalAccessor.count,\n    type: 'VEC2'\n  });\n  primitive.attributes[`TEXCOORD_${newTexCoord}`] = accessors.length - 1;\n}\n\n/**\n * Construct transformation matrix from the extension data (transition, rotation, scale)\n * @param extensionData extension data\n * @returns transformation matrix\n */\nfunction makeTransformationMatrix(extensionData: TextureInfo): Matrix3 {\n  const {offset = [0, 0], rotation = 0, scale = [1, 1]} = extensionData;\n  const translationMatirx = new Matrix3().set(1, 0, 0, 0, 1, 0, offset[0], offset[1], 1);\n  const rotationMatirx = scratchRotationMatrix.set(\n    Math.cos(rotation),\n    Math.sin(rotation),\n    0,\n    -Math.sin(rotation),\n    Math.cos(rotation),\n    0,\n    0,\n    0,\n    1\n  );\n  const scaleMatrix = scratchScaleMatrix.set(scale[0], 0, 0, 0, scale[1], 0, 0, 0, 1);\n  return translationMatirx.multiplyRight(rotationMatirx).multiplyRight(scaleMatrix);\n}\n"],"mappings":"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"}