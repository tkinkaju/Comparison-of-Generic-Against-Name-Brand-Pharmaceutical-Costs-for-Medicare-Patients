"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.decode = exports.name = void 0;
const gltf_scenegraph_1 = __importDefault(require("../../api/gltf-scenegraph"));
/** Extension name */
const EXT_FEATURE_METADATA = 'EXT_feature_metadata';
exports.name = EXT_FEATURE_METADATA;
async function decode(gltfData) {
    const scenegraph = new gltf_scenegraph_1.default(gltfData);
    decodeExtFeatureMetadata(scenegraph);
}
exports.decode = decode;
/**
 * Decodes feature metadata from extension
 * @param scenegraph
 */
function decodeExtFeatureMetadata(scenegraph) {
    const extension = scenegraph.getExtension(EXT_FEATURE_METADATA);
    const schemaClasses = extension?.schema?.classes;
    const featureTables = extension?.featureTables;
    const featureTextures = extension?.featureTextures;
    if (featureTextures) {
        /*
         * TODO add support for featureTextures
         * Spec - https://github.com/CesiumGS/glTF/tree/3d-tiles-next/extensions/2.0/Vendor/EXT_feature_metadata#feature-textures
         */
        // eslint-disable-next-line no-console
        console.warn('featureTextures is not yet supported in the "EXT_feature_metadata" extension.');
    }
    if (schemaClasses && featureTables) {
        for (const schemaName in schemaClasses) {
            const schemaClass = schemaClasses[schemaName];
            const featureTable = findFeatureTableByName(featureTables, schemaName);
            if (featureTable) {
                handleFeatureTableProperties(scenegraph, featureTable, schemaClass);
            }
        }
    }
}
/**
 * Navigate throw all properies in feature table and gets properties data.
 * @param scenegraph
 * @param featureTable
 * @param schemaClass
 */
function handleFeatureTableProperties(scenegraph, featureTable, schemaClass) {
    for (const propertyName in schemaClass.properties) {
        const schemaProperty = schemaClass.properties[propertyName];
        const featureTableProperty = featureTable?.properties?.[propertyName];
        const numberOfFeatures = featureTable.count;
        if (featureTableProperty) {
            const data = getPropertyDataFromBinarySource(scenegraph, schemaProperty, numberOfFeatures, featureTableProperty);
            featureTableProperty.data = data;
        }
    }
}
/**
 * Decode properties from binary sourse based on property type.
 * @param scenegraph
 * @param schemaProperty
 * @param numberOfFeatures
 * @param featureTableProperty
 */
function getPropertyDataFromBinarySource(scenegraph, schemaProperty, numberOfFeatures, featureTableProperty) {
    const bufferView = featureTableProperty.bufferView;
    // TODO think maybe we shouldn't get data only in Uint8Array format.
    let data = scenegraph.getTypedArrayForBufferView(bufferView);
    switch (schemaProperty.type) {
        case 'STRING': {
            // stringOffsetBufferView should be available for string type.
            const stringOffsetBufferView = featureTableProperty.stringOffsetBufferView;
            const offsetsData = scenegraph.getTypedArrayForBufferView(stringOffsetBufferView);
            data = getStringAttributes(data, offsetsData, numberOfFeatures);
            break;
        }
        default:
    }
    return data;
}
/**
 * Find the feature table by class name.
 * @param featureTables
 * @param schemaClassName
 */
function findFeatureTableByName(featureTables, schemaClassName) {
    for (const featureTableName in featureTables) {
        const featureTable = featureTables[featureTableName];
        if (featureTable.class === schemaClassName) {
            return featureTable;
        }
    }
    return null;
}
/**
 * Getting string attributes from binary data.
 * Spec - https://github.com/CesiumGS/3d-tiles/tree/main/specification/Metadata#strings
 * @param data
 * @param offsetsData
 * @param stringsCount
 */
function getStringAttributes(data, offsetsData, stringsCount) {
    const stringsArray = [];
    const textDecoder = new TextDecoder('utf8');
    let stringOffset = 0;
    const bytesPerStringSize = 4;
    for (let index = 0; index < stringsCount; index++) {
        // TODO check if it is multiplication on bytesPerStringSize is valid operation?
        const stringByteSize = offsetsData[(index + 1) * bytesPerStringSize] - offsetsData[index * bytesPerStringSize];
        const stringData = data.subarray(stringOffset, stringByteSize + stringOffset);
        const stringAttribute = textDecoder.decode(stringData);
        stringsArray.push(stringAttribute);
        stringOffset += stringByteSize;
    }
    return stringsArray;
}
