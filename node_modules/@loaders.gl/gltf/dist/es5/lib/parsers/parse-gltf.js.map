{"version":3,"file":"parse-gltf.js","names":["isGLTF","arrayBuffer","options","byteOffset","isGLB","parseGLTF","gltf","arrayBufferOrString","context","parseGLTFContainerSync","normalizeGLTFV1","normalize","preprocessExtensions","promises","loadBuffers","json","buffers","loadImages","promise","push","decodeExtensions","Promise","all","postProcess","postProcessGLTF","data","uri","baseUri","ArrayBuffer","textDecoder","TextDecoder","decode","parseJSON","glb","parseGLBSync","assert","type","_glb","Array","length","fill","header","hasBinChunk","binChunks","byteLength","images","i","buffer","fetch","resolveUrl","response","imageIndices","getReferencesImageIndices","imageIndex","loadImage","Set","textures","texture","source","undefined","add","from","sort","image","index","parse","hasOwnProperty","bufferView","Number","isFinite","array","getTypedArrayForBufferView","sliceArrayBuffer","ImageLoader","BasisLoader","mimeType","basis","format","selectSupportedBasisFormat","parsedImage","compressed","mipmaps","width","height"],"sources":["../../../../src/lib/parsers/parse-gltf.ts"],"sourcesContent":["/* eslint-disable camelcase, max-statements, no-restricted-globals */\nimport type {LoaderContext} from '@loaders.gl/loader-utils';\nimport {BasisLoader, selectSupportedBasisFormat} from '@loaders.gl/textures';\nimport type {GLTFLoaderOptions} from '../../gltf-loader';\nimport type {GLB} from '../types/glb-types';\nimport type {GLTFWithBuffers} from '../types/gltf-types';\n\nimport {ImageLoader} from '@loaders.gl/images';\nimport {parseJSON, sliceArrayBuffer} from '@loaders.gl/loader-utils';\nimport {assert} from '../utils/assert';\nimport {resolveUrl} from '../gltf-utils/resolve-url';\nimport {getTypedArrayForBufferView} from '../gltf-utils/get-typed-array';\nimport {preprocessExtensions, decodeExtensions} from '../api/gltf-extensions';\nimport {normalizeGLTFV1} from '../api/normalize-gltf-v1';\nimport {postProcessGLTF} from '../api/post-process-gltf';\nimport parseGLBSync, {isGLB} from './parse-glb';\n\nexport type GLTFParseOptions = {\n  normalize?: boolean;\n  loadImages?: boolean;\n  loadBuffers?: boolean;\n  decompressMeshes?: boolean;\n  postProcess?: boolean;\n  excludeExtensions?: string[];\n};\n\n// export type GLTFOptions = {\n//   gltf?: GLTFParseOptions;\n// };\n\nexport function isGLTF(arrayBuffer, options?): boolean {\n  const byteOffset = 0;\n  return isGLB(arrayBuffer, byteOffset, options);\n}\n\nexport async function parseGLTF(\n  gltf: GLTFWithBuffers,\n  arrayBufferOrString,\n  byteOffset = 0,\n  options: GLTFLoaderOptions,\n  context: LoaderContext\n) {\n  parseGLTFContainerSync(gltf, arrayBufferOrString, byteOffset, options);\n\n  normalizeGLTFV1(gltf, {normalize: options?.gltf?.normalize});\n\n  preprocessExtensions(gltf, options, context);\n\n  const promises: Promise<any>[] = [];\n\n  // Load linked buffers asynchronously and decodes base64 buffers in parallel\n  if (options?.gltf?.loadBuffers && gltf.json.buffers) {\n    await loadBuffers(gltf, options, context);\n  }\n\n  if (options?.gltf?.loadImages) {\n    const promise = loadImages(gltf, options, context);\n    promises.push(promise);\n  }\n\n  const promise = decodeExtensions(gltf, options, context);\n  promises.push(promise);\n\n  // Parallelize image loading and buffer loading/extension decoding\n  await Promise.all(promises);\n\n  // Post processing resolves indices to objects, buffers\n  return options?.gltf?.postProcess ? postProcessGLTF(gltf, options) : gltf;\n}\n\n// `data` - can be ArrayBuffer (GLB), ArrayBuffer (Binary JSON), String (JSON), or Object (parsed JSON)\nfunction parseGLTFContainerSync(gltf, data, byteOffset, options) {\n  // Initialize gltf container\n  if (options.uri) {\n    gltf.baseUri = options.uri;\n  }\n\n  // If data is binary and starting with magic bytes, assume binary JSON text, convert to string\n  if (data instanceof ArrayBuffer && !isGLB(data, byteOffset, options)) {\n    const textDecoder = new TextDecoder();\n    data = textDecoder.decode(data);\n  }\n\n  if (typeof data === 'string') {\n    // If string, try to parse as JSON\n    gltf.json = parseJSON(data);\n  } else if (data instanceof ArrayBuffer) {\n    // If still ArrayBuffer, parse as GLB container\n    const glb: GLB = {} as GLB;\n    byteOffset = parseGLBSync(glb, data, byteOffset, options.glb);\n\n    assert(glb.type === 'glTF', `Invalid GLB magic string ${glb.type}`);\n\n    gltf._glb = glb;\n    gltf.json = glb.json;\n  } else {\n    assert(false, 'GLTF: must be ArrayBuffer or string');\n  }\n\n  // Populate buffers\n  // Create an external buffers array to hold binary data\n  const buffers = gltf.json.buffers || [];\n  gltf.buffers = new Array(buffers.length).fill(null);\n\n  // Populates JSON and some bin chunk info\n  if (gltf._glb && gltf._glb.header.hasBinChunk) {\n    const {binChunks} = gltf._glb;\n    gltf.buffers[0] = {\n      arrayBuffer: binChunks[0].arrayBuffer,\n      byteOffset: binChunks[0].byteOffset,\n      byteLength: binChunks[0].byteLength\n    };\n\n    // TODO - this modifies JSON and is a post processing thing\n    // gltf.json.buffers[0].data = gltf.buffers[0].arrayBuffer;\n    // gltf.json.buffers[0].byteOffset = gltf.buffers[0].byteOffset;\n  }\n\n  // Populate images\n  const images = gltf.json.images || [];\n  gltf.images = new Array(images.length).fill({});\n}\n\n/** Asynchronously fetch and parse buffers, store in buffers array outside of json\n * TODO - traverse gltf and determine which buffers are actually needed\n */\nasync function loadBuffers(gltf: GLTFWithBuffers, options, context: LoaderContext) {\n  // TODO\n  const buffers = gltf.json.buffers || [];\n  for (let i = 0; i < buffers.length; ++i) {\n    const buffer = buffers[i];\n    if (buffer.uri) {\n      const {fetch} = context;\n      assert(fetch);\n\n      const uri = resolveUrl(buffer.uri, options);\n      const response = await context?.fetch?.(uri);\n      const arrayBuffer = await response?.arrayBuffer?.();\n\n      gltf.buffers[i] = {\n        arrayBuffer,\n        byteOffset: 0,\n        byteLength: arrayBuffer.byteLength\n      };\n\n      delete buffer.uri;\n    } else if (gltf.buffers[i] === null) {\n      gltf.buffers[i] = {\n        arrayBuffer: new ArrayBuffer(buffer.byteLength),\n        byteOffset: 0,\n        byteLength: buffer.byteLength\n      };\n    }\n  }\n}\n\n/**\n * Loads all images\n * TODO - traverse gltf and determine which images are actually needed\n * @param gltf\n * @param options\n * @param context\n * @returns\n */\nasync function loadImages(gltf: GLTFWithBuffers, options, context: LoaderContext) {\n  const imageIndices = getReferencesImageIndices(gltf);\n\n  const images = gltf.json.images || [];\n\n  const promises: Promise<any>[] = [];\n  for (const imageIndex of imageIndices) {\n    promises.push(loadImage(gltf, images[imageIndex], imageIndex, options, context));\n  }\n\n  return await Promise.all(promises);\n}\n\n/** Make sure we only load images that are actually referenced by textures */\nfunction getReferencesImageIndices(gltf: GLTFWithBuffers): number[] {\n  const imageIndices = new Set<number>();\n\n  const textures = gltf.json.textures || [];\n  for (const texture of textures) {\n    if (texture.source !== undefined) {\n      imageIndices.add(texture.source);\n    }\n  }\n\n  return Array.from(imageIndices).sort();\n}\n\n/** Asynchronously fetches and parses one image, store in images array outside of json */\nasync function loadImage(\n  gltf: GLTFWithBuffers,\n  image,\n  index: number,\n  options,\n  context: LoaderContext\n) {\n  const {fetch, parse} = context;\n\n  let arrayBuffer;\n\n  if (image.uri && !image.hasOwnProperty('bufferView')) {\n    const uri = resolveUrl(image.uri, options);\n    const response = await fetch(uri);\n    arrayBuffer = await response.arrayBuffer();\n    image.bufferView = {\n      data: arrayBuffer\n    };\n  }\n\n  if (Number.isFinite(image.bufferView)) {\n    const array = getTypedArrayForBufferView(gltf.json, gltf.buffers, image.bufferView);\n    arrayBuffer = sliceArrayBuffer(array.buffer, array.byteOffset, array.byteLength);\n  }\n\n  assert(arrayBuffer, 'glTF image has no data');\n\n  // Call `parse`\n  let parsedImage = await parse(\n    arrayBuffer,\n    [ImageLoader, BasisLoader],\n    {mimeType: image.mimeType, basis: options.basis || {format: selectSupportedBasisFormat()}},\n    context\n  );\n\n  if (parsedImage && parsedImage[0]) {\n    parsedImage = {\n      compressed: true,\n      mipmaps: false,\n      width: parsedImage[0].width,\n      height: parsedImage[0].height,\n      data: parsedImage[0]\n    };\n  }\n  // TODO making sure ImageLoader is overridable by using array of loaders\n  // const parsedImage = await parse(arrayBuffer, [ImageLoader]);\n\n  // Store the loaded image\n  gltf.images = gltf.images || [];\n  gltf.images[index] = parsedImage;\n}\n"],"mappings":"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"}