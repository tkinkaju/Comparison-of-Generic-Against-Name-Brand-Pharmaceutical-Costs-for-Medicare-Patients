{"version":3,"file":"KHR_texture_transform.js","names":["EXT_MESHOPT_TRANSFORM","name","scratchVector","Vector3","scratchRotationMatrix","Matrix3","scratchScaleMatrix","decode","gltfData","options","gltfScenegraph","GLTFScenegraph","extension","getExtension","materials","json","i","length","transformTexCoords","materialIndex","processedTexCoords","material","baseColorTexture","pbrMetallicRoughness","transformPrimitives","emisiveTexture","emissiveTexture","normalTexture","occlusionTexture","metallicRoughnessTexture","texture","transformParameters","getTransformParameters","meshes","mesh","primitives","primitive","Number","isFinite","transformPrimitive","textureInfo","extensions","texCoord","originalTexCoord","isProcessed","findIndex","original","newTexCoord","matrix","makeTransformationMatrix","push","texCoordAccessor","attributes","accessor","accessors","bufferView","bufferViews","buffers","buffer","arrayBuffer","bufferByteOffset","byteOffset","getAccessorArrayTypeAndLength","ArrayType","bytes","BYTES","componentType","components","COMPONENTS","type","elementAddressScale","byteStride","result","Float32Array","count","uv","set","transformByMatrix3","updateGltf","createAttribute","newTexCoordArray","byteLength","originalAccessor","extensionData","offset","rotation","scale","translationMatirx","rotationMatirx","Math","cos","sin","scaleMatrix","multiplyRight"],"sources":["../../../../src/lib/extensions/KHR_texture_transform.ts"],"sourcesContent":["/**\n * https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_texture_transform/README.md\n */\n\nimport {Vector3, Matrix3} from '@math.gl/core';\nimport type {GLTFMeshPrimitive, GLTFWithBuffers} from '../types/gltf-types';\nimport type {GLTFLoaderOptions} from '../../gltf-loader';\nimport {getAccessorArrayTypeAndLength} from '../gltf-utils/gltf-utils';\nimport {BYTES, COMPONENTS} from '../gltf-utils/gltf-constants';\nimport {\n  Accessor,\n  BufferView,\n  MaterialNormalTextureInfo,\n  MaterialOcclusionTextureInfo,\n  TextureInfo as GLTFTextureInfo\n} from '../types/gltf-json-schema';\nimport GLTFScenegraph from '../api/gltf-scenegraph';\n\n/** Extension name */\nconst EXT_MESHOPT_TRANSFORM = 'KHR_texture_transform';\n\nexport const name = EXT_MESHOPT_TRANSFORM;\n\nconst scratchVector = new Vector3();\nconst scratchRotationMatrix = new Matrix3();\nconst scratchScaleMatrix = new Matrix3();\n\n/** Extension textureInfo https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_texture_transform#gltf-schema-updates */\ntype TextureInfo = {\n  /** The offset of the UV coordinate origin as a factor of the texture dimensions. */\n  offset?: [number, number];\n  /** Rotate the UVs by this many radians counter-clockwise around the origin. This is equivalent to a similar rotation of the image clockwise. */\n  rotation?: number;\n  /** The scale factor applied to the components of the UV coordinates. */\n  scale?: [number, number];\n  /** Overrides the textureInfo texCoord value if supplied, and if this extension is supported. */\n  texCoord?: number;\n};\n/** Intersection of all GLTF textures */\ntype CompoundGLTFTextureInfo = GLTFTextureInfo &\n  MaterialNormalTextureInfo &\n  MaterialOcclusionTextureInfo;\n/** Parameters for TEXCOORD transformation */\ntype TransformParameters = {\n  /** Original texCoord value https://www.khronos.org/registry/glTF/specs/2.0/glTF-2.0.html#_textureinfo_texcoord */\n  originalTexCoord: number;\n  /** New texCoord value from extension https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_texture_transform#gltf-schema-updates */\n  texCoord: number;\n  /** Transformation matrix */\n  matrix: Matrix3;\n};\n\n/**\n * The extension entry to process the transformation\n * @param gltfData gltf buffers and json\n * @param options GLTFLoader options\n */\nexport async function decode(gltfData: GLTFWithBuffers, options: GLTFLoaderOptions) {\n  const gltfScenegraph = new GLTFScenegraph(gltfData);\n  const extension = gltfScenegraph.getExtension(EXT_MESHOPT_TRANSFORM);\n  if (!extension) {\n    return;\n  }\n  const materials = gltfData.json.materials || [];\n  for (let i = 0; i < materials.length; i++) {\n    transformTexCoords(i, gltfData);\n  }\n}\n\n/**\n * Transform TEXCOORD by material\n * @param materialIndex processing material index\n * @param gltfData gltf buffers and json\n */\nfunction transformTexCoords(materialIndex: number, gltfData: GLTFWithBuffers): void {\n  // Save processed texCoords in order no to process the same twice\n  const processedTexCoords: [number, number][] = [];\n  const material = gltfData.json.materials?.[materialIndex];\n  const baseColorTexture = material?.pbrMetallicRoughness?.baseColorTexture;\n  if (baseColorTexture) {\n    transformPrimitives(gltfData, materialIndex, baseColorTexture, processedTexCoords);\n  }\n  const emisiveTexture = material?.emissiveTexture;\n  if (emisiveTexture) {\n    transformPrimitives(gltfData, materialIndex, emisiveTexture, processedTexCoords);\n  }\n  const normalTexture = material?.normalTexture;\n  if (normalTexture) {\n    transformPrimitives(gltfData, materialIndex, normalTexture, processedTexCoords);\n  }\n  const occlusionTexture = material?.occlusionTexture;\n  if (occlusionTexture) {\n    transformPrimitives(gltfData, materialIndex, occlusionTexture, processedTexCoords);\n  }\n  const metallicRoughnessTexture = material?.pbrMetallicRoughness?.metallicRoughnessTexture;\n  if (metallicRoughnessTexture) {\n    transformPrimitives(gltfData, materialIndex, metallicRoughnessTexture, processedTexCoords);\n  }\n}\n\n/**\n * Transform primitives of the particular material\n * @param gltfData gltf data\n * @param materialIndex primitives with this material will be transformed\n * @param texture texture object\n * @param processedTexCoords storage to save already processed texCoords\n */\nfunction transformPrimitives(\n  gltfData: GLTFWithBuffers,\n  materialIndex: number,\n  texture: CompoundGLTFTextureInfo,\n  processedTexCoords: [number, number][]\n) {\n  const transformParameters = getTransformParameters(texture, processedTexCoords);\n  if (!transformParameters) {\n    return;\n  }\n  const meshes = gltfData.json.meshes || [];\n  for (const mesh of meshes) {\n    for (const primitive of mesh.primitives) {\n      const material = primitive.material;\n      if (Number.isFinite(material) && materialIndex === material) {\n        transformPrimitive(gltfData, primitive, transformParameters);\n      }\n    }\n  }\n}\n\n/**\n * Get parameters for TEXCOORD transformation\n * @param texture texture object\n * @param processedTexCoords storage to save already processed texCoords\n * @returns texCoord couple and transformation matrix\n */\nfunction getTransformParameters(\n  texture: CompoundGLTFTextureInfo,\n  processedTexCoords: [number, number][]\n): TransformParameters | null {\n  const textureInfo = texture.extensions?.[EXT_MESHOPT_TRANSFORM];\n  const {texCoord: originalTexCoord = 0} = texture;\n  // If texCoord is not set in the extension, original attribute data will be replaced\n  const {texCoord = originalTexCoord} = textureInfo;\n  // Make sure that couple [originalTexCoord, extensionTexCoord] is not processed twice\n  const isProcessed =\n    processedTexCoords.findIndex(\n      ([original, newTexCoord]) => original === originalTexCoord && newTexCoord === texCoord\n    ) !== -1;\n  if (!isProcessed) {\n    const matrix = makeTransformationMatrix(textureInfo);\n    if (originalTexCoord !== texCoord) {\n      texture.texCoord = texCoord;\n    }\n    processedTexCoords.push([originalTexCoord, texCoord]);\n    return {originalTexCoord, texCoord, matrix};\n  }\n  return null;\n}\n\n/**\n * Transform `TEXCOORD_0` attribute in the primitive\n * @param gltfData gltf data\n * @param primitive primitive object\n * @param transformParameters texCoord couple and transformation matrix\n */\nfunction transformPrimitive(\n  gltfData: GLTFWithBuffers,\n  primitive: GLTFMeshPrimitive,\n  transformParameters: TransformParameters\n) {\n  const {originalTexCoord, texCoord, matrix} = transformParameters;\n  const texCoordAccessor = primitive.attributes[`TEXCOORD_${originalTexCoord}`];\n  if (Number.isFinite(texCoordAccessor)) {\n    // Get accessor of the `TEXCOORD_0` attribute\n    const accessor = gltfData.json.accessors?.[texCoordAccessor];\n    if (accessor && accessor.bufferView) {\n      // Get `bufferView` of the `accessor`\n      const bufferView = gltfData.json.bufferViews?.[accessor.bufferView];\n      if (bufferView) {\n        // Get `arrayBuffer` the `bufferView` look at\n        const {arrayBuffer, byteOffset: bufferByteOffset} = gltfData.buffers[bufferView.buffer];\n        // Resulting byteOffset is sum of the buffer, accessor and bufferView byte offsets\n        const byteOffset =\n          (bufferByteOffset || 0) + (accessor.byteOffset || 0) + (bufferView.byteOffset || 0);\n        // Deduce TypedArray type and its length from `accessor` and `bufferView` data\n        const {ArrayType, length} = getAccessorArrayTypeAndLength(accessor, bufferView);\n        // Number of bytes each component occupies\n        const bytes = BYTES[accessor.componentType];\n        // Number of components. For the `TEXCOORD_0` with `VEC2` type, it must return 2\n        const components = COMPONENTS[accessor.type];\n        // Multiplier to calculate the address of the `TEXCOORD_0` element in the arrayBuffer\n        const elementAddressScale = bufferView.byteStride || bytes * components;\n        // Data transform to Float32Array\n        const result = new Float32Array(length);\n        for (let i = 0; i < accessor.count; i++) {\n          // Take [u, v] couple from the arrayBuffer\n          const uv = new ArrayType(arrayBuffer, byteOffset + i * elementAddressScale, 2);\n          // Set and transform Vector3 per https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_texture_transform#overview\n          scratchVector.set(uv[0], uv[1], 1);\n          scratchVector.transformByMatrix3(matrix);\n          // Save result in Float32Array\n          result.set([scratchVector[0], scratchVector[1]], i * components);\n        }\n        // If texCoord the same, replace gltf structural data\n        if (originalTexCoord === texCoord) {\n          updateGltf(accessor, bufferView, gltfData.buffers, result);\n        } else {\n          // If texCoord change, create new attribute\n          createAttribute(texCoord, accessor, primitive, gltfData, result);\n        }\n      }\n    }\n  }\n}\n\n/**\n * Update GLTF structural objects with new data as we create new `Float32Array` for `TEXCOORD_0`.\n * @param accessor accessor to change\n * @param bufferView bufferView to change\n * @param buffers binary buffers\n * @param newTexcoordArray typed array with data after transformation\n */\nfunction updateGltf(\n  accessor: Accessor,\n  bufferView: BufferView,\n  buffers: {arrayBuffer: ArrayBuffer; byteOffset: number; byteLength: number}[],\n  newTexCoordArray: Float32Array\n): void {\n  accessor.componentType = 5126;\n  buffers.push({\n    arrayBuffer: newTexCoordArray.buffer,\n    byteOffset: 0,\n    byteLength: newTexCoordArray.buffer.byteLength\n  });\n  bufferView.buffer = buffers.length - 1;\n  bufferView.byteLength = newTexCoordArray.buffer.byteLength;\n  bufferView.byteOffset = 0;\n  delete bufferView.byteStride;\n}\n\n/**\n *\n * @param newTexCoord new `texCoord` value\n * @param originalAccessor original accessor object, that store data before transformation\n * @param primitive primitive object\n * @param gltfData gltf data\n * @param newTexCoordArray typed array with data after transformation\n * @returns\n */\nfunction createAttribute(\n  newTexCoord: number,\n  originalAccessor: Accessor,\n  primitive: GLTFMeshPrimitive,\n  gltfData: GLTFWithBuffers,\n  newTexCoordArray: Float32Array\n) {\n  gltfData.buffers.push({\n    arrayBuffer: newTexCoordArray.buffer,\n    byteOffset: 0,\n    byteLength: newTexCoordArray.buffer.byteLength\n  });\n  const bufferViews = gltfData.json.bufferViews;\n  if (!bufferViews) {\n    return;\n  }\n  bufferViews.push({\n    buffer: gltfData.buffers.length - 1,\n    byteLength: newTexCoordArray.buffer.byteLength,\n    byteOffset: 0\n  });\n  const accessors = gltfData.json.accessors;\n  if (!accessors) {\n    return;\n  }\n  accessors.push({\n    bufferView: bufferViews?.length - 1,\n    byteOffset: 0,\n    componentType: 5126,\n    count: originalAccessor.count,\n    type: 'VEC2'\n  });\n  primitive.attributes[`TEXCOORD_${newTexCoord}`] = accessors.length - 1;\n}\n\n/**\n * Construct transformation matrix from the extension data (transition, rotation, scale)\n * @param extensionData extension data\n * @returns transformation matrix\n */\nfunction makeTransformationMatrix(extensionData: TextureInfo): Matrix3 {\n  const {offset = [0, 0], rotation = 0, scale = [1, 1]} = extensionData;\n  const translationMatirx = new Matrix3().set(1, 0, 0, 0, 1, 0, offset[0], offset[1], 1);\n  const rotationMatirx = scratchRotationMatrix.set(\n    Math.cos(rotation),\n    Math.sin(rotation),\n    0,\n    -Math.sin(rotation),\n    Math.cos(rotation),\n    0,\n    0,\n    0,\n    1\n  );\n  const scaleMatrix = scratchScaleMatrix.set(scale[0], 0, 0, 0, scale[1], 0, 0, 0, 1);\n  return translationMatirx.multiplyRight(rotationMatirx).multiplyRight(scaleMatrix);\n}\n"],"mappings":"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"}