{"version":3,"file":"parse-to-image.js","names":["parseToImage","arrayBuffer","options","url","blobOrDataUrl","getBlobOrSVGDataUrl","URL","self","webkitURL","objectUrl","createObjectURL","loadToImage","revokeObjectURL","image","Image","src","decode","Promise","resolve","reject","onload","onerror","err","Error","error"],"sources":["../../../../src/lib/parsers/parse-to-image.ts"],"sourcesContent":["import type {ImageLoaderOptions} from '../../image-loader';\nimport {getBlobOrSVGDataUrl} from './svg-utils';\n\n// Parses html image from array buffer\nexport default async function parseToImage(\n  arrayBuffer: ArrayBuffer,\n  options: ImageLoaderOptions,\n  url?: string\n): Promise<HTMLImageElement> {\n  // Note: image parsing requires conversion to Blob (for createObjectURL).\n  // Potentially inefficient for not using `response.blob()` (and for File / Blob inputs)...\n  // But presumably not worth adding 'blob' flag to loader objects?\n\n  const blobOrDataUrl = getBlobOrSVGDataUrl(arrayBuffer, url);\n  const URL = self.URL || self.webkitURL;\n  const objectUrl = typeof blobOrDataUrl !== 'string' && URL.createObjectURL(blobOrDataUrl);\n  try {\n    return await loadToImage(objectUrl || blobOrDataUrl, options);\n  } finally {\n    if (objectUrl) {\n      URL.revokeObjectURL(objectUrl);\n    }\n  }\n}\n\nexport async function loadToImage(url, options): Promise<HTMLImageElement> {\n  const image = new Image();\n  image.src = url;\n\n  // The `image.onload()` callback does not guarantee that the image has been decoded\n  // so a main thread \"freeze\" can be incurred when using the image for the first time.\n  // `Image.decode()` returns a promise that completes when image is decoded.\n\n  // https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/decode\n  // Note: When calling `img.decode()`, we do not need to wait for `img.onload()`\n  // Note: `HTMLImageElement.decode()` is not available in Edge and IE11\n  if (options.image && options.image.decode && image.decode) {\n    await image.decode();\n    return image;\n  }\n\n  // Create a promise that tracks onload/onerror callbacks\n  return await new Promise((resolve, reject) => {\n    try {\n      image.onload = () => resolve(image);\n      image.onerror = (err) => reject(new Error(`Could not load image ${url}: ${err}`));\n    } catch (error) {\n      reject(error);\n    }\n  });\n}\n"],"mappings":";;;;;;;;;;AACA;AAAgD,SAGlBA,YAAY;EAAA;AAAA;AAAA;EAAA,0EAA3B,iBACbC,WAAwB,EACxBC,OAA2B,EAC3BC,GAAY;IAAA;IAAA;MAAA;QAAA;UAAA;YAMNC,aAAa,GAAG,IAAAC,6BAAmB,EAACJ,WAAW,EAAEE,GAAG,CAAC;YACrDG,GAAG,GAAGC,IAAI,CAACD,GAAG,IAAIC,IAAI,CAACC,SAAS;YAChCC,SAAS,GAAG,OAAOL,aAAa,KAAK,QAAQ,IAAIE,GAAG,CAACI,eAAe,CAACN,aAAa,CAAC;YAAA;YAAA;YAAA,OAE1EO,WAAW,CAACF,SAAS,IAAIL,aAAa,EAAEF,OAAO,CAAC;UAAA;YAAA;UAAA;YAAA;YAE7D,IAAIO,SAAS,EAAE;cACbH,GAAG,CAACM,eAAe,CAACH,SAAS,CAAC;YAChC;YAAC;UAAA;UAAA;YAAA;QAAA;MAAA;IAAA;EAAA,CAEJ;EAAA;AAAA;AAAA,SAEqBE,WAAW;EAAA;AAAA;AAAA;EAAA,yEAA1B,kBAA2BR,GAAG,EAAED,OAAO;IAAA;IAAA;MAAA;QAAA;UAAA;YACtCW,KAAK,GAAG,IAAIC,KAAK,EAAE;YACzBD,KAAK,CAACE,GAAG,GAAGZ,GAAG;;YAAC,MASZD,OAAO,CAACW,KAAK,IAAIX,OAAO,CAACW,KAAK,CAACG,MAAM,IAAIH,KAAK,CAACG,MAAM;cAAA;cAAA;YAAA;YAAA;YAAA,OACjDH,KAAK,CAACG,MAAM,EAAE;UAAA;YAAA,kCACbH,KAAK;UAAA;YAAA;YAAA,OAID,IAAII,OAAO,CAAC,UAACC,OAAO,EAAEC,MAAM,EAAK;cAC5C,IAAI;gBACFN,KAAK,CAACO,MAAM,GAAG;kBAAA,OAAMF,OAAO,CAACL,KAAK,CAAC;gBAAA;gBACnCA,KAAK,CAACQ,OAAO,GAAG,UAACC,GAAG;kBAAA,OAAKH,MAAM,CAAC,IAAII,KAAK,gCAAyBpB,GAAG,eAAKmB,GAAG,EAAG,CAAC;gBAAA;cACnF,CAAC,CAAC,OAAOE,KAAK,EAAE;gBACdL,MAAM,CAACK,KAAK,CAAC;cACf;YACF,CAAC,CAAC;UAAA;YAAA;UAAA;UAAA;YAAA;QAAA;MAAA;IAAA;EAAA,CACH;EAAA;AAAA"}