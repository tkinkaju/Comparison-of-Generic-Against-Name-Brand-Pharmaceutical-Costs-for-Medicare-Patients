{"version":3,"file":"maps.cjs.js","sources":["../src/errors.ts","../src/utils.ts","../src/Client.ts"],"sourcesContent":["import { Credentials } from '@carto/toolkit-core';\n\nconst unauthorized = (credentials: Credentials) => {\n  throw new Error(\n      `Unauthorized access to Maps API: invalid combination of user ('${credentials.username}') and apiKey ('${credentials.apiKey}')`\n    );\n};\n\nconst unauthorizedDataset = (credentials: Credentials) => {\n  throw new Error(\n      `Unauthorized access to dataset: the provided apiKey('${credentials.apiKey}') doesn't provide access to the requested data`\n    );\n};\n\nexport default {\n  [401 as number]: unauthorized,\n  [403 as number]: unauthorizedDataset\n};\n","export function getRequest(url: string) {\n  return new Request(url, {\n    method: 'GET',\n    headers: {\n      Accept: 'application/json'\n    }\n  });\n}\n\nexport function postRequest(url: string, payload: string) {\n  return new Request(url, {\n    method: 'POST',\n    headers: {\n      'Accept': 'application/json',\n      'Content-Type': 'application/json'\n    },\n    body: payload\n  });\n}\n\nexport function encodeParameter(name: string, value: string) {\n  return `${name}=${encodeURIComponent(value)}`;\n}\n","import { Credentials } from '@carto/toolkit-core';\nimport errorHandlers from './errors';\nimport { encodeParameter, getRequest, postRequest } from './utils';\n\nconst REQUEST_GET_MAX_URL_LENGTH = 2048;\n\nexport class Maps {\n  private _credentials: Credentials;\n\n  constructor(credentials: Credentials) {\n    this._credentials = credentials;\n  }\n\n  /**\n   * Instantiate a map based on dataset name or a sql query, returning a layergroup\n   *\n   * @param options\n   */\n  public async instantiateMapFrom(options: MapOptions) {\n    const { sql, dataset, vector_extent, vector_simplify_extent } = options;\n\n    if (!(sql || dataset)) {\n      throw new Error('Please provide a dataset or a SQL query');\n    }\n\n    const mapConfig = {\n      layers: [{\n        type: 'cartodb',\n        options: {\n          sql: sql || `select * from ${dataset}`,\n          vector_extent: vector_extent || 2048,\n          vector_simplify_extent: vector_simplify_extent || 2048\n        }\n      }],\n      version: '1.3.1'\n    };\n\n    return this.instantiateMap(mapConfig);\n  }\n\n  private async instantiateMap(mapConfig: any) {\n    let response;\n    try {\n      const payload = JSON.stringify(mapConfig);\n      response = await fetch(this.makeMapsApiRequest(payload));\n    } catch (error) {\n      throw new Error(`Failed to connect to Maps API with the user ('${this._credentials.username}'): ${error}`);\n    }\n\n    const layergroup = await response.json();\n    if (!response.ok) {\n      this.dealWithWindshaftErrors(response, layergroup);\n    }\n\n    return layergroup;\n  }\n\n  private makeMapsApiRequest(config: string) {\n    const encodedApiKey = encodeParameter('api_key', this._credentials.apiKey);\n    const parameters = [encodedApiKey];\n    const url = this.generateMapsApiUrl(parameters);\n\n    const getUrl = `${url}&${encodeParameter('config', config)}`;\n    if (getUrl.length < REQUEST_GET_MAX_URL_LENGTH) {\n      return getRequest(getUrl);\n    }\n\n    return postRequest(url, config);\n  }\n\n  private dealWithWindshaftErrors(response: { status: number }, layergroup: any) {\n    const errorForCode = errorHandlers[response.status];\n    if (errorForCode) {\n      errorForCode(this._credentials);\n      return;\n    }\n    throw new Error(`${JSON.stringify(layergroup.errors)}`);\n  }\n\n  private generateMapsApiUrl(parameters: string[] = []) {\n    const base = `${this._credentials.serverURL}/api/v1/map`;\n    return `${base}?${parameters.join('&')}`;\n  }\n}\n\nexport interface MapOptions {\n  sql?: string;\n  dataset?: string;\n  vector_extent: number;\n  vector_simplify_extent: number;\n}\n"],"names":["credentials","Error","username","apiKey","_a","encodeParameter","name","value","encodeURIComponent","this","_credentials","Maps","options","sql","dataset","vector_extent","vector_simplify_extent","mapConfig","layers","type","version","instantiateMap","payload","JSON","stringify","fetch","makeMapsApiRequest","response","error_1","json","layergroup","ok","dealWithWindshaftErrors","config","parameters","url","generateMapsApiUrl","getUrl","length","Request","method","headers","Accept","getRequest","Content-Type","body","postRequest","errorForCode","errorHandlers","status","errors","serverURL","join"],"mappings":";;;;;;;;;;;;;;;22CAEA,cAaG,KAbkB,SAACA,GACpB,MAAM,IAAIC,MACN,kEAAkED,EAAYE,4BAA2BF,EAAYG,cAYzHC,EAAC,KARyB,SAACJ,GAC3B,MAAM,IAAIC,MACN,wDAAwDD,EAAYG,uECU1DE,EAAgBC,EAAcC,GAC5C,OAAUD,MAAQE,mBAAmBD,GCjBvC,iBAKE,WAAYP,GACVS,KAAKC,aAAeV,EAyExB,OAjEeW,+BAAb,SAAgCC,oFAG9B,GAFQC,EAAwDD,MAAnDE,EAAmDF,UAA1CG,EAA0CH,gBAA3BI,EAA2BJ,0BAE1DC,IAAOC,EACX,MAAM,IAAIb,MAAM,2CAelB,OAZMgB,EAAY,CAChBC,OAAQ,CAAC,CACPC,KAAM,UACNP,QAAS,CACPC,IAAKA,GAAO,iBAAiBC,EAC7BC,cAAeA,GAAiB,KAChCC,uBAAwBA,GAA0B,QAGtDI,QAAS,YAGJX,KAAKY,eAAeJ,WAGfN,2BAAd,SAA6BM,yGAId,6BADLK,EAAUC,KAAKC,UAAUP,MACdQ,MAAMhB,KAAKiB,mBAAmBJ,mBAA/CK,EAAWvB,sBAEX,iBAAM,IAAIH,MAAM,iDAAiDQ,KAAKC,aAAaR,gBAAe0B,UAGjF,SAAMD,EAASE,eAKlC,OALMC,EAAa1B,SACduB,EAASI,IACZtB,KAAKuB,wBAAwBL,EAAUG,MAGlCA,WAGDnB,+BAAR,SAA2BsB,GACzB,IACMC,EAAa,CADG7B,EAAgB,UAAWI,KAAKC,aAAaP,SAE7DgC,EAAM1B,KAAK2B,mBAAmBF,GAE9BG,EAAYF,MAAO9B,EAAgB,SAAU4B,GACnD,OAAII,EAAOC,OA3DoB,cDJRH,GACzB,OAAO,IAAII,QAAQJ,EAAK,CACtBK,OAAQ,MACRC,QAAS,CACPC,OAAQ,sBC4DDC,CAAWN,YDvDIF,EAAab,GACvC,OAAO,IAAIiB,QAAQJ,EAAK,CACtBK,OAAQ,OACRC,QAAS,CACPC,OAAU,mBACVE,eAAgB,oBAElBC,KAAMvB,ICmDCwB,CAAYX,EAAKF,IAGlBtB,oCAAR,SAAgCgB,EAA8BG,GAC5D,IAAMiB,EAAeC,EAAcrB,EAASsB,QAC5C,IAAIF,EAIJ,MAAM,IAAI9C,MAAM,GAAGsB,KAAKC,UAAUM,EAAWoB,SAH3CH,EAAatC,KAAKC,eAMdC,+BAAR,SAA2BuB,GAEzB,oBAFyBA,MACTzB,KAAKC,aAAayC,4BAChBjB,EAAWkB,KAAK"}