{"version":3,"file":"sql.cjs.js","sources":["../src/constants.ts","../src/RequestManager.ts","../src/CopyFromManager.ts","../src/CopyToManager.ts","../src/DDL.ts","../src/QueryManager.ts","../src/Client.ts"],"sourcesContent":["export const QUERY_LIMIT = 1024;\nexport const DEFAULT_MAX_API_REQUESTS_RETRIES = 0;\n\nexport const HTTP_ERRORS = {\n  TOO_MANY_REQUESTS: 429,\n  SERVICE_UNAVAILABLE: 503\n};\n","import { Credentials } from '@carto/toolkit-core';\nimport { DEFAULT_MAX_API_REQUESTS_RETRIES, HTTP_ERRORS } from './constants';\n\ntype PromiseCb<T> = (value?: T) => void;\n\ninterface FetchArgs {\n  requestInfo: RequestInfo;\n  requestInit: RequestInit | undefined;\n  retries_count: number;\n  resolve: PromiseCb<any>;\n  reject: PromiseCb<Error | string>;\n}\n\nconst UNKNOWN = -1;\nconst NO_RETRY = -1;\nconst RETRY_MIN_WAIT = 0.5;\n\nexport class RequestManager {\n  private _credentials: Credentials;\n  private _endpointServerURL: string;\n\n  private _queue: FetchArgs[];\n  private _callsLeft: number = UNKNOWN;\n  private _retryAfter: number = UNKNOWN;\n  private _retryTimeoutId: number = UNKNOWN;\n  private _fetching: boolean = false;\n  private _scheduleDebounce: number = UNKNOWN;\n  private _maxApiRequestsRetries: number = DEFAULT_MAX_API_REQUESTS_RETRIES;\n\n  constructor(\n    credentials: Credentials,\n    endpointServerURL: string,\n    { maxApiRequestsRetries }: { maxApiRequestsRetries?: number } = {}) {\n\n    this._credentials = credentials;\n    this._endpointServerURL = endpointServerURL;\n\n    this._queue = [];\n\n    if (Number.isFinite(maxApiRequestsRetries!) && maxApiRequestsRetries! >= 0) {\n      this._maxApiRequestsRetries = maxApiRequestsRetries!;\n    }\n  }\n\n  public get apiKey() {\n    return this._credentials.apiKey;\n  }\n\n  public set apiKey(value: string) {\n    this._credentials.apiKey = value;\n  }\n\n  protected get endpointServerURL() {\n    return this._endpointServerURL;\n  }\n\n  protected set callsLeft(value: number) {\n    this._callsLeft = value;\n  }\n\n  protected get callsLeft() {\n    return this._callsLeft;\n  }\n\n  protected set maxApiRequestsRetries(value: number) {\n    this._maxApiRequestsRetries = value;\n  }\n\n  protected _scheduleRequest(\n    resolve: PromiseCb<any>,\n    reject: PromiseCb<any>,\n    requestInfo: RequestInfo,\n    requestInit?: RequestInit) {\n\n    this._queue.push({ resolve, reject, requestInfo, requestInit, retries_count: NO_RETRY });\n\n    clearTimeout(this._scheduleDebounce);\n    this._scheduleDebounce = window.setTimeout(() => {\n      this._scheduler();\n    }, 0);\n  }\n\n  protected addHeadersTo(requestInit: any, headers: string[][] = []) {\n    if (requestInit === undefined) {\n      return;\n    }\n\n    if (!requestInit.headers) {\n      requestInit.headers = new Headers();\n    }\n\n    if (headers.length > 0) {\n      headers.forEach((header) => {\n        requestInit.headers.append(header[0], header[1]);\n      });\n    }\n  }\n\n  private _scheduler() {\n    if (this._queue.length === 0) {\n      return;\n    }\n\n    if (this._retryTimeoutId !== UNKNOWN || this._fetching) {\n      return;\n    }\n\n    if (this._retryAfter !== UNKNOWN) {\n      // This timeout waits for the minimum time to\n      // call scheduler and reset previous retry values\n      // It adds 1 to calls left because as we've waited for the\n      // limit to expire there should be one call available at least\n      // without taking into account other possible sources of requests\n      this._retryTimeoutId = window.setTimeout(() => {\n        this._retryTimeoutId = UNKNOWN;\n        this._retryAfter = UNKNOWN;\n        // Technically? But this is risky.\n        this._callsLeft += 1;\n        this._scheduler();\n      }, this._retryAfter * 1000);\n\n      return;\n    }\n\n    // Gets minimum number of requests left before reaching limits\n    // It should be whether the queue size, or _callsLeft variable\n    // which is set by Carto-Rate-Limit-Remaining header value\n    const nRequests = this._callsLeft !== -1\n      ? Math.min(Math.max(1, this._callsLeft), this._queue.length)\n      : 1;\n    const promises = [];\n\n    for (let i = 0; i < nRequests; i++) {\n      this._fetching = true;\n\n      promises.push(\n        this._fetch(this._queue[i], i)\n      );\n    }\n\n    Promise.all(promises).then((finishedPromises) => {\n      // Filter out the promises that have finished properly\n      this._queue = this._queue.filter((_e, i) => finishedPromises.indexOf(i) === -1);\n      this._fetching = false;\n\n      if (this._queue.length > 0) {\n        this._scheduler();\n      }\n    });\n  }\n\n  private _fetch(requestDefinition: FetchArgs, index: number): Promise<number | undefined> {\n    const {resolve, reject, requestInfo, requestInit, retries_count} = requestDefinition;\n\n    return fetch(requestInfo, requestInit)\n      .then(async (response) => {\n\n        this._retryAfter = this._getRateLimitHeader(response.headers, 'Retry-After', this._retryAfter);\n        this._callsLeft = this._getRateLimitHeader(response.headers, 'Carto-Rate-Limit-Remaining', this._callsLeft);\n\n        const responseBody = await getResponseBody(response);\n\n        const isTimeoutError = response.status === HTTP_ERRORS.TOO_MANY_REQUESTS &&\n          (responseBody.detail === 'datasource' || responseBody.detail === 'rate-limit');\n\n        if (response.status === HTTP_ERRORS.SERVICE_UNAVAILABLE || isTimeoutError) {\n          requestDefinition.retries_count = retries_count !== NO_RETRY\n            ? retries_count - 1\n            : this._maxApiRequestsRetries;\n\n          const timeToWait = (this._maxApiRequestsRetries - requestDefinition.retries_count)\n            * RETRY_MIN_WAIT + RETRY_MIN_WAIT;\n          this._retryAfter = Math.max(this._retryAfter, timeToWait);\n        }\n\n        if (requestDefinition.retries_count === 0) {\n          throw new Error('Too many retries');\n        }\n\n        if (\n          response.status === HTTP_ERRORS.TOO_MANY_REQUESTS ||\n          response.status === HTTP_ERRORS.SERVICE_UNAVAILABLE\n        ) {\n          // Reschedule\n          this._scheduler();\n          return null;\n        }\n\n        return responseBody;\n      })\n      .then((data) => {\n        if (data === null) {\n          return;\n        }\n\n        if (!data.error) {\n          resolve(data);\n        } else {\n          const message = data?.error?.length ? data.error[0] : 'Unknown error';\n          reject(new Error(message));\n        }\n\n        return index;\n      })\n      .catch((e) => {\n        reject(e);\n\n        // Return the index because this is likely an uncontrollable error\n        return index;\n      });\n  }\n\n  private _getRateLimitHeader(headers: Headers, name: string, defaultValue: number): number {\n    const value = headers.get(name);\n\n    if (value !== null) {\n      return parseInt(value, 10);\n    }\n\n    return defaultValue;\n  }\n\n  //#region Getters and setters\n\n  public get queued(): number {\n    return this._queue.length;\n  }\n\n  //#endregion\n}\n\nexport default RequestManager;\n\nasync function getResponseBody(response: Response) {\n  const contentType = response.headers.get('content-type') || '';\n\n  return contentType.includes('application/json')\n    ? await response.json()\n    : await response.text();\n}\n","import { Credentials, MetricsEvent } from '@carto/toolkit-core';\nimport RequestManager from './RequestManager';\n\nexport class CopyFromManager extends RequestManager {\n\n  constructor(credentials: Credentials, options: { maxApiRequestsRetries?: number } = {}) {\n    const endpointServerURL = credentials.serverURL + 'api/v2/sql/copyfrom';\n    super(credentials, endpointServerURL, options);\n  }\n\n  public copy(csv: string, tableName: string, fields: string[], options: { event?: MetricsEvent } = {}) {\n    const query = `COPY ${tableName} (${fields}) FROM STDIN WITH (FORMAT csv, HEADER true);`;\n    const url = `${this.endpointServerURL}?api_key=${this.apiKey}&q=${query}`;\n    const file = new Blob([csv]);\n\n    const requestInit = {\n      method: 'POST',\n      body: file,\n    };\n\n    const customHeaders = options.event ? options.event.getHeaders() : [];\n    this.addHeadersTo(requestInit, customHeaders);\n\n    return new Promise((resolve, reject) => {\n      this._scheduleRequest(resolve, reject, url, requestInit);\n    });\n  }\n}\n","import { Credentials } from '@carto/toolkit-core';\nimport RequestManager from './RequestManager';\n\nconst DEFAULT_FILENAME = 'carto_copyto.csv';\nconst DEFAULT_OPTIONS = 'FORMAT csv, HEADER true';\n\nexport class CopyToManager extends RequestManager {\n\n  constructor(credentials: Credentials, options: { maxApiRequestsRetries?: number } = {}) {\n    const endpointServerURL = credentials.serverURL + 'api/v2/sql/copyto';\n    super(credentials, endpointServerURL, options);\n  }\n\n  public copyUrl(q: string, filename: string = DEFAULT_FILENAME, options: string = DEFAULT_OPTIONS) {\n    const query = `COPY (${q}) TO stdout WITH(${options})`;\n    const url = `${this.endpointServerURL}?api_key=${this.apiKey}&q=${query}&filename=${filename}`;\n    return url;\n  }\n\n  /**\n   * Copy a query or a table to stdout\n   *\n   * @param {string} q\n   * @memberof CopyToManager\n   */\n  public copy(q: string, filename: string, options: string) {\n    const url = this.copyUrl(q, filename, options);\n\n    return new Promise((resolve, reject) => {\n      this._scheduleRequest(resolve, reject, url);\n    });\n  }\n}\n","// Some common aliases\nconst TYPE_MAP = {\n  string: 'text',\n  integer: 'numeric',\n  geojson: 'json'\n} as {\n  [key: string]: string\n};\n\nexport interface ColumConfig {\n  /**\n   * Name of the column\n   */\n  name: string;\n\n  /**\n   * PostgreSQL column's type\n   */\n  type: string;\n\n  /**\n   * Extra information to append in column creation\n   */\n  extra?: string;\n\n  /**\n   * Avoid adding property when inserting a new row in the table\n   */\n  omitOnInsert?: boolean;\n\n  /**\n   * Formatting for column value before being appended to SQL sentence\n   */\n  format?: (value: any) => boolean | string | null;\n}\n\nexport interface DropOptions {\n  ifExists?: boolean;\n}\n\nexport interface CreateConfig {\n  ifNotExists?: boolean;\n}\n\nexport class DDL {\n  public static drop(tableName: string, options?: any) {\n    if (options && options.ifExists) {\n      return `DROP TABLE IF EXISTS ${tableName};`;\n    }\n\n    return `DROP TABLE ${tableName};`;\n  }\n\n  public static create(tableName: string, rows: Array<ColumConfig | string>, options?: any) {\n    let template = `CREATE TABLE ${tableName} ({rows});`;\n\n    if (options && options.ifNotExists) {\n      template = `CREATE TABLE IF NOT EXISTS ${tableName} ({rows});`;\n    }\n\n    const sqlRows = rows.map((row) => {\n      if (typeof row === 'string') {\n        return row;\n      }\n\n      row.type = parseRowType(row.type);\n\n      const rowStr = `\"${row.name}\" ${row.type}`;\n\n      return row.extra ? `${rowStr} ${row.extra}` : rowStr;\n    }).join(', ');\n\n    return template.replace(/{rows}/, sqlRows);\n  }\n}\n\nfunction parseRowType(value: string): string {\n  return TYPE_MAP[value] || value;\n}\n\nexport default DDL;\n","import { Credentials, MetricsEvent } from '@carto/toolkit-core';\nimport { QUERY_LIMIT } from './constants';\nimport RequestManager from './RequestManager';\n\nexport type Pair<T> = [T, T];\nexport class QueryManager extends RequestManager {\n\n  constructor(credentials: Credentials, options: { maxApiRequestsRetries?: number } = {}) {\n    const endpointServerURL = credentials.serverURL + 'api/v2/sql';\n    super(credentials, endpointServerURL, options);\n  }\n\n  public query(\n    q: string,\n    options: {\n      extraParams?: Array<Pair<string>>,\n      event?: MetricsEvent\n    } = {}\n   ) {\n\n    const urlParams = [\n      ['api_key', this.apiKey],\n      ['q', q]\n    ];\n    if (options.extraParams) {\n      urlParams.push(...options.extraParams);\n    }\n\n    const customHeaders = options.event ? options.event.getHeaders() : [];\n\n    if (q.length < QUERY_LIMIT) {\n      return this.prepareGetRequest(urlParams, customHeaders);\n    } else {\n      return this.preparePostRequest(urlParams, customHeaders);\n    }\n  }\n\n  private prepareGetRequest(urlParams: string[][], customHeaders: string[][] = []) {\n    const stringParams = encodeURI(urlParams.map(\n      (param) => `${param[0]}=${param[1]}`\n    ).join('&'));\n\n    const requestInit = {\n      method: 'GET'\n    };\n    this.addHeadersTo(requestInit, customHeaders);\n\n    return new Promise((resolve, reject) => {\n      this._scheduleRequest(\n        resolve,\n        reject,\n        `${this.endpointServerURL}?${stringParams}`,\n        requestInit\n      );\n    });\n  }\n\n  private preparePostRequest(urlParams: string[][], customHeaders: string[][] = []) {\n    const formData = new FormData();\n\n    urlParams.forEach((value) => formData.set(value[0], value[1]));\n\n    const requestInit = {\n      method: 'POST',\n      body: formData\n    };\n    this.addHeadersTo(requestInit, customHeaders);\n\n    return new Promise((resolve, reject) => {\n      this._scheduleRequest(\n        resolve,\n        reject,\n        `${this.endpointServerURL}`,\n        requestInit\n      );\n    });\n  }\n}\n","import { Credentials, MetricsEvent } from '@carto/toolkit-core';\nimport { CopyFromManager } from './CopyFromManager';\nimport { CopyToManager } from './CopyToManager';\nimport DDL, { ColumConfig, CreateConfig, DropOptions } from './DDL';\nimport { Pair, QueryManager } from './QueryManager';\n\nconst PUBLIC_USER = 'publicuser';\n\nexport class SQL {\n  private _copyToManager: CopyToManager;\n  private _queryManager: QueryManager;\n  private _copyFromManager: CopyFromManager;\n  private _publicQueryManager: QueryManager;\n\n  private _publicRole?: string;\n  private _credentials: Credentials;\n\n  constructor(\n    credentials: Credentials,\n    { maxApiRequestsRetries }: { maxApiRequestsRetries?: number } = {}\n  ) {\n    this._credentials = credentials;\n\n    this._copyToManager = new CopyToManager(this._credentials, { maxApiRequestsRetries });\n    this._queryManager = new QueryManager(this._credentials, { maxApiRequestsRetries });\n    this._copyFromManager = new CopyFromManager(this._credentials, { maxApiRequestsRetries });\n\n    const publicCredentials = new Credentials(\n      credentials.username,\n      Credentials.DEFAULT_PUBLIC_API_KEY,\n      credentials.serverUrlTemplate\n    );\n    this._publicQueryManager = new QueryManager(publicCredentials, { maxApiRequestsRetries });\n  }\n\n  public static get DDL() {\n    return DDL;\n  }\n\n  public copyFrom(csv: string, tableName: string, fields: string[], options: { event?: MetricsEvent } = {}) {\n    return this._copyFromManager.copy(csv, tableName, fields, options);\n  }\n\n  public exportURL(q: string) {\n    return this._copyToManager.copyUrl(q);\n  }\n\n  public query(\n    q: string,\n    options: {\n       extraParams?: Array<Pair<string>>,\n       event?: MetricsEvent\n      } = {} ) {\n\n    const cleanQuery = q.replace(/\\s+/g, ' ').trim();\n    return this._queryManager.query(cleanQuery, options);\n  }\n\n  public truncate(tableName: string) {\n    return this._queryManager.query(`TRUNCATE ${tableName};`);\n  }\n\n  public create(\n    name: string,\n    colConfig: Array<ColumConfig | string>,\n    options: {\n      createOptions?: CreateConfig,\n      event?: MetricsEvent\n    } = {}) {\n\n    const query = DDL.create(name, colConfig, options.createOptions);\n    return this._queryManager.query(query, { event: options.event });\n  }\n\n  public drop(\n    name: string,\n    options: {\n      dropOptions?: DropOptions,\n      event?: MetricsEvent\n    } = {}\n    ) {\n\n    const query = DDL.drop(name, options.dropOptions);\n    return this._queryManager.query(query, { event: options.event });\n  }\n\n  public async grantPublicRead(tableName: string, options: { event?: MetricsEvent } = {}) {\n    const role = this._publicRole || await this.getRole(options);\n\n    return this.grantReadToRole(tableName, role, options);\n  }\n\n  public grantReadToRole(tableName: string, role: string = PUBLIC_USER,  options: { event?: MetricsEvent } = {}) {\n    const query = `GRANT SELECT on ${tableName} TO \"${role}\"`;\n\n    return this.query(query, options);\n  }\n\n  public transaction(queries: string[]) {\n    const query = `\n      BEGIN;\n        ${queries.join('\\n')}\n      COMMIT;\n    `;\n\n    return this._queryManager.query(query);\n  }\n\n  public setApiKey(apiKey: string) {\n    this._credentials.apiKey = apiKey;\n\n    this._queryManager.apiKey = apiKey;\n    this._copyToManager.apiKey = apiKey;\n    this._copyFromManager.apiKey = apiKey;\n  }\n\n  private getRole(options: { event?: MetricsEvent } = {}): Promise<string> {\n    return this._publicQueryManager\n      .query(`SELECT current_user as rolename`, options)\n      .then((data: any) => {\n        if (data.error) {\n          throw new Error(data.error);\n        }\n\n        if (data.rows.length === 0) {\n          throw new Error('Cannot grant: got no current_user data');\n        }\n\n        const { rolename } = data.rows[0];\n\n        this._publicRole = rolename;\n\n        return rolename;\n      });\n  }\n}\n"],"names":["HTTP_ERRORS","TOO_MANY_REQUESTS","SERVICE_UNAVAILABLE","credentials","endpointServerURL","_a","maxApiRequestsRetries","this","_credentials","_endpointServerURL","_queue","Number","isFinite","_maxApiRequestsRetries","Object","RequestManager","apiKey","value","_callsLeft","resolve","reject","requestInfo","requestInit","push","retries_count","clearTimeout","_scheduleDebounce","window","setTimeout","_this","_scheduler","headers","undefined","Headers","length","forEach","header","append","_retryTimeoutId","_fetching","_retryAfter","nRequests","Math","min","max","promises","i","_fetch","Promise","all","then","finishedPromises","filter","_e","indexOf","requestDefinition","index","fetch","response","_getRateLimitHeader","getResponseBody","responseBody","isTimeoutError","status","detail","timeToWait","Error","data","error","message","catch","e","name","defaultValue","get","parseInt","includes","json","_b","text","options","serverURL","_super","__extends","CopyFromManager","csv","tableName","fields","query","url","method","body","Blob","customHeaders","event","getHeaders","addHeadersTo","_scheduleRequest","CopyToManager","q","filename","copyUrl","TYPE_MAP","string","integer","geojson","DDL","ifExists","rows","template","ifNotExists","sqlRows","map","row","type","rowStr","extra","join","replace","QueryManager","urlParams","extraParams","prepareGetRequest","preparePostRequest","stringParams","encodeURI","param","formData","FormData","set","_copyToManager","_queryManager","_copyFromManager","publicCredentials","Credentials","username","DEFAULT_PUBLIC_API_KEY","serverUrlTemplate","_publicQueryManager","SQL","copy","cleanQuery","trim","colConfig","create","createOptions","drop","dropOptions","_publicRole","getRole","role","grantReadToRole","queries","rolename"],"mappings":"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"}