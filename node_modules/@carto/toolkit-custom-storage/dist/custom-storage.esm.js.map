{"version":3,"file":"custom-storage.esm.js","sources":["../src/errors/DuplicatedDataset.ts","../src/errors/CustomStorageError.ts","../src/errors/ErrorCodes.ts","../src/sql/utils.ts","../src/sql/SQLStorage.ts","../src/CustomStorage.ts","../src/PublicStorageReader.ts","../src/sql/PublicSQLReader.ts"],"sourcesContent":["import { CustomStorageError } from './CustomStorageError';\nimport { DUPLICATED_DATASETS } from './ErrorCodes';\n\nexport class DuplicatedDatasetsError extends CustomStorageError {\n  public datasets: string[];\n\n  constructor(datasets: string[]) {\n    super(DUPLICATED_DATASETS, 'Some datasets are duplicated');\n\n    this.datasets = datasets;\n  }\n}\n","export class CustomStorageError {\n  public errorCode: string;\n  public message: string | undefined;\n\n  constructor(errorcode: string, message?: string) {\n    this.errorCode = errorcode;\n    this.message = message;\n  }\n}\n","export const DUPLICATED_DATASETS = 'DUPLICATED_DATASETS';\n\nexport default {\n  DUPLICATED_DATASETS\n};\n","import { MetricsEvent } from '@carto/toolkit-core';\nimport { SQL } from '@carto/toolkit-sql';\nimport { CompleteVisualization, Dataset, StoredDataset, StoredVisualization } from '../StorageRepository';\n\ntype Pair<T> = [T, T];\n\nexport interface TableNames {\n  vis: string;\n  datasets: string;\n  visToDatasets: string;\n}\n\nexport function rowToVisualization(row: any): StoredVisualization {\n  return {\n    id: row.id,\n    name: row.name,\n    description: row.description,\n    thumbnail: row.thumbnail,\n    isprivate: row.isprivate,\n    config: row.config,\n    lastmodified: row.lastmodified\n  };\n}\n\n/**\n * Get dataset file as CSV from SQL API\n *\n * TODO. Consider the use of copyTo API\n */\nexport async function getDatasetData(\n  name: string,\n  tablename: string,\n  client: SQL,\n  options: {\n    event?: MetricsEvent\n  } = {}\n  ): Promise<Dataset> {\n\n  const csvFormat: Array<Pair<string>> = [['format', 'csv']];\n  const queryOptions = {\n    extraParams: csvFormat,\n    event: options.event\n  };\n  const response: string | any = await client.query(`SELECT * FROM ${tablename}`, queryOptions);\n\n  // Something wrong has happened\n  if (typeof response !== 'string') {\n    throw new Error(response.error);\n  }\n\n  return {\n    name,\n    file: response\n  };\n}\n\nexport async function getDatasetsForVis(\n  tableNames: TableNames,\n  visId: string,\n  client: SQL,\n  options: {\n    event?: MetricsEvent\n  } = {}\n  ): Promise<StoredDataset[]> {\n\n  const datasetsResp: any = await (client).query(`\n    WITH datasets AS (SELECT dataset FROM ${tableNames.visToDatasets} WHERE vis = '${visId}')\n    SELECT t.id, t.name, t.tablename FROM ${tableNames.datasets} t, datasets u\n    WHERE t.id = u.dataset\n  `, options);\n\n  if (datasetsResp.error) {\n    throw new Error(datasetsResp.error);\n  }\n\n  return datasetsResp.rows;\n}\n\n\nexport async function getVisualization(\n  tableNames: TableNames,\n  id: string,\n  client: SQL,\n  options: {\n    event?: MetricsEvent\n  } = {}\n): Promise<CompleteVisualization | null> {\n\n  // The visualization\n  const response: any = await client.query(`SELECT * FROM ${tableNames.vis} WHERE id = '${id}'`, options);\n\n  if (response.error) {\n    throw new Error(response.error);\n  }\n  if (response.rows.length === 0) {\n    return null;\n  }\n  const vis = rowToVisualization(response.rows[0]);\n\n  // The relation table between visualization & datasets\n  const datasetsForViz = await getDatasetsForVis(tableNames, id, client, options);\n  if (datasetsForViz.length === 0) {\n    return {\n      vis,\n      datasets: []\n    };\n  }\n\n  // Download each dataset\n  const datasets: Dataset[] = await Promise.all(\n    datasetsForViz.map((dataset: StoredDataset) => getDatasetData(dataset.name, dataset.tablename, client, options))\n  );\n\n  return {\n    vis,\n    datasets\n  };\n}\n\nexport function generateVisTableName(namespace: string, isPublic: boolean, version: number) {\n  return `${namespace}_${isPublic ? 'public' : 'private'}_v${version}`;\n}\n\nexport function generateDatasetTableName(tableName: string) {\n  return `${tableName}_datasets`;\n}\n\n/**\n * This generates the table name for the N <-> M relationship between vis and datasets\n * @param tableName The base table name\n */\nexport function generateDatasetVisTableName(tableName: string) {\n  return `${tableName}_datasets_vis`;\n}\n","import { MetricsEvent } from '@carto/toolkit-core';\nimport { SQL } from '@carto/toolkit-sql';\nimport { ColumConfig, CreateConfig, DropOptions } from '@carto/toolkit-sql/dist/types/DDL';\nimport { DuplicatedDatasetsError } from '../errors/DuplicatedDataset';\nimport {\n  CompleteVisualization,\n  Dataset,\n  StoredDataset,\n  StoredVisualization,\n  Visualization\n} from '../StorageRepository';\nimport {\n  generateDatasetTableName,\n  generateDatasetVisTableName,\n  generateVisTableName,\n  getDatasetData,\n  getVisualization,\n  rowToVisualization,\n  TableNames\n} from './utils';\n\n\nexport class SQLStorage {\n  protected _tableName: string;\n  protected _datasetsTableName: string;\n  protected _datasetsVisTableName: string;\n  private _sql: SQL;\n  private _isPublic: boolean;\n  private _isReady: boolean = false;\n  private _namespace: string;\n  private VIS_FIELDS: { [property: string]: ColumConfig };\n  private DATASET_COLUMNS: string[];\n  private DATASET_VIS_COLUMNS: string[];\n  private FIELD_NAMES: string[];\n  private FIELD_NAMES_INSERT: string[];\n\n  constructor(\n    tableName: string,\n    sqlClient: SQL,\n    version: number,\n    isPublic: boolean) {\n    this._namespace = tableName;\n    this._tableName = generateVisTableName(tableName, isPublic, version);\n    this._datasetsTableName = generateDatasetTableName(this._tableName);\n    this._datasetsVisTableName = generateDatasetVisTableName(this._tableName);\n    this._isPublic = isPublic;\n\n    this.VIS_FIELDS = {\n      id: { name: 'id', type: 'uuid', extra: `PRIMARY KEY DEFAULT ${this._namespace}_create_uuid()`, omitOnInsert: true },\n      name: { name: 'name', type: 'text', extra: 'NOT NULL', format: this.escapeOrNull },\n      description: { name: 'description', type: 'text', format: this.escapeOrNull },\n      thumbnail: { name: 'thumbnail', type: 'text', format: this.escapeOrNull },\n      isprivate: {\n        name: 'isprivate', type: 'boolean', format: (isPrivate: boolean) => isPrivate === undefined ? false : isPrivate\n      },\n      config: { name: 'config', type: 'json', format: this.escapeOrNull },\n      lastmodified: { name: 'lastmodified', type: 'timestamp', extra: 'NOT NULL DEFAULT now()', omitOnInsert: true }\n    };\n\n    this.DATASET_COLUMNS = [\n      `\"id\" uuid PRIMARY KEY DEFAULT ${this._namespace}_create_uuid()`,\n      `\"tablename\" text UNIQUE NOT NULL`,\n      `\"name\" text UNIQUE NOT NULL`\n    ];\n\n    this.DATASET_VIS_COLUMNS = [\n      // TODO: Reenable foreign keys when https://github.com/CartoDB/cartodb/issues/15161 is solved\n      `\"vis\" uuid NOT NULL`, // `vis uuid references ${this._tableName}(id) ON DELETE CASCADE`,\n      `\"dataset\" uuid NOT NULL` // `dataset uuid references ${this._datasetsTableName}(id) ON DELETE CASCADE`\n    ];\n\n    this.FIELD_NAMES = (Object.values(this.VIS_FIELDS) as ColumConfig[])\n      .map((field) => field.name);\n\n    this.FIELD_NAMES_INSERT = (Object.values(this.VIS_FIELDS) as ColumConfig[])\n      .filter((field) => !field.omitOnInsert)\n      .map((field) => field.name);\n\n    this._sql = sqlClient;\n  }\n\n  /**\n   * Ensures custom storage tables are ready\n   */\n  public async init(options: { event?: MetricsEvent } = {}) {\n    const missing = await this._checkMissingTables(); // notice how the previous checks don't propagate the event...\n    if (missing) {\n      await this._initTables({ event: options.event }); // ...but the real initialization does\n    }\n    this._isReady = true;\n    return missing;\n  }\n\n  /**\n   * Checks if storage tables are created\n   */\n  public async isInitialized() {\n    const hasMissingTables = await this._checkMissingTables();\n    this._isReady = !hasMissingTables;\n    return this._isReady;\n  }\n\n  public getVisualizations(options: { event?: MetricsEvent } = {}): Promise<StoredVisualization[]> {\n    return this._sql.query(`\n      SELECT ${this.FIELD_NAMES.filter((name) => name !== 'config').map((name) => `\"${name}\"`).join(', ')}\n      FROM ${this._tableName}\n      `, options).then((response: any) => {\n\n      if (response.error) {\n        throw new Error(response.error);\n      }\n\n      if (response.rows.length === 0) {\n        return [];\n      }\n\n      return response.rows.map(rowToVisualization);\n    });\n  }\n\n  public async getVisualization(id: string, options: { event?: MetricsEvent } = {}): Promise<CompleteVisualization | null> {\n    const tableNames: TableNames = {\n      vis: this._tableName,\n      datasets: this._datasetsTableName,\n      visToDatasets: this._datasetsVisTableName\n    };\n\n    return getVisualization(tableNames, id, this._sql, options);\n  }\n\n  public async getDatasetData(name: string, tablename: string): Promise<Dataset> {\n    return getDatasetData(name, tablename, this._sql);\n  }\n\n  public async getDataset(name: string, options: { event?: MetricsEvent } = {}): Promise<StoredDataset | null> {\n    const result: any = await this._sql.query(`\n      SELECT * FROM ${this._datasetsTableName} WHERE \"name\"='${name}'\n    `, options);\n\n    if (result.error) {\n      throw new Error(`Failed to get dataset ${name}`);\n    }\n\n    return result.rows[0] || null;\n  }\n\n  public async getDatasets(): Promise<StoredDataset[]> {\n    const result: any = await this._sql.query(`\n      SELECT * FROM ${this._datasetsTableName}\n    `);\n\n    if (result.error) {\n      throw new Error('Failed to read datasets');\n    }\n\n    return result.rows;\n  }\n\n  public async getVisForDataset(datasetId: string): Promise<StoredVisualization[]> {\n    const result: any = await this._sql.query(`\n      WITH dataset_vis as (SELECT * FROM ${this._datasetsVisTableName} WHERE \"dataset\" = '${datasetId}')\n\n      SELECT t.\"name\", t.\"id\", t.\"thumbnail\", t.\"isprivate\"\n      FROM ${this._tableName} t, dataset_vis u WHERE t.\"id\" = u.\"vis\"\n    `);\n\n    if (result.error) {\n      throw new Error('Failed to read visualizations');\n    }\n\n    return result.rows.map(rowToVisualization);\n  }\n\n  public async deleteVisualization(id: string, options: { event?: MetricsEvent } = {}): Promise<void> {\n    // Delete visualization - dataset relation\n    await this._sql.query(`DELETE FROM ${this._datasetsVisTableName} WHERE \"vis\"='${id}'`, options);\n\n    // Delete visualization\n    await this._sql.query(`DELETE FROM ${this._tableName} WHERE \"id\"='${id}'`, options);\n\n    // Delete (not shared) datasets\n    await this.deleteOrphanDatasets(options);\n  }\n\n  public async deleteDataset() {\n    // Find all related visualizations\n    // Delete them\n    // Delete the dataset\n    throw new Error('deleteDataset Not implemented yet');\n  }\n\n  public async createVisualization(\n    vis: Visualization,\n    datasets: Array<Dataset | string>,\n    options: {\n      overwriteDatasets?: boolean,\n      event?: MetricsEvent\n    } = {}): Promise<StoredVisualization | null> {\n\n    await this.preventAccidentalDatasetsOverwrite(options.overwriteDatasets, datasets);\n\n    const insertedVis = await this.insertVisTable(vis, { event: options.event });\n    if (insertedVis === null) {\n      return null;\n    }\n\n    await this.uploadAndLinkDatasetsTo(insertedVis.id, datasets, vis.isprivate, options);\n\n    return {\n      ...insertedVis,\n      ...vis\n    };\n  }\n\n  public async uploadDataset(\n    dataset: Dataset,\n    options: {\n      overwrite: boolean,\n      event?: MetricsEvent\n    } = { overwrite: false }\n    ): Promise<StoredDataset> {\n\n    const tableName = `${this._tableName}_${dataset.name}`;\n\n    if (!dataset.columns) {\n      throw new Error('Need dataset column information');\n    }\n\n    const storedDataset = await this.getDataset(dataset.name, { event: options.event });\n\n    if (options.overwrite && storedDataset !== null) {\n      await this._sql.query(`DROP TABLE IF EXISTS ${tableName}`, { event: options.event });\n    }\n\n    const opts = {\n      createOptions: { ifNotExists: false },\n      event: options.event\n    };\n    const result: any = await this._sql.create(tableName, dataset.columns, opts);\n\n    if (result.error) {\n      throw new Error(`Failed to create table for dataset ${dataset.name}: ${result.error}`);\n    }\n\n    let copyResult: any;\n    try {\n      const fields = dataset.columns.map((column) => {\n        if (typeof column === 'string') {\n          return `\"${column}\"`;\n        }\n        return `\"${column.name}\"`;\n      });\n      copyResult = await this._sql.copyFrom(dataset.file, tableName, fields, { event: options.event });\n    } catch (error) {\n      throw new Error(`Failed to copy to ${tableName}: ${error.message}`);\n    }\n    if (copyResult.error) {\n      throw new Error(`Failed to copy to ${tableName}: ${copyResult.error}`);\n    }\n\n    if (storedDataset === null) {\n      const insertResult: any = await this._sql.query(`\n        INSERT INTO ${this._datasetsTableName} (\"id\", \"name\", \"tablename\")\n        VALUES (${this._namespace}_create_uuid(), '${dataset.name}', '${tableName}')\n        RETURNING *\n      `, { event: options.event });\n\n      if (insertResult.error) {\n        throw new Error(`Failed to register dataset ${tableName} ${insertResult.error}`);\n      }\n\n      return insertResult.rows[0];\n    }\n\n    return storedDataset;\n  }\n\n  public shareDataset(tableName: string, options: { event?: MetricsEvent } = {}) {\n    return this._sql.grantPublicRead(tableName, options);\n  }\n\n  public async updateVisualization(\n    vis: StoredVisualization,\n    datasets: Dataset[],\n    options: {\n      event?: MetricsEvent\n    } = {}\n    ): Promise<any> {\n\n    const updatedVis = await this.updateVisTable(vis, options);\n    if (updatedVis === null) {\n      return null;\n    }\n\n    await this.cleanVisAndDatasetLinks(updatedVis.id, options);\n    await this.uploadAndLinkDatasetsTo(updatedVis.id, datasets, vis.isprivate, {\n      overwriteDatasets: true,\n      event: options.event\n    });\n    await this.deleteOrphanDatasets(options);\n\n    return {\n      ...vis,\n      ...updatedVis\n    };\n  }\n\n  public get isReady(): boolean {\n    return this._isReady;\n  }\n\n  public setApiKey(apiKey: string) {\n    this._sql.setApiKey(apiKey);\n  }\n\n  public async destroy() {\n    const rawDatasets = await this.getDatasets();\n\n    const datasets: string[] = rawDatasets.map((row: { name: string }) => row.name);\n\n    // NOTE: DROP TABLE CASCADE removes dependant views or functions and foreign keys constraints (neither tables nor data)\n    return this._sql.query(`\n      BEGIN;\n        ${datasets.map((datasetName) => `DROP TABLE IF EXISTS ${datasetName};`).join('\\n')}\n        DROP TABLE IF EXISTS ${this._tableName} CASCADE;\n        DROP TABLE IF EXISTS ${this._datasetsTableName} CASCADE;\n        DROP TABLE IF EXISTS ${this._datasetsVisTableName} CASCADE;\n      COMMIT;\n    `);\n  }\n\n  // Private methods\n\n  private async checkIfDatasetExists(datasetOrName: Dataset | string): Promise<StoredDataset | null> {\n    const name = typeof datasetOrName === 'string' ? datasetOrName : datasetOrName.name;\n\n    const result: any = await this._sql.query(`SELECT * FROM ${this._datasetsTableName} WHERE \"name\" = '${name}'`);\n\n    if (result.error) {\n      throw new Error(result.error);\n    }\n\n    if (result.rows.length === 0) {\n      return null;\n    }\n\n    return result.rows[0];\n  }\n\n  private async preventAccidentalDatasetsOverwrite(overwriteDatasets: boolean = false, datasets: Array<Dataset | string>) {\n    const fullDatasets = datasets.filter((dataset): dataset is Dataset => typeof dataset !== 'string');\n    const existingTables = await this.checkExistingDataset(fullDatasets);\n    if (!overwriteDatasets) {\n      if (existingTables.length > 0) {\n        throw new DuplicatedDatasetsError(existingTables.map((dataset) => dataset.name));\n      }\n    }\n  }\n\n  private async deleteOrphanDatasets(options: { event?: MetricsEvent } = {}) {\n    // Delete any dataset that is not used by any other visualization.\n    // This makes sense if datasets have not been cartodbfied, so they are just 'weak entities',\n    // tied to visualizations. Once cartodbfied, the drop could not make sense anymore.\n\n    // Drop the orphan datasets themselves\n    const result: any = await this._sql.query(`\n      SELECT * FROM ${this._datasetsTableName} WHERE \"id\" NOT IN (SELECT distinct(\"dataset\") FROM ${this._datasetsVisTableName})\n    `, options);\n\n    const dropOptions: DropOptions = { ifExists: true };\n    const opts = {\n      dropOptions,\n      event: options.event\n    };\n    const drops = result.rows.map((row: any) => {\n      this._sql.drop(row.tablename, opts);\n    });\n    await Promise.all(drops);\n\n    // Delete the reference to those datasets\n    await this._sql.query(`DELETE FROM ${this._datasetsTableName} WHERE \"id\" NOT IN (SELECT distinct(\"dataset\") FROM ${this._datasetsVisTableName})`, options);\n  }\n\n  private async insertVisTable(vis: Visualization, options: { event?: MetricsEvent } = {}) {\n    const insert = `INSERT INTO ${this._tableName}\n     (${this.FIELD_NAMES_INSERT.map((field: string) => `\"${field}\"`).join(', ')})\n     VALUES\n     (\n       ${\n      this.FIELD_NAMES_INSERT\n        .map((field: string) => {\n          const visField = this.VIS_FIELDS[field];\n          const fieldValue = (vis as any)[field];\n\n          const value = visField && visField.format ? visField.format(fieldValue) : fieldValue;\n          return value === null ? 'null' : value;\n        })\n        .join()\n      }\n     )\n     RETURNING \"id\", \"lastmodified\"\n   `;\n    const insertResult: any = await this._sql.query(insert, options);\n\n    if (insertResult.error) {\n      throw new Error(insertResult.error);\n    }\n\n    const insertedVis = insertResult.rows[0];\n    return {\n      id: insertedVis.id,\n      lastmodified: insertedVis.lastmodified\n    };\n  }\n\n  private async updateVisTable(vis: StoredVisualization, options: { event?: MetricsEvent } = {}) {\n    const update = `UPDATE ${this._tableName}\n      SET\n        ${\n        this.FIELD_NAMES_INSERT\n          .map((field: string) => {\n            const visField = this.VIS_FIELDS[field];\n            const fieldValue = (vis as any)[field];\n\n            const value = visField && visField.format ? visField.format(fieldValue) : fieldValue;\n            return `\"${field}\" = ${value === null ? 'null' : value}`;\n          })\n          .join()\n        }\n        ,${this.VIS_FIELDS.lastmodified.name}=NOW()\n      WHERE ${this.VIS_FIELDS.id.name} = '${vis.id}'\n      RETURNING \"${this.VIS_FIELDS.id.name}\", \"${this.VIS_FIELDS.lastmodified.name}\"\n    `;\n    const updatedResult: any = await this._sql.query(update, options);\n\n    if (updatedResult.error) {\n      throw new Error(updatedResult.error);\n    }\n\n    return {\n      id: vis.id,\n      lastmodified: updatedResult.rows.length ? updatedResult.rows[0].lastmodified : vis.lastmodified\n    };\n\n  }\n\n  private async uploadAndLinkDatasetsTo(\n    visId: string,\n    datasets: Array<Dataset | string>,\n    isPrivateVis: boolean,\n    options: {\n      overwriteDatasets?: boolean,\n      event?: MetricsEvent\n    } = {}\n    ) {\n\n    for (const dataset of datasets) {\n      let tableName: string;\n\n      // User has specified an already stored dataset as a data source\n      if (typeof dataset === 'string') {\n        const storedDataset = await this.getDataset(dataset);\n\n        if (storedDataset === null) {\n          // Fail silently for now. We'd have to be able to undo everything to fail properly.\n          continue;\n        }\n        tableName = storedDataset.tablename;\n        await this.linkVisAndDataset(visId, storedDataset.id, { event: options.event });\n      } else {\n        const storedDataset = await this.uploadDataset(dataset, {\n          overwrite: options.overwriteDatasets || false,\n          event: options.event\n        });\n        tableName = storedDataset.tablename;\n\n        await this.linkVisAndDataset(visId, storedDataset.id, { event: options.event });\n\n\n        // Creating the cartodbified version\n        // BEGIN;\n        // CREATE TABLE <tableName_cartodbified> AS (select * from previousTable);\n        // We'll need some extra user info for this step, fetch this early on.\n        // CARTODBFY(...);\n        // END;\n      }\n\n      // GRANT READ to datasets\n      if (!isPrivateVis) {\n        await this.shareDataset(tableName, { event: options.event });\n      }\n    }\n  }\n\n  private async checkExistingDataset(datasets: Array<string | Dataset>): Promise<StoredDataset[]> {\n    const result = await Promise.all(datasets.map((dataset) => this.checkIfDatasetExists(dataset)));\n\n    return result.filter((element): element is StoredDataset => element !== null);\n  }\n\n  private escapeOrNull(what: string) {\n    if (what === null) {\n      return null;\n    }\n    what = what.replace(/\\'/gi, '\\\\\\'');\n\n    return `E'${what}'`;\n  }\n\n  // Removes existing links with a certain visualization\n  private async cleanVisAndDatasetLinks(visId: string, options: { event?: MetricsEvent } = {}) {\n    const cleanResult: any = await this._sql.query(`\n      DELETE FROM ${this._datasetsVisTableName}\n      WHERE vis='${visId}'\n    `, options);\n\n    if (cleanResult.error) {\n      throw new Error(`Failed to clean vis-dataset links for visualization '${visId}'`);\n    }\n  }\n\n  private async linkVisAndDataset(visId: string, datasetId: string, options: { event?: MetricsEvent } = {}) {\n    const insert = `\n      INSERT INTO ${this._datasetsVisTableName} (\"vis\", \"dataset\")\n      VALUES ('${visId}', '${datasetId}')\n    `;\n    const insertResult: any = await this._sql.query(insert, options);\n\n    if (insertResult.error) {\n      throw new Error('Failed to link dataset id to vis id');\n    }\n  }\n\n  /**\n   * Checks if all the tables for SQLStorage exist\n   */\n  private _checkMissingTables() {\n    return new Promise(async (resolve, reject) => {\n      try {\n        const requiredTables = [this._tableName, this._datasetsTableName, this._datasetsVisTableName];\n\n        const checksTablesAreReady = requiredTables.map((table) => this._sql.query(`SELECT to_regclass('${table}')`));\n        const results = await Promise.all(checksTablesAreReady);\n        const missingTables = results.some((response: any) => {\n          const tableIsMissing = (response.rows[0].to_regclass === null);\n          return tableIsMissing;\n        });\n\n        resolve(missingTables);\n      } catch (err) {\n        reject(err);\n      }\n    });\n  }\n\n  /**\n   * Creates missing required tables for custom storage\n   */\n  private async _initTables(options: { event?: MetricsEvent } = {}) {\n    const columnsConfig = [...Object.values(this.VIS_FIELDS)];\n\n    const createConfig: CreateConfig = { ifNotExists: true };\n    const createOptions = {\n      createConfig,\n      event: options.event\n    };\n\n    await this._sql.create(this._tableName, columnsConfig, createOptions);\n    await this._sql.create(this._datasetsTableName, this.DATASET_COLUMNS, createOptions);\n    await this._sql.create(this._datasetsVisTableName, this.DATASET_VIS_COLUMNS, createOptions);\n\n    // TODO: If they are already granted, no point in following\n    if (this._isPublic) {\n      await this._sql.grantPublicRead(this._tableName, options);\n      await this._sql.grantPublicRead(this._datasetsTableName, options);\n      await this._sql.grantPublicRead(this._datasetsVisTableName, options);\n    }\n  }\n}\n","import { Credentials, MetricsEvent } from '@carto/toolkit-core';\nimport { Constants, SQL } from '@carto/toolkit-sql';\nimport { SQLStorage } from './sql/SQLStorage';\nimport {\n  CompleteVisualization,\n  Dataset,\n  StorageRepository,\n  StoredDataset,\n  StoredVisualization,\n  Visualization\n} from './StorageRepository';\n\nconst DEFAULT_CLIENT = 'keplergl'; // default client app using the storage\n\nconst CONTEXT_INIT = 'custom_storage_init';\nconst CONTEXT_CREATE_PUBLIC_VIS = 'custom_storage_public_visualization_create';\nconst CONTEXT_CREATE_PRIVATE_VIS = 'custom_storage_private_visualization_create';\nconst CONTEXT_UPDATE_VIS = 'custom_storage_visualization_update';\nconst CONTEXT_DELETE_VIS = 'custom_storage_visualization_delete';\nconst CONTEXT_GET_ALL_VIS = 'custom_storage_visualization_list_load';\nconst CONTEXT_GET_PUBLIC_VIS = 'custom_storage_public_visualizations_load';\nconst CONTEXT_GET_PRIVATE_VIS = 'custom_storage_private_visualizations_load';\nconst CONTEXT_GET_VIS = 'custom_storage_visualization_load';\n\nexport class CustomStorage implements StorageRepository {\n  public static version: number = 0;\n\n  public client: string;\n\n  private _publicSQLStorage: SQLStorage;\n  private _privateSQLStorage: SQLStorage;\n  private _sqlClient: SQL;\n  private _namespace: string;\n\n  constructor(\n      namespace: string,\n      credentials: Credentials,\n      options: {\n        client?: string\n        maxApiRequestsRetries?: number,\n      } = {}\n    ) {\n      const opts = Object.assign({\n        client: DEFAULT_CLIENT,\n        maxApiRequestsRetries: Constants.DEFAULT_MAX_API_REQUESTS_RETRIES,\n      }, options);\n\n      this.client = opts.client;\n      this._sqlClient = new SQL(credentials, { maxApiRequestsRetries: opts.maxApiRequestsRetries });\n      this._checkNamespace(namespace);\n\n      this._namespace = namespace;\n\n      this._publicSQLStorage = new SQLStorage(\n      this._namespace,\n      this._sqlClient,\n      this.getVersion(),\n      true\n    );\n\n      this._privateSQLStorage = new SQLStorage(\n      this._namespace,\n      this._sqlClient,\n      this.getVersion(),\n      false\n    );\n  }\n\n  public async init() {\n    const isInitialized = await this.isInitialized();\n    if (isInitialized) {\n      return true;\n    }\n\n    await this._sqlClient.query(`\n      BEGIN;\n        CREATE OR REPLACE FUNCTION ${this._namespace}_create_uuid()\n        RETURNS UUID AS\n        $$\n        DECLARE\n          _output UUID;\n        BEGIN\n          SELECT uuid_in(md5(random()::text || clock_timestamp()::text)::cstring) INTO _output;\n          RETURN _output;\n        END\n        $$ LANGUAGE plpgsql PARALLEL SAFE;\n      COMMIT;\n    `);\n\n    const event = new MetricsEvent(this.client, CONTEXT_INIT);\n    const inits = await Promise.all([this._publicSQLStorage.init({ event }), this._privateSQLStorage.init({ event })]);\n\n    const storageHasBeenInitialized = inits[0] || inits[1];\n    return storageHasBeenInitialized;\n  }\n\n  public getVisualizations(): Promise<StoredVisualization[]> {\n    this._checkReady();\n\n    const event = new MetricsEvent(this.client, CONTEXT_GET_ALL_VIS);\n    return Promise.all([\n      this._privateSQLStorage.getVisualizations({ event }),\n      this._publicSQLStorage.getVisualizations({ event })\n    ]).then((data) => {\n      return [...data[0], ...data[1]];\n    });\n  }\n\n  public getPublicVisualizations(): Promise<StoredVisualization[]> {\n    this._checkReady();\n\n    const event = new MetricsEvent(this.client, CONTEXT_GET_PUBLIC_VIS);\n    return this._publicSQLStorage.getVisualizations({ event });\n  }\n\n  public getPrivateVisualizations(): Promise<StoredVisualization[]> {\n    this._checkReady();\n\n    const event = new MetricsEvent(this.client, CONTEXT_GET_PRIVATE_VIS);\n    return this._privateSQLStorage.getVisualizations({ event });\n  }\n\n  public getVisualization(id: string): Promise<CompleteVisualization | null> {\n    this._checkReady();\n\n    const event = new MetricsEvent(this.client, CONTEXT_GET_VIS);\n\n    // Alternatively: SELECT * from (SELECT * FROM <public_table> UNION SELECT * FROM <private_table>) WHERE id = ${id};\n    return Promise.all([\n      this._publicSQLStorage.getVisualization(id, { event }),\n      this._privateSQLStorage.getVisualization(id, { event })\n    ]).then((d) => {\n      return d[0] || d[1];\n    });\n  }\n\n  // TODO: optimize by splitting into two methods because clients will know the type of vis it is\n  public deleteVisualization(id: string) {\n    this._checkReady();\n\n    const event = new MetricsEvent(this.client, CONTEXT_DELETE_VIS);\n\n    return Promise.all([\n      this._publicSQLStorage.deleteVisualization(id, { event }),\n      this._privateSQLStorage.deleteVisualization(id, { event })\n    ]).then(() => {\n      return true;\n    }).catch(() => {\n      return false;\n    });\n  }\n\n  public createVisualization(\n    vis: Visualization,\n    datasets: Array<Dataset | string>,\n    overwriteDatasets: boolean): Promise<StoredVisualization | null> {\n    this._checkReady();\n\n    const target = vis.isprivate ? this._privateSQLStorage : this._publicSQLStorage;\n    const eventName = vis.isprivate ? CONTEXT_CREATE_PRIVATE_VIS : CONTEXT_CREATE_PUBLIC_VIS;\n    const event = new MetricsEvent(this.client, eventName);\n\n    return target.createVisualization(vis, datasets, { overwriteDatasets, event });\n  }\n\n  public updateVisualization(vis: StoredVisualization, datasets: Dataset[]): Promise<StoredVisualization | null> {\n    this._checkReady();\n\n    const target = vis.isprivate ? this._privateSQLStorage : this._publicSQLStorage;\n\n    const event = new MetricsEvent(this.client, CONTEXT_UPDATE_VIS);\n    return target.updateVisualization(vis, datasets, { event });\n  }\n\n  public getDatasets(): Promise<StoredDataset[]> {\n    return Promise.all([this._publicSQLStorage.getDatasets(), this._privateSQLStorage.getDatasets()])\n      .then((result) => {\n        return [\n          ...result[0], ...result[1]\n        ];\n      });\n  }\n\n  public getVisForDataset(datasetName: string) {\n    return Promise.all([\n      this._publicSQLStorage.getVisForDataset(datasetName),\n      this._privateSQLStorage.getVisForDataset(datasetName)\n    ])\n    .then((result) => {\n      return [\n        ...result[0], ...result[1]\n      ];\n    });\n  }\n\n  public uploadPublicDataset(dataset: Dataset, overwrite: boolean = false) {\n    return this._uploadDataset(dataset, this._publicSQLStorage, true, overwrite);\n  }\n\n  public uploadPrivateDataset(dataset: Dataset, overwrite: boolean = false) {\n    return this._uploadDataset(dataset, this._privateSQLStorage, false, overwrite);\n  }\n\n  public getVersion() {\n    return CustomStorage.version;\n  }\n\n  public migrate() {\n    // Version 0 does not need to migrate anything.\n    // Future versions should implement this to migrate from 0 to this.getVersion()\n    return Promise.resolve();\n  }\n\n  public getSQLClient(): SQL {\n    return this._sqlClient;\n  }\n\n  public setApiKey(apiKey: string) {\n    this._sqlClient.setApiKey(apiKey);\n    this._privateSQLStorage.setApiKey(apiKey);\n    this._publicSQLStorage.setApiKey(apiKey);\n  }\n\n  public async destroy() {\n    await this._sqlClient.query(`DROP FUNCTION ${this._namespace}_create_uuid CASCADE;`);\n    await this._privateSQLStorage.destroy();\n    await this._publicSQLStorage.destroy();\n  }\n\n  public async isInitialized() {\n    const inits = await Promise.all([this._publicSQLStorage.isInitialized(), this._privateSQLStorage.isInitialized()]);\n    const isInitialized = inits[0] || inits[1];\n    return isInitialized;\n  }\n\n  /**\n   * Check namespace, as it will be used internally to create database-related elements\n   *\n   * @private\n   * @param {string} namespace\n   * @memberof CustomStorage\n   */\n  private _checkNamespace(namespace: string) {\n\n    if ((namespace.split(' ').length > 1)) {\n      throw new Error ('Namespace for custom-storage must be 1 word');\n    }\n  }\n\n  private _checkReady() {\n    if (!this._privateSQLStorage.isReady || !this._publicSQLStorage.isReady) {\n      throw new Error('.init has not finished');\n    }\n  }\n\n  private async _uploadDataset(dataset: Dataset, storage: SQLStorage, isPublic: boolean, overwrite: boolean) {\n    const storedDataset = await storage.uploadDataset(dataset, { overwrite });\n\n    if (isPublic) {\n      await storage.shareDataset(storedDataset.tablename);\n    }\n\n    return storedDataset;\n  }\n}\n","import { PublicSQLReader } from './sql/PublicSQLReader';\n\nexport class PublicStorageReader extends PublicSQLReader {\n}\n","import { Credentials, MetricsEvent } from '@carto/toolkit-core';\nimport { SQL } from '@carto/toolkit-sql';\nimport { CustomStorage } from '../CustomStorage';\nimport { generateDatasetTableName, generateDatasetVisTableName, generateVisTableName, getVisualization, TableNames } from './utils';\n\ninterface SQLClientMap {\n  [key: string]: SQL;\n}\n\nconst DEFAULT_CLIENT = 'keplergl'; // default client app using the storage\n\nconst CONTEXT_GET_PUBLIC_VIS = 'public_sql_reader_visualization_load';\n\nexport class PublicSQLReader {\n\n  private _client: string;\n\n  private _clientMap: SQLClientMap;\n  private _serverUrlTemplate: string;\n\n  private _tableName: string;\n  private _datasetTableName: string;\n  private _datasetsVisTableName: string;\n\n  constructor(\n      namespace: string,\n      serverUrlTemplate: string = Credentials.DEFAULT_SERVER_URL_TEMPLATE,\n      options: {\n        client?: string\n      } = { }\n    ) {\n\n      this._client = options.client ? options.client : DEFAULT_CLIENT;\n\n      this._clientMap = {};\n      this._serverUrlTemplate = serverUrlTemplate;\n\n      this._tableName = generateVisTableName(namespace, true, CustomStorage.version);\n      this._datasetTableName = generateDatasetTableName(this._tableName);\n      this._datasetsVisTableName = generateDatasetVisTableName(this._tableName);\n  }\n\n  public getVisualization(username: string, id: string) {\n    if (this._clientMap[username] === undefined) {\n      const publicCredentials = new Credentials(username, Credentials.DEFAULT_PUBLIC_API_KEY, this._serverUrlTemplate);\n      this._clientMap[username] = new SQL(publicCredentials);\n    }\n\n    const tableNames: TableNames = {\n      vis: this._tableName,\n      datasets: this._datasetTableName,\n      visToDatasets: this._datasetsVisTableName\n    };\n\n    const event = new MetricsEvent(this._client, CONTEXT_GET_PUBLIC_VIS);\n\n    return getVisualization(tableNames, id, this._clientMap[username], { event });\n  }\n}\n"],"names":["DuplicatedDatasetsError","[object Object]","errorcode","message","this","errorCode","datasets","super","rowToVisualization","row","id","name","description","thumbnail","isprivate","config","lastmodified","getDatasetData","tablename","client","options","queryOptions","extraParams","event","response","query","Error","error","file","getVisualization","tableNames","vis","rows","length","datasetsForViz","visId","datasetsResp","visToDatasets","getDatasetsForVis","Promise","all","map","dataset","generateVisTableName","namespace","isPublic","version","generateDatasetTableName","tableName","generateDatasetVisTableName","SQLStorage","sqlClient","_namespace","_tableName","_datasetsTableName","_datasetsVisTableName","_isPublic","VIS_FIELDS","type","extra","omitOnInsert","format","escapeOrNull","isPrivate","undefined","DATASET_COLUMNS","DATASET_VIS_COLUMNS","FIELD_NAMES","Object","values","field","FIELD_NAMES_INSERT","filter","_sql","missing","_checkMissingTables","_initTables","_isReady","hasMissingTables","join","then","result","datasetId","deleteOrphanDatasets","preventAccidentalDatasetsOverwrite","overwriteDatasets","insertedVis","insertVisTable","uploadAndLinkDatasetsTo","overwrite","columns","storedDataset","getDataset","opts","createOptions","ifNotExists","create","copyResult","fields","column","copyFrom","insertResult","grantPublicRead","updatedVis","updateVisTable","cleanVisAndDatasetLinks","isReady","apiKey","setApiKey","getDatasets","datasetName","datasetOrName","fullDatasets","existingTables","checkExistingDataset","dropOptions","ifExists","drops","drop","insert","visField","fieldValue","value","update","updatedResult","isPrivateVis","linkVisAndDataset","uploadDataset","shareDataset","checkIfDatasetExists","element","what","replace","resolve","reject","checksTablesAreReady","table","missingTables","some","to_regclass","err","columnsConfig","createConfig","CustomStorage","credentials","assign","maxApiRequestsRetries","Constants","DEFAULT_MAX_API_REQUESTS_RETRIES","_sqlClient","SQL","_checkNamespace","_publicSQLStorage","getVersion","_privateSQLStorage","isInitialized","MetricsEvent","inits","init","_checkReady","getVisualizations","data","d","deleteVisualization","catch","target","eventName","createVisualization","updateVisualization","getVisForDataset","_uploadDataset","destroy","split","storage","PublicStorageReader","serverUrlTemplate","Credentials","DEFAULT_SERVER_URL_TEMPLATE","_client","_clientMap","_serverUrlTemplate","_datasetTableName","username","publicCredentials","DEFAULT_PUBLIC_API_KEY"],"mappings":"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"}