"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getPickedEditHandle = getPickedEditHandle;
exports.getIntermediatePosition = getIntermediatePosition;
exports.getEditHandlesForGeometry = getEditHandlesForGeometry;
exports.BaseGeoJsonEditMode = void 0;

var _union = _interopRequireDefault(require("@turf/union"));

var _difference = _interopRequireDefault(require("@turf/difference"));

var _intersect = _interopRequireDefault(require("@turf/intersect"));

var _editMode = require("./edit-mode.js");

var _immutableFeatureCollection = require("./immutable-feature-collection.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var DEFAULT_EDIT_HANDLES = []; // Main interface for `EditMode`s that edit GeoJSON

var BaseGeoJsonEditMode =
/*#__PURE__*/
function (_BaseEditMode) {
  _inherits(BaseGeoJsonEditMode, _BaseEditMode);

  // TODO: add underscore
  function BaseGeoJsonEditMode(featureCollection) {
    var _this;

    _classCallCheck(this, BaseGeoJsonEditMode);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(BaseGeoJsonEditMode).call(this));

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "featureCollection", void 0);

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_clickSequence", []);

    if (featureCollection) {
      _this.setFeatureCollection(featureCollection);
    }

    return _this;
  }

  _createClass(BaseGeoJsonEditMode, [{
    key: "getFeatureCollection",
    value: function getFeatureCollection() {
      return this.featureCollection.getObject();
    }
  }, {
    key: "getImmutableFeatureCollection",
    value: function getImmutableFeatureCollection() {
      return this.featureCollection;
    }
  }, {
    key: "getSelectedFeature",
    value: function getSelectedFeature() {
      if (this.getSelectedIndexes().length === 1) {
        return this.featureCollection.getObject().features[this.getSelectedIndexes()[0]];
      }

      return null;
    }
  }, {
    key: "getSelectedGeometry",
    value: function getSelectedGeometry() {
      var feature = this.getSelectedFeature();

      if (feature) {
        return feature.geometry;
      }

      return null;
    }
  }, {
    key: "getSelectedFeaturesAsFeatureCollection",
    value: function getSelectedFeaturesAsFeatureCollection() {
      var _this$featureCollecti = this.featureCollection.getObject(),
          features = _this$featureCollecti.features;

      var selectedFeatures = this.getSelectedFeatureIndexes().map(function (selectedIndex) {
        return features[selectedIndex];
      });
      return {
        type: 'FeatureCollection',
        features: selectedFeatures
      };
    }
  }, {
    key: "onDataChanged",
    value: function onDataChanged() {
      this.setFeatureCollection(this.getData());

      this._refreshEditHandles();
    }
  }, {
    key: "setFeatureCollection",
    value: function setFeatureCollection(featureCollection) {
      this.featureCollection = new _immutableFeatureCollection.ImmutableFeatureCollection(featureCollection);
    } // TODO: delete me

  }, {
    key: "setModeConfig",
    value: function setModeConfig(modeConfig) {
      console.warn('TODO: call to obsolete setModeConfig'); // eslint-disable-line
    } // TODO: delete me

  }, {
    key: "getSelectedFeatureIndexes",
    value: function getSelectedFeatureIndexes() {
      return this.getSelectedIndexes();
    } // TODO: delete me

  }, {
    key: "setSelectedFeatureIndexes",
    value: function setSelectedFeatureIndexes(indexes) {
      console.warn('TODO: call to obsolete setSelectedFeatureIndexes'); // eslint-disable-line
    }
  }, {
    key: "onSelectedIndexesChanged",
    value: function onSelectedIndexesChanged() {
      this._setTentativeFeature(null);
    }
  }, {
    key: "onGuidesChanged",
    value: function onGuidesChanged(prevState) {
      var guides = this.getGuides();

      if (!guides) {
        // Reset the click sequence
        this._clickSequence = [];
      }

      if (prevState && prevState.guides && guides && prevState.guides.tentativeFeature !== guides.tentativeFeature) {
        // re-calculate edit handles
        this._refreshEditHandles();
      }
    }
  }, {
    key: "getClickSequence",
    value: function getClickSequence() {
      return this._clickSequence;
    }
  }, {
    key: "resetClickSequence",
    value: function resetClickSequence() {
      this._clickSequence = [];
    }
  }, {
    key: "getTentativeFeature",
    value: function getTentativeFeature() {
      var _ref = this.getGuides() || {},
          tentativeFeature = _ref.tentativeFeature;

      return tentativeFeature;
    }
  }, {
    key: "getEditHandles",
    value: function getEditHandles() {
      var _ref2 = this.getGuides() || {
        editHandles: DEFAULT_EDIT_HANDLES
      },
          editHandles = _ref2.editHandles;

      return editHandles;
    } // TODO: delete me once mode handlers do getEditHandles lazily

  }, {
    key: "_setTentativeFeature",
    value: function _setTentativeFeature(tentativeFeature) {
      this.getState().onUpdateGuides({
        tentativeFeature: tentativeFeature,
        editHandles: this.getEditHandles()
      });
    } // TODO: delete me once mode handlers do getEditHandles lazily

  }, {
    key: "_refreshEditHandles",
    value: function _refreshEditHandles(picks, mapCoords) {
      this.getState().onUpdateGuides({
        tentativeFeature: this.getTentativeFeature(),
        editHandles: this.getEditHandlesAdapter(picks, mapCoords)
      });
    }
  }, {
    key: "_refreshCursor",
    value: function _refreshCursor() {
      var currentCursor = this.getCursor();
      var updatedCursor = this.getCursorAdapter({
        isDragging: false
      });

      if (currentCursor !== updatedCursor) {
        this.onUpdateCursor(updatedCursor);
      }
    }
    /**
     * Returns a flat array of positions for the given feature along with their indexes into the feature's geometry's coordinates.
     *
     * @param featureIndex The index of the feature to get edit handles
     */

  }, {
    key: "getEditHandlesAdapter",
    value: function getEditHandlesAdapter(picks, mapCoords, tentativeFeature) {
      return DEFAULT_EDIT_HANDLES;
    }
  }, {
    key: "getCursorAdapter",
    value: function getCursorAdapter(_ref3) {
      var isDragging = _ref3.isDragging;
      return 'cell';
    }
  }, {
    key: "isSelectionPicked",
    value: function isSelectionPicked(picks) {
      if (!picks.length) return false;
      var pickedIndexes = picks.map(function (_ref4) {
        var index = _ref4.index;
        return index;
      });
      var selectedFeatureIndexes = this.getSelectedFeatureIndexes();
      return selectedFeatureIndexes.some(function (index) {
        return pickedIndexes.includes(index);
      });
    }
  }, {
    key: "getAddFeatureAction",
    value: function getAddFeatureAction(geometry) {
      // Unsure why flow can't deal with Geometry type, but there I fixed it
      var geometryAsAny = geometry;
      var updatedData = this.getImmutableFeatureCollection().addFeature({
        type: 'Feature',
        properties: {},
        geometry: geometryAsAny
      }).getObject();
      return {
        updatedData: updatedData,
        editType: 'addFeature',
        editContext: {
          featureIndexes: [updatedData.features.length - 1]
        }
      };
    }
  }, {
    key: "getAddManyFeaturesAction",
    value: function getAddManyFeaturesAction(featureCollection) {
      var features = featureCollection.features;
      var updatedData = this.getImmutableFeatureCollection();
      var initialIndex = updatedData.getObject().features.length;
      var updatedIndexes = [];
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = features[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var feature = _step.value;
          var properties = feature.properties,
              geometry = feature.geometry;
          var geometryAsAny = geometry;
          updatedData = updatedData.addFeature({
            type: 'Feature',
            properties: properties,
            geometry: geometryAsAny
          });
          updatedIndexes.push(initialIndex + updatedIndexes.length);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return {
        updatedData: updatedData.getObject(),
        editType: 'addFeature',
        editContext: {
          featureIndexes: updatedIndexes
        }
      };
    }
  }, {
    key: "getAddFeatureOrBooleanPolygonAction",
    value: function getAddFeatureOrBooleanPolygonAction(geometry) {
      var selectedFeature = this.getSelectedFeature();
      var modeConfig = this.getModeConfig();

      if (modeConfig && modeConfig.booleanOperation) {
        if (!selectedFeature || selectedFeature.geometry.type !== 'Polygon' && selectedFeature.geometry.type !== 'MultiPolygon') {
          // eslint-disable-next-line no-console,no-undef
          console.warn('booleanOperation only supported for single Polygon or MultiPolygon selection');
          return null;
        }

        var feature = {
          type: 'Feature',
          geometry: geometry
        };
        var updatedGeometry;

        if (modeConfig.booleanOperation === 'union') {
          updatedGeometry = (0, _union.default)(selectedFeature, feature);
        } else if (modeConfig.booleanOperation === 'difference') {
          updatedGeometry = (0, _difference.default)(selectedFeature, feature);
        } else if (modeConfig.booleanOperation === 'intersection') {
          updatedGeometry = (0, _intersect.default)(selectedFeature, feature);
        } else {
          // eslint-disable-next-line no-console,no-undef
          console.warn("Invalid booleanOperation ".concat(modeConfig.booleanOperation));
          return null;
        }

        if (!updatedGeometry) {
          // eslint-disable-next-line no-console,no-undef
          console.warn('Canceling edit. Boolean operation erased entire polygon.');
          return null;
        }

        var featureIndex = this.getSelectedFeatureIndexes()[0];
        var updatedData = this.getImmutableFeatureCollection().replaceGeometry(featureIndex, updatedGeometry.geometry).getObject();
        var editAction = {
          updatedData: updatedData,
          editType: 'unionGeometry',
          editContext: {
            featureIndexes: [featureIndex]
          }
        };
        return editAction;
      }

      return this.getAddFeatureAction(geometry);
    }
  }, {
    key: "handleClick",
    value: function handleClick(event) {
      var editAction = this.handleClickAdapter(event);

      this._refreshEditHandles(event.picks, event.mapCoords);

      if (editAction) {
        this.onEdit(editAction);
      }
    }
  }, {
    key: "handlePointerMove",
    value: function handlePointerMove(event) {
      var _this$handlePointerMo = this.handlePointerMoveAdapter(event),
          editAction = _this$handlePointerMo.editAction,
          cancelMapPan = _this$handlePointerMo.cancelMapPan;

      if (cancelMapPan) {
        // TODO: is there a less hacky way to prevent map panning?
        // Stop propagation to prevent map panning while dragging an edit handle
        event.sourceEvent.stopPropagation();
      }

      this._refreshCursor();

      this._refreshEditHandles(event.picks, event.mapCoords);

      if (editAction) {
        this.onEdit(editAction);
      }
    }
  }, {
    key: "handleStartDragging",
    value: function handleStartDragging(event) {
      var editAction = this.handleStartDraggingAdapter(event);

      this._refreshEditHandles(event.picks, event.mapCoords);

      if (editAction) {
        this.onEdit(editAction);
      }
    }
  }, {
    key: "handleStopDragging",
    value: function handleStopDragging(event) {
      var editAction = this.handleStopDraggingAdapter(event);

      this._refreshEditHandles(event.picks, event.mapCoords);

      if (editAction) {
        this.onEdit(editAction);
      }
    } // TODO: delete these adapters once all ModeHandler implementations don't use them

  }, {
    key: "handleClickAdapter",
    value: function handleClickAdapter(event) {
      this._clickSequence.push(event.mapCoords);

      return null;
    }
  }, {
    key: "handlePointerMoveAdapter",
    value: function handlePointerMoveAdapter(event) {
      return {
        editAction: null,
        cancelMapPan: false
      };
    }
  }, {
    key: "handleStartDraggingAdapter",
    value: function handleStartDraggingAdapter(event) {
      return null;
    }
  }, {
    key: "handleStopDraggingAdapter",
    value: function handleStopDraggingAdapter(event) {
      return null;
    }
  }]);

  return BaseGeoJsonEditMode;
}(_editMode.BaseEditMode);

exports.BaseGeoJsonEditMode = BaseGeoJsonEditMode;

function getPickedEditHandle(picks) {
  var info = picks && picks.find(function (pick) {
    return pick.isGuide;
  });

  if (info) {
    return info.object;
  }

  return null;
}

function getIntermediatePosition(position1, position2) {
  var intermediatePosition = [(position1[0] + position2[0]) / 2.0, (position1[1] + position2[1]) / 2.0];
  return intermediatePosition;
}

function getEditHandlesForGeometry(geometry, featureIndex) {
  var editHandleType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'existing';
  var handles = [];

  switch (geometry.type) {
    case 'Point':
      // positions are not nested
      handles = [{
        position: geometry.coordinates,
        positionIndexes: [],
        featureIndex: featureIndex,
        type: editHandleType
      }];
      break;

    case 'MultiPoint':
    case 'LineString':
      // positions are nested 1 level
      handles = handles.concat(getEditHandlesForCoordinates(geometry.coordinates, [], featureIndex, editHandleType));
      break;

    case 'Polygon':
    case 'MultiLineString':
      // positions are nested 2 levels
      for (var a = 0; a < geometry.coordinates.length; a++) {
        handles = handles.concat(getEditHandlesForCoordinates(geometry.coordinates[a], [a], featureIndex, editHandleType));

        if (geometry.type === 'Polygon') {
          // Don't repeat the first/last handle for Polygons
          handles = handles.slice(0, -1);
        }
      }

      break;

    case 'MultiPolygon':
      // positions are nested 3 levels
      for (var _a = 0; _a < geometry.coordinates.length; _a++) {
        for (var b = 0; b < geometry.coordinates[_a].length; b++) {
          handles = handles.concat(getEditHandlesForCoordinates(geometry.coordinates[_a][b], [_a, b], featureIndex, editHandleType)); // Don't repeat the first/last handle for Polygons

          handles = handles.slice(0, -1);
        }
      }

      break;

    default:
      throw Error("Unhandled geometry type: ".concat(geometry.type));
  }

  return handles;
}

function getEditHandlesForCoordinates(coordinates, positionIndexPrefix, featureIndex) {
  var editHandleType = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'existing';
  var editHandles = [];

  for (var i = 0; i < coordinates.length; i++) {
    var position = coordinates[i];
    editHandles.push({
      position: position,
      positionIndexes: _toConsumableArray(positionIndexPrefix).concat([i]),
      featureIndex: featureIndex,
      type: editHandleType
    });
  }

  return editHandles;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvZ2VvanNvbi1lZGl0LW1vZGUuanMiXSwibmFtZXMiOlsiREVGQVVMVF9FRElUX0hBTkRMRVMiLCJCYXNlR2VvSnNvbkVkaXRNb2RlIiwiZmVhdHVyZUNvbGxlY3Rpb24iLCJzZXRGZWF0dXJlQ29sbGVjdGlvbiIsImdldE9iamVjdCIsImdldFNlbGVjdGVkSW5kZXhlcyIsImxlbmd0aCIsImZlYXR1cmVzIiwiZmVhdHVyZSIsImdldFNlbGVjdGVkRmVhdHVyZSIsImdlb21ldHJ5Iiwic2VsZWN0ZWRGZWF0dXJlcyIsImdldFNlbGVjdGVkRmVhdHVyZUluZGV4ZXMiLCJtYXAiLCJzZWxlY3RlZEluZGV4IiwidHlwZSIsImdldERhdGEiLCJfcmVmcmVzaEVkaXRIYW5kbGVzIiwiSW1tdXRhYmxlRmVhdHVyZUNvbGxlY3Rpb24iLCJtb2RlQ29uZmlnIiwiY29uc29sZSIsIndhcm4iLCJpbmRleGVzIiwiX3NldFRlbnRhdGl2ZUZlYXR1cmUiLCJwcmV2U3RhdGUiLCJndWlkZXMiLCJnZXRHdWlkZXMiLCJfY2xpY2tTZXF1ZW5jZSIsInRlbnRhdGl2ZUZlYXR1cmUiLCJlZGl0SGFuZGxlcyIsImdldFN0YXRlIiwib25VcGRhdGVHdWlkZXMiLCJnZXRFZGl0SGFuZGxlcyIsInBpY2tzIiwibWFwQ29vcmRzIiwiZ2V0VGVudGF0aXZlRmVhdHVyZSIsImdldEVkaXRIYW5kbGVzQWRhcHRlciIsImN1cnJlbnRDdXJzb3IiLCJnZXRDdXJzb3IiLCJ1cGRhdGVkQ3Vyc29yIiwiZ2V0Q3Vyc29yQWRhcHRlciIsImlzRHJhZ2dpbmciLCJvblVwZGF0ZUN1cnNvciIsInBpY2tlZEluZGV4ZXMiLCJpbmRleCIsInNlbGVjdGVkRmVhdHVyZUluZGV4ZXMiLCJzb21lIiwiaW5jbHVkZXMiLCJnZW9tZXRyeUFzQW55IiwidXBkYXRlZERhdGEiLCJnZXRJbW11dGFibGVGZWF0dXJlQ29sbGVjdGlvbiIsImFkZEZlYXR1cmUiLCJwcm9wZXJ0aWVzIiwiZWRpdFR5cGUiLCJlZGl0Q29udGV4dCIsImZlYXR1cmVJbmRleGVzIiwiaW5pdGlhbEluZGV4IiwidXBkYXRlZEluZGV4ZXMiLCJwdXNoIiwic2VsZWN0ZWRGZWF0dXJlIiwiZ2V0TW9kZUNvbmZpZyIsImJvb2xlYW5PcGVyYXRpb24iLCJ1cGRhdGVkR2VvbWV0cnkiLCJmZWF0dXJlSW5kZXgiLCJyZXBsYWNlR2VvbWV0cnkiLCJlZGl0QWN0aW9uIiwiZ2V0QWRkRmVhdHVyZUFjdGlvbiIsImV2ZW50IiwiaGFuZGxlQ2xpY2tBZGFwdGVyIiwib25FZGl0IiwiaGFuZGxlUG9pbnRlck1vdmVBZGFwdGVyIiwiY2FuY2VsTWFwUGFuIiwic291cmNlRXZlbnQiLCJzdG9wUHJvcGFnYXRpb24iLCJfcmVmcmVzaEN1cnNvciIsImhhbmRsZVN0YXJ0RHJhZ2dpbmdBZGFwdGVyIiwiaGFuZGxlU3RvcERyYWdnaW5nQWRhcHRlciIsIkJhc2VFZGl0TW9kZSIsImdldFBpY2tlZEVkaXRIYW5kbGUiLCJpbmZvIiwiZmluZCIsInBpY2siLCJpc0d1aWRlIiwib2JqZWN0IiwiZ2V0SW50ZXJtZWRpYXRlUG9zaXRpb24iLCJwb3NpdGlvbjEiLCJwb3NpdGlvbjIiLCJpbnRlcm1lZGlhdGVQb3NpdGlvbiIsImdldEVkaXRIYW5kbGVzRm9yR2VvbWV0cnkiLCJlZGl0SGFuZGxlVHlwZSIsImhhbmRsZXMiLCJwb3NpdGlvbiIsImNvb3JkaW5hdGVzIiwicG9zaXRpb25JbmRleGVzIiwiY29uY2F0IiwiZ2V0RWRpdEhhbmRsZXNGb3JDb29yZGluYXRlcyIsImEiLCJzbGljZSIsImIiLCJFcnJvciIsInBvc2l0aW9uSW5kZXhQcmVmaXgiLCJpIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBRUE7O0FBQ0E7O0FBQ0E7O0FBWUE7O0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBY0EsSUFBTUEsb0JBQWtDLEdBQUcsRUFBM0MsQyxDQUVBOztJQUdhQyxtQjs7Ozs7QUFDWDtBQUlBLCtCQUFZQyxpQkFBWixFQUFtRDtBQUFBOztBQUFBOztBQUNqRDs7QUFEaUQ7O0FBQUEsNkZBRnRCLEVBRXNCOztBQUVqRCxRQUFJQSxpQkFBSixFQUF1QjtBQUNyQixZQUFLQyxvQkFBTCxDQUEwQkQsaUJBQTFCO0FBQ0Q7O0FBSmdEO0FBS2xEOzs7OzJDQUV5QztBQUN4QyxhQUFPLEtBQUtBLGlCQUFMLENBQXVCRSxTQUF2QixFQUFQO0FBQ0Q7OztvREFFMkQ7QUFDMUQsYUFBTyxLQUFLRixpQkFBWjtBQUNEOzs7eUNBRThCO0FBQzdCLFVBQUksS0FBS0csa0JBQUwsR0FBMEJDLE1BQTFCLEtBQXFDLENBQXpDLEVBQTRDO0FBQzFDLGVBQU8sS0FBS0osaUJBQUwsQ0FBdUJFLFNBQXZCLEdBQW1DRyxRQUFuQyxDQUE0QyxLQUFLRixrQkFBTCxHQUEwQixDQUExQixDQUE1QyxDQUFQO0FBQ0Q7O0FBQ0QsYUFBTyxJQUFQO0FBQ0Q7OzswQ0FFZ0M7QUFDL0IsVUFBTUcsT0FBTyxHQUFHLEtBQUtDLGtCQUFMLEVBQWhCOztBQUNBLFVBQUlELE9BQUosRUFBYTtBQUNYLGVBQU9BLE9BQU8sQ0FBQ0UsUUFBZjtBQUNEOztBQUNELGFBQU8sSUFBUDtBQUNEOzs7NkRBRTJEO0FBQUEsa0NBQ3JDLEtBQUtSLGlCQUFMLENBQXVCRSxTQUF2QixFQURxQztBQUFBLFVBQ2xERyxRQURrRCx5QkFDbERBLFFBRGtEOztBQUUxRCxVQUFNSSxnQkFBZ0IsR0FBRyxLQUFLQyx5QkFBTCxHQUFpQ0MsR0FBakMsQ0FDdkIsVUFBQUMsYUFBYTtBQUFBLGVBQUlQLFFBQVEsQ0FBQ08sYUFBRCxDQUFaO0FBQUEsT0FEVSxDQUF6QjtBQUdBLGFBQU87QUFDTEMsUUFBQUEsSUFBSSxFQUFFLG1CQUREO0FBRUxSLFFBQUFBLFFBQVEsRUFBRUk7QUFGTCxPQUFQO0FBSUQ7OztvQ0FFcUI7QUFDcEIsV0FBS1Isb0JBQUwsQ0FBMEIsS0FBS2EsT0FBTCxFQUExQjs7QUFDQSxXQUFLQyxtQkFBTDtBQUNEOzs7eUNBRW9CZixpQixFQUE0QztBQUMvRCxXQUFLQSxpQkFBTCxHQUF5QixJQUFJZ0Isc0RBQUosQ0FBK0JoQixpQkFBL0IsQ0FBekI7QUFDRCxLLENBRUQ7Ozs7a0NBQ2NpQixVLEVBQXVCO0FBQ25DQyxNQUFBQSxPQUFPLENBQUNDLElBQVIsQ0FBYSxzQ0FBYixFQURtQyxDQUNtQjtBQUN2RCxLLENBRUQ7Ozs7Z0RBQ3NDO0FBQ3BDLGFBQU8sS0FBS2hCLGtCQUFMLEVBQVA7QUFDRCxLLENBRUQ7Ozs7OENBQzBCaUIsTyxFQUF5QjtBQUNqREYsTUFBQUEsT0FBTyxDQUFDQyxJQUFSLENBQWEsa0RBQWIsRUFEaUQsQ0FDaUI7QUFDbkU7OzsrQ0FFZ0M7QUFDL0IsV0FBS0Usb0JBQUwsQ0FBMEIsSUFBMUI7QUFDRDs7O29DQUVlQyxTLEVBQWtFO0FBQ2hGLFVBQU1DLE1BQU0sR0FBRyxLQUFLQyxTQUFMLEVBQWY7O0FBRUEsVUFBSSxDQUFDRCxNQUFMLEVBQWE7QUFDWDtBQUNBLGFBQUtFLGNBQUwsR0FBc0IsRUFBdEI7QUFDRDs7QUFFRCxVQUNFSCxTQUFTLElBQ1RBLFNBQVMsQ0FBQ0MsTUFEVixJQUVBQSxNQUZBLElBR0FELFNBQVMsQ0FBQ0MsTUFBVixDQUFpQkcsZ0JBQWpCLEtBQXNDSCxNQUFNLENBQUNHLGdCQUovQyxFQUtFO0FBQ0E7QUFDQSxhQUFLWCxtQkFBTDtBQUNEO0FBQ0Y7Ozt1Q0FFOEI7QUFDN0IsYUFBTyxLQUFLVSxjQUFaO0FBQ0Q7Ozt5Q0FFMEI7QUFDekIsV0FBS0EsY0FBTCxHQUFzQixFQUF0QjtBQUNEOzs7MENBRStCO0FBQUEsaUJBQ0QsS0FBS0QsU0FBTCxNQUFvQixFQURuQjtBQUFBLFVBQ3RCRSxnQkFEc0IsUUFDdEJBLGdCQURzQjs7QUFFOUIsYUFBT0EsZ0JBQVA7QUFDRDs7O3FDQUU4QjtBQUFBLGtCQUNMLEtBQUtGLFNBQUwsTUFBb0I7QUFBRUcsUUFBQUEsV0FBVyxFQUFFN0I7QUFBZixPQURmO0FBQUEsVUFDckI2QixXQURxQixTQUNyQkEsV0FEcUI7O0FBRTdCLGFBQU9BLFdBQVA7QUFDRCxLLENBRUQ7Ozs7eUNBQ3FCRCxnQixFQUFrQztBQUNyRCxXQUFLRSxRQUFMLEdBQWdCQyxjQUFoQixDQUErQjtBQUM3QkgsUUFBQUEsZ0JBQWdCLEVBQWhCQSxnQkFENkI7QUFFN0JDLFFBQUFBLFdBQVcsRUFBRSxLQUFLRyxjQUFMO0FBRmdCLE9BQS9CO0FBSUQsSyxDQUVEOzs7O3dDQUNvQkMsSyxFQUF1QkMsUyxFQUE0QjtBQUNyRSxXQUFLSixRQUFMLEdBQWdCQyxjQUFoQixDQUErQjtBQUM3QkgsUUFBQUEsZ0JBQWdCLEVBQUUsS0FBS08sbUJBQUwsRUFEVztBQUU3Qk4sUUFBQUEsV0FBVyxFQUFFLEtBQUtPLHFCQUFMLENBQTJCSCxLQUEzQixFQUFrQ0MsU0FBbEM7QUFGZ0IsT0FBL0I7QUFJRDs7O3FDQUVzQjtBQUNyQixVQUFNRyxhQUFhLEdBQUcsS0FBS0MsU0FBTCxFQUF0QjtBQUNBLFVBQU1DLGFBQWEsR0FBRyxLQUFLQyxnQkFBTCxDQUFzQjtBQUFFQyxRQUFBQSxVQUFVLEVBQUU7QUFBZCxPQUF0QixDQUF0Qjs7QUFFQSxVQUFJSixhQUFhLEtBQUtFLGFBQXRCLEVBQXFDO0FBQ25DLGFBQUtHLGNBQUwsQ0FBb0JILGFBQXBCO0FBQ0Q7QUFDRjtBQUVEOzs7Ozs7OzswQ0FNRU4sSyxFQUNBQyxTLEVBQ0FOLGdCLEVBQ2M7QUFDZCxhQUFPNUIsb0JBQVA7QUFDRDs7OzRDQUVpRTtBQUFBLFVBQS9DeUMsVUFBK0MsU0FBL0NBLFVBQStDO0FBQ2hFLGFBQU8sTUFBUDtBQUNEOzs7c0NBRWlCUixLLEVBQXdCO0FBQ3hDLFVBQUksQ0FBQ0EsS0FBSyxDQUFDM0IsTUFBWCxFQUFtQixPQUFPLEtBQVA7QUFDbkIsVUFBTXFDLGFBQWEsR0FBR1YsS0FBSyxDQUFDcEIsR0FBTixDQUFVO0FBQUEsWUFBRytCLEtBQUgsU0FBR0EsS0FBSDtBQUFBLGVBQWVBLEtBQWY7QUFBQSxPQUFWLENBQXRCO0FBQ0EsVUFBTUMsc0JBQXNCLEdBQUcsS0FBS2pDLHlCQUFMLEVBQS9CO0FBQ0EsYUFBT2lDLHNCQUFzQixDQUFDQyxJQUF2QixDQUE0QixVQUFBRixLQUFLO0FBQUEsZUFBSUQsYUFBYSxDQUFDSSxRQUFkLENBQXVCSCxLQUF2QixDQUFKO0FBQUEsT0FBakMsQ0FBUDtBQUNEOzs7d0NBRW1CbEMsUSxFQUF1QztBQUN6RDtBQUNBLFVBQU1zQyxhQUFrQixHQUFHdEMsUUFBM0I7QUFFQSxVQUFNdUMsV0FBVyxHQUFHLEtBQUtDLDZCQUFMLEdBQ2pCQyxVQURpQixDQUNOO0FBQ1ZwQyxRQUFBQSxJQUFJLEVBQUUsU0FESTtBQUVWcUMsUUFBQUEsVUFBVSxFQUFFLEVBRkY7QUFHVjFDLFFBQUFBLFFBQVEsRUFBRXNDO0FBSEEsT0FETSxFQU1qQjVDLFNBTmlCLEVBQXBCO0FBUUEsYUFBTztBQUNMNkMsUUFBQUEsV0FBVyxFQUFYQSxXQURLO0FBRUxJLFFBQUFBLFFBQVEsRUFBRSxZQUZMO0FBR0xDLFFBQUFBLFdBQVcsRUFBRTtBQUNYQyxVQUFBQSxjQUFjLEVBQUUsQ0FBQ04sV0FBVyxDQUFDMUMsUUFBWixDQUFxQkQsTUFBckIsR0FBOEIsQ0FBL0I7QUFETDtBQUhSLE9BQVA7QUFPRDs7OzZDQUV3QkosaUIsRUFBeUQ7QUFDaEYsVUFBTUssUUFBUSxHQUFHTCxpQkFBaUIsQ0FBQ0ssUUFBbkM7QUFDQSxVQUFJMEMsV0FBVyxHQUFHLEtBQUtDLDZCQUFMLEVBQWxCO0FBQ0EsVUFBTU0sWUFBWSxHQUFHUCxXQUFXLENBQUM3QyxTQUFaLEdBQXdCRyxRQUF4QixDQUFpQ0QsTUFBdEQ7QUFDQSxVQUFNbUQsY0FBYyxHQUFHLEVBQXZCO0FBSmdGO0FBQUE7QUFBQTs7QUFBQTtBQUtoRiw2QkFBc0JsRCxRQUF0Qiw4SEFBZ0M7QUFBQSxjQUFyQkMsT0FBcUI7QUFBQSxjQUN0QjRDLFVBRHNCLEdBQ0c1QyxPQURILENBQ3RCNEMsVUFEc0I7QUFBQSxjQUNWMUMsUUFEVSxHQUNHRixPQURILENBQ1ZFLFFBRFU7QUFFOUIsY0FBTXNDLGFBQWtCLEdBQUd0QyxRQUEzQjtBQUNBdUMsVUFBQUEsV0FBVyxHQUFHQSxXQUFXLENBQUNFLFVBQVosQ0FBdUI7QUFDbkNwQyxZQUFBQSxJQUFJLEVBQUUsU0FENkI7QUFFbkNxQyxZQUFBQSxVQUFVLEVBQVZBLFVBRm1DO0FBR25DMUMsWUFBQUEsUUFBUSxFQUFFc0M7QUFIeUIsV0FBdkIsQ0FBZDtBQUtBUyxVQUFBQSxjQUFjLENBQUNDLElBQWYsQ0FBb0JGLFlBQVksR0FBR0MsY0FBYyxDQUFDbkQsTUFBbEQ7QUFDRDtBQWQrRTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQWdCaEYsYUFBTztBQUNMMkMsUUFBQUEsV0FBVyxFQUFFQSxXQUFXLENBQUM3QyxTQUFaLEVBRFI7QUFFTGlELFFBQUFBLFFBQVEsRUFBRSxZQUZMO0FBR0xDLFFBQUFBLFdBQVcsRUFBRTtBQUNYQyxVQUFBQSxjQUFjLEVBQUVFO0FBREw7QUFIUixPQUFQO0FBT0Q7Ozt3REFFbUMvQyxRLEVBQXVDO0FBQ3pFLFVBQU1pRCxlQUFlLEdBQUcsS0FBS2xELGtCQUFMLEVBQXhCO0FBQ0EsVUFBTVUsVUFBVSxHQUFHLEtBQUt5QyxhQUFMLEVBQW5COztBQUNBLFVBQUl6QyxVQUFVLElBQUlBLFVBQVUsQ0FBQzBDLGdCQUE3QixFQUErQztBQUM3QyxZQUNFLENBQUNGLGVBQUQsSUFDQ0EsZUFBZSxDQUFDakQsUUFBaEIsQ0FBeUJLLElBQXpCLEtBQWtDLFNBQWxDLElBQ0M0QyxlQUFlLENBQUNqRCxRQUFoQixDQUF5QkssSUFBekIsS0FBa0MsY0FIdEMsRUFJRTtBQUNBO0FBQ0FLLFVBQUFBLE9BQU8sQ0FBQ0MsSUFBUixDQUNFLDhFQURGO0FBR0EsaUJBQU8sSUFBUDtBQUNEOztBQUVELFlBQU1iLE9BQU8sR0FBRztBQUNkTyxVQUFBQSxJQUFJLEVBQUUsU0FEUTtBQUVkTCxVQUFBQSxRQUFRLEVBQVJBO0FBRmMsU0FBaEI7QUFLQSxZQUFJb0QsZUFBSjs7QUFDQSxZQUFJM0MsVUFBVSxDQUFDMEMsZ0JBQVgsS0FBZ0MsT0FBcEMsRUFBNkM7QUFDM0NDLFVBQUFBLGVBQWUsR0FBRyxvQkFBVUgsZUFBVixFQUEyQm5ELE9BQTNCLENBQWxCO0FBQ0QsU0FGRCxNQUVPLElBQUlXLFVBQVUsQ0FBQzBDLGdCQUFYLEtBQWdDLFlBQXBDLEVBQWtEO0FBQ3ZEQyxVQUFBQSxlQUFlLEdBQUcseUJBQWVILGVBQWYsRUFBZ0NuRCxPQUFoQyxDQUFsQjtBQUNELFNBRk0sTUFFQSxJQUFJVyxVQUFVLENBQUMwQyxnQkFBWCxLQUFnQyxjQUFwQyxFQUFvRDtBQUN6REMsVUFBQUEsZUFBZSxHQUFHLHdCQUFjSCxlQUFkLEVBQStCbkQsT0FBL0IsQ0FBbEI7QUFDRCxTQUZNLE1BRUE7QUFDTDtBQUNBWSxVQUFBQSxPQUFPLENBQUNDLElBQVIsb0NBQXlDRixVQUFVLENBQUMwQyxnQkFBcEQ7QUFDQSxpQkFBTyxJQUFQO0FBQ0Q7O0FBRUQsWUFBSSxDQUFDQyxlQUFMLEVBQXNCO0FBQ3BCO0FBQ0ExQyxVQUFBQSxPQUFPLENBQUNDLElBQVIsQ0FBYSwwREFBYjtBQUNBLGlCQUFPLElBQVA7QUFDRDs7QUFFRCxZQUFNMEMsWUFBWSxHQUFHLEtBQUtuRCx5QkFBTCxHQUFpQyxDQUFqQyxDQUFyQjtBQUVBLFlBQU1xQyxXQUFXLEdBQUcsS0FBS0MsNkJBQUwsR0FDakJjLGVBRGlCLENBQ0RELFlBREMsRUFDYUQsZUFBZSxDQUFDcEQsUUFEN0IsRUFFakJOLFNBRmlCLEVBQXBCO0FBSUEsWUFBTTZELFVBQTZCLEdBQUc7QUFDcENoQixVQUFBQSxXQUFXLEVBQVhBLFdBRG9DO0FBRXBDSSxVQUFBQSxRQUFRLEVBQUUsZUFGMEI7QUFHcENDLFVBQUFBLFdBQVcsRUFBRTtBQUNYQyxZQUFBQSxjQUFjLEVBQUUsQ0FBQ1EsWUFBRDtBQURMO0FBSHVCLFNBQXRDO0FBUUEsZUFBT0UsVUFBUDtBQUNEOztBQUNELGFBQU8sS0FBS0MsbUJBQUwsQ0FBeUJ4RCxRQUF6QixDQUFQO0FBQ0Q7OztnQ0FFV3lELEssRUFBeUI7QUFDbkMsVUFBTUYsVUFBVSxHQUFHLEtBQUtHLGtCQUFMLENBQXdCRCxLQUF4QixDQUFuQjs7QUFFQSxXQUFLbEQsbUJBQUwsQ0FBeUJrRCxLQUFLLENBQUNsQyxLQUEvQixFQUFzQ2tDLEtBQUssQ0FBQ2pDLFNBQTVDOztBQUNBLFVBQUkrQixVQUFKLEVBQWdCO0FBQ2QsYUFBS0ksTUFBTCxDQUFZSixVQUFaO0FBQ0Q7QUFDRjs7O3NDQUVpQkUsSyxFQUErQjtBQUFBLGtDQUNWLEtBQUtHLHdCQUFMLENBQThCSCxLQUE5QixDQURVO0FBQUEsVUFDdkNGLFVBRHVDLHlCQUN2Q0EsVUFEdUM7QUFBQSxVQUMzQk0sWUFEMkIseUJBQzNCQSxZQUQyQjs7QUFHL0MsVUFBSUEsWUFBSixFQUFrQjtBQUNoQjtBQUNBO0FBQ0FKLFFBQUFBLEtBQUssQ0FBQ0ssV0FBTixDQUFrQkMsZUFBbEI7QUFDRDs7QUFFRCxXQUFLQyxjQUFMOztBQUNBLFdBQUt6RCxtQkFBTCxDQUF5QmtELEtBQUssQ0FBQ2xDLEtBQS9CLEVBQXNDa0MsS0FBSyxDQUFDakMsU0FBNUM7O0FBQ0EsVUFBSStCLFVBQUosRUFBZ0I7QUFDZCxhQUFLSSxNQUFMLENBQVlKLFVBQVo7QUFDRDtBQUNGOzs7d0NBRW1CRSxLLEVBQWlDO0FBQ25ELFVBQU1GLFVBQVUsR0FBRyxLQUFLVSwwQkFBTCxDQUFnQ1IsS0FBaEMsQ0FBbkI7O0FBRUEsV0FBS2xELG1CQUFMLENBQXlCa0QsS0FBSyxDQUFDbEMsS0FBL0IsRUFBc0NrQyxLQUFLLENBQUNqQyxTQUE1Qzs7QUFDQSxVQUFJK0IsVUFBSixFQUFnQjtBQUNkLGFBQUtJLE1BQUwsQ0FBWUosVUFBWjtBQUNEO0FBQ0Y7Ozt1Q0FFa0JFLEssRUFBZ0M7QUFDakQsVUFBTUYsVUFBVSxHQUFHLEtBQUtXLHlCQUFMLENBQStCVCxLQUEvQixDQUFuQjs7QUFFQSxXQUFLbEQsbUJBQUwsQ0FBeUJrRCxLQUFLLENBQUNsQyxLQUEvQixFQUFzQ2tDLEtBQUssQ0FBQ2pDLFNBQTVDOztBQUNBLFVBQUkrQixVQUFKLEVBQWdCO0FBQ2QsYUFBS0ksTUFBTCxDQUFZSixVQUFaO0FBQ0Q7QUFDRixLLENBRUQ7Ozs7dUNBQ21CRSxLLEVBQXVDO0FBQ3hELFdBQUt4QyxjQUFMLENBQW9CK0IsSUFBcEIsQ0FBeUJTLEtBQUssQ0FBQ2pDLFNBQS9COztBQUVBLGFBQU8sSUFBUDtBQUNEOzs7NkNBR0NpQyxLLEVBQzJEO0FBQzNELGFBQU87QUFBRUYsUUFBQUEsVUFBVSxFQUFFLElBQWQ7QUFBb0JNLFFBQUFBLFlBQVksRUFBRTtBQUFsQyxPQUFQO0FBQ0Q7OzsrQ0FFMEJKLEssRUFBK0M7QUFDeEUsYUFBTyxJQUFQO0FBQ0Q7Ozs4Q0FFeUJBLEssRUFBOEM7QUFDdEUsYUFBTyxJQUFQO0FBQ0Q7Ozs7RUF2VXNDVSxzQjs7OztBQTBVbEMsU0FBU0MsbUJBQVQsQ0FBNkI3QyxLQUE3QixFQUEyRDtBQUNoRSxNQUFNOEMsSUFBSSxHQUFHOUMsS0FBSyxJQUFJQSxLQUFLLENBQUMrQyxJQUFOLENBQVcsVUFBQUMsSUFBSTtBQUFBLFdBQUlBLElBQUksQ0FBQ0MsT0FBVDtBQUFBLEdBQWYsQ0FBdEI7O0FBQ0EsTUFBSUgsSUFBSixFQUFVO0FBQ1IsV0FBT0EsSUFBSSxDQUFDSSxNQUFaO0FBQ0Q7O0FBQ0QsU0FBTyxJQUFQO0FBQ0Q7O0FBRU0sU0FBU0MsdUJBQVQsQ0FBaUNDLFNBQWpDLEVBQXNEQyxTQUF0RCxFQUFxRjtBQUMxRixNQUFNQyxvQkFBb0IsR0FBRyxDQUMzQixDQUFDRixTQUFTLENBQUMsQ0FBRCxDQUFULEdBQWVDLFNBQVMsQ0FBQyxDQUFELENBQXpCLElBQWdDLEdBREwsRUFFM0IsQ0FBQ0QsU0FBUyxDQUFDLENBQUQsQ0FBVCxHQUFlQyxTQUFTLENBQUMsQ0FBRCxDQUF6QixJQUFnQyxHQUZMLENBQTdCO0FBSUEsU0FBT0Msb0JBQVA7QUFDRDs7QUFFTSxTQUFTQyx5QkFBVCxDQUNMOUUsUUFESyxFQUVMcUQsWUFGSyxFQUlMO0FBQUEsTUFEQTBCLGNBQ0EsdUVBRGlDLFVBQ2pDO0FBQ0EsTUFBSUMsT0FBcUIsR0FBRyxFQUE1Qjs7QUFFQSxVQUFRaEYsUUFBUSxDQUFDSyxJQUFqQjtBQUNFLFNBQUssT0FBTDtBQUNFO0FBQ0EyRSxNQUFBQSxPQUFPLEdBQUcsQ0FDUjtBQUNFQyxRQUFBQSxRQUFRLEVBQUVqRixRQUFRLENBQUNrRixXQURyQjtBQUVFQyxRQUFBQSxlQUFlLEVBQUUsRUFGbkI7QUFHRTlCLFFBQUFBLFlBQVksRUFBWkEsWUFIRjtBQUlFaEQsUUFBQUEsSUFBSSxFQUFFMEU7QUFKUixPQURRLENBQVY7QUFRQTs7QUFDRixTQUFLLFlBQUw7QUFDQSxTQUFLLFlBQUw7QUFDRTtBQUNBQyxNQUFBQSxPQUFPLEdBQUdBLE9BQU8sQ0FBQ0ksTUFBUixDQUNSQyw0QkFBNEIsQ0FBQ3JGLFFBQVEsQ0FBQ2tGLFdBQVYsRUFBdUIsRUFBdkIsRUFBMkI3QixZQUEzQixFQUF5QzBCLGNBQXpDLENBRHBCLENBQVY7QUFHQTs7QUFDRixTQUFLLFNBQUw7QUFDQSxTQUFLLGlCQUFMO0FBQ0U7QUFDQSxXQUFLLElBQUlPLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUd0RixRQUFRLENBQUNrRixXQUFULENBQXFCdEYsTUFBekMsRUFBaUQwRixDQUFDLEVBQWxELEVBQXNEO0FBQ3BETixRQUFBQSxPQUFPLEdBQUdBLE9BQU8sQ0FBQ0ksTUFBUixDQUNSQyw0QkFBNEIsQ0FBQ3JGLFFBQVEsQ0FBQ2tGLFdBQVQsQ0FBcUJJLENBQXJCLENBQUQsRUFBMEIsQ0FBQ0EsQ0FBRCxDQUExQixFQUErQmpDLFlBQS9CLEVBQTZDMEIsY0FBN0MsQ0FEcEIsQ0FBVjs7QUFHQSxZQUFJL0UsUUFBUSxDQUFDSyxJQUFULEtBQWtCLFNBQXRCLEVBQWlDO0FBQy9CO0FBQ0EyRSxVQUFBQSxPQUFPLEdBQUdBLE9BQU8sQ0FBQ08sS0FBUixDQUFjLENBQWQsRUFBaUIsQ0FBQyxDQUFsQixDQUFWO0FBQ0Q7QUFDRjs7QUFDRDs7QUFDRixTQUFLLGNBQUw7QUFDRTtBQUNBLFdBQUssSUFBSUQsRUFBQyxHQUFHLENBQWIsRUFBZ0JBLEVBQUMsR0FBR3RGLFFBQVEsQ0FBQ2tGLFdBQVQsQ0FBcUJ0RixNQUF6QyxFQUFpRDBGLEVBQUMsRUFBbEQsRUFBc0Q7QUFDcEQsYUFBSyxJQUFJRSxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHeEYsUUFBUSxDQUFDa0YsV0FBVCxDQUFxQkksRUFBckIsRUFBd0IxRixNQUE1QyxFQUFvRDRGLENBQUMsRUFBckQsRUFBeUQ7QUFDdkRSLFVBQUFBLE9BQU8sR0FBR0EsT0FBTyxDQUFDSSxNQUFSLENBQ1JDLDRCQUE0QixDQUMxQnJGLFFBQVEsQ0FBQ2tGLFdBQVQsQ0FBcUJJLEVBQXJCLEVBQXdCRSxDQUF4QixDQUQwQixFQUUxQixDQUFDRixFQUFELEVBQUlFLENBQUosQ0FGMEIsRUFHMUJuQyxZQUgwQixFQUkxQjBCLGNBSjBCLENBRHBCLENBQVYsQ0FEdUQsQ0FTdkQ7O0FBQ0FDLFVBQUFBLE9BQU8sR0FBR0EsT0FBTyxDQUFDTyxLQUFSLENBQWMsQ0FBZCxFQUFpQixDQUFDLENBQWxCLENBQVY7QUFDRDtBQUNGOztBQUNEOztBQUNGO0FBQ0UsWUFBTUUsS0FBSyxvQ0FBNkJ6RixRQUFRLENBQUNLLElBQXRDLEVBQVg7QUFsREo7O0FBcURBLFNBQU8yRSxPQUFQO0FBQ0Q7O0FBRUQsU0FBU0ssNEJBQVQsQ0FDRUgsV0FERixFQUVFUSxtQkFGRixFQUdFckMsWUFIRixFQUtnQjtBQUFBLE1BRGQwQixjQUNjLHVFQURtQixVQUNuQjtBQUNkLE1BQU01RCxXQUFXLEdBQUcsRUFBcEI7O0FBQ0EsT0FBSyxJQUFJd0UsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR1QsV0FBVyxDQUFDdEYsTUFBaEMsRUFBd0MrRixDQUFDLEVBQXpDLEVBQTZDO0FBQzNDLFFBQU1WLFFBQVEsR0FBR0MsV0FBVyxDQUFDUyxDQUFELENBQTVCO0FBQ0F4RSxJQUFBQSxXQUFXLENBQUM2QixJQUFaLENBQWlCO0FBQ2ZpQyxNQUFBQSxRQUFRLEVBQVJBLFFBRGU7QUFFZkUsTUFBQUEsZUFBZSxxQkFBTU8sbUJBQU4sVUFBMkJDLENBQTNCLEVBRkE7QUFHZnRDLE1BQUFBLFlBQVksRUFBWkEsWUFIZTtBQUlmaEQsTUFBQUEsSUFBSSxFQUFFMEU7QUFKUyxLQUFqQjtBQU1EOztBQUNELFNBQU81RCxXQUFQO0FBQ0QiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBAZmxvd1xuXG5pbXBvcnQgdHVyZlVuaW9uIGZyb20gJ0B0dXJmL3VuaW9uJztcbmltcG9ydCB0dXJmRGlmZmVyZW5jZSBmcm9tICdAdHVyZi9kaWZmZXJlbmNlJztcbmltcG9ydCB0dXJmSW50ZXJzZWN0IGZyb20gJ0B0dXJmL2ludGVyc2VjdCc7XG5cbmltcG9ydCB0eXBlIHtcbiAgRWRpdEFjdGlvbixcbiAgQ2xpY2tFdmVudCxcbiAgUG9pbnRlck1vdmVFdmVudCxcbiAgU3RhcnREcmFnZ2luZ0V2ZW50LFxuICBTdG9wRHJhZ2dpbmdFdmVudCxcbiAgUGlja1xufSBmcm9tICcuLi90eXBlcy5qcyc7XG5pbXBvcnQgdHlwZSB7IEZlYXR1cmVDb2xsZWN0aW9uLCBGZWF0dXJlLCBQb2x5Z29uLCBHZW9tZXRyeSwgUG9zaXRpb24gfSBmcm9tICcuLi9nZW9qc29uLXR5cGVzLmpzJztcbmltcG9ydCB0eXBlIHsgTW9kZVN0YXRlIH0gZnJvbSAnLi9lZGl0LW1vZGUuanMnO1xuaW1wb3J0IHsgRWRpdE1vZGUsIEJhc2VFZGl0TW9kZSB9IGZyb20gJy4vZWRpdC1tb2RlLmpzJztcblxuaW1wb3J0IHsgSW1tdXRhYmxlRmVhdHVyZUNvbGxlY3Rpb24gfSBmcm9tICcuL2ltbXV0YWJsZS1mZWF0dXJlLWNvbGxlY3Rpb24uanMnO1xuXG5leHBvcnQgdHlwZSBFZGl0SGFuZGxlVHlwZSA9ICdleGlzdGluZycgfCAnaW50ZXJtZWRpYXRlJyB8ICdzbmFwJztcblxuZXhwb3J0IHR5cGUgRWRpdEhhbmRsZSA9IHtcbiAgcG9zaXRpb246IFBvc2l0aW9uLFxuICBwb3NpdGlvbkluZGV4ZXM6IG51bWJlcltdLFxuICBmZWF0dXJlSW5kZXg6IG51bWJlcixcbiAgdHlwZTogRWRpdEhhbmRsZVR5cGVcbn07XG5cbmV4cG9ydCB0eXBlIEdlb0pzb25FZGl0QWN0aW9uID0gRWRpdEFjdGlvbjxGZWF0dXJlQ29sbGVjdGlvbj47XG5leHBvcnQgdHlwZSBNb2RlSGFuZGxlckd1aWRlcyA9IHsgdGVudGF0aXZlRmVhdHVyZTogP0ZlYXR1cmUsIGVkaXRIYW5kbGVzOiBFZGl0SGFuZGxlW10gfTtcblxuY29uc3QgREVGQVVMVF9FRElUX0hBTkRMRVM6IEVkaXRIYW5kbGVbXSA9IFtdO1xuXG4vLyBNYWluIGludGVyZmFjZSBmb3IgYEVkaXRNb2RlYHMgdGhhdCBlZGl0IEdlb0pTT05cbmV4cG9ydCB0eXBlIEdlb0pzb25FZGl0TW9kZSA9IEVkaXRNb2RlPEZlYXR1cmVDb2xsZWN0aW9uLCBNb2RlSGFuZGxlckd1aWRlcz47XG5cbmV4cG9ydCBjbGFzcyBCYXNlR2VvSnNvbkVkaXRNb2RlIGV4dGVuZHMgQmFzZUVkaXRNb2RlPEZlYXR1cmVDb2xsZWN0aW9uLCBNb2RlSGFuZGxlckd1aWRlcz4ge1xuICAvLyBUT0RPOiBhZGQgdW5kZXJzY29yZVxuICBmZWF0dXJlQ29sbGVjdGlvbjogSW1tdXRhYmxlRmVhdHVyZUNvbGxlY3Rpb247XG4gIF9jbGlja1NlcXVlbmNlOiBQb3NpdGlvbltdID0gW107XG5cbiAgY29uc3RydWN0b3IoZmVhdHVyZUNvbGxlY3Rpb24/OiBGZWF0dXJlQ29sbGVjdGlvbikge1xuICAgIHN1cGVyKCk7XG4gICAgaWYgKGZlYXR1cmVDb2xsZWN0aW9uKSB7XG4gICAgICB0aGlzLnNldEZlYXR1cmVDb2xsZWN0aW9uKGZlYXR1cmVDb2xsZWN0aW9uKTtcbiAgICB9XG4gIH1cblxuICBnZXRGZWF0dXJlQ29sbGVjdGlvbigpOiBGZWF0dXJlQ29sbGVjdGlvbiB7XG4gICAgcmV0dXJuIHRoaXMuZmVhdHVyZUNvbGxlY3Rpb24uZ2V0T2JqZWN0KCk7XG4gIH1cblxuICBnZXRJbW11dGFibGVGZWF0dXJlQ29sbGVjdGlvbigpOiBJbW11dGFibGVGZWF0dXJlQ29sbGVjdGlvbiB7XG4gICAgcmV0dXJuIHRoaXMuZmVhdHVyZUNvbGxlY3Rpb247XG4gIH1cblxuICBnZXRTZWxlY3RlZEZlYXR1cmUoKTogP0ZlYXR1cmUge1xuICAgIGlmICh0aGlzLmdldFNlbGVjdGVkSW5kZXhlcygpLmxlbmd0aCA9PT0gMSkge1xuICAgICAgcmV0dXJuIHRoaXMuZmVhdHVyZUNvbGxlY3Rpb24uZ2V0T2JqZWN0KCkuZmVhdHVyZXNbdGhpcy5nZXRTZWxlY3RlZEluZGV4ZXMoKVswXV07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZ2V0U2VsZWN0ZWRHZW9tZXRyeSgpOiA/R2VvbWV0cnkge1xuICAgIGNvbnN0IGZlYXR1cmUgPSB0aGlzLmdldFNlbGVjdGVkRmVhdHVyZSgpO1xuICAgIGlmIChmZWF0dXJlKSB7XG4gICAgICByZXR1cm4gZmVhdHVyZS5nZW9tZXRyeTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBnZXRTZWxlY3RlZEZlYXR1cmVzQXNGZWF0dXJlQ29sbGVjdGlvbigpOiBGZWF0dXJlQ29sbGVjdGlvbiB7XG4gICAgY29uc3QgeyBmZWF0dXJlcyB9ID0gdGhpcy5mZWF0dXJlQ29sbGVjdGlvbi5nZXRPYmplY3QoKTtcbiAgICBjb25zdCBzZWxlY3RlZEZlYXR1cmVzID0gdGhpcy5nZXRTZWxlY3RlZEZlYXR1cmVJbmRleGVzKCkubWFwKFxuICAgICAgc2VsZWN0ZWRJbmRleCA9PiBmZWF0dXJlc1tzZWxlY3RlZEluZGV4XVxuICAgICk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdGZWF0dXJlQ29sbGVjdGlvbicsXG4gICAgICBmZWF0dXJlczogc2VsZWN0ZWRGZWF0dXJlc1xuICAgIH07XG4gIH1cblxuICBvbkRhdGFDaGFuZ2VkKCk6IHZvaWQge1xuICAgIHRoaXMuc2V0RmVhdHVyZUNvbGxlY3Rpb24odGhpcy5nZXREYXRhKCkpO1xuICAgIHRoaXMuX3JlZnJlc2hFZGl0SGFuZGxlcygpO1xuICB9XG5cbiAgc2V0RmVhdHVyZUNvbGxlY3Rpb24oZmVhdHVyZUNvbGxlY3Rpb246IEZlYXR1cmVDb2xsZWN0aW9uKTogdm9pZCB7XG4gICAgdGhpcy5mZWF0dXJlQ29sbGVjdGlvbiA9IG5ldyBJbW11dGFibGVGZWF0dXJlQ29sbGVjdGlvbihmZWF0dXJlQ29sbGVjdGlvbik7XG4gIH1cblxuICAvLyBUT0RPOiBkZWxldGUgbWVcbiAgc2V0TW9kZUNvbmZpZyhtb2RlQ29uZmlnOiBhbnkpOiB2b2lkIHtcbiAgICBjb25zb2xlLndhcm4oJ1RPRE86IGNhbGwgdG8gb2Jzb2xldGUgc2V0TW9kZUNvbmZpZycpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gIH1cblxuICAvLyBUT0RPOiBkZWxldGUgbWVcbiAgZ2V0U2VsZWN0ZWRGZWF0dXJlSW5kZXhlcygpOiBudW1iZXJbXSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0U2VsZWN0ZWRJbmRleGVzKCk7XG4gIH1cblxuICAvLyBUT0RPOiBkZWxldGUgbWVcbiAgc2V0U2VsZWN0ZWRGZWF0dXJlSW5kZXhlcyhpbmRleGVzOiBudW1iZXJbXSk6IHZvaWQge1xuICAgIGNvbnNvbGUud2FybignVE9ETzogY2FsbCB0byBvYnNvbGV0ZSBzZXRTZWxlY3RlZEZlYXR1cmVJbmRleGVzJyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgfVxuXG4gIG9uU2VsZWN0ZWRJbmRleGVzQ2hhbmdlZCgpOiB2b2lkIHtcbiAgICB0aGlzLl9zZXRUZW50YXRpdmVGZWF0dXJlKG51bGwpO1xuICB9XG5cbiAgb25HdWlkZXNDaGFuZ2VkKHByZXZTdGF0ZTogTW9kZVN0YXRlPEZlYXR1cmVDb2xsZWN0aW9uLCBNb2RlSGFuZGxlckd1aWRlcz4pOiB2b2lkIHtcbiAgICBjb25zdCBndWlkZXMgPSB0aGlzLmdldEd1aWRlcygpO1xuXG4gICAgaWYgKCFndWlkZXMpIHtcbiAgICAgIC8vIFJlc2V0IHRoZSBjbGljayBzZXF1ZW5jZVxuICAgICAgdGhpcy5fY2xpY2tTZXF1ZW5jZSA9IFtdO1xuICAgIH1cblxuICAgIGlmIChcbiAgICAgIHByZXZTdGF0ZSAmJlxuICAgICAgcHJldlN0YXRlLmd1aWRlcyAmJlxuICAgICAgZ3VpZGVzICYmXG4gICAgICBwcmV2U3RhdGUuZ3VpZGVzLnRlbnRhdGl2ZUZlYXR1cmUgIT09IGd1aWRlcy50ZW50YXRpdmVGZWF0dXJlXG4gICAgKSB7XG4gICAgICAvLyByZS1jYWxjdWxhdGUgZWRpdCBoYW5kbGVzXG4gICAgICB0aGlzLl9yZWZyZXNoRWRpdEhhbmRsZXMoKTtcbiAgICB9XG4gIH1cblxuICBnZXRDbGlja1NlcXVlbmNlKCk6IFBvc2l0aW9uW10ge1xuICAgIHJldHVybiB0aGlzLl9jbGlja1NlcXVlbmNlO1xuICB9XG5cbiAgcmVzZXRDbGlja1NlcXVlbmNlKCk6IHZvaWQge1xuICAgIHRoaXMuX2NsaWNrU2VxdWVuY2UgPSBbXTtcbiAgfVxuXG4gIGdldFRlbnRhdGl2ZUZlYXR1cmUoKTogP0ZlYXR1cmUge1xuICAgIGNvbnN0IHsgdGVudGF0aXZlRmVhdHVyZSB9ID0gdGhpcy5nZXRHdWlkZXMoKSB8fCB7fTtcbiAgICByZXR1cm4gdGVudGF0aXZlRmVhdHVyZTtcbiAgfVxuXG4gIGdldEVkaXRIYW5kbGVzKCk6IEVkaXRIYW5kbGVbXSB7XG4gICAgY29uc3QgeyBlZGl0SGFuZGxlcyB9ID0gdGhpcy5nZXRHdWlkZXMoKSB8fCB7IGVkaXRIYW5kbGVzOiBERUZBVUxUX0VESVRfSEFORExFUyB9O1xuICAgIHJldHVybiBlZGl0SGFuZGxlcztcbiAgfVxuXG4gIC8vIFRPRE86IGRlbGV0ZSBtZSBvbmNlIG1vZGUgaGFuZGxlcnMgZG8gZ2V0RWRpdEhhbmRsZXMgbGF6aWx5XG4gIF9zZXRUZW50YXRpdmVGZWF0dXJlKHRlbnRhdGl2ZUZlYXR1cmU6ID9GZWF0dXJlKTogdm9pZCB7XG4gICAgdGhpcy5nZXRTdGF0ZSgpLm9uVXBkYXRlR3VpZGVzKHtcbiAgICAgIHRlbnRhdGl2ZUZlYXR1cmUsXG4gICAgICBlZGl0SGFuZGxlczogdGhpcy5nZXRFZGl0SGFuZGxlcygpXG4gICAgfSk7XG4gIH1cblxuICAvLyBUT0RPOiBkZWxldGUgbWUgb25jZSBtb2RlIGhhbmRsZXJzIGRvIGdldEVkaXRIYW5kbGVzIGxhemlseVxuICBfcmVmcmVzaEVkaXRIYW5kbGVzKHBpY2tzPzogQXJyYXk8T2JqZWN0PiwgbWFwQ29vcmRzPzogUG9zaXRpb24pOiB2b2lkIHtcbiAgICB0aGlzLmdldFN0YXRlKCkub25VcGRhdGVHdWlkZXMoe1xuICAgICAgdGVudGF0aXZlRmVhdHVyZTogdGhpcy5nZXRUZW50YXRpdmVGZWF0dXJlKCksXG4gICAgICBlZGl0SGFuZGxlczogdGhpcy5nZXRFZGl0SGFuZGxlc0FkYXB0ZXIocGlja3MsIG1hcENvb3JkcylcbiAgICB9KTtcbiAgfVxuXG4gIF9yZWZyZXNoQ3Vyc29yKCk6IHZvaWQge1xuICAgIGNvbnN0IGN1cnJlbnRDdXJzb3IgPSB0aGlzLmdldEN1cnNvcigpO1xuICAgIGNvbnN0IHVwZGF0ZWRDdXJzb3IgPSB0aGlzLmdldEN1cnNvckFkYXB0ZXIoeyBpc0RyYWdnaW5nOiBmYWxzZSB9KTtcblxuICAgIGlmIChjdXJyZW50Q3Vyc29yICE9PSB1cGRhdGVkQ3Vyc29yKSB7XG4gICAgICB0aGlzLm9uVXBkYXRlQ3Vyc29yKHVwZGF0ZWRDdXJzb3IpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgZmxhdCBhcnJheSBvZiBwb3NpdGlvbnMgZm9yIHRoZSBnaXZlbiBmZWF0dXJlIGFsb25nIHdpdGggdGhlaXIgaW5kZXhlcyBpbnRvIHRoZSBmZWF0dXJlJ3MgZ2VvbWV0cnkncyBjb29yZGluYXRlcy5cbiAgICpcbiAgICogQHBhcmFtIGZlYXR1cmVJbmRleCBUaGUgaW5kZXggb2YgdGhlIGZlYXR1cmUgdG8gZ2V0IGVkaXQgaGFuZGxlc1xuICAgKi9cbiAgZ2V0RWRpdEhhbmRsZXNBZGFwdGVyKFxuICAgIHBpY2tzPzogQXJyYXk8T2JqZWN0PixcbiAgICBtYXBDb29yZHM/OiBQb3NpdGlvbixcbiAgICB0ZW50YXRpdmVGZWF0dXJlPzogP0ZlYXR1cmVcbiAgKTogRWRpdEhhbmRsZVtdIHtcbiAgICByZXR1cm4gREVGQVVMVF9FRElUX0hBTkRMRVM7XG4gIH1cblxuICBnZXRDdXJzb3JBZGFwdGVyKHsgaXNEcmFnZ2luZyB9OiB7IGlzRHJhZ2dpbmc6IGJvb2xlYW4gfSk6IHN0cmluZyB7XG4gICAgcmV0dXJuICdjZWxsJztcbiAgfVxuXG4gIGlzU2VsZWN0aW9uUGlja2VkKHBpY2tzOiBQaWNrW10pOiBib29sZWFuIHtcbiAgICBpZiAoIXBpY2tzLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IHBpY2tlZEluZGV4ZXMgPSBwaWNrcy5tYXAoKHsgaW5kZXggfSkgPT4gaW5kZXgpO1xuICAgIGNvbnN0IHNlbGVjdGVkRmVhdHVyZUluZGV4ZXMgPSB0aGlzLmdldFNlbGVjdGVkRmVhdHVyZUluZGV4ZXMoKTtcbiAgICByZXR1cm4gc2VsZWN0ZWRGZWF0dXJlSW5kZXhlcy5zb21lKGluZGV4ID0+IHBpY2tlZEluZGV4ZXMuaW5jbHVkZXMoaW5kZXgpKTtcbiAgfVxuXG4gIGdldEFkZEZlYXR1cmVBY3Rpb24oZ2VvbWV0cnk6IEdlb21ldHJ5KTogR2VvSnNvbkVkaXRBY3Rpb24ge1xuICAgIC8vIFVuc3VyZSB3aHkgZmxvdyBjYW4ndCBkZWFsIHdpdGggR2VvbWV0cnkgdHlwZSwgYnV0IHRoZXJlIEkgZml4ZWQgaXRcbiAgICBjb25zdCBnZW9tZXRyeUFzQW55OiBhbnkgPSBnZW9tZXRyeTtcblxuICAgIGNvbnN0IHVwZGF0ZWREYXRhID0gdGhpcy5nZXRJbW11dGFibGVGZWF0dXJlQ29sbGVjdGlvbigpXG4gICAgICAuYWRkRmVhdHVyZSh7XG4gICAgICAgIHR5cGU6ICdGZWF0dXJlJyxcbiAgICAgICAgcHJvcGVydGllczoge30sXG4gICAgICAgIGdlb21ldHJ5OiBnZW9tZXRyeUFzQW55XG4gICAgICB9KVxuICAgICAgLmdldE9iamVjdCgpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHVwZGF0ZWREYXRhLFxuICAgICAgZWRpdFR5cGU6ICdhZGRGZWF0dXJlJyxcbiAgICAgIGVkaXRDb250ZXh0OiB7XG4gICAgICAgIGZlYXR1cmVJbmRleGVzOiBbdXBkYXRlZERhdGEuZmVhdHVyZXMubGVuZ3RoIC0gMV1cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgZ2V0QWRkTWFueUZlYXR1cmVzQWN0aW9uKGZlYXR1cmVDb2xsZWN0aW9uOiBGZWF0dXJlQ29sbGVjdGlvbik6IEdlb0pzb25FZGl0QWN0aW9uIHtcbiAgICBjb25zdCBmZWF0dXJlcyA9IGZlYXR1cmVDb2xsZWN0aW9uLmZlYXR1cmVzO1xuICAgIGxldCB1cGRhdGVkRGF0YSA9IHRoaXMuZ2V0SW1tdXRhYmxlRmVhdHVyZUNvbGxlY3Rpb24oKTtcbiAgICBjb25zdCBpbml0aWFsSW5kZXggPSB1cGRhdGVkRGF0YS5nZXRPYmplY3QoKS5mZWF0dXJlcy5sZW5ndGg7XG4gICAgY29uc3QgdXBkYXRlZEluZGV4ZXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGZlYXR1cmUgb2YgZmVhdHVyZXMpIHtcbiAgICAgIGNvbnN0IHsgcHJvcGVydGllcywgZ2VvbWV0cnkgfSA9IGZlYXR1cmU7XG4gICAgICBjb25zdCBnZW9tZXRyeUFzQW55OiBhbnkgPSBnZW9tZXRyeTtcbiAgICAgIHVwZGF0ZWREYXRhID0gdXBkYXRlZERhdGEuYWRkRmVhdHVyZSh7XG4gICAgICAgIHR5cGU6ICdGZWF0dXJlJyxcbiAgICAgICAgcHJvcGVydGllcyxcbiAgICAgICAgZ2VvbWV0cnk6IGdlb21ldHJ5QXNBbnlcbiAgICAgIH0pO1xuICAgICAgdXBkYXRlZEluZGV4ZXMucHVzaChpbml0aWFsSW5kZXggKyB1cGRhdGVkSW5kZXhlcy5sZW5ndGgpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB1cGRhdGVkRGF0YTogdXBkYXRlZERhdGEuZ2V0T2JqZWN0KCksXG4gICAgICBlZGl0VHlwZTogJ2FkZEZlYXR1cmUnLFxuICAgICAgZWRpdENvbnRleHQ6IHtcbiAgICAgICAgZmVhdHVyZUluZGV4ZXM6IHVwZGF0ZWRJbmRleGVzXG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIGdldEFkZEZlYXR1cmVPckJvb2xlYW5Qb2x5Z29uQWN0aW9uKGdlb21ldHJ5OiBQb2x5Z29uKTogP0dlb0pzb25FZGl0QWN0aW9uIHtcbiAgICBjb25zdCBzZWxlY3RlZEZlYXR1cmUgPSB0aGlzLmdldFNlbGVjdGVkRmVhdHVyZSgpO1xuICAgIGNvbnN0IG1vZGVDb25maWcgPSB0aGlzLmdldE1vZGVDb25maWcoKTtcbiAgICBpZiAobW9kZUNvbmZpZyAmJiBtb2RlQ29uZmlnLmJvb2xlYW5PcGVyYXRpb24pIHtcbiAgICAgIGlmIChcbiAgICAgICAgIXNlbGVjdGVkRmVhdHVyZSB8fFxuICAgICAgICAoc2VsZWN0ZWRGZWF0dXJlLmdlb21ldHJ5LnR5cGUgIT09ICdQb2x5Z29uJyAmJlxuICAgICAgICAgIHNlbGVjdGVkRmVhdHVyZS5nZW9tZXRyeS50eXBlICE9PSAnTXVsdGlQb2x5Z29uJylcbiAgICAgICkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZSxuby11bmRlZlxuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgJ2Jvb2xlYW5PcGVyYXRpb24gb25seSBzdXBwb3J0ZWQgZm9yIHNpbmdsZSBQb2x5Z29uIG9yIE11bHRpUG9seWdvbiBzZWxlY3Rpb24nXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBmZWF0dXJlID0ge1xuICAgICAgICB0eXBlOiAnRmVhdHVyZScsXG4gICAgICAgIGdlb21ldHJ5XG4gICAgICB9O1xuXG4gICAgICBsZXQgdXBkYXRlZEdlb21ldHJ5O1xuICAgICAgaWYgKG1vZGVDb25maWcuYm9vbGVhbk9wZXJhdGlvbiA9PT0gJ3VuaW9uJykge1xuICAgICAgICB1cGRhdGVkR2VvbWV0cnkgPSB0dXJmVW5pb24oc2VsZWN0ZWRGZWF0dXJlLCBmZWF0dXJlKTtcbiAgICAgIH0gZWxzZSBpZiAobW9kZUNvbmZpZy5ib29sZWFuT3BlcmF0aW9uID09PSAnZGlmZmVyZW5jZScpIHtcbiAgICAgICAgdXBkYXRlZEdlb21ldHJ5ID0gdHVyZkRpZmZlcmVuY2Uoc2VsZWN0ZWRGZWF0dXJlLCBmZWF0dXJlKTtcbiAgICAgIH0gZWxzZSBpZiAobW9kZUNvbmZpZy5ib29sZWFuT3BlcmF0aW9uID09PSAnaW50ZXJzZWN0aW9uJykge1xuICAgICAgICB1cGRhdGVkR2VvbWV0cnkgPSB0dXJmSW50ZXJzZWN0KHNlbGVjdGVkRmVhdHVyZSwgZmVhdHVyZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZSxuby11bmRlZlxuICAgICAgICBjb25zb2xlLndhcm4oYEludmFsaWQgYm9vbGVhbk9wZXJhdGlvbiAke21vZGVDb25maWcuYm9vbGVhbk9wZXJhdGlvbn1gKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmICghdXBkYXRlZEdlb21ldHJ5KSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlLG5vLXVuZGVmXG4gICAgICAgIGNvbnNvbGUud2FybignQ2FuY2VsaW5nIGVkaXQuIEJvb2xlYW4gb3BlcmF0aW9uIGVyYXNlZCBlbnRpcmUgcG9seWdvbi4nKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGZlYXR1cmVJbmRleCA9IHRoaXMuZ2V0U2VsZWN0ZWRGZWF0dXJlSW5kZXhlcygpWzBdO1xuXG4gICAgICBjb25zdCB1cGRhdGVkRGF0YSA9IHRoaXMuZ2V0SW1tdXRhYmxlRmVhdHVyZUNvbGxlY3Rpb24oKVxuICAgICAgICAucmVwbGFjZUdlb21ldHJ5KGZlYXR1cmVJbmRleCwgdXBkYXRlZEdlb21ldHJ5Lmdlb21ldHJ5KVxuICAgICAgICAuZ2V0T2JqZWN0KCk7XG5cbiAgICAgIGNvbnN0IGVkaXRBY3Rpb246IEdlb0pzb25FZGl0QWN0aW9uID0ge1xuICAgICAgICB1cGRhdGVkRGF0YSxcbiAgICAgICAgZWRpdFR5cGU6ICd1bmlvbkdlb21ldHJ5JyxcbiAgICAgICAgZWRpdENvbnRleHQ6IHtcbiAgICAgICAgICBmZWF0dXJlSW5kZXhlczogW2ZlYXR1cmVJbmRleF1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgcmV0dXJuIGVkaXRBY3Rpb247XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdldEFkZEZlYXR1cmVBY3Rpb24oZ2VvbWV0cnkpO1xuICB9XG5cbiAgaGFuZGxlQ2xpY2soZXZlbnQ6IENsaWNrRXZlbnQpOiB2b2lkIHtcbiAgICBjb25zdCBlZGl0QWN0aW9uID0gdGhpcy5oYW5kbGVDbGlja0FkYXB0ZXIoZXZlbnQpO1xuXG4gICAgdGhpcy5fcmVmcmVzaEVkaXRIYW5kbGVzKGV2ZW50LnBpY2tzLCBldmVudC5tYXBDb29yZHMpO1xuICAgIGlmIChlZGl0QWN0aW9uKSB7XG4gICAgICB0aGlzLm9uRWRpdChlZGl0QWN0aW9uKTtcbiAgICB9XG4gIH1cblxuICBoYW5kbGVQb2ludGVyTW92ZShldmVudDogUG9pbnRlck1vdmVFdmVudCk6IHZvaWQge1xuICAgIGNvbnN0IHsgZWRpdEFjdGlvbiwgY2FuY2VsTWFwUGFuIH0gPSB0aGlzLmhhbmRsZVBvaW50ZXJNb3ZlQWRhcHRlcihldmVudCk7XG5cbiAgICBpZiAoY2FuY2VsTWFwUGFuKSB7XG4gICAgICAvLyBUT0RPOiBpcyB0aGVyZSBhIGxlc3MgaGFja3kgd2F5IHRvIHByZXZlbnQgbWFwIHBhbm5pbmc/XG4gICAgICAvLyBTdG9wIHByb3BhZ2F0aW9uIHRvIHByZXZlbnQgbWFwIHBhbm5pbmcgd2hpbGUgZHJhZ2dpbmcgYW4gZWRpdCBoYW5kbGVcbiAgICAgIGV2ZW50LnNvdXJjZUV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH1cblxuICAgIHRoaXMuX3JlZnJlc2hDdXJzb3IoKTtcbiAgICB0aGlzLl9yZWZyZXNoRWRpdEhhbmRsZXMoZXZlbnQucGlja3MsIGV2ZW50Lm1hcENvb3Jkcyk7XG4gICAgaWYgKGVkaXRBY3Rpb24pIHtcbiAgICAgIHRoaXMub25FZGl0KGVkaXRBY3Rpb24pO1xuICAgIH1cbiAgfVxuXG4gIGhhbmRsZVN0YXJ0RHJhZ2dpbmcoZXZlbnQ6IFN0YXJ0RHJhZ2dpbmdFdmVudCk6IHZvaWQge1xuICAgIGNvbnN0IGVkaXRBY3Rpb24gPSB0aGlzLmhhbmRsZVN0YXJ0RHJhZ2dpbmdBZGFwdGVyKGV2ZW50KTtcblxuICAgIHRoaXMuX3JlZnJlc2hFZGl0SGFuZGxlcyhldmVudC5waWNrcywgZXZlbnQubWFwQ29vcmRzKTtcbiAgICBpZiAoZWRpdEFjdGlvbikge1xuICAgICAgdGhpcy5vbkVkaXQoZWRpdEFjdGlvbik7XG4gICAgfVxuICB9XG5cbiAgaGFuZGxlU3RvcERyYWdnaW5nKGV2ZW50OiBTdG9wRHJhZ2dpbmdFdmVudCk6IHZvaWQge1xuICAgIGNvbnN0IGVkaXRBY3Rpb24gPSB0aGlzLmhhbmRsZVN0b3BEcmFnZ2luZ0FkYXB0ZXIoZXZlbnQpO1xuXG4gICAgdGhpcy5fcmVmcmVzaEVkaXRIYW5kbGVzKGV2ZW50LnBpY2tzLCBldmVudC5tYXBDb29yZHMpO1xuICAgIGlmIChlZGl0QWN0aW9uKSB7XG4gICAgICB0aGlzLm9uRWRpdChlZGl0QWN0aW9uKTtcbiAgICB9XG4gIH1cblxuICAvLyBUT0RPOiBkZWxldGUgdGhlc2UgYWRhcHRlcnMgb25jZSBhbGwgTW9kZUhhbmRsZXIgaW1wbGVtZW50YXRpb25zIGRvbid0IHVzZSB0aGVtXG4gIGhhbmRsZUNsaWNrQWRhcHRlcihldmVudDogQ2xpY2tFdmVudCk6ID9HZW9Kc29uRWRpdEFjdGlvbiB7XG4gICAgdGhpcy5fY2xpY2tTZXF1ZW5jZS5wdXNoKGV2ZW50Lm1hcENvb3Jkcyk7XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGhhbmRsZVBvaW50ZXJNb3ZlQWRhcHRlcihcbiAgICBldmVudDogUG9pbnRlck1vdmVFdmVudFxuICApOiB7IGVkaXRBY3Rpb246ID9HZW9Kc29uRWRpdEFjdGlvbiwgY2FuY2VsTWFwUGFuOiBib29sZWFuIH0ge1xuICAgIHJldHVybiB7IGVkaXRBY3Rpb246IG51bGwsIGNhbmNlbE1hcFBhbjogZmFsc2UgfTtcbiAgfVxuXG4gIGhhbmRsZVN0YXJ0RHJhZ2dpbmdBZGFwdGVyKGV2ZW50OiBTdGFydERyYWdnaW5nRXZlbnQpOiA/R2VvSnNvbkVkaXRBY3Rpb24ge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaGFuZGxlU3RvcERyYWdnaW5nQWRhcHRlcihldmVudDogU3RvcERyYWdnaW5nRXZlbnQpOiA/R2VvSnNvbkVkaXRBY3Rpb24ge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRQaWNrZWRFZGl0SGFuZGxlKHBpY2tzOiA/KGFueVtdKSk6ID9FZGl0SGFuZGxlIHtcbiAgY29uc3QgaW5mbyA9IHBpY2tzICYmIHBpY2tzLmZpbmQocGljayA9PiBwaWNrLmlzR3VpZGUpO1xuICBpZiAoaW5mbykge1xuICAgIHJldHVybiBpbmZvLm9iamVjdDtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEludGVybWVkaWF0ZVBvc2l0aW9uKHBvc2l0aW9uMTogUG9zaXRpb24sIHBvc2l0aW9uMjogUG9zaXRpb24pOiBQb3NpdGlvbiB7XG4gIGNvbnN0IGludGVybWVkaWF0ZVBvc2l0aW9uID0gW1xuICAgIChwb3NpdGlvbjFbMF0gKyBwb3NpdGlvbjJbMF0pIC8gMi4wLFxuICAgIChwb3NpdGlvbjFbMV0gKyBwb3NpdGlvbjJbMV0pIC8gMi4wXG4gIF07XG4gIHJldHVybiBpbnRlcm1lZGlhdGVQb3NpdGlvbjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEVkaXRIYW5kbGVzRm9yR2VvbWV0cnkoXG4gIGdlb21ldHJ5OiBHZW9tZXRyeSxcbiAgZmVhdHVyZUluZGV4OiBudW1iZXIsXG4gIGVkaXRIYW5kbGVUeXBlOiBFZGl0SGFuZGxlVHlwZSA9ICdleGlzdGluZydcbikge1xuICBsZXQgaGFuZGxlczogRWRpdEhhbmRsZVtdID0gW107XG5cbiAgc3dpdGNoIChnZW9tZXRyeS50eXBlKSB7XG4gICAgY2FzZSAnUG9pbnQnOlxuICAgICAgLy8gcG9zaXRpb25zIGFyZSBub3QgbmVzdGVkXG4gICAgICBoYW5kbGVzID0gW1xuICAgICAgICB7XG4gICAgICAgICAgcG9zaXRpb246IGdlb21ldHJ5LmNvb3JkaW5hdGVzLFxuICAgICAgICAgIHBvc2l0aW9uSW5kZXhlczogW10sXG4gICAgICAgICAgZmVhdHVyZUluZGV4LFxuICAgICAgICAgIHR5cGU6IGVkaXRIYW5kbGVUeXBlXG4gICAgICAgIH1cbiAgICAgIF07XG4gICAgICBicmVhaztcbiAgICBjYXNlICdNdWx0aVBvaW50JzpcbiAgICBjYXNlICdMaW5lU3RyaW5nJzpcbiAgICAgIC8vIHBvc2l0aW9ucyBhcmUgbmVzdGVkIDEgbGV2ZWxcbiAgICAgIGhhbmRsZXMgPSBoYW5kbGVzLmNvbmNhdChcbiAgICAgICAgZ2V0RWRpdEhhbmRsZXNGb3JDb29yZGluYXRlcyhnZW9tZXRyeS5jb29yZGluYXRlcywgW10sIGZlYXR1cmVJbmRleCwgZWRpdEhhbmRsZVR5cGUpXG4gICAgICApO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnUG9seWdvbic6XG4gICAgY2FzZSAnTXVsdGlMaW5lU3RyaW5nJzpcbiAgICAgIC8vIHBvc2l0aW9ucyBhcmUgbmVzdGVkIDIgbGV2ZWxzXG4gICAgICBmb3IgKGxldCBhID0gMDsgYSA8IGdlb21ldHJ5LmNvb3JkaW5hdGVzLmxlbmd0aDsgYSsrKSB7XG4gICAgICAgIGhhbmRsZXMgPSBoYW5kbGVzLmNvbmNhdChcbiAgICAgICAgICBnZXRFZGl0SGFuZGxlc0ZvckNvb3JkaW5hdGVzKGdlb21ldHJ5LmNvb3JkaW5hdGVzW2FdLCBbYV0sIGZlYXR1cmVJbmRleCwgZWRpdEhhbmRsZVR5cGUpXG4gICAgICAgICk7XG4gICAgICAgIGlmIChnZW9tZXRyeS50eXBlID09PSAnUG9seWdvbicpIHtcbiAgICAgICAgICAvLyBEb24ndCByZXBlYXQgdGhlIGZpcnN0L2xhc3QgaGFuZGxlIGZvciBQb2x5Z29uc1xuICAgICAgICAgIGhhbmRsZXMgPSBoYW5kbGVzLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnTXVsdGlQb2x5Z29uJzpcbiAgICAgIC8vIHBvc2l0aW9ucyBhcmUgbmVzdGVkIDMgbGV2ZWxzXG4gICAgICBmb3IgKGxldCBhID0gMDsgYSA8IGdlb21ldHJ5LmNvb3JkaW5hdGVzLmxlbmd0aDsgYSsrKSB7XG4gICAgICAgIGZvciAobGV0IGIgPSAwOyBiIDwgZ2VvbWV0cnkuY29vcmRpbmF0ZXNbYV0ubGVuZ3RoOyBiKyspIHtcbiAgICAgICAgICBoYW5kbGVzID0gaGFuZGxlcy5jb25jYXQoXG4gICAgICAgICAgICBnZXRFZGl0SGFuZGxlc0ZvckNvb3JkaW5hdGVzKFxuICAgICAgICAgICAgICBnZW9tZXRyeS5jb29yZGluYXRlc1thXVtiXSxcbiAgICAgICAgICAgICAgW2EsIGJdLFxuICAgICAgICAgICAgICBmZWF0dXJlSW5kZXgsXG4gICAgICAgICAgICAgIGVkaXRIYW5kbGVUeXBlXG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcbiAgICAgICAgICAvLyBEb24ndCByZXBlYXQgdGhlIGZpcnN0L2xhc3QgaGFuZGxlIGZvciBQb2x5Z29uc1xuICAgICAgICAgIGhhbmRsZXMgPSBoYW5kbGVzLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IEVycm9yKGBVbmhhbmRsZWQgZ2VvbWV0cnkgdHlwZTogJHtnZW9tZXRyeS50eXBlfWApO1xuICB9XG5cbiAgcmV0dXJuIGhhbmRsZXM7XG59XG5cbmZ1bmN0aW9uIGdldEVkaXRIYW5kbGVzRm9yQ29vcmRpbmF0ZXMoXG4gIGNvb3JkaW5hdGVzOiBhbnlbXSxcbiAgcG9zaXRpb25JbmRleFByZWZpeDogbnVtYmVyW10sXG4gIGZlYXR1cmVJbmRleDogbnVtYmVyLFxuICBlZGl0SGFuZGxlVHlwZTogRWRpdEhhbmRsZVR5cGUgPSAnZXhpc3RpbmcnXG4pOiBFZGl0SGFuZGxlW10ge1xuICBjb25zdCBlZGl0SGFuZGxlcyA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGNvb3JkaW5hdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgcG9zaXRpb24gPSBjb29yZGluYXRlc1tpXTtcbiAgICBlZGl0SGFuZGxlcy5wdXNoKHtcbiAgICAgIHBvc2l0aW9uLFxuICAgICAgcG9zaXRpb25JbmRleGVzOiBbLi4ucG9zaXRpb25JbmRleFByZWZpeCwgaV0sXG4gICAgICBmZWF0dXJlSW5kZXgsXG4gICAgICB0eXBlOiBlZGl0SGFuZGxlVHlwZVxuICAgIH0pO1xuICB9XG4gIHJldHVybiBlZGl0SGFuZGxlcztcbn1cbiJdfQ==